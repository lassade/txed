//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (19)
//--------------------------------------------------------------------------------
pub const EVCF_HASSETTINGS = @as(u32, 1);
pub const EVCF_ENABLEBYDEFAULT = @as(u32, 2);
pub const EVCF_REMOVEFROMLIST = @as(u32, 4);
pub const EVCF_ENABLEBYDEFAULT_AUTO = @as(u32, 8);
pub const EVCF_DONTSHOWIFZERO = @as(u32, 16);
pub const EVCF_SETTINGSMODE = @as(u32, 32);
pub const EVCF_OUTOFDISKSPACE = @as(u32, 64);
pub const EVCF_USERCONSENTOBTAINED = @as(u32, 128);
pub const EVCF_SYSTEMAUTORUN = @as(u32, 256);
pub const EVCCBF_LASTNOTIFICATION = @as(u32, 1);
pub const STATEBITS_FLAT = @as(u32, 1);
pub const REC_S_IDIDTHEUPDATES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266240));
pub const REC_S_NOTCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266241));
pub const REC_S_NOTCOMPLETEBUTPROPAGATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266242));
pub const REC_E_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const REC_E_NOCALLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const REC_E_NORESIDUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const REC_E_TOODIFFERENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217405));
pub const REC_E_INEEDTODOTHEUPDATES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217404));

//--------------------------------------------------------------------------------
// Section: Types (9)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCacheCallBack_Value = Guid.initString("6e793361-73c6-11d0-8469-00aa00442901");
pub const IID_IEmptyVolumeCacheCallBack = &IID_IEmptyVolumeCacheCallBack_Value;
pub const IEmptyVolumeCacheCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScanProgress: *const fn (
            self: *const IEmptyVolumeCacheCallBack,
            dwl_space_used: u64,
            dw_flags: u32,
            pcwsz_status: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PurgeProgress: *const fn (
            self: *const IEmptyVolumeCacheCallBack,
            dwl_space_freed: u64,
            dwl_space_to_free: u64,
            dw_flags: u32,
            pcwsz_status: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn scanProgress(self: *const T, dwl_space_used_: u64, dw_flags_: u32, pcwsz_status_: ?[*:0]const u16) HRESULT {
                return @as(*const IEmptyVolumeCacheCallBack.VTable, @ptrCast(self.vtable)).ScanProgress(@as(*const IEmptyVolumeCacheCallBack, @ptrCast(self)), dwl_space_used_, dw_flags_, pcwsz_status_);
            }
            pub inline fn purgeProgress(self: *const T, dwl_space_freed_: u64, dwl_space_to_free_: u64, dw_flags_: u32, pcwsz_status_: ?[*:0]const u16) HRESULT {
                return @as(*const IEmptyVolumeCacheCallBack.VTable, @ptrCast(self.vtable)).PurgeProgress(@as(*const IEmptyVolumeCacheCallBack, @ptrCast(self)), dwl_space_freed_, dwl_space_to_free_, dw_flags_, pcwsz_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCache_Value = Guid.initString("8fce5227-04da-11d1-a004-00805f8abe06");
pub const IID_IEmptyVolumeCache = &IID_IEmptyVolumeCache_Value;
pub const IEmptyVolumeCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IEmptyVolumeCache,
            hk_reg_key: ?HKEY,
            pcwsz_volume: ?[*:0]const u16,
            ppwsz_display_name: ?*?PWSTR,
            ppwsz_description: ?*?PWSTR,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceUsed: *const fn (
            self: *const IEmptyVolumeCache,
            pdwl_space_used: ?*u64,
            picb: ?*IEmptyVolumeCacheCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Purge: *const fn (
            self: *const IEmptyVolumeCache,
            dwl_space_to_free: u64,
            picb: ?*IEmptyVolumeCacheCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProperties: *const fn (
            self: *const IEmptyVolumeCache,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: *const fn (
            self: *const IEmptyVolumeCache,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, hk_reg_key_: ?HKEY, pcwsz_volume_: ?[*:0]const u16, ppwsz_display_name_: ?*?PWSTR, ppwsz_description_: ?*?PWSTR, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IEmptyVolumeCache, @ptrCast(self)), hk_reg_key_, pcwsz_volume_, ppwsz_display_name_, ppwsz_description_, pdw_flags_);
            }
            pub inline fn getSpaceUsed(self: *const T, pdwl_space_used_: ?*u64, picb_: ?*IEmptyVolumeCacheCallBack) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).GetSpaceUsed(@as(*const IEmptyVolumeCache, @ptrCast(self)), pdwl_space_used_, picb_);
            }
            pub inline fn purge(self: *const T, dwl_space_to_free_: u64, picb_: ?*IEmptyVolumeCacheCallBack) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Purge(@as(*const IEmptyVolumeCache, @ptrCast(self)), dwl_space_to_free_, picb_);
            }
            pub inline fn showProperties(self: *const T, hwnd_: ?HWND) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).ShowProperties(@as(*const IEmptyVolumeCache, @ptrCast(self)), hwnd_);
            }
            pub inline fn deactivate(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const IEmptyVolumeCache, @ptrCast(self)), pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCache2_Value = Guid.initString("02b7e3ba-4db3-11d2-b2d9-00c04f8eec8c");
pub const IID_IEmptyVolumeCache2 = &IID_IEmptyVolumeCache2_Value;
pub const IEmptyVolumeCache2 = extern struct {
    pub const VTable = extern struct {
        base: IEmptyVolumeCache.VTable,
        InitializeEx: *const fn (
            self: *const IEmptyVolumeCache2,
            hk_reg_key: ?HKEY,
            pcwsz_volume: ?[*:0]const u16,
            pcwsz_key_name: ?[*:0]const u16,
            ppwsz_display_name: ?*?PWSTR,
            ppwsz_description: ?*?PWSTR,
            ppwsz_btn_text: ?*?PWSTR,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEmptyVolumeCache.MethodMixin(T);
            pub inline fn initializeEx(self: *const T, hk_reg_key_: ?HKEY, pcwsz_volume_: ?[*:0]const u16, pcwsz_key_name_: ?[*:0]const u16, ppwsz_display_name_: ?*?PWSTR, ppwsz_description_: ?*?PWSTR, ppwsz_btn_text_: ?*?PWSTR, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache2.VTable, @ptrCast(self.vtable)).InitializeEx(@as(*const IEmptyVolumeCache2, @ptrCast(self)), hk_reg_key_, pcwsz_volume_, pcwsz_key_name_, ppwsz_display_name_, ppwsz_description_, ppwsz_btn_text_, pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IReconcileInitiator_Value = Guid.initString("99180161-da16-101a-935c-444553540000");
pub const IID_IReconcileInitiator = &IID_IReconcileInitiator_Value;
pub const IReconcileInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAbortCallback: *const fn (
            self: *const IReconcileInitiator,
            punk_for_abort: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressFeedback: *const fn (
            self: *const IReconcileInitiator,
            ul_progress: u32,
            ul_progress_max: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAbortCallback(self: *const T, punk_for_abort_: ?*IUnknown) HRESULT {
                return @as(*const IReconcileInitiator.VTable, @ptrCast(self.vtable)).SetAbortCallback(@as(*const IReconcileInitiator, @ptrCast(self)), punk_for_abort_);
            }
            pub inline fn setProgressFeedback(self: *const T, ul_progress_: u32, ul_progress_max_: u32) HRESULT {
                return @as(*const IReconcileInitiator.VTable, @ptrCast(self.vtable)).SetProgressFeedback(@as(*const IReconcileInitiator, @ptrCast(self)), ul_progress_, ul_progress_max_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _reconcilef = enum(i32) {
    RECONCILEF_MAYBOTHERUSER = 1,
    RECONCILEF_FEEDBACKWINDOWVALID = 2,
    RECONCILEF_NORESIDUESOK = 4,
    RECONCILEF_OMITSELFRESIDUE = 8,
    RECONCILEF_RESUMERECONCILIATION = 16,
    RECONCILEF_YOUMAYDOTHEUPDATES = 32,
    RECONCILEF_ONLYYOUWERECHANGED = 64,
    ALL_RECONCILE_FLAGS = 127,
};
pub const RECONCILEF_MAYBOTHERUSER = _reconcilef.RECONCILEF_MAYBOTHERUSER;
pub const RECONCILEF_FEEDBACKWINDOWVALID = _reconcilef.RECONCILEF_FEEDBACKWINDOWVALID;
pub const RECONCILEF_NORESIDUESOK = _reconcilef.RECONCILEF_NORESIDUESOK;
pub const RECONCILEF_OMITSELFRESIDUE = _reconcilef.RECONCILEF_OMITSELFRESIDUE;
pub const RECONCILEF_RESUMERECONCILIATION = _reconcilef.RECONCILEF_RESUMERECONCILIATION;
pub const RECONCILEF_YOUMAYDOTHEUPDATES = _reconcilef.RECONCILEF_YOUMAYDOTHEUPDATES;
pub const RECONCILEF_ONLYYOUWERECHANGED = _reconcilef.RECONCILEF_ONLYYOUWERECHANGED;
pub const ALL_RECONCILE_FLAGS = _reconcilef.ALL_RECONCILE_FLAGS;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IReconcilableObject_Value = Guid.initString("99180162-da16-101a-935c-444553540000");
pub const IID_IReconcilableObject = &IID_IReconcilableObject_Value;
pub const IReconcilableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconcile: *const fn (
            self: *const IReconcilableObject,
            p_initiator: ?*IReconcileInitiator,
            dw_flags: u32,
            hwnd_owner: ?HWND,
            hwnd_progress_feedback: ?HWND,
            ulc_input: u32,
            rgpmk_other_input: [*]?*IMoniker,
            pl_out_index: ?*i32,
            pstg_new_residues: ?*IStorage,
            pv_reserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgressFeedbackMaxEstimate: *const fn (
            self: *const IReconcilableObject,
            pul_progress_max: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reconcile(self: *const T, p_initiator_: ?*IReconcileInitiator, dw_flags_: u32, hwnd_owner_: ?HWND, hwnd_progress_feedback_: ?HWND, ulc_input_: u32, rgpmk_other_input_: [*]?*IMoniker, pl_out_index_: ?*i32, pstg_new_residues_: ?*IStorage, pv_reserved_: ?*anyopaque) HRESULT {
                return @as(*const IReconcilableObject.VTable, @ptrCast(self.vtable)).Reconcile(@as(*const IReconcilableObject, @ptrCast(self)), p_initiator_, dw_flags_, hwnd_owner_, hwnd_progress_feedback_, ulc_input_, rgpmk_other_input_, pl_out_index_, pstg_new_residues_, pv_reserved_);
            }
            pub inline fn getProgressFeedbackMaxEstimate(self: *const T, pul_progress_max_: ?*u32) HRESULT {
                return @as(*const IReconcilableObject.VTable, @ptrCast(self.vtable)).GetProgressFeedbackMaxEstimate(@as(*const IReconcilableObject, @ptrCast(self)), pul_progress_max_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBriefcaseInitiator_Value = Guid.initString("99180164-da16-101a-935c-444553540000");
pub const IID_IBriefcaseInitiator = &IID_IBriefcaseInitiator_Value;
pub const IBriefcaseInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMonikerInBriefcase: *const fn (
            self: *const IBriefcaseInitiator,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isMonikerInBriefcase(self: *const T, pmk_: ?*IMoniker) HRESULT {
                return @as(*const IBriefcaseInitiator.VTable, @ptrCast(self.vtable)).IsMonikerInBriefcase(@as(*const IBriefcaseInitiator, @ptrCast(self)), pmk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IActiveDesktopP_Value = Guid.initString("52502ee0-ec80-11d0-89ab-00c04fc2972d");
pub const IID_IActiveDesktopP = &IID_IActiveDesktopP_Value;
pub const IActiveDesktopP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSafeMode: *const fn (
            self: *const IActiveDesktopP,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnsureUpdateHTML: *const fn (
            self: *const IActiveDesktopP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScheme: *const fn (
            self: *const IActiveDesktopP,
            pwsz_scheme_name: ?[*:0]const u16,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheme: *const fn (
            self: *const IActiveDesktopP,
            pwsz_scheme_name: [*:0]u16,
            pdwcch_buffer: ?*u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setSafeMode(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).SetSafeMode(@as(*const IActiveDesktopP, @ptrCast(self)), dw_flags_);
            }
            pub inline fn ensureUpdateHTML(self: *const T) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).EnsureUpdateHTML(@as(*const IActiveDesktopP, @ptrCast(self)));
            }
            pub inline fn setScheme(self: *const T, pwsz_scheme_name_: ?[*:0]const u16, dw_flags_: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).SetScheme(@as(*const IActiveDesktopP, @ptrCast(self)), pwsz_scheme_name_, dw_flags_);
            }
            pub inline fn getScheme(self: *const T, pwsz_scheme_name_: [*:0]u16, pdwcch_buffer_: ?*u32, dw_flags_: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).GetScheme(@as(*const IActiveDesktopP, @ptrCast(self)), pwsz_scheme_name_, pdwcch_buffer_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IADesktopP2_Value = Guid.initString("b22754e2-4574-11d1-9888-006097deacf9");
pub const IID_IADesktopP2 = &IID_IADesktopP2_Value;
pub const IADesktopP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReReadWallpaper: *const fn (
            self: *const IADesktopP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetADObjectFlags: *const fn (
            self: *const IADesktopP2,
            pdw_flags: ?*u32,
            dw_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAllDesktopSubscriptions: *const fn (
            self: *const IADesktopP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeDynamicChanges: *const fn (
            self: *const IADesktopP2,
            p_ole_obj: ?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reReadWallpaper(self: *const T) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).ReReadWallpaper(@as(*const IADesktopP2, @ptrCast(self)));
            }
            pub inline fn getADObjectFlags(self: *const T, pdw_flags_: ?*u32, dw_mask_: u32) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).GetADObjectFlags(@as(*const IADesktopP2, @ptrCast(self)), pdw_flags_, dw_mask_);
            }
            pub inline fn updateAllDesktopSubscriptions(self: *const T) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).UpdateAllDesktopSubscriptions(@as(*const IADesktopP2, @ptrCast(self)));
            }
            pub inline fn makeDynamicChanges(self: *const T, p_ole_obj_: ?*IOleObject) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).MakeDynamicChanges(@as(*const IADesktopP2, @ptrCast(self)), p_ole_obj_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMoniker = @import("../system/com.zig").IMoniker;
const IOleObject = @import("../system/ole.zig").IOleObject;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
