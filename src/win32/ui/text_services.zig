//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (439)
//--------------------------------------------------------------------------------
pub const GUID_PROP_TEXTOWNER = Guid.initString("f1e2d520-0969-11d3-8df0-00105a2799b5");
pub const GUID_PROP_ATTRIBUTE = Guid.initString("34b45670-7526-11d2-a147-00105a2799b5");
pub const GUID_PROP_LANGID = Guid.initString("3280ce20-8032-11d2-b603-00105a2799b5");
pub const GUID_PROP_READING = Guid.initString("5463f7c0-8e31-11d2-bf46-00105a2799b5");
pub const GUID_PROP_COMPOSING = Guid.initString("e12ac060-af15-11d2-afc5-00105a2799b5");
pub const GUID_PROP_TKB_ALTERNATES = Guid.initString("70b2a803-968d-462e-b93b-2164c91517f7");
pub const GUID_SYSTEM_FUNCTIONPROVIDER = Guid.initString("9a698bb0-0f21-11d3-8df1-00105a2799b5");
pub const GUID_APP_FUNCTIONPROVIDER = Guid.initString("4caef01e-12af-4b0e-9db1-a6ec5b881208");
pub const GUID_TFCAT_CATEGORY_OF_TIP = Guid.initString("534c48c1-0607-4098-a521-4fc899c73e90");
pub const GUID_TFCAT_TIP_KEYBOARD = Guid.initString("34745c63-b2f0-4784-8b67-5e12c8701a31");
pub const GUID_TFCAT_TIP_SPEECH = Guid.initString("b5a73cd1-8355-426b-a161-259808f26b14");
pub const GUID_TFCAT_TIP_HANDWRITING = Guid.initString("246ecb87-c2f2-4abe-905b-c8b38add2c43");
pub const GUID_TFCAT_PROP_AUDIODATA = Guid.initString("9b7be3a9-e8ab-4d47-a8fe-254fa423436d");
pub const GUID_TFCAT_PROP_INKDATA = Guid.initString("7c6a82ae-b0d7-4f14-a745-14f28b009d61");
pub const GUID_COMPARTMENT_SAPI_AUDIO = Guid.initString("51af2086-cc6b-457d-b5aa-8b19dc290ab4");
pub const GUID_COMPARTMENT_KEYBOARD_DISABLED = Guid.initString("71a5b253-1951-466b-9fbc-9c8808fa84f2");
pub const GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = Guid.initString("58273aad-01bb-4164-95c6-755ba0b5162d");
pub const GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = Guid.initString("f9ae2c6b-1866-4361-af72-7aa30948890e");
pub const GUID_COMPARTMENT_SPEECH_DISABLED = Guid.initString("56c5c607-0703-4e59-8e52-cbc84e8bbe35");
pub const GUID_COMPARTMENT_SPEECH_OPENCLOSE = Guid.initString("544d6a63-e2e8-4752-bbd1-000960bca083");
pub const GUID_COMPARTMENT_SPEECH_GLOBALSTATE = Guid.initString("2a54fe8e-0d08-460c-a75d-87035ff436c5");
pub const GUID_COMPARTMENT_CONVERSIONMODEBIAS = Guid.initString("5497f516-ee91-436e-b946-aa2c05f1ac5b");
pub const GUID_PROP_MODEBIAS = Guid.initString("372e0716-974f-40ac-a088-08cdc92ebfbc");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE = Guid.initString("b6592511-bcee-4122-a7c4-09f4b3fa4396");
pub const GUID_MODEBIAS_NONE = Guid.initString("00000000-0000-0000-0000-000000000000");
pub const GUID_MODEBIAS_URLHISTORY = Guid.initString("8b0e54d9-63f2-4c68-84d4-79aee7a59f09");
pub const GUID_MODEBIAS_FILENAME = Guid.initString("d7f707fe-44c6-4fca-8e76-86ab50c7931b");
pub const GUID_MODEBIAS_READING = Guid.initString("e31643a3-6466-4cbf-8d8b-0bd4d8545461");
pub const GUID_MODEBIAS_DATETIME = Guid.initString("f2bdb372-7f61-4039-92ef-1c35599f0222");
pub const GUID_MODEBIAS_NAME = Guid.initString("fddc10f0-d239-49bf-b8fc-5410caaa427e");
pub const GUID_MODEBIAS_CONVERSATION = Guid.initString("0f4ec104-1790-443b-95f1-e10f939d6546");
pub const GUID_MODEBIAS_NUMERIC = Guid.initString("4021766c-e872-48fd-9cee-4ec5c75e16c3");
pub const GUID_MODEBIAS_HIRAGANA = Guid.initString("d73d316e-9b91-46f1-a280-31597f52c694");
pub const GUID_MODEBIAS_KATAKANA = Guid.initString("2e0eeddd-3a1a-499e-8543-3c7ee7949811");
pub const GUID_MODEBIAS_HANGUL = Guid.initString("76ef0541-23b3-4d77-a074-691801ccea17");
pub const GUID_MODEBIAS_CHINESE = Guid.initString("7add26de-4328-489b-83ae-6493750cad5c");
pub const GUID_MODEBIAS_HALFWIDTHKATAKANA = Guid.initString("005f6b63-78d4-41cc-8859-485ca821a795");
pub const GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = Guid.initString("81489fb8-b36a-473d-8146-e4a2258b24ae");
pub const GUID_MODEBIAS_FULLWIDTHHANGUL = Guid.initString("c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea");
pub const GUID_TFCAT_PROPSTYLE_STATIC = Guid.initString("565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96");
pub const GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = Guid.initString("046b8c80-1647-40f7-9b21-b93b81aabc1b");
pub const GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = Guid.initString("b95f181b-ea4c-4af1-8056-7c321abbb091");
pub const GUID_COMPARTMENT_SPEECH_UI_STATUS = Guid.initString("d92016f0-9367-4fe7-9abf-bc59dacbe0e3");
pub const GUID_COMPARTMENT_EMPTYCONTEXT = Guid.initString("d7487dbf-804e-41c5-894d-ad96fd4eea13");
pub const GUID_COMPARTMENT_TIPUISTATUS = Guid.initString("148ca3ec-0366-401c-8d75-ed978d85fbc9");
pub const GUID_COMPARTMENT_SPEECH_CFGMENU = Guid.initString("fb6c5c2d-4e83-4bb6-91a2-e019bff6762d");
pub const GUID_LBI_SAPILAYR_CFGMENUBUTTON = Guid.initString("d02f24a1-942d-422e-8d99-b4f2addee999");
pub const GUID_TFCAT_TIPCAP_SECUREMODE = Guid.initString("49d2f9ce-1f5e-11d7-a6d3-00065b84435c");
pub const GUID_TFCAT_TIPCAP_UIELEMENTENABLED = Guid.initString("49d2f9cf-1f5e-11d7-a6d3-00065b84435c");
pub const GUID_TFCAT_TIPCAP_INPUTMODECOMPARTMENT = Guid.initString("ccf05dd7-4a87-11d7-a6e2-00065b84435c");
pub const GUID_TFCAT_TIPCAP_COMLESS = Guid.initString("364215d9-75bc-11d7-a6ef-00065b84435c");
pub const GUID_TFCAT_TIPCAP_WOW16 = Guid.initString("364215da-75bc-11d7-a6ef-00065b84435c");
pub const GUID_TFCAT_TIPCAP_IMMERSIVESUPPORT = Guid.initString("13a016df-560b-46cd-947a-4c3af1e0e35d");
pub const GUID_TFCAT_TIPCAP_IMMERSIVEONLY = Guid.initString("3a4259ac-640d-4ad4-89f7-1eb67e7c4ee8");
pub const GUID_TFCAT_TIPCAP_LOCALSERVER = Guid.initString("74769ee9-4a66-4f9d-90d6-bf8b7c3eb461");
pub const GUID_TFCAT_TIPCAP_TSF3 = Guid.initString("07dcb4af-98de-4548-bef7-25bd45979a1f");
pub const GUID_TFCAT_TIPCAP_DUALMODE = Guid.initString("3af314a2-d79f-4b1b-9992-15086d339b05");
pub const GUID_TFCAT_TIPCAP_SYSTRAYSUPPORT = Guid.initString("25504fb4-7bab-4bc1-9c69-cf81890f0ef5");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION = Guid.initString("ccf05dd8-4a87-11d7-a6e2-00065b84435c");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE_SENTENCE = Guid.initString("ccf05dd9-4a87-11d7-a6e2-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION = Guid.initString("8be347f5-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION_DOCUMENTMANAGER = Guid.initString("8be347f7-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION_PARENT = Guid.initString("8be347f8-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_ENABLED_PROFILES_UPDATED = Guid.initString("92c1fd48-a9ae-4a7c-be08-4329e4723817");
pub const GUID_TFCAT_TRANSITORYEXTENSIONUI = Guid.initString("6302de22-a5cf-4b02-bfe8-4d72b2bed3c6");
pub const GUID_LBI_INPUTMODE = Guid.initString("2c77a81e-41cc-4178-a3a7-5f8a987568e6");
pub const CLSID_TF_ThreadMgr = Guid.initString("529a9e6b-6587-4f23-ab9e-9c7d683e3c50");
pub const CLSID_TF_LangBarMgr = Guid.initString("ebb08c45-6c4a-4fdc-ae53-4eb8c4c7db8e");
pub const CLSID_TF_DisplayAttributeMgr = Guid.initString("3ce74de4-53d3-4d74-8b83-431b3828ba53");
pub const CLSID_TF_CategoryMgr = Guid.initString("a4b544a1-438d-4b41-9325-869523e2d6c7");
pub const CLSID_TF_InputProcessorProfiles = Guid.initString("33c53a50-f456-4884-b049-85fd643ecfed");
pub const CLSID_TF_LangBarItemMgr = Guid.initString("b9931692-a2b3-4fab-bf33-9ec6f9fb96ac");
pub const CLSID_TF_ClassicLangBar = Guid.initString("3318360c-1afc-4d09-a86b-9f9cb6dceb9c");
pub const CLSID_TF_TransitoryExtensionUIEntry = Guid.initString("ae6be008-07fb-400d-8beb-337a64f7051f");
pub const CLSID_TsfServices = Guid.initString("39aedc00-6b60-46db-8d31-3642be0e4373");
pub const GUID_TS_SERVICE_DATAOBJECT = Guid.initString("6086fbb5-e225-46ce-a770-c1bbd3e05d7b");
pub const GUID_TS_SERVICE_ACCESSIBLE = Guid.initString("f9786200-a5bf-4a0f-8c24-fb16f5d1aabb");
pub const GUID_TS_SERVICE_ACTIVEX = Guid.initString("ea937a50-c9a6-4b7d-894a-49d99b784834");
pub const TS_E_INVALIDPOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const TS_E_NOLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const TS_E_NOOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const TS_E_NOSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const TS_E_NOINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const TS_E_NOSELECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const TS_E_NOLAYOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const TS_E_INVALIDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const TS_E_SYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const TS_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const TS_E_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const TS_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262912));
pub const TS_AS_TEXT_CHANGE = @as(u32, 1);
pub const TS_AS_SEL_CHANGE = @as(u32, 2);
pub const TS_AS_LAYOUT_CHANGE = @as(u32, 4);
pub const TS_AS_ATTR_CHANGE = @as(u32, 8);
pub const TS_AS_STATUS_CHANGE = @as(u32, 16);
pub const TS_LF_SYNC = @as(u32, 1);
pub const TS_SD_READONLY = @as(u32, 1);
pub const TS_SD_LOADING = @as(u32, 2);
pub const TS_SD_RESERVED = @as(u32, 4);
pub const TS_SD_TKBAUTOCORRECTENABLE = @as(u32, 8);
pub const TS_SD_TKBPREDICTIONENABLE = @as(u32, 16);
pub const TS_SD_UIINTEGRATIONENABLE = @as(u32, 32);
pub const TS_SD_INPUTPANEMANUALDISPLAYENABLE = @as(u32, 64);
pub const TS_SD_EMBEDDEDHANDWRITINGVIEW_ENABLED = @as(u32, 128);
pub const TS_SD_EMBEDDEDHANDWRITINGVIEW_VISIBLE = @as(u32, 256);
pub const TS_SS_DISJOINTSEL = @as(u32, 1);
pub const TS_SS_REGIONS = @as(u32, 2);
pub const TS_SS_TRANSITORY = @as(u32, 4);
pub const TS_SS_NOHIDDENTEXT = @as(u32, 8);
pub const TS_SS_TKBAUTOCORRECTENABLE = @as(u32, 16);
pub const TS_SS_TKBPREDICTIONENABLE = @as(u32, 32);
pub const TS_SS_UWPCONTROL = @as(u32, 64);
pub const TS_IE_CORRECTION = @as(u32, 1);
pub const TS_IE_COMPOSITION = @as(u32, 2);
pub const TS_IAS_NOQUERY = @as(u32, 1);
pub const TS_IAS_QUERYONLY = @as(u32, 2);
pub const GXFPF_ROUND_NEAREST = @as(u32, 1);
pub const GXFPF_NEAREST = @as(u32, 2);
pub const TS_CHAR_EMBEDDED = @as(u32, 65532);
pub const TS_CHAR_REGION = @as(u32, 0);
pub const TS_CHAR_REPLACEMENT = @as(u32, 65533);
pub const TS_ATTR_FIND_BACKWARDS = @as(u32, 1);
pub const TS_ATTR_FIND_WANT_OFFSET = @as(u32, 2);
pub const TS_ATTR_FIND_UPDATESTART = @as(u32, 4);
pub const TS_ATTR_FIND_WANT_VALUE = @as(u32, 8);
pub const TS_ATTR_FIND_WANT_END = @as(u32, 16);
pub const TS_ATTR_FIND_HIDDEN = @as(u32, 32);
pub const TS_VCOOKIE_NUL = @as(u32, 4294967295);
pub const TS_SHIFT_COUNT_HIDDEN = @as(u32, 1);
pub const TS_SHIFT_HALT_HIDDEN = @as(u32, 2);
pub const TS_SHIFT_HALT_VISIBLE = @as(u32, 4);
pub const TS_SHIFT_COUNT_ONLY = @as(u32, 8);
pub const TS_GTA_HIDDEN = @as(u32, 1);
pub const TS_GEA_HIDDEN = @as(u32, 1);
pub const TF_E_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220224));
pub const TF_E_STACKFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220223));
pub const TF_E_NOTOWNEDRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220222));
pub const TF_E_NOPROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220221));
pub const TF_E_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220220));
pub const TF_E_INVALIDVIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220219));
pub const TF_E_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220218));
pub const TF_E_RANGE_NOT_COVERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220217));
pub const TF_E_COMPOSITION_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220216));
pub const TF_E_EMPTYCONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220215));
pub const TF_E_INVALIDPOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const TF_E_NOLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const TF_E_NOOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const TF_E_NOSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const TF_E_NOINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const TF_E_NOSELECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const TF_E_NOLAYOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const TF_E_INVALIDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const TF_E_SYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const TF_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const TF_E_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const TF_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262912));
pub const TF_RCM_COMLESS = @as(u32, 1);
pub const TF_RCM_VKEY = @as(u32, 2);
pub const TF_RCM_HINT_READING_LENGTH = @as(u32, 4);
pub const TF_RCM_HINT_COLLISION = @as(u32, 8);
pub const TKB_ALTERNATES_STANDARD = @as(u32, 1);
pub const TKB_ALTERNATES_FOR_AUTOCORRECTION = @as(u32, 2);
pub const TKB_ALTERNATES_FOR_PREDICTION = @as(u32, 3);
pub const TKB_ALTERNATES_AUTOCORRECTION_APPLIED = @as(u32, 4);
pub const TF_TMAE_NOACTIVATETIP = @as(u32, 1);
pub const TF_TMAE_SECUREMODE = @as(u32, 2);
pub const TF_TMAE_UIELEMENTENABLEDONLY = @as(u32, 4);
pub const TF_TMAE_COMLESS = @as(u32, 8);
pub const TF_TMAE_WOW16 = @as(u32, 16);
pub const TF_TMAE_NOACTIVATEKEYBOARDLAYOUT = @as(u32, 32);
pub const TF_TMAE_CONSOLE = @as(u32, 64);
pub const TF_TMF_NOACTIVATETIP = @as(u32, 1);
pub const TF_TMF_SECUREMODE = @as(u32, 2);
pub const TF_TMF_UIELEMENTENABLEDONLY = @as(u32, 4);
pub const TF_TMF_COMLESS = @as(u32, 8);
pub const TF_TMF_WOW16 = @as(u32, 16);
pub const TF_TMF_CONSOLE = @as(u32, 64);
pub const TF_TMF_IMMERSIVEMODE = @as(u32, 1073741824);
pub const TF_TMF_ACTIVATED = @as(u32, 2147483648);
pub const TF_MOD_ALT = @as(u32, 1);
pub const TF_MOD_CONTROL = @as(u32, 2);
pub const TF_MOD_SHIFT = @as(u32, 4);
pub const TF_MOD_RALT = @as(u32, 8);
pub const TF_MOD_RCONTROL = @as(u32, 16);
pub const TF_MOD_RSHIFT = @as(u32, 32);
pub const TF_MOD_LALT = @as(u32, 64);
pub const TF_MOD_LCONTROL = @as(u32, 128);
pub const TF_MOD_LSHIFT = @as(u32, 256);
pub const TF_MOD_ON_KEYUP = @as(u32, 512);
pub const TF_MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const TF_US_HIDETIPUI = @as(u32, 1);
pub const TF_DISABLE_SPEECH = @as(u32, 1);
pub const TF_DISABLE_DICTATION = @as(u32, 2);
pub const TF_DISABLE_COMMANDING = @as(u32, 4);
pub const TF_PROCESS_ATOM = "_CTF_PROCESS_ATOM_";
pub const TF_ENABLE_PROCESS_ATOM = "_CTF_ENABLE_PROCESS_ATOM_";
pub const TF_CLUIE_DOCUMENTMGR = @as(u32, 1);
pub const TF_CLUIE_COUNT = @as(u32, 2);
pub const TF_CLUIE_SELECTION = @as(u32, 4);
pub const TF_CLUIE_STRING = @as(u32, 8);
pub const TF_CLUIE_PAGEINDEX = @as(u32, 16);
pub const TF_CLUIE_CURRENTPAGE = @as(u32, 32);
pub const TF_RIUIE_CONTEXT = @as(u32, 1);
pub const TF_RIUIE_STRING = @as(u32, 2);
pub const TF_RIUIE_MAXREADINGSTRINGLENGTH = @as(u32, 4);
pub const TF_RIUIE_ERRORINDEX = @as(u32, 8);
pub const TF_RIUIE_VERTICALORDER = @as(u32, 16);
pub const TF_CONVERSIONMODE_ALPHANUMERIC = @as(u32, 0);
pub const TF_CONVERSIONMODE_NATIVE = @as(u32, 1);
pub const TF_CONVERSIONMODE_KATAKANA = @as(u32, 2);
pub const TF_CONVERSIONMODE_FULLSHAPE = @as(u32, 8);
pub const TF_CONVERSIONMODE_ROMAN = @as(u32, 16);
pub const TF_CONVERSIONMODE_CHARCODE = @as(u32, 32);
pub const TF_CONVERSIONMODE_SOFTKEYBOARD = @as(u32, 128);
pub const TF_CONVERSIONMODE_NOCONVERSION = @as(u32, 256);
pub const TF_CONVERSIONMODE_EUDC = @as(u32, 512);
pub const TF_CONVERSIONMODE_SYMBOL = @as(u32, 1024);
pub const TF_CONVERSIONMODE_FIXED = @as(u32, 2048);
pub const TF_SENTENCEMODE_NONE = @as(u32, 0);
pub const TF_SENTENCEMODE_PLAURALCLAUSE = @as(u32, 1);
pub const TF_SENTENCEMODE_SINGLECONVERT = @as(u32, 2);
pub const TF_SENTENCEMODE_AUTOMATIC = @as(u32, 4);
pub const TF_SENTENCEMODE_PHRASEPREDICT = @as(u32, 8);
pub const TF_SENTENCEMODE_CONVERSATION = @as(u32, 16);
pub const TF_TRANSITORYEXTENSION_NONE = @as(u32, 0);
pub const TF_TRANSITORYEXTENSION_FLOATING = @as(u32, 1);
pub const TF_TRANSITORYEXTENSION_ATSELECTION = @as(u32, 2);
pub const TF_PROFILETYPE_INPUTPROCESSOR = @as(u32, 1);
pub const TF_PROFILETYPE_KEYBOARDLAYOUT = @as(u32, 2);
pub const TF_RIP_FLAG_FREEUNUSEDLIBRARIES = @as(u32, 1);
pub const TF_IPP_FLAG_ACTIVE = @as(u32, 1);
pub const TF_IPP_FLAG_ENABLED = @as(u32, 2);
pub const TF_IPP_FLAG_SUBSTITUTEDBYINPUTPROCESSOR = @as(u32, 4);
pub const TF_IPP_CAPS_DISABLEONTRANSITORY = @as(u32, 1);
pub const TF_IPP_CAPS_SECUREMODESUPPORT = @as(u32, 2);
pub const TF_IPP_CAPS_UIELEMENTENABLED = @as(u32, 4);
pub const TF_IPP_CAPS_COMLESSSUPPORT = @as(u32, 8);
pub const TF_IPP_CAPS_WOW16SUPPORT = @as(u32, 16);
pub const TF_IPP_CAPS_IMMERSIVESUPPORT = @as(u32, 65536);
pub const TF_IPP_CAPS_SYSTRAYSUPPORT = @as(u32, 131072);
pub const TF_IPPMF_FORPROCESS = @as(u32, 268435456);
pub const TF_IPPMF_FORSESSION = @as(u32, 536870912);
pub const TF_IPPMF_FORSYSTEMALL = @as(u32, 1073741824);
pub const TF_IPPMF_ENABLEPROFILE = @as(u32, 1);
pub const TF_IPPMF_DISABLEPROFILE = @as(u32, 2);
pub const TF_IPPMF_DONTCARECURRENTINPUTLANGUAGE = @as(u32, 4);
pub const TF_RP_HIDDENINSETTINGUI = @as(u32, 2);
pub const TF_RP_LOCALPROCESS = @as(u32, 4);
pub const TF_RP_LOCALTHREAD = @as(u32, 8);
pub const TF_RP_SUBITEMINSETTINGUI = @as(u32, 16);
pub const TF_URP_ALLPROFILES = @as(u32, 2);
pub const TF_URP_LOCALPROCESS = @as(u32, 4);
pub const TF_URP_LOCALTHREAD = @as(u32, 8);
pub const TF_IPSINK_FLAG_ACTIVE = @as(u32, 1);
pub const TF_INVALID_EDIT_COOKIE = @as(u32, 0);
pub const TF_POPF_ALL = @as(u32, 1);
pub const TF_SD_READONLY = @as(u32, 1);
pub const TF_SD_LOADING = @as(u32, 2);
pub const TF_SS_DISJOINTSEL = @as(u32, 1);
pub const TF_SS_REGIONS = @as(u32, 2);
pub const TF_SS_TRANSITORY = @as(u32, 4);
pub const TF_SS_TKBAUTOCORRECTENABLE = @as(u32, 16);
pub const TF_SS_TKBPREDICTIONENABLE = @as(u32, 32);
pub const TF_CHAR_EMBEDDED = @as(u32, 65532);
pub const TF_HF_OBJECT = @as(u32, 1);
pub const TF_TF_MOVESTART = @as(u32, 1);
pub const TF_TF_IGNOREEND = @as(u32, 2);
pub const TF_ST_CORRECTION = @as(u32, 1);
pub const TF_IE_CORRECTION = @as(u32, 1);
pub const TF_TU_CORRECTION = @as(u32, 1);
pub const TF_INVALID_COOKIE = @as(u32, 4294967295);
pub const TF_PROFILE_NEWPHONETIC = Guid.initString("b2f9c502-1742-11d4-9790-0080c882687e");
pub const TF_PROFILE_PHONETIC = Guid.initString("761309de-317a-11d4-9b5d-0080c882687e");
pub const TF_PROFILE_NEWCHANGJIE = Guid.initString("f3ba907a-6c7e-11d4-97fa-0080c882687e");
pub const TF_PROFILE_CHANGJIE = Guid.initString("4bdf9f03-c7d3-11d4-b2ab-0080c882687e");
pub const TF_PROFILE_NEWQUICK = Guid.initString("0b883ba0-c1c7-11d4-87f9-0080c882687e");
pub const TF_PROFILE_QUICK = Guid.initString("6024b45f-5c54-11d4-b921-0080c882687e");
pub const TF_PROFILE_CANTONESE = Guid.initString("0aec109c-7e96-11d4-b2ef-0080c882687e");
pub const TF_PROFILE_PINYIN = Guid.initString("f3ba9077-6c7e-11d4-97fa-0080c882687e");
pub const TF_PROFILE_SIMPLEFAST = Guid.initString("fa550b04-5ad7-411f-a5ac-ca038ec515d7");
pub const TF_PROFILE_WUBI = Guid.initString("82590c13-f4dd-44f4-ba1d-8667246fdf8e");
pub const TF_PROFILE_DAYI = Guid.initString("037b2c25-480c-4d7f-b027-d6ca6b69788a");
pub const TF_PROFILE_ARRAY = Guid.initString("d38eff65-aa46-4fd5-91a7-67845fb02f5b");
pub const TF_PROFILE_YI = Guid.initString("409c8376-007b-4357-ae8e-26316ee3fb0d");
pub const TF_PROFILE_TIGRINYA = Guid.initString("3cab88b7-cc3e-46a6-9765-b772ad7761ff");
pub const TF_E_NOCONVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219968));
pub const TF_DICTATION_ON = @as(u32, 1);
pub const TF_DICTATION_ENABLED = @as(u32, 2);
pub const TF_COMMANDING_ENABLED = @as(u32, 4);
pub const TF_COMMANDING_ON = @as(u32, 8);
pub const TF_SPEECHUI_SHOWN = @as(u32, 16);
pub const TF_SHOW_BALLOON = @as(u32, 1);
pub const TF_DISABLE_BALLOON = @as(u32, 2);
pub const TF_MENUREADY = @as(u32, 1);
pub const TF_PROPUI_STATUS_SAVETOFILE = @as(u32, 1);
pub const GUID_INTEGRATIONSTYLE_SEARCHBOX = Guid.initString("e6d1bd11-82f7-4903-ae21-1a6397cde2eb");
pub const TKBL_UNDEFINED = @as(u32, 0);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_PHONETIC = @as(u32, 1028);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_CHANGJIE = @as(u32, 61506);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_DAYI = @as(u32, 61507);
pub const TKBL_OPT_JAPANESE_ABC = @as(u32, 1041);
pub const TKBL_OPT_KOREAN_HANGUL_2_BULSIK = @as(u32, 1042);
pub const TKBL_OPT_SIMPLIFIED_CHINESE_PINYIN = @as(u32, 2052);
pub const TKBL_OPT_TRADITIONAL_CHINESE_PHONETIC = @as(u32, 1028);
pub const TF_FLOATINGLANGBAR_WNDTITLEW = "TF_FloatingLangBar_WndTitle";
pub const TF_FLOATINGLANGBAR_WNDTITLEA = "TF_FloatingLangBar_WndTitle";
pub const TF_FLOATINGLANGBAR_WNDTITLE = "TF_FloatingLangBar_WndTitle";
pub const TF_LBI_ICON = @as(u32, 1);
pub const TF_LBI_TEXT = @as(u32, 2);
pub const TF_LBI_TOOLTIP = @as(u32, 4);
pub const TF_LBI_BITMAP = @as(u32, 8);
pub const TF_LBI_BALLOON = @as(u32, 16);
pub const TF_LBI_CUSTOMUI = @as(u32, 32);
pub const TF_LBI_STATUS = @as(u32, 65536);
pub const TF_LBI_STYLE_HIDDENSTATUSCONTROL = @as(u32, 1);
pub const TF_LBI_STYLE_SHOWNINTRAY = @as(u32, 2);
pub const TF_LBI_STYLE_HIDEONNOOTHERITEMS = @as(u32, 4);
pub const TF_LBI_STYLE_SHOWNINTRAYONLY = @as(u32, 8);
pub const TF_LBI_STYLE_HIDDENBYDEFAULT = @as(u32, 16);
pub const TF_LBI_STYLE_TEXTCOLORICON = @as(u32, 32);
pub const TF_LBI_STYLE_BTN_BUTTON = @as(u32, 65536);
pub const TF_LBI_STYLE_BTN_MENU = @as(u32, 131072);
pub const TF_LBI_STYLE_BTN_TOGGLE = @as(u32, 262144);
pub const TF_LBI_STATUS_HIDDEN = @as(u32, 1);
pub const TF_LBI_STATUS_DISABLED = @as(u32, 2);
pub const TF_LBI_STATUS_BTN_TOGGLED = @as(u32, 65536);
pub const TF_LBI_BMPF_VERTICAL = @as(u32, 1);
pub const TF_SFT_SHOWNORMAL = @as(u32, 1);
pub const TF_SFT_DOCK = @as(u32, 2);
pub const TF_SFT_MINIMIZED = @as(u32, 4);
pub const TF_SFT_HIDDEN = @as(u32, 8);
pub const TF_SFT_NOTRANSPARENCY = @as(u32, 16);
pub const TF_SFT_LOWTRANSPARENCY = @as(u32, 32);
pub const TF_SFT_HIGHTRANSPARENCY = @as(u32, 64);
pub const TF_SFT_LABELS = @as(u32, 128);
pub const TF_SFT_NOLABELS = @as(u32, 256);
pub const TF_SFT_EXTRAICONSONMINIMIZED = @as(u32, 512);
pub const TF_SFT_NOEXTRAICONSONMINIMIZED = @as(u32, 1024);
pub const TF_SFT_DESKBAND = @as(u32, 2048);
pub const TF_LBI_DESC_MAXLEN = @as(u32, 32);
pub const TF_LBMENUF_CHECKED = @as(u32, 1);
pub const TF_LBMENUF_SUBMENU = @as(u32, 2);
pub const TF_LBMENUF_SEPARATOR = @as(u32, 4);
pub const TF_LBMENUF_RADIOCHECKED = @as(u32, 8);
pub const TF_LBMENUF_GRAYED = @as(u32, 16);
pub const GUID_PROP_INPUTSCOPE = Guid.initString("1713dd5a-68e7-4a5b-9af6-592a595c778d");
pub const DCM_FLAGS_TASKENG = @as(u32, 1);
pub const DCM_FLAGS_CTFMON = @as(u32, 2);
pub const DCM_FLAGS_LOCALTHREADTSF = @as(u32, 4);
pub const ILMCM_CHECKLAYOUTANDTIPENABLED = @as(u32, 1);
pub const ILMCM_LANGUAGEBAROFF = @as(u32, 2);
pub const LIBID_MSAATEXTLib = Guid.initString("150e2d7a-dac1-4582-947d-2a8fd78b82cd");
pub const TS_STRF_START = @as(u32, 0);
pub const TS_STRF_MID = @as(u32, 1);
pub const TS_STRF_END = @as(u32, 2);
pub const TSATTRID_OTHERS = Guid.initString("b3c32af9-57d0-46a9-bca8-dac238a13057");
pub const TSATTRID_Font = Guid.initString("573ea825-749b-4f8a-9cfd-21c3605ca828");
pub const TSATTRID_Font_FaceName = Guid.initString("b536aeb6-053b-4eb8-b65a-50da1e81e72e");
pub const TSATTRID_Font_SizePts = Guid.initString("c8493302-a5e9-456d-af04-8005e4130f03");
pub const TSATTRID_Font_Style = Guid.initString("68b2a77f-6b0e-4f28-8177-571c2f3a42b1");
pub const TSATTRID_Font_Style_Bold = Guid.initString("48813a43-8a20-4940-8e58-97823f7b268a");
pub const TSATTRID_Font_Style_Italic = Guid.initString("8740682a-a765-48e1-acfc-d22222b2f810");
pub const TSATTRID_Font_Style_SmallCaps = Guid.initString("facb6bc6-9100-4cc6-b969-11eea45a86b4");
pub const TSATTRID_Font_Style_Capitalize = Guid.initString("7d85a3ba-b4fd-43b3-befc-6b985c843141");
pub const TSATTRID_Font_Style_Uppercase = Guid.initString("33a300e8-e340-4937-b697-8f234045cd9a");
pub const TSATTRID_Font_Style_Lowercase = Guid.initString("76d8ccb5-ca7b-4498-8ee9-d5c4f6f74c60");
pub const TSATTRID_Font_Style_Animation = Guid.initString("dcf73d22-e029-47b7-bb36-f263a3d004cc");
pub const TSATTRID_Font_Style_Animation_LasVegasLights = Guid.initString("f40423d5-0f87-4f8f-bada-e6d60c25e152");
pub const TSATTRID_Font_Style_Animation_BlinkingBackground = Guid.initString("86e5b104-0104-4b10-b585-00f2527522b5");
pub const TSATTRID_Font_Style_Animation_SparkleText = Guid.initString("533aad20-962c-4e9f-8c09-b42ea4749711");
pub const TSATTRID_Font_Style_Animation_MarchingBlackAnts = Guid.initString("7644e067-f186-4902-bfc6-ec815aa20e9d");
pub const TSATTRID_Font_Style_Animation_MarchingRedAnts = Guid.initString("78368dad-50fb-4c6f-840b-d486bb6cf781");
pub const TSATTRID_Font_Style_Animation_Shimmer = Guid.initString("2ce31b58-5293-4c36-8809-bf8bb51a27b3");
pub const TSATTRID_Font_Style_Animation_WipeDown = Guid.initString("5872e874-367b-4803-b160-c90ff62569d0");
pub const TSATTRID_Font_Style_Animation_WipeRight = Guid.initString("b855cbe3-3d2c-4600-b1e9-e1c9ce02f842");
pub const TSATTRID_Font_Style_Emboss = Guid.initString("bd8ed742-349e-4e37-82fb-437979cb53a7");
pub const TSATTRID_Font_Style_Engrave = Guid.initString("9c3371de-8332-4897-be5d-89233223179a");
pub const TSATTRID_Font_Style_Hidden = Guid.initString("b1e28770-881c-475f-863f-887a647b1090");
pub const TSATTRID_Font_Style_Kerning = Guid.initString("cc26e1b4-2f9a-47c8-8bff-bf1eb7cce0dd");
pub const TSATTRID_Font_Style_Outlined = Guid.initString("10e6db31-db0d-4ac6-a7f5-9c9cff6f2ab4");
pub const TSATTRID_Font_Style_Position = Guid.initString("15cd26ab-f2fb-4062-b5a6-9a49e1a5cc0b");
pub const TSATTRID_Font_Style_Protected = Guid.initString("1c557cb2-14cf-4554-a574-ecb2f7e7efd4");
pub const TSATTRID_Font_Style_Shadow = Guid.initString("5f686d2f-c6cd-4c56-8a1a-994a4b9766be");
pub const TSATTRID_Font_Style_Spacing = Guid.initString("98c1200d-8f06-409a-8e49-6a554bf7c153");
pub const TSATTRID_Font_Style_Weight = Guid.initString("12f3189c-8bb0-461b-b1fa-eaf907047fe0");
pub const TSATTRID_Font_Style_Height = Guid.initString("7e937477-12e6-458b-926a-1fa44ee8f391");
pub const TSATTRID_Font_Style_Underline = Guid.initString("c3c9c9f3-7902-444b-9a7b-48e70f4b50f7");
pub const TSATTRID_Font_Style_Underline_Single = Guid.initString("1b6720e5-0f73-4951-a6b3-6f19e43c9461");
pub const TSATTRID_Font_Style_Underline_Double = Guid.initString("74d24aa6-1db3-4c69-a176-31120e7586d5");
pub const TSATTRID_Font_Style_Strikethrough = Guid.initString("0c562193-2d08-4668-9601-ced41309d7af");
pub const TSATTRID_Font_Style_Strikethrough_Single = Guid.initString("75d736b6-3c8f-4b97-ab78-1877cb990d31");
pub const TSATTRID_Font_Style_Strikethrough_Double = Guid.initString("62489b31-a3e7-4f94-ac43-ebaf8fcc7a9f");
pub const TSATTRID_Font_Style_Overline = Guid.initString("e3989f4a-992b-4301-8ce1-a5b7c6d1f3c8");
pub const TSATTRID_Font_Style_Overline_Single = Guid.initString("8440d94c-51ce-47b2-8d4c-15751e5f721b");
pub const TSATTRID_Font_Style_Overline_Double = Guid.initString("dc46063a-e115-46e3-bcd8-ca6772aa95b4");
pub const TSATTRID_Font_Style_Blink = Guid.initString("bfb2c036-7acf-4532-b720-b416dd7765a8");
pub const TSATTRID_Font_Style_Subscript = Guid.initString("5774fb84-389b-43bc-a74b-1568347cf0f4");
pub const TSATTRID_Font_Style_Superscript = Guid.initString("2ea4993c-563c-49aa-9372-0bef09a9255b");
pub const TSATTRID_Font_Style_Color = Guid.initString("857a7a37-b8af-4e9a-81b4-acf700c8411b");
pub const TSATTRID_Font_Style_BackgroundColor = Guid.initString("b50eaa4e-3091-4468-81db-d79ea190c7c7");
pub const TSATTRID_Text = Guid.initString("7edb8e68-81f9-449d-a15a-87a8388faac0");
pub const TSATTRID_Text_VerticalWriting = Guid.initString("6bba8195-046f-4ea9-b311-97fd66c4274b");
pub const TSATTRID_Text_RightToLeft = Guid.initString("ca666e71-1b08-453d-bfdd-28e08c8aaf7a");
pub const TSATTRID_Text_Orientation = Guid.initString("6bab707f-8785-4c39-8b52-96f878303ffb");
pub const TSATTRID_Text_Language = Guid.initString("d8c04ef1-5753-4c25-8887-85443fe5f819");
pub const TSATTRID_Text_ReadOnly = Guid.initString("85836617-de32-4afd-a50f-a2db110e6e4d");
pub const TSATTRID_Text_EmbeddedObject = Guid.initString("7edb8e68-81f9-449d-a15a-87a8388faac0");
pub const TSATTRID_Text_Alignment = Guid.initString("139941e6-1767-456d-938e-35ba568b5cd4");
pub const TSATTRID_Text_Alignment_Left = Guid.initString("16ae95d3-6361-43a2-8495-d00f397f1693");
pub const TSATTRID_Text_Alignment_Right = Guid.initString("b36f0f98-1b9e-4360-8616-03fb08a78456");
pub const TSATTRID_Text_Alignment_Center = Guid.initString("a4a95c16-53bf-4d55-8b87-4bdd8d4275fc");
pub const TSATTRID_Text_Alignment_Justify = Guid.initString("ed350740-a0f7-42d3-8ea8-f81b6488faf0");
pub const TSATTRID_Text_Link = Guid.initString("47cd9051-3722-4cd8-b7c8-4e17ca1759f5");
pub const TSATTRID_Text_Hyphenation = Guid.initString("dadf4525-618e-49eb-b1a8-3b68bd7648e3");
pub const TSATTRID_Text_Para = Guid.initString("5edc5822-99dc-4dd6-aec3-b62baa5b2e7c");
pub const TSATTRID_Text_Para_FirstLineIndent = Guid.initString("07c97a13-7472-4dd8-90a9-91e3d7e4f29c");
pub const TSATTRID_Text_Para_LeftIndent = Guid.initString("fb2848e9-7471-41c9-b6b3-8a1450e01897");
pub const TSATTRID_Text_Para_RightIndent = Guid.initString("2c7f26f9-a5e2-48da-b98a-520cb16513bf");
pub const TSATTRID_Text_Para_SpaceAfter = Guid.initString("7b0a3f55-22dc-425f-a411-93da1d8f9baa");
pub const TSATTRID_Text_Para_SpaceBefore = Guid.initString("8df98589-194a-4601-b251-9865a3e906dd");
pub const TSATTRID_Text_Para_LineSpacing = Guid.initString("699b380d-7f8c-46d6-a73b-dfe3d1538df3");
pub const TSATTRID_Text_Para_LineSpacing_Single = Guid.initString("ed350740-a0f7-42d3-8ea8-f81b6488faf0");
pub const TSATTRID_Text_Para_LineSpacing_OnePtFive = Guid.initString("0428a021-0397-4b57-9a17-0795994cd3c5");
pub const TSATTRID_Text_Para_LineSpacing_Double = Guid.initString("82fb1805-a6c4-4231-ac12-6260af2aba28");
pub const TSATTRID_Text_Para_LineSpacing_AtLeast = Guid.initString("adfedf31-2d44-4434-a5ff-7f4c4990a905");
pub const TSATTRID_Text_Para_LineSpacing_Exactly = Guid.initString("3d45ad40-23de-48d7-a6b3-765420c620cc");
pub const TSATTRID_Text_Para_LineSpacing_Multiple = Guid.initString("910f1e3c-d6d0-4f65-8a3c-42b4b31868c5");
pub const TSATTRID_List = Guid.initString("436d673b-26f1-4aee-9e65-8f83a4ed4884");
pub const TSATTRID_List_LevelIndel = Guid.initString("7f7cc899-311f-487b-ad5d-e2a459e12d42");
pub const TSATTRID_List_Type = Guid.initString("ae3e665e-4bce-49e3-a0fe-2db47d3a17ae");
pub const TSATTRID_List_Type_Bullet = Guid.initString("bccd77c5-4c4d-4ce2-b102-559f3b2bfcea");
pub const TSATTRID_List_Type_Arabic = Guid.initString("1338c5d6-98a3-4fa3-9bd1-7a60eef8e9e0");
pub const TSATTRID_List_Type_LowerLetter = Guid.initString("96372285-f3cf-491e-a925-3832347fd237");
pub const TSATTRID_List_Type_UpperLetter = Guid.initString("7987b7cd-ce52-428b-9b95-a357f6f10c45");
pub const TSATTRID_List_Type_LowerRoman = Guid.initString("90466262-3980-4b8e-9368-918bd1218a41");
pub const TSATTRID_List_Type_UpperRoman = Guid.initString("0f6ab552-4a80-467f-b2f1-127e2aa3ba9e");
pub const TSATTRID_App = Guid.initString("a80f77df-4237-40e5-849c-b5fa51c13ac7");
pub const TSATTRID_App_IncorrectSpelling = Guid.initString("f42de43c-ef12-430d-944c-9a08970a25d2");
pub const TSATTRID_App_IncorrectGrammar = Guid.initString("bd54e398-ad03-4b74-b6b3-5edb19996388");

//--------------------------------------------------------------------------------
// Section: Types (211)
//--------------------------------------------------------------------------------
pub const LANG_BAR_ITEM_ICON_MODE_FLAGS = enum(u32) {
    NONE = 0,
    USEPROFILEICON = 1,
};
pub const TF_DTLBI_NONE = LANG_BAR_ITEM_ICON_MODE_FLAGS.NONE;
pub const TF_DTLBI_USEPROFILEICON = LANG_BAR_ITEM_ICON_MODE_FLAGS.USEPROFILEICON;

pub const TEXT_STORE_TEXT_CHANGE_FLAGS = enum(u32) {
    NONE = 0,
    CORRECTION = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CORRECTION: u1 = 0,
    }) TEXT_STORE_TEXT_CHANGE_FLAGS {
        return @as(TEXT_STORE_TEXT_CHANGE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(TEXT_STORE_TEXT_CHANGE_FLAGS.NONE) else 0) | (if (o.CORRECTION == 1) @intFromEnum(TEXT_STORE_TEXT_CHANGE_FLAGS.CORRECTION) else 0)));
    }
};
pub const TS_ST_NONE = TEXT_STORE_TEXT_CHANGE_FLAGS.NONE;
pub const TS_ST_CORRECTION = TEXT_STORE_TEXT_CHANGE_FLAGS.CORRECTION;

pub const TEXT_STORE_CHANGE_FLAGS = enum(u32) {
    NONE = 0,
    CORRECTION = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CORRECTION: u1 = 0,
    }) TEXT_STORE_CHANGE_FLAGS {
        return @as(TEXT_STORE_CHANGE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(TEXT_STORE_CHANGE_FLAGS.NONE) else 0) | (if (o.CORRECTION == 1) @intFromEnum(TEXT_STORE_CHANGE_FLAGS.CORRECTION) else 0)));
    }
};
pub const TS_TC_NONE = TEXT_STORE_CHANGE_FLAGS.NONE;
pub const TS_TC_CORRECTION = TEXT_STORE_CHANGE_FLAGS.CORRECTION;

pub const INSERT_TEXT_AT_SELECTION_FLAGS = enum(u32) {
    NOQUERY = 1,
    QUERYONLY = 2,
    NO_DEFAULT_COMPOSITION = 2147483648,
};
pub const TF_IAS_NOQUERY = INSERT_TEXT_AT_SELECTION_FLAGS.NOQUERY;
pub const TF_IAS_QUERYONLY = INSERT_TEXT_AT_SELECTION_FLAGS.QUERYONLY;
pub const TF_IAS_NO_DEFAULT_COMPOSITION = INSERT_TEXT_AT_SELECTION_FLAGS.NO_DEFAULT_COMPOSITION;

pub const ANCHOR_CHANGE_HISTORY_FLAGS = enum(u32) {
    PRECEDING_DEL = 1,
    FOLLOWING_DEL = 2,
    _,
    pub fn initFlags(o: struct {
        PRECEDING_DEL: u1 = 0,
        FOLLOWING_DEL: u1 = 0,
    }) ANCHOR_CHANGE_HISTORY_FLAGS {
        return @as(ANCHOR_CHANGE_HISTORY_FLAGS, @enumFromInt((if (o.PRECEDING_DEL == 1) @intFromEnum(ANCHOR_CHANGE_HISTORY_FLAGS.PRECEDING_DEL) else 0) | (if (o.FOLLOWING_DEL == 1) @intFromEnum(ANCHOR_CHANGE_HISTORY_FLAGS.FOLLOWING_DEL) else 0)));
    }
};
pub const TS_CH_PRECEDING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.PRECEDING_DEL;
pub const TS_CH_FOLLOWING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.FOLLOWING_DEL;

pub const TEXT_STORE_LOCK_FLAGS = enum(u32) {
    D = 2,
    WRITE = 6,
};
pub const TS_LF_READ = TEXT_STORE_LOCK_FLAGS.D;
pub const TS_LF_READWRITE = TEXT_STORE_LOCK_FLAGS.WRITE;

pub const GET_TEXT_AND_PROPERTY_UPDATES_FLAGS = enum(u32) {
    NONE = 0,
    INCL_TEXT = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        INCL_TEXT: u1 = 0,
    }) GET_TEXT_AND_PROPERTY_UPDATES_FLAGS {
        return @as(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.NONE) else 0) | (if (o.INCL_TEXT == 1) @intFromEnum(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.INCL_TEXT) else 0)));
    }
};
pub const TF_GTP_NONE = GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.NONE;
pub const TF_GTP_INCL_TEXT = GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.INCL_TEXT;

pub const TF_CONTEXT_EDIT_CONTEXT_FLAGS = enum(u32) {
    ASYNCDONTCARE = 0,
    SYNC = 1,
    READ = 2,
    READWRITE = 6,
    ASYNC = 8,
    _,
    pub fn initFlags(o: struct {
        ASYNCDONTCARE: u1 = 0,
        SYNC: u1 = 0,
        READ: u1 = 0,
        READWRITE: u1 = 0,
        ASYNC: u1 = 0,
    }) TF_CONTEXT_EDIT_CONTEXT_FLAGS {
        return @as(TF_CONTEXT_EDIT_CONTEXT_FLAGS, @enumFromInt((if (o.ASYNCDONTCARE == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNCDONTCARE) else 0) | (if (o.SYNC == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.SYNC) else 0) | (if (o.READ == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.READ) else 0) | (if (o.READWRITE == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.READWRITE) else 0) | (if (o.ASYNC == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNC) else 0)));
    }
};
pub const TF_ES_ASYNCDONTCARE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNCDONTCARE;
pub const TF_ES_SYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.SYNC;
pub const TF_ES_READ = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READ;
pub const TF_ES_READWRITE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READWRITE;
pub const TF_ES_ASYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNC;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HKL = *opaque {};

pub const TS_STATUS = extern struct {
    dwDynamicFlags: u32,
    dwStaticFlags: u32,
};

pub const TS_TEXTCHANGE = extern struct {
    acpStart: i32,
    acpOldEnd: i32,
    acpNewEnd: i32,
};

pub const TsActiveSelEnd = enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TS_AE_NONE = TsActiveSelEnd.NONE;
pub const TS_AE_START = TsActiveSelEnd.START;
pub const TS_AE_END = TsActiveSelEnd.END;

pub const TS_SELECTIONSTYLE = extern struct {
    ase: TsActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TS_SELECTION_ACP = extern struct {
    acpStart: i32,
    acpEnd: i32,
    style: TS_SELECTIONSTYLE,
};

pub const TS_SELECTION_ANCHOR = extern struct {
    paStart: ?*IAnchor,
    paEnd: ?*IAnchor,
    style: TS_SELECTIONSTYLE,
};

pub const TS_ATTRVAL = extern struct {
    idAttr: Guid,
    dwOverlapId: u32,
    varValue: VARIANT,
};

pub const TsLayoutCode = enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TS_LC_CREATE = TsLayoutCode.CREATE;
pub const TS_LC_CHANGE = TsLayoutCode.CHANGE;
pub const TS_LC_DESTROY = TsLayoutCode.DESTROY;

pub const TsRunType = enum(i32) {
    PLAIN = 0,
    HIDDEN = 1,
    OPAQUE = 2,
};
pub const TS_RT_PLAIN = TsRunType.PLAIN;
pub const TS_RT_HIDDEN = TsRunType.HIDDEN;
pub const TS_RT_OPAQUE = TsRunType.OPAQUE;

pub const TS_RUNINFO = extern struct {
    uCount: u32,
    type: TsRunType,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACP_Value = Guid.initString("28888fe3-c2a0-483a-a3ea-8cb1ce51ff3d");
pub const IID_ITextStoreACP = &IID_ITextStoreACP_Value;
pub const ITextStoreACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: *const fn (
            self: *const ITextStoreACP,
            riid: ?*const Guid,
            punk: ?*IUnknown,
            dw_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: *const fn (
            self: *const ITextStoreACP,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: *const fn (
            self: *const ITextStoreACP,
            dw_lock_flags: u32,
            phr_session: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITextStoreACP,
            pdcs: ?*TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: *const fn (
            self: *const ITextStoreACP,
            acp_test_start: i32,
            acp_test_end: i32,
            cch: u32,
            pacp_result_start: ?*i32,
            pacp_result_end: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITextStoreACP,
            ul_index: u32,
            ul_count: u32,
            p_selection: [*]TS_SELECTION_ACP,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const ITextStoreACP,
            ul_count: u32,
            p_selection: [*]const TS_SELECTION_ACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITextStoreACP,
            acp_start: i32,
            acp_end: i32,
            pch_plain: [*:0]u16,
            cch_plain_req: u32,
            pcch_plain_ret: ?*u32,
            prg_run_info: [*]TS_RUNINFO,
            c_run_info_req: u32,
            pc_run_info_ret: ?*u32,
            pacp_next: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITextStoreACP,
            dw_flags: u32,
            acp_start: i32,
            acp_end: i32,
            pch_text: [*:0]const u16,
            cch: u32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: *const fn (
            self: *const ITextStoreACP,
            acp_start: i32,
            acp_end: i32,
            pp_data_object: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: *const fn (
            self: *const ITextStoreACP,
            acp_pos: i32,
            rguid_service: ?*const Guid,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: *const fn (
            self: *const ITextStoreACP,
            pguid_service: ?*const Guid,
            p_format_etc: ?*const FORMATETC,
            pf_insertable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: *const fn (
            self: *const ITextStoreACP,
            dw_flags: u32,
            acp_start: i32,
            acp_end: i32,
            p_data_object: ?*IDataObject,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: *const fn (
            self: *const ITextStoreACP,
            dw_flags: u32,
            pch_text: [*:0]const u16,
            cch: u32,
            pacp_start: ?*i32,
            pacp_end: ?*i32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: *const fn (
            self: *const ITextStoreACP,
            dw_flags: u32,
            p_data_object: ?*IDataObject,
            pacp_start: ?*i32,
            pacp_end: ?*i32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: *const fn (
            self: *const ITextStoreACP,
            dw_flags: u32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: *const fn (
            self: *const ITextStoreACP,
            acp_pos: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: *const fn (
            self: *const ITextStoreACP,
            acp_pos: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: *const fn (
            self: *const ITextStoreACP,
            acp_start: i32,
            acp_halt: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
            pacp_next: ?*i32,
            pf_found: ?*BOOL,
            pl_found_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: *const fn (
            self: *const ITextStoreACP,
            ul_count: u32,
            pa_attr_vals: [*]TS_ATTRVAL,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndACP: *const fn (
            self: *const ITextStoreACP,
            pacp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: *const fn (
            self: *const ITextStoreACP,
            pvc_view: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetACPFromPoint: *const fn (
            self: *const ITextStoreACP,
            vc_view: u32,
            pt_screen: ?*const POINT,
            dw_flags: u32,
            pacp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: *const fn (
            self: *const ITextStoreACP,
            vc_view: u32,
            acp_start: i32,
            acp_end: i32,
            prc: ?*RECT,
            pf_clipped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: *const fn (
            self: *const ITextStoreACP,
            vc_view: u32,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: *const fn (
            self: *const ITextStoreACP,
            vc_view: u32,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSink(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown, dw_mask_: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreACP, @ptrCast(self)), riid_, punk_, dw_mask_);
            }
            pub inline fn unadviseSink(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreACP, @ptrCast(self)), punk_);
            }
            pub inline fn requestLock(self: *const T, dw_lock_flags_: u32, phr_session_: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreACP, @ptrCast(self)), dw_lock_flags_, phr_session_);
            }
            pub inline fn getStatus(self: *const T, pdcs_: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreACP, @ptrCast(self)), pdcs_);
            }
            pub inline fn queryInsert(self: *const T, acp_test_start_: i32, acp_test_end_: i32, cch_: u32, pacp_result_start_: ?*i32, pacp_result_end_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreACP, @ptrCast(self)), acp_test_start_, acp_test_end_, cch_, pacp_result_start_, pacp_result_end_);
            }
            pub inline fn getSelection(self: *const T, ul_index_: u32, ul_count_: u32, p_selection_: [*]TS_SELECTION_ACP, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreACP, @ptrCast(self)), ul_index_, ul_count_, p_selection_, pc_fetched_);
            }
            pub inline fn setSelection(self: *const T, ul_count_: u32, p_selection_: [*]const TS_SELECTION_ACP) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreACP, @ptrCast(self)), ul_count_, p_selection_);
            }
            pub inline fn getText(self: *const T, acp_start_: i32, acp_end_: i32, pch_plain_: [*:0]u16, cch_plain_req_: u32, pcch_plain_ret_: ?*u32, prg_run_info_: [*]TS_RUNINFO, c_run_info_req_: u32, pc_run_info_ret_: ?*u32, pacp_next_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreACP, @ptrCast(self)), acp_start_, acp_end_, pch_plain_, cch_plain_req_, pcch_plain_ret_, prg_run_info_, c_run_info_req_, pc_run_info_ret_, pacp_next_);
            }
            pub inline fn setText(self: *const T, dw_flags_: u32, acp_start_: i32, acp_end_: i32, pch_text_: [*:0]const u16, cch_: u32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreACP, @ptrCast(self)), dw_flags_, acp_start_, acp_end_, pch_text_, cch_, p_change_);
            }
            pub inline fn getFormattedText(self: *const T, acp_start_: i32, acp_end_: i32, pp_data_object_: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreACP, @ptrCast(self)), acp_start_, acp_end_, pp_data_object_);
            }
            pub inline fn getEmbedded(self: *const T, acp_pos_: i32, rguid_service_: ?*const Guid, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), acp_pos_, rguid_service_, riid_, ppunk_);
            }
            pub inline fn queryInsertEmbedded(self: *const T, pguid_service_: ?*const Guid, p_format_etc_: ?*const FORMATETC, pf_insertable_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), pguid_service_, p_format_etc_, pf_insertable_);
            }
            pub inline fn insertEmbedded(self: *const T, dw_flags_: u32, acp_start_: i32, acp_end_: i32, p_data_object_: ?*IDataObject, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), dw_flags_, acp_start_, acp_end_, p_data_object_, p_change_);
            }
            pub inline fn insertTextAtSelection(self: *const T, dw_flags_: u32, pch_text_: [*:0]const u16, cch_: u32, pacp_start_: ?*i32, pacp_end_: ?*i32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreACP, @ptrCast(self)), dw_flags_, pch_text_, cch_, pacp_start_, pacp_end_, p_change_);
            }
            pub inline fn insertEmbeddedAtSelection(self: *const T, dw_flags_: u32, p_data_object_: ?*IDataObject, pacp_start_: ?*i32, pacp_end_: ?*i32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreACP, @ptrCast(self)), dw_flags_, p_data_object_, pacp_start_, pacp_end_, p_change_);
            }
            pub inline fn requestSupportedAttrs(self: *const T, dw_flags_: u32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreACP, @ptrCast(self)), dw_flags_, c_filter_attrs_, pa_filter_attrs_);
            }
            pub inline fn requestAttrsAtPosition(self: *const T, acp_pos_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreACP, @ptrCast(self)), acp_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn requestAttrsTransitioningAtPosition(self: *const T, acp_pos_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreACP, @ptrCast(self)), acp_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn findNextAttrTransition(self: *const T, acp_start_: i32, acp_halt_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32, pacp_next_: ?*i32, pf_found_: ?*BOOL, pl_found_offset_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreACP, @ptrCast(self)), acp_start_, acp_halt_, c_filter_attrs_, pa_filter_attrs_, dw_flags_, pacp_next_, pf_found_, pl_found_offset_);
            }
            pub inline fn retrieveRequestedAttrs(self: *const T, ul_count_: u32, pa_attr_vals_: [*]TS_ATTRVAL, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreACP, @ptrCast(self)), ul_count_, pa_attr_vals_, pc_fetched_);
            }
            pub inline fn getEndACP(self: *const T, pacp_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetEndACP(@as(*const ITextStoreACP, @ptrCast(self)), pacp_);
            }
            pub inline fn getActiveView(self: *const T, pvc_view_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreACP, @ptrCast(self)), pvc_view_);
            }
            pub inline fn getACPFromPoint(self: *const T, vc_view_: u32, pt_screen_: ?*const POINT, dw_flags_: u32, pacp_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITextStoreACP, @ptrCast(self)), vc_view_, pt_screen_, dw_flags_, pacp_);
            }
            pub inline fn getTextExt(self: *const T, vc_view_: u32, acp_start_: i32, acp_end_: i32, prc_: ?*RECT, pf_clipped_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreACP, @ptrCast(self)), vc_view_, acp_start_, acp_end_, prc_, pf_clipped_);
            }
            pub inline fn getScreenExt(self: *const T, vc_view_: u32, prc_: ?*RECT) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreACP, @ptrCast(self)), vc_view_, prc_);
            }
            pub inline fn getWnd(self: *const T, vc_view_: u32, phwnd_: ?*?HWND) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITextStoreACP, @ptrCast(self)), vc_view_, phwnd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoreACP2_Value = Guid.initString("f86ad89f-5fe4-4b8d-bb9f-ef3797a84f1f");
pub const IID_ITextStoreACP2 = &IID_ITextStoreACP2_Value;
pub const ITextStoreACP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: *const fn (
            self: *const ITextStoreACP2,
            riid: ?*const Guid,
            punk: ?*IUnknown,
            dw_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: *const fn (
            self: *const ITextStoreACP2,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: *const fn (
            self: *const ITextStoreACP2,
            dw_lock_flags: u32,
            phr_session: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITextStoreACP2,
            pdcs: ?*TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: *const fn (
            self: *const ITextStoreACP2,
            acp_test_start: i32,
            acp_test_end: i32,
            cch: u32,
            pacp_result_start: ?*i32,
            pacp_result_end: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITextStoreACP2,
            ul_index: u32,
            ul_count: u32,
            p_selection: [*]TS_SELECTION_ACP,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const ITextStoreACP2,
            ul_count: u32,
            p_selection: [*]const TS_SELECTION_ACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITextStoreACP2,
            acp_start: i32,
            acp_end: i32,
            pch_plain: [*:0]u16,
            cch_plain_req: u32,
            pcch_plain_ret: ?*u32,
            prg_run_info: [*]TS_RUNINFO,
            c_run_info_req: u32,
            pc_run_info_ret: ?*u32,
            pacp_next: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITextStoreACP2,
            dw_flags: u32,
            acp_start: i32,
            acp_end: i32,
            pch_text: [*:0]const u16,
            cch: u32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: *const fn (
            self: *const ITextStoreACP2,
            acp_start: i32,
            acp_end: i32,
            pp_data_object: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: *const fn (
            self: *const ITextStoreACP2,
            acp_pos: i32,
            rguid_service: ?*const Guid,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: *const fn (
            self: *const ITextStoreACP2,
            pguid_service: ?*const Guid,
            p_format_etc: ?*const FORMATETC,
            pf_insertable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: *const fn (
            self: *const ITextStoreACP2,
            dw_flags: u32,
            acp_start: i32,
            acp_end: i32,
            p_data_object: ?*IDataObject,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: *const fn (
            self: *const ITextStoreACP2,
            dw_flags: u32,
            pch_text: [*:0]const u16,
            cch: u32,
            pacp_start: ?*i32,
            pacp_end: ?*i32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: *const fn (
            self: *const ITextStoreACP2,
            dw_flags: u32,
            p_data_object: ?*IDataObject,
            pacp_start: ?*i32,
            pacp_end: ?*i32,
            p_change: ?*TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: *const fn (
            self: *const ITextStoreACP2,
            dw_flags: u32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: *const fn (
            self: *const ITextStoreACP2,
            acp_pos: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: *const fn (
            self: *const ITextStoreACP2,
            acp_pos: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: *const fn (
            self: *const ITextStoreACP2,
            acp_start: i32,
            acp_halt: i32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
            pacp_next: ?*i32,
            pf_found: ?*BOOL,
            pl_found_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: *const fn (
            self: *const ITextStoreACP2,
            ul_count: u32,
            pa_attr_vals: [*]TS_ATTRVAL,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndACP: *const fn (
            self: *const ITextStoreACP2,
            pacp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: *const fn (
            self: *const ITextStoreACP2,
            pvc_view: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetACPFromPoint: *const fn (
            self: *const ITextStoreACP2,
            vc_view: u32,
            pt_screen: ?*const POINT,
            dw_flags: u32,
            pacp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: *const fn (
            self: *const ITextStoreACP2,
            vc_view: u32,
            acp_start: i32,
            acp_end: i32,
            prc: ?*RECT,
            pf_clipped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: *const fn (
            self: *const ITextStoreACP2,
            vc_view: u32,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSink(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown, dw_mask_: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreACP2, @ptrCast(self)), riid_, punk_, dw_mask_);
            }
            pub inline fn unadviseSink(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreACP2, @ptrCast(self)), punk_);
            }
            pub inline fn requestLock(self: *const T, dw_lock_flags_: u32, phr_session_: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreACP2, @ptrCast(self)), dw_lock_flags_, phr_session_);
            }
            pub inline fn getStatus(self: *const T, pdcs_: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreACP2, @ptrCast(self)), pdcs_);
            }
            pub inline fn queryInsert(self: *const T, acp_test_start_: i32, acp_test_end_: i32, cch_: u32, pacp_result_start_: ?*i32, pacp_result_end_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreACP2, @ptrCast(self)), acp_test_start_, acp_test_end_, cch_, pacp_result_start_, pacp_result_end_);
            }
            pub inline fn getSelection(self: *const T, ul_index_: u32, ul_count_: u32, p_selection_: [*]TS_SELECTION_ACP, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreACP2, @ptrCast(self)), ul_index_, ul_count_, p_selection_, pc_fetched_);
            }
            pub inline fn setSelection(self: *const T, ul_count_: u32, p_selection_: [*]const TS_SELECTION_ACP) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreACP2, @ptrCast(self)), ul_count_, p_selection_);
            }
            pub inline fn getText(self: *const T, acp_start_: i32, acp_end_: i32, pch_plain_: [*:0]u16, cch_plain_req_: u32, pcch_plain_ret_: ?*u32, prg_run_info_: [*]TS_RUNINFO, c_run_info_req_: u32, pc_run_info_ret_: ?*u32, pacp_next_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreACP2, @ptrCast(self)), acp_start_, acp_end_, pch_plain_, cch_plain_req_, pcch_plain_ret_, prg_run_info_, c_run_info_req_, pc_run_info_ret_, pacp_next_);
            }
            pub inline fn setText(self: *const T, dw_flags_: u32, acp_start_: i32, acp_end_: i32, pch_text_: [*:0]const u16, cch_: u32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreACP2, @ptrCast(self)), dw_flags_, acp_start_, acp_end_, pch_text_, cch_, p_change_);
            }
            pub inline fn getFormattedText(self: *const T, acp_start_: i32, acp_end_: i32, pp_data_object_: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreACP2, @ptrCast(self)), acp_start_, acp_end_, pp_data_object_);
            }
            pub inline fn getEmbedded(self: *const T, acp_pos_: i32, rguid_service_: ?*const Guid, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), acp_pos_, rguid_service_, riid_, ppunk_);
            }
            pub inline fn queryInsertEmbedded(self: *const T, pguid_service_: ?*const Guid, p_format_etc_: ?*const FORMATETC, pf_insertable_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), pguid_service_, p_format_etc_, pf_insertable_);
            }
            pub inline fn insertEmbedded(self: *const T, dw_flags_: u32, acp_start_: i32, acp_end_: i32, p_data_object_: ?*IDataObject, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), dw_flags_, acp_start_, acp_end_, p_data_object_, p_change_);
            }
            pub inline fn insertTextAtSelection(self: *const T, dw_flags_: u32, pch_text_: [*:0]const u16, cch_: u32, pacp_start_: ?*i32, pacp_end_: ?*i32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreACP2, @ptrCast(self)), dw_flags_, pch_text_, cch_, pacp_start_, pacp_end_, p_change_);
            }
            pub inline fn insertEmbeddedAtSelection(self: *const T, dw_flags_: u32, p_data_object_: ?*IDataObject, pacp_start_: ?*i32, pacp_end_: ?*i32, p_change_: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreACP2, @ptrCast(self)), dw_flags_, p_data_object_, pacp_start_, pacp_end_, p_change_);
            }
            pub inline fn requestSupportedAttrs(self: *const T, dw_flags_: u32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreACP2, @ptrCast(self)), dw_flags_, c_filter_attrs_, pa_filter_attrs_);
            }
            pub inline fn requestAttrsAtPosition(self: *const T, acp_pos_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreACP2, @ptrCast(self)), acp_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn requestAttrsTransitioningAtPosition(self: *const T, acp_pos_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreACP2, @ptrCast(self)), acp_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn findNextAttrTransition(self: *const T, acp_start_: i32, acp_halt_: i32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32, pacp_next_: ?*i32, pf_found_: ?*BOOL, pl_found_offset_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreACP2, @ptrCast(self)), acp_start_, acp_halt_, c_filter_attrs_, pa_filter_attrs_, dw_flags_, pacp_next_, pf_found_, pl_found_offset_);
            }
            pub inline fn retrieveRequestedAttrs(self: *const T, ul_count_: u32, pa_attr_vals_: [*]TS_ATTRVAL, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreACP2, @ptrCast(self)), ul_count_, pa_attr_vals_, pc_fetched_);
            }
            pub inline fn getEndACP(self: *const T, pacp_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetEndACP(@as(*const ITextStoreACP2, @ptrCast(self)), pacp_);
            }
            pub inline fn getActiveView(self: *const T, pvc_view_: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreACP2, @ptrCast(self)), pvc_view_);
            }
            pub inline fn getACPFromPoint(self: *const T, vc_view_: u32, pt_screen_: ?*const POINT, dw_flags_: u32, pacp_: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITextStoreACP2, @ptrCast(self)), vc_view_, pt_screen_, dw_flags_, pacp_);
            }
            pub inline fn getTextExt(self: *const T, vc_view_: u32, acp_start_: i32, acp_end_: i32, prc_: ?*RECT, pf_clipped_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreACP2, @ptrCast(self)), vc_view_, acp_start_, acp_end_, prc_, pf_clipped_);
            }
            pub inline fn getScreenExt(self: *const T, vc_view_: u32, prc_: ?*RECT) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreACP2, @ptrCast(self)), vc_view_, prc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPSink_Value = Guid.initString("22d44c94-a419-4542-a272-ae26093ececf");
pub const IID_ITextStoreACPSink = &IID_ITextStoreACPSink_Value;
pub const ITextStoreACPSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: *const fn (
            self: *const ITextStoreACPSink,
            dw_flags: TEXT_STORE_TEXT_CHANGE_FLAGS,
            p_change: ?*const TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: *const fn (
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLayoutChange: *const fn (
            self: *const ITextStoreACPSink,
            lcode: TsLayoutCode,
            vc_view: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: *const fn (
            self: *const ITextStoreACPSink,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttrsChange: *const fn (
            self: *const ITextStoreACPSink,
            acp_start: i32,
            acp_end: i32,
            c_attrs: u32,
            pa_attrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLockGranted: *const fn (
            self: *const ITextStoreACPSink,
            dw_lock_flags: TEXT_STORE_LOCK_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStartEditTransaction: *const fn (
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: *const fn (
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onTextChange(self: *const T, dw_flags_: TEXT_STORE_TEXT_CHANGE_FLAGS, p_change_: ?*const TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnTextChange(@as(*const ITextStoreACPSink, @ptrCast(self)), dw_flags_, p_change_);
            }
            pub inline fn onSelectionChange(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnSelectionChange(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
            pub inline fn onLayoutChange(self: *const T, lcode_: TsLayoutCode, vc_view_: u32) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITextStoreACPSink, @ptrCast(self)), lcode_, vc_view_);
            }
            pub inline fn onStatusChange(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITextStoreACPSink, @ptrCast(self)), dw_flags_);
            }
            pub inline fn onAttrsChange(self: *const T, acp_start_: i32, acp_end_: i32, c_attrs_: u32, pa_attrs_: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnAttrsChange(@as(*const ITextStoreACPSink, @ptrCast(self)), acp_start_, acp_end_, c_attrs_, pa_attrs_);
            }
            pub inline fn onLockGranted(self: *const T, dw_lock_flags_: TEXT_STORE_LOCK_FLAGS) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnLockGranted(@as(*const ITextStoreACPSink, @ptrCast(self)), dw_lock_flags_);
            }
            pub inline fn onStartEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
            pub inline fn onEndEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TsGravity = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_GR_BACKWARD = TsGravity.BACKWARD;
pub const TS_GR_FORWARD = TsGravity.FORWARD;

pub const TsShiftDir = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_SD_BACKWARD = TsShiftDir.BACKWARD;
pub const TS_SD_FORWARD = TsShiftDir.FORWARD;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAnchor_Value = Guid.initString("0feb7e34-5a60-4356-8ef7-abdec2ff7cf8");
pub const IID_IAnchor = &IID_IAnchor_Value;
pub const IAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGravity: *const fn (
            self: *const IAnchor,
            gravity: TsGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: *const fn (
            self: *const IAnchor,
            pgravity: ?*TsGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const IAnchor,
            pa_with: ?*IAnchor,
            pf_equal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: *const fn (
            self: *const IAnchor,
            pa_with: ?*IAnchor,
            pl_result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shift: *const fn (
            self: *const IAnchor,
            dw_flags: u32,
            cch_req: i32,
            pcch: ?*i32,
            pa_halt_anchor: ?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftTo: *const fn (
            self: *const IAnchor,
            pa_site: ?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftRegion: *const fn (
            self: *const IAnchor,
            dw_flags: u32,
            dir: TsShiftDir,
            pf_no_region: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChangeHistoryMask: *const fn (
            self: *const IAnchor,
            dw_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChangeHistory: *const fn (
            self: *const IAnchor,
            pdw_history: ?*ANCHOR_CHANGE_HISTORY_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearChangeHistory: *const fn (
            self: *const IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IAnchor,
            ppa_clone: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setGravity(self: *const T, gravity_: TsGravity) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const IAnchor, @ptrCast(self)), gravity_);
            }
            pub inline fn getGravity(self: *const T, pgravity_: ?*TsGravity) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const IAnchor, @ptrCast(self)), pgravity_);
            }
            pub inline fn isEqual(self: *const T, pa_with_: ?*IAnchor, pf_equal_: ?*BOOL) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IAnchor, @ptrCast(self)), pa_with_, pf_equal_);
            }
            pub inline fn compare(self: *const T, pa_with_: ?*IAnchor, pl_result_: ?*i32) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Compare(@as(*const IAnchor, @ptrCast(self)), pa_with_, pl_result_);
            }
            pub inline fn shift(self: *const T, dw_flags_: u32, cch_req_: i32, pcch_: ?*i32, pa_halt_anchor_: ?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Shift(@as(*const IAnchor, @ptrCast(self)), dw_flags_, cch_req_, pcch_, pa_halt_anchor_);
            }
            pub inline fn shiftTo(self: *const T, pa_site_: ?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ShiftTo(@as(*const IAnchor, @ptrCast(self)), pa_site_);
            }
            pub inline fn shiftRegion(self: *const T, dw_flags_: u32, dir_: TsShiftDir, pf_no_region_: ?*BOOL) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ShiftRegion(@as(*const IAnchor, @ptrCast(self)), dw_flags_, dir_, pf_no_region_);
            }
            pub inline fn setChangeHistoryMask(self: *const T, dw_mask_: u32) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).SetChangeHistoryMask(@as(*const IAnchor, @ptrCast(self)), dw_mask_);
            }
            pub inline fn getChangeHistory(self: *const T, pdw_history_: ?*ANCHOR_CHANGE_HISTORY_FLAGS) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).GetChangeHistory(@as(*const IAnchor, @ptrCast(self)), pdw_history_);
            }
            pub inline fn clearChangeHistory(self: *const T) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ClearChangeHistory(@as(*const IAnchor, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppa_clone_: ?*?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Clone(@as(*const IAnchor, @ptrCast(self)), ppa_clone_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchor_Value = Guid.initString("9b2077b0-5f18-4dec-bee9-3cc722f5dfe0");
pub const IID_ITextStoreAnchor = &IID_ITextStoreAnchor_Value;
pub const ITextStoreAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: *const fn (
            self: *const ITextStoreAnchor,
            riid: ?*const Guid,
            punk: ?*IUnknown,
            dw_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: *const fn (
            self: *const ITextStoreAnchor,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: *const fn (
            self: *const ITextStoreAnchor,
            dw_lock_flags: u32,
            phr_session: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITextStoreAnchor,
            pdcs: ?*TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: *const fn (
            self: *const ITextStoreAnchor,
            pa_test_start: ?*IAnchor,
            pa_test_end: ?*IAnchor,
            cch: u32,
            ppa_result_start: ?*?*IAnchor,
            ppa_result_end: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITextStoreAnchor,
            ul_index: u32,
            ul_count: u32,
            p_selection: [*]TS_SELECTION_ANCHOR,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const ITextStoreAnchor,
            ul_count: u32,
            p_selection: [*]const TS_SELECTION_ANCHOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            pch_text: [*:0]u16,
            cch_req: u32,
            pcch: ?*u32,
            f_update_anchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            pch_text: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: *const fn (
            self: *const ITextStoreAnchor,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            pp_data_object: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            pa_pos: ?*IAnchor,
            rguid_service: ?*const Guid,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            p_data_object: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: *const fn (
            self: *const ITextStoreAnchor,
            pa_pos: ?*IAnchor,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: *const fn (
            self: *const ITextStoreAnchor,
            pa_pos: ?*IAnchor,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: *const fn (
            self: *const ITextStoreAnchor,
            pa_start: ?*IAnchor,
            pa_halt: ?*IAnchor,
            c_filter_attrs: u32,
            pa_filter_attrs: [*]const Guid,
            dw_flags: u32,
            pf_found: ?*BOOL,
            pl_found_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: *const fn (
            self: *const ITextStoreAnchor,
            ul_count: u32,
            pa_attr_vals: [*]TS_ATTRVAL,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: *const fn (
            self: *const ITextStoreAnchor,
            ppa_start: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: *const fn (
            self: *const ITextStoreAnchor,
            ppa_end: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: *const fn (
            self: *const ITextStoreAnchor,
            pvc_view: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnchorFromPoint: *const fn (
            self: *const ITextStoreAnchor,
            vc_view: u32,
            pt_screen: ?*const POINT,
            dw_flags: u32,
            ppa_site: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: *const fn (
            self: *const ITextStoreAnchor,
            vc_view: u32,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            prc: ?*RECT,
            pf_clipped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: *const fn (
            self: *const ITextStoreAnchor,
            vc_view: u32,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: *const fn (
            self: *const ITextStoreAnchor,
            vc_view: u32,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: *const fn (
            self: *const ITextStoreAnchor,
            pguid_service: ?*const Guid,
            p_format_etc: ?*const FORMATETC,
            pf_insertable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            pch_text: [*:0]const u16,
            cch: u32,
            ppa_start: ?*?*IAnchor,
            ppa_end: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: *const fn (
            self: *const ITextStoreAnchor,
            dw_flags: u32,
            p_data_object: ?*IDataObject,
            ppa_start: ?*?*IAnchor,
            ppa_end: ?*?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSink(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown, dw_mask_: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreAnchor, @ptrCast(self)), riid_, punk_, dw_mask_);
            }
            pub inline fn unadviseSink(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreAnchor, @ptrCast(self)), punk_);
            }
            pub inline fn requestLock(self: *const T, dw_lock_flags_: u32, phr_session_: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_lock_flags_, phr_session_);
            }
            pub inline fn getStatus(self: *const T, pdcs_: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreAnchor, @ptrCast(self)), pdcs_);
            }
            pub inline fn queryInsert(self: *const T, pa_test_start_: ?*IAnchor, pa_test_end_: ?*IAnchor, cch_: u32, ppa_result_start_: ?*?*IAnchor, ppa_result_end_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreAnchor, @ptrCast(self)), pa_test_start_, pa_test_end_, cch_, ppa_result_start_, ppa_result_end_);
            }
            pub inline fn getSelection(self: *const T, ul_index_: u32, ul_count_: u32, p_selection_: [*]TS_SELECTION_ANCHOR, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), ul_index_, ul_count_, p_selection_, pc_fetched_);
            }
            pub inline fn setSelection(self: *const T, ul_count_: u32, p_selection_: [*]const TS_SELECTION_ANCHOR) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), ul_count_, p_selection_);
            }
            pub inline fn getText(self: *const T, dw_flags_: u32, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, pch_text_: [*:0]u16, cch_req_: u32, pcch_: ?*u32, f_update_anchor_: BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, pa_start_, pa_end_, pch_text_, cch_req_, pcch_, f_update_anchor_);
            }
            pub inline fn setText(self: *const T, dw_flags_: u32, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, pch_text_: [*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, pa_start_, pa_end_, pch_text_, cch_);
            }
            pub inline fn getFormattedText(self: *const T, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, pp_data_object_: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreAnchor, @ptrCast(self)), pa_start_, pa_end_, pp_data_object_);
            }
            pub inline fn getEmbedded(self: *const T, dw_flags_: u32, pa_pos_: ?*IAnchor, rguid_service_: ?*const Guid, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, pa_pos_, rguid_service_, riid_, ppunk_);
            }
            pub inline fn insertEmbedded(self: *const T, dw_flags_: u32, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, p_data_object_: ?*IDataObject) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, pa_start_, pa_end_, p_data_object_);
            }
            pub inline fn requestSupportedAttrs(self: *const T, dw_flags_: u32, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, c_filter_attrs_, pa_filter_attrs_);
            }
            pub inline fn requestAttrsAtPosition(self: *const T, pa_pos_: ?*IAnchor, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreAnchor, @ptrCast(self)), pa_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn requestAttrsTransitioningAtPosition(self: *const T, pa_pos_: ?*IAnchor, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreAnchor, @ptrCast(self)), pa_pos_, c_filter_attrs_, pa_filter_attrs_, dw_flags_);
            }
            pub inline fn findNextAttrTransition(self: *const T, pa_start_: ?*IAnchor, pa_halt_: ?*IAnchor, c_filter_attrs_: u32, pa_filter_attrs_: [*]const Guid, dw_flags_: u32, pf_found_: ?*BOOL, pl_found_offset_: ?*i32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreAnchor, @ptrCast(self)), pa_start_, pa_halt_, c_filter_attrs_, pa_filter_attrs_, dw_flags_, pf_found_, pl_found_offset_);
            }
            pub inline fn retrieveRequestedAttrs(self: *const T, ul_count_: u32, pa_attr_vals_: [*]TS_ATTRVAL, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreAnchor, @ptrCast(self)), ul_count_, pa_attr_vals_, pc_fetched_);
            }
            pub inline fn getStart(self: *const T, ppa_start_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITextStoreAnchor, @ptrCast(self)), ppa_start_);
            }
            pub inline fn getEnd(self: *const T, ppa_end_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITextStoreAnchor, @ptrCast(self)), ppa_end_);
            }
            pub inline fn getActiveView(self: *const T, pvc_view_: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreAnchor, @ptrCast(self)), pvc_view_);
            }
            pub inline fn getAnchorFromPoint(self: *const T, vc_view_: u32, pt_screen_: ?*const POINT, dw_flags_: u32, ppa_site_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetAnchorFromPoint(@as(*const ITextStoreAnchor, @ptrCast(self)), vc_view_, pt_screen_, dw_flags_, ppa_site_);
            }
            pub inline fn getTextExt(self: *const T, vc_view_: u32, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, prc_: ?*RECT, pf_clipped_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreAnchor, @ptrCast(self)), vc_view_, pa_start_, pa_end_, prc_, pf_clipped_);
            }
            pub inline fn getScreenExt(self: *const T, vc_view_: u32, prc_: ?*RECT) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreAnchor, @ptrCast(self)), vc_view_, prc_);
            }
            pub inline fn getWnd(self: *const T, vc_view_: u32, phwnd_: ?*?HWND) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITextStoreAnchor, @ptrCast(self)), vc_view_, phwnd_);
            }
            pub inline fn queryInsertEmbedded(self: *const T, pguid_service_: ?*const Guid, p_format_etc_: ?*const FORMATETC, pf_insertable_: ?*BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), pguid_service_, p_format_etc_, pf_insertable_);
            }
            pub inline fn insertTextAtSelection(self: *const T, dw_flags_: u32, pch_text_: [*:0]const u16, cch_: u32, ppa_start_: ?*?*IAnchor, ppa_end_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, pch_text_, cch_, ppa_start_, ppa_end_);
            }
            pub inline fn insertEmbeddedAtSelection(self: *const T, dw_flags_: u32, p_data_object_: ?*IDataObject, ppa_start_: ?*?*IAnchor, ppa_end_: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), dw_flags_, p_data_object_, ppa_start_, ppa_end_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchorSink_Value = Guid.initString("aa80e905-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreAnchorSink = &IID_ITextStoreAnchorSink_Value;
pub const ITextStoreAnchorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: *const fn (
            self: *const ITextStoreAnchorSink,
            dw_flags: TEXT_STORE_CHANGE_FLAGS,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: *const fn (
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLayoutChange: *const fn (
            self: *const ITextStoreAnchorSink,
            lcode: TsLayoutCode,
            vc_view: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: *const fn (
            self: *const ITextStoreAnchorSink,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttrsChange: *const fn (
            self: *const ITextStoreAnchorSink,
            pa_start: ?*IAnchor,
            pa_end: ?*IAnchor,
            c_attrs: u32,
            pa_attrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLockGranted: *const fn (
            self: *const ITextStoreAnchorSink,
            dw_lock_flags: TEXT_STORE_LOCK_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStartEditTransaction: *const fn (
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: *const fn (
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onTextChange(self: *const T, dw_flags_: TEXT_STORE_CHANGE_FLAGS, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnTextChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dw_flags_, pa_start_, pa_end_);
            }
            pub inline fn onSelectionChange(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnSelectionChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
            pub inline fn onLayoutChange(self: *const T, lcode_: TsLayoutCode, vc_view_: u32) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), lcode_, vc_view_);
            }
            pub inline fn onStatusChange(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dw_flags_);
            }
            pub inline fn onAttrsChange(self: *const T, pa_start_: ?*IAnchor, pa_end_: ?*IAnchor, c_attrs_: u32, pa_attrs_: [*]const Guid) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnAttrsChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), pa_start_, pa_end_, c_attrs_, pa_attrs_);
            }
            pub inline fn onLockGranted(self: *const T, dw_lock_flags_: TEXT_STORE_LOCK_FLAGS) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnLockGranted(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dw_lock_flags_);
            }
            pub inline fn onStartEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
            pub inline fn onEndEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarMgr_Value = Guid.initString("87955690-e627-11d2-8ddb-00105a2799b5");
pub const IID_ITfLangBarMgr = &IID_ITfLangBarMgr_Value;
pub const ITfLangBarMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseEventSink: *const fn (
            self: *const ITfLangBarMgr,
            p_sink: ?*ITfLangBarEventSink,
            hwnd: ?HWND,
            dw_flags: u32,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseEventSink: *const fn (
            self: *const ITfLangBarMgr,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadMarshalInterface: *const fn (
            self: *const ITfLangBarMgr,
            dw_thread_id: u32,
            dw_type: u32,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadLangBarItemMgr: *const fn (
            self: *const ITfLangBarMgr,
            dw_thread_id: u32,
            pplbi: ?*?*ITfLangBarItemMgr,
            pdw_threadid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputProcessorProfiles: *const fn (
            self: *const ITfLangBarMgr,
            dw_thread_id: u32,
            ppaip: ?*?*ITfInputProcessorProfiles,
            pdw_threadid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreLastFocus: *const fn (
            self: *const ITfLangBarMgr,
            pdw_thread_id: ?*u32,
            f_prev: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModalInput: *const fn (
            self: *const ITfLangBarMgr,
            p_sink: ?*ITfLangBarEventSink,
            dw_thread_id: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowFloating: *const fn (
            self: *const ITfLangBarMgr,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowFloatingStatus: *const fn (
            self: *const ITfLangBarMgr,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseEventSink(self: *const T, p_sink_: ?*ITfLangBarEventSink, hwnd_: ?HWND, dw_flags_: u32, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).AdviseEventSink(@as(*const ITfLangBarMgr, @ptrCast(self)), p_sink_, hwnd_, dw_flags_, pdw_cookie_);
            }
            pub inline fn unadviseEventSink(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).UnadviseEventSink(@as(*const ITfLangBarMgr, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn getThreadMarshalInterface(self: *const T, dw_thread_id_: u32, dw_type_: u32, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetThreadMarshalInterface(@as(*const ITfLangBarMgr, @ptrCast(self)), dw_thread_id_, dw_type_, riid_, ppunk_);
            }
            pub inline fn getThreadLangBarItemMgr(self: *const T, dw_thread_id_: u32, pplbi_: ?*?*ITfLangBarItemMgr, pdw_threadid_: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetThreadLangBarItemMgr(@as(*const ITfLangBarMgr, @ptrCast(self)), dw_thread_id_, pplbi_, pdw_threadid_);
            }
            pub inline fn getInputProcessorProfiles(self: *const T, dw_thread_id_: u32, ppaip_: ?*?*ITfInputProcessorProfiles, pdw_threadid_: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetInputProcessorProfiles(@as(*const ITfLangBarMgr, @ptrCast(self)), dw_thread_id_, ppaip_, pdw_threadid_);
            }
            pub inline fn restoreLastFocus(self: *const T, pdw_thread_id_: ?*u32, f_prev_: BOOL) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).RestoreLastFocus(@as(*const ITfLangBarMgr, @ptrCast(self)), pdw_thread_id_, f_prev_);
            }
            pub inline fn setModalInput(self: *const T, p_sink_: ?*ITfLangBarEventSink, dw_thread_id_: u32, dw_flags_: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).SetModalInput(@as(*const ITfLangBarMgr, @ptrCast(self)), p_sink_, dw_thread_id_, dw_flags_);
            }
            pub inline fn showFloating(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).ShowFloating(@as(*const ITfLangBarMgr, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getShowFloatingStatus(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetShowFloatingStatus(@as(*const ITfLangBarMgr, @ptrCast(self)), pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarEventSink_Value = Guid.initString("18a4e900-e0ae-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarEventSink = &IID_ITfLangBarEventSink_Value;
pub const ITfLangBarEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: *const fn (
            self: *const ITfLangBarEventSink,
            dw_thread_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnThreadTerminate: *const fn (
            self: *const ITfLangBarEventSink,
            dw_thread_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnThreadItemChange: *const fn (
            self: *const ITfLangBarEventSink,
            dw_thread_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnModalInput: *const fn (
            self: *const ITfLangBarEventSink,
            dw_thread_id: u32,
            u_msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowFloating: *const fn (
            self: *const ITfLangBarEventSink,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFloatingRect: *const fn (
            self: *const ITfLangBarEventSink,
            dw_thread_id: u32,
            rguid: ?*const Guid,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onSetFocus(self: *const T, dw_thread_id_: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_thread_id_);
            }
            pub inline fn onThreadTerminate(self: *const T, dw_thread_id_: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnThreadTerminate(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_thread_id_);
            }
            pub inline fn onThreadItemChange(self: *const T, dw_thread_id_: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnThreadItemChange(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_thread_id_);
            }
            pub inline fn onModalInput(self: *const T, dw_thread_id_: u32, u_msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnModalInput(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_thread_id_, u_msg_, w_param_, l_param_);
            }
            pub inline fn showFloating(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).ShowFloating(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getItemFloatingRect(self: *const T, dw_thread_id_: u32, rguid_: ?*const Guid, prc_: ?*RECT) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).GetItemFloatingRect(@as(*const ITfLangBarEventSink, @ptrCast(self)), dw_thread_id_, rguid_, prc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemSink_Value = Guid.initString("57dbe1a0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemSink = &IID_ITfLangBarItemSink_Value;
pub const ITfLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdate: *const fn (
            self: *const ITfLangBarItemSink,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUpdate(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITfLangBarItemSink.VTable, @ptrCast(self.vtable)).OnUpdate(@as(*const ITfLangBarItemSink, @ptrCast(self)), dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLangBarItems_Value = Guid.initString("583f34d0-de25-11d2-afdd-00105a2799b5");
pub const IID_IEnumTfLangBarItems = &IID_IEnumTfLangBarItems_Value;
pub const IEnumTfLangBarItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfLangBarItems,
            pp_enum: ?*?*IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfLangBarItems,
            ul_count: u32,
            pp_item: [*]?*ITfLangBarItem,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfLangBarItems,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfLangBarItems) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLangBarItems, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_item_: [*]?*ITfLangBarItem, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLangBarItems, @ptrCast(self)), ul_count_, pp_item_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLangBarItems, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLangBarItems, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LANGBARITEMINFO = extern struct {
    clsidService: Guid,
    guidItem: Guid,
    dwStyle: u32,
    ulSort: u32,
    szDescription: [32]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemMgr_Value = Guid.initString("ba468c55-9956-4fb1-a59d-52a7dd7cc6aa");
pub const IID_ITfLangBarItemMgr = &IID_ITfLangBarItemMgr_Value;
pub const ITfLangBarItemMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumItems: *const fn (
            self: *const ITfLangBarItemMgr,
            pp_enum: ?*?*IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: *const fn (
            self: *const ITfLangBarItemMgr,
            rguid: ?*const Guid,
            pp_item: ?*?*ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddItem: *const fn (
            self: *const ITfLangBarItemMgr,
            punk: ?*ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveItem: *const fn (
            self: *const ITfLangBarItemMgr,
            punk: ?*ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseItemSink: *const fn (
            self: *const ITfLangBarItemMgr,
            punk: ?*ITfLangBarItemSink,
            pdw_cookie: ?*u32,
            rguid_item: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseItemSink: *const fn (
            self: *const ITfLangBarItemMgr,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFloatingRect: *const fn (
            self: *const ITfLangBarItemMgr,
            dw_thread_id: u32,
            rguid: ?*const Guid,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsStatus: *const fn (
            self: *const ITfLangBarItemMgr,
            ul_count: u32,
            prgguid: [*]const Guid,
            pdw_status: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemNum: *const fn (
            self: *const ITfLangBarItemMgr,
            pul_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItems: *const fn (
            self: *const ITfLangBarItemMgr,
            ul_count: u32,
            pp_item: [*]?*ITfLangBarItem,
            p_info: [*]TF_LANGBARITEMINFO,
            pdw_status: [*]u32,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseItemsSink: *const fn (
            self: *const ITfLangBarItemMgr,
            ul_count: u32,
            ppunk: [*]?*ITfLangBarItemSink,
            pguid_item: [*]const Guid,
            pdw_cookie: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseItemsSink: *const fn (
            self: *const ITfLangBarItemMgr,
            ul_count: u32,
            pdw_cookie: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumItems(self: *const T, pp_enum_: ?*?*IEnumTfLangBarItems) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).EnumItems(@as(*const ITfLangBarItemMgr, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getItem(self: *const T, rguid_: ?*const Guid, pp_item_: ?*?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), rguid_, pp_item_);
            }
            pub inline fn addItem(self: *const T, punk_: ?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AddItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk_);
            }
            pub inline fn removeItem(self: *const T, punk_: ?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).RemoveItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk_);
            }
            pub inline fn adviseItemSink(self: *const T, punk_: ?*ITfLangBarItemSink, pdw_cookie_: ?*u32, rguid_item_: ?*const Guid) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AdviseItemSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk_, pdw_cookie_, rguid_item_);
            }
            pub inline fn unadviseItemSink(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).UnadviseItemSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn getItemFloatingRect(self: *const T, dw_thread_id_: u32, rguid_: ?*const Guid, prc_: ?*RECT) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemFloatingRect(@as(*const ITfLangBarItemMgr, @ptrCast(self)), dw_thread_id_, rguid_, prc_);
            }
            pub inline fn getItemsStatus(self: *const T, ul_count_: u32, prgguid_: [*]const Guid, pdw_status_: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemsStatus(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ul_count_, prgguid_, pdw_status_);
            }
            pub inline fn getItemNum(self: *const T, pul_count_: ?*u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemNum(@as(*const ITfLangBarItemMgr, @ptrCast(self)), pul_count_);
            }
            pub inline fn getItems(self: *const T, ul_count_: u32, pp_item_: [*]?*ITfLangBarItem, p_info_: [*]TF_LANGBARITEMINFO, pdw_status_: [*]u32, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItems(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ul_count_, pp_item_, p_info_, pdw_status_, pc_fetched_);
            }
            pub inline fn adviseItemsSink(self: *const T, ul_count_: u32, ppunk_: [*]?*ITfLangBarItemSink, pguid_item_: [*]const Guid, pdw_cookie_: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AdviseItemsSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ul_count_, ppunk_, pguid_item_, pdw_cookie_);
            }
            pub inline fn unadviseItemsSink(self: *const T, ul_count_: u32, pdw_cookie_: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).UnadviseItemsSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ul_count_, pdw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItem_Value = Guid.initString("73540d69-edeb-4ee9-96c9-23aa30b25916");
pub const IID_ITfLangBarItem = &IID_ITfLangBarItem_Value;
pub const ITfLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: *const fn (
            self: *const ITfLangBarItem,
            p_info: ?*TF_LANGBARITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITfLangBarItem,
            pdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: *const fn (
            self: *const ITfLangBarItem,
            f_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTooltipString: *const fn (
            self: *const ITfLangBarItem,
            pbstr_tool_tip: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInfo(self: *const T, p_info_: ?*TF_LANGBARITEMINFO) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ITfLangBarItem, @ptrCast(self)), p_info_);
            }
            pub inline fn getStatus(self: *const T, pdw_status_: ?*u32) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfLangBarItem, @ptrCast(self)), pdw_status_);
            }
            pub inline fn show(self: *const T, f_show_: BOOL) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfLangBarItem, @ptrCast(self)), f_show_);
            }
            pub inline fn getTooltipString(self: *const T, pbstr_tool_tip_: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetTooltipString(@as(*const ITfLangBarItem, @ptrCast(self)), pbstr_tool_tip_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemSink_Value = Guid.initString("1449d9ab-13cf-4687-aa3e-8d8b18574396");
pub const IID_ITfSystemLangBarItemSink = &IID_ITfSystemLangBarItemSink_Value;
pub const ITfSystemLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitMenu: *const fn (
            self: *const ITfSystemLangBarItemSink,
            p_menu: ?*ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: *const fn (
            self: *const ITfSystemLangBarItemSink,
            w_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initMenu(self: *const T, p_menu_: ?*ITfMenu) HRESULT {
                return @as(*const ITfSystemLangBarItemSink.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfSystemLangBarItemSink, @ptrCast(self)), p_menu_);
            }
            pub inline fn onMenuSelect(self: *const T, w_i_d_: u32) HRESULT {
                return @as(*const ITfSystemLangBarItemSink.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfSystemLangBarItemSink, @ptrCast(self)), w_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItem_Value = Guid.initString("1e13e9ec-6b33-4d4a-b5eb-8a92f029f356");
pub const IID_ITfSystemLangBarItem = &IID_ITfSystemLangBarItem_Value;
pub const ITfSystemLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIcon: *const fn (
            self: *const ITfSystemLangBarItem,
            h_icon: ?HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTooltipString: *const fn (
            self: *const ITfSystemLangBarItem,
            pch_tool_tip: [*:0]u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setIcon(self: *const T, h_icon_: ?HICON) HRESULT {
                return @as(*const ITfSystemLangBarItem.VTable, @ptrCast(self.vtable)).SetIcon(@as(*const ITfSystemLangBarItem, @ptrCast(self)), h_icon_);
            }
            pub inline fn setTooltipString(self: *const T, pch_tool_tip_: [*:0]u16, cch_: u32) HRESULT {
                return @as(*const ITfSystemLangBarItem.VTable, @ptrCast(self.vtable)).SetTooltipString(@as(*const ITfSystemLangBarItem, @ptrCast(self)), pch_tool_tip_, cch_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemText_Value = Guid.initString("5c4ce0e5-ba49-4b52-ac6b-3b397b4f701f");
pub const IID_ITfSystemLangBarItemText = &IID_ITfSystemLangBarItemText_Value;
pub const ITfSystemLangBarItemText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItemText: *const fn (
            self: *const ITfSystemLangBarItemText,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemText: *const fn (
            self: *const ITfSystemLangBarItemText,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setItemText(self: *const T, pch_: [*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ITfSystemLangBarItemText.VTable, @ptrCast(self.vtable)).SetItemText(@as(*const ITfSystemLangBarItemText, @ptrCast(self)), pch_, cch_);
            }
            pub inline fn getItemText(self: *const T, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const ITfSystemLangBarItemText.VTable, @ptrCast(self.vtable)).GetItemText(@as(*const ITfSystemLangBarItemText, @ptrCast(self)), pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemDeviceTypeLangBarItem_Value = Guid.initString("45672eb9-9059-46a2-838d-4530355f6a77");
pub const IID_ITfSystemDeviceTypeLangBarItem = &IID_ITfSystemDeviceTypeLangBarItem_Value;
pub const ITfSystemDeviceTypeLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIconMode: *const fn (
            self: *const ITfSystemDeviceTypeLangBarItem,
            dw_flags: LANG_BAR_ITEM_ICON_MODE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconMode: *const fn (
            self: *const ITfSystemDeviceTypeLangBarItem,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setIconMode(self: *const T, dw_flags_: LANG_BAR_ITEM_ICON_MODE_FLAGS) HRESULT {
                return @as(*const ITfSystemDeviceTypeLangBarItem.VTable, @ptrCast(self.vtable)).SetIconMode(@as(*const ITfSystemDeviceTypeLangBarItem, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getIconMode(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfSystemDeviceTypeLangBarItem.VTable, @ptrCast(self.vtable)).GetIconMode(@as(*const ITfSystemDeviceTypeLangBarItem, @ptrCast(self)), pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBIClick = enum(i32) {
    RIGHT = 1,
    LEFT = 2,
};
pub const TF_LBI_CLK_RIGHT = TfLBIClick.RIGHT;
pub const TF_LBI_CLK_LEFT = TfLBIClick.LEFT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemButton_Value = Guid.initString("28c7f1d0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemButton = &IID_ITfLangBarItemButton_Value;
pub const ITfLangBarItemButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: *const fn (
            self: *const ITfLangBarItemButton,
            click: TfLBIClick,
            pt: POINT,
            prc_area: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitMenu: *const fn (
            self: *const ITfLangBarItemButton,
            p_menu: ?*ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: *const fn (
            self: *const ITfLangBarItemButton,
            w_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: *const fn (
            self: *const ITfLangBarItemButton,
            ph_icon: ?*?HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITfLangBarItemButton,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            pub inline fn onClick(self: *const T, click_: TfLBIClick, pt_: POINT, prc_area_: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemButton, @ptrCast(self)), click_, pt_, prc_area_);
            }
            pub inline fn initMenu(self: *const T, p_menu_: ?*ITfMenu) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfLangBarItemButton, @ptrCast(self)), p_menu_);
            }
            pub inline fn onMenuSelect(self: *const T, w_i_d_: u32) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfLangBarItemButton, @ptrCast(self)), w_i_d_);
            }
            pub inline fn getIcon(self: *const T, ph_icon_: ?*?HICON) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).GetIcon(@as(*const ITfLangBarItemButton, @ptrCast(self)), ph_icon_);
            }
            pub inline fn getText(self: *const T, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfLangBarItemButton, @ptrCast(self)), pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmapButton_Value = Guid.initString("a26a0525-3fae-4fa0-89ee-88a964f9f1b5");
pub const IID_ITfLangBarItemBitmapButton = &IID_ITfLangBarItemBitmapButton_Value;
pub const ITfLangBarItemBitmapButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            click: TfLBIClick,
            pt: POINT,
            prc_area: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitMenu: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            p_menu: ?*ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            w_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            psz_default: ?*const SIZE,
            psz: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawBitmap: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            bm_width: i32,
            bm_height: i32,
            dw_flags: u32,
            phbmp: ?*?HBITMAP,
            phbmp_mask: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITfLangBarItemBitmapButton,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            pub inline fn onClick(self: *const T, click_: TfLBIClick, pt_: POINT, prc_area_: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), click_, pt_, prc_area_);
            }
            pub inline fn initMenu(self: *const T, p_menu_: ?*ITfMenu) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), p_menu_);
            }
            pub inline fn onMenuSelect(self: *const T, w_i_d_: u32) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), w_i_d_);
            }
            pub inline fn getPreferredSize(self: *const T, psz_default_: ?*const SIZE, psz_: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), psz_default_, psz_);
            }
            pub inline fn drawBitmap(self: *const T, bm_width_: i32, bm_height_: i32, dw_flags_: u32, phbmp_: ?*?HBITMAP, phbmp_mask_: ?*?HBITMAP) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), bm_width_, bm_height_, dw_flags_, phbmp_, phbmp_mask_);
            }
            pub inline fn getText(self: *const T, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmap_Value = Guid.initString("73830352-d722-4179-ada5-f045c98df355");
pub const IID_ITfLangBarItemBitmap = &IID_ITfLangBarItemBitmap_Value;
pub const ITfLangBarItemBitmap = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: *const fn (
            self: *const ITfLangBarItemBitmap,
            click: TfLBIClick,
            pt: POINT,
            prc_area: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: *const fn (
            self: *const ITfLangBarItemBitmap,
            psz_default: ?*const SIZE,
            psz: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawBitmap: *const fn (
            self: *const ITfLangBarItemBitmap,
            bm_width: i32,
            bm_height: i32,
            dw_flags: u32,
            phbmp: ?*?HBITMAP,
            phbmp_mask: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            pub inline fn onClick(self: *const T, click_: TfLBIClick, pt_: POINT, prc_area_: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), click_, pt_, prc_area_);
            }
            pub inline fn getPreferredSize(self: *const T, psz_default_: ?*const SIZE, psz_: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), psz_default_, psz_);
            }
            pub inline fn drawBitmap(self: *const T, bm_width_: i32, bm_height_: i32, dw_flags_: u32, phbmp_: ?*?HBITMAP, phbmp_mask_: ?*?HBITMAP) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), bm_width_, bm_height_, dw_flags_, phbmp_, phbmp_mask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBBalloonStyle = enum(i32) {
    RECO = 0,
    SHOW = 1,
    MISS = 2,
};
pub const TF_LB_BALLOON_RECO = TfLBBalloonStyle.RECO;
pub const TF_LB_BALLOON_SHOW = TfLBBalloonStyle.SHOW;
pub const TF_LB_BALLOON_MISS = TfLBBalloonStyle.MISS;

pub const TF_LBBALLOONINFO = extern struct {
    style: TfLBBalloonStyle,
    bstrText: ?BSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBalloon_Value = Guid.initString("01c2d285-d3c7-4b7b-b5b5-d97411d0c283");
pub const IID_ITfLangBarItemBalloon = &IID_ITfLangBarItemBalloon_Value;
pub const ITfLangBarItemBalloon = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: *const fn (
            self: *const ITfLangBarItemBalloon,
            click: TfLBIClick,
            pt: POINT,
            prc_area: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: *const fn (
            self: *const ITfLangBarItemBalloon,
            psz_default: ?*const SIZE,
            psz: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBalloonInfo: *const fn (
            self: *const ITfLangBarItemBalloon,
            p_info: ?*TF_LBBALLOONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            pub inline fn onClick(self: *const T, click_: TfLBIClick, pt_: POINT, prc_area_: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), click_, pt_, prc_area_);
            }
            pub inline fn getPreferredSize(self: *const T, psz_default_: ?*const SIZE, psz_: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), psz_default_, psz_);
            }
            pub inline fn getBalloonInfo(self: *const T, p_info_: ?*TF_LBBALLOONINFO) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).GetBalloonInfo(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), p_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMenu_Value = Guid.initString("6f8a98e4-aaa0-4f15-8c5b-07e0df0a3dd8");
pub const IID_ITfMenu = &IID_ITfMenu_Value;
pub const ITfMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMenuItem: *const fn (
            self: *const ITfMenu,
            u_id: u32,
            dw_flags: u32,
            hbmp: ?HBITMAP,
            hbmp_mask: ?HBITMAP,
            pch: [*:0]const u16,
            cch: u32,
            pp_menu: ?*?*ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addMenuItem(self: *const T, u_id_: u32, dw_flags_: u32, hbmp_: ?HBITMAP, hbmp_mask_: ?HBITMAP, pch_: [*:0]const u16, cch_: u32, pp_menu_: ?*?*ITfMenu) HRESULT {
                return @as(*const ITfMenu.VTable, @ptrCast(self.vtable)).AddMenuItem(@as(*const ITfMenu, @ptrCast(self)), u_id_, dw_flags_, hbmp_, hbmp_mask_, pch_, cch_, pp_menu_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PERSISTENT_PROPERTY_HEADER_ACP = extern struct {
    guidType: Guid,
    ichStart: i32,
    cch: i32,
    cb: u32,
    dwPrivate: u32,
    clsidTIP: Guid,
};

pub const TF_LANGUAGEPROFILE = extern struct {
    clsid: Guid,
    langid: u16,
    catid: Guid,
    fActive: BOOL,
    guidProfile: Guid,
};

pub const TfAnchor = enum(i32) {
    START = 0,
    END = 1,
};
pub const TF_ANCHOR_START = TfAnchor.START;
pub const TF_ANCHOR_END = TfAnchor.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgr_Value = Guid.initString("aa80e801-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgr = &IID_ITfThreadMgr_Value;
pub const ITfThreadMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: *const fn (
            self: *const ITfThreadMgr,
            ptid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: *const fn (
            self: *const ITfThreadMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDocumentMgr: *const fn (
            self: *const ITfThreadMgr,
            ppdim: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDocumentMgrs: *const fn (
            self: *const ITfThreadMgr,
            pp_enum: ?*?*IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: *const fn (
            self: *const ITfThreadMgr,
            ppdim_focus: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: *const fn (
            self: *const ITfThreadMgr,
            pdim_focus: ?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateFocus: *const fn (
            self: *const ITfThreadMgr,
            hwnd: ?HWND,
            pdim_new: ?*ITfDocumentMgr,
            ppdim_prev: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsThreadFocus: *const fn (
            self: *const ITfThreadMgr,
            pf_thread_focus: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionProvider: *const fn (
            self: *const ITfThreadMgr,
            clsid: ?*const Guid,
            pp_func_prov: ?*?*ITfFunctionProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFunctionProviders: *const fn (
            self: *const ITfThreadMgr,
            pp_enum: ?*?*IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalCompartment: *const fn (
            self: *const ITfThreadMgr,
            pp_comp_mgr: ?*?*ITfCompartmentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activate(self: *const T, ptid_: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfThreadMgr, @ptrCast(self)), ptid_);
            }
            pub inline fn deactivate(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfThreadMgr, @ptrCast(self)));
            }
            pub inline fn createDocumentMgr(self: *const T, ppdim_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).CreateDocumentMgr(@as(*const ITfThreadMgr, @ptrCast(self)), ppdim_);
            }
            pub inline fn enumDocumentMgrs(self: *const T, pp_enum_: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).EnumDocumentMgrs(@as(*const ITfThreadMgr, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getFocus(self: *const T, ppdim_focus_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const ITfThreadMgr, @ptrCast(self)), ppdim_focus_);
            }
            pub inline fn setFocus(self: *const T, pdim_focus_: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const ITfThreadMgr, @ptrCast(self)), pdim_focus_);
            }
            pub inline fn associateFocus(self: *const T, hwnd_: ?HWND, pdim_new_: ?*ITfDocumentMgr, ppdim_prev_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).AssociateFocus(@as(*const ITfThreadMgr, @ptrCast(self)), hwnd_, pdim_new_, ppdim_prev_);
            }
            pub inline fn isThreadFocus(self: *const T, pf_thread_focus_: ?*BOOL) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).IsThreadFocus(@as(*const ITfThreadMgr, @ptrCast(self)), pf_thread_focus_);
            }
            pub inline fn getFunctionProvider(self: *const T, clsid_: ?*const Guid, pp_func_prov_: ?*?*ITfFunctionProvider) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetFunctionProvider(@as(*const ITfThreadMgr, @ptrCast(self)), clsid_, pp_func_prov_);
            }
            pub inline fn enumFunctionProviders(self: *const T, pp_enum_: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).EnumFunctionProviders(@as(*const ITfThreadMgr, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getGlobalCompartment(self: *const T, pp_comp_mgr_: ?*?*ITfCompartmentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetGlobalCompartment(@as(*const ITfThreadMgr, @ptrCast(self)), pp_comp_mgr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEx_Value = Guid.initString("3e90ade3-7594-4cb0-bb58-69628f5f458c");
pub const IID_ITfThreadMgrEx = &IID_ITfThreadMgrEx_Value;
pub const ITfThreadMgrEx = extern struct {
    pub const VTable = extern struct {
        base: ITfThreadMgr.VTable,
        ActivateEx: *const fn (
            self: *const ITfThreadMgrEx,
            ptid: ?*u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveFlags: *const fn (
            self: *const ITfThreadMgrEx,
            lpdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfThreadMgr.MethodMixin(T);
            pub inline fn activateEx(self: *const T, ptid_: ?*u32, dw_flags_: u32) HRESULT {
                return @as(*const ITfThreadMgrEx.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfThreadMgrEx, @ptrCast(self)), ptid_, dw_flags_);
            }
            pub inline fn getActiveFlags(self: *const T, lpdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfThreadMgrEx.VTable, @ptrCast(self.vtable)).GetActiveFlags(@as(*const ITfThreadMgrEx, @ptrCast(self)), lpdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfThreadMgr2_Value = Guid.initString("0ab198ef-6477-4ee8-8812-6780edb82d5e");
pub const IID_ITfThreadMgr2 = &IID_ITfThreadMgr2_Value;
pub const ITfThreadMgr2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: *const fn (
            self: *const ITfThreadMgr2,
            ptid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: *const fn (
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDocumentMgr: *const fn (
            self: *const ITfThreadMgr2,
            ppdim: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDocumentMgrs: *const fn (
            self: *const ITfThreadMgr2,
            pp_enum: ?*?*IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: *const fn (
            self: *const ITfThreadMgr2,
            ppdim_focus: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: *const fn (
            self: *const ITfThreadMgr2,
            pdim_focus: ?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsThreadFocus: *const fn (
            self: *const ITfThreadMgr2,
            pf_thread_focus: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionProvider: *const fn (
            self: *const ITfThreadMgr2,
            clsid: ?*const Guid,
            pp_func_prov: ?*?*ITfFunctionProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFunctionProviders: *const fn (
            self: *const ITfThreadMgr2,
            pp_enum: ?*?*IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalCompartment: *const fn (
            self: *const ITfThreadMgr2,
            pp_comp_mgr: ?*?*ITfCompartmentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateEx: *const fn (
            self: *const ITfThreadMgr2,
            ptid: ?*u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveFlags: *const fn (
            self: *const ITfThreadMgr2,
            lpdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendKeystrokeHandling: *const fn (
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeKeystrokeHandling: *const fn (
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activate(self: *const T, ptid_: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfThreadMgr2, @ptrCast(self)), ptid_);
            }
            pub inline fn deactivate(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
            pub inline fn createDocumentMgr(self: *const T, ppdim_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).CreateDocumentMgr(@as(*const ITfThreadMgr2, @ptrCast(self)), ppdim_);
            }
            pub inline fn enumDocumentMgrs(self: *const T, pp_enum_: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).EnumDocumentMgrs(@as(*const ITfThreadMgr2, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getFocus(self: *const T, ppdim_focus_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), ppdim_focus_);
            }
            pub inline fn setFocus(self: *const T, pdim_focus_: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), pdim_focus_);
            }
            pub inline fn isThreadFocus(self: *const T, pf_thread_focus_: ?*BOOL) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).IsThreadFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), pf_thread_focus_);
            }
            pub inline fn getFunctionProvider(self: *const T, clsid_: ?*const Guid, pp_func_prov_: ?*?*ITfFunctionProvider) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetFunctionProvider(@as(*const ITfThreadMgr2, @ptrCast(self)), clsid_, pp_func_prov_);
            }
            pub inline fn enumFunctionProviders(self: *const T, pp_enum_: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).EnumFunctionProviders(@as(*const ITfThreadMgr2, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getGlobalCompartment(self: *const T, pp_comp_mgr_: ?*?*ITfCompartmentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetGlobalCompartment(@as(*const ITfThreadMgr2, @ptrCast(self)), pp_comp_mgr_);
            }
            pub inline fn activateEx(self: *const T, ptid_: ?*u32, dw_flags_: u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfThreadMgr2, @ptrCast(self)), ptid_, dw_flags_);
            }
            pub inline fn getActiveFlags(self: *const T, lpdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetActiveFlags(@as(*const ITfThreadMgr2, @ptrCast(self)), lpdw_flags_);
            }
            pub inline fn suspendKeystrokeHandling(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).SuspendKeystrokeHandling(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
            pub inline fn resumeKeystrokeHandling(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).ResumeKeystrokeHandling(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEventSink_Value = Guid.initString("aa80e80e-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgrEventSink = &IID_ITfThreadMgrEventSink_Value;
pub const ITfThreadMgrEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInitDocumentMgr: *const fn (
            self: *const ITfThreadMgrEventSink,
            pdim: ?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUninitDocumentMgr: *const fn (
            self: *const ITfThreadMgrEventSink,
            pdim: ?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSetFocus: *const fn (
            self: *const ITfThreadMgrEventSink,
            pdim_focus: ?*ITfDocumentMgr,
            pdim_prev_focus: ?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPushContext: *const fn (
            self: *const ITfThreadMgrEventSink,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPopContext: *const fn (
            self: *const ITfThreadMgrEventSink,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onInitDocumentMgr(self: *const T, pdim_: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnInitDocumentMgr(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdim_);
            }
            pub inline fn onUninitDocumentMgr(self: *const T, pdim_: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnUninitDocumentMgr(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdim_);
            }
            pub inline fn onSetFocus(self: *const T, pdim_focus_: ?*ITfDocumentMgr, pdim_prev_focus_: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdim_focus_, pdim_prev_focus_);
            }
            pub inline fn onPushContext(self: *const T, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnPushContext(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pic_);
            }
            pub inline fn onPopContext(self: *const T, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnPopContext(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pic_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfConfigureSystemKeystrokeFeed_Value = Guid.initString("0d2c969a-bc9c-437c-84ee-951c49b1a764");
pub const IID_ITfConfigureSystemKeystrokeFeed = &IID_ITfConfigureSystemKeystrokeFeed_Value;
pub const ITfConfigureSystemKeystrokeFeed = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DisableSystemKeystrokeFeed: *const fn (
            self: *const ITfConfigureSystemKeystrokeFeed,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSystemKeystrokeFeed: *const fn (
            self: *const ITfConfigureSystemKeystrokeFeed,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn disableSystemKeystrokeFeed(self: *const T) HRESULT {
                return @as(*const ITfConfigureSystemKeystrokeFeed.VTable, @ptrCast(self.vtable)).DisableSystemKeystrokeFeed(@as(*const ITfConfigureSystemKeystrokeFeed, @ptrCast(self)));
            }
            pub inline fn enableSystemKeystrokeFeed(self: *const T) HRESULT {
                return @as(*const ITfConfigureSystemKeystrokeFeed.VTable, @ptrCast(self.vtable)).EnableSystemKeystrokeFeed(@as(*const ITfConfigureSystemKeystrokeFeed, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDocumentMgrs_Value = Guid.initString("aa80e808-2021-11d2-93e0-0060b067b86e");
pub const IID_IEnumTfDocumentMgrs = &IID_IEnumTfDocumentMgrs_Value;
pub const IEnumTfDocumentMgrs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfDocumentMgrs,
            pp_enum: ?*?*IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfDocumentMgrs,
            ul_count: u32,
            rg_document_mgr: [*]?*ITfDocumentMgr,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfDocumentMgrs,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_document_mgr_: [*]?*ITfDocumentMgr, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), ul_count_, rg_document_mgr_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDocumentMgr_Value = Guid.initString("aa80e7f4-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfDocumentMgr = &IID_ITfDocumentMgr_Value;
pub const ITfDocumentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: *const fn (
            self: *const ITfDocumentMgr,
            tid_owner: u32,
            dw_flags: u32,
            punk: ?*IUnknown,
            ppic: ?*?*ITfContext,
            pec_text_store: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: *const fn (
            self: *const ITfDocumentMgr,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pop: *const fn (
            self: *const ITfDocumentMgr,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTop: *const fn (
            self: *const ITfDocumentMgr,
            ppic: ?*?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBase: *const fn (
            self: *const ITfDocumentMgr,
            ppic: ?*?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumContexts: *const fn (
            self: *const ITfDocumentMgr,
            pp_enum: ?*?*IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createContext(self: *const T, tid_owner_: u32, dw_flags_: u32, punk_: ?*IUnknown, ppic_: ?*?*ITfContext, pec_text_store_: ?*u32) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const ITfDocumentMgr, @ptrCast(self)), tid_owner_, dw_flags_, punk_, ppic_, pec_text_store_);
            }
            pub inline fn push(self: *const T, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).Push(@as(*const ITfDocumentMgr, @ptrCast(self)), pic_);
            }
            pub inline fn pop(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).Pop(@as(*const ITfDocumentMgr, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getTop(self: *const T, ppic_: ?*?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).GetTop(@as(*const ITfDocumentMgr, @ptrCast(self)), ppic_);
            }
            pub inline fn getBase(self: *const T, ppic_: ?*?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).GetBase(@as(*const ITfDocumentMgr, @ptrCast(self)), ppic_);
            }
            pub inline fn enumContexts(self: *const T, pp_enum_: ?*?*IEnumTfContexts) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).EnumContexts(@as(*const ITfDocumentMgr, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfContexts_Value = Guid.initString("8f1a7ea6-1654-4502-a86e-b2902344d507");
pub const IID_IEnumTfContexts = &IID_IEnumTfContexts_Value;
pub const IEnumTfContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfContexts,
            pp_enum: ?*?*IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfContexts,
            ul_count: u32,
            rg_context: [*]?*ITfContext,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfContexts,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfContexts) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfContexts, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_context_: [*]?*ITfContext, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfContexts, @ptrCast(self)), ul_count_, rg_context_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfContexts, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfContexts, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionView_Value = Guid.initString("d7540241-f9a1-4364-befc-dbcd2c4395b7");
pub const IID_ITfCompositionView = &IID_ITfCompositionView_Value;
pub const ITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOwnerClsid: *const fn (
            self: *const ITfCompositionView,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: *const fn (
            self: *const ITfCompositionView,
            pp_range: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getOwnerClsid(self: *const T, pclsid_: ?*Guid) HRESULT {
                return @as(*const ITfCompositionView.VTable, @ptrCast(self.vtable)).GetOwnerClsid(@as(*const ITfCompositionView, @ptrCast(self)), pclsid_);
            }
            pub inline fn getRange(self: *const T, pp_range_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfCompositionView.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITfCompositionView, @ptrCast(self)), pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumITfCompositionView_Value = Guid.initString("5efd22ba-7838-46cb-88e2-cadb14124f8f");
pub const IID_IEnumITfCompositionView = &IID_IEnumITfCompositionView_Value;
pub const IEnumITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumITfCompositionView,
            pp_enum: ?*?*IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumITfCompositionView,
            ul_count: u32,
            rg_composition_view: [*]?*ITfCompositionView,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumITfCompositionView,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumITfCompositionView, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_composition_view_: [*]?*ITfCompositionView, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumITfCompositionView, @ptrCast(self)), ul_count_, rg_composition_view_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumITfCompositionView, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumITfCompositionView, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfComposition_Value = Guid.initString("20168d64-5a8f-4a5a-b7bd-cfa29f4d0fd9");
pub const IID_ITfComposition = &IID_ITfComposition_Value;
pub const ITfComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: *const fn (
            self: *const ITfComposition,
            pp_range: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStart: *const fn (
            self: *const ITfComposition,
            ec_write: u32,
            p_new_start: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEnd: *const fn (
            self: *const ITfComposition,
            ec_write: u32,
            p_new_end: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndComposition: *const fn (
            self: *const ITfComposition,
            ec_write: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRange(self: *const T, pp_range_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITfComposition, @ptrCast(self)), pp_range_);
            }
            pub inline fn shiftStart(self: *const T, ec_write_: u32, p_new_start_: ?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).ShiftStart(@as(*const ITfComposition, @ptrCast(self)), ec_write_, p_new_start_);
            }
            pub inline fn shiftEnd(self: *const T, ec_write_: u32, p_new_end_: ?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).ShiftEnd(@as(*const ITfComposition, @ptrCast(self)), ec_write_, p_new_end_);
            }
            pub inline fn endComposition(self: *const T, ec_write_: u32) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).EndComposition(@as(*const ITfComposition, @ptrCast(self)), ec_write_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionSink_Value = Guid.initString("a781718c-579a-4b15-a280-32b8577acc5e");
pub const IID_ITfCompositionSink = &IID_ITfCompositionSink_Value;
pub const ITfCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCompositionTerminated: *const fn (
            self: *const ITfCompositionSink,
            ec_write: u32,
            p_composition: ?*ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onCompositionTerminated(self: *const T, ec_write_: u32, p_composition_: ?*ITfComposition) HRESULT {
                return @as(*const ITfCompositionSink.VTable, @ptrCast(self.vtable)).OnCompositionTerminated(@as(*const ITfCompositionSink, @ptrCast(self)), ec_write_, p_composition_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextComposition_Value = Guid.initString("d40c8aae-ac92-4fc7-9a11-0ee0e23aa39b");
pub const IID_ITfContextComposition = &IID_ITfContextComposition_Value;
pub const ITfContextComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartComposition: *const fn (
            self: *const ITfContextComposition,
            ec_write: u32,
            p_composition_range: ?*ITfRange,
            p_sink: ?*ITfCompositionSink,
            pp_composition: ?*?*ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCompositions: *const fn (
            self: *const ITfContextComposition,
            pp_enum: ?*?*IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindComposition: *const fn (
            self: *const ITfContextComposition,
            ec_read: u32,
            p_test_range: ?*ITfRange,
            pp_enum: ?*?*IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TakeOwnership: *const fn (
            self: *const ITfContextComposition,
            ec_write: u32,
            p_composition: ?*ITfCompositionView,
            p_sink: ?*ITfCompositionSink,
            pp_composition: ?*?*ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startComposition(self: *const T, ec_write_: u32, p_composition_range_: ?*ITfRange, p_sink_: ?*ITfCompositionSink, pp_composition_: ?*?*ITfComposition) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).StartComposition(@as(*const ITfContextComposition, @ptrCast(self)), ec_write_, p_composition_range_, p_sink_, pp_composition_);
            }
            pub inline fn enumCompositions(self: *const T, pp_enum_: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).EnumCompositions(@as(*const ITfContextComposition, @ptrCast(self)), pp_enum_);
            }
            pub inline fn findComposition(self: *const T, ec_read_: u32, p_test_range_: ?*ITfRange, pp_enum_: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).FindComposition(@as(*const ITfContextComposition, @ptrCast(self)), ec_read_, p_test_range_, pp_enum_);
            }
            pub inline fn takeOwnership(self: *const T, ec_write_: u32, p_composition_: ?*ITfCompositionView, p_sink_: ?*ITfCompositionSink, pp_composition_: ?*?*ITfComposition) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).TakeOwnership(@as(*const ITfContextComposition, @ptrCast(self)), ec_write_, p_composition_, p_sink_, pp_composition_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionServices_Value = Guid.initString("86462810-593b-4916-9764-19c08e9ce110");
pub const IID_ITfContextOwnerCompositionServices = &IID_ITfContextOwnerCompositionServices_Value;
pub const ITfContextOwnerCompositionServices = extern struct {
    pub const VTable = extern struct {
        base: ITfContextComposition.VTable,
        TerminateComposition: *const fn (
            self: *const ITfContextOwnerCompositionServices,
            p_composition: ?*ITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfContextComposition.MethodMixin(T);
            pub inline fn terminateComposition(self: *const T, p_composition_: ?*ITfCompositionView) HRESULT {
                return @as(*const ITfContextOwnerCompositionServices.VTable, @ptrCast(self.vtable)).TerminateComposition(@as(*const ITfContextOwnerCompositionServices, @ptrCast(self)), p_composition_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionSink_Value = Guid.initString("5f20aa40-b57a-4f34-96ab-3576f377cc79");
pub const IID_ITfContextOwnerCompositionSink = &IID_ITfContextOwnerCompositionSink_Value;
pub const ITfContextOwnerCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartComposition: *const fn (
            self: *const ITfContextOwnerCompositionSink,
            p_composition: ?*ITfCompositionView,
            pf_ok: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateComposition: *const fn (
            self: *const ITfContextOwnerCompositionSink,
            p_composition: ?*ITfCompositionView,
            p_range_new: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndComposition: *const fn (
            self: *const ITfContextOwnerCompositionSink,
            p_composition: ?*ITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onStartComposition(self: *const T, p_composition_: ?*ITfCompositionView, pf_ok_: ?*BOOL) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnStartComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), p_composition_, pf_ok_);
            }
            pub inline fn onUpdateComposition(self: *const T, p_composition_: ?*ITfCompositionView, p_range_new_: ?*ITfRange) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnUpdateComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), p_composition_, p_range_new_);
            }
            pub inline fn onEndComposition(self: *const T, p_composition_: ?*ITfCompositionView) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnEndComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), p_composition_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextView_Value = Guid.initString("2433bf8e-0f9b-435c-ba2c-180611978c30");
pub const IID_ITfContextView = &IID_ITfContextView_Value;
pub const ITfContextView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeFromPoint: *const fn (
            self: *const ITfContextView,
            ec: u32,
            ppt: ?*const POINT,
            dw_flags: u32,
            pp_range: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: *const fn (
            self: *const ITfContextView,
            ec: u32,
            p_range: ?*ITfRange,
            prc: ?*RECT,
            pf_clipped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: *const fn (
            self: *const ITfContextView,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: *const fn (
            self: *const ITfContextView,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRangeFromPoint(self: *const T, ec_: u32, ppt_: ?*const POINT, dw_flags_: u32, pp_range_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetRangeFromPoint(@as(*const ITfContextView, @ptrCast(self)), ec_, ppt_, dw_flags_, pp_range_);
            }
            pub inline fn getTextExt(self: *const T, ec_: u32, p_range_: ?*ITfRange, prc_: ?*RECT, pf_clipped_: ?*BOOL) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITfContextView, @ptrCast(self)), ec_, p_range_, prc_, pf_clipped_);
            }
            pub inline fn getScreenExt(self: *const T, prc_: ?*RECT) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITfContextView, @ptrCast(self)), prc_);
            }
            pub inline fn getWnd(self: *const T, phwnd_: ?*?HWND) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITfContextView, @ptrCast(self)), phwnd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTfContextViews_Value = Guid.initString("f0c0f8dd-cf38-44e1-bb0f-68cf0d551c78");
pub const IID_IEnumTfContextViews = &IID_IEnumTfContextViews_Value;
pub const IEnumTfContextViews = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfContextViews,
            pp_enum: ?*?*IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfContextViews,
            ul_count: u32,
            rg_views: [*]?*ITfContextView,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfContextViews,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfContextViews) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfContextViews, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_views_: [*]?*ITfContextView, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfContextViews, @ptrCast(self)), ul_count_, rg_views_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfContextViews, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfContextViews, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfActiveSelEnd = enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TF_AE_NONE = TfActiveSelEnd.NONE;
pub const TF_AE_START = TfActiveSelEnd.START;
pub const TF_AE_END = TfActiveSelEnd.END;

pub const TF_SELECTIONSTYLE = extern struct {
    ase: TfActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TF_SELECTION = extern struct {
    range: ?*ITfRange,
    style: TF_SELECTIONSTYLE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContext_Value = Guid.initString("aa80e7fd-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContext = &IID_ITfContext_Value;
pub const ITfContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestEditSession: *const fn (
            self: *const ITfContext,
            tid: u32,
            pes: ?*ITfEditSession,
            dw_flags: TF_CONTEXT_EDIT_CONTEXT_FLAGS,
            phr_session: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InWriteSession: *const fn (
            self: *const ITfContext,
            tid: u32,
            pf_write_session: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITfContext,
            ec: u32,
            ul_index: u32,
            ul_count: u32,
            p_selection: [*]TF_SELECTION,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const ITfContext,
            ec: u32,
            ul_count: u32,
            p_selection: [*]const TF_SELECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: *const fn (
            self: *const ITfContext,
            ec: u32,
            pp_start: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: *const fn (
            self: *const ITfContext,
            ec: u32,
            pp_end: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: *const fn (
            self: *const ITfContext,
            pp_view: ?*?*ITfContextView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumViews: *const fn (
            self: *const ITfContext,
            pp_enum: ?*?*IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITfContext,
            pdcs: ?*TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITfContext,
            guid_prop: ?*const Guid,
            pp_prop: ?*?*ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppProperty: *const fn (
            self: *const ITfContext,
            guid_prop: ?*const Guid,
            pp_prop: ?*?*ITfReadOnlyProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TrackProperties: *const fn (
            self: *const ITfContext,
            prg_prop: [*]const ?*const Guid,
            c_prop: u32,
            prg_app_prop: [*]const ?*const Guid,
            c_app_prop: u32,
            pp_property: ?*?*ITfReadOnlyProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProperties: *const fn (
            self: *const ITfContext,
            pp_enum: ?*?*IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentMgr: *const fn (
            self: *const ITfContext,
            pp_dm: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRangeBackup: *const fn (
            self: *const ITfContext,
            ec: u32,
            p_range: ?*ITfRange,
            pp_backup: ?*?*ITfRangeBackup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn requestEditSession(self: *const T, tid_: u32, pes_: ?*ITfEditSession, dw_flags_: TF_CONTEXT_EDIT_CONTEXT_FLAGS, phr_session_: ?*HRESULT) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).RequestEditSession(@as(*const ITfContext, @ptrCast(self)), tid_, pes_, dw_flags_, phr_session_);
            }
            pub inline fn inWriteSession(self: *const T, tid_: u32, pf_write_session_: ?*BOOL) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).InWriteSession(@as(*const ITfContext, @ptrCast(self)), tid_, pf_write_session_);
            }
            pub inline fn getSelection(self: *const T, ec_: u32, ul_index_: u32, ul_count_: u32, p_selection_: [*]TF_SELECTION, pc_fetched_: ?*u32) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITfContext, @ptrCast(self)), ec_, ul_index_, ul_count_, p_selection_, pc_fetched_);
            }
            pub inline fn setSelection(self: *const T, ec_: u32, ul_count_: u32, p_selection_: [*]const TF_SELECTION) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITfContext, @ptrCast(self)), ec_, ul_count_, p_selection_);
            }
            pub inline fn getStart(self: *const T, ec_: u32, pp_start_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITfContext, @ptrCast(self)), ec_, pp_start_);
            }
            pub inline fn getEnd(self: *const T, ec_: u32, pp_end_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITfContext, @ptrCast(self)), ec_, pp_end_);
            }
            pub inline fn getActiveView(self: *const T, pp_view_: ?*?*ITfContextView) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITfContext, @ptrCast(self)), pp_view_);
            }
            pub inline fn enumViews(self: *const T, pp_enum_: ?*?*IEnumTfContextViews) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).EnumViews(@as(*const ITfContext, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getStatus(self: *const T, pdcs_: ?*TS_STATUS) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfContext, @ptrCast(self)), pdcs_);
            }
            pub inline fn getProperty(self: *const T, guid_prop_: ?*const Guid, pp_prop_: ?*?*ITfProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITfContext, @ptrCast(self)), guid_prop_, pp_prop_);
            }
            pub inline fn getAppProperty(self: *const T, guid_prop_: ?*const Guid, pp_prop_: ?*?*ITfReadOnlyProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetAppProperty(@as(*const ITfContext, @ptrCast(self)), guid_prop_, pp_prop_);
            }
            pub inline fn trackProperties(self: *const T, prg_prop_: [*]const ?*const Guid, c_prop_: u32, prg_app_prop_: [*]const ?*const Guid, c_app_prop_: u32, pp_property_: ?*?*ITfReadOnlyProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).TrackProperties(@as(*const ITfContext, @ptrCast(self)), prg_prop_, c_prop_, prg_app_prop_, c_app_prop_, pp_property_);
            }
            pub inline fn enumProperties(self: *const T, pp_enum_: ?*?*IEnumTfProperties) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).EnumProperties(@as(*const ITfContext, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getDocumentMgr(self: *const T, pp_dm_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfContext, @ptrCast(self)), pp_dm_);
            }
            pub inline fn createRangeBackup(self: *const T, ec_: u32, p_range_: ?*ITfRange, pp_backup_: ?*?*ITfRangeBackup) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).CreateRangeBackup(@as(*const ITfContext, @ptrCast(self)), ec_, p_range_, pp_backup_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfQueryEmbedded_Value = Guid.initString("0fab9bdb-d250-4169-84e5-6be118fdd7a8");
pub const IID_ITfQueryEmbedded = &IID_ITfQueryEmbedded_Value;
pub const ITfQueryEmbedded = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInsertEmbedded: *const fn (
            self: *const ITfQueryEmbedded,
            pguid_service: ?*const Guid,
            p_format_etc: ?*const FORMATETC,
            pf_insertable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryInsertEmbedded(self: *const T, pguid_service_: ?*const Guid, p_format_etc_: ?*const FORMATETC, pf_insertable_: ?*BOOL) HRESULT {
                return @as(*const ITfQueryEmbedded.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITfQueryEmbedded, @ptrCast(self)), pguid_service_, p_format_etc_, pf_insertable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInsertAtSelection_Value = Guid.initString("55ce16ba-3014-41c1-9ceb-fade1446ac6c");
pub const IID_ITfInsertAtSelection = &IID_ITfInsertAtSelection_Value;
pub const ITfInsertAtSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertTextAtSelection: *const fn (
            self: *const ITfInsertAtSelection,
            ec: u32,
            dw_flags: INSERT_TEXT_AT_SELECTION_FLAGS,
            pch_text: [*:0]const u16,
            cch: i32,
            pp_range: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: *const fn (
            self: *const ITfInsertAtSelection,
            ec: u32,
            dw_flags: u32,
            p_data_object: ?*IDataObject,
            pp_range: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn insertTextAtSelection(self: *const T, ec_: u32, dw_flags_: INSERT_TEXT_AT_SELECTION_FLAGS, pch_text_: [*:0]const u16, cch_: i32, pp_range_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfInsertAtSelection.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITfInsertAtSelection, @ptrCast(self)), ec_, dw_flags_, pch_text_, cch_, pp_range_);
            }
            pub inline fn insertEmbeddedAtSelection(self: *const T, ec_: u32, dw_flags_: u32, p_data_object_: ?*IDataObject, pp_range_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfInsertAtSelection.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITfInsertAtSelection, @ptrCast(self)), ec_, dw_flags_, p_data_object_, pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextSink_Value = Guid.initString("01689689-7acb-4e9b-ab7c-7ea46b12b522");
pub const IID_ITfCleanupContextSink = &IID_ITfCleanupContextSink_Value;
pub const ITfCleanupContextSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCleanupContext: *const fn (
            self: *const ITfCleanupContextSink,
            ec_write: u32,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onCleanupContext(self: *const T, ec_write_: u32, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfCleanupContextSink.VTable, @ptrCast(self.vtable)).OnCleanupContext(@as(*const ITfCleanupContextSink, @ptrCast(self)), ec_write_, pic_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextDurationSink_Value = Guid.initString("45c35144-154e-4797-bed8-d33ae7bf8794");
pub const IID_ITfCleanupContextDurationSink = &IID_ITfCleanupContextDurationSink_Value;
pub const ITfCleanupContextDurationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartCleanupContext: *const fn (
            self: *const ITfCleanupContextDurationSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndCleanupContext: *const fn (
            self: *const ITfCleanupContextDurationSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onStartCleanupContext(self: *const T) HRESULT {
                return @as(*const ITfCleanupContextDurationSink.VTable, @ptrCast(self.vtable)).OnStartCleanupContext(@as(*const ITfCleanupContextDurationSink, @ptrCast(self)));
            }
            pub inline fn onEndCleanupContext(self: *const T) HRESULT {
                return @as(*const ITfCleanupContextDurationSink.VTable, @ptrCast(self.vtable)).OnEndCleanupContext(@as(*const ITfCleanupContextDurationSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadOnlyProperty_Value = Guid.initString("17d49a3d-f8b8-4b2f-b254-52319dd64c53");
pub const IID_ITfReadOnlyProperty = &IID_ITfReadOnlyProperty_Value;
pub const ITfReadOnlyProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: *const fn (
            self: *const ITfReadOnlyProperty,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRanges: *const fn (
            self: *const ITfReadOnlyProperty,
            ec: u32,
            pp_enum: ?*?*IEnumTfRanges,
            p_target_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: *const fn (
            self: *const ITfReadOnlyProperty,
            ec: u32,
            p_range: ?*ITfRange,
            pvar_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: *const fn (
            self: *const ITfReadOnlyProperty,
            pp_context: ?*?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getType(self: *const T, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfReadOnlyProperty, @ptrCast(self)), pguid_);
            }
            pub inline fn enumRanges(self: *const T, ec_: u32, pp_enum_: ?*?*IEnumTfRanges, p_target_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).EnumRanges(@as(*const ITfReadOnlyProperty, @ptrCast(self)), ec_, pp_enum_, p_target_range_);
            }
            pub inline fn getValue(self: *const T, ec_: u32, p_range_: ?*ITfRange, pvar_value_: ?*VARIANT) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ITfReadOnlyProperty, @ptrCast(self)), ec_, p_range_, pvar_value_);
            }
            pub inline fn getContext(self: *const T, pp_context_: ?*?*ITfContext) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfReadOnlyProperty, @ptrCast(self)), pp_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PROPERTYVAL = extern struct {
    guidId: Guid,
    varValue: VARIANT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfPropertyValue_Value = Guid.initString("8ed8981b-7c10-4d7d-9fb3-ab72e9c75f72");
pub const IID_IEnumTfPropertyValue = &IID_IEnumTfPropertyValue_Value;
pub const IEnumTfPropertyValue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfPropertyValue,
            pp_enum: ?*?*IEnumTfPropertyValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfPropertyValue,
            ul_count: u32,
            rg_values: [*]TF_PROPERTYVAL,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfPropertyValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfPropertyValue,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfPropertyValue) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfPropertyValue, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_values_: [*]TF_PROPERTYVAL, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfPropertyValue, @ptrCast(self)), ul_count_, rg_values_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfPropertyValue, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfPropertyValue, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTracker_Value = Guid.initString("09d146cd-a544-4132-925b-7afa8ef322d0");
pub const IID_ITfMouseTracker = &IID_ITfMouseTracker_Value;
pub const ITfMouseTracker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: *const fn (
            self: *const ITfMouseTracker,
            range: ?*ITfRange,
            p_sink: ?*ITfMouseSink,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseMouseSink: *const fn (
            self: *const ITfMouseTracker,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseMouseSink(self: *const T, range_: ?*ITfRange, p_sink_: ?*ITfMouseSink, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const ITfMouseTracker.VTable, @ptrCast(self.vtable)).AdviseMouseSink(@as(*const ITfMouseTracker, @ptrCast(self)), range_, p_sink_, pdw_cookie_);
            }
            pub inline fn unadviseMouseSink(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ITfMouseTracker.VTable, @ptrCast(self.vtable)).UnadviseMouseSink(@as(*const ITfMouseTracker, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTrackerACP_Value = Guid.initString("3bdd78e2-c16e-47fd-b883-ce6facc1a208");
pub const IID_ITfMouseTrackerACP = &IID_ITfMouseTrackerACP_Value;
pub const ITfMouseTrackerACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: *const fn (
            self: *const ITfMouseTrackerACP,
            range: ?*ITfRangeACP,
            p_sink: ?*ITfMouseSink,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseMouseSink: *const fn (
            self: *const ITfMouseTrackerACP,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseMouseSink(self: *const T, range_: ?*ITfRangeACP, p_sink_: ?*ITfMouseSink, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const ITfMouseTrackerACP.VTable, @ptrCast(self.vtable)).AdviseMouseSink(@as(*const ITfMouseTrackerACP, @ptrCast(self)), range_, p_sink_, pdw_cookie_);
            }
            pub inline fn unadviseMouseSink(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ITfMouseTrackerACP.VTable, @ptrCast(self.vtable)).UnadviseMouseSink(@as(*const ITfMouseTrackerACP, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseSink_Value = Guid.initString("a1adaaa2-3a24-449d-ac96-5183e7f5c217");
pub const IID_ITfMouseSink = &IID_ITfMouseSink_Value;
pub const ITfMouseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMouseEvent: *const fn (
            self: *const ITfMouseSink,
            u_edge: u32,
            u_quadrant: u32,
            dw_btn_status: u32,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onMouseEvent(self: *const T, u_edge_: u32, u_quadrant_: u32, dw_btn_status_: u32, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfMouseSink.VTable, @ptrCast(self.vtable)).OnMouseEvent(@as(*const ITfMouseSink, @ptrCast(self)), u_edge_, u_quadrant_, dw_btn_status_, pf_eaten_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditRecord_Value = Guid.initString("42d4d099-7c1a-4a89-b836-6c6f22160df0");
pub const IID_ITfEditRecord = &IID_ITfEditRecord_Value;
pub const ITfEditRecord = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelectionStatus: *const fn (
            self: *const ITfEditRecord,
            pf_changed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextAndPropertyUpdates: *const fn (
            self: *const ITfEditRecord,
            dw_flags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS,
            prg_properties: [*]const ?*const Guid,
            c_properties: u32,
            pp_enum: ?*?*IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSelectionStatus(self: *const T, pf_changed_: ?*BOOL) HRESULT {
                return @as(*const ITfEditRecord.VTable, @ptrCast(self.vtable)).GetSelectionStatus(@as(*const ITfEditRecord, @ptrCast(self)), pf_changed_);
            }
            pub inline fn getTextAndPropertyUpdates(self: *const T, dw_flags_: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS, prg_properties_: [*]const ?*const Guid, c_properties_: u32, pp_enum_: ?*?*IEnumTfRanges) HRESULT {
                return @as(*const ITfEditRecord.VTable, @ptrCast(self.vtable)).GetTextAndPropertyUpdates(@as(*const ITfEditRecord, @ptrCast(self)), dw_flags_, prg_properties_, c_properties_, pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextEditSink_Value = Guid.initString("8127d409-ccd3-4683-967a-b43d5b482bf7");
pub const IID_ITfTextEditSink = &IID_ITfTextEditSink_Value;
pub const ITfTextEditSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEndEdit: *const fn (
            self: *const ITfTextEditSink,
            pic: ?*ITfContext,
            ec_read_only: u32,
            p_edit_record: ?*ITfEditRecord,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onEndEdit(self: *const T, pic_: ?*ITfContext, ec_read_only_: u32, p_edit_record_: ?*ITfEditRecord) HRESULT {
                return @as(*const ITfTextEditSink.VTable, @ptrCast(self.vtable)).OnEndEdit(@as(*const ITfTextEditSink, @ptrCast(self)), pic_, ec_read_only_, p_edit_record_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLayoutCode = enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TF_LC_CREATE = TfLayoutCode.CREATE;
pub const TF_LC_CHANGE = TfLayoutCode.CHANGE;
pub const TF_LC_DESTROY = TfLayoutCode.DESTROY;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextLayoutSink_Value = Guid.initString("2af2d06a-dd5b-4927-a0b4-54f19c91fade");
pub const IID_ITfTextLayoutSink = &IID_ITfTextLayoutSink_Value;
pub const ITfTextLayoutSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: *const fn (
            self: *const ITfTextLayoutSink,
            pic: ?*ITfContext,
            lcode: TfLayoutCode,
            p_view: ?*ITfContextView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onLayoutChange(self: *const T, pic_: ?*ITfContext, lcode_: TfLayoutCode, p_view_: ?*ITfContextView) HRESULT {
                return @as(*const ITfTextLayoutSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITfTextLayoutSink, @ptrCast(self)), pic_, lcode_, p_view_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfStatusSink_Value = Guid.initString("6b7d8d73-b267-4f69-b32e-1ca321ce4f45");
pub const IID_ITfStatusSink = &IID_ITfStatusSink_Value;
pub const ITfStatusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatusChange: *const fn (
            self: *const ITfStatusSink,
            pic: ?*ITfContext,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onStatusChange(self: *const T, pic_: ?*ITfContext, dw_flags_: u32) HRESULT {
                return @as(*const ITfStatusSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITfStatusSink, @ptrCast(self)), pic_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditTransactionSink_Value = Guid.initString("708fbf70-b520-416b-b06c-2c41ab44f8ba");
pub const IID_ITfEditTransactionSink = &IID_ITfEditTransactionSink_Value;
pub const ITfEditTransactionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartEditTransaction: *const fn (
            self: *const ITfEditTransactionSink,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: *const fn (
            self: *const ITfEditTransactionSink,
            pic: ?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onStartEditTransaction(self: *const T, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfEditTransactionSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITfEditTransactionSink, @ptrCast(self)), pic_);
            }
            pub inline fn onEndEditTransaction(self: *const T, pic_: ?*ITfContext) HRESULT {
                return @as(*const ITfEditTransactionSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITfEditTransactionSink, @ptrCast(self)), pic_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwner_Value = Guid.initString("aa80e80c-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContextOwner = &IID_ITfContextOwner_Value;
pub const ITfContextOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetACPFromPoint: *const fn (
            self: *const ITfContextOwner,
            pt_screen: ?*const POINT,
            dw_flags: u32,
            pacp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: *const fn (
            self: *const ITfContextOwner,
            acp_start: i32,
            acp_end: i32,
            prc: ?*RECT,
            pf_clipped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: *const fn (
            self: *const ITfContextOwner,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ITfContextOwner,
            pdcs: ?*TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: *const fn (
            self: *const ITfContextOwner,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttribute: *const fn (
            self: *const ITfContextOwner,
            rguid_attribute: ?*const Guid,
            pvar_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getACPFromPoint(self: *const T, pt_screen_: ?*const POINT, dw_flags_: u32, pacp_: ?*i32) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITfContextOwner, @ptrCast(self)), pt_screen_, dw_flags_, pacp_);
            }
            pub inline fn getTextExt(self: *const T, acp_start_: i32, acp_end_: i32, prc_: ?*RECT, pf_clipped_: ?*BOOL) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITfContextOwner, @ptrCast(self)), acp_start_, acp_end_, prc_, pf_clipped_);
            }
            pub inline fn getScreenExt(self: *const T, prc_: ?*RECT) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITfContextOwner, @ptrCast(self)), prc_);
            }
            pub inline fn getStatus(self: *const T, pdcs_: ?*TS_STATUS) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfContextOwner, @ptrCast(self)), pdcs_);
            }
            pub inline fn getWnd(self: *const T, phwnd_: ?*?HWND) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITfContextOwner, @ptrCast(self)), phwnd_);
            }
            pub inline fn getAttribute(self: *const T, rguid_attribute_: ?*const Guid, pvar_value_: ?*VARIANT) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetAttribute(@as(*const ITfContextOwner, @ptrCast(self)), rguid_attribute_, pvar_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerServices_Value = Guid.initString("b23eb630-3e1c-11d3-a745-0050040ab407");
pub const IID_ITfContextOwnerServices = &IID_ITfContextOwnerServices_Value;
pub const ITfContextOwnerServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: *const fn (
            self: *const ITfContextOwnerServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: *const fn (
            self: *const ITfContextOwnerServices,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttributeChange: *const fn (
            self: *const ITfContextOwnerServices,
            rguid_attribute: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Serialize: *const fn (
            self: *const ITfContextOwnerServices,
            p_prop: ?*ITfProperty,
            p_range: ?*ITfRange,
            p_hdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
            p_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unserialize: *const fn (
            self: *const ITfContextOwnerServices,
            p_prop: ?*ITfProperty,
            p_hdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            p_stream: ?*IStream,
            p_loader: ?*ITfPersistentPropertyLoaderACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceLoadProperty: *const fn (
            self: *const ITfContextOwnerServices,
            p_prop: ?*ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRange: *const fn (
            self: *const ITfContextOwnerServices,
            acp_start: i32,
            acp_end: i32,
            pp_range: ?*?*ITfRangeACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onLayoutChange(self: *const T) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITfContextOwnerServices, @ptrCast(self)));
            }
            pub inline fn onStatusChange(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITfContextOwnerServices, @ptrCast(self)), dw_flags_);
            }
            pub inline fn onAttributeChange(self: *const T, rguid_attribute_: ?*const Guid) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnAttributeChange(@as(*const ITfContextOwnerServices, @ptrCast(self)), rguid_attribute_);
            }
            pub inline fn serialize(self: *const T, p_prop_: ?*ITfProperty, p_range_: ?*ITfRange, p_hdr_: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP, p_stream_: ?*IStream) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITfContextOwnerServices, @ptrCast(self)), p_prop_, p_range_, p_hdr_, p_stream_);
            }
            pub inline fn unserialize(self: *const T, p_prop_: ?*ITfProperty, p_hdr_: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, p_stream_: ?*IStream, p_loader_: ?*ITfPersistentPropertyLoaderACP) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).Unserialize(@as(*const ITfContextOwnerServices, @ptrCast(self)), p_prop_, p_hdr_, p_stream_, p_loader_);
            }
            pub inline fn forceLoadProperty(self: *const T, p_prop_: ?*ITfProperty) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).ForceLoadProperty(@as(*const ITfContextOwnerServices, @ptrCast(self)), p_prop_);
            }
            pub inline fn createRange(self: *const T, acp_start_: i32, acp_end_: i32, pp_range_: ?*?*ITfRangeACP) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).CreateRange(@as(*const ITfContextOwnerServices, @ptrCast(self)), acp_start_, acp_end_, pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextKeyEventSink_Value = Guid.initString("0552ba5d-c835-4934-bf50-846aaa67432f");
pub const IID_ITfContextKeyEventSink = &IID_ITfContextKeyEventSink_Value;
pub const ITfContextKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyDown: *const fn (
            self: *const ITfContextKeyEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyUp: *const fn (
            self: *const ITfContextKeyEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyDown: *const fn (
            self: *const ITfContextKeyEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyUp: *const fn (
            self: *const ITfContextKeyEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onKeyDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfContextKeyEventSink, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onKeyUp(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyUp(@as(*const ITfContextKeyEventSink, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onTestKeyDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyDown(@as(*const ITfContextKeyEventSink, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onTestKeyUp(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyUp(@as(*const ITfContextKeyEventSink, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditSession_Value = Guid.initString("aa80e803-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfEditSession = &IID_ITfEditSession_Value;
pub const ITfEditSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoEditSession: *const fn (
            self: *const ITfEditSession,
            ec: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn doEditSession(self: *const T, ec_: u32) HRESULT {
                return @as(*const ITfEditSession.VTable, @ptrCast(self.vtable)).DoEditSession(@as(*const ITfEditSession, @ptrCast(self)), ec_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfGravity = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_GRAVITY_BACKWARD = TfGravity.BACKWARD;
pub const TF_GRAVITY_FORWARD = TfGravity.FORWARD;

pub const TfShiftDir = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_SD_BACKWARD = TfShiftDir.BACKWARD;
pub const TF_SD_FORWARD = TfShiftDir.FORWARD;

pub const TF_HALTCOND = extern struct {
    pHaltRange: ?*ITfRange,
    aHaltPos: TfAnchor,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRange_Value = Guid.initString("aa80e7ff-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfRange = &IID_ITfRange_Value;
pub const ITfRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetText: *const fn (
            self: *const ITfRange,
            ec: u32,
            dw_flags: u32,
            pch_text: [*:0]u16,
            cch_max: u32,
            pcch: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITfRange,
            ec: u32,
            dw_flags: u32,
            pch_text: [*:0]const u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: *const fn (
            self: *const ITfRange,
            ec: u32,
            pp_data_object: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: *const fn (
            self: *const ITfRange,
            ec: u32,
            rguid_service: ?*const Guid,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: *const fn (
            self: *const ITfRange,
            ec: u32,
            dw_flags: u32,
            p_data_object: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStart: *const fn (
            self: *const ITfRange,
            ec: u32,
            cch_req: i32,
            pcch: ?*i32,
            p_halt: ?*const TF_HALTCOND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEnd: *const fn (
            self: *const ITfRange,
            ec: u32,
            cch_req: i32,
            pcch: ?*i32,
            p_halt: ?*const TF_HALTCOND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStartToRange: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_range: ?*ITfRange,
            a_pos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEndToRange: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_range: ?*ITfRange,
            a_pos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStartRegion: *const fn (
            self: *const ITfRange,
            ec: u32,
            dir: TfShiftDir,
            pf_no_region: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEndRegion: *const fn (
            self: *const ITfRange,
            ec: u32,
            dir: TfShiftDir,
            pf_no_region: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEmpty: *const fn (
            self: *const ITfRange,
            ec: u32,
            pf_empty: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: *const fn (
            self: *const ITfRange,
            ec: u32,
            a_pos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualStart: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_with: ?*ITfRange,
            a_pos: TfAnchor,
            pf_equal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualEnd: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_with: ?*ITfRange,
            a_pos: TfAnchor,
            pf_equal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareStart: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_with: ?*ITfRange,
            a_pos: TfAnchor,
            pl_result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEnd: *const fn (
            self: *const ITfRange,
            ec: u32,
            p_with: ?*ITfRange,
            a_pos: TfAnchor,
            pl_result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdjustForInsert: *const fn (
            self: *const ITfRange,
            ec: u32,
            cch_insert: u32,
            pf_insert_ok: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: *const fn (
            self: *const ITfRange,
            pg_start: ?*TfGravity,
            pg_end: ?*TfGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: *const fn (
            self: *const ITfRange,
            ec: u32,
            g_start: TfGravity,
            g_end: TfGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ITfRange,
            pp_clone: ?*?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: *const fn (
            self: *const ITfRange,
            pp_context: ?*?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getText(self: *const T, ec_: u32, dw_flags_: u32, pch_text_: [*:0]u16, cch_max_: u32, pcch_: ?*u32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfRange, @ptrCast(self)), ec_, dw_flags_, pch_text_, cch_max_, pcch_);
            }
            pub inline fn setText(self: *const T, ec_: u32, dw_flags_: u32, pch_text_: [*:0]const u16, cch_: i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITfRange, @ptrCast(self)), ec_, dw_flags_, pch_text_, cch_);
            }
            pub inline fn getFormattedText(self: *const T, ec_: u32, pp_data_object_: ?*?*IDataObject) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITfRange, @ptrCast(self)), ec_, pp_data_object_);
            }
            pub inline fn getEmbedded(self: *const T, ec_: u32, rguid_service_: ?*const Guid, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITfRange, @ptrCast(self)), ec_, rguid_service_, riid_, ppunk_);
            }
            pub inline fn insertEmbedded(self: *const T, ec_: u32, dw_flags_: u32, p_data_object_: ?*IDataObject) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITfRange, @ptrCast(self)), ec_, dw_flags_, p_data_object_);
            }
            pub inline fn shiftStart(self: *const T, ec_: u32, cch_req_: i32, pcch_: ?*i32, p_halt_: ?*const TF_HALTCOND) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStart(@as(*const ITfRange, @ptrCast(self)), ec_, cch_req_, pcch_, p_halt_);
            }
            pub inline fn shiftEnd(self: *const T, ec_: u32, cch_req_: i32, pcch_: ?*i32, p_halt_: ?*const TF_HALTCOND) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEnd(@as(*const ITfRange, @ptrCast(self)), ec_, cch_req_, pcch_, p_halt_);
            }
            pub inline fn shiftStartToRange(self: *const T, ec_: u32, p_range_: ?*ITfRange, a_pos_: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStartToRange(@as(*const ITfRange, @ptrCast(self)), ec_, p_range_, a_pos_);
            }
            pub inline fn shiftEndToRange(self: *const T, ec_: u32, p_range_: ?*ITfRange, a_pos_: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEndToRange(@as(*const ITfRange, @ptrCast(self)), ec_, p_range_, a_pos_);
            }
            pub inline fn shiftStartRegion(self: *const T, ec_: u32, dir_: TfShiftDir, pf_no_region_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStartRegion(@as(*const ITfRange, @ptrCast(self)), ec_, dir_, pf_no_region_);
            }
            pub inline fn shiftEndRegion(self: *const T, ec_: u32, dir_: TfShiftDir, pf_no_region_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEndRegion(@as(*const ITfRange, @ptrCast(self)), ec_, dir_, pf_no_region_);
            }
            pub inline fn isEmpty(self: *const T, ec_: u32, pf_empty_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEmpty(@as(*const ITfRange, @ptrCast(self)), ec_, pf_empty_);
            }
            pub inline fn collapse(self: *const T, ec_: u32, a_pos_: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).Collapse(@as(*const ITfRange, @ptrCast(self)), ec_, a_pos_);
            }
            pub inline fn isEqualStart(self: *const T, ec_: u32, p_with_: ?*ITfRange, a_pos_: TfAnchor, pf_equal_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEqualStart(@as(*const ITfRange, @ptrCast(self)), ec_, p_with_, a_pos_, pf_equal_);
            }
            pub inline fn isEqualEnd(self: *const T, ec_: u32, p_with_: ?*ITfRange, a_pos_: TfAnchor, pf_equal_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEqualEnd(@as(*const ITfRange, @ptrCast(self)), ec_, p_with_, a_pos_, pf_equal_);
            }
            pub inline fn compareStart(self: *const T, ec_: u32, p_with_: ?*ITfRange, a_pos_: TfAnchor, pl_result_: ?*i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).CompareStart(@as(*const ITfRange, @ptrCast(self)), ec_, p_with_, a_pos_, pl_result_);
            }
            pub inline fn compareEnd(self: *const T, ec_: u32, p_with_: ?*ITfRange, a_pos_: TfAnchor, pl_result_: ?*i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).CompareEnd(@as(*const ITfRange, @ptrCast(self)), ec_, p_with_, a_pos_, pl_result_);
            }
            pub inline fn adjustForInsert(self: *const T, ec_: u32, cch_insert_: u32, pf_insert_ok_: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).AdjustForInsert(@as(*const ITfRange, @ptrCast(self)), ec_, cch_insert_, pf_insert_ok_);
            }
            pub inline fn getGravity(self: *const T, pg_start_: ?*TfGravity, pg_end_: ?*TfGravity) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const ITfRange, @ptrCast(self)), pg_start_, pg_end_);
            }
            pub inline fn setGravity(self: *const T, ec_: u32, g_start_: TfGravity, g_end_: TfGravity) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const ITfRange, @ptrCast(self)), ec_, g_start_, g_end_);
            }
            pub inline fn clone(self: *const T, pp_clone_: ?*?*ITfRange) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITfRange, @ptrCast(self)), pp_clone_);
            }
            pub inline fn getContext(self: *const T, pp_context_: ?*?*ITfContext) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfRange, @ptrCast(self)), pp_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeACP_Value = Guid.initString("057a6296-029b-4154-b79a-0d461d4ea94c");
pub const IID_ITfRangeACP = &IID_ITfRangeACP_Value;
pub const ITfRangeACP = extern struct {
    pub const VTable = extern struct {
        base: ITfRange.VTable,
        GetExtent: *const fn (
            self: *const ITfRangeACP,
            pacp_anchor: ?*i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtent: *const fn (
            self: *const ITfRangeACP,
            acp_anchor: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfRange.MethodMixin(T);
            pub inline fn getExtent(self: *const T, pacp_anchor_: ?*i32, pcch_: ?*i32) HRESULT {
                return @as(*const ITfRangeACP.VTable, @ptrCast(self.vtable)).GetExtent(@as(*const ITfRangeACP, @ptrCast(self)), pacp_anchor_, pcch_);
            }
            pub inline fn setExtent(self: *const T, acp_anchor_: i32, cch_: i32) HRESULT {
                return @as(*const ITfRangeACP.VTable, @ptrCast(self.vtable)).SetExtent(@as(*const ITfRangeACP, @ptrCast(self)), acp_anchor_, cch_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPServices_Value = Guid.initString("aa80e901-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreACPServices = &IID_ITextStoreACPServices_Value;
pub const ITextStoreACPServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Serialize: *const fn (
            self: *const ITextStoreACPServices,
            p_prop: ?*ITfProperty,
            p_range: ?*ITfRange,
            p_hdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
            p_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unserialize: *const fn (
            self: *const ITextStoreACPServices,
            p_prop: ?*ITfProperty,
            p_hdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            p_stream: ?*IStream,
            p_loader: ?*ITfPersistentPropertyLoaderACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceLoadProperty: *const fn (
            self: *const ITextStoreACPServices,
            p_prop: ?*ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRange: *const fn (
            self: *const ITextStoreACPServices,
            acp_start: i32,
            acp_end: i32,
            pp_range: ?*?*ITfRangeACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn serialize(self: *const T, p_prop_: ?*ITfProperty, p_range_: ?*ITfRange, p_hdr_: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP, p_stream_: ?*IStream) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITextStoreACPServices, @ptrCast(self)), p_prop_, p_range_, p_hdr_, p_stream_);
            }
            pub inline fn unserialize(self: *const T, p_prop_: ?*ITfProperty, p_hdr_: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, p_stream_: ?*IStream, p_loader_: ?*ITfPersistentPropertyLoaderACP) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).Unserialize(@as(*const ITextStoreACPServices, @ptrCast(self)), p_prop_, p_hdr_, p_stream_, p_loader_);
            }
            pub inline fn forceLoadProperty(self: *const T, p_prop_: ?*ITfProperty) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).ForceLoadProperty(@as(*const ITextStoreACPServices, @ptrCast(self)), p_prop_);
            }
            pub inline fn createRange(self: *const T, acp_start_: i32, acp_end_: i32, pp_range_: ?*?*ITfRangeACP) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).CreateRange(@as(*const ITextStoreACPServices, @ptrCast(self)), acp_start_, acp_end_, pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeBackup_Value = Guid.initString("463a506d-6992-49d2-9b88-93d55e70bb16");
pub const IID_ITfRangeBackup = &IID_ITfRangeBackup_Value;
pub const ITfRangeBackup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Restore: *const fn (
            self: *const ITfRangeBackup,
            ec: u32,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn restore(self: *const T, ec_: u32, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfRangeBackup.VTable, @ptrCast(self.vtable)).Restore(@as(*const ITfRangeBackup, @ptrCast(self)), ec_, p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPropertyStore_Value = Guid.initString("6834b120-88cb-11d2-bf45-00105a2799b5");
pub const IID_ITfPropertyStore = &IID_ITfPropertyStore_Value;
pub const ITfPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: *const fn (
            self: *const ITfPropertyStore,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataType: *const fn (
            self: *const ITfPropertyStore,
            pdw_reserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const ITfPropertyStore,
            pvar_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTextUpdated: *const fn (
            self: *const ITfPropertyStore,
            dw_flags: u32,
            p_range_new: ?*ITfRange,
            pf_accept: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shrink: *const fn (
            self: *const ITfPropertyStore,
            p_range_new: ?*ITfRange,
            pf_free: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Divide: *const fn (
            self: *const ITfPropertyStore,
            p_range_this: ?*ITfRange,
            p_range_new: ?*ITfRange,
            pp_prop_store: ?*?*ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ITfPropertyStore,
            p_prop_store: ?*?*ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyRangeCreator: *const fn (
            self: *const ITfPropertyStore,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Serialize: *const fn (
            self: *const ITfPropertyStore,
            p_stream: ?*IStream,
            pcb: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getType(self: *const T, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfPropertyStore, @ptrCast(self)), pguid_);
            }
            pub inline fn getDataType(self: *const T, pdw_reserved_: ?*u32) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetDataType(@as(*const ITfPropertyStore, @ptrCast(self)), pdw_reserved_);
            }
            pub inline fn getData(self: *const T, pvar_value_: ?*VARIANT) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetData(@as(*const ITfPropertyStore, @ptrCast(self)), pvar_value_);
            }
            pub inline fn onTextUpdated(self: *const T, dw_flags_: u32, p_range_new_: ?*ITfRange, pf_accept_: ?*BOOL) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).OnTextUpdated(@as(*const ITfPropertyStore, @ptrCast(self)), dw_flags_, p_range_new_, pf_accept_);
            }
            pub inline fn shrink(self: *const T, p_range_new_: ?*ITfRange, pf_free_: ?*BOOL) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Shrink(@as(*const ITfPropertyStore, @ptrCast(self)), p_range_new_, pf_free_);
            }
            pub inline fn divide(self: *const T, p_range_this_: ?*ITfRange, p_range_new_: ?*ITfRange, pp_prop_store_: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Divide(@as(*const ITfPropertyStore, @ptrCast(self)), p_range_this_, p_range_new_, pp_prop_store_);
            }
            pub inline fn clone(self: *const T, p_prop_store_: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITfPropertyStore, @ptrCast(self)), p_prop_store_);
            }
            pub inline fn getPropertyRangeCreator(self: *const T, pclsid_: ?*Guid) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetPropertyRangeCreator(@as(*const ITfPropertyStore, @ptrCast(self)), pclsid_);
            }
            pub inline fn serialize(self: *const T, p_stream_: ?*IStream, pcb_: ?*u32) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITfPropertyStore, @ptrCast(self)), p_stream_, pcb_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfRanges_Value = Guid.initString("f99d3f40-8e32-11d2-bf46-00105a2799b5");
pub const IID_IEnumTfRanges = &IID_IEnumTfRanges_Value;
pub const IEnumTfRanges = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfRanges,
            pp_enum: ?*?*IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfRanges,
            ul_count: u32,
            pp_range: [*]?*ITfRange,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfRanges,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfRanges) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfRanges, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_range_: [*]?*ITfRange, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfRanges, @ptrCast(self)), ul_count_, pp_range_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfRanges, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfRanges, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCreatePropertyStore_Value = Guid.initString("2463fbf0-b0af-11d2-afc5-00105a2799b5");
pub const IID_ITfCreatePropertyStore = &IID_ITfCreatePropertyStore_Value;
pub const ITfCreatePropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStoreSerializable: *const fn (
            self: *const ITfCreatePropertyStore,
            guid_prop: ?*const Guid,
            p_range: ?*ITfRange,
            p_prop_store: ?*ITfPropertyStore,
            pf_serializable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyStore: *const fn (
            self: *const ITfCreatePropertyStore,
            guid_prop: ?*const Guid,
            p_range: ?*ITfRange,
            cb: u32,
            p_stream: ?*IStream,
            pp_store: ?*?*ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isStoreSerializable(self: *const T, guid_prop_: ?*const Guid, p_range_: ?*ITfRange, p_prop_store_: ?*ITfPropertyStore, pf_serializable_: ?*BOOL) HRESULT {
                return @as(*const ITfCreatePropertyStore.VTable, @ptrCast(self.vtable)).IsStoreSerializable(@as(*const ITfCreatePropertyStore, @ptrCast(self)), guid_prop_, p_range_, p_prop_store_, pf_serializable_);
            }
            pub inline fn createPropertyStore(self: *const T, guid_prop_: ?*const Guid, p_range_: ?*ITfRange, cb_: u32, p_stream_: ?*IStream, pp_store_: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfCreatePropertyStore.VTable, @ptrCast(self.vtable)).CreatePropertyStore(@as(*const ITfCreatePropertyStore, @ptrCast(self)), guid_prop_, p_range_, cb_, p_stream_, pp_store_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPersistentPropertyLoaderACP_Value = Guid.initString("4ef89150-0807-11d3-8df0-00105a2799b5");
pub const IID_ITfPersistentPropertyLoaderACP = &IID_ITfPersistentPropertyLoaderACP_Value;
pub const ITfPersistentPropertyLoaderACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadProperty: *const fn (
            self: *const ITfPersistentPropertyLoaderACP,
            p_hdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            pp_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn loadProperty(self: *const T, p_hdr_: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, pp_stream_: ?*?*IStream) HRESULT {
                return @as(*const ITfPersistentPropertyLoaderACP.VTable, @ptrCast(self.vtable)).LoadProperty(@as(*const ITfPersistentPropertyLoaderACP, @ptrCast(self)), p_hdr_, pp_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfProperty_Value = Guid.initString("e2449660-9542-11d2-bf46-00105a2799b5");
pub const IID_ITfProperty = &IID_ITfProperty_Value;
pub const ITfProperty = extern struct {
    pub const VTable = extern struct {
        base: ITfReadOnlyProperty.VTable,
        FindRange: *const fn (
            self: *const ITfProperty,
            ec: u32,
            p_range: ?*ITfRange,
            pp_range: ?*?*ITfRange,
            a_pos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueStore: *const fn (
            self: *const ITfProperty,
            ec: u32,
            p_range: ?*ITfRange,
            p_prop_store: ?*ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: *const fn (
            self: *const ITfProperty,
            ec: u32,
            p_range: ?*ITfRange,
            pvar_value: ?*const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: *const fn (
            self: *const ITfProperty,
            ec: u32,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfReadOnlyProperty.MethodMixin(T);
            pub inline fn findRange(self: *const T, ec_: u32, p_range_: ?*ITfRange, pp_range_: ?*?*ITfRange, a_pos_: TfAnchor) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).FindRange(@as(*const ITfProperty, @ptrCast(self)), ec_, p_range_, pp_range_, a_pos_);
            }
            pub inline fn setValueStore(self: *const T, ec_: u32, p_range_: ?*ITfRange, p_prop_store_: ?*ITfPropertyStore) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).SetValueStore(@as(*const ITfProperty, @ptrCast(self)), ec_, p_range_, p_prop_store_);
            }
            pub inline fn setValue(self: *const T, ec_: u32, p_range_: ?*ITfRange, pvar_value_: ?*const VARIANT) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ITfProperty, @ptrCast(self)), ec_, p_range_, pvar_value_);
            }
            pub inline fn clear(self: *const T, ec_: u32, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).Clear(@as(*const ITfProperty, @ptrCast(self)), ec_, p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfProperties_Value = Guid.initString("19188cb0-aca9-11d2-afc5-00105a2799b5");
pub const IID_IEnumTfProperties = &IID_IEnumTfProperties_Value;
pub const IEnumTfProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfProperties,
            pp_enum: ?*?*IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfProperties,
            ul_count: u32,
            pp_prop: [*]?*ITfProperty,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfProperties,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfProperties) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfProperties, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_prop_: [*]?*ITfProperty, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfProperties, @ptrCast(self)), ul_count_, pp_prop_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfProperties, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfProperties, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartment_Value = Guid.initString("bb08f7a9-607a-4384-8623-056892b64371");
pub const IID_ITfCompartment = &IID_ITfCompartment_Value;
pub const ITfCompartment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: *const fn (
            self: *const ITfCompartment,
            tid: u32,
            pvar_value: ?*const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: *const fn (
            self: *const ITfCompartment,
            pvar_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setValue(self: *const T, tid_: u32, pvar_value_: ?*const VARIANT) HRESULT {
                return @as(*const ITfCompartment.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ITfCompartment, @ptrCast(self)), tid_, pvar_value_);
            }
            pub inline fn getValue(self: *const T, pvar_value_: ?*VARIANT) HRESULT {
                return @as(*const ITfCompartment.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ITfCompartment, @ptrCast(self)), pvar_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentEventSink_Value = Guid.initString("743abd5f-f26d-48df-8cc5-238492419b64");
pub const IID_ITfCompartmentEventSink = &IID_ITfCompartmentEventSink_Value;
pub const ITfCompartmentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: *const fn (
            self: *const ITfCompartmentEventSink,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onChange(self: *const T, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCompartmentEventSink.VTable, @ptrCast(self.vtable)).OnChange(@as(*const ITfCompartmentEventSink, @ptrCast(self)), rguid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentMgr_Value = Guid.initString("7dcf57ac-18ad-438b-824d-979bffb74b7c");
pub const IID_ITfCompartmentMgr = &IID_ITfCompartmentMgr_Value;
pub const ITfCompartmentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCompartment: *const fn (
            self: *const ITfCompartmentMgr,
            rguid: ?*const Guid,
            ppcomp: ?*?*ITfCompartment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearCompartment: *const fn (
            self: *const ITfCompartmentMgr,
            tid: u32,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCompartments: *const fn (
            self: *const ITfCompartmentMgr,
            pp_enum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCompartment(self: *const T, rguid_: ?*const Guid, ppcomp_: ?*?*ITfCompartment) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).GetCompartment(@as(*const ITfCompartmentMgr, @ptrCast(self)), rguid_, ppcomp_);
            }
            pub inline fn clearCompartment(self: *const T, tid_: u32, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).ClearCompartment(@as(*const ITfCompartmentMgr, @ptrCast(self)), tid_, rguid_);
            }
            pub inline fn enumCompartments(self: *const T, pp_enum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).EnumCompartments(@as(*const ITfCompartmentMgr, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunction_Value = Guid.initString("db593490-098f-11d3-8df0-00105a2799b5");
pub const IID_ITfFunction = &IID_ITfFunction_Value;
pub const ITfFunction = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayName: *const fn (
            self: *const ITfFunction,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDisplayName(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const ITfFunction.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const ITfFunction, @ptrCast(self)), pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunctionProvider_Value = Guid.initString("101d6610-0990-11d3-8df0-00105a2799b5");
pub const IID_ITfFunctionProvider = &IID_ITfFunctionProvider_Value;
pub const ITfFunctionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: *const fn (
            self: *const ITfFunctionProvider,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: *const fn (
            self: *const ITfFunctionProvider,
            pbstr_desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunction: *const fn (
            self: *const ITfFunctionProvider,
            rguid: ?*const Guid,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getType(self: *const T, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfFunctionProvider, @ptrCast(self)), pguid_);
            }
            pub inline fn getDescription(self: *const T, pbstr_desc_: ?*?BSTR) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfFunctionProvider, @ptrCast(self)), pbstr_desc_);
            }
            pub inline fn getFunction(self: *const T, rguid_: ?*const Guid, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetFunction(@as(*const ITfFunctionProvider, @ptrCast(self)), rguid_, riid_, ppunk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfFunctionProviders_Value = Guid.initString("e4b24db0-0990-11d3-8df0-00105a2799b5");
pub const IID_IEnumTfFunctionProviders = &IID_IEnumTfFunctionProviders_Value;
pub const IEnumTfFunctionProviders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfFunctionProviders,
            pp_enum: ?*?*IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfFunctionProviders,
            ul_count: u32,
            pp_cmdobj: [*]?*ITfFunctionProvider,
            pc_fetch: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfFunctionProviders,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_cmdobj_: [*]?*ITfFunctionProvider, pc_fetch_: ?*u32) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), ul_count_, pp_cmdobj_, pc_fetch_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfFunctionProviders, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfiles_Value = Guid.initString("1f02b6c5-7842-4ee6-8a0b-9a24183a95ca");
pub const IID_ITfInputProcessorProfiles = &IID_ITfInputProcessorProfiles_Value;
pub const ITfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            pch_desc: [*:0]const u16,
            cch_desc: u32,
            pch_icon_file: [*:0]const u16,
            cch_file: u32,
            u_icon_index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputProcessorInfo: *const fn (
            self: *const ITfInputProcessorProfiles,
            pp_enum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            catid: ?*const Guid,
            pclsid: ?*Guid,
            pguid_profile: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            rclsid: ?*const Guid,
            guid_profiles: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profiles: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            plangid: ?*u16,
            pguid_profile: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageProfileDescription: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            pbstr_profile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLanguage: *const fn (
            self: *const ITfInputProcessorProfiles,
            plangid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentLanguage: *const fn (
            self: *const ITfInputProcessorProfiles,
            langid: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageList: *const fn (
            self: *const ITfInputProcessorProfiles,
            pp_lang_id: [*]?*u16,
            pul_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumLanguageProfiles: *const fn (
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            pp_enum: ?*?*IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            f_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEnabledLanguageProfile: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            pf_enable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableLanguageProfileByDefault: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            f_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubstituteKeyboardLayout: *const fn (
            self: *const ITfInputProcessorProfiles,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            h_k_l: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T, rclsid_: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Register(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_);
            }
            pub inline fn unregister(self: *const T, rclsid_: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Unregister(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_);
            }
            pub inline fn addLanguageProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, pch_desc_: [*:0]const u16, cch_desc_: u32, pch_icon_file_: [*:0]const u16, cch_file_: u32, u_icon_index_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).AddLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, pch_desc_, cch_desc_, pch_icon_file_, cch_file_, u_icon_index_);
            }
            pub inline fn removeLanguageProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).RemoveLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_);
            }
            pub inline fn enumInputProcessorInfo(self: *const T, pp_enum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnumInputProcessorInfo(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getDefaultLanguageProfile(self: *const T, langid_: u16, catid_: ?*const Guid, pclsid_: ?*Guid, pguid_profile_: ?*Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetDefaultLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid_, catid_, pclsid_, pguid_profile_);
            }
            pub inline fn setDefaultLanguageProfile(self: *const T, langid_: u16, rclsid_: ?*const Guid, guid_profiles_: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).SetDefaultLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid_, rclsid_, guid_profiles_);
            }
            pub inline fn activateLanguageProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profiles_: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).ActivateLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profiles_);
            }
            pub inline fn getActiveLanguageProfile(self: *const T, rclsid_: ?*const Guid, plangid_: ?*u16, pguid_profile_: ?*Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetActiveLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, plangid_, pguid_profile_);
            }
            pub inline fn getLanguageProfileDescription(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, pbstr_profile_: ?*?BSTR) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetLanguageProfileDescription(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, pbstr_profile_);
            }
            pub inline fn getCurrentLanguage(self: *const T, plangid_: ?*u16) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetCurrentLanguage(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), plangid_);
            }
            pub inline fn changeCurrentLanguage(self: *const T, langid_: u16) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).ChangeCurrentLanguage(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid_);
            }
            pub inline fn getLanguageList(self: *const T, pp_lang_id_: [*]?*u16, pul_count_: ?*u32) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetLanguageList(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), pp_lang_id_, pul_count_);
            }
            pub inline fn enumLanguageProfiles(self: *const T, langid_: u16, pp_enum_: ?*?*IEnumTfLanguageProfiles) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnumLanguageProfiles(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid_, pp_enum_);
            }
            pub inline fn enableLanguageProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, f_enable_: BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnableLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, f_enable_);
            }
            pub inline fn isEnabledLanguageProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, pf_enable_: ?*BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).IsEnabledLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, pf_enable_);
            }
            pub inline fn enableLanguageProfileByDefault(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, f_enable_: BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnableLanguageProfileByDefault(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, f_enable_);
            }
            pub inline fn substituteKeyboardLayout(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, h_k_l_: ?HKL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).SubstituteKeyboardLayout(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid_, langid_, guid_profile_, h_k_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfilesEx_Value = Guid.initString("892f230f-fe00-4a41-a98e-fcd6de0d35ef");
pub const IID_ITfInputProcessorProfilesEx = &IID_ITfInputProcessorProfilesEx_Value;
pub const ITfInputProcessorProfilesEx = extern struct {
    pub const VTable = extern struct {
        base: ITfInputProcessorProfiles.VTable,
        SetLanguageProfileDisplayName: *const fn (
            self: *const ITfInputProcessorProfilesEx,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            pch_file: [*:0]const u16,
            cch_file: u32,
            u_res_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfInputProcessorProfiles.MethodMixin(T);
            pub inline fn setLanguageProfileDisplayName(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, pch_file_: [*:0]const u16, cch_file_: u32, u_res_id_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfilesEx.VTable, @ptrCast(self.vtable)).SetLanguageProfileDisplayName(@as(*const ITfInputProcessorProfilesEx, @ptrCast(self)), rclsid_, langid_, guid_profile_, pch_file_, cch_file_, u_res_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileSubstituteLayout_Value = Guid.initString("4fd67194-1002-4513-bff2-c0ddf6258552");
pub const IID_ITfInputProcessorProfileSubstituteLayout = &IID_ITfInputProcessorProfileSubstituteLayout_Value;
pub const ITfInputProcessorProfileSubstituteLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubstituteKeyboardLayout: *const fn (
            self: *const ITfInputProcessorProfileSubstituteLayout,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSubstituteKeyboardLayout(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const ITfInputProcessorProfileSubstituteLayout.VTable, @ptrCast(self.vtable)).GetSubstituteKeyboardLayout(@as(*const ITfInputProcessorProfileSubstituteLayout, @ptrCast(self)), rclsid_, langid_, guid_profile_, ph_k_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfActiveLanguageProfileNotifySink_Value = Guid.initString("b246cb75-a93e-4652-bf8c-b3fe0cfd7e57");
pub const IID_ITfActiveLanguageProfileNotifySink = &IID_ITfActiveLanguageProfileNotifySink_Value;
pub const ITfActiveLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: *const fn (
            self: *const ITfActiveLanguageProfileNotifySink,
            clsid: ?*const Guid,
            guid_profile: ?*const Guid,
            f_activated: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onActivated(self: *const T, clsid_: ?*const Guid, guid_profile_: ?*const Guid, f_activated_: BOOL) HRESULT {
                return @as(*const ITfActiveLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnActivated(@as(*const ITfActiveLanguageProfileNotifySink, @ptrCast(self)), clsid_, guid_profile_, f_activated_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLanguageProfiles_Value = Guid.initString("3d61bf11-ac5f-42c8-a4cb-931bcc28c744");
pub const IID_IEnumTfLanguageProfiles = &IID_IEnumTfLanguageProfiles_Value;
pub const IEnumTfLanguageProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfLanguageProfiles,
            pp_enum: ?*?*IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfLanguageProfiles,
            ul_count: u32,
            p_profile: [*]TF_LANGUAGEPROFILE,
            pc_fetch: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfLanguageProfiles,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfLanguageProfiles) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, p_profile_: [*]TF_LANGUAGEPROFILE, pc_fetch_: ?*u32) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), ul_count_, p_profile_, pc_fetch_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLanguageProfileNotifySink_Value = Guid.initString("43c9fe15-f494-4c17-9de2-b8a4ac350aa8");
pub const IID_ITfLanguageProfileNotifySink = &IID_ITfLanguageProfileNotifySink_Value;
pub const ITfLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLanguageChange: *const fn (
            self: *const ITfLanguageProfileNotifySink,
            langid: u16,
            pf_accept: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLanguageChanged: *const fn (
            self: *const ITfLanguageProfileNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onLanguageChange(self: *const T, langid_: u16, pf_accept_: ?*BOOL) HRESULT {
                return @as(*const ITfLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnLanguageChange(@as(*const ITfLanguageProfileNotifySink, @ptrCast(self)), langid_, pf_accept_);
            }
            pub inline fn onLanguageChanged(self: *const T) HRESULT {
                return @as(*const ITfLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnLanguageChanged(@as(*const ITfLanguageProfileNotifySink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_INPUTPROCESSORPROFILE = extern struct {
    dwProfileType: u32,
    langid: u16,
    clsid: Guid,
    guidProfile: Guid,
    catid: Guid,
    hklSubstitute: ?HKL,
    dwCaps: u32,
    hkl: ?HKL,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfInputProcessorProfileMgr_Value = Guid.initString("71c6e74c-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileMgr = &IID_ITfInputProcessorProfileMgr_Value;
pub const ITfInputProcessorProfileMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            dw_profile_type: u32,
            langid: u16,
            clsid: ?*const Guid,
            guid_profile: ?*const Guid,
            hkl: ?HKL,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeactivateProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            dw_profile_type: u32,
            langid: u16,
            clsid: ?*const Guid,
            guid_profile: ?*const Guid,
            hkl: ?HKL,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            dw_profile_type: u32,
            langid: u16,
            clsid: ?*const Guid,
            guid_profile: ?*const Guid,
            hkl: ?HKL,
            p_profile: ?*TF_INPUTPROCESSORPROFILE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProfiles: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            langid: u16,
            pp_enum: ?*?*IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseInputProcessor: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            rclsid: ?*const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            pch_desc: [*:0]const u16,
            cch_desc: u32,
            pch_icon_file: [*:0]const u16,
            cch_file: u32,
            u_icon_index: u32,
            hklsubstitute: ?HKL,
            dw_preferred_layout: u32,
            b_enabled_by_default: BOOL,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            rclsid: ?*const Guid,
            langid: u16,
            guid_profile: ?*const Guid,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveProfile: *const fn (
            self: *const ITfInputProcessorProfileMgr,
            catid: ?*const Guid,
            p_profile: ?*TF_INPUTPROCESSORPROFILE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activateProfile(self: *const T, dw_profile_type_: u32, langid_: u16, clsid_: ?*const Guid, guid_profile_: ?*const Guid, hkl_: ?HKL, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).ActivateProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dw_profile_type_, langid_, clsid_, guid_profile_, hkl_, dw_flags_);
            }
            pub inline fn deactivateProfile(self: *const T, dw_profile_type_: u32, langid_: u16, clsid_: ?*const Guid, guid_profile_: ?*const Guid, hkl_: ?HKL, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).DeactivateProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dw_profile_type_, langid_, clsid_, guid_profile_, hkl_, dw_flags_);
            }
            pub inline fn getProfile(self: *const T, dw_profile_type_: u32, langid_: u16, clsid_: ?*const Guid, guid_profile_: ?*const Guid, hkl_: ?HKL, p_profile_: ?*TF_INPUTPROCESSORPROFILE) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dw_profile_type_, langid_, clsid_, guid_profile_, hkl_, p_profile_);
            }
            pub inline fn enumProfiles(self: *const T, langid_: u16, pp_enum_: ?*?*IEnumTfInputProcessorProfiles) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).EnumProfiles(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), langid_, pp_enum_);
            }
            pub inline fn releaseInputProcessor(self: *const T, rclsid_: ?*const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).ReleaseInputProcessor(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid_, dw_flags_);
            }
            pub inline fn registerProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, pch_desc_: [*:0]const u16, cch_desc_: u32, pch_icon_file_: [*:0]const u16, cch_file_: u32, u_icon_index_: u32, hklsubstitute_: ?HKL, dw_preferred_layout_: u32, b_enabled_by_default_: BOOL, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).RegisterProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid_, langid_, guid_profile_, pch_desc_, cch_desc_, pch_icon_file_, cch_file_, u_icon_index_, hklsubstitute_, dw_preferred_layout_, b_enabled_by_default_, dw_flags_);
            }
            pub inline fn unregisterProfile(self: *const T, rclsid_: ?*const Guid, langid_: u16, guid_profile_: ?*const Guid, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).UnregisterProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid_, langid_, guid_profile_, dw_flags_);
            }
            pub inline fn getActiveProfile(self: *const T, catid_: ?*const Guid, p_profile_: ?*TF_INPUTPROCESSORPROFILE) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).GetActiveProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), catid_, p_profile_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfInputProcessorProfiles_Value = Guid.initString("71c6e74d-0f28-11d8-a82a-00065b84435c");
pub const IID_IEnumTfInputProcessorProfiles = &IID_IEnumTfInputProcessorProfiles_Value;
pub const IEnumTfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfInputProcessorProfiles,
            pp_enum: ?*?*IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfInputProcessorProfiles,
            ul_count: u32,
            p_profile: [*]TF_INPUTPROCESSORPROFILE,
            pc_fetch: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfInputProcessorProfiles,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfInputProcessorProfiles) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, p_profile_: [*]TF_INPUTPROCESSORPROFILE, pc_fetch_: ?*u32) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), ul_count_, p_profile_, pc_fetch_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileActivationSink_Value = Guid.initString("71c6e74e-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileActivationSink = &IID_ITfInputProcessorProfileActivationSink_Value;
pub const ITfInputProcessorProfileActivationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: *const fn (
            self: *const ITfInputProcessorProfileActivationSink,
            dw_profile_type: u32,
            langid: u16,
            clsid: ?*const Guid,
            catid: ?*const Guid,
            guid_profile: ?*const Guid,
            hkl: ?HKL,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onActivated(self: *const T, dw_profile_type_: u32, langid_: u16, clsid_: ?*const Guid, catid_: ?*const Guid, guid_profile_: ?*const Guid, hkl_: ?HKL, dw_flags_: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileActivationSink.VTable, @ptrCast(self.vtable)).OnActivated(@as(*const ITfInputProcessorProfileActivationSink, @ptrCast(self)), dw_profile_type_, langid_, clsid_, catid_, guid_profile_, hkl_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PRESERVEDKEY = extern struct {
    uVKey: u32,
    uModifiers: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeystrokeMgr_Value = Guid.initString("aa80e7f0-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeystrokeMgr = &IID_ITfKeystrokeMgr_Value;
pub const ITfKeystrokeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseKeyEventSink: *const fn (
            self: *const ITfKeystrokeMgr,
            tid: u32,
            p_sink: ?*ITfKeyEventSink,
            f_foreground: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseKeyEventSink: *const fn (
            self: *const ITfKeystrokeMgr,
            tid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeground: *const fn (
            self: *const ITfKeystrokeMgr,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestKeyDown: *const fn (
            self: *const ITfKeystrokeMgr,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestKeyUp: *const fn (
            self: *const ITfKeystrokeMgr,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyDown: *const fn (
            self: *const ITfKeystrokeMgr,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyUp: *const fn (
            self: *const ITfKeystrokeMgr,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreservedKey: *const fn (
            self: *const ITfKeystrokeMgr,
            pic: ?*ITfContext,
            pprekey: ?*const TF_PRESERVEDKEY,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreservedKey: *const fn (
            self: *const ITfKeystrokeMgr,
            rguid: ?*const Guid,
            pprekey: ?*const TF_PRESERVEDKEY,
            pf_registered: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreserveKey: *const fn (
            self: *const ITfKeystrokeMgr,
            tid: u32,
            rguid: ?*const Guid,
            prekey: ?*const TF_PRESERVEDKEY,
            pch_desc: [*:0]const u16,
            cch_desc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnpreserveKey: *const fn (
            self: *const ITfKeystrokeMgr,
            rguid: ?*const Guid,
            pprekey: ?*const TF_PRESERVEDKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreservedKeyDescription: *const fn (
            self: *const ITfKeystrokeMgr,
            rguid: ?*const Guid,
            pch_desc: [*:0]const u16,
            cch_desc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreservedKeyDescription: *const fn (
            self: *const ITfKeystrokeMgr,
            rguid: ?*const Guid,
            pbstr_desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulatePreservedKey: *const fn (
            self: *const ITfKeystrokeMgr,
            pic: ?*ITfContext,
            rguid: ?*const Guid,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseKeyEventSink(self: *const T, tid_: u32, p_sink_: ?*ITfKeyEventSink, f_foreground_: BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).AdviseKeyEventSink(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid_, p_sink_, f_foreground_);
            }
            pub inline fn unadviseKeyEventSink(self: *const T, tid_: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).UnadviseKeyEventSink(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid_);
            }
            pub inline fn getForeground(self: *const T, pclsid_: ?*Guid) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetForeground(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pclsid_);
            }
            pub inline fn testKeyDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).TestKeyDown(@as(*const ITfKeystrokeMgr, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn testKeyUp(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).TestKeyUp(@as(*const ITfKeystrokeMgr, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn keyDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).KeyDown(@as(*const ITfKeystrokeMgr, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn keyUp(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).KeyUp(@as(*const ITfKeystrokeMgr, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn getPreservedKey(self: *const T, pic_: ?*ITfContext, pprekey_: ?*const TF_PRESERVEDKEY, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetPreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pic_, pprekey_, pguid_);
            }
            pub inline fn isPreservedKey(self: *const T, rguid_: ?*const Guid, pprekey_: ?*const TF_PRESERVEDKEY, pf_registered_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).IsPreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid_, pprekey_, pf_registered_);
            }
            pub inline fn preserveKey(self: *const T, tid_: u32, rguid_: ?*const Guid, prekey_: ?*const TF_PRESERVEDKEY, pch_desc_: [*:0]const u16, cch_desc_: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).PreserveKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid_, rguid_, prekey_, pch_desc_, cch_desc_);
            }
            pub inline fn unpreserveKey(self: *const T, rguid_: ?*const Guid, pprekey_: ?*const TF_PRESERVEDKEY) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).UnpreserveKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid_, pprekey_);
            }
            pub inline fn setPreservedKeyDescription(self: *const T, rguid_: ?*const Guid, pch_desc_: [*:0]const u16, cch_desc_: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).SetPreservedKeyDescription(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid_, pch_desc_, cch_desc_);
            }
            pub inline fn getPreservedKeyDescription(self: *const T, rguid_: ?*const Guid, pbstr_desc_: ?*?BSTR) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetPreservedKeyDescription(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid_, pbstr_desc_);
            }
            pub inline fn simulatePreservedKey(self: *const T, pic_: ?*ITfContext, rguid_: ?*const Guid, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).SimulatePreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pic_, rguid_, pf_eaten_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyEventSink_Value = Guid.initString("aa80e7f5-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeyEventSink = &IID_ITfKeyEventSink_Value;
pub const ITfKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: *const fn (
            self: *const ITfKeyEventSink,
            f_foreground: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyDown: *const fn (
            self: *const ITfKeyEventSink,
            pic: ?*ITfContext,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyUp: *const fn (
            self: *const ITfKeyEventSink,
            pic: ?*ITfContext,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyDown: *const fn (
            self: *const ITfKeyEventSink,
            pic: ?*ITfContext,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyUp: *const fn (
            self: *const ITfKeyEventSink,
            pic: ?*ITfContext,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPreservedKey: *const fn (
            self: *const ITfKeyEventSink,
            pic: ?*ITfContext,
            rguid: ?*const Guid,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onSetFocus(self: *const T, f_foreground_: BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfKeyEventSink, @ptrCast(self)), f_foreground_);
            }
            pub inline fn onTestKeyDown(self: *const T, pic_: ?*ITfContext, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyDown(@as(*const ITfKeyEventSink, @ptrCast(self)), pic_, w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onTestKeyUp(self: *const T, pic_: ?*ITfContext, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyUp(@as(*const ITfKeyEventSink, @ptrCast(self)), pic_, w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onKeyDown(self: *const T, pic_: ?*ITfContext, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfKeyEventSink, @ptrCast(self)), pic_, w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onKeyUp(self: *const T, pic_: ?*ITfContext, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyUp(@as(*const ITfKeyEventSink, @ptrCast(self)), pic_, w_param_, l_param_, pf_eaten_);
            }
            pub inline fn onPreservedKey(self: *const T, pic_: ?*ITfContext, rguid_: ?*const Guid, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnPreservedKey(@as(*const ITfKeyEventSink, @ptrCast(self)), pic_, rguid_, pf_eaten_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyTraceEventSink_Value = Guid.initString("1cd4c13b-1c36-4191-a70a-7f3e611f367d");
pub const IID_ITfKeyTraceEventSink = &IID_ITfKeyTraceEventSink_Value;
pub const ITfKeyTraceEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyTraceDown: *const fn (
            self: *const ITfKeyTraceEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyTraceUp: *const fn (
            self: *const ITfKeyTraceEventSink,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onKeyTraceDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ITfKeyTraceEventSink.VTable, @ptrCast(self.vtable)).OnKeyTraceDown(@as(*const ITfKeyTraceEventSink, @ptrCast(self)), w_param_, l_param_);
            }
            pub inline fn onKeyTraceUp(self: *const T, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ITfKeyTraceEventSink.VTable, @ptrCast(self.vtable)).OnKeyTraceUp(@as(*const ITfKeyTraceEventSink, @ptrCast(self)), w_param_, l_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPreservedKeyNotifySink_Value = Guid.initString("6f77c993-d2b1-446e-853e-5912efc8a286");
pub const IID_ITfPreservedKeyNotifySink = &IID_ITfPreservedKeyNotifySink_Value;
pub const ITfPreservedKeyNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdated: *const fn (
            self: *const ITfPreservedKeyNotifySink,
            pprekey: ?*const TF_PRESERVEDKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUpdated(self: *const T, pprekey_: ?*const TF_PRESERVEDKEY) HRESULT {
                return @as(*const ITfPreservedKeyNotifySink.VTable, @ptrCast(self.vtable)).OnUpdated(@as(*const ITfPreservedKeyNotifySink, @ptrCast(self)), pprekey_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMessagePump_Value = Guid.initString("8f1b8ad8-0b6b-4874-90c5-bd76011e8f7c");
pub const IID_ITfMessagePump = &IID_ITfMessagePump_Value;
pub const ITfMessagePump = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PeekMessageA: *const fn (
            self: *const ITfMessagePump,
            p_msg: ?*MSG,
            hwnd: ?HWND,
            w_msg_filter_min: u32,
            w_msg_filter_max: u32,
            w_remove_msg: u32,
            pf_result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageA: *const fn (
            self: *const ITfMessagePump,
            p_msg: ?*MSG,
            hwnd: ?HWND,
            w_msg_filter_min: u32,
            w_msg_filter_max: u32,
            pf_result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PeekMessageW: *const fn (
            self: *const ITfMessagePump,
            p_msg: ?*MSG,
            hwnd: ?HWND,
            w_msg_filter_min: u32,
            w_msg_filter_max: u32,
            w_remove_msg: u32,
            pf_result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageW: *const fn (
            self: *const ITfMessagePump,
            p_msg: ?*MSG,
            hwnd: ?HWND,
            w_msg_filter_min: u32,
            w_msg_filter_max: u32,
            pf_result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn peekMessageA(self: *const T, p_msg_: ?*MSG, hwnd_: ?HWND, w_msg_filter_min_: u32, w_msg_filter_max_: u32, w_remove_msg_: u32, pf_result_: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).PeekMessageA(@as(*const ITfMessagePump, @ptrCast(self)), p_msg_, hwnd_, w_msg_filter_min_, w_msg_filter_max_, w_remove_msg_, pf_result_);
            }
            pub inline fn getMessageA(self: *const T, p_msg_: ?*MSG, hwnd_: ?HWND, w_msg_filter_min_: u32, w_msg_filter_max_: u32, pf_result_: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).GetMessageA(@as(*const ITfMessagePump, @ptrCast(self)), p_msg_, hwnd_, w_msg_filter_min_, w_msg_filter_max_, pf_result_);
            }
            pub inline fn peekMessageW(self: *const T, p_msg_: ?*MSG, hwnd_: ?HWND, w_msg_filter_min_: u32, w_msg_filter_max_: u32, w_remove_msg_: u32, pf_result_: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).PeekMessageW(@as(*const ITfMessagePump, @ptrCast(self)), p_msg_, hwnd_, w_msg_filter_min_, w_msg_filter_max_, w_remove_msg_, pf_result_);
            }
            pub inline fn getMessageW(self: *const T, p_msg_: ?*MSG, hwnd_: ?HWND, w_msg_filter_min_: u32, w_msg_filter_max_: u32, pf_result_: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).GetMessageW(@as(*const ITfMessagePump, @ptrCast(self)), p_msg_, hwnd_, w_msg_filter_min_, w_msg_filter_max_, pf_result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadFocusSink_Value = Guid.initString("c0f1db0c-3a20-405c-a303-96b6010a885f");
pub const IID_ITfThreadFocusSink = &IID_ITfThreadFocusSink_Value;
pub const ITfThreadFocusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetThreadFocus: *const fn (
            self: *const ITfThreadFocusSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKillThreadFocus: *const fn (
            self: *const ITfThreadFocusSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onSetThreadFocus(self: *const T) HRESULT {
                return @as(*const ITfThreadFocusSink.VTable, @ptrCast(self.vtable)).OnSetThreadFocus(@as(*const ITfThreadFocusSink, @ptrCast(self)));
            }
            pub inline fn onKillThreadFocus(self: *const T) HRESULT {
                return @as(*const ITfThreadFocusSink.VTable, @ptrCast(self.vtable)).OnKillThreadFocus(@as(*const ITfThreadFocusSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessor_Value = Guid.initString("aa80e7f7-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfTextInputProcessor = &IID_ITfTextInputProcessor_Value;
pub const ITfTextInputProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: *const fn (
            self: *const ITfTextInputProcessor,
            ptim: ?*ITfThreadMgr,
            tid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: *const fn (
            self: *const ITfTextInputProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activate(self: *const T, ptim_: ?*ITfThreadMgr, tid_: u32) HRESULT {
                return @as(*const ITfTextInputProcessor.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfTextInputProcessor, @ptrCast(self)), ptim_, tid_);
            }
            pub inline fn deactivate(self: *const T) HRESULT {
                return @as(*const ITfTextInputProcessor.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfTextInputProcessor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessorEx_Value = Guid.initString("6e4e2102-f9cd-433d-b496-303ce03a6507");
pub const IID_ITfTextInputProcessorEx = &IID_ITfTextInputProcessorEx_Value;
pub const ITfTextInputProcessorEx = extern struct {
    pub const VTable = extern struct {
        base: ITfTextInputProcessor.VTable,
        ActivateEx: *const fn (
            self: *const ITfTextInputProcessorEx,
            ptim: ?*ITfThreadMgr,
            tid: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfTextInputProcessor.MethodMixin(T);
            pub inline fn activateEx(self: *const T, ptim_: ?*ITfThreadMgr, tid_: u32, dw_flags_: u32) HRESULT {
                return @as(*const ITfTextInputProcessorEx.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfTextInputProcessorEx, @ptrCast(self)), ptim_, tid_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfClientId_Value = Guid.initString("d60a7b49-1b9f-4be2-b702-47e9dc05dec3");
pub const IID_ITfClientId = &IID_ITfClientId_Value;
pub const ITfClientId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientId: *const fn (
            self: *const ITfClientId,
            rclsid: ?*const Guid,
            ptid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getClientId(self: *const T, rclsid_: ?*const Guid, ptid_: ?*u32) HRESULT {
                return @as(*const ITfClientId.VTable, @ptrCast(self.vtable)).GetClientId(@as(*const ITfClientId, @ptrCast(self)), rclsid_, ptid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_DA_LINESTYLE = enum(i32) {
    NONE = 0,
    SOLID = 1,
    DOT = 2,
    DASH = 3,
    SQUIGGLE = 4,
};
pub const TF_LS_NONE = TF_DA_LINESTYLE.NONE;
pub const TF_LS_SOLID = TF_DA_LINESTYLE.SOLID;
pub const TF_LS_DOT = TF_DA_LINESTYLE.DOT;
pub const TF_LS_DASH = TF_DA_LINESTYLE.DASH;
pub const TF_LS_SQUIGGLE = TF_DA_LINESTYLE.SQUIGGLE;

pub const TF_DA_COLORTYPE = enum(i32) {
    NONE = 0,
    SYSCOLOR = 1,
    COLORREF = 2,
};
pub const TF_CT_NONE = TF_DA_COLORTYPE.NONE;
pub const TF_CT_SYSCOLOR = TF_DA_COLORTYPE.SYSCOLOR;
pub const TF_CT_COLORREF = TF_DA_COLORTYPE.COLORREF;

pub const TF_DA_COLOR = extern struct {
    type: TF_DA_COLORTYPE,
    Anonymous: extern union {
        nIndex: i32,
        cr: u32,
    },
};

pub const TF_DA_ATTR_INFO = enum(i32) {
    INPUT = 0,
    TARGET_CONVERTED = 1,
    CONVERTED = 2,
    TARGET_NOTCONVERTED = 3,
    INPUT_ERROR = 4,
    FIXEDCONVERTED = 5,
    OTHER = -1,
};
pub const TF_ATTR_INPUT = TF_DA_ATTR_INFO.INPUT;
pub const TF_ATTR_TARGET_CONVERTED = TF_DA_ATTR_INFO.TARGET_CONVERTED;
pub const TF_ATTR_CONVERTED = TF_DA_ATTR_INFO.CONVERTED;
pub const TF_ATTR_TARGET_NOTCONVERTED = TF_DA_ATTR_INFO.TARGET_NOTCONVERTED;
pub const TF_ATTR_INPUT_ERROR = TF_DA_ATTR_INFO.INPUT_ERROR;
pub const TF_ATTR_FIXEDCONVERTED = TF_DA_ATTR_INFO.FIXEDCONVERTED;
pub const TF_ATTR_OTHER = TF_DA_ATTR_INFO.OTHER;

pub const TF_DISPLAYATTRIBUTE = extern struct {
    crText: TF_DA_COLOR,
    crBk: TF_DA_COLOR,
    lsStyle: TF_DA_LINESTYLE,
    fBoldLine: BOOL,
    crLine: TF_DA_COLOR,
    bAttr: TF_DA_ATTR_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeInfo_Value = Guid.initString("70528852-2f26-4aea-8c96-215150578932");
pub const IID_ITfDisplayAttributeInfo = &IID_ITfDisplayAttributeInfo_Value;
pub const ITfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: *const fn (
            self: *const ITfDisplayAttributeInfo,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: *const fn (
            self: *const ITfDisplayAttributeInfo,
            pbstr_desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeInfo,
            pda: ?*TF_DISPLAYATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeInfo,
            pda: ?*const TF_DISPLAYATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ITfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getGUID(self: *const T, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pguid_);
            }
            pub inline fn getDescription(self: *const T, pbstr_desc_: ?*?BSTR) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pbstr_desc_);
            }
            pub inline fn getAttributeInfo(self: *const T, pda_: ?*TF_DISPLAYATTRIBUTE) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetAttributeInfo(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pda_);
            }
            pub inline fn setAttributeInfo(self: *const T, pda_: ?*const TF_DISPLAYATTRIBUTE) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).SetAttributeInfo(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pda_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDisplayAttributeInfo_Value = Guid.initString("7cef04d7-cb75-4e80-a7ab-5f5bc7d332de");
pub const IID_IEnumTfDisplayAttributeInfo = &IID_IEnumTfDisplayAttributeInfo_Value;
pub const IEnumTfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfDisplayAttributeInfo,
            pp_enum: ?*?*IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfDisplayAttributeInfo,
            ul_count: u32,
            rg_info: [*]?*ITfDisplayAttributeInfo,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfDisplayAttributeInfo,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_info_: [*]?*ITfDisplayAttributeInfo, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), ul_count_, rg_info_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeProvider_Value = Guid.initString("fee47777-163c-4769-996a-6e9c50ad8f54");
pub const IID_ITfDisplayAttributeProvider = &IID_ITfDisplayAttributeProvider_Value;
pub const ITfDisplayAttributeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumDisplayAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeProvider,
            pp_enum: ?*?*IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeProvider,
            guid: ?*const Guid,
            pp_info: ?*?*ITfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumDisplayAttributeInfo(self: *const T, pp_enum_: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeProvider.VTable, @ptrCast(self.vtable)).EnumDisplayAttributeInfo(@as(*const ITfDisplayAttributeProvider, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getDisplayAttributeInfo(self: *const T, guid_: ?*const Guid, pp_info_: ?*?*ITfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeProvider.VTable, @ptrCast(self.vtable)).GetDisplayAttributeInfo(@as(*const ITfDisplayAttributeProvider, @ptrCast(self)), guid_, pp_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeMgr_Value = Guid.initString("8ded7393-5db1-475c-9e71-a39111b0ff67");
pub const IID_ITfDisplayAttributeMgr = &IID_ITfDisplayAttributeMgr_Value;
pub const ITfDisplayAttributeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: *const fn (
            self: *const ITfDisplayAttributeMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDisplayAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeMgr,
            pp_enum: ?*?*IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAttributeInfo: *const fn (
            self: *const ITfDisplayAttributeMgr,
            guid: ?*const Guid,
            pp_info: ?*?*ITfDisplayAttributeInfo,
            pclsid_owner: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUpdateInfo(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).OnUpdateInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)));
            }
            pub inline fn enumDisplayAttributeInfo(self: *const T, pp_enum_: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).EnumDisplayAttributeInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getDisplayAttributeInfo(self: *const T, guid_: ?*const Guid, pp_info_: ?*?*ITfDisplayAttributeInfo, pclsid_owner_: ?*Guid) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).GetDisplayAttributeInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)), guid_, pp_info_, pclsid_owner_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeNotifySink_Value = Guid.initString("ad56f402-e162-4f25-908f-7d577cf9bda9");
pub const IID_ITfDisplayAttributeNotifySink = &IID_ITfDisplayAttributeNotifySink_Value;
pub const ITfDisplayAttributeNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: *const fn (
            self: *const ITfDisplayAttributeNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUpdateInfo(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeNotifySink.VTable, @ptrCast(self.vtable)).OnUpdateInfo(@as(*const ITfDisplayAttributeNotifySink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCategoryMgr_Value = Guid.initString("c3acefb5-f69d-4905-938f-fcadcf4be830");
pub const IID_ITfCategoryMgr = &IID_ITfCategoryMgr_Value;
pub const ITfCategoryMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategory: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rcatid: ?*const Guid,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterCategory: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rcatid: ?*const Guid,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCategoriesInItem: *const fn (
            self: *const ITfCategoryMgr,
            rguid: ?*const Guid,
            pp_enum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumItemsInCategory: *const fn (
            self: *const ITfCategoryMgr,
            rcatid: ?*const Guid,
            pp_enum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestCategory: *const fn (
            self: *const ITfCategoryMgr,
            rguid: ?*const Guid,
            pcatid: ?*Guid,
            ppcatid_list: [*]const ?*const Guid,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUIDDescription: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rguid: ?*const Guid,
            pch_desc: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterGUIDDescription: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUIDDescription: *const fn (
            self: *const ITfCategoryMgr,
            rguid: ?*const Guid,
            pbstr_desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUIDDWORD: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rguid: ?*const Guid,
            dw: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterGUIDDWORD: *const fn (
            self: *const ITfCategoryMgr,
            rclsid: ?*const Guid,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUIDDWORD: *const fn (
            self: *const ITfCategoryMgr,
            rguid: ?*const Guid,
            pdw: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUID: *const fn (
            self: *const ITfCategoryMgr,
            rguid: ?*const Guid,
            pguidatom: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUID: *const fn (
            self: *const ITfCategoryMgr,
            guidatom: u32,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTfGuidAtom: *const fn (
            self: *const ITfCategoryMgr,
            guidatom: u32,
            rguid: ?*const Guid,
            pf_equal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerCategory(self: *const T, rclsid_: ?*const Guid, rcatid_: ?*const Guid, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rcatid_, rguid_);
            }
            pub inline fn unregisterCategory(self: *const T, rclsid_: ?*const Guid, rcatid_: ?*const Guid, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rcatid_, rguid_);
            }
            pub inline fn enumCategoriesInItem(self: *const T, rguid_: ?*const Guid, pp_enum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).EnumCategoriesInItem(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid_, pp_enum_);
            }
            pub inline fn enumItemsInCategory(self: *const T, rcatid_: ?*const Guid, pp_enum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).EnumItemsInCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rcatid_, pp_enum_);
            }
            pub inline fn findClosestCategory(self: *const T, rguid_: ?*const Guid, pcatid_: ?*Guid, ppcatid_list_: [*]const ?*const Guid, ul_count_: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).FindClosestCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid_, pcatid_, ppcatid_list_, ul_count_);
            }
            pub inline fn registerGUIDDescription(self: *const T, rclsid_: ?*const Guid, rguid_: ?*const Guid, pch_desc_: [*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rguid_, pch_desc_, cch_);
            }
            pub inline fn unregisterGUIDDescription(self: *const T, rclsid_: ?*const Guid, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rguid_);
            }
            pub inline fn getGUIDDescription(self: *const T, rguid_: ?*const Guid, pbstr_desc_: ?*?BSTR) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid_, pbstr_desc_);
            }
            pub inline fn registerGUIDDWORD(self: *const T, rclsid_: ?*const Guid, rguid_: ?*const Guid, dw_: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rguid_, dw_);
            }
            pub inline fn unregisterGUIDDWORD(self: *const T, rclsid_: ?*const Guid, rguid_: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid_, rguid_);
            }
            pub inline fn getGUIDDWORD(self: *const T, rguid_: ?*const Guid, pdw_: ?*u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid_, pdw_);
            }
            pub inline fn registerGUID(self: *const T, rguid_: ?*const Guid, pguidatom_: ?*u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUID(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid_, pguidatom_);
            }
            pub inline fn getGUID(self: *const T, guidatom_: u32, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfCategoryMgr, @ptrCast(self)), guidatom_, pguid_);
            }
            pub inline fn isEqualTfGuidAtom(self: *const T, guidatom_: u32, rguid_: ?*const Guid, pf_equal_: ?*BOOL) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).IsEqualTfGuidAtom(@as(*const ITfCategoryMgr, @ptrCast(self)), guidatom_, rguid_, pf_equal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSource_Value = Guid.initString("4ea48a35-60ae-446f-8fd6-e6a8d82459f7");
pub const IID_ITfSource = &IID_ITfSource_Value;
pub const ITfSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: *const fn (
            self: *const ITfSource,
            riid: ?*const Guid,
            punk: ?*IUnknown,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: *const fn (
            self: *const ITfSource,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSink(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const ITfSource.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITfSource, @ptrCast(self)), riid_, punk_, pdw_cookie_);
            }
            pub inline fn unadviseSink(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ITfSource.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITfSource, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSourceSingle_Value = Guid.initString("73131f9c-56a9-49dd-b0ee-d046633f7528");
pub const IID_ITfSourceSingle = &IID_ITfSourceSingle_Value;
pub const ITfSourceSingle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSingleSink: *const fn (
            self: *const ITfSourceSingle,
            tid: u32,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSingleSink: *const fn (
            self: *const ITfSourceSingle,
            tid: u32,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSingleSink(self: *const T, tid_: u32, riid_: ?*const Guid, punk_: ?*IUnknown) HRESULT {
                return @as(*const ITfSourceSingle.VTable, @ptrCast(self.vtable)).AdviseSingleSink(@as(*const ITfSourceSingle, @ptrCast(self)), tid_, riid_, punk_);
            }
            pub inline fn unadviseSingleSink(self: *const T, tid_: u32, riid_: ?*const Guid) HRESULT {
                return @as(*const ITfSourceSingle.VTable, @ptrCast(self.vtable)).UnadviseSingleSink(@as(*const ITfSourceSingle, @ptrCast(self)), tid_, riid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementMgr_Value = Guid.initString("ea1ea135-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementMgr = &IID_ITfUIElementMgr_Value;
pub const ITfUIElementMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: *const fn (
            self: *const ITfUIElementMgr,
            p_element: ?*ITfUIElement,
            pb_show: ?*BOOL,
            pdw_u_i_element_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateUIElement: *const fn (
            self: *const ITfUIElementMgr,
            dw_u_i_element_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUIElement: *const fn (
            self: *const ITfUIElementMgr,
            dw_u_i_element_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUIElement: *const fn (
            self: *const ITfUIElementMgr,
            dw_u_i_e_lement_id: u32,
            pp_element: ?*?*ITfUIElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumUIElements: *const fn (
            self: *const ITfUIElementMgr,
            pp_enum: ?*?*IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginUIElement(self: *const T, p_element_: ?*ITfUIElement, pb_show_: ?*BOOL, pdw_u_i_element_id_: ?*u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).BeginUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), p_element_, pb_show_, pdw_u_i_element_id_);
            }
            pub inline fn updateUIElement(self: *const T, dw_u_i_element_id_: u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).UpdateUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dw_u_i_element_id_);
            }
            pub inline fn endUIElement(self: *const T, dw_u_i_element_id_: u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).EndUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dw_u_i_element_id_);
            }
            pub inline fn getUIElement(self: *const T, dw_u_i_e_lement_id_: u32, pp_element_: ?*?*ITfUIElement) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).GetUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dw_u_i_e_lement_id_, pp_element_);
            }
            pub inline fn enumUIElements(self: *const T, pp_enum_: ?*?*IEnumTfUIElements) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).EnumUIElements(@as(*const ITfUIElementMgr, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfUIElements_Value = Guid.initString("887aa91e-acba-4931-84da-3c5208cf543f");
pub const IID_IEnumTfUIElements = &IID_IEnumTfUIElements_Value;
pub const IEnumTfUIElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfUIElements,
            pp_enum: ?*?*IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfUIElements,
            ul_count: u32,
            pp_element: [*]?*ITfUIElement,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfUIElements,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfUIElements) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfUIElements, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_element_: [*]?*ITfUIElement, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfUIElements, @ptrCast(self)), ul_count_, pp_element_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfUIElements, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfUIElements, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementSink_Value = Guid.initString("ea1ea136-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementSink = &IID_ITfUIElementSink_Value;
pub const ITfUIElementSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: *const fn (
            self: *const ITfUIElementSink,
            dw_u_i_element_id: u32,
            pb_show: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateUIElement: *const fn (
            self: *const ITfUIElementSink,
            dw_u_i_element_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUIElement: *const fn (
            self: *const ITfUIElementSink,
            dw_u_i_element_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginUIElement(self: *const T, dw_u_i_element_id_: u32, pb_show_: ?*BOOL) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).BeginUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dw_u_i_element_id_, pb_show_);
            }
            pub inline fn updateUIElement(self: *const T, dw_u_i_element_id_: u32) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).UpdateUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dw_u_i_element_id_);
            }
            pub inline fn endUIElement(self: *const T, dw_u_i_element_id_: u32) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).EndUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dw_u_i_element_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElement_Value = Guid.initString("ea1ea137-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElement = &IID_ITfUIElement_Value;
pub const ITfUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDescription: *const fn (
            self: *const ITfUIElement,
            pbstr_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUID: *const fn (
            self: *const ITfUIElement,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: *const fn (
            self: *const ITfUIElement,
            b_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsShown: *const fn (
            self: *const ITfUIElement,
            pb_show: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDescription(self: *const T, pbstr_description_: ?*?BSTR) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfUIElement, @ptrCast(self)), pbstr_description_);
            }
            pub inline fn getGUID(self: *const T, pguid_: ?*Guid) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfUIElement, @ptrCast(self)), pguid_);
            }
            pub inline fn show(self: *const T, b_show_: BOOL) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfUIElement, @ptrCast(self)), b_show_);
            }
            pub inline fn isShown(self: *const T, pb_show_: ?*BOOL) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).IsShown(@as(*const ITfUIElement, @ptrCast(self)), pb_show_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElement_Value = Guid.initString("ea1ea138-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfCandidateListUIElement = &IID_ITfCandidateListUIElement_Value;
pub const ITfCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: *const fn (
            self: *const ITfCandidateListUIElement,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentMgr: *const fn (
            self: *const ITfCandidateListUIElement,
            ppdim: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const ITfCandidateListUIElement,
            pu_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITfCandidateListUIElement,
            pu_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: *const fn (
            self: *const ITfCandidateListUIElement,
            u_index: u32,
            pstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageIndex: *const fn (
            self: *const ITfCandidateListUIElement,
            p_index: [*]u32,
            u_size: u32,
            pu_page_cnt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageIndex: *const fn (
            self: *const ITfCandidateListUIElement,
            p_index: [*]u32,
            u_page_cnt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPage: *const fn (
            self: *const ITfCandidateListUIElement,
            pu_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            pub inline fn getUpdatedFlags(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetUpdatedFlags(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn getDocumentMgr(self: *const T, ppdim_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfCandidateListUIElement, @ptrCast(self)), ppdim_);
            }
            pub inline fn getCount(self: *const T, pu_count_: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pu_count_);
            }
            pub inline fn getSelection(self: *const T, pu_index_: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pu_index_);
            }
            pub inline fn getString(self: *const T, u_index_: u32, pstr_: ?*?BSTR) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfCandidateListUIElement, @ptrCast(self)), u_index_, pstr_);
            }
            pub inline fn getPageIndex(self: *const T, p_index_: [*]u32, u_size_: u32, pu_page_cnt_: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetPageIndex(@as(*const ITfCandidateListUIElement, @ptrCast(self)), p_index_, u_size_, pu_page_cnt_);
            }
            pub inline fn setPageIndex(self: *const T, p_index_: [*]u32, u_page_cnt_: u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).SetPageIndex(@as(*const ITfCandidateListUIElement, @ptrCast(self)), p_index_, u_page_cnt_);
            }
            pub inline fn getCurrentPage(self: *const T, pu_page_: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetCurrentPage(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pu_page_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElementBehavior_Value = Guid.initString("85fad185-58ce-497a-9460-355366b64b9a");
pub const IID_ITfCandidateListUIElementBehavior = &IID_ITfCandidateListUIElementBehavior_Value;
pub const ITfCandidateListUIElementBehavior = extern struct {
    pub const VTable = extern struct {
        base: ITfCandidateListUIElement.VTable,
        SetSelection: *const fn (
            self: *const ITfCandidateListUIElementBehavior,
            n_index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: *const fn (
            self: *const ITfCandidateListUIElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: *const fn (
            self: *const ITfCandidateListUIElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfCandidateListUIElement.MethodMixin(T);
            pub inline fn setSelection(self: *const T, n_index_: u32) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)), n_index_);
            }
            pub inline fn finalize(self: *const T) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).Finalize(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)));
            }
            pub inline fn abort(self: *const T) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).Abort(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadingInformationUIElement_Value = Guid.initString("ea1ea139-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfReadingInformationUIElement = &IID_ITfReadingInformationUIElement_Value;
pub const ITfReadingInformationUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: *const fn (
            self: *const ITfReadingInformationUIElement,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: *const fn (
            self: *const ITfReadingInformationUIElement,
            ppic: ?*?*ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: *const fn (
            self: *const ITfReadingInformationUIElement,
            pstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxReadingStringLength: *const fn (
            self: *const ITfReadingInformationUIElement,
            pcch_max: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorIndex: *const fn (
            self: *const ITfReadingInformationUIElement,
            p_error_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVerticalOrderPreferred: *const fn (
            self: *const ITfReadingInformationUIElement,
            pf_vertical: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            pub inline fn getUpdatedFlags(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetUpdatedFlags(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn getContext(self: *const T, ppic_: ?*?*ITfContext) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), ppic_);
            }
            pub inline fn getString(self: *const T, pstr_: ?*?BSTR) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pstr_);
            }
            pub inline fn getMaxReadingStringLength(self: *const T, pcch_max_: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetMaxReadingStringLength(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pcch_max_);
            }
            pub inline fn getErrorIndex(self: *const T, p_error_index_: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetErrorIndex(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), p_error_index_);
            }
            pub inline fn isVerticalOrderPreferred(self: *const T, pf_vertical_: ?*BOOL) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).IsVerticalOrderPreferred(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pf_vertical_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionUIElement_Value = Guid.initString("858f956a-972f-42a2-a2f2-0321e1abe209");
pub const IID_ITfTransitoryExtensionUIElement = &IID_ITfTransitoryExtensionUIElement_Value;
pub const ITfTransitoryExtensionUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetDocumentMgr: *const fn (
            self: *const ITfTransitoryExtensionUIElement,
            ppdim: ?*?*ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            pub inline fn getDocumentMgr(self: *const T, ppdim_: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfTransitoryExtensionUIElement.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfTransitoryExtensionUIElement, @ptrCast(self)), ppdim_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionSink_Value = Guid.initString("a615096f-1c57-4813-8a15-55ee6e5a839c");
pub const IID_ITfTransitoryExtensionSink = &IID_ITfTransitoryExtensionSink_Value;
pub const ITfTransitoryExtensionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTransitoryExtensionUpdated: *const fn (
            self: *const ITfTransitoryExtensionSink,
            pic: ?*ITfContext,
            ec_read_only: u32,
            p_result_range: ?*ITfRange,
            p_composition_range: ?*ITfRange,
            pf_delete_result_range: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onTransitoryExtensionUpdated(self: *const T, pic_: ?*ITfContext, ec_read_only_: u32, p_result_range_: ?*ITfRange, p_composition_range_: ?*ITfRange, pf_delete_result_range_: ?*BOOL) HRESULT {
                return @as(*const ITfTransitoryExtensionSink.VTable, @ptrCast(self.vtable)).OnTransitoryExtensionUpdated(@as(*const ITfTransitoryExtensionSink, @ptrCast(self)), pic_, ec_read_only_, p_result_range_, p_composition_range_, pf_delete_result_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfToolTipUIElement_Value = Guid.initString("52b18b5c-555d-46b2-b00a-fa680144fbdb");
pub const IID_ITfToolTipUIElement = &IID_ITfToolTipUIElement_Value;
pub const ITfToolTipUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetString: *const fn (
            self: *const ITfToolTipUIElement,
            pstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            pub inline fn getString(self: *const T, pstr_: ?*?BSTR) HRESULT {
                return @as(*const ITfToolTipUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfToolTipUIElement, @ptrCast(self)), pstr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionList_Value = Guid.initString("151d69f0-86f4-4674-b721-56911e797f47");
pub const IID_ITfReverseConversionList = &IID_ITfReverseConversionList_Value;
pub const ITfReverseConversionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: *const fn (
            self: *const ITfReverseConversionList,
            pu_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: *const fn (
            self: *const ITfReverseConversionList,
            u_index: u32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLength(self: *const T, pu_index_: ?*u32) HRESULT {
                return @as(*const ITfReverseConversionList.VTable, @ptrCast(self.vtable)).GetLength(@as(*const ITfReverseConversionList, @ptrCast(self)), pu_index_);
            }
            pub inline fn getString(self: *const T, u_index_: u32, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITfReverseConversionList.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfReverseConversionList, @ptrCast(self)), u_index_, pbstr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversion_Value = Guid.initString("a415e162-157d-417d-8a8c-0ab26c7d2781");
pub const IID_ITfReverseConversion = &IID_ITfReverseConversion_Value;
pub const ITfReverseConversion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoReverseConversion: *const fn (
            self: *const ITfReverseConversion,
            lpstr: ?[*:0]const u16,
            pp_list: ?*?*ITfReverseConversionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn doReverseConversion(self: *const T, lpstr_: ?[*:0]const u16, pp_list_: ?*?*ITfReverseConversionList) HRESULT {
                return @as(*const ITfReverseConversion.VTable, @ptrCast(self.vtable)).DoReverseConversion(@as(*const ITfReverseConversion, @ptrCast(self)), lpstr_, pp_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionMgr_Value = Guid.initString("b643c236-c493-41b6-abb3-692412775cc4");
pub const IID_ITfReverseConversionMgr = &IID_ITfReverseConversionMgr_Value;
pub const ITfReverseConversionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReverseConversion: *const fn (
            self: *const ITfReverseConversionMgr,
            langid: u16,
            guid_profile: ?*const Guid,
            dwflag: u32,
            pp_reverse_conversion: ?*?*ITfReverseConversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getReverseConversion(self: *const T, langid_: u16, guid_profile_: ?*const Guid, dwflag_: u32, pp_reverse_conversion_: ?*?*ITfReverseConversion) HRESULT {
                return @as(*const ITfReverseConversionMgr.VTable, @ptrCast(self.vtable)).GetReverseConversion(@as(*const ITfReverseConversionMgr, @ptrCast(self)), langid_, guid_profile_, dwflag_, pp_reverse_conversion_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateString_Value = Guid.initString("581f317e-fd9d-443f-b972-ed00467c5d40");
pub const IID_ITfCandidateString = &IID_ITfCandidateString_Value;
pub const ITfCandidateString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetString: *const fn (
            self: *const ITfCandidateString,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: *const fn (
            self: *const ITfCandidateString,
            pn_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getString(self: *const T, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITfCandidateString.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfCandidateString, @ptrCast(self)), pbstr_);
            }
            pub inline fn getIndex(self: *const T, pn_index_: ?*u32) HRESULT {
                return @as(*const ITfCandidateString.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITfCandidateString, @ptrCast(self)), pn_index_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfCandidates_Value = Guid.initString("defb1926-6c80-4ce8-87d4-d6b72b812bde");
pub const IID_IEnumTfCandidates = &IID_IEnumTfCandidates_Value;
pub const IEnumTfCandidates = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfCandidates,
            pp_enum: ?*?*IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfCandidates,
            ul_count: u32,
            pp_cand: [*]?*ITfCandidateString,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfCandidates,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfCandidates) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfCandidates, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, pp_cand_: [*]?*ITfCandidateString, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfCandidates, @ptrCast(self)), ul_count_, pp_cand_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfCandidates, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfCandidates, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfCandidateResult = enum(i32) {
    FINALIZED = 0,
    SELECTED = 1,
    CANCELED = 2,
};
pub const CAND_FINALIZED = TfCandidateResult.FINALIZED;
pub const CAND_SELECTED = TfCandidateResult.SELECTED;
pub const CAND_CANCELED = TfCandidateResult.CANCELED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateList_Value = Guid.initString("a3ad50fb-9bdb-49e3-a843-6c76520fbf5d");
pub const IID_ITfCandidateList = &IID_ITfCandidateList_Value;
pub const ITfCandidateList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCandidates: *const fn (
            self: *const ITfCandidateList,
            pp_enum: ?*?*IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidate: *const fn (
            self: *const ITfCandidateList,
            n_index: u32,
            pp_cand: ?*?*ITfCandidateString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateNum: *const fn (
            self: *const ITfCandidateList,
            pn_cnt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResult: *const fn (
            self: *const ITfCandidateList,
            n_index: u32,
            imcr: TfCandidateResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumCandidates(self: *const T, pp_enum_: ?*?*IEnumTfCandidates) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).EnumCandidates(@as(*const ITfCandidateList, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getCandidate(self: *const T, n_index_: u32, pp_cand_: ?*?*ITfCandidateString) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).GetCandidate(@as(*const ITfCandidateList, @ptrCast(self)), n_index_, pp_cand_);
            }
            pub inline fn getCandidateNum(self: *const T, pn_cnt_: ?*u32) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).GetCandidateNum(@as(*const ITfCandidateList, @ptrCast(self)), pn_cnt_);
            }
            pub inline fn setResult(self: *const T, n_index_: u32, imcr_: TfCandidateResult) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).SetResult(@as(*const ITfCandidateList, @ptrCast(self)), n_index_, imcr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnReconversion_Value = Guid.initString("4cea93c0-0a58-11d3-8df0-00105a2799b5");
pub const IID_ITfFnReconversion = &IID_ITfFnReconversion_Value;
pub const ITfFnReconversion = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: *const fn (
            self: *const ITfFnReconversion,
            p_range: ?*ITfRange,
            pp_new_range: ?*?*ITfRange,
            pf_convertable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReconversion: *const fn (
            self: *const ITfFnReconversion,
            p_range: ?*ITfRange,
            pp_cand_list: ?*?*ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconvert: *const fn (
            self: *const ITfFnReconversion,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn queryRange(self: *const T, p_range_: ?*ITfRange, pp_new_range_: ?*?*ITfRange, pf_convertable_: ?*BOOL) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnReconversion, @ptrCast(self)), p_range_, pp_new_range_, pf_convertable_);
            }
            pub inline fn getReconversion(self: *const T, p_range_: ?*ITfRange, pp_cand_list_: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).GetReconversion(@as(*const ITfFnReconversion, @ptrCast(self)), p_range_, pp_cand_list_);
            }
            pub inline fn reconvert(self: *const T, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).Reconvert(@as(*const ITfFnReconversion, @ptrCast(self)), p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPlayBack_Value = Guid.initString("a3a416a4-0f64-11d3-b5b7-00c04fc324a1");
pub const IID_ITfFnPlayBack = &IID_ITfFnPlayBack_Value;
pub const ITfFnPlayBack = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: *const fn (
            self: *const ITfFnPlayBack,
            p_range: ?*ITfRange,
            pp_new_range: ?*?*ITfRange,
            pf_playable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Play: *const fn (
            self: *const ITfFnPlayBack,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn queryRange(self: *const T, p_range_: ?*ITfRange, pp_new_range_: ?*?*ITfRange, pf_playable_: ?*BOOL) HRESULT {
                return @as(*const ITfFnPlayBack.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnPlayBack, @ptrCast(self)), p_range_, pp_new_range_, pf_playable_);
            }
            pub inline fn play(self: *const T, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfFnPlayBack.VTable, @ptrCast(self.vtable)).Play(@as(*const ITfFnPlayBack, @ptrCast(self)), p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLangProfileUtil_Value = Guid.initString("a87a8574-a6c1-4e15-99f0-3d3965f548eb");
pub const IID_ITfFnLangProfileUtil = &IID_ITfFnLangProfileUtil_Value;
pub const ITfFnLangProfileUtil = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        RegisterActiveProfiles: *const fn (
            self: *const ITfFnLangProfileUtil,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProfileAvailableForLang: *const fn (
            self: *const ITfFnLangProfileUtil,
            langid: u16,
            pf_available: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn registerActiveProfiles(self: *const T) HRESULT {
                return @as(*const ITfFnLangProfileUtil.VTable, @ptrCast(self.vtable)).RegisterActiveProfiles(@as(*const ITfFnLangProfileUtil, @ptrCast(self)));
            }
            pub inline fn isProfileAvailableForLang(self: *const T, langid_: u16, pf_available_: ?*BOOL) HRESULT {
                return @as(*const ITfFnLangProfileUtil.VTable, @ptrCast(self.vtable)).IsProfileAvailableForLang(@as(*const ITfFnLangProfileUtil, @ptrCast(self)), langid_, pf_available_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigure_Value = Guid.initString("88f567c6-1757-49f8-a1b2-89234c1eeff9");
pub const IID_ITfFnConfigure = &IID_ITfFnConfigure_Value;
pub const ITfFnConfigure = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: *const fn (
            self: *const ITfFnConfigure,
            hwnd_parent: ?HWND,
            langid: u16,
            rguid_profile: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn show(self: *const T, hwnd_parent_: ?HWND, langid_: u16, rguid_profile_: ?*const Guid) HRESULT {
                return @as(*const ITfFnConfigure.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigure, @ptrCast(self)), hwnd_parent_, langid_, rguid_profile_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterWord_Value = Guid.initString("bb95808a-6d8f-4bca-8400-5390b586aedf");
pub const IID_ITfFnConfigureRegisterWord = &IID_ITfFnConfigureRegisterWord_Value;
pub const ITfFnConfigureRegisterWord = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: *const fn (
            self: *const ITfFnConfigureRegisterWord,
            hwnd_parent: ?HWND,
            langid: u16,
            rguid_profile: ?*const Guid,
            bstr_registered: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn show(self: *const T, hwnd_parent_: ?HWND, langid_: u16, rguid_profile_: ?*const Guid, bstr_registered_: ?BSTR) HRESULT {
                return @as(*const ITfFnConfigureRegisterWord.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigureRegisterWord, @ptrCast(self)), hwnd_parent_, langid_, rguid_profile_, bstr_registered_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterEudc_Value = Guid.initString("b5e26ff5-d7ad-4304-913f-21a2ed95a1b0");
pub const IID_ITfFnConfigureRegisterEudc = &IID_ITfFnConfigureRegisterEudc_Value;
pub const ITfFnConfigureRegisterEudc = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: *const fn (
            self: *const ITfFnConfigureRegisterEudc,
            hwnd_parent: ?HWND,
            langid: u16,
            rguid_profile: ?*const Guid,
            bstr_registered: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn show(self: *const T, hwnd_parent_: ?HWND, langid_: u16, rguid_profile_: ?*const Guid, bstr_registered_: ?BSTR) HRESULT {
                return @as(*const ITfFnConfigureRegisterEudc.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigureRegisterEudc, @ptrCast(self)), hwnd_parent_, langid_, rguid_profile_, bstr_registered_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnShowHelp_Value = Guid.initString("5ab1d30c-094d-4c29-8ea5-0bf59be87bf3");
pub const IID_ITfFnShowHelp = &IID_ITfFnShowHelp_Value;
pub const ITfFnShowHelp = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: *const fn (
            self: *const ITfFnShowHelp,
            hwnd_parent: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn show(self: *const T, hwnd_parent_: ?HWND) HRESULT {
                return @as(*const ITfFnShowHelp.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnShowHelp, @ptrCast(self)), hwnd_parent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnBalloon_Value = Guid.initString("3bab89e4-5fbe-45f4-a5bc-dca36ad225a8");
pub const IID_ITfFnBalloon = &IID_ITfFnBalloon_Value;
pub const ITfFnBalloon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateBalloon: *const fn (
            self: *const ITfFnBalloon,
            style: TfLBBalloonStyle,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn updateBalloon(self: *const T, style_: TfLBBalloonStyle, pch_: [*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ITfFnBalloon.VTable, @ptrCast(self.vtable)).UpdateBalloon(@as(*const ITfFnBalloon, @ptrCast(self)), style_, pch_, cch_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfSapiObject = enum(i32) {
    RESMGR = 0,
    RECOCONTEXT = 1,
    RECOGNIZER = 2,
    VOICE = 3,
    DICTGRAM = 4,
    RECOGNIZERNOINIT = 5,
};
pub const GETIF_RESMGR = TfSapiObject.RESMGR;
pub const GETIF_RECOCONTEXT = TfSapiObject.RECOCONTEXT;
pub const GETIF_RECOGNIZER = TfSapiObject.RECOGNIZER;
pub const GETIF_VOICE = TfSapiObject.VOICE;
pub const GETIF_DICTGRAM = TfSapiObject.DICTGRAM;
pub const GETIF_RECOGNIZERNOINIT = TfSapiObject.RECOGNIZERNOINIT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnGetSAPIObject_Value = Guid.initString("5c0ab7ea-167d-4f59-bfb5-4693755e90ca");
pub const IID_ITfFnGetSAPIObject = &IID_ITfFnGetSAPIObject_Value;
pub const ITfFnGetSAPIObject = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Get: *const fn (
            self: *const ITfFnGetSAPIObject,
            s_obj: TfSapiObject,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn get(self: *const T, s_obj_: TfSapiObject, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const ITfFnGetSAPIObject.VTable, @ptrCast(self.vtable)).Get(@as(*const ITfFnGetSAPIObject, @ptrCast(self)), s_obj_, ppunk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPropertyUIStatus_Value = Guid.initString("2338ac6e-2b9d-44c0-a75e-ee64f256b3bd");
pub const IID_ITfFnPropertyUIStatus = &IID_ITfFnPropertyUIStatus_Value;
pub const ITfFnPropertyUIStatus = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetStatus: *const fn (
            self: *const ITfFnPropertyUIStatus,
            refguid_prop: ?*const Guid,
            pdw: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: *const fn (
            self: *const ITfFnPropertyUIStatus,
            refguid_prop: ?*const Guid,
            dw: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn getStatus(self: *const T, refguid_prop_: ?*const Guid, pdw_: ?*u32) HRESULT {
                return @as(*const ITfFnPropertyUIStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfFnPropertyUIStatus, @ptrCast(self)), refguid_prop_, pdw_);
            }
            pub inline fn setStatus(self: *const T, refguid_prop_: ?*const Guid, dw_: u32) HRESULT {
                return @as(*const ITfFnPropertyUIStatus.VTable, @ptrCast(self.vtable)).SetStatus(@as(*const ITfFnPropertyUIStatus, @ptrCast(self)), refguid_prop_, dw_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSpeechCommands_Value = Guid.initString("8c5dac4f-083c-4b85-a4c9-71746048adca");
pub const IID_IEnumSpeechCommands = &IID_IEnumSpeechCommands_Value;
pub const IEnumSpeechCommands = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumSpeechCommands,
            pp_enum: ?*?*IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumSpeechCommands,
            ul_count: u32,
            p_sp_cmds: [*]?*u16,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSpeechCommands,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumSpeechCommands) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSpeechCommands, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, p_sp_cmds_: [*]?*u16, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSpeechCommands, @ptrCast(self)), ul_count_, p_sp_cmds_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSpeechCommands, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSpeechCommands, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechCommandProvider_Value = Guid.initString("38e09d4c-586d-435a-b592-c8a86691dec6");
pub const IID_ISpeechCommandProvider = &IID_ISpeechCommandProvider_Value;
pub const ISpeechCommandProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumSpeechCommands: *const fn (
            self: *const ISpeechCommandProvider,
            langid: u16,
            pp_enum: ?*?*IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessCommand: *const fn (
            self: *const ISpeechCommandProvider,
            psz_command: [*:0]const u16,
            cch: u32,
            langid: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumSpeechCommands(self: *const T, langid_: u16, pp_enum_: ?*?*IEnumSpeechCommands) HRESULT {
                return @as(*const ISpeechCommandProvider.VTable, @ptrCast(self.vtable)).EnumSpeechCommands(@as(*const ISpeechCommandProvider, @ptrCast(self)), langid_, pp_enum_);
            }
            pub inline fn processCommand(self: *const T, psz_command_: [*:0]const u16, cch_: u32, langid_: u16) HRESULT {
                return @as(*const ISpeechCommandProvider.VTable, @ptrCast(self.vtable)).ProcessCommand(@as(*const ISpeechCommandProvider, @ptrCast(self)), psz_command_, cch_, langid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITfFnCustomSpeechCommand_Value = Guid.initString("fca6c349-a12f-43a3-8dd6-5a5a4282577b");
pub const IID_ITfFnCustomSpeechCommand = &IID_ITfFnCustomSpeechCommand_Value;
pub const ITfFnCustomSpeechCommand = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        SetSpeechCommandProvider: *const fn (
            self: *const ITfFnCustomSpeechCommand,
            pspcmd_provider: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn setSpeechCommandProvider(self: *const T, pspcmd_provider_: ?*IUnknown) HRESULT {
                return @as(*const ITfFnCustomSpeechCommand.VTable, @ptrCast(self.vtable)).SetSpeechCommandProvider(@as(*const ITfFnCustomSpeechCommand, @ptrCast(self)), pspcmd_provider_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMProcessor_Value = Guid.initString("7afbf8e7-ac4b-4082-b058-890899d3a010");
pub const IID_ITfFnLMProcessor = &IID_ITfFnLMProcessor_Value;
pub const ITfFnLMProcessor = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: *const fn (
            self: *const ITfFnLMProcessor,
            p_range: ?*ITfRange,
            pp_new_range: ?*?*ITfRange,
            pf_accepted: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryLangID: *const fn (
            self: *const ITfFnLMProcessor,
            langid: u16,
            pf_accepted: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReconversion: *const fn (
            self: *const ITfFnLMProcessor,
            p_range: ?*ITfRange,
            pp_cand_list: ?*?*ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconvert: *const fn (
            self: *const ITfFnLMProcessor,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryKey: *const fn (
            self: *const ITfFnLMProcessor,
            f_up: BOOL,
            v_key: WPARAM,
            lparam_keydata: LPARAM,
            pf_interested: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeKey: *const fn (
            self: *const ITfFnLMProcessor,
            f_up: BOOL,
            v_key: WPARAM,
            lparam_key_data: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeFunc: *const fn (
            self: *const ITfFnLMProcessor,
            pic: ?*ITfContext,
            refguid_func: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn queryRange(self: *const T, p_range_: ?*ITfRange, pp_new_range_: ?*?*ITfRange, pf_accepted_: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnLMProcessor, @ptrCast(self)), p_range_, pp_new_range_, pf_accepted_);
            }
            pub inline fn queryLangID(self: *const T, langid_: u16, pf_accepted_: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryLangID(@as(*const ITfFnLMProcessor, @ptrCast(self)), langid_, pf_accepted_);
            }
            pub inline fn getReconversion(self: *const T, p_range_: ?*ITfRange, pp_cand_list_: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).GetReconversion(@as(*const ITfFnLMProcessor, @ptrCast(self)), p_range_, pp_cand_list_);
            }
            pub inline fn reconvert(self: *const T, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).Reconvert(@as(*const ITfFnLMProcessor, @ptrCast(self)), p_range_);
            }
            pub inline fn queryKey(self: *const T, f_up_: BOOL, v_key_: WPARAM, lparam_keydata_: LPARAM, pf_interested_: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryKey(@as(*const ITfFnLMProcessor, @ptrCast(self)), f_up_, v_key_, lparam_keydata_, pf_interested_);
            }
            pub inline fn invokeKey(self: *const T, f_up_: BOOL, v_key_: WPARAM, lparam_key_data_: LPARAM) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).InvokeKey(@as(*const ITfFnLMProcessor, @ptrCast(self)), f_up_, v_key_, lparam_key_data_);
            }
            pub inline fn invokeFunc(self: *const T, pic_: ?*ITfContext, refguid_func_: ?*const Guid) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).InvokeFunc(@as(*const ITfFnLMProcessor, @ptrCast(self)), pic_, refguid_func_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMInternal_Value = Guid.initString("04b825b1-ac9a-4f7b-b5ad-c7168f1ee445");
pub const IID_ITfFnLMInternal = &IID_ITfFnLMInternal_Value;
pub const ITfFnLMInternal = extern struct {
    pub const VTable = extern struct {
        base: ITfFnLMProcessor.VTable,
        ProcessLattice: *const fn (
            self: *const ITfFnLMInternal,
            p_range: ?*ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFnLMProcessor.MethodMixin(T);
            pub inline fn processLattice(self: *const T, p_range_: ?*ITfRange) HRESULT {
                return @as(*const ITfFnLMInternal.VTable, @ptrCast(self.vtable)).ProcessLattice(@as(*const ITfFnLMInternal, @ptrCast(self)), p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LMLATTELEMENT = extern struct {
    dwFrameStart: u32,
    dwFrameLen: u32,
    dwFlags: u32,
    Anonymous: extern union {
        iCost: i32,
    },
    bstrText: ?BSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLatticeElements_Value = Guid.initString("56988052-47da-4a05-911a-e3d941f17145");
pub const IID_IEnumTfLatticeElements = &IID_IEnumTfLatticeElements_Value;
pub const IEnumTfLatticeElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumTfLatticeElements,
            pp_enum: ?*?*IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumTfLatticeElements,
            ul_count: u32,
            rgs_elements: [*]TF_LMLATTELEMENT,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTfLatticeElements,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTfLatticeElements) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLatticeElements, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rgs_elements_: [*]TF_LMLATTELEMENT, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLatticeElements, @ptrCast(self)), ul_count_, rgs_elements_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLatticeElements, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLatticeElements, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLMLattice_Value = Guid.initString("d4236675-a5bf-4570-9d42-5d6d7b02d59b");
pub const IID_ITfLMLattice = &IID_ITfLMLattice_Value;
pub const ITfLMLattice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryType: *const fn (
            self: *const ITfLMLattice,
            rguid_type: ?*const Guid,
            pf_supported: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumLatticeElements: *const fn (
            self: *const ITfLMLattice,
            dw_frame_start: u32,
            rguid_type: ?*const Guid,
            pp_enum: ?*?*IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryType(self: *const T, rguid_type_: ?*const Guid, pf_supported_: ?*BOOL) HRESULT {
                return @as(*const ITfLMLattice.VTable, @ptrCast(self.vtable)).QueryType(@as(*const ITfLMLattice, @ptrCast(self)), rguid_type_, pf_supported_);
            }
            pub inline fn enumLatticeElements(self: *const T, dw_frame_start_: u32, rguid_type_: ?*const Guid, pp_enum_: ?*?*IEnumTfLatticeElements) HRESULT {
                return @as(*const ITfLMLattice.VTable, @ptrCast(self.vtable)).EnumLatticeElements(@as(*const ITfLMLattice, @ptrCast(self)), dw_frame_start_, rguid_type_, pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnAdviseText_Value = Guid.initString("3527268b-7d53-4dd9-92b7-7296ae461249");
pub const IID_ITfFnAdviseText = &IID_ITfFnAdviseText_Value;
pub const ITfFnAdviseText = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        OnTextUpdate: *const fn (
            self: *const ITfFnAdviseText,
            p_range: ?*ITfRange,
            pch_text: [*:0]const u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLatticeUpdate: *const fn (
            self: *const ITfFnAdviseText,
            p_range: ?*ITfRange,
            p_lattice: ?*ITfLMLattice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn onTextUpdate(self: *const T, p_range_: ?*ITfRange, pch_text_: [*:0]const u16, cch_: i32) HRESULT {
                return @as(*const ITfFnAdviseText.VTable, @ptrCast(self.vtable)).OnTextUpdate(@as(*const ITfFnAdviseText, @ptrCast(self)), p_range_, pch_text_, cch_);
            }
            pub inline fn onLatticeUpdate(self: *const T, p_range_: ?*ITfRange, p_lattice_: ?*ITfLMLattice) HRESULT {
                return @as(*const ITfFnAdviseText.VTable, @ptrCast(self.vtable)).OnLatticeUpdate(@as(*const ITfFnAdviseText, @ptrCast(self)), p_range_, p_lattice_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnSearchCandidateProvider_Value = Guid.initString("87a2ad8f-f27b-4920-8501-67602280175d");
pub const IID_ITfFnSearchCandidateProvider = &IID_ITfFnSearchCandidateProvider_Value;
pub const ITfFnSearchCandidateProvider = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetSearchCandidates: *const fn (
            self: *const ITfFnSearchCandidateProvider,
            bstr_query: ?BSTR,
            bstr_application_id: ?BSTR,
            pplist: ?*?*ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResult: *const fn (
            self: *const ITfFnSearchCandidateProvider,
            bstr_query: ?BSTR,
            bstr_application_i_d: ?BSTR,
            bstr_result: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn getSearchCandidates(self: *const T, bstr_query_: ?BSTR, bstr_application_id_: ?BSTR, pplist_: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnSearchCandidateProvider.VTable, @ptrCast(self.vtable)).GetSearchCandidates(@as(*const ITfFnSearchCandidateProvider, @ptrCast(self)), bstr_query_, bstr_application_id_, pplist_);
            }
            pub inline fn setResult(self: *const T, bstr_query_: ?BSTR, bstr_application_i_d_: ?BSTR, bstr_result_: ?BSTR) HRESULT {
                return @as(*const ITfFnSearchCandidateProvider.VTable, @ptrCast(self.vtable)).SetResult(@as(*const ITfFnSearchCandidateProvider, @ptrCast(self)), bstr_query_, bstr_application_i_d_, bstr_result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfIntegratableCandidateListSelectionStyle = enum(i32) {
    ACTIVE_SELECTION = 0,
    IMPLIED_SELECTION = 1,
};
pub const STYLE_ACTIVE_SELECTION = TfIntegratableCandidateListSelectionStyle.ACTIVE_SELECTION;
pub const STYLE_IMPLIED_SELECTION = TfIntegratableCandidateListSelectionStyle.IMPLIED_SELECTION;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfIntegratableCandidateListUIElement_Value = Guid.initString("c7a6f54f-b180-416f-b2bf-7bf2e4683d7b");
pub const IID_ITfIntegratableCandidateListUIElement = &IID_ITfIntegratableCandidateListUIElement_Value;
pub const ITfIntegratableCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIntegrationStyle: *const fn (
            self: *const ITfIntegratableCandidateListUIElement,
            guid_integration_style: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionStyle: *const fn (
            self: *const ITfIntegratableCandidateListUIElement,
            ptf_selection_style: ?*TfIntegratableCandidateListSelectionStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyDown: *const fn (
            self: *const ITfIntegratableCandidateListUIElement,
            w_param: WPARAM,
            l_param: LPARAM,
            pf_eaten: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowCandidateNumbers: *const fn (
            self: *const ITfIntegratableCandidateListUIElement,
            pf_show: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinalizeExactCompositionString: *const fn (
            self: *const ITfIntegratableCandidateListUIElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setIntegrationStyle(self: *const T, guid_integration_style_: Guid) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).SetIntegrationStyle(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), guid_integration_style_);
            }
            pub inline fn getSelectionStyle(self: *const T, ptf_selection_style_: ?*TfIntegratableCandidateListSelectionStyle) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetSelectionStyle(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), ptf_selection_style_);
            }
            pub inline fn onKeyDown(self: *const T, w_param_: WPARAM, l_param_: LPARAM, pf_eaten_: ?*BOOL) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), w_param_, l_param_, pf_eaten_);
            }
            pub inline fn showCandidateNumbers(self: *const T, pf_show_: ?*BOOL) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).ShowCandidateNumbers(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), pf_show_);
            }
            pub inline fn finalizeExactCompositionString(self: *const T) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).FinalizeExactCompositionString(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TKBLayoutType = enum(i32) {
    UNDEFINED = 0,
    CLASSIC = 1,
    OPTIMIZED = 2,
};
pub const TKBLT_UNDEFINED = TKBLayoutType.UNDEFINED;
pub const TKBLT_CLASSIC = TKBLayoutType.CLASSIC;
pub const TKBLT_OPTIMIZED = TKBLayoutType.OPTIMIZED;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnGetPreferredTouchKeyboardLayout_Value = Guid.initString("5f309a41-590a-4acc-a97f-d8efff13fdfc");
pub const IID_ITfFnGetPreferredTouchKeyboardLayout = &IID_ITfFnGetPreferredTouchKeyboardLayout_Value;
pub const ITfFnGetPreferredTouchKeyboardLayout = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetLayout: *const fn (
            self: *const ITfFnGetPreferredTouchKeyboardLayout,
            p_t_k_b_layout_type: ?*TKBLayoutType,
            pw_preferred_layout_id: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn getLayout(self: *const T, p_t_k_b_layout_type_: ?*TKBLayoutType, pw_preferred_layout_id_: ?*u16) HRESULT {
                return @as(*const ITfFnGetPreferredTouchKeyboardLayout.VTable, @ptrCast(self.vtable)).GetLayout(@as(*const ITfFnGetPreferredTouchKeyboardLayout, @ptrCast(self)), p_t_k_b_layout_type_, pw_preferred_layout_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ITfFnGetLinguisticAlternates_Value = Guid.initString("ea163ce2-7a65-4506-82a3-c528215da64e");
pub const IID_ITfFnGetLinguisticAlternates = &IID_ITfFnGetLinguisticAlternates_Value;
pub const ITfFnGetLinguisticAlternates = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetAlternates: *const fn (
            self: *const ITfFnGetLinguisticAlternates,
            p_range: ?*ITfRange,
            pp_candidate_list: ?*?*ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            pub inline fn getAlternates(self: *const T, p_range_: ?*ITfRange, pp_candidate_list_: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnGetLinguisticAlternates.VTable, @ptrCast(self.vtable)).GetAlternates(@as(*const ITfFnGetLinguisticAlternates, @ptrCast(self)), p_range_, pp_candidate_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIManagerEventSink_Value = Guid.initString("cd91d690-a7e8-4265-9b38-8bb3bbaba7de");
pub const IID_IUIManagerEventSink = &IID_IUIManagerEventSink_Value;
pub const IUIManagerEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWindowOpening: *const fn (
            self: *const IUIManagerEventSink,
            prc_bounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowOpened: *const fn (
            self: *const IUIManagerEventSink,
            prc_bounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowUpdating: *const fn (
            self: *const IUIManagerEventSink,
            prc_updated_bounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowUpdated: *const fn (
            self: *const IUIManagerEventSink,
            prc_updated_bounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowClosing: *const fn (
            self: *const IUIManagerEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowClosed: *const fn (
            self: *const IUIManagerEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onWindowOpening(self: *const T, prc_bounds_: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowOpening(@as(*const IUIManagerEventSink, @ptrCast(self)), prc_bounds_);
            }
            pub inline fn onWindowOpened(self: *const T, prc_bounds_: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowOpened(@as(*const IUIManagerEventSink, @ptrCast(self)), prc_bounds_);
            }
            pub inline fn onWindowUpdating(self: *const T, prc_updated_bounds_: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowUpdating(@as(*const IUIManagerEventSink, @ptrCast(self)), prc_updated_bounds_);
            }
            pub inline fn onWindowUpdated(self: *const T, prc_updated_bounds_: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowUpdated(@as(*const IUIManagerEventSink, @ptrCast(self)), prc_updated_bounds_);
            }
            pub inline fn onWindowClosing(self: *const T) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowClosing(@as(*const IUIManagerEventSink, @ptrCast(self)));
            }
            pub inline fn onWindowClosed(self: *const T) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowClosed(@as(*const IUIManagerEventSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const InputScope = enum(i32) {
    DEFAULT = 0,
    URL = 1,
    FILE_FULLFILEPATH = 2,
    FILE_FILENAME = 3,
    EMAIL_USERNAME = 4,
    EMAIL_SMTPEMAILADDRESS = 5,
    LOGINNAME = 6,
    PERSONALNAME_FULLNAME = 7,
    PERSONALNAME_PREFIX = 8,
    PERSONALNAME_GIVENNAME = 9,
    PERSONALNAME_MIDDLENAME = 10,
    PERSONALNAME_SURNAME = 11,
    PERSONALNAME_SUFFIX = 12,
    ADDRESS_FULLPOSTALADDRESS = 13,
    ADDRESS_POSTALCODE = 14,
    ADDRESS_STREET = 15,
    ADDRESS_STATEORPROVINCE = 16,
    ADDRESS_CITY = 17,
    ADDRESS_COUNTRYNAME = 18,
    ADDRESS_COUNTRYSHORTNAME = 19,
    CURRENCY_AMOUNTANDSYMBOL = 20,
    CURRENCY_AMOUNT = 21,
    DATE_FULLDATE = 22,
    DATE_MONTH = 23,
    DATE_DAY = 24,
    DATE_YEAR = 25,
    DATE_MONTHNAME = 26,
    DATE_DAYNAME = 27,
    DIGITS = 28,
    NUMBER = 29,
    ONECHAR = 30,
    PASSWORD = 31,
    TELEPHONE_FULLTELEPHONENUMBER = 32,
    TELEPHONE_COUNTRYCODE = 33,
    TELEPHONE_AREACODE = 34,
    TELEPHONE_LOCALNUMBER = 35,
    TIME_FULLTIME = 36,
    TIME_HOUR = 37,
    TIME_MINORSEC = 38,
    NUMBER_FULLWIDTH = 39,
    ALPHANUMERIC_HALFWIDTH = 40,
    ALPHANUMERIC_FULLWIDTH = 41,
    CURRENCY_CHINESE = 42,
    BOPOMOFO = 43,
    HIRAGANA = 44,
    KATAKANA_HALFWIDTH = 45,
    KATAKANA_FULLWIDTH = 46,
    HANJA = 47,
    HANGUL_HALFWIDTH = 48,
    HANGUL_FULLWIDTH = 49,
    SEARCH = 50,
    FORMULA = 51,
    SEARCH_INCREMENTAL = 52,
    CHINESE_HALFWIDTH = 53,
    CHINESE_FULLWIDTH = 54,
    NATIVE_SCRIPT = 55,
    YOMI = 56,
    TEXT = 57,
    CHAT = 58,
    NAME_OR_PHONENUMBER = 59,
    EMAILNAME_OR_ADDRESS = 60,
    PRIVATE = 61,
    MAPS = 62,
    NUMERIC_PASSWORD = 63,
    NUMERIC_PIN = 64,
    ALPHANUMERIC_PIN = 65,
    ALPHANUMERIC_PIN_SET = 66,
    FORMULA_NUMBER = 67,
    CHAT_WITHOUT_EMOJI = 68,
    PHRASELIST = -1,
    REGULAREXPRESSION = -2,
    SRGS = -3,
    XML = -4,
    ENUMSTRING = -5,
};
pub const IS_DEFAULT = InputScope.DEFAULT;
pub const IS_URL = InputScope.URL;
pub const IS_FILE_FULLFILEPATH = InputScope.FILE_FULLFILEPATH;
pub const IS_FILE_FILENAME = InputScope.FILE_FILENAME;
pub const IS_EMAIL_USERNAME = InputScope.EMAIL_USERNAME;
pub const IS_EMAIL_SMTPEMAILADDRESS = InputScope.EMAIL_SMTPEMAILADDRESS;
pub const IS_LOGINNAME = InputScope.LOGINNAME;
pub const IS_PERSONALNAME_FULLNAME = InputScope.PERSONALNAME_FULLNAME;
pub const IS_PERSONALNAME_PREFIX = InputScope.PERSONALNAME_PREFIX;
pub const IS_PERSONALNAME_GIVENNAME = InputScope.PERSONALNAME_GIVENNAME;
pub const IS_PERSONALNAME_MIDDLENAME = InputScope.PERSONALNAME_MIDDLENAME;
pub const IS_PERSONALNAME_SURNAME = InputScope.PERSONALNAME_SURNAME;
pub const IS_PERSONALNAME_SUFFIX = InputScope.PERSONALNAME_SUFFIX;
pub const IS_ADDRESS_FULLPOSTALADDRESS = InputScope.ADDRESS_FULLPOSTALADDRESS;
pub const IS_ADDRESS_POSTALCODE = InputScope.ADDRESS_POSTALCODE;
pub const IS_ADDRESS_STREET = InputScope.ADDRESS_STREET;
pub const IS_ADDRESS_STATEORPROVINCE = InputScope.ADDRESS_STATEORPROVINCE;
pub const IS_ADDRESS_CITY = InputScope.ADDRESS_CITY;
pub const IS_ADDRESS_COUNTRYNAME = InputScope.ADDRESS_COUNTRYNAME;
pub const IS_ADDRESS_COUNTRYSHORTNAME = InputScope.ADDRESS_COUNTRYSHORTNAME;
pub const IS_CURRENCY_AMOUNTANDSYMBOL = InputScope.CURRENCY_AMOUNTANDSYMBOL;
pub const IS_CURRENCY_AMOUNT = InputScope.CURRENCY_AMOUNT;
pub const IS_DATE_FULLDATE = InputScope.DATE_FULLDATE;
pub const IS_DATE_MONTH = InputScope.DATE_MONTH;
pub const IS_DATE_DAY = InputScope.DATE_DAY;
pub const IS_DATE_YEAR = InputScope.DATE_YEAR;
pub const IS_DATE_MONTHNAME = InputScope.DATE_MONTHNAME;
pub const IS_DATE_DAYNAME = InputScope.DATE_DAYNAME;
pub const IS_DIGITS = InputScope.DIGITS;
pub const IS_NUMBER = InputScope.NUMBER;
pub const IS_ONECHAR = InputScope.ONECHAR;
pub const IS_PASSWORD = InputScope.PASSWORD;
pub const IS_TELEPHONE_FULLTELEPHONENUMBER = InputScope.TELEPHONE_FULLTELEPHONENUMBER;
pub const IS_TELEPHONE_COUNTRYCODE = InputScope.TELEPHONE_COUNTRYCODE;
pub const IS_TELEPHONE_AREACODE = InputScope.TELEPHONE_AREACODE;
pub const IS_TELEPHONE_LOCALNUMBER = InputScope.TELEPHONE_LOCALNUMBER;
pub const IS_TIME_FULLTIME = InputScope.TIME_FULLTIME;
pub const IS_TIME_HOUR = InputScope.TIME_HOUR;
pub const IS_TIME_MINORSEC = InputScope.TIME_MINORSEC;
pub const IS_NUMBER_FULLWIDTH = InputScope.NUMBER_FULLWIDTH;
pub const IS_ALPHANUMERIC_HALFWIDTH = InputScope.ALPHANUMERIC_HALFWIDTH;
pub const IS_ALPHANUMERIC_FULLWIDTH = InputScope.ALPHANUMERIC_FULLWIDTH;
pub const IS_CURRENCY_CHINESE = InputScope.CURRENCY_CHINESE;
pub const IS_BOPOMOFO = InputScope.BOPOMOFO;
pub const IS_HIRAGANA = InputScope.HIRAGANA;
pub const IS_KATAKANA_HALFWIDTH = InputScope.KATAKANA_HALFWIDTH;
pub const IS_KATAKANA_FULLWIDTH = InputScope.KATAKANA_FULLWIDTH;
pub const IS_HANJA = InputScope.HANJA;
pub const IS_HANGUL_HALFWIDTH = InputScope.HANGUL_HALFWIDTH;
pub const IS_HANGUL_FULLWIDTH = InputScope.HANGUL_FULLWIDTH;
pub const IS_SEARCH = InputScope.SEARCH;
pub const IS_FORMULA = InputScope.FORMULA;
pub const IS_SEARCH_INCREMENTAL = InputScope.SEARCH_INCREMENTAL;
pub const IS_CHINESE_HALFWIDTH = InputScope.CHINESE_HALFWIDTH;
pub const IS_CHINESE_FULLWIDTH = InputScope.CHINESE_FULLWIDTH;
pub const IS_NATIVE_SCRIPT = InputScope.NATIVE_SCRIPT;
pub const IS_YOMI = InputScope.YOMI;
pub const IS_TEXT = InputScope.TEXT;
pub const IS_CHAT = InputScope.CHAT;
pub const IS_NAME_OR_PHONENUMBER = InputScope.NAME_OR_PHONENUMBER;
pub const IS_EMAILNAME_OR_ADDRESS = InputScope.EMAILNAME_OR_ADDRESS;
pub const IS_PRIVATE = InputScope.PRIVATE;
pub const IS_MAPS = InputScope.MAPS;
pub const IS_NUMERIC_PASSWORD = InputScope.NUMERIC_PASSWORD;
pub const IS_NUMERIC_PIN = InputScope.NUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN = InputScope.ALPHANUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN_SET = InputScope.ALPHANUMERIC_PIN_SET;
pub const IS_FORMULA_NUMBER = InputScope.FORMULA_NUMBER;
pub const IS_CHAT_WITHOUT_EMOJI = InputScope.CHAT_WITHOUT_EMOJI;
pub const IS_PHRASELIST = InputScope.PHRASELIST;
pub const IS_REGULAREXPRESSION = InputScope.REGULAREXPRESSION;
pub const IS_SRGS = InputScope.SRGS;
pub const IS_XML = InputScope.XML;
pub const IS_ENUMSTRING = InputScope.ENUMSTRING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope_Value = Guid.initString("fde1eaee-6924-4cdf-91e7-da38cff5559d");
pub const IID_ITfInputScope = &IID_ITfInputScope_Value;
pub const ITfInputScope = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputScopes: *const fn (
            self: *const ITfInputScope,
            pprg_input_scopes: [*]?*InputScope,
            pc_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPhrase: *const fn (
            self: *const ITfInputScope,
            ppbstr_phrases: [*]?*?BSTR,
            pc_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegularExpression: *const fn (
            self: *const ITfInputScope,
            pbstr_reg_exp: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSRGS: *const fn (
            self: *const ITfInputScope,
            pbstr_s_r_g_s: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXML: *const fn (
            self: *const ITfInputScope,
            pbstr_x_m_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInputScopes(self: *const T, pprg_input_scopes_: [*]?*InputScope, pc_count_: ?*u32) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetInputScopes(@as(*const ITfInputScope, @ptrCast(self)), pprg_input_scopes_, pc_count_);
            }
            pub inline fn getPhrase(self: *const T, ppbstr_phrases_: [*]?*?BSTR, pc_count_: ?*u32) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetPhrase(@as(*const ITfInputScope, @ptrCast(self)), ppbstr_phrases_, pc_count_);
            }
            pub inline fn getRegularExpression(self: *const T, pbstr_reg_exp_: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetRegularExpression(@as(*const ITfInputScope, @ptrCast(self)), pbstr_reg_exp_);
            }
            pub inline fn getSRGS(self: *const T, pbstr_s_r_g_s_: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetSRGS(@as(*const ITfInputScope, @ptrCast(self)), pbstr_s_r_g_s_);
            }
            pub inline fn getXML(self: *const T, pbstr_x_m_l_: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetXML(@as(*const ITfInputScope, @ptrCast(self)), pbstr_x_m_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope2_Value = Guid.initString("5731eaa0-6bc2-4681-a532-92fbb74d7c41");
pub const IID_ITfInputScope2 = &IID_ITfInputScope2_Value;
pub const ITfInputScope2 = extern struct {
    pub const VTable = extern struct {
        base: ITfInputScope.VTable,
        EnumWordList: *const fn (
            self: *const ITfInputScope2,
            pp_enum_string: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfInputScope.MethodMixin(T);
            pub inline fn enumWordList(self: *const T, pp_enum_string_: ?*?*IEnumString) HRESULT {
                return @as(*const ITfInputScope2.VTable, @ptrCast(self.vtable)).EnumWordList(@as(*const ITfInputScope2, @ptrCast(self)), pp_enum_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSAAControl_Value = Guid.initString("08cd963f-7a3e-4f5c-9bd8-d692bb043c5b");
pub const CLSID_MSAAControl = &CLSID_MSAAControl_Value;

const CLSID_AccStore_Value = Guid.initString("5440837f-4bff-4ae5-a1b1-7722ecc6332a");
pub const CLSID_AccStore = &CLSID_AccStore_Value;

const CLSID_AccDictionary_Value = Guid.initString("6572ee16-5fe5-4331-bb6d-76a49c56e423");
pub const CLSID_AccDictionary = &CLSID_AccDictionary_Value;

const CLSID_AccServerDocMgr_Value = Guid.initString("6089a37e-eb8a-482d-bd6f-f9f46904d16d");
pub const CLSID_AccServerDocMgr = &CLSID_AccServerDocMgr_Value;

const CLSID_AccClientDocMgr_Value = Guid.initString("fc48cc30-4f3e-4fa1-803b-ad0e196a83b1");
pub const CLSID_AccClientDocMgr = &CLSID_AccClientDocMgr_Value;

const CLSID_DocWrap_Value = Guid.initString("bf426f7e-7a5e-44d6-830c-a390ea9462a3");
pub const CLSID_DocWrap = &CLSID_DocWrap_Value;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMSAAControl_Value = Guid.initString("b5f8fb3b-393f-4f7c-84cb-504924c2705a");
pub const IID_ITfMSAAControl = &IID_ITfMSAAControl_Value;
pub const ITfMSAAControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SystemEnableMSAA: *const fn (
            self: *const ITfMSAAControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SystemDisableMSAA: *const fn (
            self: *const ITfMSAAControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn systemEnableMSAA(self: *const T) HRESULT {
                return @as(*const ITfMSAAControl.VTable, @ptrCast(self.vtable)).SystemEnableMSAA(@as(*const ITfMSAAControl, @ptrCast(self)));
            }
            pub inline fn systemDisableMSAA(self: *const T) HRESULT {
                return @as(*const ITfMSAAControl.VTable, @ptrCast(self.vtable)).SystemDisableMSAA(@as(*const ITfMSAAControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternalDocWrap_Value = Guid.initString("e1aa6466-9db4-40ba-be03-77c38e8e60b2");
pub const IID_IInternalDocWrap = &IID_IInternalDocWrap_Value;
pub const IInternalDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRevoke: *const fn (
            self: *const IInternalDocWrap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn notifyRevoke(self: *const T) HRESULT {
                return @as(*const IInternalDocWrap.VTable, @ptrCast(self.vtable)).NotifyRevoke(@as(*const IInternalDocWrap, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPEx_Value = Guid.initString("a2de3bc2-3d8e-11d3-81a9-f753fbe61a00");
pub const IID_ITextStoreACPEx = &IID_ITextStoreACPEx_Value;
pub const ITextStoreACPEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: *const fn (
            self: *const ITextStoreACPEx,
            acp_start: i32,
            acp_end: i32,
            rc: RECT,
            dw_position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn scrollToRect(self: *const T, acp_start_: i32, acp_end_: i32, rc_: RECT, dw_position_: u32) HRESULT {
                return @as(*const ITextStoreACPEx.VTable, @ptrCast(self.vtable)).ScrollToRect(@as(*const ITextStoreACPEx, @ptrCast(self)), acp_start_, acp_end_, rc_, dw_position_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreAnchorEx_Value = Guid.initString("a2de3bc1-3d8e-11d3-81a9-f753fbe61a00");
pub const IID_ITextStoreAnchorEx = &IID_ITextStoreAnchorEx_Value;
pub const ITextStoreAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: *const fn (
            self: *const ITextStoreAnchorEx,
            p_start: ?*IAnchor,
            p_end: ?*IAnchor,
            rc: RECT,
            dw_position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn scrollToRect(self: *const T, p_start_: ?*IAnchor, p_end_: ?*IAnchor, rc_: RECT, dw_position_: u32) HRESULT {
                return @as(*const ITextStoreAnchorEx.VTable, @ptrCast(self.vtable)).ScrollToRect(@as(*const ITextStoreAnchorEx, @ptrCast(self)), p_start_, p_end_, rc_, dw_position_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPSinkEx_Value = Guid.initString("2bdf9464-41e2-43e3-950c-a6865ba25cd4");
pub const IID_ITextStoreACPSinkEx = &IID_ITextStoreACPSinkEx_Value;
pub const ITextStoreACPSinkEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreACPSink.VTable,
        OnDisconnect: *const fn (
            self: *const ITextStoreACPSinkEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoreACPSink.MethodMixin(T);
            pub inline fn onDisconnect(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSinkEx.VTable, @ptrCast(self.vtable)).OnDisconnect(@as(*const ITextStoreACPSinkEx, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreSinkAnchorEx_Value = Guid.initString("25642426-028d-4474-977b-111bb114fe3e");
pub const IID_ITextStoreSinkAnchorEx = &IID_ITextStoreSinkAnchorEx_Value;
pub const ITextStoreSinkAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreAnchorSink.VTable,
        OnDisconnect: *const fn (
            self: *const ITextStoreSinkAnchorEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoreAnchorSink.MethodMixin(T);
            pub inline fn onDisconnect(self: *const T) HRESULT {
                return @as(*const ITextStoreSinkAnchorEx.VTable, @ptrCast(self.vtable)).OnDisconnect(@as(*const ITextStoreSinkAnchorEx, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccDictionary_Value = Guid.initString("1dc4cb5f-d737-474d-ade9-5ccfc9bc1cc9");
pub const IID_IAccDictionary = &IID_IAccDictionary_Value;
pub const IAccDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocalizedString: *const fn (
            self: *const IAccDictionary,
            term: ?*const Guid,
            lcid: u32,
            p_result: ?*?BSTR,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentTerm: *const fn (
            self: *const IAccDictionary,
            term: ?*const Guid,
            p_parent_term: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMnemonicString: *const fn (
            self: *const IAccDictionary,
            term: ?*const Guid,
            p_result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupMnemonicTerm: *const fn (
            self: *const IAccDictionary,
            bstr_mnemonic: ?BSTR,
            p_term: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertValueToString: *const fn (
            self: *const IAccDictionary,
            term: ?*const Guid,
            lcid: u32,
            var_value: VARIANT,
            pbstr_result: ?*?BSTR,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLocalizedString(self: *const T, term_: ?*const Guid, lcid_: u32, p_result_: ?*?BSTR, plcid_: ?*u32) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetLocalizedString(@as(*const IAccDictionary, @ptrCast(self)), term_, lcid_, p_result_, plcid_);
            }
            pub inline fn getParentTerm(self: *const T, term_: ?*const Guid, p_parent_term_: ?*Guid) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetParentTerm(@as(*const IAccDictionary, @ptrCast(self)), term_, p_parent_term_);
            }
            pub inline fn getMnemonicString(self: *const T, term_: ?*const Guid, p_result_: ?*?BSTR) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetMnemonicString(@as(*const IAccDictionary, @ptrCast(self)), term_, p_result_);
            }
            pub inline fn lookupMnemonicTerm(self: *const T, bstr_mnemonic_: ?BSTR, p_term_: ?*Guid) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).LookupMnemonicTerm(@as(*const IAccDictionary, @ptrCast(self)), bstr_mnemonic_, p_term_);
            }
            pub inline fn convertValueToString(self: *const T, term_: ?*const Guid, lcid_: u32, var_value_: VARIANT, pbstr_result_: ?*?BSTR, plcid_: ?*u32) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).ConvertValueToString(@as(*const IAccDictionary, @ptrCast(self)), term_, lcid_, var_value_, pbstr_result_, plcid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVersionInfo_Value = Guid.initString("401518ec-db00-4611-9b29-2a0e4b9afa85");
pub const IID_IVersionInfo = &IID_IVersionInfo_Value;
pub const IVersionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubcomponentCount: *const fn (
            self: *const IVersionInfo,
            ul_sub: u32,
            ul_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplementationID: *const fn (
            self: *const IVersionInfo,
            ul_sub: u32,
            implid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuildVersion: *const fn (
            self: *const IVersionInfo,
            ul_sub: u32,
            pdw_major: ?*u32,
            pdw_minor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentDescription: *const fn (
            self: *const IVersionInfo,
            ul_sub: u32,
            p_impl_str: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstanceDescription: *const fn (
            self: *const IVersionInfo,
            ul_sub: u32,
            p_impl_str: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSubcomponentCount(self: *const T, ul_sub_: u32, ul_count_: ?*u32) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetSubcomponentCount(@as(*const IVersionInfo, @ptrCast(self)), ul_sub_, ul_count_);
            }
            pub inline fn getImplementationID(self: *const T, ul_sub_: u32, implid_: ?*Guid) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetImplementationID(@as(*const IVersionInfo, @ptrCast(self)), ul_sub_, implid_);
            }
            pub inline fn getBuildVersion(self: *const T, ul_sub_: u32, pdw_major_: ?*u32, pdw_minor_: ?*u32) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetBuildVersion(@as(*const IVersionInfo, @ptrCast(self)), ul_sub_, pdw_major_, pdw_minor_);
            }
            pub inline fn getComponentDescription(self: *const T, ul_sub_: u32, p_impl_str_: ?*?BSTR) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetComponentDescription(@as(*const IVersionInfo, @ptrCast(self)), ul_sub_, p_impl_str_);
            }
            pub inline fn getInstanceDescription(self: *const T, ul_sub_: u32, p_impl_str_: ?*?BSTR) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetInstanceDescription(@as(*const IVersionInfo, @ptrCast(self)), ul_sub_, p_impl_str_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICoCreateLocally_Value = Guid.initString("03de00aa-f272-41e3-99cb-03c5e8114ea0");
pub const IID_ICoCreateLocally = &IID_ICoCreateLocally_Value;
pub const ICoCreateLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CoCreateLocally: *const fn (
            self: *const ICoCreateLocally,
            rclsid: ?*const Guid,
            dw_cls_context: u32,
            riid: ?*const Guid,
            punk: ?*?*IUnknown,
            riid_param: ?*const Guid,
            punk_param: ?*IUnknown,
            var_param: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn coCreateLocally(self: *const T, rclsid_: ?*const Guid, dw_cls_context_: u32, riid_: ?*const Guid, punk_: ?*?*IUnknown, riid_param_: ?*const Guid, punk_param_: ?*IUnknown, var_param_: VARIANT) HRESULT {
                return @as(*const ICoCreateLocally.VTable, @ptrCast(self.vtable)).CoCreateLocally(@as(*const ICoCreateLocally, @ptrCast(self)), rclsid_, dw_cls_context_, riid_, punk_, riid_param_, punk_param_, var_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICoCreatedLocally_Value = Guid.initString("0a53eb6c-1908-4742-8cff-2cee2e93f94c");
pub const IID_ICoCreatedLocally = &IID_ICoCreatedLocally_Value;
pub const ICoCreatedLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LocalInit: *const fn (
            self: *const ICoCreatedLocally,
            punk_local_object: ?*IUnknown,
            riid_param: ?*const Guid,
            punk_param: ?*IUnknown,
            var_param: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn localInit(self: *const T, punk_local_object_: ?*IUnknown, riid_param_: ?*const Guid, punk_param_: ?*IUnknown, var_param_: VARIANT) HRESULT {
                return @as(*const ICoCreatedLocally.VTable, @ptrCast(self.vtable)).LocalInit(@as(*const ICoCreatedLocally, @ptrCast(self)), punk_local_object_, riid_param_, punk_param_, var_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccStore_Value = Guid.initString("e2cd4a63-2b72-4d48-b739-95e4765195ba");
pub const IID_IAccStore = &IID_IAccStore_Value;
pub const IAccStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const IAccStore,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: *const fn (
            self: *const IAccStore,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocuments: *const fn (
            self: *const IAccStore,
            enum_unknown: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByHWND: *const fn (
            self: *const IAccStore,
            h_wnd: ?HWND,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByPoint: *const fn (
            self: *const IAccStore,
            pt: POINT,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentFocus: *const fn (
            self: *const IAccStore,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocused: *const fn (
            self: *const IAccStore,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).Register(@as(*const IAccStore, @ptrCast(self)), riid_, punk_);
            }
            pub inline fn unregister(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IAccStore, @ptrCast(self)), punk_);
            }
            pub inline fn getDocuments(self: *const T, enum_unknown_: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).GetDocuments(@as(*const IAccStore, @ptrCast(self)), enum_unknown_);
            }
            pub inline fn lookupByHWND(self: *const T, h_wnd_: ?HWND, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).LookupByHWND(@as(*const IAccStore, @ptrCast(self)), h_wnd_, riid_, ppunk_);
            }
            pub inline fn lookupByPoint(self: *const T, pt_: POINT, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).LookupByPoint(@as(*const IAccStore, @ptrCast(self)), pt_, riid_, ppunk_);
            }
            pub inline fn onDocumentFocus(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).OnDocumentFocus(@as(*const IAccStore, @ptrCast(self)), punk_);
            }
            pub inline fn getFocused(self: *const T, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).GetFocused(@as(*const IAccStore, @ptrCast(self)), riid_, ppunk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccServerDocMgr_Value = Guid.initString("ad7c73cf-6dd5-4855-abc2-b04bad5b9153");
pub const IID_IAccServerDocMgr = &IID_IAccServerDocMgr_Value;
pub const IAccServerDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewDocument: *const fn (
            self: *const IAccServerDocMgr,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeDocument: *const fn (
            self: *const IAccServerDocMgr,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentFocus: *const fn (
            self: *const IAccServerDocMgr,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn newDocument(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).NewDocument(@as(*const IAccServerDocMgr, @ptrCast(self)), riid_, punk_);
            }
            pub inline fn revokeDocument(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).RevokeDocument(@as(*const IAccServerDocMgr, @ptrCast(self)), punk_);
            }
            pub inline fn onDocumentFocus(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).OnDocumentFocus(@as(*const IAccServerDocMgr, @ptrCast(self)), punk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccClientDocMgr_Value = Guid.initString("4c896039-7b6d-49e6-a8c1-45116a98292b");
pub const IID_IAccClientDocMgr = &IID_IAccClientDocMgr_Value;
pub const IAccClientDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocuments: *const fn (
            self: *const IAccClientDocMgr,
            enum_unknown: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByHWND: *const fn (
            self: *const IAccClientDocMgr,
            h_wnd: ?HWND,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByPoint: *const fn (
            self: *const IAccClientDocMgr,
            pt: POINT,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocused: *const fn (
            self: *const IAccClientDocMgr,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDocuments(self: *const T, enum_unknown_: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).GetDocuments(@as(*const IAccClientDocMgr, @ptrCast(self)), enum_unknown_);
            }
            pub inline fn lookupByHWND(self: *const T, h_wnd_: ?HWND, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).LookupByHWND(@as(*const IAccClientDocMgr, @ptrCast(self)), h_wnd_, riid_, ppunk_);
            }
            pub inline fn lookupByPoint(self: *const T, pt_: POINT, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).LookupByPoint(@as(*const IAccClientDocMgr, @ptrCast(self)), pt_, riid_, ppunk_);
            }
            pub inline fn getFocused(self: *const T, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).GetFocused(@as(*const IAccClientDocMgr, @ptrCast(self)), riid_, ppunk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocWrap_Value = Guid.initString("dcd285fe-0be0-43bd-99c9-aaaec513c555");
pub const IID_IDocWrap = &IID_IDocWrap_Value;
pub const IDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDoc: *const fn (
            self: *const IDocWrap,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWrappedDoc: *const fn (
            self: *const IDocWrap,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDoc(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown) HRESULT {
                return @as(*const IDocWrap.VTable, @ptrCast(self.vtable)).SetDoc(@as(*const IDocWrap, @ptrCast(self)), riid_, punk_);
            }
            pub inline fn getWrappedDoc(self: *const T, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IDocWrap.VTable, @ptrCast(self.vtable)).GetWrappedDoc(@as(*const IDocWrap, @ptrCast(self)), riid_, ppunk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IClonableWrapper_Value = Guid.initString("b33e75ff-e84c-4dca-a25c-33b8dc003374");
pub const IID_IClonableWrapper = &IID_IClonableWrapper_Value;
pub const IClonableWrapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloneNewWrapper: *const fn (
            self: *const IClonableWrapper,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn cloneNewWrapper(self: *const T, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IClonableWrapper.VTable, @ptrCast(self.vtable)).CloneNewWrapper(@as(*const IClonableWrapper, @ptrCast(self)), riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSpeechUIServer_Value = Guid.initString("90e9a944-9244-489f-a78f-de67afc013a7");
pub const IID_ITfSpeechUIServer = &IID_ITfSpeechUIServer_Value;
pub const ITfSpeechUIServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const ITfSpeechUIServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowUI: *const fn (
            self: *const ITfSpeechUIServer,
            f_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateBalloon: *const fn (
            self: *const ITfSpeechUIServer,
            style: TfLBBalloonStyle,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITfSpeechUIServer, @ptrCast(self)));
            }
            pub inline fn showUI(self: *const T, f_show_: BOOL) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).ShowUI(@as(*const ITfSpeechUIServer, @ptrCast(self)), f_show_);
            }
            pub inline fn updateBalloon(self: *const T, style_: TfLBBalloonStyle, pch_: [*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).UpdateBalloon(@as(*const ITfSpeechUIServer, @ptrCast(self)), style_, pch_, cch_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (3)
//--------------------------------------------------------------------------------
pub extern "msctfmonitor" fn DoMsCtfMonitor(
    dw_flags: u32,
    h_event_for_service_stop: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msctfmonitor" fn InitLocalMsCtfMonitor(
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msctfmonitor" fn UninitLocalMsCtfMonitor() callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (23)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FORMATETC = @import("../system/com.zig").FORMATETC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDataObject = @import("../system/com.zig").IDataObject;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../foundation.zig").POINT;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SIZE = @import("../foundation.zig").SIZE;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
