//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (462)
//--------------------------------------------------------------------------------
pub const cchTextLimitDefault = @as(u32, 32767);
pub const MSFTEDIT_CLASS = "RICHEDIT50W";
pub const CERICHEDIT_CLASSA = "RichEditCEA";
pub const CERICHEDIT_CLASSW = "RichEditCEW";
pub const RICHEDIT_CLASSA = "RichEdit20A";
pub const RICHEDIT_CLASS10A = "RICHEDIT";
pub const RICHEDIT_CLASSW = "RichEdit20W";
pub const RICHEDIT_CLASS = "RichEdit20W";
pub const EM_CANPASTE = @as(u32, 1074);
pub const EM_DISPLAYBAND = @as(u32, 1075);
pub const EM_EXGETSEL = @as(u32, 1076);
pub const EM_EXLIMITTEXT = @as(u32, 1077);
pub const EM_EXLINEFROMCHAR = @as(u32, 1078);
pub const EM_EXSETSEL = @as(u32, 1079);
pub const EM_FINDTEXT = @as(u32, 1080);
pub const EM_FORMATRANGE = @as(u32, 1081);
pub const EM_GETCHARFORMAT = @as(u32, 1082);
pub const EM_GETEVENTMASK = @as(u32, 1083);
pub const EM_GETOLEINTERFACE = @as(u32, 1084);
pub const EM_GETPARAFORMAT = @as(u32, 1085);
pub const EM_GETSELTEXT = @as(u32, 1086);
pub const EM_HIDESELECTION = @as(u32, 1087);
pub const EM_PASTESPECIAL = @as(u32, 1088);
pub const EM_REQUESTRESIZE = @as(u32, 1089);
pub const EM_SELECTIONTYPE = @as(u32, 1090);
pub const EM_SETBKGNDCOLOR = @as(u32, 1091);
pub const EM_SETCHARFORMAT = @as(u32, 1092);
pub const EM_SETEVENTMASK = @as(u32, 1093);
pub const EM_SETOLECALLBACK = @as(u32, 1094);
pub const EM_SETPARAFORMAT = @as(u32, 1095);
pub const EM_SETTARGETDEVICE = @as(u32, 1096);
pub const EM_STREAMIN = @as(u32, 1097);
pub const EM_STREAMOUT = @as(u32, 1098);
pub const EM_GETTEXTRANGE = @as(u32, 1099);
pub const EM_FINDWORDBREAK = @as(u32, 1100);
pub const EM_SETOPTIONS = @as(u32, 1101);
pub const EM_GETOPTIONS = @as(u32, 1102);
pub const EM_FINDTEXTEX = @as(u32, 1103);
pub const EM_GETWORDBREAKPROCEX = @as(u32, 1104);
pub const EM_SETWORDBREAKPROCEX = @as(u32, 1105);
pub const EM_SETUNDOLIMIT = @as(u32, 1106);
pub const EM_REDO = @as(u32, 1108);
pub const EM_CANREDO = @as(u32, 1109);
pub const EM_GETUNDONAME = @as(u32, 1110);
pub const EM_GETREDONAME = @as(u32, 1111);
pub const EM_STOPGROUPTYPING = @as(u32, 1112);
pub const EM_SETTEXTMODE = @as(u32, 1113);
pub const EM_GETTEXTMODE = @as(u32, 1114);
pub const EM_AUTOURLDETECT = @as(u32, 1115);
pub const AURL_ENABLEURL = @as(u32, 1);
pub const AURL_ENABLEEMAILADDR = @as(u32, 2);
pub const AURL_ENABLETELNO = @as(u32, 4);
pub const AURL_ENABLEEAURLS = @as(u32, 8);
pub const AURL_ENABLEDRIVELETTERS = @as(u32, 16);
pub const AURL_DISABLEMIXEDLGC = @as(u32, 32);
pub const EM_GETAUTOURLDETECT = @as(u32, 1116);
pub const EM_SETPALETTE = @as(u32, 1117);
pub const EM_GETTEXTEX = @as(u32, 1118);
pub const EM_GETTEXTLENGTHEX = @as(u32, 1119);
pub const EM_SHOWSCROLLBAR = @as(u32, 1120);
pub const EM_SETTEXTEX = @as(u32, 1121);
pub const EM_SETPUNCTUATION = @as(u32, 1124);
pub const EM_GETPUNCTUATION = @as(u32, 1125);
pub const EM_SETWORDWRAPMODE = @as(u32, 1126);
pub const EM_GETWORDWRAPMODE = @as(u32, 1127);
pub const EM_SETIMECOLOR = @as(u32, 1128);
pub const EM_GETIMECOLOR = @as(u32, 1129);
pub const EM_SETIMEOPTIONS = @as(u32, 1130);
pub const EM_GETIMEOPTIONS = @as(u32, 1131);
pub const EM_CONVPOSITION = @as(u32, 1132);
pub const EM_SETLANGOPTIONS = @as(u32, 1144);
pub const EM_GETLANGOPTIONS = @as(u32, 1145);
pub const EM_GETIMECOMPMODE = @as(u32, 1146);
pub const EM_FINDTEXTW = @as(u32, 1147);
pub const EM_FINDTEXTEXW = @as(u32, 1148);
pub const EM_RECONVERSION = @as(u32, 1149);
pub const EM_SETIMEMODEBIAS = @as(u32, 1150);
pub const EM_GETIMEMODEBIAS = @as(u32, 1151);
pub const EM_SETBIDIOPTIONS = @as(u32, 1224);
pub const EM_GETBIDIOPTIONS = @as(u32, 1225);
pub const EM_SETTYPOGRAPHYOPTIONS = @as(u32, 1226);
pub const EM_GETTYPOGRAPHYOPTIONS = @as(u32, 1227);
pub const EM_SETEDITSTYLE = @as(u32, 1228);
pub const EM_GETEDITSTYLE = @as(u32, 1229);
pub const SES_EMULATESYSEDIT = @as(u32, 1);
pub const SES_BEEPONMAXTEXT = @as(u32, 2);
pub const SES_EXTENDBACKCOLOR = @as(u32, 4);
pub const SES_MAPCPS = @as(u32, 8);
pub const SES_HYPERLINKTOOLTIPS = @as(u32, 8);
pub const SES_EMULATE10 = @as(u32, 16);
pub const SES_DEFAULTLATINLIGA = @as(u32, 16);
pub const SES_USECRLF = @as(u32, 32);
pub const SES_NOFOCUSLINKNOTIFY = @as(u32, 32);
pub const SES_USEAIMM = @as(u32, 64);
pub const SES_NOIME = @as(u32, 128);
pub const SES_ALLOWBEEPS = @as(u32, 256);
pub const SES_UPPERCASE = @as(u32, 512);
pub const SES_LOWERCASE = @as(u32, 1024);
pub const SES_NOINPUTSEQUENCECHK = @as(u32, 2048);
pub const SES_BIDI = @as(u32, 4096);
pub const SES_SCROLLONKILLFOCUS = @as(u32, 8192);
pub const SES_XLTCRCRLFTOCR = @as(u32, 16384);
pub const SES_DRAFTMODE = @as(u32, 32768);
pub const SES_USECTF = @as(u32, 65536);
pub const SES_HIDEGRIDLINES = @as(u32, 131072);
pub const SES_USEATFONT = @as(u32, 262144);
pub const SES_CUSTOMLOOK = @as(u32, 524288);
pub const SES_LBSCROLLNOTIFY = @as(u32, 1048576);
pub const SES_CTFALLOWEMBED = @as(u32, 2097152);
pub const SES_CTFALLOWSMARTTAG = @as(u32, 4194304);
pub const SES_CTFALLOWPROOFING = @as(u32, 8388608);
pub const SES_LOGICALCARET = @as(u32, 16777216);
pub const SES_WORDDRAGDROP = @as(u32, 33554432);
pub const SES_SMARTDRAGDROP = @as(u32, 67108864);
pub const SES_MULTISELECT = @as(u32, 134217728);
pub const SES_CTFNOLOCK = @as(u32, 268435456);
pub const SES_NOEALINEHEIGHTADJUST = @as(u32, 536870912);
pub const SES_MAX = @as(u32, 536870912);
pub const IMF_AUTOKEYBOARD = @as(u32, 1);
pub const IMF_AUTOFONT = @as(u32, 2);
pub const IMF_IMECANCELCOMPLETE = @as(u32, 4);
pub const IMF_IMEALWAYSSENDNOTIFY = @as(u32, 8);
pub const IMF_AUTOFONTSIZEADJUST = @as(u32, 16);
pub const IMF_UIFONTS = @as(u32, 32);
pub const IMF_NOIMPLICITLANG = @as(u32, 64);
pub const IMF_DUALFONT = @as(u32, 128);
pub const IMF_NOKBDLIDFIXUP = @as(u32, 512);
pub const IMF_NORTFFONTSUBSTITUTE = @as(u32, 1024);
pub const IMF_SPELLCHECKING = @as(u32, 2048);
pub const IMF_TKBPREDICTION = @as(u32, 4096);
pub const IMF_IMEUIINTEGRATION = @as(u32, 8192);
pub const ICM_NOTOPEN = @as(u32, 0);
pub const ICM_LEVEL3 = @as(u32, 1);
pub const ICM_LEVEL2 = @as(u32, 2);
pub const ICM_LEVEL2_5 = @as(u32, 3);
pub const ICM_LEVEL2_SUI = @as(u32, 4);
pub const ICM_CTF = @as(u32, 5);
pub const TO_ADVANCEDTYPOGRAPHY = @as(u32, 1);
pub const TO_SIMPLELINEBREAK = @as(u32, 2);
pub const TO_DISABLECUSTOMTEXTOUT = @as(u32, 4);
pub const TO_ADVANCEDLAYOUT = @as(u32, 8);
pub const EM_OUTLINE = @as(u32, 1244);
pub const EM_GETSCROLLPOS = @as(u32, 1245);
pub const EM_SETSCROLLPOS = @as(u32, 1246);
pub const EM_SETFONTSIZE = @as(u32, 1247);
pub const EM_GETZOOM = @as(u32, 1248);
pub const EM_SETZOOM = @as(u32, 1249);
pub const EM_GETVIEWKIND = @as(u32, 1250);
pub const EM_SETVIEWKIND = @as(u32, 1251);
pub const EM_GETPAGE = @as(u32, 1252);
pub const EM_SETPAGE = @as(u32, 1253);
pub const EM_GETHYPHENATEINFO = @as(u32, 1254);
pub const EM_SETHYPHENATEINFO = @as(u32, 1255);
pub const EM_GETPAGEROTATE = @as(u32, 1259);
pub const EM_SETPAGEROTATE = @as(u32, 1260);
pub const EM_GETCTFMODEBIAS = @as(u32, 1261);
pub const EM_SETCTFMODEBIAS = @as(u32, 1262);
pub const EM_GETCTFOPENSTATUS = @as(u32, 1264);
pub const EM_SETCTFOPENSTATUS = @as(u32, 1265);
pub const EM_GETIMECOMPTEXT = @as(u32, 1266);
pub const EM_ISIME = @as(u32, 1267);
pub const EM_GETIMEPROPERTY = @as(u32, 1268);
pub const EM_GETQUERYRTFOBJ = @as(u32, 1293);
pub const EM_SETQUERYRTFOBJ = @as(u32, 1294);
pub const EPR_0 = @as(u32, 0);
pub const EPR_270 = @as(u32, 1);
pub const EPR_180 = @as(u32, 2);
pub const EPR_90 = @as(u32, 3);
pub const EPR_SE = @as(u32, 5);
pub const CTFMODEBIAS_DEFAULT = @as(u32, 0);
pub const CTFMODEBIAS_FILENAME = @as(u32, 1);
pub const CTFMODEBIAS_NAME = @as(u32, 2);
pub const CTFMODEBIAS_READING = @as(u32, 3);
pub const CTFMODEBIAS_DATETIME = @as(u32, 4);
pub const CTFMODEBIAS_CONVERSATION = @as(u32, 5);
pub const CTFMODEBIAS_NUMERIC = @as(u32, 6);
pub const CTFMODEBIAS_HIRAGANA = @as(u32, 7);
pub const CTFMODEBIAS_KATAKANA = @as(u32, 8);
pub const CTFMODEBIAS_HANGUL = @as(u32, 9);
pub const CTFMODEBIAS_HALFWIDTHKATAKANA = @as(u32, 10);
pub const CTFMODEBIAS_FULLWIDTHALPHANUMERIC = @as(u32, 11);
pub const CTFMODEBIAS_HALFWIDTHALPHANUMERIC = @as(u32, 12);
pub const IMF_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IMF_SMODE_NONE = @as(u32, 2);
pub const EMO_EXIT = @as(u32, 0);
pub const EMO_ENTER = @as(u32, 1);
pub const EMO_PROMOTE = @as(u32, 2);
pub const EMO_EXPAND = @as(u32, 3);
pub const EMO_MOVESELECTION = @as(u32, 4);
pub const EMO_GETVIEWMODE = @as(u32, 5);
pub const EMO_EXPANDSELECTION = @as(u32, 0);
pub const EMO_EXPANDDOCUMENT = @as(u32, 1);
pub const VM_NORMAL = @as(u32, 4);
pub const VM_OUTLINE = @as(u32, 2);
pub const VM_PAGE = @as(u32, 9);
pub const EM_INSERTTABLE = @as(u32, 1256);
pub const EM_GETAUTOCORRECTPROC = @as(u32, 1257);
pub const EM_SETAUTOCORRECTPROC = @as(u32, 1258);
pub const EM_CALLAUTOCORRECTPROC = @as(u32, 1279);
pub const ATP_NOCHANGE = @as(u32, 0);
pub const ATP_CHANGE = @as(u32, 1);
pub const ATP_NODELIMITER = @as(u32, 2);
pub const ATP_REPLACEALLTEXT = @as(u32, 4);
pub const EM_GETTABLEPARMS = @as(u32, 1289);
pub const EM_SETEDITSTYLEEX = @as(u32, 1299);
pub const EM_GETEDITSTYLEEX = @as(u32, 1300);
pub const SES_EX_NOTABLE = @as(u32, 4);
pub const SES_EX_NOMATH = @as(u32, 64);
pub const SES_EX_HANDLEFRIENDLYURL = @as(u32, 256);
pub const SES_EX_NOTHEMING = @as(u32, 524288);
pub const SES_EX_NOACETATESELECTION = @as(u32, 1048576);
pub const SES_EX_USESINGLELINE = @as(u32, 2097152);
pub const SES_EX_MULTITOUCH = @as(u32, 134217728);
pub const SES_EX_HIDETEMPFORMAT = @as(u32, 268435456);
pub const SES_EX_USEMOUSEWPARAM = @as(u32, 536870912);
pub const EM_GETSTORYTYPE = @as(u32, 1314);
pub const EM_SETSTORYTYPE = @as(u32, 1315);
pub const EM_GETELLIPSISMODE = @as(u32, 1329);
pub const EM_SETELLIPSISMODE = @as(u32, 1330);
pub const ELLIPSIS_MASK = @as(u32, 3);
pub const ELLIPSIS_NONE = @as(u32, 0);
pub const ELLIPSIS_END = @as(u32, 1);
pub const ELLIPSIS_WORD = @as(u32, 3);
pub const EM_SETTABLEPARMS = @as(u32, 1331);
pub const EM_GETTOUCHOPTIONS = @as(u32, 1334);
pub const EM_SETTOUCHOPTIONS = @as(u32, 1335);
pub const EM_INSERTIMAGE = @as(u32, 1338);
pub const EM_SETUIANAME = @as(u32, 1344);
pub const EM_GETELLIPSISSTATE = @as(u32, 1346);
pub const RTO_SHOWHANDLES = @as(u32, 1);
pub const RTO_DISABLEHANDLES = @as(u32, 2);
pub const RTO_READINGMODE = @as(u32, 3);
pub const EN_MSGFILTER = @as(u32, 1792);
pub const EN_REQUESTRESIZE = @as(u32, 1793);
pub const EN_SELCHANGE = @as(u32, 1794);
pub const EN_DROPFILES = @as(u32, 1795);
pub const EN_PROTECTED = @as(u32, 1796);
pub const EN_CORRECTTEXT = @as(u32, 1797);
pub const EN_STOPNOUNDO = @as(u32, 1798);
pub const EN_IMECHANGE = @as(u32, 1799);
pub const EN_SAVECLIPBOARD = @as(u32, 1800);
pub const EN_OLEOPFAILED = @as(u32, 1801);
pub const EN_OBJECTPOSITIONS = @as(u32, 1802);
pub const EN_LINK = @as(u32, 1803);
pub const EN_DRAGDROPDONE = @as(u32, 1804);
pub const EN_PARAGRAPHEXPANDED = @as(u32, 1805);
pub const EN_PAGECHANGE = @as(u32, 1806);
pub const EN_LOWFIRTF = @as(u32, 1807);
pub const EN_ALIGNLTR = @as(u32, 1808);
pub const EN_ALIGNRTL = @as(u32, 1809);
pub const EN_CLIPFORMAT = @as(u32, 1810);
pub const EN_STARTCOMPOSITION = @as(u32, 1811);
pub const EN_ENDCOMPOSITION = @as(u32, 1812);
pub const ENM_NONE = @as(u32, 0);
pub const ENM_CHANGE = @as(u32, 1);
pub const ENM_UPDATE = @as(u32, 2);
pub const ENM_SCROLL = @as(u32, 4);
pub const ENM_SCROLLEVENTS = @as(u32, 8);
pub const ENM_DRAGDROPDONE = @as(u32, 16);
pub const ENM_PARAGRAPHEXPANDED = @as(u32, 32);
pub const ENM_PAGECHANGE = @as(u32, 64);
pub const ENM_CLIPFORMAT = @as(u32, 128);
pub const ENM_KEYEVENTS = @as(u32, 65536);
pub const ENM_MOUSEEVENTS = @as(u32, 131072);
pub const ENM_REQUESTRESIZE = @as(u32, 262144);
pub const ENM_SELCHANGE = @as(u32, 524288);
pub const ENM_DROPFILES = @as(u32, 1048576);
pub const ENM_PROTECTED = @as(u32, 2097152);
pub const ENM_CORRECTTEXT = @as(u32, 4194304);
pub const ENM_IMECHANGE = @as(u32, 8388608);
pub const ENM_LANGCHANGE = @as(u32, 16777216);
pub const ENM_OBJECTPOSITIONS = @as(u32, 33554432);
pub const ENM_LINK = @as(u32, 67108864);
pub const ENM_LOWFIRTF = @as(u32, 134217728);
pub const ENM_STARTCOMPOSITION = @as(u32, 268435456);
pub const ENM_ENDCOMPOSITION = @as(u32, 536870912);
pub const ENM_GROUPTYPINGCHANGE = @as(u32, 1073741824);
pub const ENM_HIDELINKTOOLTIP = @as(u32, 2147483648);
pub const ES_SAVESEL = @as(u32, 32768);
pub const ES_SUNKEN = @as(u32, 16384);
pub const ES_DISABLENOSCROLL = @as(u32, 8192);
pub const ES_SELECTIONBAR = @as(u32, 16777216);
pub const ES_NOOLEDRAGDROP = @as(u32, 8);
pub const ES_EX_NOCALLOLEINIT = @as(u32, 0);
pub const ES_VERTICAL = @as(u32, 4194304);
pub const ES_NOIME = @as(u32, 524288);
pub const ES_SELFIME = @as(u32, 262144);
pub const ECO_AUTOWORDSELECTION = @as(u32, 1);
pub const ECO_AUTOVSCROLL = @as(u32, 64);
pub const ECO_AUTOHSCROLL = @as(u32, 128);
pub const ECO_NOHIDESEL = @as(u32, 256);
pub const ECO_READONLY = @as(u32, 2048);
pub const ECO_WANTRETURN = @as(u32, 4096);
pub const ECO_SAVESEL = @as(u32, 32768);
pub const ECO_SELECTIONBAR = @as(u32, 16777216);
pub const ECO_VERTICAL = @as(u32, 4194304);
pub const ECOOP_SET = @as(u32, 1);
pub const ECOOP_OR = @as(u32, 2);
pub const ECOOP_AND = @as(u32, 3);
pub const ECOOP_XOR = @as(u32, 4);
pub const WB_MOVEWORDPREV = @as(u32, 4);
pub const WB_MOVEWORDNEXT = @as(u32, 5);
pub const WB_PREVBREAK = @as(u32, 6);
pub const WB_NEXTBREAK = @as(u32, 7);
pub const PC_FOLLOWING = @as(u32, 1);
pub const PC_LEADING = @as(u32, 2);
pub const PC_OVERFLOW = @as(u32, 3);
pub const PC_DELIMITER = @as(u32, 4);
pub const WBF_WORDWRAP = @as(u32, 16);
pub const WBF_WORDBREAK = @as(u32, 32);
pub const WBF_OVERFLOW = @as(u32, 64);
pub const WBF_LEVEL1 = @as(u32, 128);
pub const WBF_LEVEL2 = @as(u32, 256);
pub const WBF_CUSTOM = @as(u32, 512);
pub const IMF_FORCENONE = @as(u32, 1);
pub const IMF_FORCEENABLE = @as(u32, 2);
pub const IMF_FORCEDISABLE = @as(u32, 4);
pub const IMF_CLOSESTATUSWINDOW = @as(u32, 8);
pub const IMF_VERTICAL = @as(u32, 32);
pub const IMF_FORCEACTIVE = @as(u32, 64);
pub const IMF_FORCEINACTIVE = @as(u32, 128);
pub const IMF_FORCEREMEMBER = @as(u32, 256);
pub const IMF_MULTIPLEEDIT = @as(u32, 1024);
pub const yHeightCharPtsMost = @as(u32, 1638);
pub const SCF_SELECTION = @as(u32, 1);
pub const SCF_WORD = @as(u32, 2);
pub const SCF_DEFAULT = @as(u32, 0);
pub const SCF_ALL = @as(u32, 4);
pub const SCF_USEUIRULES = @as(u32, 8);
pub const SCF_ASSOCIATEFONT = @as(u32, 16);
pub const SCF_NOKBUPDATE = @as(u32, 32);
pub const SCF_ASSOCIATEFONT2 = @as(u32, 64);
pub const SCF_SMARTFONT = @as(u32, 128);
pub const SCF_CHARREPFROMLCID = @as(u32, 256);
pub const SPF_DONTSETDEFAULT = @as(u32, 2);
pub const SPF_SETDEFAULT = @as(u32, 4);
pub const SF_TEXT = @as(u32, 1);
pub const SF_RTF = @as(u32, 2);
pub const SF_RTFNOOBJS = @as(u32, 3);
pub const SF_TEXTIZED = @as(u32, 4);
pub const SF_UNICODE = @as(u32, 16);
pub const SF_USECODEPAGE = @as(u32, 32);
pub const SF_NCRFORNONASCII = @as(u32, 64);
pub const SFF_WRITEXTRAPAR = @as(u32, 128);
pub const SFF_SELECTION = @as(u32, 32768);
pub const SFF_PLAINRTF = @as(u32, 16384);
pub const SFF_PERSISTVIEWSCALE = @as(u32, 8192);
pub const SFF_KEEPDOCINFO = @as(u32, 4096);
pub const SFF_PWD = @as(u32, 2048);
pub const SF_RTFVAL = @as(u32, 1792);
pub const MAX_TAB_STOPS = @as(u32, 32);
pub const lDefaultTab = @as(u32, 720);
pub const MAX_TABLE_CELLS = @as(u32, 63);
pub const PFM_SPACEBEFORE = @as(u32, 64);
pub const PFM_SPACEAFTER = @as(u32, 128);
pub const PFM_LINESPACING = @as(u32, 256);
pub const PFM_STYLE = @as(u32, 1024);
pub const PFM_BORDER = @as(u32, 2048);
pub const PFM_SHADING = @as(u32, 4096);
pub const PFM_NUMBERINGSTYLE = @as(u32, 8192);
pub const PFM_NUMBERINGTAB = @as(u32, 16384);
pub const PFM_NUMBERINGSTART = @as(u32, 32768);
pub const PFM_KEEP = @as(u32, 131072);
pub const PFM_KEEPNEXT = @as(u32, 262144);
pub const PFM_PAGEBREAKBEFORE = @as(u32, 524288);
pub const PFM_NOLINENUMBER = @as(u32, 1048576);
pub const PFM_NOWIDOWCONTROL = @as(u32, 2097152);
pub const PFM_DONOTHYPHEN = @as(u32, 4194304);
pub const PFM_SIDEBYSIDE = @as(u32, 8388608);
pub const PFM_COLLAPSED = @as(u32, 16777216);
pub const PFM_OUTLINELEVEL = @as(u32, 33554432);
pub const PFM_BOX = @as(u32, 67108864);
pub const PFM_RESERVED2 = @as(u32, 134217728);
pub const PFM_TABLEROWDELIMITER = @as(u32, 268435456);
pub const PFM_TEXTWRAPPINGBREAK = @as(u32, 536870912);
pub const PFM_TABLE = @as(u32, 1073741824);
pub const PFN_BULLET = @as(u32, 1);
pub const PFN_ARABIC = @as(u32, 2);
pub const PFN_LCLETTER = @as(u32, 3);
pub const PFN_UCLETTER = @as(u32, 4);
pub const PFN_LCROMAN = @as(u32, 5);
pub const PFN_UCROMAN = @as(u32, 6);
pub const PFA_JUSTIFY = @as(u32, 4);
pub const PFA_FULL_INTERWORD = @as(u32, 4);
pub const GCMF_GRIPPER = @as(u32, 1);
pub const GCMF_SPELLING = @as(u32, 2);
pub const GCMF_TOUCHMENU = @as(u32, 16384);
pub const GCMF_MOUSEMENU = @as(u32, 8192);
pub const OLEOP_DOVERB = @as(u32, 1);
pub const CF_RTF = "Rich Text Format";
pub const CF_RTFNOOBJS = "Rich Text Format Without Objects";
pub const CF_RETEXTOBJ = "RichEdit Text and Objects";
pub const ST_DEFAULT = @as(u32, 0);
pub const ST_KEEPUNDO = @as(u32, 1);
pub const ST_SELECTION = @as(u32, 2);
pub const ST_NEWCHARS = @as(u32, 4);
pub const ST_UNICODE = @as(u32, 8);
pub const BOM_DEFPARADIR = @as(u32, 1);
pub const BOM_PLAINTEXT = @as(u32, 2);
pub const BOM_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOM_CONTEXTREADING = @as(u32, 8);
pub const BOM_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOM_LEGACYBIDICLASS = @as(u32, 64);
pub const BOM_UNICODEBIDI = @as(u32, 128);
pub const BOE_RTLDIR = @as(u32, 1);
pub const BOE_PLAINTEXT = @as(u32, 2);
pub const BOE_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOE_CONTEXTREADING = @as(u32, 8);
pub const BOE_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOE_FORCERECALC = @as(u32, 32);
pub const BOE_LEGACYBIDICLASS = @as(u32, 64);
pub const BOE_UNICODEBIDI = @as(u32, 128);
pub const FR_MATCHDIAC = @as(u32, 536870912);
pub const FR_MATCHKASHIDA = @as(u32, 1073741824);
pub const FR_MATCHALEFHAMZA = @as(u32, 2147483648);
pub const RICHEDIT60_CLASS = "RICHEDIT60W";
pub const PFA_FULL_NEWSPAPER = @as(u32, 5);
pub const PFA_FULL_INTERLETTER = @as(u32, 6);
pub const PFA_FULL_SCALED = @as(u32, 7);
pub const PFA_FULL_GLYPHS = @as(u32, 8);
pub const AURL_ENABLEEA = @as(u32, 1);
pub const GCM_TOUCHMENU = @as(u32, 16384);
pub const GCM_MOUSEMENU = @as(u32, 8192);
pub const S_MSG_KEY_IGNORED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const TXTBIT_RICHTEXT = @as(u32, 1);
pub const TXTBIT_MULTILINE = @as(u32, 2);
pub const TXTBIT_READONLY = @as(u32, 4);
pub const TXTBIT_SHOWACCELERATOR = @as(u32, 8);
pub const TXTBIT_USEPASSWORD = @as(u32, 16);
pub const TXTBIT_HIDESELECTION = @as(u32, 32);
pub const TXTBIT_SAVESELECTION = @as(u32, 64);
pub const TXTBIT_AUTOWORDSEL = @as(u32, 128);
pub const TXTBIT_VERTICAL = @as(u32, 256);
pub const TXTBIT_SELBARCHANGE = @as(u32, 512);
pub const TXTBIT_WORDWRAP = @as(u32, 1024);
pub const TXTBIT_ALLOWBEEP = @as(u32, 2048);
pub const TXTBIT_DISABLEDRAG = @as(u32, 4096);
pub const TXTBIT_VIEWINSETCHANGE = @as(u32, 8192);
pub const TXTBIT_BACKSTYLECHANGE = @as(u32, 16384);
pub const TXTBIT_MAXLENGTHCHANGE = @as(u32, 32768);
pub const TXTBIT_SCROLLBARCHANGE = @as(u32, 65536);
pub const TXTBIT_CHARFORMATCHANGE = @as(u32, 131072);
pub const TXTBIT_PARAFORMATCHANGE = @as(u32, 262144);
pub const TXTBIT_EXTENTCHANGE = @as(u32, 524288);
pub const TXTBIT_CLIENTRECTCHANGE = @as(u32, 1048576);
pub const TXTBIT_USECURRENTBKG = @as(u32, 2097152);
pub const TXTBIT_NOTHREADREFCOUNT = @as(u32, 4194304);
pub const TXTBIT_SHOWPASSWORD = @as(u32, 8388608);
pub const TXTBIT_D2DDWRITE = @as(u32, 16777216);
pub const TXTBIT_D2DSIMPLETYPOGRAPHY = @as(u32, 33554432);
pub const TXTBIT_D2DPIXELSNAPPED = @as(u32, 67108864);
pub const TXTBIT_D2DSUBPIXELLINES = @as(u32, 134217728);
pub const TXTBIT_FLASHLASTPASSWORDCHAR = @as(u32, 268435456);
pub const TXTBIT_ADVANCEDINPUT = @as(u32, 536870912);
pub const TXES_ISDIALOG = @as(u32, 1);
pub const REO_NULL = @as(i32, 0);
pub const REO_READWRITEMASK = @as(i32, 2047);
pub const RECO_PASTE = @as(i32, 0);
pub const RECO_DROP = @as(i32, 1);
pub const RECO_COPY = @as(i32, 2);
pub const RECO_CUT = @as(i32, 3);
pub const RECO_DRAG = @as(i32, 4);

//--------------------------------------------------------------------------------
// Section: Types (101)
//--------------------------------------------------------------------------------
pub const CFM_MASK = enum(u32) {
    SUBSCRIPT = 196608,
    // SUPERSCRIPT = 196608, this enum value conflicts with SUBSCRIPT
    EFFECTS = 1073741887,
    ALL = 4160749631,
    BOLD = 1,
    CHARSET = 134217728,
    COLOR = 1073741824,
    FACE = 536870912,
    ITALIC = 2,
    OFFSET = 268435456,
    PROTECTED = 16,
    SIZE = 2147483648,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    LINK = 32,
    SMALLCAPS = 64,
    ALLCAPS = 128,
    HIDDEN = 256,
    OUTLINE = 512,
    SHADOW = 1024,
    EMBOSS = 2048,
    IMPRINT = 4096,
    DISABLED = 8192,
    REVISED = 16384,
    REVAUTHOR = 32768,
    ANIMATION = 262144,
    STYLE = 524288,
    KERNING = 1048576,
    SPACING = 2097152,
    WEIGHT = 4194304,
    UNDERLINETYPE = 8388608,
    COOKIE = 16777216,
    LCID = 33554432,
    BACKCOLOR = 67108864,
    EFFECTS2 = 1141080063,
    ALL2 = 4294967295,
    // FONTBOUND = 1048576, this enum value conflicts with KERNING
    // LINKPROTECTED = 8388608, this enum value conflicts with UNDERLINETYPE
    // EXTENDED = 33554432, this enum value conflicts with LCID
    // MATHNOBUILDUP = 134217728, this enum value conflicts with CHARSET
    // MATH = 268435456, this enum value conflicts with OFFSET
    // MATHORDINARY = 536870912, this enum value conflicts with FACE
    ALLEFFECTS = 2115207167,
    _,
    pub fn initFlags(o: struct {
        SUBSCRIPT: u1 = 0,
        EFFECTS: u1 = 0,
        ALL: u1 = 0,
        BOLD: u1 = 0,
        CHARSET: u1 = 0,
        COLOR: u1 = 0,
        FACE: u1 = 0,
        ITALIC: u1 = 0,
        OFFSET: u1 = 0,
        PROTECTED: u1 = 0,
        SIZE: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        LINK: u1 = 0,
        SMALLCAPS: u1 = 0,
        ALLCAPS: u1 = 0,
        HIDDEN: u1 = 0,
        OUTLINE: u1 = 0,
        SHADOW: u1 = 0,
        EMBOSS: u1 = 0,
        IMPRINT: u1 = 0,
        DISABLED: u1 = 0,
        REVISED: u1 = 0,
        REVAUTHOR: u1 = 0,
        ANIMATION: u1 = 0,
        STYLE: u1 = 0,
        KERNING: u1 = 0,
        SPACING: u1 = 0,
        WEIGHT: u1 = 0,
        UNDERLINETYPE: u1 = 0,
        COOKIE: u1 = 0,
        LCID: u1 = 0,
        BACKCOLOR: u1 = 0,
        EFFECTS2: u1 = 0,
        ALL2: u1 = 0,
        ALLEFFECTS: u1 = 0,
    }) CFM_MASK {
        return @as(CFM_MASK, @enumFromInt((if (o.SUBSCRIPT == 1) @intFromEnum(CFM_MASK.SUBSCRIPT) else 0) | (if (o.EFFECTS == 1) @intFromEnum(CFM_MASK.EFFECTS) else 0) | (if (o.ALL == 1) @intFromEnum(CFM_MASK.ALL) else 0) | (if (o.BOLD == 1) @intFromEnum(CFM_MASK.BOLD) else 0) | (if (o.CHARSET == 1) @intFromEnum(CFM_MASK.CHARSET) else 0) | (if (o.COLOR == 1) @intFromEnum(CFM_MASK.COLOR) else 0) | (if (o.FACE == 1) @intFromEnum(CFM_MASK.FACE) else 0) | (if (o.ITALIC == 1) @intFromEnum(CFM_MASK.ITALIC) else 0) | (if (o.OFFSET == 1) @intFromEnum(CFM_MASK.OFFSET) else 0) | (if (o.PROTECTED == 1) @intFromEnum(CFM_MASK.PROTECTED) else 0) | (if (o.SIZE == 1) @intFromEnum(CFM_MASK.SIZE) else 0) | (if (o.STRIKEOUT == 1) @intFromEnum(CFM_MASK.STRIKEOUT) else 0) | (if (o.UNDERLINE == 1) @intFromEnum(CFM_MASK.UNDERLINE) else 0) | (if (o.LINK == 1) @intFromEnum(CFM_MASK.LINK) else 0) | (if (o.SMALLCAPS == 1) @intFromEnum(CFM_MASK.SMALLCAPS) else 0) | (if (o.ALLCAPS == 1) @intFromEnum(CFM_MASK.ALLCAPS) else 0) | (if (o.HIDDEN == 1) @intFromEnum(CFM_MASK.HIDDEN) else 0) | (if (o.OUTLINE == 1) @intFromEnum(CFM_MASK.OUTLINE) else 0) | (if (o.SHADOW == 1) @intFromEnum(CFM_MASK.SHADOW) else 0) | (if (o.EMBOSS == 1) @intFromEnum(CFM_MASK.EMBOSS) else 0) | (if (o.IMPRINT == 1) @intFromEnum(CFM_MASK.IMPRINT) else 0) | (if (o.DISABLED == 1) @intFromEnum(CFM_MASK.DISABLED) else 0) | (if (o.REVISED == 1) @intFromEnum(CFM_MASK.REVISED) else 0) | (if (o.REVAUTHOR == 1) @intFromEnum(CFM_MASK.REVAUTHOR) else 0) | (if (o.ANIMATION == 1) @intFromEnum(CFM_MASK.ANIMATION) else 0) | (if (o.STYLE == 1) @intFromEnum(CFM_MASK.STYLE) else 0) | (if (o.KERNING == 1) @intFromEnum(CFM_MASK.KERNING) else 0) | (if (o.SPACING == 1) @intFromEnum(CFM_MASK.SPACING) else 0) | (if (o.WEIGHT == 1) @intFromEnum(CFM_MASK.WEIGHT) else 0) | (if (o.UNDERLINETYPE == 1) @intFromEnum(CFM_MASK.UNDERLINETYPE) else 0) | (if (o.COOKIE == 1) @intFromEnum(CFM_MASK.COOKIE) else 0) | (if (o.LCID == 1) @intFromEnum(CFM_MASK.LCID) else 0) | (if (o.BACKCOLOR == 1) @intFromEnum(CFM_MASK.BACKCOLOR) else 0) | (if (o.EFFECTS2 == 1) @intFromEnum(CFM_MASK.EFFECTS2) else 0) | (if (o.ALL2 == 1) @intFromEnum(CFM_MASK.ALL2) else 0) | (if (o.ALLEFFECTS == 1) @intFromEnum(CFM_MASK.ALLEFFECTS) else 0)));
    }
};
pub const CFM_SUBSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_SUPERSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS = CFM_MASK.EFFECTS;
pub const CFM_ALL = CFM_MASK.ALL;
pub const CFM_BOLD = CFM_MASK.BOLD;
pub const CFM_CHARSET = CFM_MASK.CHARSET;
pub const CFM_COLOR = CFM_MASK.COLOR;
pub const CFM_FACE = CFM_MASK.FACE;
pub const CFM_ITALIC = CFM_MASK.ITALIC;
pub const CFM_OFFSET = CFM_MASK.OFFSET;
pub const CFM_PROTECTED = CFM_MASK.PROTECTED;
pub const CFM_SIZE = CFM_MASK.SIZE;
pub const CFM_STRIKEOUT = CFM_MASK.STRIKEOUT;
pub const CFM_UNDERLINE = CFM_MASK.UNDERLINE;
pub const CFM_LINK = CFM_MASK.LINK;
pub const CFM_SMALLCAPS = CFM_MASK.SMALLCAPS;
pub const CFM_ALLCAPS = CFM_MASK.ALLCAPS;
pub const CFM_HIDDEN = CFM_MASK.HIDDEN;
pub const CFM_OUTLINE = CFM_MASK.OUTLINE;
pub const CFM_SHADOW = CFM_MASK.SHADOW;
pub const CFM_EMBOSS = CFM_MASK.EMBOSS;
pub const CFM_IMPRINT = CFM_MASK.IMPRINT;
pub const CFM_DISABLED = CFM_MASK.DISABLED;
pub const CFM_REVISED = CFM_MASK.REVISED;
pub const CFM_REVAUTHOR = CFM_MASK.REVAUTHOR;
pub const CFM_ANIMATION = CFM_MASK.ANIMATION;
pub const CFM_STYLE = CFM_MASK.STYLE;
pub const CFM_KERNING = CFM_MASK.KERNING;
pub const CFM_SPACING = CFM_MASK.SPACING;
pub const CFM_WEIGHT = CFM_MASK.WEIGHT;
pub const CFM_UNDERLINETYPE = CFM_MASK.UNDERLINETYPE;
pub const CFM_COOKIE = CFM_MASK.COOKIE;
pub const CFM_LCID = CFM_MASK.LCID;
pub const CFM_BACKCOLOR = CFM_MASK.BACKCOLOR;
pub const CFM_EFFECTS2 = CFM_MASK.EFFECTS2;
pub const CFM_ALL2 = CFM_MASK.ALL2;
pub const CFM_FONTBOUND = CFM_MASK.KERNING;
pub const CFM_LINKPROTECTED = CFM_MASK.UNDERLINETYPE;
pub const CFM_EXTENDED = CFM_MASK.LCID;
pub const CFM_MATHNOBUILDUP = CFM_MASK.CHARSET;
pub const CFM_MATH = CFM_MASK.OFFSET;
pub const CFM_MATHORDINARY = CFM_MASK.FACE;
pub const CFM_ALLEFFECTS = CFM_MASK.ALLEFFECTS;

pub const CFE_EFFECTS = enum(u32) {
    ALLCAPS = 128,
    AUTOBACKCOLOR = 67108864,
    DISABLED = 8192,
    EMBOSS = 2048,
    HIDDEN = 256,
    IMPRINT = 4096,
    OUTLINE = 512,
    REVISED = 16384,
    SHADOW = 1024,
    SMALLCAPS = 64,
    AUTOCOLOR = 1073741824,
    BOLD = 1,
    ITALIC = 2,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    PROTECTED = 16,
    LINK = 32,
    SUBSCRIPT = 65536,
    SUPERSCRIPT = 131072,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    _,
    pub fn initFlags(o: struct {
        ALLCAPS: u1 = 0,
        AUTOBACKCOLOR: u1 = 0,
        DISABLED: u1 = 0,
        EMBOSS: u1 = 0,
        HIDDEN: u1 = 0,
        IMPRINT: u1 = 0,
        OUTLINE: u1 = 0,
        REVISED: u1 = 0,
        SHADOW: u1 = 0,
        SMALLCAPS: u1 = 0,
        AUTOCOLOR: u1 = 0,
        BOLD: u1 = 0,
        ITALIC: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        PROTECTED: u1 = 0,
        LINK: u1 = 0,
        SUBSCRIPT: u1 = 0,
        SUPERSCRIPT: u1 = 0,
        FONTBOUND: u1 = 0,
        LINKPROTECTED: u1 = 0,
        EXTENDED: u1 = 0,
        MATHNOBUILDUP: u1 = 0,
        MATH: u1 = 0,
        MATHORDINARY: u1 = 0,
    }) CFE_EFFECTS {
        return @as(CFE_EFFECTS, @enumFromInt((if (o.ALLCAPS == 1) @intFromEnum(CFE_EFFECTS.ALLCAPS) else 0) | (if (o.AUTOBACKCOLOR == 1) @intFromEnum(CFE_EFFECTS.AUTOBACKCOLOR) else 0) | (if (o.DISABLED == 1) @intFromEnum(CFE_EFFECTS.DISABLED) else 0) | (if (o.EMBOSS == 1) @intFromEnum(CFE_EFFECTS.EMBOSS) else 0) | (if (o.HIDDEN == 1) @intFromEnum(CFE_EFFECTS.HIDDEN) else 0) | (if (o.IMPRINT == 1) @intFromEnum(CFE_EFFECTS.IMPRINT) else 0) | (if (o.OUTLINE == 1) @intFromEnum(CFE_EFFECTS.OUTLINE) else 0) | (if (o.REVISED == 1) @intFromEnum(CFE_EFFECTS.REVISED) else 0) | (if (o.SHADOW == 1) @intFromEnum(CFE_EFFECTS.SHADOW) else 0) | (if (o.SMALLCAPS == 1) @intFromEnum(CFE_EFFECTS.SMALLCAPS) else 0) | (if (o.AUTOCOLOR == 1) @intFromEnum(CFE_EFFECTS.AUTOCOLOR) else 0) | (if (o.BOLD == 1) @intFromEnum(CFE_EFFECTS.BOLD) else 0) | (if (o.ITALIC == 1) @intFromEnum(CFE_EFFECTS.ITALIC) else 0) | (if (o.STRIKEOUT == 1) @intFromEnum(CFE_EFFECTS.STRIKEOUT) else 0) | (if (o.UNDERLINE == 1) @intFromEnum(CFE_EFFECTS.UNDERLINE) else 0) | (if (o.PROTECTED == 1) @intFromEnum(CFE_EFFECTS.PROTECTED) else 0) | (if (o.LINK == 1) @intFromEnum(CFE_EFFECTS.LINK) else 0) | (if (o.SUBSCRIPT == 1) @intFromEnum(CFE_EFFECTS.SUBSCRIPT) else 0) | (if (o.SUPERSCRIPT == 1) @intFromEnum(CFE_EFFECTS.SUPERSCRIPT) else 0) | (if (o.FONTBOUND == 1) @intFromEnum(CFE_EFFECTS.FONTBOUND) else 0) | (if (o.LINKPROTECTED == 1) @intFromEnum(CFE_EFFECTS.LINKPROTECTED) else 0) | (if (o.EXTENDED == 1) @intFromEnum(CFE_EFFECTS.EXTENDED) else 0) | (if (o.MATHNOBUILDUP == 1) @intFromEnum(CFE_EFFECTS.MATHNOBUILDUP) else 0) | (if (o.MATH == 1) @intFromEnum(CFE_EFFECTS.MATH) else 0) | (if (o.MATHORDINARY == 1) @intFromEnum(CFE_EFFECTS.MATHORDINARY) else 0)));
    }
};
// TODO: enum 'CFE_EFFECTS' has known issues with its value aliases

pub const PARAFORMAT_MASK = enum(u32) {
    ALIGNMENT = 8,
    NUMBERING = 32,
    OFFSET = 4,
    OFFSETINDENT = 2147483648,
    RIGHTINDENT = 2,
    RTLPARA = 65536,
    STARTINDENT = 1,
    TABSTOPS = 16,
    _,
    pub fn initFlags(o: struct {
        ALIGNMENT: u1 = 0,
        NUMBERING: u1 = 0,
        OFFSET: u1 = 0,
        OFFSETINDENT: u1 = 0,
        RIGHTINDENT: u1 = 0,
        RTLPARA: u1 = 0,
        STARTINDENT: u1 = 0,
        TABSTOPS: u1 = 0,
    }) PARAFORMAT_MASK {
        return @as(PARAFORMAT_MASK, @enumFromInt((if (o.ALIGNMENT == 1) @intFromEnum(PARAFORMAT_MASK.ALIGNMENT) else 0) | (if (o.NUMBERING == 1) @intFromEnum(PARAFORMAT_MASK.NUMBERING) else 0) | (if (o.OFFSET == 1) @intFromEnum(PARAFORMAT_MASK.OFFSET) else 0) | (if (o.OFFSETINDENT == 1) @intFromEnum(PARAFORMAT_MASK.OFFSETINDENT) else 0) | (if (o.RIGHTINDENT == 1) @intFromEnum(PARAFORMAT_MASK.RIGHTINDENT) else 0) | (if (o.RTLPARA == 1) @intFromEnum(PARAFORMAT_MASK.RTLPARA) else 0) | (if (o.STARTINDENT == 1) @intFromEnum(PARAFORMAT_MASK.STARTINDENT) else 0) | (if (o.TABSTOPS == 1) @intFromEnum(PARAFORMAT_MASK.TABSTOPS) else 0)));
    }
};
pub const PFM_ALIGNMENT = PARAFORMAT_MASK.ALIGNMENT;
pub const PFM_NUMBERING = PARAFORMAT_MASK.NUMBERING;
pub const PFM_OFFSET = PARAFORMAT_MASK.OFFSET;
pub const PFM_OFFSETINDENT = PARAFORMAT_MASK.OFFSETINDENT;
pub const PFM_RIGHTINDENT = PARAFORMAT_MASK.RIGHTINDENT;
pub const PFM_RTLPARA = PARAFORMAT_MASK.RTLPARA;
pub const PFM_STARTINDENT = PARAFORMAT_MASK.STARTINDENT;
pub const PFM_TABSTOPS = PARAFORMAT_MASK.TABSTOPS;

pub const RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE = enum(u16) {
    SEL_EMPTY = 0,
    SEL_TEXT = 1,
    SEL_OBJECT = 2,
    SEL_MULTICHAR = 4,
    SEL_MULTIOBJECT = 8,
    GCM_RIGHTMOUSEDROP = 32768,
    _,
    pub fn initFlags(o: struct {
        SEL_EMPTY: u1 = 0,
        SEL_TEXT: u1 = 0,
        SEL_OBJECT: u1 = 0,
        SEL_MULTICHAR: u1 = 0,
        SEL_MULTIOBJECT: u1 = 0,
        GCM_RIGHTMOUSEDROP: u1 = 0,
    }) RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE {
        return @as(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, @enumFromInt((if (o.SEL_EMPTY == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY) else 0) | (if (o.SEL_TEXT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT) else 0) | (if (o.SEL_OBJECT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT) else 0) | (if (o.SEL_MULTICHAR == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR) else 0) | (if (o.SEL_MULTIOBJECT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT) else 0) | (if (o.GCM_RIGHTMOUSEDROP == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP) else 0)));
    }
};
pub const SEL_EMPTY = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY;
pub const SEL_TEXT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT;
pub const SEL_OBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT;
pub const SEL_MULTICHAR = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR;
pub const SEL_MULTIOBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT;
pub const GCM_RIGHTMOUSEDROP = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP;

pub const RICH_EDIT_GET_OBJECT_FLAGS = enum(u32) {
    POLEOBJ = 1,
    PSTG = 2,
    POLESITE = 4,
    NO_INTERFACES = 0,
    ALL_INTERFACES = 7,
    _,
    pub fn initFlags(o: struct {
        POLEOBJ: u1 = 0,
        PSTG: u1 = 0,
        POLESITE: u1 = 0,
        NO_INTERFACES: u1 = 0,
        ALL_INTERFACES: u1 = 0,
    }) RICH_EDIT_GET_OBJECT_FLAGS {
        return @as(RICH_EDIT_GET_OBJECT_FLAGS, @enumFromInt((if (o.POLEOBJ == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ) else 0) | (if (o.PSTG == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.PSTG) else 0) | (if (o.POLESITE == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.POLESITE) else 0) | (if (o.NO_INTERFACES == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES) else 0) | (if (o.ALL_INTERFACES == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES) else 0)));
    }
};
pub const REO_GETOBJ_POLEOBJ = RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ;
pub const REO_GETOBJ_PSTG = RICH_EDIT_GET_OBJECT_FLAGS.PSTG;
pub const REO_GETOBJ_POLESITE = RICH_EDIT_GET_OBJECT_FLAGS.POLESITE;
pub const REO_GETOBJ_NO_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES;
pub const REO_GETOBJ_ALL_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES;

pub const PARAFORMAT_BORDERS = enum(u16) {
    LEFT = 1,
    RIGHT = 2,
    TOP = 4,
    BOTTOM = 8,
    INSIDE = 16,
    OUTSIDE = 32,
    AUTOCOLOR = 64,
    _,
    pub fn initFlags(o: struct {
        LEFT: u1 = 0,
        RIGHT: u1 = 0,
        TOP: u1 = 0,
        BOTTOM: u1 = 0,
        INSIDE: u1 = 0,
        OUTSIDE: u1 = 0,
        AUTOCOLOR: u1 = 0,
    }) PARAFORMAT_BORDERS {
        return @as(PARAFORMAT_BORDERS, @enumFromInt((if (o.LEFT == 1) @intFromEnum(PARAFORMAT_BORDERS.LEFT) else 0) | (if (o.RIGHT == 1) @intFromEnum(PARAFORMAT_BORDERS.RIGHT) else 0) | (if (o.TOP == 1) @intFromEnum(PARAFORMAT_BORDERS.TOP) else 0) | (if (o.BOTTOM == 1) @intFromEnum(PARAFORMAT_BORDERS.BOTTOM) else 0) | (if (o.INSIDE == 1) @intFromEnum(PARAFORMAT_BORDERS.INSIDE) else 0) | (if (o.OUTSIDE == 1) @intFromEnum(PARAFORMAT_BORDERS.OUTSIDE) else 0) | (if (o.AUTOCOLOR == 1) @intFromEnum(PARAFORMAT_BORDERS.AUTOCOLOR) else 0)));
    }
};
pub const PARAFORMAT_BORDERS_LEFT = PARAFORMAT_BORDERS.LEFT;
pub const PARAFORMAT_BORDERS_RIGHT = PARAFORMAT_BORDERS.RIGHT;
pub const PARAFORMAT_BORDERS_TOP = PARAFORMAT_BORDERS.TOP;
pub const PARAFORMAT_BORDERS_BOTTOM = PARAFORMAT_BORDERS.BOTTOM;
pub const PARAFORMAT_BORDERS_INSIDE = PARAFORMAT_BORDERS.INSIDE;
pub const PARAFORMAT_BORDERS_OUTSIDE = PARAFORMAT_BORDERS.OUTSIDE;
pub const PARAFORMAT_BORDERS_AUTOCOLOR = PARAFORMAT_BORDERS.AUTOCOLOR;

pub const PARAFORMAT_SHADING_STYLE = enum(u16) {
    NONE = 0,
    DARK_HORIZ = 1,
    DARK_VERT = 2,
    DARK_DOWN_DIAG = 3,
    DARK_UP_DIAG = 4,
    DARK_GRID = 5,
    DARK_TRELLIS = 6,
    LIGHT_HORZ = 7,
    LIGHT_VERT = 8,
    LIGHT_DOWN_DIAG = 9,
    LIGHT_UP_DIAG = 10,
    LIGHT_GRID = 11,
    LIGHT_TRELLIS = 12,
};
pub const PARAFORMAT_SHADING_STYLE_NONE = PARAFORMAT_SHADING_STYLE.NONE;
pub const PARAFORMAT_SHADING_STYLE_DARK_HORIZ = PARAFORMAT_SHADING_STYLE.DARK_HORIZ;
pub const PARAFORMAT_SHADING_STYLE_DARK_VERT = PARAFORMAT_SHADING_STYLE.DARK_VERT;
pub const PARAFORMAT_SHADING_STYLE_DARK_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.DARK_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_UP_DIAG = PARAFORMAT_SHADING_STYLE.DARK_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_GRID = PARAFORMAT_SHADING_STYLE.DARK_GRID;
pub const PARAFORMAT_SHADING_STYLE_DARK_TRELLIS = PARAFORMAT_SHADING_STYLE.DARK_TRELLIS;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_HORZ = PARAFORMAT_SHADING_STYLE.LIGHT_HORZ;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_VERT = PARAFORMAT_SHADING_STYLE.LIGHT_VERT;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_UP_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_GRID = PARAFORMAT_SHADING_STYLE.LIGHT_GRID;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_TRELLIS = PARAFORMAT_SHADING_STYLE.LIGHT_TRELLIS;

pub const GETTEXTEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    NOHIDDENTEXT = 8,
    RAWTEXT = 4,
    SELECTION = 2,
    USECRLF = 1,
};
pub const GT_DEFAULT = GETTEXTEX_FLAGS.DEFAULT;
pub const GT_NOHIDDENTEXT = GETTEXTEX_FLAGS.NOHIDDENTEXT;
pub const GT_RAWTEXT = GETTEXTEX_FLAGS.RAWTEXT;
pub const GT_SELECTION = GETTEXTEX_FLAGS.SELECTION;
pub const GT_USECRLF = GETTEXTEX_FLAGS.USECRLF;

pub const ENDCOMPOSITIONNOTIFY_CODE = enum(u32) {
    ENDCOMPOSITION = 1,
    NEWTEXT = 2,
};
pub const ECN_ENDCOMPOSITION = ENDCOMPOSITIONNOTIFY_CODE.ENDCOMPOSITION;
pub const ECN_NEWTEXT = ENDCOMPOSITIONNOTIFY_CODE.NEWTEXT;

pub const IMECOMPTEXT_FLAGS = enum(u32) {
    R = 1,
};
pub const ICT_RESULTREADSTR = IMECOMPTEXT_FLAGS.R;

pub const GETTEXTLENGTHEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    USECRLF = 1,
    PRECISE = 2,
    CLOSE = 4,
    NUMCHARS = 8,
    NUMBYTES = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        USECRLF: u1 = 0,
        PRECISE: u1 = 0,
        CLOSE: u1 = 0,
        NUMCHARS: u1 = 0,
        NUMBYTES: u1 = 0,
    }) GETTEXTLENGTHEX_FLAGS {
        return @as(GETTEXTLENGTHEX_FLAGS, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.DEFAULT) else 0) | (if (o.USECRLF == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.USECRLF) else 0) | (if (o.PRECISE == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.PRECISE) else 0) | (if (o.CLOSE == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.CLOSE) else 0) | (if (o.NUMCHARS == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.NUMCHARS) else 0) | (if (o.NUMBYTES == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.NUMBYTES) else 0)));
    }
};
pub const GTL_DEFAULT = GETTEXTLENGTHEX_FLAGS.DEFAULT;
pub const GTL_USECRLF = GETTEXTLENGTHEX_FLAGS.USECRLF;
pub const GTL_PRECISE = GETTEXTLENGTHEX_FLAGS.PRECISE;
pub const GTL_CLOSE = GETTEXTLENGTHEX_FLAGS.CLOSE;
pub const GTL_NUMCHARS = GETTEXTLENGTHEX_FLAGS.NUMCHARS;
pub const GTL_NUMBYTES = GETTEXTLENGTHEX_FLAGS.NUMBYTES;

pub const REOBJECT_FLAGS = enum(u32) {
    ALIGNTORIGHT = 256,
    BELOWBASELINE = 2,
    BLANK = 16,
    CANROTATE = 128,
    DONTNEEDPALETTE = 32,
    DYNAMICSIZE = 8,
    GETMETAFILE = 4194304,
    HILITED = 16777216,
    INPLACEACTIVE = 33554432,
    INVERTEDSELECT = 4,
    LINK = 2147483648,
    LINKAVAILABLE = 8388608,
    OPEN = 67108864,
    OWNERDRAWSELECT = 64,
    RESIZABLE = 1,
    SELECTED = 134217728,
    STATIC = 1073741824,
    USEASBACKGROUND = 1024,
    WRAPTEXTAROUND = 512,
    _,
    pub fn initFlags(o: struct {
        ALIGNTORIGHT: u1 = 0,
        BELOWBASELINE: u1 = 0,
        BLANK: u1 = 0,
        CANROTATE: u1 = 0,
        DONTNEEDPALETTE: u1 = 0,
        DYNAMICSIZE: u1 = 0,
        GETMETAFILE: u1 = 0,
        HILITED: u1 = 0,
        INPLACEACTIVE: u1 = 0,
        INVERTEDSELECT: u1 = 0,
        LINK: u1 = 0,
        LINKAVAILABLE: u1 = 0,
        OPEN: u1 = 0,
        OWNERDRAWSELECT: u1 = 0,
        RESIZABLE: u1 = 0,
        SELECTED: u1 = 0,
        STATIC: u1 = 0,
        USEASBACKGROUND: u1 = 0,
        WRAPTEXTAROUND: u1 = 0,
    }) REOBJECT_FLAGS {
        return @as(REOBJECT_FLAGS, @enumFromInt((if (o.ALIGNTORIGHT == 1) @intFromEnum(REOBJECT_FLAGS.ALIGNTORIGHT) else 0) | (if (o.BELOWBASELINE == 1) @intFromEnum(REOBJECT_FLAGS.BELOWBASELINE) else 0) | (if (o.BLANK == 1) @intFromEnum(REOBJECT_FLAGS.BLANK) else 0) | (if (o.CANROTATE == 1) @intFromEnum(REOBJECT_FLAGS.CANROTATE) else 0) | (if (o.DONTNEEDPALETTE == 1) @intFromEnum(REOBJECT_FLAGS.DONTNEEDPALETTE) else 0) | (if (o.DYNAMICSIZE == 1) @intFromEnum(REOBJECT_FLAGS.DYNAMICSIZE) else 0) | (if (o.GETMETAFILE == 1) @intFromEnum(REOBJECT_FLAGS.GETMETAFILE) else 0) | (if (o.HILITED == 1) @intFromEnum(REOBJECT_FLAGS.HILITED) else 0) | (if (o.INPLACEACTIVE == 1) @intFromEnum(REOBJECT_FLAGS.INPLACEACTIVE) else 0) | (if (o.INVERTEDSELECT == 1) @intFromEnum(REOBJECT_FLAGS.INVERTEDSELECT) else 0) | (if (o.LINK == 1) @intFromEnum(REOBJECT_FLAGS.LINK) else 0) | (if (o.LINKAVAILABLE == 1) @intFromEnum(REOBJECT_FLAGS.LINKAVAILABLE) else 0) | (if (o.OPEN == 1) @intFromEnum(REOBJECT_FLAGS.OPEN) else 0) | (if (o.OWNERDRAWSELECT == 1) @intFromEnum(REOBJECT_FLAGS.OWNERDRAWSELECT) else 0) | (if (o.RESIZABLE == 1) @intFromEnum(REOBJECT_FLAGS.RESIZABLE) else 0) | (if (o.SELECTED == 1) @intFromEnum(REOBJECT_FLAGS.SELECTED) else 0) | (if (o.STATIC == 1) @intFromEnum(REOBJECT_FLAGS.STATIC) else 0) | (if (o.USEASBACKGROUND == 1) @intFromEnum(REOBJECT_FLAGS.USEASBACKGROUND) else 0) | (if (o.WRAPTEXTAROUND == 1) @intFromEnum(REOBJECT_FLAGS.WRAPTEXTAROUND) else 0)));
    }
};
pub const REO_ALIGNTORIGHT = REOBJECT_FLAGS.ALIGNTORIGHT;
pub const REO_BELOWBASELINE = REOBJECT_FLAGS.BELOWBASELINE;
pub const REO_BLANK = REOBJECT_FLAGS.BLANK;
pub const REO_CANROTATE = REOBJECT_FLAGS.CANROTATE;
pub const REO_DONTNEEDPALETTE = REOBJECT_FLAGS.DONTNEEDPALETTE;
pub const REO_DYNAMICSIZE = REOBJECT_FLAGS.DYNAMICSIZE;
pub const REO_GETMETAFILE = REOBJECT_FLAGS.GETMETAFILE;
pub const REO_HILITED = REOBJECT_FLAGS.HILITED;
pub const REO_INPLACEACTIVE = REOBJECT_FLAGS.INPLACEACTIVE;
pub const REO_INVERTEDSELECT = REOBJECT_FLAGS.INVERTEDSELECT;
pub const REO_LINK = REOBJECT_FLAGS.LINK;
pub const REO_LINKAVAILABLE = REOBJECT_FLAGS.LINKAVAILABLE;
pub const REO_OPEN = REOBJECT_FLAGS.OPEN;
pub const REO_OWNERDRAWSELECT = REOBJECT_FLAGS.OWNERDRAWSELECT;
pub const REO_RESIZABLE = REOBJECT_FLAGS.RESIZABLE;
pub const REO_SELECTED = REOBJECT_FLAGS.SELECTED;
pub const REO_STATIC = REOBJECT_FLAGS.STATIC;
pub const REO_USEASBACKGROUND = REOBJECT_FLAGS.USEASBACKGROUND;
pub const REO_WRAPTEXTAROUND = REOBJECT_FLAGS.WRAPTEXTAROUND;

pub const PARAFORMAT_NUMBERING_STYLE = enum(u16) {
    PAREN = 0,
    PARENS = 256,
    PERIOD = 512,
    PLAIN = 768,
    NONUMBER = 1024,
    NEWNUMBER = 32768,
};
pub const PFNS_PAREN = PARAFORMAT_NUMBERING_STYLE.PAREN;
pub const PFNS_PARENS = PARAFORMAT_NUMBERING_STYLE.PARENS;
pub const PFNS_PERIOD = PARAFORMAT_NUMBERING_STYLE.PERIOD;
pub const PFNS_PLAIN = PARAFORMAT_NUMBERING_STYLE.PLAIN;
pub const PFNS_NONUMBER = PARAFORMAT_NUMBERING_STYLE.NONUMBER;
pub const PFNS_NEWNUMBER = PARAFORMAT_NUMBERING_STYLE.NEWNUMBER;

pub const PARAFORMAT_ALIGNMENT = enum(u16) {
    CENTER = 3,
    LEFT = 1,
    RIGHT = 2,
};
pub const PFA_CENTER = PARAFORMAT_ALIGNMENT.CENTER;
pub const PFA_LEFT = PARAFORMAT_ALIGNMENT.LEFT;
pub const PFA_RIGHT = PARAFORMAT_ALIGNMENT.RIGHT;

pub const TEXTMODE = enum(i32) {
    PLAINTEXT = 1,
    RICHTEXT = 2,
    SINGLELEVELUNDO = 4,
    MULTILEVELUNDO = 8,
    SINGLECODEPAGE = 16,
    MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: IMECOMPTEXT_FLAGS,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = *const fn (
    langid: u16,
    psz_before: ?[*:0]const u16,
    psz_after: ?PWSTR,
    cch_after: i32,
    pcch_replaced: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32 align(4),
    yHeight: i32 align(4),
    Ascent: i32 align(4),
    Type: TEXT_ALIGN_OPTIONS align(4),
    pwszAlternateText: ?[*:0]const u16 align(4),
    pIStream: ?*IStream align(4),
};

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR align(4),
    dwCode: ENDCOMPOSITIONNOTIFY_CODE align(4),
};

pub const EDITWORDBREAKPROCEX = *const fn (
    pch_text: ?PSTR,
    cch_text: i32,
    b_char_set: u8,
    action: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]CHAR,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?PSTR align(4),
};

pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?PWSTR align(4),
};

pub const EDITSTREAMCALLBACK = *const fn (
    dw_cookie: usize,
    pb_buff: ?*u8,
    cb: i32,
    pcb: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const EDITSTREAM = extern struct {
    dwCookie: usize align(4),
    dwError: u32 align(4),
    pfnCallback: ?EDITSTREAMCALLBACK align(4),
};

pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u8 align(4),
};

pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u16 align(4),
};

pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u8 align(4),
    chrgText: CHARRANGE align(4),
};

pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u16 align(4),
    chrgText: CHARRANGE align(4),
};

pub const FORMATRANGE = extern struct {
    hdc: ?HDC align(4),
    hdcTarget: ?HDC align(4),
    rc: RECT align(4),
    rcPage: RECT align(4),
    chrg: CHARRANGE align(4),
};

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: PARAFORMAT_MASK,
    wNumbering: u16,
    Anonymous: extern union {
        wReserved: u16,
        wEffects: u16,
    },
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: PARAFORMAT_ALIGNMENT,
    cTabCount: i16,
    rgxTabs: [32]u32,
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: PARAFORMAT_SHADING_STYLE,
    wNumberingStart: u16,
    wNumberingStyle: PARAFORMAT_NUMBERING_STYLE,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: PARAFORMAT_BORDERS,
};

pub const MSGFILTER = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
};

pub const REQRESIZE = extern struct {
    nmhdr: NMHDR align(4),
    rc: RECT align(4),
};

pub const SELCHANGE = extern struct {
    nmhdr: NMHDR align(4),
    chrg: CHARRANGE align(4),
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE align(4),
};

pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR align(4),
    fGroupTyping: BOOL align(4),
};

pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR align(4),
    cf: u16 align(4),
};

pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE align(4),
    dwFlags: u32 align(4),
    pt: POINT align(4),
    pvReserved: ?*anyopaque align(4),
};

pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR align(4),
    hDrop: ?HANDLE align(4),
    cp: i32 align(4),
    fProtected: BOOL align(4),
};

pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
    chrg: CHARRANGE align(4),
};

pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR align(4),
    cObjectCount: i32 align(4),
    cch: i32 align(4),
};

pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR align(4),
    iob: i32 align(4),
    lOper: i32 align(4),
    hr: HRESULT align(4),
};

pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR align(4),
    cObjectCount: i32 align(4),
    pcpPositions: ?*i32 align(4),
};

pub const ENLINK = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
    chrg: CHARRANGE align(4),
};

pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR align(4),
    szControl: ?PSTR align(4),
};

pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR align(4),
    chrg: CHARRANGE align(4),
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE align(4),
};

pub const PUNCTUATION = extern struct {
    iSize: u32 align(4),
    szPunctuation: ?PSTR align(4),
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const REPASTESPECIAL = extern struct {
    dwAspect: DVASPECT align(4),
    dwParam: usize align(4),
};

pub const UNDONAMEID = enum(i32) {
    UNKNOWN = 0,
    TYPING = 1,
    DELETE = 2,
    DRAGDROP = 3,
    CUT = 4,
    PASTE = 5,
    AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UNKNOWN;
pub const UID_TYPING = UNDONAMEID.TYPING;
pub const UID_DELETE = UNDONAMEID.DELETE;
pub const UID_DRAGDROP = UNDONAMEID.DRAGDROP;
pub const UID_CUT = UNDONAMEID.CUT;
pub const UID_PASTE = UNDONAMEID.PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTEX = extern struct {
    cb: u32 align(4),
    flags: GETTEXTEX_FLAGS align(4),
    codepage: u32 align(4),
    lpDefaultChar: ?[*:0]const u8 align(4),
    lpUsedDefChar: ?*i32 align(4),
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: GETTEXTLENGTHEX_FLAGS,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = enum(i32) {
    Nil = 0,
    Normal = 1,
    AddBefore = 2,
    ChangeBefore = 3,
    DeleteBefore = 4,
    ChangeAfter = 5,
    DelAndChange = 6,
};
pub const khyphNil = KHYPH.Nil;
pub const khyphNormal = KHYPH.Normal;
pub const khyphAddBefore = KHYPH.AddBefore;
pub const khyphChangeBefore = KHYPH.ChangeBefore;
pub const khyphDeleteBefore = KHYPH.DeleteBefore;
pub const khyphChangeAfter = KHYPH.ChangeAfter;
pub const khyphDelAndChange = KHYPH.DelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const HYPHENATEINFO = extern struct {
    cbSize: i16 align(4),
    dxHyphenateZone: i16 align(4),
    pfnHyphenate: isize align(4),
};

pub const TXTBACKSTYLE = enum(i32) {
    TRANSPARENT = 0,
    OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.OPAQUE;

pub const TXTHITRESULT = enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = enum(i32) {
    FITTOCONTENT2 = 0,
    FITTOCONTENT = 1,
    ROUNDTOLINE = 2,
    FITTOCONTENT3 = 3,
    FITTOCONTENTWSP = 4,
    INCLUDELASTLINE = 1073741824,
    EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.EMU;

pub const TXTVIEW = enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = enum(i32) {
    GENERIC = 0,
    TEXTCHANGED = 1,
    NEWUNDO = 2,
    NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: CHANGETYPE,
    pvCookieData: ?*anyopaque,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: *const fn (
            self: *const ITextServices,
            msg: u32,
            wparam: WPARAM,
            lparam: LPARAM,
            plresult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDraw: *const fn (
            self: *const ITextServices,
            dw_draw_aspect: DVASPECT,
            lindex: i32,
            pv_aspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdc_draw: ?HDC,
            hic_target_dev: ?HDC,
            lprc_bounds: ?*RECTL,
            lprc_w_bounds: ?*RECTL,
            lprc_update: ?*RECT,
            pfn_continue: isize,
            dw_continue: u32,
            l_view_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHScroll: *const fn (
            self: *const ITextServices,
            pl_min: ?*i32,
            pl_max: ?*i32,
            pl_pos: ?*i32,
            pl_page: ?*i32,
            pf_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetVScroll: *const fn (
            self: *const ITextServices,
            pl_min: ?*i32,
            pl_max: ?*i32,
            pl_pos: ?*i32,
            pl_page: ?*i32,
            pf_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxSetCursor: *const fn (
            self: *const ITextServices,
            dw_draw_aspect: DVASPECT,
            lindex: i32,
            pv_aspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdc_draw: ?HDC,
            hic_target_dev: ?HDC,
            lprc_client: ?*RECT,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxQueryHitPoint: *const fn (
            self: *const ITextServices,
            dw_draw_aspect: DVASPECT,
            lindex: i32,
            pv_aspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdc_draw: ?HDC,
            hic_target_dev: ?HDC,
            lprc_client: ?*RECT,
            x: i32,
            y: i32,
            p_hit_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceActivate: *const fn (
            self: *const ITextServices,
            prc_client: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceDeactivate: *const fn (
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIActivate: *const fn (
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIDeactivate: *const fn (
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetText: *const fn (
            self: *const ITextServices,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetText: *const fn (
            self: *const ITextServices,
            psz_text: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCurTargetX: *const fn (
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetBaseLinePos: *const fn (
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetNaturalSize: *const fn (
            self: *const ITextServices,
            dw_aspect: u32,
            hdc_draw: ?HDC,
            hic_target_dev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dw_mode: u32,
            psizel_extent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetDropTarget: *const fn (
            self: *const ITextServices,
            pp_drop_target: ?*?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxPropertyBitsChange: *const fn (
            self: *const ITextServices,
            dw_mask: u32,
            dw_bits: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCachedSize: *const fn (
            self: *const ITextServices,
            pdw_width: ?*u32,
            pdw_height: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn txSendMessage(self: *const T, msg_: u32, wparam_: WPARAM, lparam_: LPARAM, plresult_: ?*LRESULT) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxSendMessage(@as(*const ITextServices, @ptrCast(self)), msg_, wparam_, lparam_, plresult_);
            }
            pub inline fn txDraw(self: *const T, dw_draw_aspect_: DVASPECT, lindex_: i32, pv_aspect_: ?*anyopaque, ptd_: ?*DVTARGETDEVICE, hdc_draw_: ?HDC, hic_target_dev_: ?HDC, lprc_bounds_: ?*RECTL, lprc_w_bounds_: ?*RECTL, lprc_update_: ?*RECT, pfn_continue_: isize, dw_continue_: u32, l_view_id_: i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxDraw(@as(*const ITextServices, @ptrCast(self)), dw_draw_aspect_, lindex_, pv_aspect_, ptd_, hdc_draw_, hic_target_dev_, lprc_bounds_, lprc_w_bounds_, lprc_update_, pfn_continue_, dw_continue_, l_view_id_);
            }
            pub inline fn txGetHScroll(self: *const T, pl_min_: ?*i32, pl_max_: ?*i32, pl_pos_: ?*i32, pl_page_: ?*i32, pf_enabled_: ?*BOOL) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetHScroll(@as(*const ITextServices, @ptrCast(self)), pl_min_, pl_max_, pl_pos_, pl_page_, pf_enabled_);
            }
            pub inline fn txGetVScroll(self: *const T, pl_min_: ?*i32, pl_max_: ?*i32, pl_pos_: ?*i32, pl_page_: ?*i32, pf_enabled_: ?*BOOL) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetVScroll(@as(*const ITextServices, @ptrCast(self)), pl_min_, pl_max_, pl_pos_, pl_page_, pf_enabled_);
            }
            pub inline fn onTxSetCursor(self: *const T, dw_draw_aspect_: DVASPECT, lindex_: i32, pv_aspect_: ?*anyopaque, ptd_: ?*DVTARGETDEVICE, hdc_draw_: ?HDC, hic_target_dev_: ?HDC, lprc_client_: ?*RECT, x_: i32, y_: i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxSetCursor(@as(*const ITextServices, @ptrCast(self)), dw_draw_aspect_, lindex_, pv_aspect_, ptd_, hdc_draw_, hic_target_dev_, lprc_client_, x_, y_);
            }
            pub inline fn txQueryHitPoint(self: *const T, dw_draw_aspect_: DVASPECT, lindex_: i32, pv_aspect_: ?*anyopaque, ptd_: ?*DVTARGETDEVICE, hdc_draw_: ?HDC, hic_target_dev_: ?HDC, lprc_client_: ?*RECT, x_: i32, y_: i32, p_hit_result_: ?*u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxQueryHitPoint(@as(*const ITextServices, @ptrCast(self)), dw_draw_aspect_, lindex_, pv_aspect_, ptd_, hdc_draw_, hic_target_dev_, lprc_client_, x_, y_, p_hit_result_);
            }
            pub inline fn onTxInPlaceActivate(self: *const T, prc_client_: ?*RECT) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxInPlaceActivate(@as(*const ITextServices, @ptrCast(self)), prc_client_);
            }
            pub inline fn onTxInPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxInPlaceDeactivate(@as(*const ITextServices, @ptrCast(self)));
            }
            pub inline fn onTxUIActivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxUIActivate(@as(*const ITextServices, @ptrCast(self)));
            }
            pub inline fn onTxUIDeactivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxUIDeactivate(@as(*const ITextServices, @ptrCast(self)));
            }
            pub inline fn txGetText(self: *const T, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetText(@as(*const ITextServices, @ptrCast(self)), pbstr_text_);
            }
            pub inline fn txSetText(self: *const T, psz_text_: ?[*:0]const u16) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxSetText(@as(*const ITextServices, @ptrCast(self)), psz_text_);
            }
            pub inline fn txGetCurTargetX(self: *const T, param0_: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetCurTargetX(@as(*const ITextServices, @ptrCast(self)), param0_);
            }
            pub inline fn txGetBaseLinePos(self: *const T, param0_: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetBaseLinePos(@as(*const ITextServices, @ptrCast(self)), param0_);
            }
            pub inline fn txGetNaturalSize(self: *const T, dw_aspect_: u32, hdc_draw_: ?HDC, hic_target_dev_: ?HDC, ptd_: ?*DVTARGETDEVICE, dw_mode_: u32, psizel_extent_: ?*const SIZE, pwidth_: ?*i32, pheight_: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetNaturalSize(@as(*const ITextServices, @ptrCast(self)), dw_aspect_, hdc_draw_, hic_target_dev_, ptd_, dw_mode_, psizel_extent_, pwidth_, pheight_);
            }
            pub inline fn txGetDropTarget(self: *const T, pp_drop_target_: ?*?*IDropTarget) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetDropTarget(@as(*const ITextServices, @ptrCast(self)), pp_drop_target_);
            }
            pub inline fn onTxPropertyBitsChange(self: *const T, dw_mask_: u32, dw_bits_: u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxPropertyBitsChange(@as(*const ITextServices, @ptrCast(self)), dw_mask_, dw_bits_);
            }
            pub inline fn txGetCachedSize(self: *const T, pdw_width_: ?*u32, pdw_height_: ?*u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetCachedSize(@as(*const ITextServices, @ptrCast(self)), pdw_width_, pdw_height_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = enum(i32) {
    NONE = 0,
    CUSTOM = 1,
    RTL = 2,
    ITALIC = 32,
    NULL = 64,
    ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CUSTOM;
pub const CARET_RTL = CARET_FLAGS.RTL;
pub const CARET_ITALIC = CARET_FLAGS.ITALIC;
pub const CARET_NULL = CARET_FLAGS.NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.ROTATE90;

pub const CARET_INFO = extern union {
    hbitmap: ?HBITMAP,
    caretFlags: CARET_FLAGS,
};

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: *const fn (
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HDC,
        TxReleaseDC: *const fn (
            self: *const ITextHost,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        TxShowScrollBar: *const fn (
            self: *const ITextHost,
            fn_bar: i32,
            f_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxEnableScrollBar: *const fn (
            self: *const ITextHost,
            fu_s_b_flags: SCROLLBAR_CONSTANTS,
            fu_arrowflags: ENABLE_SCROLL_BAR_ARROWS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollRange: *const fn (
            self: *const ITextHost,
            fn_bar: i32,
            n_min_pos: i32,
            n_max_pos: i32,
            f_redraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollPos: *const fn (
            self: *const ITextHost,
            fn_bar: i32,
            n_pos: i32,
            f_redraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxInvalidateRect: *const fn (
            self: *const ITextHost,
            prc: ?*RECT,
            f_mode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxViewChange: *const fn (
            self: *const ITextHost,
            f_update: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxCreateCaret: *const fn (
            self: *const ITextHost,
            hbmp: ?HBITMAP,
            x_width: i32,
            y_height: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxShowCaret: *const fn (
            self: *const ITextHost,
            f_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetCaretPos: *const fn (
            self: *const ITextHost,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetTimer: *const fn (
            self: *const ITextHost,
            id_timer: u32,
            u_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxKillTimer: *const fn (
            self: *const ITextHost,
            id_timer: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScrollWindowEx: *const fn (
            self: *const ITextHost,
            dx: i32,
            dy: i32,
            lprc_scroll: ?*RECT,
            lprc_clip: ?*RECT,
            hrgn_update: ?HRGN,
            lprc_update: ?*RECT,
            fu_scroll: SHOW_WINDOW_CMD,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCapture: *const fn (
            self: *const ITextHost,
            f_capture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetFocus: *const fn (
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCursor: *const fn (
            self: *const ITextHost,
            hcur: ?HCURSOR,
            f_text: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScreenToClient: *const fn (
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxClientToScreen: *const fn (
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxActivate: *const fn (
            self: *const ITextHost,
            pl_old_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDeactivate: *const fn (
            self: *const ITextHost,
            l_new_state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetClientRect: *const fn (
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetViewInset: *const fn (
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCharFormat: *const fn (
            self: *const ITextHost,
            pp_c_f: ?*const ?*CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetParaFormat: *const fn (
            self: *const ITextHost,
            pp_p_f: ?*const ?*PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetSysColor: *const fn (
            self: *const ITextHost,
            n_index: i32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        TxGetBackStyle: *const fn (
            self: *const ITextHost,
            pstyle: ?*TXTBACKSTYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetMaxLength: *const fn (
            self: *const ITextHost,
            plength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetScrollBars: *const fn (
            self: *const ITextHost,
            pdw_scroll_bar: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPasswordChar: *const fn (
            self: *const ITextHost,
            pch: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetAcceleratorPos: *const fn (
            self: *const ITextHost,
            pcp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetExtent: *const fn (
            self: *const ITextHost,
            lp_extent: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxCharFormatChange: *const fn (
            self: *const ITextHost,
            p_c_f: ?*const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxParaFormatChange: *const fn (
            self: *const ITextHost,
            p_p_f: ?*const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPropertyBits: *const fn (
            self: *const ITextHost,
            dw_mask: u32,
            pdw_bits: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxNotify: *const fn (
            self: *const ITextHost,
            i_notify: u32,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxImmGetContext: *const fn (
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HIMC,
        TxImmReleaseContext: *const fn (
            self: *const ITextHost,
            himc: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetSelectionBarWidth: *const fn (
            self: *const ITextHost,
            l_sel_bar_width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn txGetDC(self: *const T) ?HDC {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetDC(@as(*const ITextHost, @ptrCast(self)));
            }
            pub inline fn txReleaseDC(self: *const T, hdc_: ?HDC) i32 {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxReleaseDC(@as(*const ITextHost, @ptrCast(self)), hdc_);
            }
            pub inline fn txShowScrollBar(self: *const T, fn_bar_: i32, f_show_: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxShowScrollBar(@as(*const ITextHost, @ptrCast(self)), fn_bar_, f_show_);
            }
            pub inline fn txEnableScrollBar(self: *const T, fu_s_b_flags_: SCROLLBAR_CONSTANTS, fu_arrowflags_: ENABLE_SCROLL_BAR_ARROWS) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxEnableScrollBar(@as(*const ITextHost, @ptrCast(self)), fu_s_b_flags_, fu_arrowflags_);
            }
            pub inline fn txSetScrollRange(self: *const T, fn_bar_: i32, n_min_pos_: i32, n_max_pos_: i32, f_redraw_: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetScrollRange(@as(*const ITextHost, @ptrCast(self)), fn_bar_, n_min_pos_, n_max_pos_, f_redraw_);
            }
            pub inline fn txSetScrollPos(self: *const T, fn_bar_: i32, n_pos_: i32, f_redraw_: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetScrollPos(@as(*const ITextHost, @ptrCast(self)), fn_bar_, n_pos_, f_redraw_);
            }
            pub inline fn txInvalidateRect(self: *const T, prc_: ?*RECT, f_mode_: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxInvalidateRect(@as(*const ITextHost, @ptrCast(self)), prc_, f_mode_);
            }
            pub inline fn txViewChange(self: *const T, f_update_: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxViewChange(@as(*const ITextHost, @ptrCast(self)), f_update_);
            }
            pub inline fn txCreateCaret(self: *const T, hbmp_: ?HBITMAP, x_width_: i32, y_height_: i32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxCreateCaret(@as(*const ITextHost, @ptrCast(self)), hbmp_, x_width_, y_height_);
            }
            pub inline fn txShowCaret(self: *const T, f_show_: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxShowCaret(@as(*const ITextHost, @ptrCast(self)), f_show_);
            }
            pub inline fn txSetCaretPos(self: *const T, x_: i32, y_: i32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCaretPos(@as(*const ITextHost, @ptrCast(self)), x_, y_);
            }
            pub inline fn txSetTimer(self: *const T, id_timer_: u32, u_timeout_: u32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetTimer(@as(*const ITextHost, @ptrCast(self)), id_timer_, u_timeout_);
            }
            pub inline fn txKillTimer(self: *const T, id_timer_: u32) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxKillTimer(@as(*const ITextHost, @ptrCast(self)), id_timer_);
            }
            pub inline fn txScrollWindowEx(self: *const T, dx_: i32, dy_: i32, lprc_scroll_: ?*RECT, lprc_clip_: ?*RECT, hrgn_update_: ?HRGN, lprc_update_: ?*RECT, fu_scroll_: SHOW_WINDOW_CMD) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxScrollWindowEx(@as(*const ITextHost, @ptrCast(self)), dx_, dy_, lprc_scroll_, lprc_clip_, hrgn_update_, lprc_update_, fu_scroll_);
            }
            pub inline fn txSetCapture(self: *const T, f_capture_: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCapture(@as(*const ITextHost, @ptrCast(self)), f_capture_);
            }
            pub inline fn txSetFocus(self: *const T) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetFocus(@as(*const ITextHost, @ptrCast(self)));
            }
            pub inline fn txSetCursor(self: *const T, hcur_: ?HCURSOR, f_text_: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCursor(@as(*const ITextHost, @ptrCast(self)), hcur_, f_text_);
            }
            pub inline fn txScreenToClient(self: *const T, lppt_: ?*POINT) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxScreenToClient(@as(*const ITextHost, @ptrCast(self)), lppt_);
            }
            pub inline fn txClientToScreen(self: *const T, lppt_: ?*POINT) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxClientToScreen(@as(*const ITextHost, @ptrCast(self)), lppt_);
            }
            pub inline fn txActivate(self: *const T, pl_old_state_: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxActivate(@as(*const ITextHost, @ptrCast(self)), pl_old_state_);
            }
            pub inline fn txDeactivate(self: *const T, l_new_state_: i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxDeactivate(@as(*const ITextHost, @ptrCast(self)), l_new_state_);
            }
            pub inline fn txGetClientRect(self: *const T, prc_: ?*RECT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetClientRect(@as(*const ITextHost, @ptrCast(self)), prc_);
            }
            pub inline fn txGetViewInset(self: *const T, prc_: ?*RECT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetViewInset(@as(*const ITextHost, @ptrCast(self)), prc_);
            }
            pub inline fn txGetCharFormat(self: *const T, pp_c_f_: ?*const ?*CHARFORMATW) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetCharFormat(@as(*const ITextHost, @ptrCast(self)), pp_c_f_);
            }
            pub inline fn txGetParaFormat(self: *const T, pp_p_f_: ?*const ?*PARAFORMAT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetParaFormat(@as(*const ITextHost, @ptrCast(self)), pp_p_f_);
            }
            pub inline fn txGetSysColor(self: *const T, n_index_: i32) u32 {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetSysColor(@as(*const ITextHost, @ptrCast(self)), n_index_);
            }
            pub inline fn txGetBackStyle(self: *const T, pstyle_: ?*TXTBACKSTYLE) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetBackStyle(@as(*const ITextHost, @ptrCast(self)), pstyle_);
            }
            pub inline fn txGetMaxLength(self: *const T, plength_: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetMaxLength(@as(*const ITextHost, @ptrCast(self)), plength_);
            }
            pub inline fn txGetScrollBars(self: *const T, pdw_scroll_bar_: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetScrollBars(@as(*const ITextHost, @ptrCast(self)), pdw_scroll_bar_);
            }
            pub inline fn txGetPasswordChar(self: *const T, pch_: ?*i8) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetPasswordChar(@as(*const ITextHost, @ptrCast(self)), pch_);
            }
            pub inline fn txGetAcceleratorPos(self: *const T, pcp_: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetAcceleratorPos(@as(*const ITextHost, @ptrCast(self)), pcp_);
            }
            pub inline fn txGetExtent(self: *const T, lp_extent_: ?*SIZE) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetExtent(@as(*const ITextHost, @ptrCast(self)), lp_extent_);
            }
            pub inline fn onTxCharFormatChange(self: *const T, p_c_f_: ?*const CHARFORMATW) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).OnTxCharFormatChange(@as(*const ITextHost, @ptrCast(self)), p_c_f_);
            }
            pub inline fn onTxParaFormatChange(self: *const T, p_p_f_: ?*const PARAFORMAT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).OnTxParaFormatChange(@as(*const ITextHost, @ptrCast(self)), p_p_f_);
            }
            pub inline fn txGetPropertyBits(self: *const T, dw_mask_: u32, pdw_bits_: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetPropertyBits(@as(*const ITextHost, @ptrCast(self)), dw_mask_, pdw_bits_);
            }
            pub inline fn txNotify(self: *const T, i_notify_: u32, pv_: ?*anyopaque) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxNotify(@as(*const ITextHost, @ptrCast(self)), i_notify_, pv_);
            }
            pub inline fn txImmGetContext(self: *const T) ?HIMC {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxImmGetContext(@as(*const ITextHost, @ptrCast(self)));
            }
            pub inline fn txImmReleaseContext(self: *const T, himc_: ?HIMC) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxImmReleaseContext(@as(*const ITextHost, @ptrCast(self)), himc_);
            }
            pub inline fn txGetSelectionBarWidth(self: *const T, l_sel_bar_width_: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetSelectionBarWidth(@as(*const ITextHost, @ptrCast(self)), l_sel_bar_width_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: *const fn (
            self: *const IRicheditUiaOverrides,
            property_id: i32,
            p_ret_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPropertyOverrideValue(self: *const T, property_id_: i32, p_ret_value_: ?*VARIANT) HRESULT {
                return @as(*const IRicheditUiaOverrides.VTable, @ptrCast(self.vtable)).GetPropertyOverrideValue(@as(*const IRicheditUiaOverrides, @ptrCast(self)), property_id_, p_ret_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = *const fn (
    punk_outer: ?*IUnknown,
    p_i_text_host: ?*ITextHost,
    pp_unk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PShutdownTextServices = *const fn (
    p_text_services: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: *const fn (
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxGetWindow: *const fn (
            self: *const ITextHost2,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetForegroundWindow: *const fn (
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPalette: *const fn (
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) ?HPALETTE,
        TxGetEastAsianFlags: *const fn (
            self: *const ITextHost2,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetCursor2: *const fn (
            self: *const ITextHost2,
            hcur: ?HCURSOR,
            b_text: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?HCURSOR,
        TxFreeTextServicesNotification: *const fn (
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetEditStyle: *const fn (
            self: *const ITextHost2,
            dw_item: u32,
            pdw_data: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetWindowStyles: *const fn (
            self: *const ITextHost2,
            pdw_style: ?*u32,
            pdw_ex_style: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxShowDropCaret: *const fn (
            self: *const ITextHost2,
            f_show: BOOL,
            hdc: ?HDC,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDestroyCaret: *const fn (
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHorzExtent: *const fn (
            self: *const ITextHost2,
            pl_horz_extent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextHost.MethodMixin(T);
            pub inline fn txIsDoubleClickPending(self: *const T) BOOL {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxIsDoubleClickPending(@as(*const ITextHost2, @ptrCast(self)));
            }
            pub inline fn txGetWindow(self: *const T, phwnd_: ?*?HWND) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetWindow(@as(*const ITextHost2, @ptrCast(self)), phwnd_);
            }
            pub inline fn txSetForegroundWindow(self: *const T) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxSetForegroundWindow(@as(*const ITextHost2, @ptrCast(self)));
            }
            pub inline fn txGetPalette(self: *const T) ?HPALETTE {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetPalette(@as(*const ITextHost2, @ptrCast(self)));
            }
            pub inline fn txGetEastAsianFlags(self: *const T, p_flags_: ?*i32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetEastAsianFlags(@as(*const ITextHost2, @ptrCast(self)), p_flags_);
            }
            pub inline fn txSetCursor2(self: *const T, hcur_: ?HCURSOR, b_text_: BOOL) ?HCURSOR {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxSetCursor2(@as(*const ITextHost2, @ptrCast(self)), hcur_, b_text_);
            }
            pub inline fn txFreeTextServicesNotification(self: *const T) void {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxFreeTextServicesNotification(@as(*const ITextHost2, @ptrCast(self)));
            }
            pub inline fn txGetEditStyle(self: *const T, dw_item_: u32, pdw_data_: ?*u32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetEditStyle(@as(*const ITextHost2, @ptrCast(self)), dw_item_, pdw_data_);
            }
            pub inline fn txGetWindowStyles(self: *const T, pdw_style_: ?*u32, pdw_ex_style_: ?*u32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetWindowStyles(@as(*const ITextHost2, @ptrCast(self)), pdw_style_, pdw_ex_style_);
            }
            pub inline fn txShowDropCaret(self: *const T, f_show_: BOOL, hdc_: ?HDC, prc_: ?*RECT) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxShowDropCaret(@as(*const ITextHost2, @ptrCast(self)), f_show_, hdc_, prc_);
            }
            pub inline fn txDestroyCaret(self: *const T) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxDestroyCaret(@as(*const ITextHost2, @ptrCast(self)));
            }
            pub inline fn txGetHorzExtent(self: *const T, pl_horz_extent_: ?*i32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetHorzExtent(@as(*const ITextHost2, @ptrCast(self)), pl_horz_extent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: *const fn (
            self: *const ITextServices2,
            dw_aspect: u32,
            hdc_draw: ?HDC,
            hic_target_dev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dw_mode: u32,
            psizel_extent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
            pascent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDrawD2D: *const fn (
            self: *const ITextServices2,
            p_render_target: ?*ID2D1RenderTarget,
            lprc_bounds: ?*RECTL,
            lprc_update: ?*RECT,
            l_view_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextServices.MethodMixin(T);
            pub inline fn txGetNaturalSize2(self: *const T, dw_aspect_: u32, hdc_draw_: ?HDC, hic_target_dev_: ?HDC, ptd_: ?*DVTARGETDEVICE, dw_mode_: u32, psizel_extent_: ?*const SIZE, pwidth_: ?*i32, pheight_: ?*i32, pascent_: ?*i32) HRESULT {
                return @as(*const ITextServices2.VTable, @ptrCast(self.vtable)).TxGetNaturalSize2(@as(*const ITextServices2, @ptrCast(self)), dw_aspect_, hdc_draw_, hic_target_dev_, ptd_, dw_mode_, psizel_extent_, pwidth_, pheight_, pascent_);
            }
            pub inline fn txDrawD2D(self: *const T, p_render_target_: ?*ID2D1RenderTarget, lprc_bounds_: ?*RECTL, lprc_update_: ?*RECT, l_view_id_: i32) HRESULT {
                return @as(*const ITextServices2.VTable, @ptrCast(self.vtable)).TxDrawD2D(@as(*const ITextServices2, @ptrCast(self)), p_render_target_, lprc_bounds_, lprc_update_, l_view_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: ?*IOleObject,
    pstg: ?*IStorage,
    polesite: ?*IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: REOBJECT_FLAGS,
    dwUser: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOle_Value = Guid.initString("00020d00-0000-0000-c000-000000000046");
pub const IID_IRichEditOle = &IID_IRichEditOle_Value;
pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: *const fn (
            self: *const IRichEditOle,
            lplpolesite: ?*?*IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: *const fn (
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetLinkCount: *const fn (
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetObject: *const fn (
            self: *const IRichEditOle,
            iob: i32,
            lpreobject: ?*REOBJECT,
            dw_flags: RICH_EDIT_GET_OBJECT_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertObject: *const fn (
            self: *const IRichEditOle,
            lpreobject: ?*REOBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: *const fn (
            self: *const IRichEditOle,
            iob: i32,
            rclsid_new: ?*const Guid,
            lpstr_user_type_new: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAs: *const fn (
            self: *const IRichEditOle,
            rclsid: ?*const Guid,
            rclsid_as: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: *const fn (
            self: *const IRichEditOle,
            lpstr_container_app: ?[*:0]const u8,
            lpstr_container_obj: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkAvailable: *const fn (
            self: *const IRichEditOle,
            iob: i32,
            f_available: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDvaspect: *const fn (
            self: *const IRichEditOle,
            iob: i32,
            dvaspect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: *const fn (
            self: *const IRichEditOle,
            iob: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: *const fn (
            self: *const IRichEditOle,
            iob: i32,
            lpstg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPlaceDeactivate: *const fn (
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: *const fn (
            self: *const IRichEditOle,
            f_enter_mode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: *const fn (
            self: *const IRichEditOle,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportDataObject: *const fn (
            self: *const IRichEditOle,
            lpdataobj: ?*IDataObject,
            cf: u16,
            h_meta_pict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getClientSite(self: *const T, lplpolesite_: ?*?*IOleClientSite) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetClientSite(@as(*const IRichEditOle, @ptrCast(self)), lplpolesite_);
            }
            pub inline fn getObjectCount(self: *const T) i32 {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetObjectCount(@as(*const IRichEditOle, @ptrCast(self)));
            }
            pub inline fn getLinkCount(self: *const T) i32 {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetLinkCount(@as(*const IRichEditOle, @ptrCast(self)));
            }
            pub inline fn getObject(self: *const T, iob_: i32, lpreobject_: ?*REOBJECT, dw_flags_: RICH_EDIT_GET_OBJECT_FLAGS) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IRichEditOle, @ptrCast(self)), iob_, lpreobject_, dw_flags_);
            }
            pub inline fn insertObject(self: *const T, lpreobject_: ?*REOBJECT) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).InsertObject(@as(*const IRichEditOle, @ptrCast(self)), lpreobject_);
            }
            pub inline fn convertObject(self: *const T, iob_: i32, rclsid_new_: ?*const Guid, lpstr_user_type_new_: ?[*:0]const u8) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ConvertObject(@as(*const IRichEditOle, @ptrCast(self)), iob_, rclsid_new_, lpstr_user_type_new_);
            }
            pub inline fn activateAs(self: *const T, rclsid_: ?*const Guid, rclsid_as_: ?*const Guid) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ActivateAs(@as(*const IRichEditOle, @ptrCast(self)), rclsid_, rclsid_as_);
            }
            pub inline fn setHostNames(self: *const T, lpstr_container_app_: ?[*:0]const u8, lpstr_container_obj_: ?[*:0]const u8) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetHostNames(@as(*const IRichEditOle, @ptrCast(self)), lpstr_container_app_, lpstr_container_obj_);
            }
            pub inline fn setLinkAvailable(self: *const T, iob_: i32, f_available_: BOOL) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetLinkAvailable(@as(*const IRichEditOle, @ptrCast(self)), iob_, f_available_);
            }
            pub inline fn setDvaspect(self: *const T, iob_: i32, dvaspect_: u32) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetDvaspect(@as(*const IRichEditOle, @ptrCast(self)), iob_, dvaspect_);
            }
            pub inline fn handsOffStorage(self: *const T, iob_: i32) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).HandsOffStorage(@as(*const IRichEditOle, @ptrCast(self)), iob_);
            }
            pub inline fn saveCompleted(self: *const T, iob_: i32, lpstg_: ?*IStorage) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IRichEditOle, @ptrCast(self)), iob_, lpstg_);
            }
            pub inline fn inPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).InPlaceDeactivate(@as(*const IRichEditOle, @ptrCast(self)));
            }
            pub inline fn contextSensitiveHelp(self: *const T, f_enter_mode_: BOOL) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ContextSensitiveHelp(@as(*const IRichEditOle, @ptrCast(self)), f_enter_mode_);
            }
            pub inline fn getClipboardData(self: *const T, lpchrg_: ?*CHARRANGE, reco_: u32, lplpdataobj_: ?*?*IDataObject) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetClipboardData(@as(*const IRichEditOle, @ptrCast(self)), lpchrg_, reco_, lplpdataobj_);
            }
            pub inline fn importDataObject(self: *const T, lpdataobj_: ?*IDataObject, cf_: u16, h_meta_pict_: isize) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ImportDataObject(@as(*const IRichEditOle, @ptrCast(self)), lpdataobj_, cf_, h_meta_pict_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOleCallback_Value = Guid.initString("00020d03-0000-0000-c000-000000000046");
pub const IID_IRichEditOleCallback = &IID_IRichEditOleCallback_Value;
pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: *const fn (
            self: *const IRichEditOleCallback,
            lplpstg: ?*?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceContext: *const fn (
            self: *const IRichEditOleCallback,
            lplp_frame: ?*?*IOleInPlaceFrame,
            lplp_doc: ?*?*IOleInPlaceUIWindow,
            lp_frame_info: ?*OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContainerUI: *const fn (
            self: *const IRichEditOleCallback,
            f_show: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertObject: *const fn (
            self: *const IRichEditOleCallback,
            lpclsid: ?*Guid,
            lpstg: ?*IStorage,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteObject: *const fn (
            self: *const IRichEditOleCallback,
            lpoleobj: ?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAcceptData: *const fn (
            self: *const IRichEditOleCallback,
            lpdataobj: ?*IDataObject,
            lpcf_format: ?*u16,
            reco: u32,
            f_really: BOOL,
            h_meta_pict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: *const fn (
            self: *const IRichEditOleCallback,
            f_enter_mode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: *const fn (
            self: *const IRichEditOleCallback,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragDropEffect: *const fn (
            self: *const IRichEditOleCallback,
            f_drag: BOOL,
            grf_key_state: u32,
            pdw_effect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextMenu: *const fn (
            self: *const IRichEditOleCallback,
            seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
            lpoleobj: ?*IOleObject,
            lpchrg: ?*CHARRANGE,
            lphmenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNewStorage(self: *const T, lplpstg_: ?*?*IStorage) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetNewStorage(@as(*const IRichEditOleCallback, @ptrCast(self)), lplpstg_);
            }
            pub inline fn getInPlaceContext(self: *const T, lplp_frame_: ?*?*IOleInPlaceFrame, lplp_doc_: ?*?*IOleInPlaceUIWindow, lp_frame_info_: ?*OIFI) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetInPlaceContext(@as(*const IRichEditOleCallback, @ptrCast(self)), lplp_frame_, lplp_doc_, lp_frame_info_);
            }
            pub inline fn showContainerUI(self: *const T, f_show_: BOOL) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).ShowContainerUI(@as(*const IRichEditOleCallback, @ptrCast(self)), f_show_);
            }
            pub inline fn queryInsertObject(self: *const T, lpclsid_: ?*Guid, lpstg_: ?*IStorage, cp_: i32) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).QueryInsertObject(@as(*const IRichEditOleCallback, @ptrCast(self)), lpclsid_, lpstg_, cp_);
            }
            pub inline fn deleteObject(self: *const T, lpoleobj_: ?*IOleObject) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).DeleteObject(@as(*const IRichEditOleCallback, @ptrCast(self)), lpoleobj_);
            }
            pub inline fn queryAcceptData(self: *const T, lpdataobj_: ?*IDataObject, lpcf_format_: ?*u16, reco_: u32, f_really_: BOOL, h_meta_pict_: isize) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).QueryAcceptData(@as(*const IRichEditOleCallback, @ptrCast(self)), lpdataobj_, lpcf_format_, reco_, f_really_, h_meta_pict_);
            }
            pub inline fn contextSensitiveHelp(self: *const T, f_enter_mode_: BOOL) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).ContextSensitiveHelp(@as(*const IRichEditOleCallback, @ptrCast(self)), f_enter_mode_);
            }
            pub inline fn getClipboardData(self: *const T, lpchrg_: ?*CHARRANGE, reco_: u32, lplpdataobj_: ?*?*IDataObject) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetClipboardData(@as(*const IRichEditOleCallback, @ptrCast(self)), lpchrg_, reco_, lplpdataobj_);
            }
            pub inline fn getDragDropEffect(self: *const T, f_drag_: BOOL, grf_key_state_: u32, pdw_effect_: ?*u32) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetDragDropEffect(@as(*const IRichEditOleCallback, @ptrCast(self)), f_drag_, grf_key_state_, pdw_effect_);
            }
            pub inline fn getContextMenu(self: *const T, seltype_: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, lpoleobj_: ?*IOleObject, lpchrg_: ?*CHARRANGE, lphmenu_: ?*?HMENU) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetContextMenu(@as(*const IRichEditOleCallback, @ptrCast(self)), seltype_, lpoleobj_, lpchrg_, lphmenu_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const tomConstants = enum(i32) {
    False = 0,
    True = -1,
    Undefined = -9999999,
    Toggle = -9999998,
    AutoColor = -9999997,
    Default = -9999996,
    Suspend = -9999995,
    Resume = -9999994,
    // ApplyNow = 0, this enum value conflicts with False
    ApplyLater = 1,
    TrackParms = 2,
    CacheParms = 3,
    ApplyTmp = 4,
    DisableSmartFont = 8,
    EnableSmartFont = 9,
    UsePoints = 10,
    UseTwips = 11,
    Backward = -1073741823,
    Forward = 1073741823,
    // Move = 0, this enum value conflicts with False
    // Extend = 1, this enum value conflicts with ApplyLater
    // NoSelection = 0, this enum value conflicts with False
    // SelectionIP = 1, this enum value conflicts with ApplyLater
    // SelectionNormal = 2, this enum value conflicts with TrackParms
    // SelectionFrame = 3, this enum value conflicts with CacheParms
    // SelectionColumn = 4, this enum value conflicts with ApplyTmp
    SelectionRow = 5,
    SelectionBlock = 6,
    SelectionInlineShape = 7,
    // SelectionShape = 8, this enum value conflicts with DisableSmartFont
    // SelStartActive = 1, this enum value conflicts with ApplyLater
    // SelAtEOL = 2, this enum value conflicts with TrackParms
    // SelOvertype = 4, this enum value conflicts with ApplyTmp
    // SelActive = 8, this enum value conflicts with DisableSmartFont
    SelReplace = 16,
    // End = 0, this enum value conflicts with False
    Start = 32,
    // CollapseEnd = 0, this enum value conflicts with False
    // CollapseStart = 1, this enum value conflicts with ApplyLater
    ClientCoord = 256,
    AllowOffClient = 512,
    Transform = 1024,
    ObjectArg = 2048,
    AtEnd = 4096,
    // None = 0, this enum value conflicts with False
    // Single = 1, this enum value conflicts with ApplyLater
    // Words = 2, this enum value conflicts with TrackParms
    // Double = 3, this enum value conflicts with CacheParms
    // Dotted = 4, this enum value conflicts with ApplyTmp
    // Dash = 5, this enum value conflicts with SelectionRow
    // DashDot = 6, this enum value conflicts with SelectionBlock
    // DashDotDot = 7, this enum value conflicts with SelectionInlineShape
    // Wave = 8, this enum value conflicts with DisableSmartFont
    // Thick = 9, this enum value conflicts with EnableSmartFont
    // Hair = 10, this enum value conflicts with UsePoints
    // DoubleWave = 11, this enum value conflicts with UseTwips
    HeavyWave = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    // ThickDashDotDot = 16, this enum value conflicts with SelReplace
    ThickDotted = 17,
    ThickLongDash = 18,
    // LineSpaceSingle = 0, this enum value conflicts with False
    // LineSpace1pt5 = 1, this enum value conflicts with ApplyLater
    // LineSpaceDouble = 2, this enum value conflicts with TrackParms
    // LineSpaceAtLeast = 3, this enum value conflicts with CacheParms
    // LineSpaceExactly = 4, this enum value conflicts with ApplyTmp
    // LineSpaceMultiple = 5, this enum value conflicts with SelectionRow
    // LineSpacePercent = 6, this enum value conflicts with SelectionBlock
    // AlignLeft = 0, this enum value conflicts with False
    // AlignCenter = 1, this enum value conflicts with ApplyLater
    // AlignRight = 2, this enum value conflicts with TrackParms
    // AlignJustify = 3, this enum value conflicts with CacheParms
    // AlignDecimal = 3, this enum value conflicts with CacheParms
    // AlignBar = 4, this enum value conflicts with ApplyTmp
    // DefaultTab = 5, this enum value conflicts with SelectionRow
    // AlignInterWord = 3, this enum value conflicts with CacheParms
    // AlignNewspaper = 4, this enum value conflicts with ApplyTmp
    // AlignInterLetter = 5, this enum value conflicts with SelectionRow
    // AlignScaled = 6, this enum value conflicts with SelectionBlock
    // Spaces = 0, this enum value conflicts with False
    // Dots = 1, this enum value conflicts with ApplyLater
    // Dashes = 2, this enum value conflicts with TrackParms
    // Lines = 3, this enum value conflicts with CacheParms
    // ThickLines = 4, this enum value conflicts with ApplyTmp
    // Equals = 5, this enum value conflicts with SelectionRow
    TabBack = -3,
    TabNext = -2,
    // TabHere = -1, this enum value conflicts with True
    // ListNone = 0, this enum value conflicts with False
    // ListBullet = 1, this enum value conflicts with ApplyLater
    // ListNumberAsArabic = 2, this enum value conflicts with TrackParms
    // ListNumberAsLCLetter = 3, this enum value conflicts with CacheParms
    // ListNumberAsUCLetter = 4, this enum value conflicts with ApplyTmp
    // ListNumberAsLCRoman = 5, this enum value conflicts with SelectionRow
    // ListNumberAsUCRoman = 6, this enum value conflicts with SelectionBlock
    // ListNumberAsSequence = 7, this enum value conflicts with SelectionInlineShape
    // ListNumberedCircle = 8, this enum value conflicts with DisableSmartFont
    // ListNumberedBlackCircleWingding = 9, this enum value conflicts with EnableSmartFont
    // ListNumberedWhiteCircleWingding = 10, this enum value conflicts with UsePoints
    // ListNumberedArabicWide = 11, this enum value conflicts with UseTwips
    // ListNumberedChS = 12, this enum value conflicts with HeavyWave
    // ListNumberedChT = 13, this enum value conflicts with LongDash
    // ListNumberedJpnChS = 14, this enum value conflicts with ThickDash
    // ListNumberedJpnKor = 15, this enum value conflicts with ThickDashDot
    // ListNumberedArabic1 = 16, this enum value conflicts with SelReplace
    // ListNumberedArabic2 = 17, this enum value conflicts with ThickDotted
    // ListNumberedHebrew = 18, this enum value conflicts with ThickLongDash
    ListNumberedThaiAlpha = 19,
    ListNumberedThaiNum = 20,
    ListNumberedHindiAlpha = 21,
    ListNumberedHindiAlpha1 = 22,
    ListNumberedHindiNum = 23,
    ListParentheses = 65536,
    ListPeriod = 131072,
    ListPlain = 196608,
    ListNoNumber = 262144,
    ListMinus = 524288,
    IgnoreNumberStyle = 16777216,
    // ParaStyleNormal = -1, this enum value conflicts with True
    // ParaStyleHeading1 = -2, this enum value conflicts with TabNext
    // ParaStyleHeading2 = -3, this enum value conflicts with TabBack
    ParaStyleHeading3 = -4,
    ParaStyleHeading4 = -5,
    ParaStyleHeading5 = -6,
    ParaStyleHeading6 = -7,
    ParaStyleHeading7 = -8,
    ParaStyleHeading8 = -9,
    ParaStyleHeading9 = -10,
    // Character = 1, this enum value conflicts with ApplyLater
    // Word = 2, this enum value conflicts with TrackParms
    // Sentence = 3, this enum value conflicts with CacheParms
    // Paragraph = 4, this enum value conflicts with ApplyTmp
    // Line = 5, this enum value conflicts with SelectionRow
    // Story = 6, this enum value conflicts with SelectionBlock
    // Screen = 7, this enum value conflicts with SelectionInlineShape
    // Section = 8, this enum value conflicts with DisableSmartFont
    // TableColumn = 9, this enum value conflicts with EnableSmartFont
    // Column = 9, this enum value conflicts with EnableSmartFont
    // Row = 10, this enum value conflicts with UsePoints
    // Window = 11, this enum value conflicts with UseTwips
    // Cell = 12, this enum value conflicts with HeavyWave
    // CharFormat = 13, this enum value conflicts with LongDash
    // ParaFormat = 14, this enum value conflicts with ThickDash
    // Table = 15, this enum value conflicts with ThickDashDot
    // Object = 16, this enum value conflicts with SelReplace
    // Page = 17, this enum value conflicts with ThickDotted
    // HardParagraph = 18, this enum value conflicts with ThickLongDash
    // Cluster = 19, this enum value conflicts with ListNumberedThaiAlpha
    // InlineObject = 20, this enum value conflicts with ListNumberedThaiNum
    // InlineObjectArg = 21, this enum value conflicts with ListNumberedHindiAlpha
    // LeafLine = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // LayoutColumn = 23, this enum value conflicts with ListNumberedHindiNum
    ProcessId = 1073741825,
    // MatchWord = 2, this enum value conflicts with TrackParms
    // MatchCase = 4, this enum value conflicts with ApplyTmp
    // MatchPattern = 8, this enum value conflicts with DisableSmartFont
    // UnknownStory = 0, this enum value conflicts with False
    // MainTextStory = 1, this enum value conflicts with ApplyLater
    // FootnotesStory = 2, this enum value conflicts with TrackParms
    // EndnotesStory = 3, this enum value conflicts with CacheParms
    // CommentsStory = 4, this enum value conflicts with ApplyTmp
    // TextFrameStory = 5, this enum value conflicts with SelectionRow
    // EvenPagesHeaderStory = 6, this enum value conflicts with SelectionBlock
    // PrimaryHeaderStory = 7, this enum value conflicts with SelectionInlineShape
    // EvenPagesFooterStory = 8, this enum value conflicts with DisableSmartFont
    // PrimaryFooterStory = 9, this enum value conflicts with EnableSmartFont
    // FirstPageHeaderStory = 10, this enum value conflicts with UsePoints
    // FirstPageFooterStory = 11, this enum value conflicts with UseTwips
    ScratchStory = 127,
    FindStory = 128,
    ReplaceStory = 129,
    // StoryInactive = 0, this enum value conflicts with False
    // StoryActiveDisplay = 1, this enum value conflicts with ApplyLater
    // StoryActiveUI = 2, this enum value conflicts with TrackParms
    // StoryActiveDisplayUI = 3, this enum value conflicts with CacheParms
    // NoAnimation = 0, this enum value conflicts with False
    // LasVegasLights = 1, this enum value conflicts with ApplyLater
    // BlinkingBackground = 2, this enum value conflicts with TrackParms
    // SparkleText = 3, this enum value conflicts with CacheParms
    // MarchingBlackAnts = 4, this enum value conflicts with ApplyTmp
    // MarchingRedAnts = 5, this enum value conflicts with SelectionRow
    // Shimmer = 6, this enum value conflicts with SelectionBlock
    // WipeDown = 7, this enum value conflicts with SelectionInlineShape
    // WipeRight = 8, this enum value conflicts with DisableSmartFont
    // AnimationMax = 8, this enum value conflicts with DisableSmartFont
    // LowerCase = 0, this enum value conflicts with False
    // UpperCase = 1, this enum value conflicts with ApplyLater
    // TitleCase = 2, this enum value conflicts with TrackParms
    // SentenceCase = 4, this enum value conflicts with ApplyTmp
    // ToggleCase = 5, this enum value conflicts with SelectionRow
    // ReadOnly = 256, this enum value conflicts with ClientCoord
    // ShareDenyRead = 512, this enum value conflicts with AllowOffClient
    // ShareDenyWrite = 1024, this enum value conflicts with Transform
    // PasteFile = 4096, this enum value conflicts with AtEnd
    // CreateNew = 16, this enum value conflicts with SelReplace
    // CreateAlways = 32, this enum value conflicts with Start
    OpenExisting = 48,
    OpenAlways = 64,
    TruncateExisting = 80,
    // RTF = 1, this enum value conflicts with ApplyLater
    // Text = 2, this enum value conflicts with TrackParms
    // HTML = 3, this enum value conflicts with CacheParms
    // WordDocument = 4, this enum value conflicts with ApplyTmp
    Bold = -2147483647,
    Italic = -2147483646,
    Underline = -2147483644,
    Strikeout = -2147483640,
    Protected = -2147483632,
    Link = -2147483616,
    SmallCaps = -2147483584,
    AllCaps = -2147483520,
    Hidden = -2147483392,
    Outline = -2147483136,
    Shadow = -2147482624,
    Emboss = -2147481600,
    Imprint = -2147479552,
    Disabled = -2147475456,
    Revised = -2147467264,
    SubscriptCF = -2147418112,
    SuperscriptCF = -2147352576,
    FontBound = -2146435072,
    LinkProtected = -2139095040,
    InlineObjectStart = -2130706432,
    ExtendedChar = -2113929216,
    AutoBackColor = -2080374784,
    MathZoneNoBuildUp = -2013265920,
    MathZone = -1879048192,
    MathZoneOrdinary = -1610612736,
    AutoTextColor = -1073741824,
    // MathZoneDisplay = 262144, this enum value conflicts with ListNoNumber
    // ParaEffectRTL = 1, this enum value conflicts with ApplyLater
    // ParaEffectKeep = 2, this enum value conflicts with TrackParms
    // ParaEffectKeepNext = 4, this enum value conflicts with ApplyTmp
    // ParaEffectPageBreakBefore = 8, this enum value conflicts with DisableSmartFont
    // ParaEffectNoLineNumber = 16, this enum value conflicts with SelReplace
    // ParaEffectNoWidowControl = 32, this enum value conflicts with Start
    // ParaEffectDoNotHyphen = 64, this enum value conflicts with OpenAlways
    // ParaEffectSideBySide = 128, this enum value conflicts with FindStory
    // ParaEffectCollapsed = 256, this enum value conflicts with ClientCoord
    // ParaEffectOutlineLevel = 512, this enum value conflicts with AllowOffClient
    // ParaEffectBox = 1024, this enum value conflicts with Transform
    // ParaEffectTableRowDelimiter = 4096, this enum value conflicts with AtEnd
    ParaEffectTable = 16384,
    // ModWidthPairs = 1, this enum value conflicts with ApplyLater
    // ModWidthSpace = 2, this enum value conflicts with TrackParms
    // AutoSpaceAlpha = 4, this enum value conflicts with ApplyTmp
    // AutoSpaceNumeric = 8, this enum value conflicts with DisableSmartFont
    // AutoSpaceParens = 16, this enum value conflicts with SelReplace
    // EmbeddedFont = 32, this enum value conflicts with Start
    // Doublestrike = 64, this enum value conflicts with OpenAlways
    // Overlapping = 128, this enum value conflicts with FindStory
    // NormalCaret = 0, this enum value conflicts with False
    // KoreanBlockCaret = 1, this enum value conflicts with ApplyLater
    // NullCaret = 2, this enum value conflicts with TrackParms
    // IncludeInset = 1, this enum value conflicts with ApplyLater
    // UnicodeBiDi = 1, this enum value conflicts with ApplyLater
    // MathCFCheck = 4, this enum value conflicts with ApplyTmp
    // Unlink = 8, this enum value conflicts with DisableSmartFont
    // Unhide = 16, this enum value conflicts with SelReplace
    // CheckTextLimit = 32, this enum value conflicts with Start
    // IgnoreCurrentFont = 0, this enum value conflicts with False
    // MatchCharRep = 1, this enum value conflicts with ApplyLater
    // MatchFontSignature = 2, this enum value conflicts with TrackParms
    // MatchAscii = 4, this enum value conflicts with ApplyTmp
    // GetHeightOnly = 8, this enum value conflicts with DisableSmartFont
    // MatchMathFont = 16, this enum value conflicts with SelReplace
    Charset = -2147483648,
    CharRepFromLcid = 1073741824,
    // Ansi = 0, this enum value conflicts with False
    // EastEurope = 1, this enum value conflicts with ApplyLater
    // Cyrillic = 2, this enum value conflicts with TrackParms
    // Greek = 3, this enum value conflicts with CacheParms
    // Turkish = 4, this enum value conflicts with ApplyTmp
    // Hebrew = 5, this enum value conflicts with SelectionRow
    // Arabic = 6, this enum value conflicts with SelectionBlock
    // Baltic = 7, this enum value conflicts with SelectionInlineShape
    // Vietnamese = 8, this enum value conflicts with DisableSmartFont
    // DefaultCharRep = 9, this enum value conflicts with EnableSmartFont
    // Symbol = 10, this enum value conflicts with UsePoints
    // Thai = 11, this enum value conflicts with UseTwips
    // ShiftJIS = 12, this enum value conflicts with HeavyWave
    // GB2312 = 13, this enum value conflicts with LongDash
    // Hangul = 14, this enum value conflicts with ThickDash
    // BIG5 = 15, this enum value conflicts with ThickDashDot
    // PC437 = 16, this enum value conflicts with SelReplace
    // OEM = 17, this enum value conflicts with ThickDotted
    // Mac = 18, this enum value conflicts with ThickLongDash
    // Armenian = 19, this enum value conflicts with ListNumberedThaiAlpha
    // Syriac = 20, this enum value conflicts with ListNumberedThaiNum
    // Thaana = 21, this enum value conflicts with ListNumberedHindiAlpha
    // Devanagari = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // Bengali = 23, this enum value conflicts with ListNumberedHindiNum
    Gurmukhi = 24,
    Gujarati = 25,
    Oriya = 26,
    Tamil = 27,
    Telugu = 28,
    Kannada = 29,
    Malayalam = 30,
    Sinhala = 31,
    // Lao = 32, this enum value conflicts with Start
    Tibetan = 33,
    Myanmar = 34,
    Georgian = 35,
    Jamo = 36,
    Ethiopic = 37,
    Cherokee = 38,
    Aboriginal = 39,
    Ogham = 40,
    Runic = 41,
    Khmer = 42,
    Mongolian = 43,
    Braille = 44,
    Yi = 45,
    Limbu = 46,
    TaiLe = 47,
    // NewTaiLue = 48, this enum value conflicts with OpenExisting
    SylotiNagri = 49,
    Kharoshthi = 50,
    Kayahli = 51,
    Usymbol = 52,
    Emoji = 53,
    Glagolitic = 54,
    Lisu = 55,
    Vai = 56,
    NKo = 57,
    Osmanya = 58,
    PhagsPa = 59,
    Gothic = 60,
    Deseret = 61,
    Tifinagh = 62,
    CharRepMax = 63,
    // RE10Mode = 1, this enum value conflicts with ApplyLater
    // UseAtFont = 2, this enum value conflicts with TrackParms
    // TextFlowMask = 12, this enum value conflicts with HeavyWave
    // TextFlowES = 0, this enum value conflicts with False
    // TextFlowSW = 4, this enum value conflicts with ApplyTmp
    // TextFlowWN = 8, this enum value conflicts with DisableSmartFont
    // TextFlowNE = 12, this enum value conflicts with HeavyWave
    // NoIME = 524288, this enum value conflicts with ListMinus
    // SelfIME = 262144, this enum value conflicts with ListNoNumber
    // NoUpScroll = 65536, this enum value conflicts with ListParentheses
    // NoVpScroll = 262144, this enum value conflicts with ListNoNumber
    // NoLink = 0, this enum value conflicts with False
    // ClientLink = 1, this enum value conflicts with ApplyLater
    // FriendlyLinkName = 2, this enum value conflicts with TrackParms
    // FriendlyLinkAddress = 3, this enum value conflicts with CacheParms
    // AutoLinkURL = 4, this enum value conflicts with ApplyTmp
    // AutoLinkEmail = 5, this enum value conflicts with SelectionRow
    // AutoLinkPhone = 6, this enum value conflicts with SelectionBlock
    // AutoLinkPath = 7, this enum value conflicts with SelectionInlineShape
    // CompressNone = 0, this enum value conflicts with False
    // CompressPunctuation = 1, this enum value conflicts with ApplyLater
    // CompressPunctuationAndKana = 2, this enum value conflicts with TrackParms
    // CompressMax = 2, this enum value conflicts with TrackParms
    // UnderlinePositionAuto = 0, this enum value conflicts with False
    // UnderlinePositionBelow = 1, this enum value conflicts with ApplyLater
    // UnderlinePositionAbove = 2, this enum value conflicts with TrackParms
    // UnderlinePositionMax = 2, this enum value conflicts with TrackParms
    // FontAlignmentAuto = 0, this enum value conflicts with False
    // FontAlignmentTop = 1, this enum value conflicts with ApplyLater
    // FontAlignmentBaseline = 2, this enum value conflicts with TrackParms
    // FontAlignmentBottom = 3, this enum value conflicts with CacheParms
    // FontAlignmentCenter = 4, this enum value conflicts with ApplyTmp
    // FontAlignmentMax = 4, this enum value conflicts with ApplyTmp
    // RubyBelow = 128, this enum value conflicts with FindStory
    // RubyAlignCenter = 0, this enum value conflicts with False
    // RubyAlign010 = 1, this enum value conflicts with ApplyLater
    // RubyAlign121 = 2, this enum value conflicts with TrackParms
    // RubyAlignLeft = 3, this enum value conflicts with CacheParms
    // RubyAlignRight = 4, this enum value conflicts with ApplyTmp
    // LimitsDefault = 0, this enum value conflicts with False
    // LimitsUnderOver = 1, this enum value conflicts with ApplyLater
    // LimitsSubSup = 2, this enum value conflicts with TrackParms
    // UpperLimitAsSuperScript = 3, this enum value conflicts with CacheParms
    // LimitsOpposite = 4, this enum value conflicts with ApplyTmp
    // ShowLLimPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // ShowULimPlaceHldr = 16, this enum value conflicts with SelReplace
    // DontGrowWithContent = 64, this enum value conflicts with OpenAlways
    // GrowWithContent = 128, this enum value conflicts with FindStory
    // SubSupAlign = 1, this enum value conflicts with ApplyLater
    // LimitAlignMask = 3, this enum value conflicts with CacheParms
    // LimitAlignCenter = 0, this enum value conflicts with False
    // LimitAlignLeft = 1, this enum value conflicts with ApplyLater
    // LimitAlignRight = 2, this enum value conflicts with TrackParms
    // ShowDegPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // AlignDefault = 0, this enum value conflicts with False
    // AlignMatchAscentDescent = 2, this enum value conflicts with TrackParms
    // MathVariant = 32, this enum value conflicts with Start
    // StyleDefault = 0, this enum value conflicts with False
    // StyleScriptScriptCramped = 1, this enum value conflicts with ApplyLater
    // StyleScriptScript = 2, this enum value conflicts with TrackParms
    // StyleScriptCramped = 3, this enum value conflicts with CacheParms
    // StyleScript = 4, this enum value conflicts with ApplyTmp
    // StyleTextCramped = 5, this enum value conflicts with SelectionRow
    // StyleText = 6, this enum value conflicts with SelectionBlock
    // StyleDisplayCramped = 7, this enum value conflicts with SelectionInlineShape
    // StyleDisplay = 8, this enum value conflicts with DisableSmartFont
    // MathRelSize = 64, this enum value conflicts with OpenAlways
    DecDecSize = 254,
    DecSize = 255,
    IncSize = 65,
    IncIncSize = 66,
    // GravityUI = 0, this enum value conflicts with False
    // GravityBack = 1, this enum value conflicts with ApplyLater
    // GravityFore = 2, this enum value conflicts with TrackParms
    // GravityIn = 3, this enum value conflicts with CacheParms
    // GravityOut = 4, this enum value conflicts with ApplyTmp
    GravityBackward = 536870912,
    // GravityForward = 1073741824, this enum value conflicts with CharRepFromLcid
    // AdjustCRLF = 1, this enum value conflicts with ApplyLater
    // UseCRLF = 2, this enum value conflicts with TrackParms
    // Textize = 4, this enum value conflicts with ApplyTmp
    // AllowFinalEOP = 8, this enum value conflicts with DisableSmartFont
    // FoldMathAlpha = 16, this enum value conflicts with SelReplace
    // NoHidden = 32, this enum value conflicts with Start
    // IncludeNumbering = 64, this enum value conflicts with OpenAlways
    // TranslateTableCell = 128, this enum value conflicts with FindStory
    // NoMathZoneBrackets = 256, this enum value conflicts with ClientCoord
    // ConvertMathChar = 512, this enum value conflicts with AllowOffClient
    // NoUCGreekItalic = 1024, this enum value conflicts with Transform
    // AllowMathBold = 2048, this enum value conflicts with ObjectArg
    // LanguageTag = 4096, this enum value conflicts with AtEnd
    ConvertRTF = 8192,
    // ApplyRtfDocProps = 16384, this enum value conflicts with ParaEffectTable
    // PhantomShow = 1, this enum value conflicts with ApplyLater
    // PhantomZeroWidth = 2, this enum value conflicts with TrackParms
    // PhantomZeroAscent = 4, this enum value conflicts with ApplyTmp
    // PhantomZeroDescent = 8, this enum value conflicts with DisableSmartFont
    // PhantomTransparent = 16, this enum value conflicts with SelReplace
    // PhantomASmash = 5, this enum value conflicts with SelectionRow
    // PhantomDSmash = 9, this enum value conflicts with EnableSmartFont
    // PhantomHSmash = 3, this enum value conflicts with CacheParms
    // PhantomSmash = 13, this enum value conflicts with LongDash
    // PhantomHorz = 12, this enum value conflicts with HeavyWave
    // PhantomVert = 2, this enum value conflicts with TrackParms
    // BoxHideTop = 1, this enum value conflicts with ApplyLater
    // BoxHideBottom = 2, this enum value conflicts with TrackParms
    // BoxHideLeft = 4, this enum value conflicts with ApplyTmp
    // BoxHideRight = 8, this enum value conflicts with DisableSmartFont
    // BoxStrikeH = 16, this enum value conflicts with SelReplace
    // BoxStrikeV = 32, this enum value conflicts with Start
    // BoxStrikeTLBR = 64, this enum value conflicts with OpenAlways
    // BoxStrikeBLTR = 128, this enum value conflicts with FindStory
    // BoxAlignCenter = 1, this enum value conflicts with ApplyLater
    // SpaceMask = 28, this enum value conflicts with Telugu
    // SpaceDefault = 0, this enum value conflicts with False
    // SpaceUnary = 4, this enum value conflicts with ApplyTmp
    // SpaceBinary = 8, this enum value conflicts with DisableSmartFont
    // SpaceRelational = 12, this enum value conflicts with HeavyWave
    // SpaceSkip = 16, this enum value conflicts with SelReplace
    // SpaceOrd = 20, this enum value conflicts with ListNumberedThaiNum
    // SpaceDifferential = 24, this enum value conflicts with Gurmukhi
    // SizeText = 32, this enum value conflicts with Start
    // SizeScript = 64, this enum value conflicts with OpenAlways
    SizeScriptScript = 96,
    // NoBreak = 128, this enum value conflicts with FindStory
    // TransparentForPositioning = 256, this enum value conflicts with ClientCoord
    // TransparentForSpacing = 512, this enum value conflicts with AllowOffClient
    // StretchCharBelow = 0, this enum value conflicts with False
    // StretchCharAbove = 1, this enum value conflicts with ApplyLater
    // StretchBaseBelow = 2, this enum value conflicts with TrackParms
    // StretchBaseAbove = 3, this enum value conflicts with CacheParms
    // MatrixAlignMask = 3, this enum value conflicts with CacheParms
    // MatrixAlignCenter = 0, this enum value conflicts with False
    // MatrixAlignTopRow = 1, this enum value conflicts with ApplyLater
    // MatrixAlignBottomRow = 3, this enum value conflicts with CacheParms
    // ShowMatPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // EqArrayLayoutWidth = 1, this enum value conflicts with ApplyLater
    // EqArrayAlignMask = 12, this enum value conflicts with HeavyWave
    // EqArrayAlignCenter = 0, this enum value conflicts with False
    // EqArrayAlignTopRow = 4, this enum value conflicts with ApplyTmp
    // EqArrayAlignBottomRow = 12, this enum value conflicts with HeavyWave
    // MathManualBreakMask = 127, this enum value conflicts with ScratchStory
    MathBreakLeft = 125,
    MathBreakCenter = 126,
    // MathBreakRight = 127, this enum value conflicts with ScratchStory
    // MathEqAlign = 128, this enum value conflicts with FindStory
    MathArgShadingStart = 593,
    MathArgShadingEnd = 594,
    MathObjShadingStart = 595,
    MathObjShadingEnd = 596,
    // FunctionTypeNone = 0, this enum value conflicts with False
    // FunctionTypeTakesArg = 1, this enum value conflicts with ApplyLater
    // FunctionTypeTakesLim = 2, this enum value conflicts with TrackParms
    // FunctionTypeTakesLim2 = 3, this enum value conflicts with CacheParms
    // FunctionTypeIsLim = 4, this enum value conflicts with ApplyTmp
    // MathParaAlignDefault = 0, this enum value conflicts with False
    // MathParaAlignCenterGroup = 1, this enum value conflicts with ApplyLater
    // MathParaAlignCenter = 2, this enum value conflicts with TrackParms
    // MathParaAlignLeft = 3, this enum value conflicts with CacheParms
    // MathParaAlignRight = 4, this enum value conflicts with ApplyTmp
    // MathDispAlignMask = 3, this enum value conflicts with CacheParms
    // MathDispAlignCenterGroup = 0, this enum value conflicts with False
    // MathDispAlignCenter = 1, this enum value conflicts with ApplyLater
    // MathDispAlignLeft = 2, this enum value conflicts with TrackParms
    // MathDispAlignRight = 3, this enum value conflicts with CacheParms
    // MathDispIntUnderOver = 4, this enum value conflicts with ApplyTmp
    // MathDispFracTeX = 8, this enum value conflicts with DisableSmartFont
    // MathDispNaryGrow = 16, this enum value conflicts with SelReplace
    // MathDocEmptyArgMask = 96, this enum value conflicts with SizeScriptScript
    // MathDocEmptyArgAuto = 0, this enum value conflicts with False
    // MathDocEmptyArgAlways = 32, this enum value conflicts with Start
    // MathDocEmptyArgNever = 64, this enum value conflicts with OpenAlways
    // MathDocSbSpOpUnchanged = 128, this enum value conflicts with FindStory
    MathDocDiffMask = 768,
    // MathDocDiffDefault = 0, this enum value conflicts with False
    // MathDocDiffUpright = 256, this enum value conflicts with ClientCoord
    // MathDocDiffItalic = 512, this enum value conflicts with AllowOffClient
    // MathDocDiffOpenItalic = 768, this enum value conflicts with MathDocDiffMask
    // MathDispNarySubSup = 1024, this enum value conflicts with Transform
    // MathDispDef = 2048, this enum value conflicts with ObjectArg
    // MathEnableRtl = 4096, this enum value conflicts with AtEnd
    // MathBrkBinMask = 196608, this enum value conflicts with ListPlain
    // MathBrkBinBefore = 0, this enum value conflicts with False
    // MathBrkBinAfter = 65536, this enum value conflicts with ListParentheses
    // MathBrkBinDup = 131072, this enum value conflicts with ListPeriod
    MathBrkBinSubMask = 786432,
    // MathBrkBinSubMM = 0, this enum value conflicts with False
    // MathBrkBinSubPM = 262144, this enum value conflicts with ListNoNumber
    // MathBrkBinSubMP = 524288, this enum value conflicts with ListMinus
    SelRange = 597,
    // Hstring = 596, this enum value conflicts with MathObjShadingEnd
    FontPropTeXStyle = 828,
    FontPropAlign = 829,
    FontStretch = 830,
    FontStyle = 831,
    // FontStyleUpright = 0, this enum value conflicts with False
    // FontStyleOblique = 1, this enum value conflicts with ApplyLater
    // FontStyleItalic = 2, this enum value conflicts with TrackParms
    // FontStretchDefault = 0, this enum value conflicts with False
    // FontStretchUltraCondensed = 1, this enum value conflicts with ApplyLater
    // FontStretchExtraCondensed = 2, this enum value conflicts with TrackParms
    // FontStretchCondensed = 3, this enum value conflicts with CacheParms
    // FontStretchSemiCondensed = 4, this enum value conflicts with ApplyTmp
    // FontStretchNormal = 5, this enum value conflicts with SelectionRow
    // FontStretchSemiExpanded = 6, this enum value conflicts with SelectionBlock
    // FontStretchExpanded = 7, this enum value conflicts with SelectionInlineShape
    // FontStretchExtraExpanded = 8, this enum value conflicts with DisableSmartFont
    // FontStretchUltraExpanded = 9, this enum value conflicts with EnableSmartFont
    // FontWeightDefault = 0, this enum value conflicts with False
    FontWeightThin = 100,
    FontWeightExtraLight = 200,
    FontWeightLight = 300,
    FontWeightNormal = 400,
    // FontWeightRegular = 400, this enum value conflicts with FontWeightNormal
    FontWeightMedium = 500,
    FontWeightSemiBold = 600,
    FontWeightBold = 700,
    FontWeightExtraBold = 800,
    FontWeightBlack = 900,
    // FontWeightHeavy = 900, this enum value conflicts with FontWeightBlack
    FontWeightExtraBlack = 950,
    ParaPropMathAlign = 1079,
    // DocMathBuild = 128, this enum value conflicts with FindStory
    // MathLMargin = 129, this enum value conflicts with ReplaceStory
    MathRMargin = 130,
    MathWrapIndent = 131,
    MathWrapRight = 132,
    MathPostSpace = 134,
    MathPreSpace = 133,
    MathInterSpace = 135,
    MathIntraSpace = 136,
    CanCopy = 137,
    CanRedo = 138,
    CanUndo = 139,
    UndoLimit = 140,
    DocAutoLink = 141,
    EllipsisMode = 142,
    EllipsisState = 143,
    // EllipsisNone = 0, this enum value conflicts with False
    // EllipsisEnd = 1, this enum value conflicts with ApplyLater
    // EllipsisWord = 3, this enum value conflicts with CacheParms
    // EllipsisPresent = 1, this enum value conflicts with ApplyLater
    // VTopCell = 1, this enum value conflicts with ApplyLater
    // VLowCell = 2, this enum value conflicts with TrackParms
    // HStartCell = 4, this enum value conflicts with ApplyTmp
    // HContCell = 8, this enum value conflicts with DisableSmartFont
    // RowUpdate = 1, this enum value conflicts with ApplyLater
    // RowApplyDefault = 0, this enum value conflicts with False
    // CellStructureChangeOnly = 1, this enum value conflicts with ApplyLater
    RowHeightActual = 2059,
};
pub const tomFalse = tomConstants.False;
pub const tomTrue = tomConstants.True;
pub const tomUndefined = tomConstants.Undefined;
pub const tomToggle = tomConstants.Toggle;
pub const tomAutoColor = tomConstants.AutoColor;
pub const tomDefault = tomConstants.Default;
pub const tomSuspend = tomConstants.Suspend;
pub const tomResume = tomConstants.Resume;
pub const tomApplyNow = tomConstants.False;
pub const tomApplyLater = tomConstants.ApplyLater;
pub const tomTrackParms = tomConstants.TrackParms;
pub const tomCacheParms = tomConstants.CacheParms;
pub const tomApplyTmp = tomConstants.ApplyTmp;
pub const tomDisableSmartFont = tomConstants.DisableSmartFont;
pub const tomEnableSmartFont = tomConstants.EnableSmartFont;
pub const tomUsePoints = tomConstants.UsePoints;
pub const tomUseTwips = tomConstants.UseTwips;
pub const tomBackward = tomConstants.Backward;
pub const tomForward = tomConstants.Forward;
pub const tomMove = tomConstants.False;
pub const tomExtend = tomConstants.ApplyLater;
pub const tomNoSelection = tomConstants.False;
pub const tomSelectionIP = tomConstants.ApplyLater;
pub const tomSelectionNormal = tomConstants.TrackParms;
pub const tomSelectionFrame = tomConstants.CacheParms;
pub const tomSelectionColumn = tomConstants.ApplyTmp;
pub const tomSelectionRow = tomConstants.SelectionRow;
pub const tomSelectionBlock = tomConstants.SelectionBlock;
pub const tomSelectionInlineShape = tomConstants.SelectionInlineShape;
pub const tomSelectionShape = tomConstants.DisableSmartFont;
pub const tomSelStartActive = tomConstants.ApplyLater;
pub const tomSelAtEOL = tomConstants.TrackParms;
pub const tomSelOvertype = tomConstants.ApplyTmp;
pub const tomSelActive = tomConstants.DisableSmartFont;
pub const tomSelReplace = tomConstants.SelReplace;
pub const tomEnd = tomConstants.False;
pub const tomStart = tomConstants.Start;
pub const tomCollapseEnd = tomConstants.False;
pub const tomCollapseStart = tomConstants.ApplyLater;
pub const tomClientCoord = tomConstants.ClientCoord;
pub const tomAllowOffClient = tomConstants.AllowOffClient;
pub const tomTransform = tomConstants.Transform;
pub const tomObjectArg = tomConstants.ObjectArg;
pub const tomAtEnd = tomConstants.AtEnd;
pub const tomNone = tomConstants.False;
pub const tomSingle = tomConstants.ApplyLater;
pub const tomWords = tomConstants.TrackParms;
pub const tomDouble = tomConstants.CacheParms;
pub const tomDotted = tomConstants.ApplyTmp;
pub const tomDash = tomConstants.SelectionRow;
pub const tomDashDot = tomConstants.SelectionBlock;
pub const tomDashDotDot = tomConstants.SelectionInlineShape;
pub const tomWave = tomConstants.DisableSmartFont;
pub const tomThick = tomConstants.EnableSmartFont;
pub const tomHair = tomConstants.UsePoints;
pub const tomDoubleWave = tomConstants.UseTwips;
pub const tomHeavyWave = tomConstants.HeavyWave;
pub const tomLongDash = tomConstants.LongDash;
pub const tomThickDash = tomConstants.ThickDash;
pub const tomThickDashDot = tomConstants.ThickDashDot;
pub const tomThickDashDotDot = tomConstants.SelReplace;
pub const tomThickDotted = tomConstants.ThickDotted;
pub const tomThickLongDash = tomConstants.ThickLongDash;
pub const tomLineSpaceSingle = tomConstants.False;
pub const tomLineSpace1pt5 = tomConstants.ApplyLater;
pub const tomLineSpaceDouble = tomConstants.TrackParms;
pub const tomLineSpaceAtLeast = tomConstants.CacheParms;
pub const tomLineSpaceExactly = tomConstants.ApplyTmp;
pub const tomLineSpaceMultiple = tomConstants.SelectionRow;
pub const tomLineSpacePercent = tomConstants.SelectionBlock;
pub const tomAlignLeft = tomConstants.False;
pub const tomAlignCenter = tomConstants.ApplyLater;
pub const tomAlignRight = tomConstants.TrackParms;
pub const tomAlignJustify = tomConstants.CacheParms;
pub const tomAlignDecimal = tomConstants.CacheParms;
pub const tomAlignBar = tomConstants.ApplyTmp;
pub const tomDefaultTab = tomConstants.SelectionRow;
pub const tomAlignInterWord = tomConstants.CacheParms;
pub const tomAlignNewspaper = tomConstants.ApplyTmp;
pub const tomAlignInterLetter = tomConstants.SelectionRow;
pub const tomAlignScaled = tomConstants.SelectionBlock;
pub const tomSpaces = tomConstants.False;
pub const tomDots = tomConstants.ApplyLater;
pub const tomDashes = tomConstants.TrackParms;
pub const tomLines = tomConstants.CacheParms;
pub const tomThickLines = tomConstants.ApplyTmp;
pub const tomEquals = tomConstants.SelectionRow;
pub const tomTabBack = tomConstants.TabBack;
pub const tomTabNext = tomConstants.TabNext;
pub const tomTabHere = tomConstants.True;
pub const tomListNone = tomConstants.False;
pub const tomListBullet = tomConstants.ApplyLater;
pub const tomListNumberAsArabic = tomConstants.TrackParms;
pub const tomListNumberAsLCLetter = tomConstants.CacheParms;
pub const tomListNumberAsUCLetter = tomConstants.ApplyTmp;
pub const tomListNumberAsLCRoman = tomConstants.SelectionRow;
pub const tomListNumberAsUCRoman = tomConstants.SelectionBlock;
pub const tomListNumberAsSequence = tomConstants.SelectionInlineShape;
pub const tomListNumberedCircle = tomConstants.DisableSmartFont;
pub const tomListNumberedBlackCircleWingding = tomConstants.EnableSmartFont;
pub const tomListNumberedWhiteCircleWingding = tomConstants.UsePoints;
pub const tomListNumberedArabicWide = tomConstants.UseTwips;
pub const tomListNumberedChS = tomConstants.HeavyWave;
pub const tomListNumberedChT = tomConstants.LongDash;
pub const tomListNumberedJpnChS = tomConstants.ThickDash;
pub const tomListNumberedJpnKor = tomConstants.ThickDashDot;
pub const tomListNumberedArabic1 = tomConstants.SelReplace;
pub const tomListNumberedArabic2 = tomConstants.ThickDotted;
pub const tomListNumberedHebrew = tomConstants.ThickLongDash;
pub const tomListNumberedThaiAlpha = tomConstants.ListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.ListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.ListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.ListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.ListNumberedHindiNum;
pub const tomListParentheses = tomConstants.ListParentheses;
pub const tomListPeriod = tomConstants.ListPeriod;
pub const tomListPlain = tomConstants.ListPlain;
pub const tomListNoNumber = tomConstants.ListNoNumber;
pub const tomListMinus = tomConstants.ListMinus;
pub const tomIgnoreNumberStyle = tomConstants.IgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.True;
pub const tomParaStyleHeading1 = tomConstants.TabNext;
pub const tomParaStyleHeading2 = tomConstants.TabBack;
pub const tomParaStyleHeading3 = tomConstants.ParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.ParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.ParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.ParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.ParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.ParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.ParaStyleHeading9;
pub const tomCharacter = tomConstants.ApplyLater;
pub const tomWord = tomConstants.TrackParms;
pub const tomSentence = tomConstants.CacheParms;
pub const tomParagraph = tomConstants.ApplyTmp;
pub const tomLine = tomConstants.SelectionRow;
pub const tomStory = tomConstants.SelectionBlock;
pub const tomScreen = tomConstants.SelectionInlineShape;
pub const tomSection = tomConstants.DisableSmartFont;
pub const tomTableColumn = tomConstants.EnableSmartFont;
pub const tomColumn = tomConstants.EnableSmartFont;
pub const tomRow = tomConstants.UsePoints;
pub const tomWindow = tomConstants.UseTwips;
pub const tomCell = tomConstants.HeavyWave;
pub const tomCharFormat = tomConstants.LongDash;
pub const tomParaFormat = tomConstants.ThickDash;
pub const tomTable = tomConstants.ThickDashDot;
pub const tomObject = tomConstants.SelReplace;
pub const tomPage = tomConstants.ThickDotted;
pub const tomHardParagraph = tomConstants.ThickLongDash;
pub const tomCluster = tomConstants.ListNumberedThaiAlpha;
pub const tomInlineObject = tomConstants.ListNumberedThaiNum;
pub const tomInlineObjectArg = tomConstants.ListNumberedHindiAlpha;
pub const tomLeafLine = tomConstants.ListNumberedHindiAlpha1;
pub const tomLayoutColumn = tomConstants.ListNumberedHindiNum;
pub const tomProcessId = tomConstants.ProcessId;
pub const tomMatchWord = tomConstants.TrackParms;
pub const tomMatchCase = tomConstants.ApplyTmp;
pub const tomMatchPattern = tomConstants.DisableSmartFont;
pub const tomUnknownStory = tomConstants.False;
pub const tomMainTextStory = tomConstants.ApplyLater;
pub const tomFootnotesStory = tomConstants.TrackParms;
pub const tomEndnotesStory = tomConstants.CacheParms;
pub const tomCommentsStory = tomConstants.ApplyTmp;
pub const tomTextFrameStory = tomConstants.SelectionRow;
pub const tomEvenPagesHeaderStory = tomConstants.SelectionBlock;
pub const tomPrimaryHeaderStory = tomConstants.SelectionInlineShape;
pub const tomEvenPagesFooterStory = tomConstants.DisableSmartFont;
pub const tomPrimaryFooterStory = tomConstants.EnableSmartFont;
pub const tomFirstPageHeaderStory = tomConstants.UsePoints;
pub const tomFirstPageFooterStory = tomConstants.UseTwips;
pub const tomScratchStory = tomConstants.ScratchStory;
pub const tomFindStory = tomConstants.FindStory;
pub const tomReplaceStory = tomConstants.ReplaceStory;
pub const tomStoryInactive = tomConstants.False;
pub const tomStoryActiveDisplay = tomConstants.ApplyLater;
pub const tomStoryActiveUI = tomConstants.TrackParms;
pub const tomStoryActiveDisplayUI = tomConstants.CacheParms;
pub const tomNoAnimation = tomConstants.False;
pub const tomLasVegasLights = tomConstants.ApplyLater;
pub const tomBlinkingBackground = tomConstants.TrackParms;
pub const tomSparkleText = tomConstants.CacheParms;
pub const tomMarchingBlackAnts = tomConstants.ApplyTmp;
pub const tomMarchingRedAnts = tomConstants.SelectionRow;
pub const tomShimmer = tomConstants.SelectionBlock;
pub const tomWipeDown = tomConstants.SelectionInlineShape;
pub const tomWipeRight = tomConstants.DisableSmartFont;
pub const tomAnimationMax = tomConstants.DisableSmartFont;
pub const tomLowerCase = tomConstants.False;
pub const tomUpperCase = tomConstants.ApplyLater;
pub const tomTitleCase = tomConstants.TrackParms;
pub const tomSentenceCase = tomConstants.ApplyTmp;
pub const tomToggleCase = tomConstants.SelectionRow;
pub const tomReadOnly = tomConstants.ClientCoord;
pub const tomShareDenyRead = tomConstants.AllowOffClient;
pub const tomShareDenyWrite = tomConstants.Transform;
pub const tomPasteFile = tomConstants.AtEnd;
pub const tomCreateNew = tomConstants.SelReplace;
pub const tomCreateAlways = tomConstants.Start;
pub const tomOpenExisting = tomConstants.OpenExisting;
pub const tomOpenAlways = tomConstants.OpenAlways;
pub const tomTruncateExisting = tomConstants.TruncateExisting;
pub const tomRTF = tomConstants.ApplyLater;
pub const tomText = tomConstants.TrackParms;
pub const tomHTML = tomConstants.CacheParms;
pub const tomWordDocument = tomConstants.ApplyTmp;
pub const tomBold = tomConstants.Bold;
pub const tomItalic = tomConstants.Italic;
pub const tomUnderline = tomConstants.Underline;
pub const tomStrikeout = tomConstants.Strikeout;
pub const tomProtected = tomConstants.Protected;
pub const tomLink = tomConstants.Link;
pub const tomSmallCaps = tomConstants.SmallCaps;
pub const tomAllCaps = tomConstants.AllCaps;
pub const tomHidden = tomConstants.Hidden;
pub const tomOutline = tomConstants.Outline;
pub const tomShadow = tomConstants.Shadow;
pub const tomEmboss = tomConstants.Emboss;
pub const tomImprint = tomConstants.Imprint;
pub const tomDisabled = tomConstants.Disabled;
pub const tomRevised = tomConstants.Revised;
pub const tomSubscriptCF = tomConstants.SubscriptCF;
pub const tomSuperscriptCF = tomConstants.SuperscriptCF;
pub const tomFontBound = tomConstants.FontBound;
pub const tomLinkProtected = tomConstants.LinkProtected;
pub const tomInlineObjectStart = tomConstants.InlineObjectStart;
pub const tomExtendedChar = tomConstants.ExtendedChar;
pub const tomAutoBackColor = tomConstants.AutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.MathZoneNoBuildUp;
pub const tomMathZone = tomConstants.MathZone;
pub const tomMathZoneOrdinary = tomConstants.MathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.AutoTextColor;
pub const tomMathZoneDisplay = tomConstants.ListNoNumber;
pub const tomParaEffectRTL = tomConstants.ApplyLater;
pub const tomParaEffectKeep = tomConstants.TrackParms;
pub const tomParaEffectKeepNext = tomConstants.ApplyTmp;
pub const tomParaEffectPageBreakBefore = tomConstants.DisableSmartFont;
pub const tomParaEffectNoLineNumber = tomConstants.SelReplace;
pub const tomParaEffectNoWidowControl = tomConstants.Start;
pub const tomParaEffectDoNotHyphen = tomConstants.OpenAlways;
pub const tomParaEffectSideBySide = tomConstants.FindStory;
pub const tomParaEffectCollapsed = tomConstants.ClientCoord;
pub const tomParaEffectOutlineLevel = tomConstants.AllowOffClient;
pub const tomParaEffectBox = tomConstants.Transform;
pub const tomParaEffectTableRowDelimiter = tomConstants.AtEnd;
pub const tomParaEffectTable = tomConstants.ParaEffectTable;
pub const tomModWidthPairs = tomConstants.ApplyLater;
pub const tomModWidthSpace = tomConstants.TrackParms;
pub const tomAutoSpaceAlpha = tomConstants.ApplyTmp;
pub const tomAutoSpaceNumeric = tomConstants.DisableSmartFont;
pub const tomAutoSpaceParens = tomConstants.SelReplace;
pub const tomEmbeddedFont = tomConstants.Start;
pub const tomDoublestrike = tomConstants.OpenAlways;
pub const tomOverlapping = tomConstants.FindStory;
pub const tomNormalCaret = tomConstants.False;
pub const tomKoreanBlockCaret = tomConstants.ApplyLater;
pub const tomNullCaret = tomConstants.TrackParms;
pub const tomIncludeInset = tomConstants.ApplyLater;
pub const tomUnicodeBiDi = tomConstants.ApplyLater;
pub const tomMathCFCheck = tomConstants.ApplyTmp;
pub const tomUnlink = tomConstants.DisableSmartFont;
pub const tomUnhide = tomConstants.SelReplace;
pub const tomCheckTextLimit = tomConstants.Start;
pub const tomIgnoreCurrentFont = tomConstants.False;
pub const tomMatchCharRep = tomConstants.ApplyLater;
pub const tomMatchFontSignature = tomConstants.TrackParms;
pub const tomMatchAscii = tomConstants.ApplyTmp;
pub const tomGetHeightOnly = tomConstants.DisableSmartFont;
pub const tomMatchMathFont = tomConstants.SelReplace;
pub const tomCharset = tomConstants.Charset;
pub const tomCharRepFromLcid = tomConstants.CharRepFromLcid;
pub const tomAnsi = tomConstants.False;
pub const tomEastEurope = tomConstants.ApplyLater;
pub const tomCyrillic = tomConstants.TrackParms;
pub const tomGreek = tomConstants.CacheParms;
pub const tomTurkish = tomConstants.ApplyTmp;
pub const tomHebrew = tomConstants.SelectionRow;
pub const tomArabic = tomConstants.SelectionBlock;
pub const tomBaltic = tomConstants.SelectionInlineShape;
pub const tomVietnamese = tomConstants.DisableSmartFont;
pub const tomDefaultCharRep = tomConstants.EnableSmartFont;
pub const tomSymbol = tomConstants.UsePoints;
pub const tomThai = tomConstants.UseTwips;
pub const tomShiftJIS = tomConstants.HeavyWave;
pub const tomGB2312 = tomConstants.LongDash;
pub const tomHangul = tomConstants.ThickDash;
pub const tomBIG5 = tomConstants.ThickDashDot;
pub const tomPC437 = tomConstants.SelReplace;
pub const tomOEM = tomConstants.ThickDotted;
pub const tomMac = tomConstants.ThickLongDash;
pub const tomArmenian = tomConstants.ListNumberedThaiAlpha;
pub const tomSyriac = tomConstants.ListNumberedThaiNum;
pub const tomThaana = tomConstants.ListNumberedHindiAlpha;
pub const tomDevanagari = tomConstants.ListNumberedHindiAlpha1;
pub const tomBengali = tomConstants.ListNumberedHindiNum;
pub const tomGurmukhi = tomConstants.Gurmukhi;
pub const tomGujarati = tomConstants.Gujarati;
pub const tomOriya = tomConstants.Oriya;
pub const tomTamil = tomConstants.Tamil;
pub const tomTelugu = tomConstants.Telugu;
pub const tomKannada = tomConstants.Kannada;
pub const tomMalayalam = tomConstants.Malayalam;
pub const tomSinhala = tomConstants.Sinhala;
pub const tomLao = tomConstants.Start;
pub const tomTibetan = tomConstants.Tibetan;
pub const tomMyanmar = tomConstants.Myanmar;
pub const tomGeorgian = tomConstants.Georgian;
pub const tomJamo = tomConstants.Jamo;
pub const tomEthiopic = tomConstants.Ethiopic;
pub const tomCherokee = tomConstants.Cherokee;
pub const tomAboriginal = tomConstants.Aboriginal;
pub const tomOgham = tomConstants.Ogham;
pub const tomRunic = tomConstants.Runic;
pub const tomKhmer = tomConstants.Khmer;
pub const tomMongolian = tomConstants.Mongolian;
pub const tomBraille = tomConstants.Braille;
pub const tomYi = tomConstants.Yi;
pub const tomLimbu = tomConstants.Limbu;
pub const tomTaiLe = tomConstants.TaiLe;
pub const tomNewTaiLue = tomConstants.OpenExisting;
pub const tomSylotiNagri = tomConstants.SylotiNagri;
pub const tomKharoshthi = tomConstants.Kharoshthi;
pub const tomKayahli = tomConstants.Kayahli;
pub const tomUsymbol = tomConstants.Usymbol;
pub const tomEmoji = tomConstants.Emoji;
pub const tomGlagolitic = tomConstants.Glagolitic;
pub const tomLisu = tomConstants.Lisu;
pub const tomVai = tomConstants.Vai;
pub const tomNKo = tomConstants.NKo;
pub const tomOsmanya = tomConstants.Osmanya;
pub const tomPhagsPa = tomConstants.PhagsPa;
pub const tomGothic = tomConstants.Gothic;
pub const tomDeseret = tomConstants.Deseret;
pub const tomTifinagh = tomConstants.Tifinagh;
pub const tomCharRepMax = tomConstants.CharRepMax;
pub const tomRE10Mode = tomConstants.ApplyLater;
pub const tomUseAtFont = tomConstants.TrackParms;
pub const tomTextFlowMask = tomConstants.HeavyWave;
pub const tomTextFlowES = tomConstants.False;
pub const tomTextFlowSW = tomConstants.ApplyTmp;
pub const tomTextFlowWN = tomConstants.DisableSmartFont;
pub const tomTextFlowNE = tomConstants.HeavyWave;
pub const tomNoIME = tomConstants.ListMinus;
pub const tomSelfIME = tomConstants.ListNoNumber;
pub const tomNoUpScroll = tomConstants.ListParentheses;
pub const tomNoVpScroll = tomConstants.ListNoNumber;
pub const tomNoLink = tomConstants.False;
pub const tomClientLink = tomConstants.ApplyLater;
pub const tomFriendlyLinkName = tomConstants.TrackParms;
pub const tomFriendlyLinkAddress = tomConstants.CacheParms;
pub const tomAutoLinkURL = tomConstants.ApplyTmp;
pub const tomAutoLinkEmail = tomConstants.SelectionRow;
pub const tomAutoLinkPhone = tomConstants.SelectionBlock;
pub const tomAutoLinkPath = tomConstants.SelectionInlineShape;
pub const tomCompressNone = tomConstants.False;
pub const tomCompressPunctuation = tomConstants.ApplyLater;
pub const tomCompressPunctuationAndKana = tomConstants.TrackParms;
pub const tomCompressMax = tomConstants.TrackParms;
pub const tomUnderlinePositionAuto = tomConstants.False;
pub const tomUnderlinePositionBelow = tomConstants.ApplyLater;
pub const tomUnderlinePositionAbove = tomConstants.TrackParms;
pub const tomUnderlinePositionMax = tomConstants.TrackParms;
pub const tomFontAlignmentAuto = tomConstants.False;
pub const tomFontAlignmentTop = tomConstants.ApplyLater;
pub const tomFontAlignmentBaseline = tomConstants.TrackParms;
pub const tomFontAlignmentBottom = tomConstants.CacheParms;
pub const tomFontAlignmentCenter = tomConstants.ApplyTmp;
pub const tomFontAlignmentMax = tomConstants.ApplyTmp;
pub const tomRubyBelow = tomConstants.FindStory;
pub const tomRubyAlignCenter = tomConstants.False;
pub const tomRubyAlign010 = tomConstants.ApplyLater;
pub const tomRubyAlign121 = tomConstants.TrackParms;
pub const tomRubyAlignLeft = tomConstants.CacheParms;
pub const tomRubyAlignRight = tomConstants.ApplyTmp;
pub const tomLimitsDefault = tomConstants.False;
pub const tomLimitsUnderOver = tomConstants.ApplyLater;
pub const tomLimitsSubSup = tomConstants.TrackParms;
pub const tomUpperLimitAsSuperScript = tomConstants.CacheParms;
pub const tomLimitsOpposite = tomConstants.ApplyTmp;
pub const tomShowLLimPlaceHldr = tomConstants.DisableSmartFont;
pub const tomShowULimPlaceHldr = tomConstants.SelReplace;
pub const tomDontGrowWithContent = tomConstants.OpenAlways;
pub const tomGrowWithContent = tomConstants.FindStory;
pub const tomSubSupAlign = tomConstants.ApplyLater;
pub const tomLimitAlignMask = tomConstants.CacheParms;
pub const tomLimitAlignCenter = tomConstants.False;
pub const tomLimitAlignLeft = tomConstants.ApplyLater;
pub const tomLimitAlignRight = tomConstants.TrackParms;
pub const tomShowDegPlaceHldr = tomConstants.DisableSmartFont;
pub const tomAlignDefault = tomConstants.False;
pub const tomAlignMatchAscentDescent = tomConstants.TrackParms;
pub const tomMathVariant = tomConstants.Start;
pub const tomStyleDefault = tomConstants.False;
pub const tomStyleScriptScriptCramped = tomConstants.ApplyLater;
pub const tomStyleScriptScript = tomConstants.TrackParms;
pub const tomStyleScriptCramped = tomConstants.CacheParms;
pub const tomStyleScript = tomConstants.ApplyTmp;
pub const tomStyleTextCramped = tomConstants.SelectionRow;
pub const tomStyleText = tomConstants.SelectionBlock;
pub const tomStyleDisplayCramped = tomConstants.SelectionInlineShape;
pub const tomStyleDisplay = tomConstants.DisableSmartFont;
pub const tomMathRelSize = tomConstants.OpenAlways;
pub const tomDecDecSize = tomConstants.DecDecSize;
pub const tomDecSize = tomConstants.DecSize;
pub const tomIncSize = tomConstants.IncSize;
pub const tomIncIncSize = tomConstants.IncIncSize;
pub const tomGravityUI = tomConstants.False;
pub const tomGravityBack = tomConstants.ApplyLater;
pub const tomGravityFore = tomConstants.TrackParms;
pub const tomGravityIn = tomConstants.CacheParms;
pub const tomGravityOut = tomConstants.ApplyTmp;
pub const tomGravityBackward = tomConstants.GravityBackward;
pub const tomGravityForward = tomConstants.CharRepFromLcid;
pub const tomAdjustCRLF = tomConstants.ApplyLater;
pub const tomUseCRLF = tomConstants.TrackParms;
pub const tomTextize = tomConstants.ApplyTmp;
pub const tomAllowFinalEOP = tomConstants.DisableSmartFont;
pub const tomFoldMathAlpha = tomConstants.SelReplace;
pub const tomNoHidden = tomConstants.Start;
pub const tomIncludeNumbering = tomConstants.OpenAlways;
pub const tomTranslateTableCell = tomConstants.FindStory;
pub const tomNoMathZoneBrackets = tomConstants.ClientCoord;
pub const tomConvertMathChar = tomConstants.AllowOffClient;
pub const tomNoUCGreekItalic = tomConstants.Transform;
pub const tomAllowMathBold = tomConstants.ObjectArg;
pub const tomLanguageTag = tomConstants.AtEnd;
pub const tomConvertRTF = tomConstants.ConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.ParaEffectTable;
pub const tomPhantomShow = tomConstants.ApplyLater;
pub const tomPhantomZeroWidth = tomConstants.TrackParms;
pub const tomPhantomZeroAscent = tomConstants.ApplyTmp;
pub const tomPhantomZeroDescent = tomConstants.DisableSmartFont;
pub const tomPhantomTransparent = tomConstants.SelReplace;
pub const tomPhantomASmash = tomConstants.SelectionRow;
pub const tomPhantomDSmash = tomConstants.EnableSmartFont;
pub const tomPhantomHSmash = tomConstants.CacheParms;
pub const tomPhantomSmash = tomConstants.LongDash;
pub const tomPhantomHorz = tomConstants.HeavyWave;
pub const tomPhantomVert = tomConstants.TrackParms;
pub const tomBoxHideTop = tomConstants.ApplyLater;
pub const tomBoxHideBottom = tomConstants.TrackParms;
pub const tomBoxHideLeft = tomConstants.ApplyTmp;
pub const tomBoxHideRight = tomConstants.DisableSmartFont;
pub const tomBoxStrikeH = tomConstants.SelReplace;
pub const tomBoxStrikeV = tomConstants.Start;
pub const tomBoxStrikeTLBR = tomConstants.OpenAlways;
pub const tomBoxStrikeBLTR = tomConstants.FindStory;
pub const tomBoxAlignCenter = tomConstants.ApplyLater;
pub const tomSpaceMask = tomConstants.Telugu;
pub const tomSpaceDefault = tomConstants.False;
pub const tomSpaceUnary = tomConstants.ApplyTmp;
pub const tomSpaceBinary = tomConstants.DisableSmartFont;
pub const tomSpaceRelational = tomConstants.HeavyWave;
pub const tomSpaceSkip = tomConstants.SelReplace;
pub const tomSpaceOrd = tomConstants.ListNumberedThaiNum;
pub const tomSpaceDifferential = tomConstants.Gurmukhi;
pub const tomSizeText = tomConstants.Start;
pub const tomSizeScript = tomConstants.OpenAlways;
pub const tomSizeScriptScript = tomConstants.SizeScriptScript;
pub const tomNoBreak = tomConstants.FindStory;
pub const tomTransparentForPositioning = tomConstants.ClientCoord;
pub const tomTransparentForSpacing = tomConstants.AllowOffClient;
pub const tomStretchCharBelow = tomConstants.False;
pub const tomStretchCharAbove = tomConstants.ApplyLater;
pub const tomStretchBaseBelow = tomConstants.TrackParms;
pub const tomStretchBaseAbove = tomConstants.CacheParms;
pub const tomMatrixAlignMask = tomConstants.CacheParms;
pub const tomMatrixAlignCenter = tomConstants.False;
pub const tomMatrixAlignTopRow = tomConstants.ApplyLater;
pub const tomMatrixAlignBottomRow = tomConstants.CacheParms;
pub const tomShowMatPlaceHldr = tomConstants.DisableSmartFont;
pub const tomEqArrayLayoutWidth = tomConstants.ApplyLater;
pub const tomEqArrayAlignMask = tomConstants.HeavyWave;
pub const tomEqArrayAlignCenter = tomConstants.False;
pub const tomEqArrayAlignTopRow = tomConstants.ApplyTmp;
pub const tomEqArrayAlignBottomRow = tomConstants.HeavyWave;
pub const tomMathManualBreakMask = tomConstants.ScratchStory;
pub const tomMathBreakLeft = tomConstants.MathBreakLeft;
pub const tomMathBreakCenter = tomConstants.MathBreakCenter;
pub const tomMathBreakRight = tomConstants.ScratchStory;
pub const tomMathEqAlign = tomConstants.FindStory;
pub const tomMathArgShadingStart = tomConstants.MathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.MathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.MathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.MathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.False;
pub const tomFunctionTypeTakesArg = tomConstants.ApplyLater;
pub const tomFunctionTypeTakesLim = tomConstants.TrackParms;
pub const tomFunctionTypeTakesLim2 = tomConstants.CacheParms;
pub const tomFunctionTypeIsLim = tomConstants.ApplyTmp;
pub const tomMathParaAlignDefault = tomConstants.False;
pub const tomMathParaAlignCenterGroup = tomConstants.ApplyLater;
pub const tomMathParaAlignCenter = tomConstants.TrackParms;
pub const tomMathParaAlignLeft = tomConstants.CacheParms;
pub const tomMathParaAlignRight = tomConstants.ApplyTmp;
pub const tomMathDispAlignMask = tomConstants.CacheParms;
pub const tomMathDispAlignCenterGroup = tomConstants.False;
pub const tomMathDispAlignCenter = tomConstants.ApplyLater;
pub const tomMathDispAlignLeft = tomConstants.TrackParms;
pub const tomMathDispAlignRight = tomConstants.CacheParms;
pub const tomMathDispIntUnderOver = tomConstants.ApplyTmp;
pub const tomMathDispFracTeX = tomConstants.DisableSmartFont;
pub const tomMathDispNaryGrow = tomConstants.SelReplace;
pub const tomMathDocEmptyArgMask = tomConstants.SizeScriptScript;
pub const tomMathDocEmptyArgAuto = tomConstants.False;
pub const tomMathDocEmptyArgAlways = tomConstants.Start;
pub const tomMathDocEmptyArgNever = tomConstants.OpenAlways;
pub const tomMathDocSbSpOpUnchanged = tomConstants.FindStory;
pub const tomMathDocDiffMask = tomConstants.MathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.False;
pub const tomMathDocDiffUpright = tomConstants.ClientCoord;
pub const tomMathDocDiffItalic = tomConstants.AllowOffClient;
pub const tomMathDocDiffOpenItalic = tomConstants.MathDocDiffMask;
pub const tomMathDispNarySubSup = tomConstants.Transform;
pub const tomMathDispDef = tomConstants.ObjectArg;
pub const tomMathEnableRtl = tomConstants.AtEnd;
pub const tomMathBrkBinMask = tomConstants.ListPlain;
pub const tomMathBrkBinBefore = tomConstants.False;
pub const tomMathBrkBinAfter = tomConstants.ListParentheses;
pub const tomMathBrkBinDup = tomConstants.ListPeriod;
pub const tomMathBrkBinSubMask = tomConstants.MathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.False;
pub const tomMathBrkBinSubPM = tomConstants.ListNoNumber;
pub const tomMathBrkBinSubMP = tomConstants.ListMinus;
pub const tomSelRange = tomConstants.SelRange;
pub const tomHstring = tomConstants.MathObjShadingEnd;
pub const tomFontPropTeXStyle = tomConstants.FontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.FontPropAlign;
pub const tomFontStretch = tomConstants.FontStretch;
pub const tomFontStyle = tomConstants.FontStyle;
pub const tomFontStyleUpright = tomConstants.False;
pub const tomFontStyleOblique = tomConstants.ApplyLater;
pub const tomFontStyleItalic = tomConstants.TrackParms;
pub const tomFontStretchDefault = tomConstants.False;
pub const tomFontStretchUltraCondensed = tomConstants.ApplyLater;
pub const tomFontStretchExtraCondensed = tomConstants.TrackParms;
pub const tomFontStretchCondensed = tomConstants.CacheParms;
pub const tomFontStretchSemiCondensed = tomConstants.ApplyTmp;
pub const tomFontStretchNormal = tomConstants.SelectionRow;
pub const tomFontStretchSemiExpanded = tomConstants.SelectionBlock;
pub const tomFontStretchExpanded = tomConstants.SelectionInlineShape;
pub const tomFontStretchExtraExpanded = tomConstants.DisableSmartFont;
pub const tomFontStretchUltraExpanded = tomConstants.EnableSmartFont;
pub const tomFontWeightDefault = tomConstants.False;
pub const tomFontWeightThin = tomConstants.FontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.FontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.FontWeightLight;
pub const tomFontWeightNormal = tomConstants.FontWeightNormal;
pub const tomFontWeightRegular = tomConstants.FontWeightNormal;
pub const tomFontWeightMedium = tomConstants.FontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.FontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.FontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.FontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.FontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.FontWeightBlack;
pub const tomFontWeightExtraBlack = tomConstants.FontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.ParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.FindStory;
pub const tomMathLMargin = tomConstants.ReplaceStory;
pub const tomMathRMargin = tomConstants.MathRMargin;
pub const tomMathWrapIndent = tomConstants.MathWrapIndent;
pub const tomMathWrapRight = tomConstants.MathWrapRight;
pub const tomMathPostSpace = tomConstants.MathPostSpace;
pub const tomMathPreSpace = tomConstants.MathPreSpace;
pub const tomMathInterSpace = tomConstants.MathInterSpace;
pub const tomMathIntraSpace = tomConstants.MathIntraSpace;
pub const tomCanCopy = tomConstants.CanCopy;
pub const tomCanRedo = tomConstants.CanRedo;
pub const tomCanUndo = tomConstants.CanUndo;
pub const tomUndoLimit = tomConstants.UndoLimit;
pub const tomDocAutoLink = tomConstants.DocAutoLink;
pub const tomEllipsisMode = tomConstants.EllipsisMode;
pub const tomEllipsisState = tomConstants.EllipsisState;
pub const tomEllipsisNone = tomConstants.False;
pub const tomEllipsisEnd = tomConstants.ApplyLater;
pub const tomEllipsisWord = tomConstants.CacheParms;
pub const tomEllipsisPresent = tomConstants.ApplyLater;
pub const tomVTopCell = tomConstants.ApplyLater;
pub const tomVLowCell = tomConstants.TrackParms;
pub const tomHStartCell = tomConstants.ApplyTmp;
pub const tomHContCell = tomConstants.DisableSmartFont;
pub const tomRowUpdate = tomConstants.ApplyLater;
pub const tomRowApplyDefault = tomConstants.False;
pub const tomCellStructureChangeOnly = tomConstants.ApplyLater;
pub const tomRowHeightActual = tomConstants.RowHeightActual;

pub const OBJECTTYPE = enum(i32) {
    SimpleText = 0,
    Ruby = 1,
    HorzVert = 2,
    Warichu = 3,
    Eq = 9,
    Math = 10,
    // Accent = 10, this enum value conflicts with Math
    Box = 11,
    BoxedFormula = 12,
    Brackets = 13,
    BracketsWithSeps = 14,
    EquationArray = 15,
    Fraction = 16,
    FunctionApply = 17,
    LeftSubSup = 18,
    LowerLimit = 19,
    Matrix = 20,
    Nary = 21,
    OpChar = 22,
    Overbar = 23,
    Phantom = 24,
    Radical = 25,
    SlashedFraction = 26,
    Stack = 27,
    StretchStack = 28,
    Subscript = 29,
    SubSup = 30,
    Superscript = 31,
    Underbar = 32,
    UpperLimit = 33,
    // ObjectMax = 33, this enum value conflicts with UpperLimit
};
pub const tomSimpleText = OBJECTTYPE.SimpleText;
pub const tomRuby = OBJECTTYPE.Ruby;
pub const tomHorzVert = OBJECTTYPE.HorzVert;
pub const tomWarichu = OBJECTTYPE.Warichu;
pub const tomEq = OBJECTTYPE.Eq;
pub const tomMath = OBJECTTYPE.Math;
pub const tomAccent = OBJECTTYPE.Math;
pub const tomBox = OBJECTTYPE.Box;
pub const tomBoxedFormula = OBJECTTYPE.BoxedFormula;
pub const tomBrackets = OBJECTTYPE.Brackets;
pub const tomBracketsWithSeps = OBJECTTYPE.BracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.EquationArray;
pub const tomFraction = OBJECTTYPE.Fraction;
pub const tomFunctionApply = OBJECTTYPE.FunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.LeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.LowerLimit;
pub const tomMatrix = OBJECTTYPE.Matrix;
pub const tomNary = OBJECTTYPE.Nary;
pub const tomOpChar = OBJECTTYPE.OpChar;
pub const tomOverbar = OBJECTTYPE.Overbar;
pub const tomPhantom = OBJECTTYPE.Phantom;
pub const tomRadical = OBJECTTYPE.Radical;
pub const tomSlashedFraction = OBJECTTYPE.SlashedFraction;
pub const tomStack = OBJECTTYPE.Stack;
pub const tomStretchStack = OBJECTTYPE.StretchStack;
pub const tomSubscript = OBJECTTYPE.Subscript;
pub const tomSubSup = OBJECTTYPE.SubSup;
pub const tomSuperscript = OBJECTTYPE.Superscript;
pub const tomUnderbar = OBJECTTYPE.Underbar;
pub const tomUpperLimit = OBJECTTYPE.UpperLimit;
pub const tomObjectMax = OBJECTTYPE.UpperLimit;

pub const MANCODE = enum(i32) {
    BOLD = 16,
    ITAL = 32,
    GREEK = 64,
    ROMN = 0,
    SCRP = 1,
    FRAK = 2,
    OPEN = 3,
    SANS = 4,
    MONO = 5,
    MATH = 6,
    ISOL = 7,
    INIT = 8,
    TAIL = 9,
    STRCH = 10,
    LOOP = 11,
    OPENA = 12,
};
pub const MBOLD = MANCODE.BOLD;
pub const MITAL = MANCODE.ITAL;
pub const MGREEK = MANCODE.GREEK;
pub const MROMN = MANCODE.ROMN;
pub const MSCRP = MANCODE.SCRP;
pub const MFRAK = MANCODE.FRAK;
pub const MOPEN = MANCODE.OPEN;
pub const MSANS = MANCODE.SANS;
pub const MMONO = MANCODE.MONO;
pub const MMATH = MANCODE.MATH;
pub const MISOL = MANCODE.ISOL;
pub const MINIT = MANCODE.INIT;
pub const MTAIL = MANCODE.TAIL;
pub const MSTRCH = MANCODE.STRCH;
pub const MLOOP = MANCODE.LOOP;
pub const MOPENA = MANCODE.OPENA;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextDocument_Value = Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: *const fn (
            self: *const ITextDocument,
            p_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: *const fn (
            self: *const ITextDocument,
            pp_sel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryCount: *const fn (
            self: *const ITextDocument,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges: *const fn (
            self: *const ITextDocument,
            pp_stories: ?*?*ITextStoryRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSaved: *const fn (
            self: *const ITextDocument,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSaved: *const fn (
            self: *const ITextDocument,
            value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTabStop: *const fn (
            self: *const ITextDocument,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTabStop: *const fn (
            self: *const ITextDocument,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        New: *const fn (
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: *const fn (
            self: *const ITextDocument,
            p_var: ?*VARIANT,
            flags: i32,
            code_page: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const ITextDocument,
            p_var: ?*VARIANT,
            flags: i32,
            code_page: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: *const fn (
            self: *const ITextDocument,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: *const fn (
            self: *const ITextDocument,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEditCollection: *const fn (
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEditCollection: *const fn (
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: *const fn (
            self: *const ITextDocument,
            count: i32,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redo: *const fn (
            self: *const ITextDocument,
            count: i32,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range: *const fn (
            self: *const ITextDocument,
            cp_active: i32,
            cp_anchor: i32,
            pp_range: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: *const fn (
            self: *const ITextDocument,
            x: i32,
            y: i32,
            pp_range: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, p_name_: ?*?BSTR) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetName(@as(*const ITextDocument, @ptrCast(self)), p_name_);
            }
            pub inline fn getSelection(self: *const T, pp_sel_: ?*?*ITextSelection) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextDocument, @ptrCast(self)), pp_sel_);
            }
            pub inline fn getStoryCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetStoryCount(@as(*const ITextDocument, @ptrCast(self)), p_count_);
            }
            pub inline fn getStoryRanges(self: *const T, pp_stories_: ?*?*ITextStoryRanges) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetStoryRanges(@as(*const ITextDocument, @ptrCast(self)), pp_stories_);
            }
            pub inline fn getSaved(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetSaved(@as(*const ITextDocument, @ptrCast(self)), p_value_);
            }
            pub inline fn setSaved(self: *const T, value_: tomConstants) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).SetSaved(@as(*const ITextDocument, @ptrCast(self)), value_);
            }
            pub inline fn getDefaultTabStop(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetDefaultTabStop(@as(*const ITextDocument, @ptrCast(self)), p_value_);
            }
            pub inline fn setDefaultTabStop(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).SetDefaultTabStop(@as(*const ITextDocument, @ptrCast(self)), value_);
            }
            pub inline fn new(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).New(@as(*const ITextDocument, @ptrCast(self)));
            }
            pub inline fn open(self: *const T, p_var_: ?*VARIANT, flags_: i32, code_page_: i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Open(@as(*const ITextDocument, @ptrCast(self)), p_var_, flags_, code_page_);
            }
            pub inline fn save(self: *const T, p_var_: ?*VARIANT, flags_: i32, code_page_: i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Save(@as(*const ITextDocument, @ptrCast(self)), p_var_, flags_, code_page_);
            }
            pub inline fn freeze(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Freeze(@as(*const ITextDocument, @ptrCast(self)), p_count_);
            }
            pub inline fn unfreeze(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Unfreeze(@as(*const ITextDocument, @ptrCast(self)), p_count_);
            }
            pub inline fn beginEditCollection(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).BeginEditCollection(@as(*const ITextDocument, @ptrCast(self)));
            }
            pub inline fn endEditCollection(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).EndEditCollection(@as(*const ITextDocument, @ptrCast(self)));
            }
            pub inline fn undo(self: *const T, count_: i32, p_count_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Undo(@as(*const ITextDocument, @ptrCast(self)), count_, p_count_);
            }
            pub inline fn redo(self: *const T, count_: i32, p_count_: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Redo(@as(*const ITextDocument, @ptrCast(self)), count_, p_count_);
            }
            pub inline fn range(self: *const T, cp_active_: i32, cp_anchor_: i32, pp_range_: ?*?*ITextRange) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Range(@as(*const ITextDocument, @ptrCast(self)), cp_active_, cp_anchor_, pp_range_);
            }
            pub inline fn rangeFromPoint(self: *const T, x_: i32, y_: i32, pp_range_: ?*?*ITextRange) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).RangeFromPoint(@as(*const ITextDocument, @ptrCast(self)), x_, y_, pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextRange_Value = Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: *const fn (
            self: *const ITextRange,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITextRange,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar: *const fn (
            self: *const ITextRange,
            p_char: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChar: *const fn (
            self: *const ITextRange,
            char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate: *const fn (
            self: *const ITextRange,
            pp_range: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: *const fn (
            self: *const ITextRange,
            pp_range: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: *const fn (
            self: *const ITextRange,
            p_range: ?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: *const fn (
            self: *const ITextRange,
            pcp_first: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStart: *const fn (
            self: *const ITextRange,
            cp_first: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: *const fn (
            self: *const ITextRange,
            pcp_lim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnd: *const fn (
            self: *const ITextRange,
            cp_lim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: *const fn (
            self: *const ITextRange,
            pp_font: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: *const fn (
            self: *const ITextRange,
            p_font: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara: *const fn (
            self: *const ITextRange,
            pp_para: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara: *const fn (
            self: *const ITextRange,
            p_para: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryLength: *const fn (
            self: *const ITextRange,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryType: *const fn (
            self: *const ITextRange,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: *const fn (
            self: *const ITextRange,
            b_start: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: *const fn (
            self: *const ITextRange,
            unit: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: *const fn (
            self: *const ITextRange,
            unit: i32,
            p_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: *const fn (
            self: *const ITextRange,
            unit: i32,
            index: i32,
            extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: *const fn (
            self: *const ITextRange,
            cp_anchor: i32,
            cp_active: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InRange: *const fn (
            self: *const ITextRange,
            p_range: ?*ITextRange,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InStory: *const fn (
            self: *const ITextRange,
            p_range: ?*ITextRange,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const ITextRange,
            p_range: ?*ITextRange,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: *const fn (
            self: *const ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOf: *const fn (
            self: *const ITextRange,
            unit: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOf: *const fn (
            self: *const ITextRange,
            unit: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: *const fn (
            self: *const ITextRange,
            unit: i32,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStart: *const fn (
            self: *const ITextRange,
            unit: i32,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEnd: *const fn (
            self: *const ITextRange,
            unit: i32,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWhile: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartWhile: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndWhile: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUntil: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartUntil: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndUntil: *const fn (
            self: *const ITextRange,
            cset: ?*VARIANT,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindText: *const fn (
            self: *const ITextRange,
            bstr: ?BSTR,
            count: i32,
            flags: i32,
            p_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextStart: *const fn (
            self: *const ITextRange,
            bstr: ?BSTR,
            count: i32,
            flags: i32,
            p_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextEnd: *const fn (
            self: *const ITextRange,
            bstr: ?BSTR,
            count: i32,
            flags: i32,
            p_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const ITextRange,
            unit: i32,
            count: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cut: *const fn (
            self: *const ITextRange,
            p_var: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: *const fn (
            self: *const ITextRange,
            p_var: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: *const fn (
            self: *const ITextRange,
            p_var: ?*VARIANT,
            format: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPaste: *const fn (
            self: *const ITextRange,
            p_var: ?*VARIANT,
            format: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanEdit: *const fn (
            self: *const ITextRange,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCase: *const fn (
            self: *const ITextRange,
            type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPoint: *const fn (
            self: *const ITextRange,
            type: i32,
            px: ?*i32,
            py: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoint: *const fn (
            self: *const ITextRange,
            x: i32,
            y: i32,
            type: i32,
            extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: *const fn (
            self: *const ITextRange,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedObject: *const fn (
            self: *const ITextRange,
            pp_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getText(self: *const T, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextRange, @ptrCast(self)), pbstr_);
            }
            pub inline fn setText(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextRange, @ptrCast(self)), bstr_);
            }
            pub inline fn getChar(self: *const T, p_char_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetChar(@as(*const ITextRange, @ptrCast(self)), p_char_);
            }
            pub inline fn setChar(self: *const T, char_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetChar(@as(*const ITextRange, @ptrCast(self)), char_);
            }
            pub inline fn getDuplicate(self: *const T, pp_range_: ?*?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextRange, @ptrCast(self)), pp_range_);
            }
            pub inline fn getFormattedText(self: *const T, pp_range_: ?*?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextRange, @ptrCast(self)), pp_range_);
            }
            pub inline fn setFormattedText(self: *const T, p_range_: ?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextRange, @ptrCast(self)), p_range_);
            }
            pub inline fn getStart(self: *const T, pcp_first_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITextRange, @ptrCast(self)), pcp_first_);
            }
            pub inline fn setStart(self: *const T, cp_first_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetStart(@as(*const ITextRange, @ptrCast(self)), cp_first_);
            }
            pub inline fn getEnd(self: *const T, pcp_lim_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITextRange, @ptrCast(self)), pcp_lim_);
            }
            pub inline fn setEnd(self: *const T, cp_lim_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetEnd(@as(*const ITextRange, @ptrCast(self)), cp_lim_);
            }
            pub inline fn getFont(self: *const T, pp_font_: ?*?*ITextFont) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetFont(@as(*const ITextRange, @ptrCast(self)), pp_font_);
            }
            pub inline fn setFont(self: *const T, p_font_: ?*ITextFont) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetFont(@as(*const ITextRange, @ptrCast(self)), p_font_);
            }
            pub inline fn getPara(self: *const T, pp_para_: ?*?*ITextPara) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetPara(@as(*const ITextRange, @ptrCast(self)), pp_para_);
            }
            pub inline fn setPara(self: *const T, p_para_: ?*ITextPara) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetPara(@as(*const ITextRange, @ptrCast(self)), p_para_);
            }
            pub inline fn getStoryLength(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStoryLength(@as(*const ITextRange, @ptrCast(self)), p_count_);
            }
            pub inline fn getStoryType(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStoryType(@as(*const ITextRange, @ptrCast(self)), p_value_);
            }
            pub inline fn collapse(self: *const T, b_start_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Collapse(@as(*const ITextRange, @ptrCast(self)), b_start_);
            }
            pub inline fn expand(self: *const T, unit_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Expand(@as(*const ITextRange, @ptrCast(self)), unit_, p_delta_);
            }
            pub inline fn getIndex(self: *const T, unit_: i32, p_index_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITextRange, @ptrCast(self)), unit_, p_index_);
            }
            pub inline fn setIndex(self: *const T, unit_: i32, index_: i32, extend_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetIndex(@as(*const ITextRange, @ptrCast(self)), unit_, index_, extend_);
            }
            pub inline fn setRange(self: *const T, cp_anchor_: i32, cp_active_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetRange(@as(*const ITextRange, @ptrCast(self)), cp_anchor_, cp_active_);
            }
            pub inline fn inRange(self: *const T, p_range_: ?*ITextRange, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).InRange(@as(*const ITextRange, @ptrCast(self)), p_range_, p_value_);
            }
            pub inline fn inStory(self: *const T, p_range_: ?*ITextRange, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).InStory(@as(*const ITextRange, @ptrCast(self)), p_range_, p_value_);
            }
            pub inline fn isEqual(self: *const T, p_range_: ?*ITextRange, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextRange, @ptrCast(self)), p_range_, p_value_);
            }
            pub inline fn select(self: *const T) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Select(@as(*const ITextRange, @ptrCast(self)));
            }
            pub inline fn startOf(self: *const T, unit_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).StartOf(@as(*const ITextRange, @ptrCast(self)), unit_, extend_, p_delta_);
            }
            pub inline fn endOf(self: *const T, unit_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).EndOf(@as(*const ITextRange, @ptrCast(self)), unit_, extend_, p_delta_);
            }
            pub inline fn move(self: *const T, unit_: i32, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Move(@as(*const ITextRange, @ptrCast(self)), unit_, count_, p_delta_);
            }
            pub inline fn moveStart(self: *const T, unit_: i32, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStart(@as(*const ITextRange, @ptrCast(self)), unit_, count_, p_delta_);
            }
            pub inline fn moveEnd(self: *const T, unit_: i32, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEnd(@as(*const ITextRange, @ptrCast(self)), unit_, count_, p_delta_);
            }
            pub inline fn moveWhile(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveWhile(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn moveStartWhile(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStartWhile(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn moveEndWhile(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEndWhile(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn moveUntil(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveUntil(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn moveStartUntil(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStartUntil(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn moveEndUntil(self: *const T, cset_: ?*VARIANT, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEndUntil(@as(*const ITextRange, @ptrCast(self)), cset_, count_, p_delta_);
            }
            pub inline fn findText(self: *const T, bstr_: ?BSTR, count_: i32, flags_: i32, p_length_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindText(@as(*const ITextRange, @ptrCast(self)), bstr_, count_, flags_, p_length_);
            }
            pub inline fn findTextStart(self: *const T, bstr_: ?BSTR, count_: i32, flags_: i32, p_length_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindTextStart(@as(*const ITextRange, @ptrCast(self)), bstr_, count_, flags_, p_length_);
            }
            pub inline fn findTextEnd(self: *const T, bstr_: ?BSTR, count_: i32, flags_: i32, p_length_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindTextEnd(@as(*const ITextRange, @ptrCast(self)), bstr_, count_, flags_, p_length_);
            }
            pub inline fn delete(self: *const T, unit_: i32, count_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Delete(@as(*const ITextRange, @ptrCast(self)), unit_, count_, p_delta_);
            }
            pub inline fn cut(self: *const T, p_var_: ?*VARIANT) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Cut(@as(*const ITextRange, @ptrCast(self)), p_var_);
            }
            pub inline fn copy(self: *const T, p_var_: ?*VARIANT) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Copy(@as(*const ITextRange, @ptrCast(self)), p_var_);
            }
            pub inline fn paste(self: *const T, p_var_: ?*VARIANT, format_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Paste(@as(*const ITextRange, @ptrCast(self)), p_var_, format_);
            }
            pub inline fn canPaste(self: *const T, p_var_: ?*VARIANT, format_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).CanPaste(@as(*const ITextRange, @ptrCast(self)), p_var_, format_, p_value_);
            }
            pub inline fn canEdit(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).CanEdit(@as(*const ITextRange, @ptrCast(self)), p_value_);
            }
            pub inline fn changeCase(self: *const T, type_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).ChangeCase(@as(*const ITextRange, @ptrCast(self)), type_);
            }
            pub inline fn getPoint(self: *const T, type_: i32, px_: ?*i32, py_: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetPoint(@as(*const ITextRange, @ptrCast(self)), type_, px_, py_);
            }
            pub inline fn setPoint(self: *const T, x_: i32, y_: i32, type_: i32, extend_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetPoint(@as(*const ITextRange, @ptrCast(self)), x_, y_, type_, extend_);
            }
            pub inline fn scrollIntoView(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).ScrollIntoView(@as(*const ITextRange, @ptrCast(self)), value_);
            }
            pub inline fn getEmbeddedObject(self: *const T, pp_object_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetEmbeddedObject(@as(*const ITextRange, @ptrCast(self)), pp_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextSelection_Value = Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: *const fn (
            self: *const ITextSelection,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: *const fn (
            self: *const ITextSelection,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: *const fn (
            self: *const ITextSelection,
            p_type: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveLeft: *const fn (
            self: *const ITextSelection,
            unit: i32,
            count: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRight: *const fn (
            self: *const ITextSelection,
            unit: i32,
            count: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUp: *const fn (
            self: *const ITextSelection,
            unit: i32,
            count: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDown: *const fn (
            self: *const ITextSelection,
            unit: i32,
            count: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HomeKey: *const fn (
            self: *const ITextSelection,
            unit: tomConstants,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndKey: *const fn (
            self: *const ITextSelection,
            unit: i32,
            extend: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TypeText: *const fn (
            self: *const ITextSelection,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextRange.MethodMixin(T);
            pub inline fn getFlags(self: *const T, p_flags_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const ITextSelection, @ptrCast(self)), p_flags_);
            }
            pub inline fn setFlags(self: *const T, flags_: i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const ITextSelection, @ptrCast(self)), flags_);
            }
            pub inline fn getType(self: *const T, p_type_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITextSelection, @ptrCast(self)), p_type_);
            }
            pub inline fn moveLeft(self: *const T, unit_: i32, count_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveLeft(@as(*const ITextSelection, @ptrCast(self)), unit_, count_, extend_, p_delta_);
            }
            pub inline fn moveRight(self: *const T, unit_: i32, count_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveRight(@as(*const ITextSelection, @ptrCast(self)), unit_, count_, extend_, p_delta_);
            }
            pub inline fn moveUp(self: *const T, unit_: i32, count_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveUp(@as(*const ITextSelection, @ptrCast(self)), unit_, count_, extend_, p_delta_);
            }
            pub inline fn moveDown(self: *const T, unit_: i32, count_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveDown(@as(*const ITextSelection, @ptrCast(self)), unit_, count_, extend_, p_delta_);
            }
            pub inline fn homeKey(self: *const T, unit_: tomConstants, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).HomeKey(@as(*const ITextSelection, @ptrCast(self)), unit_, extend_, p_delta_);
            }
            pub inline fn endKey(self: *const T, unit_: i32, extend_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).EndKey(@as(*const ITextSelection, @ptrCast(self)), unit_, extend_, p_delta_);
            }
            pub inline fn typeText(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).TypeText(@as(*const ITextSelection, @ptrCast(self)), bstr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextFont_Value = Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: *const fn (
            self: *const ITextFont,
            pp_font: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: *const fn (
            self: *const ITextFont,
            p_font: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const ITextFont,
            p_font: ?*ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ITextFont,
            value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCaps: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllCaps: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnimation: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackColor: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackColor: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBold: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmboss: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmboss: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeColor: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetForeColor: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHidden: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHidden: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngrave: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngrave: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItalic: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItalic: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKerning: *const fn (
            self: *const ITextFont,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKerning: *const fn (
            self: *const ITextFont,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageID: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLanguageID: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn (
            self: *const ITextFont,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: *const fn (
            self: *const ITextFont,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutline: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutline: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: *const fn (
            self: *const ITextFont,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: *const fn (
            self: *const ITextFont,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtected: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProtected: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShadow: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShadow: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const ITextFont,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: *const fn (
            self: *const ITextFont,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSmallCaps: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSmallCaps: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: *const fn (
            self: *const ITextFont,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpacing: *const fn (
            self: *const ITextFont,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrikeThrough: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrikeThrough: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscript: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscript: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuperscript: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSuperscript: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderline: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderline: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWeight: *const fn (
            self: *const ITextFont,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWeight: *const fn (
            self: *const ITextFont,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getDuplicate(self: *const T, pp_font_: ?*?*ITextFont) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextFont, @ptrCast(self)), pp_font_);
            }
            pub inline fn setDuplicate(self: *const T, p_font_: ?*ITextFont) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetDuplicate(@as(*const ITextFont, @ptrCast(self)), p_font_);
            }
            pub inline fn canChange(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn isEqual(self: *const T, p_font_: ?*ITextFont, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextFont, @ptrCast(self)), p_font_, p_value_);
            }
            pub inline fn reset(self: *const T, value_: tomConstants) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getStyle(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetStyle(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setStyle(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetStyle(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getAllCaps(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetAllCaps(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setAllCaps(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetAllCaps(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getAnimation(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetAnimation(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setAnimation(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetAnimation(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getBackColor(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetBackColor(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setBackColor(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetBackColor(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getBold(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetBold(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setBold(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetBold(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getEmboss(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetEmboss(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setEmboss(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetEmboss(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getForeColor(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetForeColor(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setForeColor(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetForeColor(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getHidden(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetHidden(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setHidden(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetHidden(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getEngrave(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetEngrave(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setEngrave(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetEngrave(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getItalic(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetItalic(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setItalic(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetItalic(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getKerning(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetKerning(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setKerning(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetKerning(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getLanguageID(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetLanguageID(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setLanguageID(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetLanguageID(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getName(self: *const T, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetName(@as(*const ITextFont, @ptrCast(self)), pbstr_);
            }
            pub inline fn setName(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetName(@as(*const ITextFont, @ptrCast(self)), bstr_);
            }
            pub inline fn getOutline(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetOutline(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setOutline(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetOutline(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getPosition(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setPosition(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getProtected(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetProtected(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setProtected(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetProtected(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getShadow(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetShadow(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setShadow(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetShadow(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getSize(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setSize(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSize(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getSmallCaps(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSmallCaps(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setSmallCaps(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSmallCaps(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getSpacing(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSpacing(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setSpacing(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSpacing(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getStrikeThrough(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetStrikeThrough(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setStrikeThrough(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetStrikeThrough(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getSubscript(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSubscript(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setSubscript(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSubscript(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getSuperscript(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSuperscript(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setSuperscript(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSuperscript(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getUnderline(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetUnderline(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setUnderline(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetUnderline(@as(*const ITextFont, @ptrCast(self)), value_);
            }
            pub inline fn getWeight(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetWeight(@as(*const ITextFont, @ptrCast(self)), p_value_);
            }
            pub inline fn setWeight(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetWeight(@as(*const ITextFont, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextPara_Value = Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: *const fn (
            self: *const ITextPara,
            pp_para: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: *const fn (
            self: *const ITextPara,
            p_para: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const ITextPara,
            p_para: ?*ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlignment: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHyphenation: *const fn (
            self: *const ITextPara,
            p_value: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHyphenation: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstLineIndent: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: *const fn (
            self: *const ITextPara,
            p_value: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: *const fn (
            self: *const ITextPara,
            p_value: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeftIndent: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacing: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacingRule: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListAlignment: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListAlignment: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListLevelIndex: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListLevelIndex: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListStart: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListStart: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListTab: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListTab: *const fn (
            self: *const ITextPara,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListType: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListType: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNoLineNumber: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoLineNumber: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageBreakBefore: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageBreakBefore: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightIndent: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRightIndent: *const fn (
            self: *const ITextPara,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndents: *const fn (
            self: *const ITextPara,
            first: f32,
            left: f32,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineSpacing: *const fn (
            self: *const ITextPara,
            rule: i32,
            spacing: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceAfter: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceAfter: *const fn (
            self: *const ITextPara,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceBefore: *const fn (
            self: *const ITextPara,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceBefore: *const fn (
            self: *const ITextPara,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWidowControl: *const fn (
            self: *const ITextPara,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWidowControl: *const fn (
            self: *const ITextPara,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTabCount: *const fn (
            self: *const ITextPara,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: *const fn (
            self: *const ITextPara,
            tb_pos: f32,
            tb_align: i32,
            tb_leader: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllTabs: *const fn (
            self: *const ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: *const fn (
            self: *const ITextPara,
            tb_pos: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTab: *const fn (
            self: *const ITextPara,
            i_tab: i32,
            ptb_pos: ?*f32,
            ptb_align: ?*i32,
            ptb_leader: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getDuplicate(self: *const T, pp_para_: ?*?*ITextPara) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextPara, @ptrCast(self)), pp_para_);
            }
            pub inline fn setDuplicate(self: *const T, p_para_: ?*ITextPara) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetDuplicate(@as(*const ITextPara, @ptrCast(self)), p_para_);
            }
            pub inline fn canChange(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn isEqual(self: *const T, p_para_: ?*ITextPara, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextPara, @ptrCast(self)), p_para_, p_value_);
            }
            pub inline fn reset(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getStyle(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetStyle(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setStyle(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetStyle(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getAlignment(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetAlignment(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setAlignment(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetAlignment(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getHyphenation(self: *const T, p_value_: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetHyphenation(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setHyphenation(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetHyphenation(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getFirstLineIndent(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetFirstLineIndent(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn getKeepTogether(self: *const T, p_value_: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetKeepTogether(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setKeepTogether(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetKeepTogether(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getKeepWithNext(self: *const T, p_value_: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetKeepWithNext(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setKeepWithNext(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetKeepWithNext(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getLeftIndent(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLeftIndent(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn getLineSpacing(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLineSpacing(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn getLineSpacingRule(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLineSpacingRule(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn getListAlignment(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListAlignment(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setListAlignment(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListAlignment(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getListLevelIndex(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListLevelIndex(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setListLevelIndex(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListLevelIndex(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getListStart(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListStart(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setListStart(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListStart(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getListTab(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListTab(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setListTab(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListTab(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getListType(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListType(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setListType(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListType(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getNoLineNumber(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetNoLineNumber(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setNoLineNumber(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetNoLineNumber(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getPageBreakBefore(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetPageBreakBefore(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setPageBreakBefore(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetPageBreakBefore(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getRightIndent(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetRightIndent(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setRightIndent(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetRightIndent(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn setIndents(self: *const T, first_: f32, left_: f32, right_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetIndents(@as(*const ITextPara, @ptrCast(self)), first_, left_, right_);
            }
            pub inline fn setLineSpacing(self: *const T, rule_: i32, spacing_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetLineSpacing(@as(*const ITextPara, @ptrCast(self)), rule_, spacing_);
            }
            pub inline fn getSpaceAfter(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetSpaceAfter(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setSpaceAfter(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetSpaceAfter(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getSpaceBefore(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetSpaceBefore(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setSpaceBefore(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetSpaceBefore(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getWidowControl(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetWidowControl(@as(*const ITextPara, @ptrCast(self)), p_value_);
            }
            pub inline fn setWidowControl(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetWidowControl(@as(*const ITextPara, @ptrCast(self)), value_);
            }
            pub inline fn getTabCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetTabCount(@as(*const ITextPara, @ptrCast(self)), p_count_);
            }
            pub inline fn addTab(self: *const T, tb_pos_: f32, tb_align_: i32, tb_leader_: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).AddTab(@as(*const ITextPara, @ptrCast(self)), tb_pos_, tb_align_, tb_leader_);
            }
            pub inline fn clearAllTabs(self: *const T) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).ClearAllTabs(@as(*const ITextPara, @ptrCast(self)));
            }
            pub inline fn deleteTab(self: *const T, tb_pos_: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).DeleteTab(@as(*const ITextPara, @ptrCast(self)), tb_pos_);
            }
            pub inline fn getTab(self: *const T, i_tab_: i32, ptb_pos_: ?*f32, ptb_align_: ?*i32, ptb_leader_: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetTab(@as(*const ITextPara, @ptrCast(self)), i_tab_, ptb_pos_, ptb_align_, ptb_leader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextStoryRanges_Value = Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: *const fn (
            self: *const ITextStoryRanges,
            ppunk_enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ITextStoryRanges,
            index: i32,
            pp_range: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const ITextStoryRanges,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn newEnum(self: *const T, ppunk_enum_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable))._NewEnum(@as(*const ITextStoryRanges, @ptrCast(self)), ppunk_enum_);
            }
            pub inline fn item(self: *const T, index_: i32, pp_range_: ?*?*ITextRange) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable)).Item(@as(*const ITextStoryRanges, @ptrCast(self)), index_, pp_range_);
            }
            pub inline fn getCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextStoryRanges, @ptrCast(self)), p_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDocument2_Value = Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: *const fn (
            self: *const ITextDocument2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: *const fn (
            self: *const ITextDocument2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplays: *const fn (
            self: *const ITextDocument2,
            pp_displays: ?*?*ITextDisplays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: *const fn (
            self: *const ITextDocument2,
            pp_font: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentFont: *const fn (
            self: *const ITextDocument2,
            p_font: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: *const fn (
            self: *const ITextDocument2,
            pp_para: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPara: *const fn (
            self: *const ITextDocument2,
            p_para: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEastAsianFlags: *const fn (
            self: *const ITextDocument2,
            p_flags: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerator: *const fn (
            self: *const ITextDocument2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIMEInProgress: *const fn (
            self: *const ITextDocument2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: *const fn (
            self: *const ITextDocument2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: *const fn (
            self: *const ITextDocument2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: *const fn (
            self: *const ITextDocument2,
            pp_sel: ?*?*ITextSelection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges2: *const fn (
            self: *const ITextDocument2,
            pp_stories: ?*?*ITextStoryRanges2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypographyOptions: *const fn (
            self: *const ITextDocument2,
            p_options: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn (
            self: *const ITextDocument2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: *const fn (
            self: *const ITextDocument2,
            p_hwnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMsgFilter: *const fn (
            self: *const ITextDocument2,
            p_filter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: *const fn (
            self: *const ITextDocument2,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: *const fn (
            self: *const ITextDocument2,
            pp_void: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: *const fn (
            self: *const ITextDocument2,
            type: tomConstants,
            p_left: ?*i32,
            p_top: ?*i32,
            p_right: ?*i32,
            p_bottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: *const fn (
            self: *const ITextDocument2,
            index: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: *const fn (
            self: *const ITextDocument2,
            p_context: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: *const fn (
            self: *const ITextDocument2,
            cp: i32,
            char_rep: i32,
            options: i32,
            cur_char_rep: i32,
            cur_font_size: i32,
            pbstr: ?*?BSTR,
            p_pitch_and_family: ?*i32,
            p_new_font_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextDocument2,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrings: *const fn (
            self: *const ITextDocument2,
            pp_strs: ?*?*ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: *const fn (
            self: *const ITextDocument2,
            notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range2: *const fn (
            self: *const ITextDocument2,
            cp_active: i32,
            cp_anchor: i32,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint2: *const fn (
            self: *const ITextDocument2,
            x: i32,
            y: i32,
            type: i32,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: *const fn (
            self: *const ITextDocument2,
            p_void: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: *const fn (
            self: *const ITextDocument2,
            context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: *const fn (
            self: *const ITextDocument2,
            index: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextDocument2,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypographyOptions: *const fn (
            self: *const ITextDocument2,
            options: i32,
            mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: *const fn (
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: *const fn (
            self: *const ITextDocument2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: *const fn (
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathProperties: *const fn (
            self: *const ITextDocument2,
            p_options: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathProperties: *const fn (
            self: *const ITextDocument2,
            options: i32,
            mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveStory: *const fn (
            self: *const ITextDocument2,
            pp_story: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveStory: *const fn (
            self: *const ITextDocument2,
            p_story: ?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainStory: *const fn (
            self: *const ITextDocument2,
            pp_story: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewStory: *const fn (
            self: *const ITextDocument2,
            pp_story: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStory: *const fn (
            self: *const ITextDocument2,
            index: i32,
            pp_story: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextDocument.MethodMixin(T);
            pub inline fn getCaretType(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetCaretType(@as(*const ITextDocument2, @ptrCast(self)), p_value_);
            }
            pub inline fn setCaretType(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetCaretType(@as(*const ITextDocument2, @ptrCast(self)), value_);
            }
            pub inline fn getDisplays(self: *const T, pp_displays_: ?*?*ITextDisplays) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDisplays(@as(*const ITextDocument2, @ptrCast(self)), pp_displays_);
            }
            pub inline fn getDocumentFont(self: *const T, pp_font_: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDocumentFont(@as(*const ITextDocument2, @ptrCast(self)), pp_font_);
            }
            pub inline fn setDocumentFont(self: *const T, p_font_: ?*ITextFont2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetDocumentFont(@as(*const ITextDocument2, @ptrCast(self)), p_font_);
            }
            pub inline fn getDocumentPara(self: *const T, pp_para_: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDocumentPara(@as(*const ITextDocument2, @ptrCast(self)), pp_para_);
            }
            pub inline fn setDocumentPara(self: *const T, p_para_: ?*ITextPara2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetDocumentPara(@as(*const ITextDocument2, @ptrCast(self)), p_para_);
            }
            pub inline fn getEastAsianFlags(self: *const T, p_flags_: ?*tomConstants) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetEastAsianFlags(@as(*const ITextDocument2, @ptrCast(self)), p_flags_);
            }
            pub inline fn getGenerator(self: *const T, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetGenerator(@as(*const ITextDocument2, @ptrCast(self)), pbstr_);
            }
            pub inline fn setIMEInProgress(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetIMEInProgress(@as(*const ITextDocument2, @ptrCast(self)), value_);
            }
            pub inline fn getNotificationMode(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetNotificationMode(@as(*const ITextDocument2, @ptrCast(self)), p_value_);
            }
            pub inline fn setNotificationMode(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetNotificationMode(@as(*const ITextDocument2, @ptrCast(self)), value_);
            }
            pub inline fn getSelection2(self: *const T, pp_sel_: ?*?*ITextSelection2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetSelection2(@as(*const ITextDocument2, @ptrCast(self)), pp_sel_);
            }
            pub inline fn getStoryRanges2(self: *const T, pp_stories_: ?*?*ITextStoryRanges2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStoryRanges2(@as(*const ITextDocument2, @ptrCast(self)), pp_stories_);
            }
            pub inline fn getTypographyOptions(self: *const T, p_options_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetTypographyOptions(@as(*const ITextDocument2, @ptrCast(self)), p_options_);
            }
            pub inline fn getVersion(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ITextDocument2, @ptrCast(self)), p_value_);
            }
            pub inline fn getWindow(self: *const T, p_hwnd_: ?*i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const ITextDocument2, @ptrCast(self)), p_hwnd_);
            }
            pub inline fn attachMsgFilter(self: *const T, p_filter_: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).AttachMsgFilter(@as(*const ITextDocument2, @ptrCast(self)), p_filter_);
            }
            pub inline fn checkTextLimit(self: *const T, cch_: i32, pcch_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).CheckTextLimit(@as(*const ITextDocument2, @ptrCast(self)), cch_, pcch_);
            }
            pub inline fn getCallManager(self: *const T, pp_void_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetCallManager(@as(*const ITextDocument2, @ptrCast(self)), pp_void_);
            }
            pub inline fn getClientRect(self: *const T, type_: tomConstants, p_left_: ?*i32, p_top_: ?*i32, p_right_: ?*i32, p_bottom_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetClientRect(@as(*const ITextDocument2, @ptrCast(self)), type_, p_left_, p_top_, p_right_, p_bottom_);
            }
            pub inline fn getEffectColor(self: *const T, index_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetEffectColor(@as(*const ITextDocument2, @ptrCast(self)), index_, p_value_);
            }
            pub inline fn getImmContext(self: *const T, p_context_: ?*i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetImmContext(@as(*const ITextDocument2, @ptrCast(self)), p_context_);
            }
            pub inline fn getPreferredFont(self: *const T, cp_: i32, char_rep_: i32, options_: i32, cur_char_rep_: i32, cur_font_size_: i32, pbstr_: ?*?BSTR, p_pitch_and_family_: ?*i32, p_new_font_size_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetPreferredFont(@as(*const ITextDocument2, @ptrCast(self)), cp_, char_rep_, options_, cur_char_rep_, cur_font_size_, pbstr_, p_pitch_and_family_, p_new_font_size_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextDocument2, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn getStrings(self: *const T, pp_strs_: ?*?*ITextStrings) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStrings(@as(*const ITextDocument2, @ptrCast(self)), pp_strs_);
            }
            pub inline fn notify(self: *const T, notify_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Notify(@as(*const ITextDocument2, @ptrCast(self)), notify_);
            }
            pub inline fn range2(self: *const T, cp_active_: i32, cp_anchor_: i32, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Range2(@as(*const ITextDocument2, @ptrCast(self)), cp_active_, cp_anchor_, pp_range_);
            }
            pub inline fn rangeFromPoint2(self: *const T, x_: i32, y_: i32, type_: i32, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).RangeFromPoint2(@as(*const ITextDocument2, @ptrCast(self)), x_, y_, type_, pp_range_);
            }
            pub inline fn releaseCallManager(self: *const T, p_void_: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).ReleaseCallManager(@as(*const ITextDocument2, @ptrCast(self)), p_void_);
            }
            pub inline fn releaseImmContext(self: *const T, context_: i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).ReleaseImmContext(@as(*const ITextDocument2, @ptrCast(self)), context_);
            }
            pub inline fn setEffectColor(self: *const T, index_: i32, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetEffectColor(@as(*const ITextDocument2, @ptrCast(self)), index_, value_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextDocument2, @ptrCast(self)), type_, value_);
            }
            pub inline fn setTypographyOptions(self: *const T, options_: i32, mask_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetTypographyOptions(@as(*const ITextDocument2, @ptrCast(self)), options_, mask_);
            }
            pub inline fn sysBeep(self: *const T) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SysBeep(@as(*const ITextDocument2, @ptrCast(self)));
            }
            pub inline fn update(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Update(@as(*const ITextDocument2, @ptrCast(self)), value_);
            }
            pub inline fn updateWindow(self: *const T) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).UpdateWindow(@as(*const ITextDocument2, @ptrCast(self)));
            }
            pub inline fn getMathProperties(self: *const T, p_options_: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetMathProperties(@as(*const ITextDocument2, @ptrCast(self)), p_options_);
            }
            pub inline fn setMathProperties(self: *const T, options_: i32, mask_: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetMathProperties(@as(*const ITextDocument2, @ptrCast(self)), options_, mask_);
            }
            pub inline fn getActiveStory(self: *const T, pp_story_: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetActiveStory(@as(*const ITextDocument2, @ptrCast(self)), pp_story_);
            }
            pub inline fn setActiveStory(self: *const T, p_story_: ?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetActiveStory(@as(*const ITextDocument2, @ptrCast(self)), p_story_);
            }
            pub inline fn getMainStory(self: *const T, pp_story_: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetMainStory(@as(*const ITextDocument2, @ptrCast(self)), pp_story_);
            }
            pub inline fn getNewStory(self: *const T, pp_story_: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetNewStory(@as(*const ITextDocument2, @ptrCast(self)), pp_story_);
            }
            pub inline fn getStory(self: *const T, index_: i32, pp_story_: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStory(@as(*const ITextDocument2, @ptrCast(self)), index_, pp_story_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRange2_Value = Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: *const fn (
            self: *const ITextRange2,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCells: *const fn (
            self: *const ITextRange2,
            pp_cells: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: *const fn (
            self: *const ITextRange2,
            pp_column: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const ITextRange2,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: *const fn (
            self: *const ITextRange2,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont2: *const fn (
            self: *const ITextRange2,
            pp_font: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont2: *const fn (
            self: *const ITextRange2,
            p_font: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText2: *const fn (
            self: *const ITextRange2,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText2: *const fn (
            self: *const ITextRange2,
            p_range: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: *const fn (
            self: *const ITextRange2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: *const fn (
            self: *const ITextRange2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara2: *const fn (
            self: *const ITextRange2,
            pp_para: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara2: *const fn (
            self: *const ITextRange2,
            p_para: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRow: *const fn (
            self: *const ITextRange2,
            pp_row: ?*?*ITextRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartPara: *const fn (
            self: *const ITextRange2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: *const fn (
            self: *const ITextRange2,
            pp_table: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: *const fn (
            self: *const ITextRange2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURL: *const fn (
            self: *const ITextRange2,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubrange: *const fn (
            self: *const ITextRange2,
            cp1: i32,
            cp2: i32,
            activate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpMath: *const fn (
            self: *const ITextRange2,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubrange: *const fn (
            self: *const ITextRange2,
            cp_first: i32,
            cp_lim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: *const fn (
            self: *const ITextRange2,
            p_range: ?*ITextRange2,
            count: i32,
            flags: i32,
            p_delta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar2: *const fn (
            self: *const ITextRange2,
            p_char: ?*i32,
            offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropCap: *const fn (
            self: *const ITextRange2,
            pc_line: ?*i32,
            p_position: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInlineObject: *const fn (
            self: *const ITextRange2,
            p_type: ?*i32,
            p_align: ?*i32,
            p_char: ?*i32,
            p_char1: ?*i32,
            p_char2: ?*i32,
            p_count: ?*i32,
            p_te_x_style: ?*i32,
            pc_col: ?*i32,
            p_level: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextRange2,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: *const fn (
            self: *const ITextRange2,
            type: i32,
            p_left: ?*i32,
            p_top: ?*i32,
            p_right: ?*i32,
            p_bottom: ?*i32,
            p_hit: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubrange: *const fn (
            self: *const ITextRange2,
            i_subrange: i32,
            pcp_first: ?*i32,
            pcp_lim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText2: *const fn (
            self: *const ITextRange2,
            flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HexToUnicode: *const fn (
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTable: *const fn (
            self: *const ITextRange2,
            c_col: i32,
            c_row: i32,
            auto_fit: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Linearize: *const fn (
            self: *const ITextRange2,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveSubrange: *const fn (
            self: *const ITextRange2,
            cp_anchor: i32,
            cp_active: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDropCap: *const fn (
            self: *const ITextRange2,
            c_line: i32,
            position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextRange2,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText2: *const fn (
            self: *const ITextRange2,
            flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnicodeToHex: *const fn (
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInlineObject: *const fn (
            self: *const ITextRange2,
            type: i32,
            @"align": i32,
            char: i32,
            char1: i32,
            char2: i32,
            count: i32,
            te_x_style: i32,
            c_col: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathFunctionType: *const fn (
            self: *const ITextRange2,
            bstr: ?BSTR,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertImage: *const fn (
            self: *const ITextRange2,
            width: i32,
            height: i32,
            ascent: i32,
            type: TEXT_ALIGN_OPTIONS,
            bstr_alt_text: ?BSTR,
            p_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextSelection.MethodMixin(T);
            pub inline fn getCch(self: *const T, pcch_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCch(@as(*const ITextRange2, @ptrCast(self)), pcch_);
            }
            pub inline fn getCells(self: *const T, pp_cells_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCells(@as(*const ITextRange2, @ptrCast(self)), pp_cells_);
            }
            pub inline fn getColumn(self: *const T, pp_column_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const ITextRange2, @ptrCast(self)), pp_column_);
            }
            pub inline fn getCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextRange2, @ptrCast(self)), p_count_);
            }
            pub inline fn getDuplicate2(self: *const T, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextRange2, @ptrCast(self)), pp_range_);
            }
            pub inline fn getFont2(self: *const T, pp_font_: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetFont2(@as(*const ITextRange2, @ptrCast(self)), pp_font_);
            }
            pub inline fn setFont2(self: *const T, p_font_: ?*ITextFont2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetFont2(@as(*const ITextRange2, @ptrCast(self)), p_font_);
            }
            pub inline fn getFormattedText2(self: *const T, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetFormattedText2(@as(*const ITextRange2, @ptrCast(self)), pp_range_);
            }
            pub inline fn setFormattedText2(self: *const T, p_range_: ?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetFormattedText2(@as(*const ITextRange2, @ptrCast(self)), p_range_);
            }
            pub inline fn getGravity(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const ITextRange2, @ptrCast(self)), p_value_);
            }
            pub inline fn setGravity(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const ITextRange2, @ptrCast(self)), value_);
            }
            pub inline fn getPara2(self: *const T, pp_para_: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetPara2(@as(*const ITextRange2, @ptrCast(self)), pp_para_);
            }
            pub inline fn setPara2(self: *const T, p_para_: ?*ITextPara2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetPara2(@as(*const ITextRange2, @ptrCast(self)), p_para_);
            }
            pub inline fn getRow(self: *const T, pp_row_: ?*?*ITextRow) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetRow(@as(*const ITextRange2, @ptrCast(self)), pp_row_);
            }
            pub inline fn getStartPara(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetStartPara(@as(*const ITextRange2, @ptrCast(self)), p_value_);
            }
            pub inline fn getTable(self: *const T, pp_table_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetTable(@as(*const ITextRange2, @ptrCast(self)), pp_table_);
            }
            pub inline fn getURL(self: *const T, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetURL(@as(*const ITextRange2, @ptrCast(self)), pbstr_);
            }
            pub inline fn setURL(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetURL(@as(*const ITextRange2, @ptrCast(self)), bstr_);
            }
            pub inline fn addSubrange(self: *const T, cp1_: i32, cp2_: i32, activate_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).AddSubrange(@as(*const ITextRange2, @ptrCast(self)), cp1_, cp2_, activate_);
            }
            pub inline fn buildUpMath(self: *const T, flags_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).BuildUpMath(@as(*const ITextRange2, @ptrCast(self)), flags_);
            }
            pub inline fn deleteSubrange(self: *const T, cp_first_: i32, cp_lim_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).DeleteSubrange(@as(*const ITextRange2, @ptrCast(self)), cp_first_, cp_lim_);
            }
            pub inline fn find(self: *const T, p_range_: ?*ITextRange2, count_: i32, flags_: i32, p_delta_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).Find(@as(*const ITextRange2, @ptrCast(self)), p_range_, count_, flags_, p_delta_);
            }
            pub inline fn getChar2(self: *const T, p_char_: ?*i32, offset_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetChar2(@as(*const ITextRange2, @ptrCast(self)), p_char_, offset_);
            }
            pub inline fn getDropCap(self: *const T, pc_line_: ?*i32, p_position_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetDropCap(@as(*const ITextRange2, @ptrCast(self)), pc_line_, p_position_);
            }
            pub inline fn getInlineObject(self: *const T, p_type_: ?*i32, p_align_: ?*i32, p_char_: ?*i32, p_char1_: ?*i32, p_char2_: ?*i32, p_count_: ?*i32, p_te_x_style_: ?*i32, pc_col_: ?*i32, p_level_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetInlineObject(@as(*const ITextRange2, @ptrCast(self)), p_type_, p_align_, p_char_, p_char1_, p_char2_, p_count_, p_te_x_style_, pc_col_, p_level_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextRange2, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn getRect(self: *const T, type_: i32, p_left_: ?*i32, p_top_: ?*i32, p_right_: ?*i32, p_bottom_: ?*i32, p_hit_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetRect(@as(*const ITextRange2, @ptrCast(self)), type_, p_left_, p_top_, p_right_, p_bottom_, p_hit_);
            }
            pub inline fn getSubrange(self: *const T, i_subrange_: i32, pcp_first_: ?*i32, pcp_lim_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetSubrange(@as(*const ITextRange2, @ptrCast(self)), i_subrange_, pcp_first_, pcp_lim_);
            }
            pub inline fn getText2(self: *const T, flags_: i32, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetText2(@as(*const ITextRange2, @ptrCast(self)), flags_, pbstr_);
            }
            pub inline fn hexToUnicode(self: *const T) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).HexToUnicode(@as(*const ITextRange2, @ptrCast(self)));
            }
            pub inline fn insertTable(self: *const T, c_col_: i32, c_row_: i32, auto_fit_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).InsertTable(@as(*const ITextRange2, @ptrCast(self)), c_col_, c_row_, auto_fit_);
            }
            pub inline fn linearize(self: *const T, flags_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).Linearize(@as(*const ITextRange2, @ptrCast(self)), flags_);
            }
            pub inline fn setActiveSubrange(self: *const T, cp_anchor_: i32, cp_active_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetActiveSubrange(@as(*const ITextRange2, @ptrCast(self)), cp_anchor_, cp_active_);
            }
            pub inline fn setDropCap(self: *const T, c_line_: i32, position_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetDropCap(@as(*const ITextRange2, @ptrCast(self)), c_line_, position_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextRange2, @ptrCast(self)), type_, value_);
            }
            pub inline fn setText2(self: *const T, flags_: i32, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetText2(@as(*const ITextRange2, @ptrCast(self)), flags_, bstr_);
            }
            pub inline fn unicodeToHex(self: *const T) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).UnicodeToHex(@as(*const ITextRange2, @ptrCast(self)));
            }
            pub inline fn setInlineObject(self: *const T, type_: i32, align_: i32, char_: i32, char1_: i32, char2_: i32, count_: i32, te_x_style_: i32, c_col_: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetInlineObject(@as(*const ITextRange2, @ptrCast(self)), type_, align_, char_, char1_, char2_, count_, te_x_style_, c_col_);
            }
            pub inline fn getMathFunctionType(self: *const T, bstr_: ?BSTR, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetMathFunctionType(@as(*const ITextRange2, @ptrCast(self)), bstr_, p_value_);
            }
            pub inline fn insertImage(self: *const T, width_: i32, height_: i32, ascent_: i32, type_: TEXT_ALIGN_OPTIONS, bstr_alt_text_: ?BSTR, p_stream_: ?*IStream) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).InsertImage(@as(*const ITextRange2, @ptrCast(self)), width_, height_, ascent_, type_, bstr_alt_text_, p_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextSelection2_Value = Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextRange2.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextFont2_Value = Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: *const fn (
            self: *const ITextFont2,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoLigatures: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutoLigatures: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceAlpha: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceAlpha: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceNumeric: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceNumeric: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceParens: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceParens: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharRep: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCharRep: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionMode: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompressionMode: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDoubleStrike: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDoubleStrike: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: *const fn (
            self: *const ITextFont2,
            pp_font: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: *const fn (
            self: *const ITextFont2,
            p_font: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkType: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathZone: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathZone: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthPairs: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthPairs: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthSpace: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthSpace: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOldNumbers: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOldNumbers: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlapping: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlapping: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionSubSuper: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositionSubSuper: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScaling: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaling: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceExtension: *const fn (
            self: *const ITextFont2,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceExtension: *const fn (
            self: *const ITextFont2,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderlinePositionMode: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderlinePositionMode: *const fn (
            self: *const ITextFont2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
            p_mask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects2: *const fn (
            self: *const ITextFont2,
            p_value: ?*i32,
            p_mask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextFont2,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: *const fn (
            self: *const ITextFont2,
            index: i32,
            p_type: ?*i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: *const fn (
            self: *const ITextFont2,
            p_font: ?*ITextFont2,
            p_b: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: *const fn (
            self: *const ITextFont2,
            value: i32,
            mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects2: *const fn (
            self: *const ITextFont2,
            value: i32,
            mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextFont2,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextFont.MethodMixin(T);
            pub inline fn getCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextFont2, @ptrCast(self)), p_count_);
            }
            pub inline fn getAutoLigatures(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutoLigatures(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setAutoLigatures(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutoLigatures(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getAutospaceAlpha(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceAlpha(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setAutospaceAlpha(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceAlpha(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getAutospaceNumeric(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceNumeric(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setAutospaceNumeric(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceNumeric(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getAutospaceParens(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceParens(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setAutospaceParens(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceParens(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getCharRep(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCharRep(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setCharRep(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCharRep(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getCompressionMode(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCompressionMode(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setCompressionMode(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCompressionMode(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getCookie(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setCookie(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCookie(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getDoubleStrike(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetDoubleStrike(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setDoubleStrike(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetDoubleStrike(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getDuplicate2(self: *const T, pp_font_: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextFont2, @ptrCast(self)), pp_font_);
            }
            pub inline fn setDuplicate2(self: *const T, p_font_: ?*ITextFont2) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetDuplicate2(@as(*const ITextFont2, @ptrCast(self)), p_font_);
            }
            pub inline fn getLinkType(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetLinkType(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn getMathZone(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetMathZone(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setMathZone(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetMathZone(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getModWidthPairs(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetModWidthPairs(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setModWidthPairs(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetModWidthPairs(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getModWidthSpace(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetModWidthSpace(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setModWidthSpace(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetModWidthSpace(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getOldNumbers(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetOldNumbers(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setOldNumbers(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetOldNumbers(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getOverlapping(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetOverlapping(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setOverlapping(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetOverlapping(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getPositionSubSuper(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetPositionSubSuper(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setPositionSubSuper(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetPositionSubSuper(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getScaling(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetScaling(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setScaling(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetScaling(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getSpaceExtension(self: *const T, p_value_: ?*f32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetSpaceExtension(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setSpaceExtension(self: *const T, value_: f32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetSpaceExtension(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getUnderlinePositionMode(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetUnderlinePositionMode(@as(*const ITextFont2, @ptrCast(self)), p_value_);
            }
            pub inline fn setUnderlinePositionMode(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetUnderlinePositionMode(@as(*const ITextFont2, @ptrCast(self)), value_);
            }
            pub inline fn getEffects(self: *const T, p_value_: ?*i32, p_mask_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetEffects(@as(*const ITextFont2, @ptrCast(self)), p_value_, p_mask_);
            }
            pub inline fn getEffects2(self: *const T, p_value_: ?*i32, p_mask_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetEffects2(@as(*const ITextFont2, @ptrCast(self)), p_value_, p_mask_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextFont2, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn getPropertyInfo(self: *const T, index_: i32, p_type_: ?*i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const ITextFont2, @ptrCast(self)), index_, p_type_, p_value_);
            }
            pub inline fn isEqual2(self: *const T, p_font_: ?*ITextFont2, p_b_: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).IsEqual2(@as(*const ITextFont2, @ptrCast(self)), p_font_, p_b_);
            }
            pub inline fn setEffects(self: *const T, value_: i32, mask_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetEffects(@as(*const ITextFont2, @ptrCast(self)), value_, mask_);
            }
            pub inline fn setEffects2(self: *const T, value_: i32, mask_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetEffects2(@as(*const ITextFont2, @ptrCast(self)), value_, mask_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextFont2, @ptrCast(self)), type_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextPara2_Value = Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: *const fn (
            self: *const ITextPara2,
            pp_borders: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: *const fn (
            self: *const ITextPara2,
            pp_para: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: *const fn (
            self: *const ITextPara2,
            p_para: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontAlignment: *const fn (
            self: *const ITextPara2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFontAlignment: *const fn (
            self: *const ITextPara2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHangingPunctuation: *const fn (
            self: *const ITextPara2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHangingPunctuation: *const fn (
            self: *const ITextPara2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapToGrid: *const fn (
            self: *const ITextPara2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapToGrid: *const fn (
            self: *const ITextPara2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrimPunctuationAtStart: *const fn (
            self: *const ITextPara2,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrimPunctuationAtStart: *const fn (
            self: *const ITextPara2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: *const fn (
            self: *const ITextPara2,
            p_value: ?*i32,
            p_mask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextPara2,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: *const fn (
            self: *const ITextPara2,
            p_para: ?*ITextPara2,
            p_b: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: *const fn (
            self: *const ITextPara2,
            value: i32,
            mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextPara2,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextPara.MethodMixin(T);
            pub inline fn getBorders(self: *const T, pp_borders_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetBorders(@as(*const ITextPara2, @ptrCast(self)), pp_borders_);
            }
            pub inline fn getDuplicate2(self: *const T, pp_para_: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextPara2, @ptrCast(self)), pp_para_);
            }
            pub inline fn setDuplicate2(self: *const T, p_para_: ?*ITextPara2) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetDuplicate2(@as(*const ITextPara2, @ptrCast(self)), p_para_);
            }
            pub inline fn getFontAlignment(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetFontAlignment(@as(*const ITextPara2, @ptrCast(self)), p_value_);
            }
            pub inline fn setFontAlignment(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetFontAlignment(@as(*const ITextPara2, @ptrCast(self)), value_);
            }
            pub inline fn getHangingPunctuation(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetHangingPunctuation(@as(*const ITextPara2, @ptrCast(self)), p_value_);
            }
            pub inline fn setHangingPunctuation(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetHangingPunctuation(@as(*const ITextPara2, @ptrCast(self)), value_);
            }
            pub inline fn getSnapToGrid(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetSnapToGrid(@as(*const ITextPara2, @ptrCast(self)), p_value_);
            }
            pub inline fn setSnapToGrid(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetSnapToGrid(@as(*const ITextPara2, @ptrCast(self)), value_);
            }
            pub inline fn getTrimPunctuationAtStart(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetTrimPunctuationAtStart(@as(*const ITextPara2, @ptrCast(self)), p_value_);
            }
            pub inline fn setTrimPunctuationAtStart(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetTrimPunctuationAtStart(@as(*const ITextPara2, @ptrCast(self)), value_);
            }
            pub inline fn getEffects(self: *const T, p_value_: ?*i32, p_mask_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetEffects(@as(*const ITextPara2, @ptrCast(self)), p_value_, p_mask_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextPara2, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn isEqual2(self: *const T, p_para_: ?*ITextPara2, p_b_: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).IsEqual2(@as(*const ITextPara2, @ptrCast(self)), p_para_, p_b_);
            }
            pub inline fn setEffects(self: *const T, value_: i32, mask_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetEffects(@as(*const ITextPara2, @ptrCast(self)), value_, mask_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextPara2, @ptrCast(self)), type_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoryRanges2_Value = Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: *const fn (
            self: *const ITextStoryRanges2,
            index: i32,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoryRanges.MethodMixin(T);
            pub inline fn item2(self: *const T, index_: i32, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStoryRanges2.VTable, @ptrCast(self.vtable)).Item2(@as(*const ITextStoryRanges2, @ptrCast(self)), index_, pp_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStory_Value = Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: *const fn (
            self: *const ITextStory,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActive: *const fn (
            self: *const ITextStory,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplay: *const fn (
            self: *const ITextStory,
            pp_display: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: *const fn (
            self: *const ITextStory,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: *const fn (
            self: *const ITextStory,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: *const fn (
            self: *const ITextStory,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextStory,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: *const fn (
            self: *const ITextStory,
            cp_active: i32,
            cp_anchor: i32,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ITextStory,
            flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: *const fn (
            self: *const ITextStory,
            p_unk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextStory,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: *const fn (
            self: *const ITextStory,
            flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getActive(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetActive(@as(*const ITextStory, @ptrCast(self)), p_value_);
            }
            pub inline fn setActive(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetActive(@as(*const ITextStory, @ptrCast(self)), value_);
            }
            pub inline fn getDisplay(self: *const T, pp_display_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetDisplay(@as(*const ITextStory, @ptrCast(self)), pp_display_);
            }
            pub inline fn getIndex(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITextStory, @ptrCast(self)), p_value_);
            }
            pub inline fn getType(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITextStory, @ptrCast(self)), p_value_);
            }
            pub inline fn setType(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetType(@as(*const ITextStory, @ptrCast(self)), value_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextStory, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn getRange(self: *const T, cp_active_: i32, cp_anchor_: i32, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITextStory, @ptrCast(self)), cp_active_, cp_anchor_, pp_range_);
            }
            pub inline fn getText(self: *const T, flags_: i32, pbstr_: ?*?BSTR) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStory, @ptrCast(self)), flags_, pbstr_);
            }
            pub inline fn setFormattedText(self: *const T, p_unk_: ?*IUnknown) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextStory, @ptrCast(self)), p_unk_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextStory, @ptrCast(self)), type_, value_);
            }
            pub inline fn setText(self: *const T, flags_: i32, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStory, @ptrCast(self)), flags_, bstr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStrings_Value = Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: *const fn (
            self: *const ITextStrings,
            index: i32,
            pp_range: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const ITextStrings,
            p_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: *const fn (
            self: *const ITextStrings,
            p_range: ?*ITextRange2,
            i_string: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cat2: *const fn (
            self: *const ITextStrings,
            i_string: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatTop2: *const fn (
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRange: *const fn (
            self: *const ITextStrings,
            p_range: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeFunction: *const fn (
            self: *const ITextStrings,
            type: i32,
            @"align": i32,
            char: i32,
            char1: i32,
            char2: i32,
            count: i32,
            te_x_style: i32,
            c_col: i32,
            p_range: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCch: *const fn (
            self: *const ITextStrings,
            i_string: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertNullStr: *const fn (
            self: *const ITextStrings,
            i_string: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveBoundary: *const fn (
            self: *const ITextStrings,
            i_string: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrefixTop: *const fn (
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const ITextStrings,
            i_string: i32,
            c_string: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: *const fn (
            self: *const ITextStrings,
            p_range_d: ?*ITextRange2,
            p_range_s: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpCp: *const fn (
            self: *const ITextStrings,
            i_string: i32,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuffixTop: *const fn (
            self: *const ITextStrings,
            bstr: ?BSTR,
            p_range: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Swap: *const fn (
            self: *const ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn item(self: *const T, index_: i32, pp_range_: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Item(@as(*const ITextStrings, @ptrCast(self)), index_, pp_range_);
            }
            pub inline fn getCount(self: *const T, p_count_: ?*i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextStrings, @ptrCast(self)), p_count_);
            }
            pub inline fn add(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Add(@as(*const ITextStrings, @ptrCast(self)), bstr_);
            }
            pub inline fn append(self: *const T, p_range_: ?*ITextRange2, i_string_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Append(@as(*const ITextStrings, @ptrCast(self)), p_range_, i_string_);
            }
            pub inline fn cat2(self: *const T, i_string_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Cat2(@as(*const ITextStrings, @ptrCast(self)), i_string_);
            }
            pub inline fn catTop2(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).CatTop2(@as(*const ITextStrings, @ptrCast(self)), bstr_);
            }
            pub inline fn deleteRange(self: *const T, p_range_: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).DeleteRange(@as(*const ITextStrings, @ptrCast(self)), p_range_);
            }
            pub inline fn encodeFunction(self: *const T, type_: i32, align_: i32, char_: i32, char1_: i32, char2_: i32, count_: i32, te_x_style_: i32, c_col_: i32, p_range_: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).EncodeFunction(@as(*const ITextStrings, @ptrCast(self)), type_, align_, char_, char1_, char2_, count_, te_x_style_, c_col_, p_range_);
            }
            pub inline fn getCch(self: *const T, i_string_: i32, pcch_: ?*i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).GetCch(@as(*const ITextStrings, @ptrCast(self)), i_string_, pcch_);
            }
            pub inline fn insertNullStr(self: *const T, i_string_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).InsertNullStr(@as(*const ITextStrings, @ptrCast(self)), i_string_);
            }
            pub inline fn moveBoundary(self: *const T, i_string_: i32, cch_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).MoveBoundary(@as(*const ITextStrings, @ptrCast(self)), i_string_, cch_);
            }
            pub inline fn prefixTop(self: *const T, bstr_: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).PrefixTop(@as(*const ITextStrings, @ptrCast(self)), bstr_);
            }
            pub inline fn remove(self: *const T, i_string_: i32, c_string_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Remove(@as(*const ITextStrings, @ptrCast(self)), i_string_, c_string_);
            }
            pub inline fn setFormattedText(self: *const T, p_range_d_: ?*ITextRange2, p_range_s_: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextStrings, @ptrCast(self)), p_range_d_, p_range_s_);
            }
            pub inline fn setOpCp(self: *const T, i_string_: i32, cp_: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SetOpCp(@as(*const ITextStrings, @ptrCast(self)), i_string_, cp_);
            }
            pub inline fn suffixTop(self: *const T, bstr_: ?BSTR, p_range_: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SuffixTop(@as(*const ITextStrings, @ptrCast(self)), bstr_, p_range_);
            }
            pub inline fn swap(self: *const T) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Swap(@as(*const ITextStrings, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRow_Value = Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCount: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCount: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCountCache: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCountCache: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellIndex: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellIndex: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMargin: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMargin: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeight: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeight: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndent: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndent: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNestLevel: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRTL: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRTL: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellAlignment: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellAlignment: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorBack: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorBack: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorFore: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorFore: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMergeFlags: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMergeFlags: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellShading: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellShading: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellVerticalText: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellVerticalText: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellWidth: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellWidth: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderColors: *const fn (
            self: *const ITextRow,
            pcr_left: ?*i32,
            pcr_top: ?*i32,
            pcr_right: ?*i32,
            pcr_bottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderWidths: *const fn (
            self: *const ITextRow,
            pdu_left: ?*i32,
            pdu_top: ?*i32,
            pdu_right: ?*i32,
            pdu_bottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderColors: *const fn (
            self: *const ITextRow,
            cr_left: i32,
            cr_top: i32,
            cr_right: i32,
            cr_bottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderWidths: *const fn (
            self: *const ITextRow,
            du_left: i32,
            du_top: i32,
            du_right: i32,
            du_bottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: *const fn (
            self: *const ITextRow,
            c_row: i32,
            flags: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: *const fn (
            self: *const ITextRow,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ITextRow,
            type: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: *const fn (
            self: *const ITextRow,
            c_row: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const ITextRow,
            p_row: ?*ITextRow,
            p_b: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ITextRow,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ITextRow,
            type: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAlignment(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetAlignment(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setAlignment(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetAlignment(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellCount(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellCount(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellCount(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellCount(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellCountCache(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellCountCache(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellCountCache(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellCountCache(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellIndex(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellIndex(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellIndex(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellIndex(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellMargin(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellMargin(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellMargin(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellMargin(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getHeight(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetHeight(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setHeight(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetHeight(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getIndent(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetIndent(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setIndent(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetIndent(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getKeepTogether(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetKeepTogether(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setKeepTogether(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetKeepTogether(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getKeepWithNext(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetKeepWithNext(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setKeepWithNext(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetKeepWithNext(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getNestLevel(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetNestLevel(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn getRTL(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetRTL(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setRTL(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetRTL(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellAlignment(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellAlignment(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellAlignment(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellAlignment(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellColorBack(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellColorBack(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellColorBack(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellColorBack(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellColorFore(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellColorFore(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellColorFore(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellColorFore(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellMergeFlags(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellMergeFlags(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellMergeFlags(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellMergeFlags(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellShading(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellShading(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellShading(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellShading(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellVerticalText(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellVerticalText(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellVerticalText(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellVerticalText(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellWidth(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellWidth(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn setCellWidth(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellWidth(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn getCellBorderColors(self: *const T, pcr_left_: ?*i32, pcr_top_: ?*i32, pcr_right_: ?*i32, pcr_bottom_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellBorderColors(@as(*const ITextRow, @ptrCast(self)), pcr_left_, pcr_top_, pcr_right_, pcr_bottom_);
            }
            pub inline fn getCellBorderWidths(self: *const T, pdu_left_: ?*i32, pdu_top_: ?*i32, pdu_right_: ?*i32, pdu_bottom_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellBorderWidths(@as(*const ITextRow, @ptrCast(self)), pdu_left_, pdu_top_, pdu_right_, pdu_bottom_);
            }
            pub inline fn setCellBorderColors(self: *const T, cr_left_: i32, cr_top_: i32, cr_right_: i32, cr_bottom_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellBorderColors(@as(*const ITextRow, @ptrCast(self)), cr_left_, cr_top_, cr_right_, cr_bottom_);
            }
            pub inline fn setCellBorderWidths(self: *const T, du_left_: i32, du_top_: i32, du_right_: i32, du_bottom_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellBorderWidths(@as(*const ITextRow, @ptrCast(self)), du_left_, du_top_, du_right_, du_bottom_);
            }
            pub inline fn apply(self: *const T, c_row_: i32, flags_: tomConstants) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Apply(@as(*const ITextRow, @ptrCast(self)), c_row_, flags_);
            }
            pub inline fn canChange(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextRow, @ptrCast(self)), p_value_);
            }
            pub inline fn getProperty(self: *const T, type_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextRow, @ptrCast(self)), type_, p_value_);
            }
            pub inline fn insert(self: *const T, c_row_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Insert(@as(*const ITextRow, @ptrCast(self)), c_row_);
            }
            pub inline fn isEqual(self: *const T, p_row_: ?*ITextRow, p_b_: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextRow, @ptrCast(self)), p_row_, p_b_);
            }
            pub inline fn reset(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextRow, @ptrCast(self)), value_);
            }
            pub inline fn setProperty(self: *const T, type_: i32, value_: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextRow, @ptrCast(self)), type_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDisplays_Value = Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: *const fn (
            self: *const ITextDocument2Old,
            p_filter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: *const fn (
            self: *const ITextDocument2Old,
            index: i32,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: *const fn (
            self: *const ITextDocument2Old,
            index: i32,
            pcr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretType: *const fn (
            self: *const ITextDocument2Old,
            p_caret_type: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: *const fn (
            self: *const ITextDocument2Old,
            caret_type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: *const fn (
            self: *const ITextDocument2Old,
            p_context: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: *const fn (
            self: *const ITextDocument2Old,
            context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: *const fn (
            self: *const ITextDocument2Old,
            cp: i32,
            char_rep: i32,
            option: i32,
            char_rep_cur: i32,
            cur_font_size: i32,
            pbstr: ?*?BSTR,
            p_pitch_and_family: ?*i32,
            p_new_font_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: *const fn (
            self: *const ITextDocument2Old,
            p_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: *const fn (
            self: *const ITextDocument2Old,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: *const fn (
            self: *const ITextDocument2Old,
            type: i32,
            p_left: ?*i32,
            p_top: ?*i32,
            p_right: ?*i32,
            p_bottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: *const fn (
            self: *const ITextDocument2Old,
            pp_sel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: *const fn (
            self: *const ITextDocument2Old,
            ph_wnd: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFEFlags: *const fn (
            self: *const ITextDocument2Old,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: *const fn (
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: *const fn (
            self: *const ITextDocument2Old,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IMEInProgress: *const fn (
            self: *const ITextDocument2Old,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: *const fn (
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: *const fn (
            self: *const ITextDocument2Old,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: *const fn (
            self: *const ITextDocument2Old,
            notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: *const fn (
            self: *const ITextDocument2Old,
            pp_i_text_font: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: *const fn (
            self: *const ITextDocument2Old,
            pp_i_text_para: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: *const fn (
            self: *const ITextDocument2Old,
            pp_void: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: *const fn (
            self: *const ITextDocument2Old,
            p_void: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextDocument.MethodMixin(T);
            pub inline fn attachMsgFilter(self: *const T, p_filter_: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).AttachMsgFilter(@as(*const ITextDocument2Old, @ptrCast(self)), p_filter_);
            }
            pub inline fn setEffectColor(self: *const T, index_: i32, cr_: u32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetEffectColor(@as(*const ITextDocument2Old, @ptrCast(self)), index_, cr_);
            }
            pub inline fn getEffectColor(self: *const T, index_: i32, pcr_: ?*u32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetEffectColor(@as(*const ITextDocument2Old, @ptrCast(self)), index_, pcr_);
            }
            pub inline fn getCaretType(self: *const T, p_caret_type_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetCaretType(@as(*const ITextDocument2Old, @ptrCast(self)), p_caret_type_);
            }
            pub inline fn setCaretType(self: *const T, caret_type_: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetCaretType(@as(*const ITextDocument2Old, @ptrCast(self)), caret_type_);
            }
            pub inline fn getImmContext(self: *const T, p_context_: ?*i64) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetImmContext(@as(*const ITextDocument2Old, @ptrCast(self)), p_context_);
            }
            pub inline fn releaseImmContext(self: *const T, context_: i64) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).ReleaseImmContext(@as(*const ITextDocument2Old, @ptrCast(self)), context_);
            }
            pub inline fn getPreferredFont(self: *const T, cp_: i32, char_rep_: i32, option_: i32, char_rep_cur_: i32, cur_font_size_: i32, pbstr_: ?*?BSTR, p_pitch_and_family_: ?*i32, p_new_font_size_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetPreferredFont(@as(*const ITextDocument2Old, @ptrCast(self)), cp_, char_rep_, option_, char_rep_cur_, cur_font_size_, pbstr_, p_pitch_and_family_, p_new_font_size_);
            }
            pub inline fn getNotificationMode(self: *const T, p_mode_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetNotificationMode(@as(*const ITextDocument2Old, @ptrCast(self)), p_mode_);
            }
            pub inline fn setNotificationMode(self: *const T, mode_: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetNotificationMode(@as(*const ITextDocument2Old, @ptrCast(self)), mode_);
            }
            pub inline fn getClientRect(self: *const T, type_: i32, p_left_: ?*i32, p_top_: ?*i32, p_right_: ?*i32, p_bottom_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetClientRect(@as(*const ITextDocument2Old, @ptrCast(self)), type_, p_left_, p_top_, p_right_, p_bottom_);
            }
            pub inline fn getSelection2(self: *const T, pp_sel_: ?*?*ITextSelection) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetSelection2(@as(*const ITextDocument2Old, @ptrCast(self)), pp_sel_);
            }
            pub inline fn getWindow(self: *const T, ph_wnd_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const ITextDocument2Old, @ptrCast(self)), ph_wnd_);
            }
            pub inline fn getFEFlags(self: *const T, p_flags_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetFEFlags(@as(*const ITextDocument2Old, @ptrCast(self)), p_flags_);
            }
            pub inline fn updateWindow(self: *const T) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).UpdateWindow(@as(*const ITextDocument2Old, @ptrCast(self)));
            }
            pub inline fn checkTextLimit(self: *const T, cch_: i32, pcch_: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).CheckTextLimit(@as(*const ITextDocument2Old, @ptrCast(self)), cch_, pcch_);
            }
            pub inline fn imeInProgress(self: *const T, value_: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).IMEInProgress(@as(*const ITextDocument2Old, @ptrCast(self)), value_);
            }
            pub inline fn sysBeep(self: *const T) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SysBeep(@as(*const ITextDocument2Old, @ptrCast(self)));
            }
            pub inline fn update(self: *const T, mode_: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).Update(@as(*const ITextDocument2Old, @ptrCast(self)), mode_);
            }
            pub inline fn notify(self: *const T, notify_: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).Notify(@as(*const ITextDocument2Old, @ptrCast(self)), notify_);
            }
            pub inline fn getDocumentFont(self: *const T, pp_i_text_font_: ?*?*ITextFont) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetDocumentFont(@as(*const ITextDocument2Old, @ptrCast(self)), pp_i_text_font_);
            }
            pub inline fn getDocumentPara(self: *const T, pp_i_text_para_: ?*?*ITextPara) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetDocumentPara(@as(*const ITextDocument2Old, @ptrCast(self)), pp_i_text_para_);
            }
            pub inline fn getCallManager(self: *const T, pp_void_: ?*?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetCallManager(@as(*const ITextDocument2Old, @ptrCast(self)), pp_void_);
            }
            pub inline fn releaseCallManager(self: *const T, p_void_: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).ReleaseCallManager(@as(*const ITextDocument2Old, @ptrCast(self)), p_void_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATA;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2A;
        pub const TEXTRANGE = thismodule.TEXTRANGEA;
        pub const FINDTEXT = thismodule.FINDTEXTA;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXA;
    },
    .wide => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATW;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2W;
        pub const TEXTRANGE = thismodule.TEXTRANGEW;
        pub const FINDTEXT = thismodule.FINDTEXTW;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CHARFORMAT = *opaque {};
        pub const CHARFORMAT2 = *opaque {};
        pub const TEXTRANGE = *opaque {};
        pub const FINDTEXT = *opaque {};
        pub const FINDTEXTEX = *opaque {};
    } else struct {
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (43)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const DVASPECT = @import("../../system/com.zig").DVASPECT;
const DVTARGETDEVICE = @import("../../system/com.zig").DVTARGETDEVICE;
const ENABLE_SCROLL_BAR_ARROWS = @import("../../ui/controls.zig").ENABLE_SCROLL_BAR_ARROWS;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HCURSOR = @import("../../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../../graphics/gdi.zig").HDC;
const HIMC = @import("../../globalization.zig").HIMC;
const HMENU = @import("../../ui/windows_and_messaging.zig").HMENU;
const HPALETTE = @import("../../graphics/gdi.zig").HPALETTE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HRGN = @import("../../graphics/gdi.zig").HRGN;
const HWND = @import("../../foundation.zig").HWND;
const ID2D1RenderTarget = @import("../../graphics/direct2d.zig").ID2D1RenderTarget;
const IDataObject = @import("../../system/com.zig").IDataObject;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IDropTarget = @import("../../system/ole.zig").IDropTarget;
const IOleClientSite = @import("../../system/ole.zig").IOleClientSite;
const IOleInPlaceFrame = @import("../../system/ole.zig").IOleInPlaceFrame;
const IOleInPlaceUIWindow = @import("../../system/ole.zig").IOleInPlaceUIWindow;
const IOleObject = @import("../../system/ole.zig").IOleObject;
const IStorage = @import("../../system/com/structured_storage.zig").IStorage;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const NMHDR = @import("../../ui/controls.zig").NMHDR;
const OIFI = @import("../../system/ole.zig").OIFI;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const RECTL = @import("../../foundation.zig").RECTL;
const SCROLLBAR_CONSTANTS = @import("../../ui/windows_and_messaging.zig").SCROLLBAR_CONSTANTS;
const SHOW_WINDOW_CMD = @import("../../ui/windows_and_messaging.zig").SHOW_WINDOW_CMD;
const SIZE = @import("../../foundation.zig").SIZE;
const TEXT_ALIGN_OPTIONS = @import("../../graphics/gdi.zig").TEXT_ALIGN_OPTIONS;
const VARIANT = @import("../../system/com.zig").VARIANT;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AutoCorrectProc")) {
        _ = AutoCorrectProc;
    }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCEX")) {
        _ = EDITWORDBREAKPROCEX;
    }
    if (@hasDecl(@This(), "EDITSTREAMCALLBACK")) {
        _ = EDITSTREAMCALLBACK;
    }
    if (@hasDecl(@This(), "PCreateTextServices")) {
        _ = PCreateTextServices;
    }
    if (@hasDecl(@This(), "PShutdownTextServices")) {
        _ = PShutdownTextServices;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
