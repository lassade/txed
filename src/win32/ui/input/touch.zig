//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (16)
//--------------------------------------------------------------------------------
pub const GESTURECONFIG_ID = enum(u32) {
    BEGIN = 1,
    END = 2,
    ZOOM = 3,
    PAN = 4,
    ROTATE = 5,
    TWOFINGERTAP = 6,
    PRESSANDTAP = 7,
    // ROLLOVER = 7, this enum value conflicts with PRESSANDTAP
    _,
    pub fn initFlags(o: struct {
        BEGIN: u1 = 0,
        END: u1 = 0,
        ZOOM: u1 = 0,
        PAN: u1 = 0,
        ROTATE: u1 = 0,
        TWOFINGERTAP: u1 = 0,
        PRESSANDTAP: u1 = 0,
    }) GESTURECONFIG_ID {
        return @as(GESTURECONFIG_ID, @enumFromInt((if (o.BEGIN == 1) @intFromEnum(GESTURECONFIG_ID.BEGIN) else 0) | (if (o.END == 1) @intFromEnum(GESTURECONFIG_ID.END) else 0) | (if (o.ZOOM == 1) @intFromEnum(GESTURECONFIG_ID.ZOOM) else 0) | (if (o.PAN == 1) @intFromEnum(GESTURECONFIG_ID.PAN) else 0) | (if (o.ROTATE == 1) @intFromEnum(GESTURECONFIG_ID.ROTATE) else 0) | (if (o.TWOFINGERTAP == 1) @intFromEnum(GESTURECONFIG_ID.TWOFINGERTAP) else 0) | (if (o.PRESSANDTAP == 1) @intFromEnum(GESTURECONFIG_ID.PRESSANDTAP) else 0)));
    }
};
pub const GID_BEGIN = GESTURECONFIG_ID.BEGIN;
pub const GID_END = GESTURECONFIG_ID.END;
pub const GID_ZOOM = GESTURECONFIG_ID.ZOOM;
pub const GID_PAN = GESTURECONFIG_ID.PAN;
pub const GID_ROTATE = GESTURECONFIG_ID.ROTATE;
pub const GID_TWOFINGERTAP = GESTURECONFIG_ID.TWOFINGERTAP;
pub const GID_PRESSANDTAP = GESTURECONFIG_ID.PRESSANDTAP;
pub const GID_ROLLOVER = GESTURECONFIG_ID.PRESSANDTAP;

pub const TOUCHEVENTF_FLAGS = enum(u32) {
    MOVE = 1,
    DOWN = 2,
    UP = 4,
    INRANGE = 8,
    PRIMARY = 16,
    NOCOALESCE = 32,
    PEN = 64,
    PALM = 128,
    _,
    pub fn initFlags(o: struct {
        MOVE: u1 = 0,
        DOWN: u1 = 0,
        UP: u1 = 0,
        INRANGE: u1 = 0,
        PRIMARY: u1 = 0,
        NOCOALESCE: u1 = 0,
        PEN: u1 = 0,
        PALM: u1 = 0,
    }) TOUCHEVENTF_FLAGS {
        return @as(TOUCHEVENTF_FLAGS, @enumFromInt((if (o.MOVE == 1) @intFromEnum(TOUCHEVENTF_FLAGS.MOVE) else 0) | (if (o.DOWN == 1) @intFromEnum(TOUCHEVENTF_FLAGS.DOWN) else 0) | (if (o.UP == 1) @intFromEnum(TOUCHEVENTF_FLAGS.UP) else 0) | (if (o.INRANGE == 1) @intFromEnum(TOUCHEVENTF_FLAGS.INRANGE) else 0) | (if (o.PRIMARY == 1) @intFromEnum(TOUCHEVENTF_FLAGS.PRIMARY) else 0) | (if (o.NOCOALESCE == 1) @intFromEnum(TOUCHEVENTF_FLAGS.NOCOALESCE) else 0) | (if (o.PEN == 1) @intFromEnum(TOUCHEVENTF_FLAGS.PEN) else 0) | (if (o.PALM == 1) @intFromEnum(TOUCHEVENTF_FLAGS.PALM) else 0)));
    }
};
pub const TOUCHEVENTF_MOVE = TOUCHEVENTF_FLAGS.MOVE;
pub const TOUCHEVENTF_DOWN = TOUCHEVENTF_FLAGS.DOWN;
pub const TOUCHEVENTF_UP = TOUCHEVENTF_FLAGS.UP;
pub const TOUCHEVENTF_INRANGE = TOUCHEVENTF_FLAGS.INRANGE;
pub const TOUCHEVENTF_PRIMARY = TOUCHEVENTF_FLAGS.PRIMARY;
pub const TOUCHEVENTF_NOCOALESCE = TOUCHEVENTF_FLAGS.NOCOALESCE;
pub const TOUCHEVENTF_PEN = TOUCHEVENTF_FLAGS.PEN;
pub const TOUCHEVENTF_PALM = TOUCHEVENTF_FLAGS.PALM;

pub const TOUCHINPUTMASKF_MASK = enum(u32) {
    TIMEFROMSYSTEM = 1,
    EXTRAINFO = 2,
    CONTACTAREA = 4,
    _,
    pub fn initFlags(o: struct {
        TIMEFROMSYSTEM: u1 = 0,
        EXTRAINFO: u1 = 0,
        CONTACTAREA: u1 = 0,
    }) TOUCHINPUTMASKF_MASK {
        return @as(TOUCHINPUTMASKF_MASK, @enumFromInt((if (o.TIMEFROMSYSTEM == 1) @intFromEnum(TOUCHINPUTMASKF_MASK.TIMEFROMSYSTEM) else 0) | (if (o.EXTRAINFO == 1) @intFromEnum(TOUCHINPUTMASKF_MASK.EXTRAINFO) else 0) | (if (o.CONTACTAREA == 1) @intFromEnum(TOUCHINPUTMASKF_MASK.CONTACTAREA) else 0)));
    }
};
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM = TOUCHINPUTMASKF_MASK.TIMEFROMSYSTEM;
pub const TOUCHINPUTMASKF_EXTRAINFO = TOUCHINPUTMASKF_MASK.EXTRAINFO;
pub const TOUCHINPUTMASKF_CONTACTAREA = TOUCHINPUTMASKF_MASK.CONTACTAREA;

pub const REGISTER_TOUCH_WINDOW_FLAGS = enum(u32) {
    FINETOUCH = 1,
    WANTPALM = 2,
};
pub const TWF_FINETOUCH = REGISTER_TOUCH_WINDOW_FLAGS.FINETOUCH;
pub const TWF_WANTPALM = REGISTER_TOUCH_WINDOW_FLAGS.WANTPALM;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HGESTUREINFO = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HTOUCHINPUT = *opaque {};

const CLSID_InertiaProcessor_Value = Guid.initString("abb27087-4ce0-4e58-a0cb-e24df96814be");
pub const CLSID_InertiaProcessor = &CLSID_InertiaProcessor_Value;

const CLSID_ManipulationProcessor_Value = Guid.initString("597d4fb0-47fd-4aff-89b9-c6cfae8cf08e");
pub const CLSID_ManipulationProcessor = &CLSID_ManipulationProcessor_Value;

pub const MANIPULATION_PROCESSOR_MANIPULATIONS = enum(i32) {
    NONE = 0,
    TRANSLATE_X = 1,
    TRANSLATE_Y = 2,
    SCALE = 4,
    ROTATE = 8,
    ALL = 15,
};
pub const MANIPULATION_NONE = MANIPULATION_PROCESSOR_MANIPULATIONS.NONE;
pub const MANIPULATION_TRANSLATE_X = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_X;
pub const MANIPULATION_TRANSLATE_Y = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_Y;
pub const MANIPULATION_SCALE = MANIPULATION_PROCESSOR_MANIPULATIONS.SCALE;
pub const MANIPULATION_ROTATE = MANIPULATION_PROCESSOR_MANIPULATIONS.ROTATE;
pub const MANIPULATION_ALL = MANIPULATION_PROCESSOR_MANIPULATIONS.ALL;

// TODO: this type is limited to platform 'windows6.1'
const IID__IManipulationEvents_Value = Guid.initString("4f62c8da-9c53-4b22-93df-927a862bbb03");
pub const IID__IManipulationEvents = &IID__IManipulationEvents_Value;
pub const _IManipulationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ManipulationStarted: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationDelta: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            translation_delta_x: f32,
            translation_delta_y: f32,
            scale_delta: f32,
            expansion_delta: f32,
            rotation_delta: f32,
            cumulative_translation_x: f32,
            cumulative_translation_y: f32,
            cumulative_scale: f32,
            cumulative_expansion: f32,
            cumulative_rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationCompleted: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            cumulative_translation_x: f32,
            cumulative_translation_y: f32,
            cumulative_scale: f32,
            cumulative_expansion: f32,
            cumulative_rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn manipulationStarted(self: *const T, x_: f32, y_: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationStarted(@as(*const _IManipulationEvents, @ptrCast(self)), x_, y_);
            }
            pub inline fn manipulationDelta(self: *const T, x_: f32, y_: f32, translation_delta_x_: f32, translation_delta_y_: f32, scale_delta_: f32, expansion_delta_: f32, rotation_delta_: f32, cumulative_translation_x_: f32, cumulative_translation_y_: f32, cumulative_scale_: f32, cumulative_expansion_: f32, cumulative_rotation_: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationDelta(@as(*const _IManipulationEvents, @ptrCast(self)), x_, y_, translation_delta_x_, translation_delta_y_, scale_delta_, expansion_delta_, rotation_delta_, cumulative_translation_x_, cumulative_translation_y_, cumulative_scale_, cumulative_expansion_, cumulative_rotation_);
            }
            pub inline fn manipulationCompleted(self: *const T, x_: f32, y_: f32, cumulative_translation_x_: f32, cumulative_translation_y_: f32, cumulative_scale_: f32, cumulative_expansion_: f32, cumulative_rotation_: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationCompleted(@as(*const _IManipulationEvents, @ptrCast(self)), x_, y_, cumulative_translation_x_, cumulative_translation_y_, cumulative_scale_, cumulative_expansion_, cumulative_rotation_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInertiaProcessor_Value = Guid.initString("18b00c6d-c5ee-41b1-90a9-9d4a929095ad");
pub const IID_IInertiaProcessor = &IID_IInertiaProcessor_Value;
pub const IInertiaProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialAngularVelocity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialAngularVelocity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialExpansionVelocity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialExpansionVelocity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            radius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryRight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryRight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryBottom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryBottom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginRight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginRight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginBottom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginBottom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDisplacement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            displacement: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDisplacement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            displacement: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredRotation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            rotation: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredRotation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            expansion: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            expansion: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredAngularDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredAngularDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansionDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansionDeceleration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialTimestamp: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            timestamp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialTimestamp: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Process: *const fn (
            self: *const IInertiaProcessor,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessTime: *const fn (
            self: *const IInertiaProcessor,
            timestamp: u32,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Complete: *const fn (
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteTime: *const fn (
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInitialOriginX(self: *const T, x_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialOriginX(@as(*const IInertiaProcessor, @ptrCast(self)), x_);
            }
            pub inline fn putInitialOriginX(self: *const T, x_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialOriginX(@as(*const IInertiaProcessor, @ptrCast(self)), x_);
            }
            pub inline fn getInitialOriginY(self: *const T, y_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialOriginY(@as(*const IInertiaProcessor, @ptrCast(self)), y_);
            }
            pub inline fn putInitialOriginY(self: *const T, y_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialOriginY(@as(*const IInertiaProcessor, @ptrCast(self)), y_);
            }
            pub inline fn getInitialVelocityX(self: *const T, x_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialVelocityX(@as(*const IInertiaProcessor, @ptrCast(self)), x_);
            }
            pub inline fn putInitialVelocityX(self: *const T, x_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialVelocityX(@as(*const IInertiaProcessor, @ptrCast(self)), x_);
            }
            pub inline fn getInitialVelocityY(self: *const T, y_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialVelocityY(@as(*const IInertiaProcessor, @ptrCast(self)), y_);
            }
            pub inline fn putInitialVelocityY(self: *const T, y_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialVelocityY(@as(*const IInertiaProcessor, @ptrCast(self)), y_);
            }
            pub inline fn getInitialAngularVelocity(self: *const T, velocity_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialAngularVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity_);
            }
            pub inline fn putInitialAngularVelocity(self: *const T, velocity_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialAngularVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity_);
            }
            pub inline fn getInitialExpansionVelocity(self: *const T, velocity_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialExpansionVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity_);
            }
            pub inline fn putInitialExpansionVelocity(self: *const T, velocity_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialExpansionVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity_);
            }
            pub inline fn getInitialRadius(self: *const T, radius_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialRadius(@as(*const IInertiaProcessor, @ptrCast(self)), radius_);
            }
            pub inline fn putInitialRadius(self: *const T, radius_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialRadius(@as(*const IInertiaProcessor, @ptrCast(self)), radius_);
            }
            pub inline fn getBoundaryLeft(self: *const T, left_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left_);
            }
            pub inline fn putBoundaryLeft(self: *const T, left_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left_);
            }
            pub inline fn getBoundaryTop(self: *const T, top_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryTop(@as(*const IInertiaProcessor, @ptrCast(self)), top_);
            }
            pub inline fn putBoundaryTop(self: *const T, top_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryTop(@as(*const IInertiaProcessor, @ptrCast(self)), top_);
            }
            pub inline fn getBoundaryRight(self: *const T, right_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryRight(@as(*const IInertiaProcessor, @ptrCast(self)), right_);
            }
            pub inline fn putBoundaryRight(self: *const T, right_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryRight(@as(*const IInertiaProcessor, @ptrCast(self)), right_);
            }
            pub inline fn getBoundaryBottom(self: *const T, bottom_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom_);
            }
            pub inline fn putBoundaryBottom(self: *const T, bottom_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom_);
            }
            pub inline fn getElasticMarginLeft(self: *const T, left_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left_);
            }
            pub inline fn putElasticMarginLeft(self: *const T, left_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left_);
            }
            pub inline fn getElasticMarginTop(self: *const T, top_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginTop(@as(*const IInertiaProcessor, @ptrCast(self)), top_);
            }
            pub inline fn putElasticMarginTop(self: *const T, top_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginTop(@as(*const IInertiaProcessor, @ptrCast(self)), top_);
            }
            pub inline fn getElasticMarginRight(self: *const T, right_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginRight(@as(*const IInertiaProcessor, @ptrCast(self)), right_);
            }
            pub inline fn putElasticMarginRight(self: *const T, right_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginRight(@as(*const IInertiaProcessor, @ptrCast(self)), right_);
            }
            pub inline fn getElasticMarginBottom(self: *const T, bottom_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom_);
            }
            pub inline fn putElasticMarginBottom(self: *const T, bottom_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom_);
            }
            pub inline fn getDesiredDisplacement(self: *const T, displacement_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredDisplacement(@as(*const IInertiaProcessor, @ptrCast(self)), displacement_);
            }
            pub inline fn putDesiredDisplacement(self: *const T, displacement_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredDisplacement(@as(*const IInertiaProcessor, @ptrCast(self)), displacement_);
            }
            pub inline fn getDesiredRotation(self: *const T, rotation_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredRotation(@as(*const IInertiaProcessor, @ptrCast(self)), rotation_);
            }
            pub inline fn putDesiredRotation(self: *const T, rotation_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredRotation(@as(*const IInertiaProcessor, @ptrCast(self)), rotation_);
            }
            pub inline fn getDesiredExpansion(self: *const T, expansion_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredExpansion(@as(*const IInertiaProcessor, @ptrCast(self)), expansion_);
            }
            pub inline fn putDesiredExpansion(self: *const T, expansion_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredExpansion(@as(*const IInertiaProcessor, @ptrCast(self)), expansion_);
            }
            pub inline fn getDesiredDeceleration(self: *const T, deceleration_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn putDesiredDeceleration(self: *const T, deceleration_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn getDesiredAngularDeceleration(self: *const T, deceleration_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredAngularDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn putDesiredAngularDeceleration(self: *const T, deceleration_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredAngularDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn getDesiredExpansionDeceleration(self: *const T, deceleration_: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredExpansionDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn putDesiredExpansionDeceleration(self: *const T, deceleration_: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredExpansionDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration_);
            }
            pub inline fn getInitialTimestamp(self: *const T, timestamp_: ?*u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialTimestamp(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp_);
            }
            pub inline fn putInitialTimestamp(self: *const T, timestamp_: u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialTimestamp(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Reset(@as(*const IInertiaProcessor, @ptrCast(self)));
            }
            pub inline fn process(self: *const T, completed_: ?*BOOL) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Process(@as(*const IInertiaProcessor, @ptrCast(self)), completed_);
            }
            pub inline fn processTime(self: *const T, timestamp_: u32, completed_: ?*BOOL) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).ProcessTime(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp_, completed_);
            }
            pub inline fn complete(self: *const T) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Complete(@as(*const IInertiaProcessor, @ptrCast(self)));
            }
            pub inline fn completeTime(self: *const T, timestamp_: u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).CompleteTime(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IManipulationProcessor_Value = Guid.initString("a22ac519-8300-48a0-bef4-f1be8737dba4");
pub const IID_IManipulationProcessor = &IID_IManipulationProcessor_Value;
pub const IManipulationProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedManipulations: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            manipulations: ?*MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportedManipulations: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_point_x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointX: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_point_x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_point_y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointY: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_point_y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_radius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            pivot_radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteManipulation: *const fn (
            self: *const IManipulationProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDown: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMove: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUp: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDownWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMoveWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUpWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulator_id: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityX: *const fn (
            self: *const IManipulationProcessor,
            velocity_x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityY: *const fn (
            self: *const IManipulationProcessor,
            velocity_y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpansionVelocity: *const fn (
            self: *const IManipulationProcessor,
            expansion_velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAngularVelocity: *const fn (
            self: *const IManipulationProcessor,
            angular_velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinimumScaleRotateRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            min_radius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinimumScaleRotateRadius: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IManipulationProcessor,
            min_radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupportedManipulations(self: *const T, manipulations_: ?*MANIPULATION_PROCESSOR_MANIPULATIONS) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_SupportedManipulations(@as(*const IManipulationProcessor, @ptrCast(self)), manipulations_);
            }
            pub inline fn putSupportedManipulations(self: *const T, manipulations_: MANIPULATION_PROCESSOR_MANIPULATIONS) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_SupportedManipulations(@as(*const IManipulationProcessor, @ptrCast(self)), manipulations_);
            }
            pub inline fn getPivotPointX(self: *const T, pivot_point_x_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotPointX(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_point_x_);
            }
            pub inline fn putPivotPointX(self: *const T, pivot_point_x_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotPointX(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_point_x_);
            }
            pub inline fn getPivotPointY(self: *const T, pivot_point_y_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotPointY(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_point_y_);
            }
            pub inline fn putPivotPointY(self: *const T, pivot_point_y_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotPointY(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_point_y_);
            }
            pub inline fn getPivotRadius(self: *const T, pivot_radius_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotRadius(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_radius_);
            }
            pub inline fn putPivotRadius(self: *const T, pivot_radius_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotRadius(@as(*const IManipulationProcessor, @ptrCast(self)), pivot_radius_);
            }
            pub inline fn completeManipulation(self: *const T) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).CompleteManipulation(@as(*const IManipulationProcessor, @ptrCast(self)));
            }
            pub inline fn processDown(self: *const T, manipulator_id_: u32, x_: f32, y_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessDown(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_);
            }
            pub inline fn processMove(self: *const T, manipulator_id_: u32, x_: f32, y_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessMove(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_);
            }
            pub inline fn processUp(self: *const T, manipulator_id_: u32, x_: f32, y_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessUp(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_);
            }
            pub inline fn processDownWithTime(self: *const T, manipulator_id_: u32, x_: f32, y_: f32, timestamp_: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessDownWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_, timestamp_);
            }
            pub inline fn processMoveWithTime(self: *const T, manipulator_id_: u32, x_: f32, y_: f32, timestamp_: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessMoveWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_, timestamp_);
            }
            pub inline fn processUpWithTime(self: *const T, manipulator_id_: u32, x_: f32, y_: f32, timestamp_: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessUpWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulator_id_, x_, y_, timestamp_);
            }
            pub inline fn getVelocityX(self: *const T, velocity_x_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetVelocityX(@as(*const IManipulationProcessor, @ptrCast(self)), velocity_x_);
            }
            pub inline fn getVelocityY(self: *const T, velocity_y_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetVelocityY(@as(*const IManipulationProcessor, @ptrCast(self)), velocity_y_);
            }
            pub inline fn getExpansionVelocity(self: *const T, expansion_velocity_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetExpansionVelocity(@as(*const IManipulationProcessor, @ptrCast(self)), expansion_velocity_);
            }
            pub inline fn getAngularVelocity(self: *const T, angular_velocity_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetAngularVelocity(@as(*const IManipulationProcessor, @ptrCast(self)), angular_velocity_);
            }
            pub inline fn getMinimumScaleRotateRadius(self: *const T, min_radius_: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_MinimumScaleRotateRadius(@as(*const IManipulationProcessor, @ptrCast(self)), min_radius_);
            }
            pub inline fn putMinimumScaleRotateRadius(self: *const T, min_radius_: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_MinimumScaleRotateRadius(@as(*const IManipulationProcessor, @ptrCast(self)), min_radius_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TOUCHINPUT = extern struct {
    x: i32,
    y: i32,
    hSource: ?HANDLE,
    dwID: u32,
    dwFlags: TOUCHEVENTF_FLAGS,
    dwMask: TOUCHINPUTMASKF_MASK,
    dwTime: u32,
    dwExtraInfo: usize,
    cxContact: u32,
    cyContact: u32,
};

pub const GESTUREINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwID: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
    dwSequenceID: u32,
    ullArguments: u64,
    cbExtraArgs: u32,
};

pub const GESTURENOTIFYSTRUCT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
};

pub const GESTURECONFIG = extern struct {
    dwID: GESTURECONFIG_ID,
    dwWant: u32,
    dwBlock: u32,
};

//--------------------------------------------------------------------------------
// Section: Functions (10)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetTouchInputInfo(
    h_touch_input: ?HTOUCHINPUT,
    c_inputs: u32,
    p_inputs: [*]TOUCHINPUT,
    cb_size: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn CloseTouchInputHandle(
    h_touch_input: ?HTOUCHINPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn RegisterTouchWindow(
    hwnd: ?HWND,
    ul_flags: REGISTER_TOUCH_WINDOW_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn UnregisterTouchWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn IsTouchWindow(
    hwnd: ?HWND,
    pul_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureInfo(
    h_gesture_info: ?HGESTUREINFO,
    p_gesture_info: ?*GESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureExtraArgs(
    h_gesture_info: ?HGESTUREINFO,
    cb_extra_args: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_extra_args: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn CloseGestureInfoHandle(
    h_gesture_info: ?HGESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn SetGestureConfig(
    hwnd: ?HWND,
    dw_reserved: u32,
    c_i_ds: u32,
    p_gesture_config: [*]GESTURECONFIG,
    cb_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureConfig(
    hwnd: ?HWND,
    dw_reserved: u32,
    dw_flags: u32,
    pc_i_ds: ?*u32,
    p_gesture_config: [*]GESTURECONFIG,
    cb_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IUnknown = @import("../../system/com.zig").IUnknown;
const POINTS = @import("../../foundation.zig").POINTS;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
