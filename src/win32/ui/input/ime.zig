//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (654)
//--------------------------------------------------------------------------------
pub const szImeJapan = "MSIME.Japan";
pub const szImeKorea = "MSIME.Korea";
pub const szImeChina = "MSIME.China";
pub const szImeTaiwan = "MSIME.Taiwan";
pub const CLSID_VERSION_DEPENDENT_MSIME_JAPANESE = Guid.initString("6a91029e-aa49-471b-aee7-7d332785660d");
pub const IFEC_S_ALREADY_DEFAULT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291840));
pub const FELANG_REQ_CONV = @as(u32, 65536);
pub const FELANG_REQ_RECONV = @as(u32, 131072);
pub const FELANG_REQ_REV = @as(u32, 196608);
pub const FELANG_CMODE_MONORUBY = @as(u32, 2);
pub const FELANG_CMODE_NOPRUNING = @as(u32, 4);
pub const FELANG_CMODE_KATAKANAOUT = @as(u32, 8);
pub const FELANG_CMODE_HIRAGANAOUT = @as(u32, 0);
pub const FELANG_CMODE_HALFWIDTHOUT = @as(u32, 16);
pub const FELANG_CMODE_FULLWIDTHOUT = @as(u32, 32);
pub const FELANG_CMODE_BOPOMOFO = @as(u32, 64);
pub const FELANG_CMODE_HANGUL = @as(u32, 128);
pub const FELANG_CMODE_PINYIN = @as(u32, 256);
pub const FELANG_CMODE_PRECONV = @as(u32, 512);
pub const FELANG_CMODE_RADICAL = @as(u32, 1024);
pub const FELANG_CMODE_UNKNOWNREADING = @as(u32, 2048);
pub const FELANG_CMODE_MERGECAND = @as(u32, 4096);
pub const FELANG_CMODE_ROMAN = @as(u32, 8192);
pub const FELANG_CMODE_BESTFIRST = @as(u32, 16384);
pub const FELANG_CMODE_USENOREVWORDS = @as(u32, 32768);
pub const FELANG_CMODE_NONE = @as(u32, 16777216);
pub const FELANG_CMODE_PLAURALCLAUSE = @as(u32, 33554432);
pub const FELANG_CMODE_SINGLECONVERT = @as(u32, 67108864);
pub const FELANG_CMODE_AUTOMATIC = @as(u32, 134217728);
pub const FELANG_CMODE_PHRASEPREDICT = @as(u32, 268435456);
pub const FELANG_CMODE_CONVERSATION = @as(u32, 536870912);
pub const FELANG_CMODE_NAME = @as(u32, 268435456);
pub const FELANG_CMODE_NOINVISIBLECHAR = @as(u32, 1073741824);
pub const E_NOCAND = @as(u32, 48);
pub const E_NOTENOUGH_BUFFER = @as(u32, 49);
pub const E_NOTENOUGH_WDD = @as(u32, 50);
pub const E_LARGEINPUT = @as(u32, 51);
pub const FELANG_CLMN_WBREAK = @as(u32, 1);
pub const FELANG_CLMN_NOWBREAK = @as(u32, 2);
pub const FELANG_CLMN_PBREAK = @as(u32, 4);
pub const FELANG_CLMN_NOPBREAK = @as(u32, 8);
pub const FELANG_CLMN_FIXR = @as(u32, 16);
pub const FELANG_CLMN_FIXD = @as(u32, 32);
pub const FELANG_INVALD_PO = @as(u32, 65535);
pub const IFED_POS_NONE = @as(u32, 0);
pub const IFED_POS_NOUN = @as(u32, 1);
pub const IFED_POS_VERB = @as(u32, 2);
pub const IFED_POS_ADJECTIVE = @as(u32, 4);
pub const IFED_POS_ADJECTIVE_VERB = @as(u32, 8);
pub const IFED_POS_ADVERB = @as(u32, 16);
pub const IFED_POS_ADNOUN = @as(u32, 32);
pub const IFED_POS_CONJUNCTION = @as(u32, 64);
pub const IFED_POS_INTERJECTION = @as(u32, 128);
pub const IFED_POS_INDEPENDENT = @as(u32, 255);
pub const IFED_POS_INFLECTIONALSUFFIX = @as(u32, 256);
pub const IFED_POS_PREFIX = @as(u32, 512);
pub const IFED_POS_SUFFIX = @as(u32, 1024);
pub const IFED_POS_AFFIX = @as(u32, 1536);
pub const IFED_POS_TANKANJI = @as(u32, 2048);
pub const IFED_POS_IDIOMS = @as(u32, 4096);
pub const IFED_POS_SYMBOLS = @as(u32, 8192);
pub const IFED_POS_PARTICLE = @as(u32, 16384);
pub const IFED_POS_AUXILIARY_VERB = @as(u32, 32768);
pub const IFED_POS_SUB_VERB = @as(u32, 65536);
pub const IFED_POS_DEPENDENT = @as(u32, 114688);
pub const IFED_POS_ALL = @as(u32, 131071);
pub const IFED_SELECT_NONE = @as(u32, 0);
pub const IFED_SELECT_READING = @as(u32, 1);
pub const IFED_SELECT_DISPLAY = @as(u32, 2);
pub const IFED_SELECT_POS = @as(u32, 4);
pub const IFED_SELECT_COMMENT = @as(u32, 8);
pub const IFED_SELECT_ALL = @as(u32, 15);
pub const IFED_REG_NONE = @as(u32, 0);
pub const IFED_REG_USER = @as(u32, 1);
pub const IFED_REG_AUTO = @as(u32, 2);
pub const IFED_REG_GRAMMAR = @as(u32, 4);
pub const IFED_REG_ALL = @as(u32, 7);
pub const IFED_TYPE_NONE = @as(u32, 0);
pub const IFED_TYPE_GENERAL = @as(u32, 1);
pub const IFED_TYPE_NAMEPLACE = @as(u32, 2);
pub const IFED_TYPE_SPEECH = @as(u32, 4);
pub const IFED_TYPE_REVERSE = @as(u32, 8);
pub const IFED_TYPE_ENGLISH = @as(u32, 16);
pub const IFED_TYPE_ALL = @as(u32, 31);
pub const IFED_S_MORE_ENTRIES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291328));
pub const IFED_S_EMPTY_DICTIONARY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291329));
pub const IFED_S_WORD_EXISTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291330));
pub const IFED_S_COMMENT_CHANGED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291331));
pub const IFED_E_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192064));
pub const IFED_E_INVALID_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192063));
pub const IFED_E_OPEN_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192062));
pub const IFED_E_WRITE_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192061));
pub const IFED_E_NO_ENTRY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192060));
pub const IFED_E_REGISTER_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192059));
pub const IFED_E_NOT_USER_DIC = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192058));
pub const IFED_E_NOT_SUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192057));
pub const IFED_E_USER_COMMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192056));
pub const IFED_E_REGISTER_ILLEGAL_POS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192055));
pub const IFED_E_REGISTER_IMPROPER_WORD = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192054));
pub const IFED_E_REGISTER_DISCONNECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192053));
pub const cbCommentMax = @as(u32, 256);
pub const wchPrivate1 = @as(u32, 57344);
pub const POS_UNDEFINED = @as(u32, 0);
pub const JPOS_UNDEFINED = @as(u32, 0);
pub const JPOS_MEISHI_FUTSU = @as(u32, 100);
pub const JPOS_MEISHI_SAHEN = @as(u32, 101);
pub const JPOS_MEISHI_ZAHEN = @as(u32, 102);
pub const JPOS_MEISHI_KEIYOUDOUSHI = @as(u32, 103);
pub const JPOS_HUKUSIMEISHI = @as(u32, 104);
pub const JPOS_MEISA_KEIDOU = @as(u32, 105);
pub const JPOS_JINMEI = @as(u32, 106);
pub const JPOS_JINMEI_SEI = @as(u32, 107);
pub const JPOS_JINMEI_MEI = @as(u32, 108);
pub const JPOS_CHIMEI = @as(u32, 109);
pub const JPOS_CHIMEI_KUNI = @as(u32, 110);
pub const JPOS_CHIMEI_KEN = @as(u32, 111);
pub const JPOS_CHIMEI_GUN = @as(u32, 112);
pub const JPOS_CHIMEI_KU = @as(u32, 113);
pub const JPOS_CHIMEI_SHI = @as(u32, 114);
pub const JPOS_CHIMEI_MACHI = @as(u32, 115);
pub const JPOS_CHIMEI_MURA = @as(u32, 116);
pub const JPOS_CHIMEI_EKI = @as(u32, 117);
pub const JPOS_SONOTA = @as(u32, 118);
pub const JPOS_SHAMEI = @as(u32, 119);
pub const JPOS_SOSHIKI = @as(u32, 120);
pub const JPOS_KENCHIKU = @as(u32, 121);
pub const JPOS_BUPPIN = @as(u32, 122);
pub const JPOS_DAIMEISHI = @as(u32, 123);
pub const JPOS_DAIMEISHI_NINSHOU = @as(u32, 124);
pub const JPOS_DAIMEISHI_SHIJI = @as(u32, 125);
pub const JPOS_KAZU = @as(u32, 126);
pub const JPOS_KAZU_SURYOU = @as(u32, 127);
pub const JPOS_KAZU_SUSHI = @as(u32, 128);
pub const JPOS_5DAN_AWA = @as(u32, 200);
pub const JPOS_5DAN_KA = @as(u32, 201);
pub const JPOS_5DAN_GA = @as(u32, 202);
pub const JPOS_5DAN_SA = @as(u32, 203);
pub const JPOS_5DAN_TA = @as(u32, 204);
pub const JPOS_5DAN_NA = @as(u32, 205);
pub const JPOS_5DAN_BA = @as(u32, 206);
pub const JPOS_5DAN_MA = @as(u32, 207);
pub const JPOS_5DAN_RA = @as(u32, 208);
pub const JPOS_5DAN_AWAUON = @as(u32, 209);
pub const JPOS_5DAN_KASOKUON = @as(u32, 210);
pub const JPOS_5DAN_RAHEN = @as(u32, 211);
pub const JPOS_4DAN_HA = @as(u32, 212);
pub const JPOS_1DAN = @as(u32, 213);
pub const JPOS_TOKUSHU_KAHEN = @as(u32, 214);
pub const JPOS_TOKUSHU_SAHENSURU = @as(u32, 215);
pub const JPOS_TOKUSHU_SAHEN = @as(u32, 216);
pub const JPOS_TOKUSHU_ZAHEN = @as(u32, 217);
pub const JPOS_TOKUSHU_NAHEN = @as(u32, 218);
pub const JPOS_KURU_KI = @as(u32, 219);
pub const JPOS_KURU_KITA = @as(u32, 220);
pub const JPOS_KURU_KITARA = @as(u32, 221);
pub const JPOS_KURU_KITARI = @as(u32, 222);
pub const JPOS_KURU_KITAROU = @as(u32, 223);
pub const JPOS_KURU_KITE = @as(u32, 224);
pub const JPOS_KURU_KUREBA = @as(u32, 225);
pub const JPOS_KURU_KO = @as(u32, 226);
pub const JPOS_KURU_KOI = @as(u32, 227);
pub const JPOS_KURU_KOYOU = @as(u32, 228);
pub const JPOS_SURU_SA = @as(u32, 229);
pub const JPOS_SURU_SI = @as(u32, 230);
pub const JPOS_SURU_SITA = @as(u32, 231);
pub const JPOS_SURU_SITARA = @as(u32, 232);
pub const JPOS_SURU_SIATRI = @as(u32, 233);
pub const JPOS_SURU_SITAROU = @as(u32, 234);
pub const JPOS_SURU_SITE = @as(u32, 235);
pub const JPOS_SURU_SIYOU = @as(u32, 236);
pub const JPOS_SURU_SUREBA = @as(u32, 237);
pub const JPOS_SURU_SE = @as(u32, 238);
pub const JPOS_SURU_SEYO = @as(u32, 239);
pub const JPOS_KEIYOU = @as(u32, 300);
pub const JPOS_KEIYOU_GARU = @as(u32, 301);
pub const JPOS_KEIYOU_GE = @as(u32, 302);
pub const JPOS_KEIYOU_ME = @as(u32, 303);
pub const JPOS_KEIYOU_YUU = @as(u32, 304);
pub const JPOS_KEIYOU_U = @as(u32, 305);
pub const JPOS_KEIDOU = @as(u32, 400);
pub const JPOS_KEIDOU_NO = @as(u32, 401);
pub const JPOS_KEIDOU_TARU = @as(u32, 402);
pub const JPOS_KEIDOU_GARU = @as(u32, 403);
pub const JPOS_FUKUSHI = @as(u32, 500);
pub const JPOS_FUKUSHI_SAHEN = @as(u32, 501);
pub const JPOS_FUKUSHI_NI = @as(u32, 502);
pub const JPOS_FUKUSHI_NANO = @as(u32, 503);
pub const JPOS_FUKUSHI_DA = @as(u32, 504);
pub const JPOS_FUKUSHI_TO = @as(u32, 505);
pub const JPOS_FUKUSHI_TOSURU = @as(u32, 506);
pub const JPOS_RENTAISHI = @as(u32, 600);
pub const JPOS_RENTAISHI_SHIJI = @as(u32, 601);
pub const JPOS_SETSUZOKUSHI = @as(u32, 650);
pub const JPOS_KANDOUSHI = @as(u32, 670);
pub const JPOS_SETTOU = @as(u32, 700);
pub const JPOS_SETTOU_KAKU = @as(u32, 701);
pub const JPOS_SETTOU_SAI = @as(u32, 702);
pub const JPOS_SETTOU_FUKU = @as(u32, 703);
pub const JPOS_SETTOU_MI = @as(u32, 704);
pub const JPOS_SETTOU_DAISHOU = @as(u32, 705);
pub const JPOS_SETTOU_KOUTEI = @as(u32, 706);
pub const JPOS_SETTOU_CHOUTAN = @as(u32, 707);
pub const JPOS_SETTOU_SHINKYU = @as(u32, 708);
pub const JPOS_SETTOU_JINMEI = @as(u32, 709);
pub const JPOS_SETTOU_CHIMEI = @as(u32, 710);
pub const JPOS_SETTOU_SONOTA = @as(u32, 711);
pub const JPOS_SETTOU_JOSUSHI = @as(u32, 712);
pub const JPOS_SETTOU_TEINEI_O = @as(u32, 713);
pub const JPOS_SETTOU_TEINEI_GO = @as(u32, 714);
pub const JPOS_SETTOU_TEINEI_ON = @as(u32, 715);
pub const JPOS_SETSUBI = @as(u32, 800);
pub const JPOS_SETSUBI_TEKI = @as(u32, 801);
pub const JPOS_SETSUBI_SEI = @as(u32, 802);
pub const JPOS_SETSUBI_KA = @as(u32, 803);
pub const JPOS_SETSUBI_CHU = @as(u32, 804);
pub const JPOS_SETSUBI_FU = @as(u32, 805);
pub const JPOS_SETSUBI_RYU = @as(u32, 806);
pub const JPOS_SETSUBI_YOU = @as(u32, 807);
pub const JPOS_SETSUBI_KATA = @as(u32, 808);
pub const JPOS_SETSUBI_MEISHIRENDAKU = @as(u32, 809);
pub const JPOS_SETSUBI_JINMEI = @as(u32, 810);
pub const JPOS_SETSUBI_CHIMEI = @as(u32, 811);
pub const JPOS_SETSUBI_KUNI = @as(u32, 812);
pub const JPOS_SETSUBI_KEN = @as(u32, 813);
pub const JPOS_SETSUBI_GUN = @as(u32, 814);
pub const JPOS_SETSUBI_KU = @as(u32, 815);
pub const JPOS_SETSUBI_SHI = @as(u32, 816);
pub const JPOS_SETSUBI_MACHI = @as(u32, 817);
pub const JPOS_SETSUBI_CHOU = @as(u32, 818);
pub const JPOS_SETSUBI_MURA = @as(u32, 819);
pub const JPOS_SETSUBI_SON = @as(u32, 820);
pub const JPOS_SETSUBI_EKI = @as(u32, 821);
pub const JPOS_SETSUBI_SONOTA = @as(u32, 822);
pub const JPOS_SETSUBI_SHAMEI = @as(u32, 823);
pub const JPOS_SETSUBI_SOSHIKI = @as(u32, 824);
pub const JPOS_SETSUBI_KENCHIKU = @as(u32, 825);
pub const JPOS_RENYOU_SETSUBI = @as(u32, 826);
pub const JPOS_SETSUBI_JOSUSHI = @as(u32, 827);
pub const JPOS_SETSUBI_JOSUSHIPLUS = @as(u32, 828);
pub const JPOS_SETSUBI_JIKAN = @as(u32, 829);
pub const JPOS_SETSUBI_JIKANPLUS = @as(u32, 830);
pub const JPOS_SETSUBI_TEINEI = @as(u32, 831);
pub const JPOS_SETSUBI_SAN = @as(u32, 832);
pub const JPOS_SETSUBI_KUN = @as(u32, 833);
pub const JPOS_SETSUBI_SAMA = @as(u32, 834);
pub const JPOS_SETSUBI_DONO = @as(u32, 835);
pub const JPOS_SETSUBI_FUKUSU = @as(u32, 836);
pub const JPOS_SETSUBI_TACHI = @as(u32, 837);
pub const JPOS_SETSUBI_RA = @as(u32, 838);
pub const JPOS_TANKANJI = @as(u32, 900);
pub const JPOS_TANKANJI_KAO = @as(u32, 901);
pub const JPOS_KANYOUKU = @as(u32, 902);
pub const JPOS_DOKURITSUGO = @as(u32, 903);
pub const JPOS_FUTEIGO = @as(u32, 904);
pub const JPOS_KIGOU = @as(u32, 905);
pub const JPOS_EIJI = @as(u32, 906);
pub const JPOS_KUTEN = @as(u32, 907);
pub const JPOS_TOUTEN = @as(u32, 908);
pub const JPOS_KANJI = @as(u32, 909);
pub const JPOS_OPENBRACE = @as(u32, 910);
pub const JPOS_CLOSEBRACE = @as(u32, 911);
pub const JPOS_YOKUSEI = @as(u32, 912);
pub const JPOS_TANSHUKU = @as(u32, 913);
pub const VERSION_ID_JAPANESE = @as(u32, 16777216);
pub const VERSION_ID_KOREAN = @as(u32, 33554432);
pub const VERSION_ID_CHINESE_TRADITIONAL = @as(u32, 67108864);
pub const VERSION_ID_CHINESE_SIMPLIFIED = @as(u32, 134217728);
pub const RWM_SERVICE = "MSIMEService";
pub const FID_MSIME_VERSION = @as(u32, 0);
pub const RWM_UIREADY = "MSIMEUIReady";
pub const RWM_MOUSE = "MSIMEMouseOperation";
pub const VERSION_MOUSE_OPERATION = @as(u32, 1);
pub const IMEMOUSERET_NOTHANDLED = @as(i32, -1);
pub const IMEMOUSE_VERSION = @as(u32, 255);
pub const IMEMOUSE_NONE = @as(u32, 0);
pub const IMEMOUSE_LDOWN = @as(u32, 1);
pub const IMEMOUSE_RDOWN = @as(u32, 2);
pub const IMEMOUSE_MDOWN = @as(u32, 4);
pub const IMEMOUSE_WUP = @as(u32, 16);
pub const IMEMOUSE_WDOWN = @as(u32, 32);
pub const RWM_RECONVERT = "MSIMEReconvert";
pub const FID_RECONVERT_VERSION = @as(u32, 268435456);
pub const VERSION_RECONVERSION = @as(u32, 1);
pub const RWM_RECONVERTREQUEST = "MSIMEReconvertRequest";
pub const VERSION_DOCUMENTFEED = @as(u32, 1);
pub const RWM_DOCUMENTFEED = "MSIMEDocumentFeed";
pub const VERSION_QUERYPOSITION = @as(u32, 1);
pub const RWM_QUERYPOSITION = "MSIMEQueryPosition";
pub const RWM_MODEBIAS = "MSIMEModeBias";
pub const VERSION_MODEBIAS = @as(u32, 1);
pub const MODEBIAS_GETVERSION = @as(u32, 0);
pub const MODEBIAS_SETVALUE = @as(u32, 1);
pub const MODEBIAS_GETVALUE = @as(u32, 2);
pub const MODEBIASMODE_DEFAULT = @as(u32, 0);
pub const MODEBIASMODE_FILENAME = @as(u32, 1);
pub const MODEBIASMODE_READING = @as(u32, 2);
pub const MODEBIASMODE_DIGIT = @as(u32, 4);
pub const RWM_SHOWIMEPAD = "MSIMEShowImePad";
pub const SHOWIMEPAD_DEFAULT = @as(u32, 0);
pub const SHOWIMEPAD_CATEGORY = @as(u32, 1);
pub const SHOWIMEPAD_GUID = @as(u32, 2);
pub const RWM_KEYMAP = "MSIMEKeyMap";
pub const RWM_CHGKEYMAP = "MSIMEChangeKeyMap";
pub const RWM_NTFYKEYMAP = "MSIMENotifyKeyMap";
pub const FID_MSIME_KMS_VERSION = @as(u32, 1);
pub const FID_MSIME_KMS_INIT = @as(u32, 2);
pub const FID_MSIME_KMS_TERM = @as(u32, 3);
pub const FID_MSIME_KMS_DEL_KEYLIST = @as(u32, 4);
pub const FID_MSIME_KMS_NOTIFY = @as(u32, 5);
pub const FID_MSIME_KMS_GETMAP = @as(u32, 6);
pub const FID_MSIME_KMS_INVOKE = @as(u32, 7);
pub const FID_MSIME_KMS_SETMAP = @as(u32, 8);
pub const FID_MSIME_KMS_FUNCDESC = @as(u32, 9);
pub const FID_MSIME_KMS_GETMAPSEAMLESS = @as(u32, 10);
pub const FID_MSIME_KMS_GETMAPFAST = @as(u32, 11);
pub const IMEKMS_NOCOMPOSITION = @as(u32, 0);
pub const IMEKMS_COMPOSITION = @as(u32, 1);
pub const IMEKMS_SELECTION = @as(u32, 2);
pub const IMEKMS_IMEOFF = @as(u32, 3);
pub const IMEKMS_2NDLEVEL = @as(u32, 4);
pub const IMEKMS_INPTGL = @as(u32, 5);
pub const IMEKMS_CANDIDATE = @as(u32, 6);
pub const IMEKMS_TYPECAND = @as(u32, 7);
pub const RWM_RECONVERTOPTIONS = "MSIMEReconvertOptions";
pub const RECONVOPT_NONE = @as(u32, 0);
pub const RECONVOPT_USECANCELNOTIFY = @as(u32, 1);
pub const GCSEX_CANCELRECONVERT = @as(u32, 268435456);
pub const STYLE_DESCRIPTION_SIZE = @as(u32, 32);
pub const IMEMENUITEM_STRING_SIZE = @as(u32, 80);
pub const IMC_GETCANDIDATEPOS = @as(u32, 7);
pub const IMC_SETCANDIDATEPOS = @as(u32, 8);
pub const IMC_GETCOMPOSITIONFONT = @as(u32, 9);
pub const IMC_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMC_GETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMC_SETCOMPOSITIONWINDOW = @as(u32, 12);
pub const IMC_GETSTATUSWINDOWPOS = @as(u32, 15);
pub const IMC_SETSTATUSWINDOWPOS = @as(u32, 16);
pub const IMC_CLOSESTATUSWINDOW = @as(u32, 33);
pub const IMC_OPENSTATUSWINDOW = @as(u32, 34);
pub const NI_FINALIZECONVERSIONRESULT = @as(u32, 20);
pub const ISC_SHOWUICANDIDATEWINDOW = @as(u32, 1);
pub const ISC_SHOWUICOMPOSITIONWINDOW = @as(u32, 2147483648);
pub const ISC_SHOWUIGUIDELINE = @as(u32, 1073741824);
pub const ISC_SHOWUIALLCANDIDATEWINDOW = @as(u32, 15);
pub const ISC_SHOWUIALL = @as(u32, 3221225487);
pub const MOD_LEFT = @as(u32, 32768);
pub const MOD_RIGHT = @as(u32, 16384);
pub const MOD_ON_KEYUP = @as(u32, 2048);
pub const MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const IME_CHOTKEY_IME_NONIME_TOGGLE = @as(u32, 16);
pub const IME_CHOTKEY_SHAPE_TOGGLE = @as(u32, 17);
pub const IME_CHOTKEY_SYMBOL_TOGGLE = @as(u32, 18);
pub const IME_JHOTKEY_CLOSE_OPEN = @as(u32, 48);
pub const IME_KHOTKEY_SHAPE_TOGGLE = @as(u32, 80);
pub const IME_KHOTKEY_HANJACONVERT = @as(u32, 81);
pub const IME_KHOTKEY_ENGLISH = @as(u32, 82);
pub const IME_THOTKEY_IME_NONIME_TOGGLE = @as(u32, 112);
pub const IME_THOTKEY_SHAPE_TOGGLE = @as(u32, 113);
pub const IME_THOTKEY_SYMBOL_TOGGLE = @as(u32, 114);
pub const IME_HOTKEY_DSWITCH_FIRST = @as(u32, 256);
pub const IME_HOTKEY_DSWITCH_LAST = @as(u32, 287);
pub const IME_HOTKEY_PRIVATE_FIRST = @as(u32, 512);
pub const IME_ITHOTKEY_RESEND_RESULTSTR = @as(u32, 512);
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION = @as(u32, 513);
pub const IME_ITHOTKEY_UISTYLE_TOGGLE = @as(u32, 514);
pub const IME_ITHOTKEY_RECONVERTSTRING = @as(u32, 515);
pub const IME_HOTKEY_PRIVATE_LAST = @as(u32, 543);
pub const GCS_COMPREADSTR = @as(u32, 1);
pub const GCS_COMPREADATTR = @as(u32, 2);
pub const GCS_COMPREADCLAUSE = @as(u32, 4);
pub const GCS_COMPSTR = @as(u32, 8);
pub const GCS_COMPATTR = @as(u32, 16);
pub const GCS_COMPCLAUSE = @as(u32, 32);
pub const GCS_CURSORPOS = @as(u32, 128);
pub const GCS_DELTASTART = @as(u32, 256);
pub const GCS_RESULTREADSTR = @as(u32, 512);
pub const GCS_RESULTREADCLAUSE = @as(u32, 1024);
pub const GCS_RESULTSTR = @as(u32, 2048);
pub const GCS_RESULTCLAUSE = @as(u32, 4096);
pub const CS_INSERTCHAR = @as(u32, 8192);
pub const CS_NOMOVECARET = @as(u32, 16384);
pub const IMEVER_0310 = @as(u32, 196618);
pub const IMEVER_0400 = @as(u32, 262144);
pub const IME_PROP_AT_CARET = @as(u32, 65536);
pub const IME_PROP_SPECIAL_UI = @as(u32, 131072);
pub const IME_PROP_CANDLIST_START_FROM_1 = @as(u32, 262144);
pub const IME_PROP_UNICODE = @as(u32, 524288);
pub const IME_PROP_COMPLETE_ON_UNSELECT = @as(u32, 1048576);
pub const UI_CAP_2700 = @as(u32, 1);
pub const UI_CAP_ROT90 = @as(u32, 2);
pub const UI_CAP_ROTANY = @as(u32, 4);
pub const SCS_CAP_COMPSTR = @as(u32, 1);
pub const SCS_CAP_MAKEREAD = @as(u32, 2);
pub const SCS_CAP_SETRECONVERTSTRING = @as(u32, 4);
pub const SELECT_CAP_CONVERSION = @as(u32, 1);
pub const SELECT_CAP_SENTENCE = @as(u32, 2);
pub const GL_LEVEL_NOGUIDELINE = @as(u32, 0);
pub const GL_LEVEL_FATAL = @as(u32, 1);
pub const GL_LEVEL_ERROR = @as(u32, 2);
pub const GL_LEVEL_WARNING = @as(u32, 3);
pub const GL_LEVEL_INFORMATION = @as(u32, 4);
pub const GL_ID_UNKNOWN = @as(u32, 0);
pub const GL_ID_NOMODULE = @as(u32, 1);
pub const GL_ID_NODICTIONARY = @as(u32, 16);
pub const GL_ID_CANNOTSAVE = @as(u32, 17);
pub const GL_ID_NOCONVERT = @as(u32, 32);
pub const GL_ID_TYPINGERROR = @as(u32, 33);
pub const GL_ID_TOOMANYSTROKE = @as(u32, 34);
pub const GL_ID_READINGCONFLICT = @as(u32, 35);
pub const GL_ID_INPUTREADING = @as(u32, 36);
pub const GL_ID_INPUTRADICAL = @as(u32, 37);
pub const GL_ID_INPUTCODE = @as(u32, 38);
pub const GL_ID_INPUTSYMBOL = @as(u32, 39);
pub const GL_ID_CHOOSECANDIDATE = @as(u32, 40);
pub const GL_ID_REVERSECONVERSION = @as(u32, 41);
pub const GL_ID_PRIVATE_FIRST = @as(u32, 32768);
pub const GL_ID_PRIVATE_LAST = @as(u32, 65535);
pub const ATTR_INPUT = @as(u32, 0);
pub const ATTR_TARGET_CONVERTED = @as(u32, 1);
pub const ATTR_CONVERTED = @as(u32, 2);
pub const ATTR_TARGET_NOTCONVERTED = @as(u32, 3);
pub const ATTR_INPUT_ERROR = @as(u32, 4);
pub const ATTR_FIXEDCONVERTED = @as(u32, 5);
pub const CFS_DEFAULT = @as(u32, 0);
pub const CFS_RECT = @as(u32, 1);
pub const CFS_POINT = @as(u32, 2);
pub const CFS_FORCE_POSITION = @as(u32, 32);
pub const CFS_CANDIDATEPOS = @as(u32, 64);
pub const CFS_EXCLUDE = @as(u32, 128);
pub const IME_CMODE_SOFTKBD = @as(u32, 128);
pub const IME_CMODE_NOCONVERSION = @as(u32, 256);
pub const IME_CMODE_EUDC = @as(u32, 512);
pub const IME_CMODE_SYMBOL = @as(u32, 1024);
pub const IME_CMODE_FIXED = @as(u32, 2048);
pub const IME_CMODE_RESERVED = @as(u32, 4026531840);
pub const IME_SMODE_NONE = @as(u32, 0);
pub const IME_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IME_SMODE_SINGLECONVERT = @as(u32, 2);
pub const IME_SMODE_AUTOMATIC = @as(u32, 4);
pub const IME_SMODE_PHRASEPREDICT = @as(u32, 8);
pub const IME_SMODE_CONVERSATION = @as(u32, 16);
pub const IME_SMODE_RESERVED = @as(u32, 61440);
pub const IME_CAND_UNKNOWN = @as(u32, 0);
pub const IME_CAND_READ = @as(u32, 1);
pub const IME_CAND_CODE = @as(u32, 2);
pub const IME_CAND_MEANING = @as(u32, 3);
pub const IME_CAND_RADICAL = @as(u32, 4);
pub const IME_CAND_STROKE = @as(u32, 5);
pub const IMN_CLOSESTATUSWINDOW = @as(u32, 1);
pub const IMN_OPENSTATUSWINDOW = @as(u32, 2);
pub const IMN_CHANGECANDIDATE = @as(u32, 3);
pub const IMN_CLOSECANDIDATE = @as(u32, 4);
pub const IMN_OPENCANDIDATE = @as(u32, 5);
pub const IMN_SETCONVERSIONMODE = @as(u32, 6);
pub const IMN_SETSENTENCEMODE = @as(u32, 7);
pub const IMN_SETOPENSTATUS = @as(u32, 8);
pub const IMN_SETCANDIDATEPOS = @as(u32, 9);
pub const IMN_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMN_SETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMN_SETSTATUSWINDOWPOS = @as(u32, 12);
pub const IMN_GUIDELINE = @as(u32, 13);
pub const IMN_PRIVATE = @as(u32, 14);
pub const IMR_COMPOSITIONWINDOW = @as(u32, 1);
pub const IMR_CANDIDATEWINDOW = @as(u32, 2);
pub const IMR_COMPOSITIONFONT = @as(u32, 3);
pub const IMR_RECONVERTSTRING = @as(u32, 4);
pub const IMR_CONFIRMRECONVERTSTRING = @as(u32, 5);
pub const IMR_QUERYCHARPOSITION = @as(u32, 6);
pub const IMR_DOCUMENTFEED = @as(u32, 7);
pub const IMM_ERROR_NODATA = @as(i32, -1);
pub const IMM_ERROR_GENERAL = @as(i32, -2);
pub const IME_CONFIG_GENERAL = @as(u32, 1);
pub const IME_CONFIG_REGISTERWORD = @as(u32, 2);
pub const IME_CONFIG_SELECTDICTIONARY = @as(u32, 3);
pub const IME_ESC_QUERY_SUPPORT = @as(u32, 3);
pub const IME_ESC_RESERVED_FIRST = @as(u32, 4);
pub const IME_ESC_RESERVED_LAST = @as(u32, 2047);
pub const IME_ESC_PRIVATE_FIRST = @as(u32, 2048);
pub const IME_ESC_PRIVATE_LAST = @as(u32, 4095);
pub const IME_ESC_SEQUENCE_TO_INTERNAL = @as(u32, 4097);
pub const IME_ESC_GET_EUDC_DICTIONARY = @as(u32, 4099);
pub const IME_ESC_SET_EUDC_DICTIONARY = @as(u32, 4100);
pub const IME_ESC_MAX_KEY = @as(u32, 4101);
pub const IME_ESC_IME_NAME = @as(u32, 4102);
pub const IME_ESC_SYNC_HOTKEY = @as(u32, 4103);
pub const IME_ESC_HANJA_MODE = @as(u32, 4104);
pub const IME_ESC_AUTOMATA = @as(u32, 4105);
pub const IME_ESC_PRIVATE_HOTKEY = @as(u32, 4106);
pub const IME_ESC_GETHELPFILENAME = @as(u32, 4107);
pub const IME_REGWORD_STYLE_EUDC = @as(u32, 1);
pub const IME_REGWORD_STYLE_USER_FIRST = @as(u32, 2147483648);
pub const IME_REGWORD_STYLE_USER_LAST = @as(u32, 4294967295);
pub const IACE_CHILDREN = @as(u32, 1);
pub const IACE_DEFAULT = @as(u32, 16);
pub const IACE_IGNORENOCONTEXT = @as(u32, 32);
pub const IGIMIF_RIGHTMENU = @as(u32, 1);
pub const IGIMII_CMODE = @as(u32, 1);
pub const IGIMII_SMODE = @as(u32, 2);
pub const IGIMII_CONFIGURE = @as(u32, 4);
pub const IGIMII_TOOLS = @as(u32, 8);
pub const IGIMII_HELP = @as(u32, 16);
pub const IGIMII_OTHER = @as(u32, 32);
pub const IGIMII_INPUTTOOLS = @as(u32, 64);
pub const IMFT_RADIOCHECK = @as(u32, 1);
pub const IMFT_SEPARATOR = @as(u32, 2);
pub const IMFT_SUBMENU = @as(u32, 4);
pub const SOFTKEYBOARD_TYPE_T1 = @as(u32, 1);
pub const SOFTKEYBOARD_TYPE_C1 = @as(u32, 2);
pub const IMMGWL_IMC = @as(u32, 0);
pub const IMMGWLP_IMC = @as(u32, 0);
pub const IMC_SETCONVERSIONMODE = @as(u32, 2);
pub const IMC_SETSENTENCEMODE = @as(u32, 4);
pub const IMC_SETOPENSTATUS = @as(u32, 6);
pub const IMC_GETSOFTKBDFONT = @as(u32, 17);
pub const IMC_SETSOFTKBDFONT = @as(u32, 18);
pub const IMC_GETSOFTKBDPOS = @as(u32, 19);
pub const IMC_SETSOFTKBDPOS = @as(u32, 20);
pub const IMC_GETSOFTKBDSUBTYPE = @as(u32, 21);
pub const IMC_SETSOFTKBDSUBTYPE = @as(u32, 22);
pub const IMC_SETSOFTKBDDATA = @as(u32, 24);
pub const NI_CONTEXTUPDATED = @as(u32, 3);
pub const IME_SYSINFO_WINLOGON = @as(u32, 1);
pub const IME_SYSINFO_WOW16 = @as(u32, 2);
pub const INIT_STATUSWNDPOS = @as(u32, 1);
pub const INIT_CONVERSION = @as(u32, 2);
pub const INIT_SENTENCE = @as(u32, 4);
pub const INIT_LOGFONT = @as(u32, 8);
pub const INIT_COMPFORM = @as(u32, 16);
pub const INIT_SOFTKBDPOS = @as(u32, 32);
pub const IME_PROP_END_UNLOAD = @as(u32, 1);
pub const IME_PROP_KBD_CHAR_FIRST = @as(u32, 2);
pub const IME_PROP_IGNORE_UPKEYS = @as(u32, 4);
pub const IME_PROP_NEED_ALTKEY = @as(u32, 8);
pub const IME_PROP_NO_KEYS_ON_CLOSE = @as(u32, 16);
pub const IME_PROP_ACCEPT_WIDE_VKEY = @as(u32, 32);
pub const UI_CAP_SOFTKBD = @as(u32, 65536);
pub const IMN_SOFTKBDDESTROYED = @as(u32, 17);
pub const IME_UI_CLASS_NAME_SIZE = @as(u32, 16);
pub const IME_ESC_STRING_BUFFER_SIZE = @as(u32, 80);
pub const CATID_MSIME_IImePadApplet_VER7 = Guid.initString("4a0f8e31-c3ee-11d1-afef-00805f0c8b6d");
pub const CATID_MSIME_IImePadApplet_VER80 = Guid.initString("56f7a792-fef1-11d3-8463-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet_VER81 = Guid.initString("656520b0-bb88-11d4-84c0-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet900 = Guid.initString("faae51bf-5e5b-4a1d-8de1-17c1d9e1728d");
pub const CATID_MSIME_IImePadApplet1000 = Guid.initString("e081e1d6-2389-43cb-b66f-609f823d9f9c");
pub const CATID_MSIME_IImePadApplet1200 = Guid.initString("a47fb5fc-7d15-4223-a789-b781bf9ae667");
pub const CATID_MSIME_IImePadApplet = Guid.initString("7566cad1-4ec9-4478-9fe9-8ed766619edf");
pub const FEID_NONE = @as(u32, 0);
pub const FEID_CHINESE_TRADITIONAL = @as(u32, 1);
pub const FEID_CHINESE_SIMPLIFIED = @as(u32, 2);
pub const FEID_CHINESE_HONGKONG = @as(u32, 3);
pub const FEID_CHINESE_SINGAPORE = @as(u32, 4);
pub const FEID_JAPANESE = @as(u32, 5);
pub const FEID_KOREAN = @as(u32, 6);
pub const FEID_KOREAN_JOHAB = @as(u32, 7);
pub const INFOMASK_NONE = @as(u32, 0);
pub const INFOMASK_QUERY_CAND = @as(u32, 1);
pub const INFOMASK_APPLY_CAND = @as(u32, 2);
pub const INFOMASK_APPLY_CAND_EX = @as(u32, 4);
pub const INFOMASK_STRING_FIX = @as(u32, 65536);
pub const INFOMASK_HIDE_CAND = @as(u32, 131072);
pub const INFOMASK_BLOCK_CAND = @as(u32, 262144);
pub const IMEFAREASTINFO_TYPE_DEFAULT = @as(u32, 0);
pub const IMEFAREASTINFO_TYPE_READING = @as(u32, 1);
pub const IMEFAREASTINFO_TYPE_COMMENT = @as(u32, 2);
pub const IMEFAREASTINFO_TYPE_COSTTIME = @as(u32, 3);
pub const CHARINFO_APPLETID_MASK = @as(u32, 4278190080);
pub const CHARINFO_FEID_MASK = @as(u32, 15728640);
pub const CHARINFO_CHARID_MASK = @as(u32, 65535);
pub const MAX_APPLETTITLE = @as(u32, 64);
pub const MAX_FONTFACE = @as(u32, 32);
pub const IPACFG_NONE = @as(i32, 0);
pub const IPACFG_PROPERTY = @as(i32, 1);
pub const IPACFG_HELP = @as(i32, 2);
pub const IPACFG_TITLE = @as(i32, 65536);
pub const IPACFG_TITLEFONTFACE = @as(i32, 131072);
pub const IPACFG_CATEGORY = @as(i32, 262144);
pub const IPACFG_LANG = @as(i32, 16);
pub const IPACID_NONE = @as(u32, 0);
pub const IPACID_SOFTKEY = @as(u32, 1);
pub const IPACID_HANDWRITING = @as(u32, 2);
pub const IPACID_STROKESEARCH = @as(u32, 3);
pub const IPACID_RADICALSEARCH = @as(u32, 4);
pub const IPACID_SYMBOLSEARCH = @as(u32, 5);
pub const IPACID_VOICE = @as(u32, 6);
pub const IPACID_EPWING = @as(u32, 7);
pub const IPACID_OCR = @as(u32, 8);
pub const IPACID_CHARLIST = @as(u32, 9);
pub const IPACID_USER = @as(u32, 256);
pub const IMEPADREQ_FIRST = @as(u32, 4096);
pub const IMEPADREQ_INSERTSTRINGCANDIDATE = @as(u32, 4098);
pub const IMEPADREQ_INSERTITEMCANDIDATE = @as(u32, 4099);
pub const IMEPADREQ_SENDKEYCONTROL = @as(u32, 4101);
pub const IMEPADREQ_GETSELECTEDSTRING = @as(u32, 4103);
pub const IMEPADREQ_SETAPPLETDATA = @as(u32, 4105);
pub const IMEPADREQ_GETAPPLETDATA = @as(u32, 4106);
pub const IMEPADREQ_SETTITLEFONT = @as(u32, 4107);
pub const IMEPADREQ_GETCOMPOSITIONSTRINGID = @as(u32, 4109);
pub const IMEPADREQ_INSERTSTRINGCANDIDATEINFO = @as(u32, 4110);
pub const IMEPADREQ_CHANGESTRINGCANDIDATEINFO = @as(u32, 4111);
pub const IMEPADREQ_INSERTSTRINGINFO = @as(u32, 4114);
pub const IMEPADREQ_CHANGESTRINGINFO = @as(u32, 4115);
pub const IMEPADREQ_GETCURRENTUILANGID = @as(u32, 4120);
pub const IMEPADCTRL_CONVERTALL = @as(u32, 1);
pub const IMEPADCTRL_DETERMINALL = @as(u32, 2);
pub const IMEPADCTRL_DETERMINCHAR = @as(u32, 3);
pub const IMEPADCTRL_CLEARALL = @as(u32, 4);
pub const IMEPADCTRL_CARETSET = @as(u32, 5);
pub const IMEPADCTRL_CARETLEFT = @as(u32, 6);
pub const IMEPADCTRL_CARETRIGHT = @as(u32, 7);
pub const IMEPADCTRL_CARETTOP = @as(u32, 8);
pub const IMEPADCTRL_CARETBOTTOM = @as(u32, 9);
pub const IMEPADCTRL_CARETBACKSPACE = @as(u32, 10);
pub const IMEPADCTRL_CARETDELETE = @as(u32, 11);
pub const IMEPADCTRL_PHRASEDELETE = @as(u32, 12);
pub const IMEPADCTRL_INSERTSPACE = @as(u32, 13);
pub const IMEPADCTRL_INSERTFULLSPACE = @as(u32, 14);
pub const IMEPADCTRL_INSERTHALFSPACE = @as(u32, 15);
pub const IMEPADCTRL_ONIME = @as(u32, 16);
pub const IMEPADCTRL_OFFIME = @as(u32, 17);
pub const IMEPADCTRL_ONPRECONVERSION = @as(u32, 18);
pub const IMEPADCTRL_OFFPRECONVERSION = @as(u32, 19);
pub const IMEPADCTRL_PHONETICCANDIDATE = @as(u32, 20);
pub const IMEKEYCTRLMASK_ALT = @as(u32, 1);
pub const IMEKEYCTRLMASK_CTRL = @as(u32, 2);
pub const IMEKEYCTRLMASK_SHIFT = @as(u32, 4);
pub const IMEKEYCTRL_UP = @as(u32, 1);
pub const IMEKEYCTRL_DOWN = @as(u32, 0);
pub const IMEPN_FIRST = @as(u32, 256);
pub const IMEPN_ACTIVATE = @as(u32, 257);
pub const IMEPN_INACTIVATE = @as(u32, 258);
pub const IMEPN_SHOW = @as(u32, 260);
pub const IMEPN_HIDE = @as(u32, 261);
pub const IMEPN_SIZECHANGING = @as(u32, 262);
pub const IMEPN_SIZECHANGED = @as(u32, 263);
pub const IMEPN_CONFIG = @as(u32, 264);
pub const IMEPN_HELP = @as(u32, 265);
pub const IMEPN_QUERYCAND = @as(u32, 266);
pub const IMEPN_APPLYCAND = @as(u32, 267);
pub const IMEPN_APPLYCANDEX = @as(u32, 268);
pub const IMEPN_SETTINGCHANGED = @as(u32, 269);
pub const IMEPN_USER = @as(u32, 356);
pub const IPAWS_ENABLED = @as(i32, 1);
pub const IPAWS_SIZINGNOTIFY = @as(i32, 4);
pub const IPAWS_VERTICALFIXED = @as(i32, 256);
pub const IPAWS_HORIZONTALFIXED = @as(i32, 512);
pub const IPAWS_SIZEFIXED = @as(i32, 768);
pub const IPAWS_MAXWIDTHFIXED = @as(i32, 4096);
pub const IPAWS_MAXHEIGHTFIXED = @as(i32, 8192);
pub const IPAWS_MAXSIZEFIXED = @as(i32, 12288);
pub const IPAWS_MINWIDTHFIXED = @as(i32, 65536);
pub const IPAWS_MINHEIGHTFIXED = @as(i32, 131072);
pub const IPAWS_MINSIZEFIXED = @as(i32, 196608);
pub const CLSID_ImePlugInDictDictionaryList_CHS = Guid.initString("7bf0129b-5bef-4de4-9b0b-5edb66ac2fa6");
pub const CLSID_ImePlugInDictDictionaryList_JPN = Guid.initString("4fe2776b-b0f9-4396-b5fc-e9d4cf1ec195");

//--------------------------------------------------------------------------------
// Section: Types (80)
//--------------------------------------------------------------------------------
pub const SET_COMPOSITION_STRING_TYPE = enum(u32) {
    SETSTR = 9,
    CHANGEATTR = 18,
    CHANGECLAUSE = 36,
    SETRECONVERTSTRING = 65536,
    QUERYRECONVERTSTRING = 131072,
};
pub const SCS_SETSTR = SET_COMPOSITION_STRING_TYPE.SETSTR;
pub const SCS_CHANGEATTR = SET_COMPOSITION_STRING_TYPE.CHANGEATTR;
pub const SCS_CHANGECLAUSE = SET_COMPOSITION_STRING_TYPE.CHANGECLAUSE;
pub const SCS_SETRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.SETRECONVERTSTRING;
pub const SCS_QUERYRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.QUERYRECONVERTSTRING;

pub const GET_GUIDE_LINE_TYPE = enum(u32) {
    LEVEL = 1,
    INDEX = 2,
    STRING = 3,
    PRIVATE = 4,
};
pub const GGL_LEVEL = GET_GUIDE_LINE_TYPE.LEVEL;
pub const GGL_INDEX = GET_GUIDE_LINE_TYPE.INDEX;
pub const GGL_STRING = GET_GUIDE_LINE_TYPE.STRING;
pub const GGL_PRIVATE = GET_GUIDE_LINE_TYPE.PRIVATE;

pub const NOTIFY_IME_INDEX = enum(u32) {
    CANCEL = 4,
    COMPLETE = 1,
    CONVERT = 2,
    REVERT = 3,
};
pub const CPS_CANCEL = NOTIFY_IME_INDEX.CANCEL;
pub const CPS_COMPLETE = NOTIFY_IME_INDEX.COMPLETE;
pub const CPS_CONVERT = NOTIFY_IME_INDEX.CONVERT;
pub const CPS_REVERT = NOTIFY_IME_INDEX.REVERT;

pub const NOTIFY_IME_ACTION = enum(u32) {
    CHANGECANDIDATELIST = 19,
    CLOSECANDIDATE = 17,
    COMPOSITIONSTR = 21,
    IMEMENUSELECTED = 24,
    OPENCANDIDATE = 16,
    SELECTCANDIDATESTR = 18,
    SETCANDIDATE_PAGESIZE = 23,
    SETCANDIDATE_PAGESTART = 22,
};
pub const NI_CHANGECANDIDATELIST = NOTIFY_IME_ACTION.CHANGECANDIDATELIST;
pub const NI_CLOSECANDIDATE = NOTIFY_IME_ACTION.CLOSECANDIDATE;
pub const NI_COMPOSITIONSTR = NOTIFY_IME_ACTION.COMPOSITIONSTR;
pub const NI_IMEMENUSELECTED = NOTIFY_IME_ACTION.IMEMENUSELECTED;
pub const NI_OPENCANDIDATE = NOTIFY_IME_ACTION.OPENCANDIDATE;
pub const NI_SELECTCANDIDATESTR = NOTIFY_IME_ACTION.SELECTCANDIDATESTR;
pub const NI_SETCANDIDATE_PAGESIZE = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESIZE;
pub const NI_SETCANDIDATE_PAGESTART = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESTART;

pub const GET_CONVERSION_LIST_FLAG = enum(u32) {
    CONVERSION = 1,
    REVERSECONVERSION = 2,
    REVERSE_LENGTH = 3,
};
pub const GCL_CONVERSION = GET_CONVERSION_LIST_FLAG.CONVERSION;
pub const GCL_REVERSECONVERSION = GET_CONVERSION_LIST_FLAG.REVERSECONVERSION;
pub const GCL_REVERSE_LENGTH = GET_CONVERSION_LIST_FLAG.REVERSE_LENGTH;

pub const IME_PAD_REQUEST_FLAGS = enum(u32) {
    INSERTSTRING = 4097,
    SENDCONTROL = 4100,
    SETAPPLETSIZE = 4104,
    GETCOMPOSITIONSTRING = 4102,
    GETCOMPOSITIONSTRINGINFO = 4108,
    DELETESTRING = 4112,
    CHANGESTRING = 4113,
    GETAPPLHWND = 4116,
    FORCEIMEPADWINDOWSHOW = 4117,
    POSTMODALNOTIFY = 4118,
    GETDEFAULTUILANGID = 4119,
    GETAPPLETUISTYLE = 4121,
    SETAPPLETUISTYLE = 4122,
    ISAPPLETACTIVE = 4123,
    ISIMEPADWINDOWVISIBLE = 4124,
    SETAPPLETMINMAXSIZE = 4125,
    GETCONVERSIONSTATUS = 4126,
    GETVERSION = 4127,
    GETCURRENTIMEINFO = 4128,
};
pub const IMEPADREQ_INSERTSTRING = IME_PAD_REQUEST_FLAGS.INSERTSTRING;
pub const IMEPADREQ_SENDCONTROL = IME_PAD_REQUEST_FLAGS.SENDCONTROL;
pub const IMEPADREQ_SETAPPLETSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETSIZE;
pub const IMEPADREQ_GETCOMPOSITIONSTRING = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRING;
pub const IMEPADREQ_GETCOMPOSITIONSTRINGINFO = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRINGINFO;
pub const IMEPADREQ_DELETESTRING = IME_PAD_REQUEST_FLAGS.DELETESTRING;
pub const IMEPADREQ_CHANGESTRING = IME_PAD_REQUEST_FLAGS.CHANGESTRING;
pub const IMEPADREQ_GETAPPLHWND = IME_PAD_REQUEST_FLAGS.GETAPPLHWND;
pub const IMEPADREQ_FORCEIMEPADWINDOWSHOW = IME_PAD_REQUEST_FLAGS.FORCEIMEPADWINDOWSHOW;
pub const IMEPADREQ_POSTMODALNOTIFY = IME_PAD_REQUEST_FLAGS.POSTMODALNOTIFY;
pub const IMEPADREQ_GETDEFAULTUILANGID = IME_PAD_REQUEST_FLAGS.GETDEFAULTUILANGID;
pub const IMEPADREQ_GETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.GETAPPLETUISTYLE;
pub const IMEPADREQ_SETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.SETAPPLETUISTYLE;
pub const IMEPADREQ_ISAPPLETACTIVE = IME_PAD_REQUEST_FLAGS.ISAPPLETACTIVE;
pub const IMEPADREQ_ISIMEPADWINDOWVISIBLE = IME_PAD_REQUEST_FLAGS.ISIMEPADWINDOWVISIBLE;
pub const IMEPADREQ_SETAPPLETMINMAXSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETMINMAXSIZE;
pub const IMEPADREQ_GETCONVERSIONSTATUS = IME_PAD_REQUEST_FLAGS.GETCONVERSIONSTATUS;
pub const IMEPADREQ_GETVERSION = IME_PAD_REQUEST_FLAGS.GETVERSION;
pub const IMEPADREQ_GETCURRENTIMEINFO = IME_PAD_REQUEST_FLAGS.GETCURRENTIMEINFO;

pub const COMPOSITIONFORM = extern struct {
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATEFORM = extern struct {
    dwIndex: u32,
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATELIST = extern struct {
    dwSize: u32,
    dwStyle: u32,
    dwCount: u32,
    dwSelection: u32,
    dwPageStart: u32,
    dwPageSize: u32,
    dwOffset: [1]u32,
};

pub const REGISTERWORDA = extern struct {
    lpReading: ?PSTR,
    lpWord: ?PSTR,
};

pub const REGISTERWORDW = extern struct {
    lpReading: ?PWSTR,
    lpWord: ?PWSTR,
};

pub const RECONVERTSTRING = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwTargetStrLen: u32,
    dwTargetStrOffset: u32,
};

pub const STYLEBUFA = extern struct {
    dwStyle: u32,
    szDescription: [32]CHAR,
};

pub const STYLEBUFW = extern struct {
    dwStyle: u32,
    szDescription: [32]u16,
};

pub const IMEMENUITEMINFOA = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]CHAR,
    hbmpItem: ?HBITMAP,
};

pub const IMEMENUITEMINFOW = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]u16,
    hbmpItem: ?HBITMAP,
};

pub const IMECHARPOSITION = extern struct {
    dwSize: u32,
    dwCharPos: u32,
    pt: POINT,
    cLineHeight: u32,
    rcDocument: RECT,
};

pub const IMCENUMPROC = *const fn (
    param0: ?HIMC,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REGISTERWORDENUMPROCA = *const fn (
    lpsz_reading: ?[*:0]const u8,
    param1: u32,
    lpsz_string: ?[*:0]const u8,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const REGISTERWORDENUMPROCW = *const fn (
    lpsz_reading: ?[*:0]const u16,
    param1: u32,
    lpsz_string: ?[*:0]const u16,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IFEClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IClassFactory.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEDLG = extern struct {
    cbIMEDLG: i32 align(1),
    hwnd: ?HWND align(1),
    lpwstrWord: ?PWSTR align(1),
    nTabId: i32 align(1),
};

const IID_IFECommon_Value = Guid.initString("019f7151-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFECommon = &IID_IFECommon_Value;
pub const IFECommon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDefaultIME: *const fn (
            self: *const IFECommon,
            sz_name: [*:0]const u8,
            csz_name: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultIME: *const fn (
            self: *const IFECommon,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeWordRegDialog: *const fn (
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeDictToolDialog: *const fn (
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isDefaultIME(self: *const T, sz_name_: [*:0]const u8, csz_name_: i32) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).IsDefaultIME(@as(*const IFECommon, @ptrCast(self)), sz_name_, csz_name_);
            }
            pub inline fn setDefaultIME(self: *const T) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).SetDefaultIME(@as(*const IFECommon, @ptrCast(self)));
            }
            pub inline fn invokeWordRegDialog(self: *const T, pimedlg_: ?*IMEDLG) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).InvokeWordRegDialog(@as(*const IFECommon, @ptrCast(self)), pimedlg_);
            }
            pub inline fn invokeDictToolDialog(self: *const T, pimedlg_: ?*IMEDLG) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).InvokeDictToolDialog(@as(*const IFECommon, @ptrCast(self)), pimedlg_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WDD = extern struct {
    wDispPos: u16 align(1),
    Anonymous1: extern union {
        wReadPos: u16 align(1),
        wCompPos: u16 align(1),
    } align(1),
    cchDisp: u16 align(1),
    Anonymous2: extern union {
        cchRead: u16 align(1),
        cchComp: u16 align(1),
    } align(1),
    WDD_nReserve1: u32 align(1),
    nPos: u16 align(1),
    _bitfield: u16 align(1),
    pReserved: ?*anyopaque align(1),
};

pub const MORRSLT = extern struct {
    dwSize: u32 align(1),
    pwchOutput: ?PWSTR align(1),
    cchOutput: u16 align(1),
    Anonymous1: extern union {
        pwchRead: ?PWSTR align(1),
        pwchComp: ?PWSTR align(1),
    } align(1),
    Anonymous2: extern union {
        cchRead: u16 align(1),
        cchComp: u16 align(1),
    } align(1),
    pchInputPos: ?*u16 align(1),
    pchOutputIdxWDD: ?*u16 align(1),
    Anonymous3: extern union {
        pchReadIdxWDD: ?*u16 align(1),
        pchCompIdxWDD: ?*u16 align(1),
    } align(1),
    paMonoRubyPos: ?*u16 align(1),
    pWDD: ?*WDD align(1),
    cWDD: i32 align(1),
    pPrivate: ?*anyopaque align(1),
    BLKBuff: [1]u16 align(1),
};

const IID_IFELanguage_Value = Guid.initString("019f7152-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFELanguage = &IID_IFELanguage_Value;
pub const IFELanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJMorphResult: *const fn (
            self: *const IFELanguage,
            dw_request: u32,
            dw_c_mode: u32,
            cwch_input: i32,
            pwch_input: ?[*:0]const u16,
            pf_c_info: ?*u32,
            pp_result: ?*?*MORRSLT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionModeCaps: *const fn (
            self: *const IFELanguage,
            pdw_caps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPhonetic: *const fn (
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            phonetic: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversion: *const fn (
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).Open(@as(*const IFELanguage, @ptrCast(self)));
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).Close(@as(*const IFELanguage, @ptrCast(self)));
            }
            pub inline fn getJMorphResult(self: *const T, dw_request_: u32, dw_c_mode_: u32, cwch_input_: i32, pwch_input_: ?[*:0]const u16, pf_c_info_: ?*u32, pp_result_: ?*?*MORRSLT) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetJMorphResult(@as(*const IFELanguage, @ptrCast(self)), dw_request_, dw_c_mode_, cwch_input_, pwch_input_, pf_c_info_, pp_result_);
            }
            pub inline fn getConversionModeCaps(self: *const T, pdw_caps_: ?*u32) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetConversionModeCaps(@as(*const IFELanguage, @ptrCast(self)), pdw_caps_);
            }
            pub inline fn getPhonetic(self: *const T, string_: ?BSTR, start_: i32, length_: i32, phonetic_: ?*?BSTR) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetPhonetic(@as(*const IFELanguage, @ptrCast(self)), string_, start_, length_, phonetic_);
            }
            pub inline fn getConversion(self: *const T, string_: ?BSTR, start_: i32, length_: i32, result_: ?*?BSTR) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetConversion(@as(*const IFELanguage, @ptrCast(self)), string_, start_, length_, result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEREG = enum(i32) {
    HEAD = 0,
    TAIL = 1,
    DEL = 2,
};
pub const IFED_REG_HEAD = IMEREG.HEAD;
pub const IFED_REG_TAIL = IMEREG.TAIL;
pub const IFED_REG_DEL = IMEREG.DEL;

pub const IMEFMT = enum(i32) {
    UNKNOWN = 0,
    MSIME2_BIN_SYSTEM = 1,
    MSIME2_BIN_USER = 2,
    MSIME2_TEXT_USER = 3,
    MSIME95_BIN_SYSTEM = 4,
    MSIME95_BIN_USER = 5,
    MSIME95_TEXT_USER = 6,
    MSIME97_BIN_SYSTEM = 7,
    MSIME97_BIN_USER = 8,
    MSIME97_TEXT_USER = 9,
    MSIME98_BIN_SYSTEM = 10,
    MSIME98_BIN_USER = 11,
    MSIME98_TEXT_USER = 12,
    ACTIVE_DICT = 13,
    ATOK9 = 14,
    ATOK10 = 15,
    NEC_AI_ = 16,
    WX_II = 17,
    WX_III = 18,
    VJE_20 = 19,
    MSIME98_SYSTEM_CE = 20,
    MSIME_BIN_SYSTEM = 21,
    MSIME_BIN_USER = 22,
    MSIME_TEXT_USER = 23,
    PIME2_BIN_USER = 24,
    PIME2_BIN_SYSTEM = 25,
    PIME2_BIN_STANDARD_SYSTEM = 26,
};
pub const IFED_UNKNOWN = IMEFMT.UNKNOWN;
pub const IFED_MSIME2_BIN_SYSTEM = IMEFMT.MSIME2_BIN_SYSTEM;
pub const IFED_MSIME2_BIN_USER = IMEFMT.MSIME2_BIN_USER;
pub const IFED_MSIME2_TEXT_USER = IMEFMT.MSIME2_TEXT_USER;
pub const IFED_MSIME95_BIN_SYSTEM = IMEFMT.MSIME95_BIN_SYSTEM;
pub const IFED_MSIME95_BIN_USER = IMEFMT.MSIME95_BIN_USER;
pub const IFED_MSIME95_TEXT_USER = IMEFMT.MSIME95_TEXT_USER;
pub const IFED_MSIME97_BIN_SYSTEM = IMEFMT.MSIME97_BIN_SYSTEM;
pub const IFED_MSIME97_BIN_USER = IMEFMT.MSIME97_BIN_USER;
pub const IFED_MSIME97_TEXT_USER = IMEFMT.MSIME97_TEXT_USER;
pub const IFED_MSIME98_BIN_SYSTEM = IMEFMT.MSIME98_BIN_SYSTEM;
pub const IFED_MSIME98_BIN_USER = IMEFMT.MSIME98_BIN_USER;
pub const IFED_MSIME98_TEXT_USER = IMEFMT.MSIME98_TEXT_USER;
pub const IFED_ACTIVE_DICT = IMEFMT.ACTIVE_DICT;
pub const IFED_ATOK9 = IMEFMT.ATOK9;
pub const IFED_ATOK10 = IMEFMT.ATOK10;
pub const IFED_NEC_AI_ = IMEFMT.NEC_AI_;
pub const IFED_WX_II = IMEFMT.WX_II;
pub const IFED_WX_III = IMEFMT.WX_III;
pub const IFED_VJE_20 = IMEFMT.VJE_20;
pub const IFED_MSIME98_SYSTEM_CE = IMEFMT.MSIME98_SYSTEM_CE;
pub const IFED_MSIME_BIN_SYSTEM = IMEFMT.MSIME_BIN_SYSTEM;
pub const IFED_MSIME_BIN_USER = IMEFMT.MSIME_BIN_USER;
pub const IFED_MSIME_TEXT_USER = IMEFMT.MSIME_TEXT_USER;
pub const IFED_PIME2_BIN_USER = IMEFMT.PIME2_BIN_USER;
pub const IFED_PIME2_BIN_SYSTEM = IMEFMT.PIME2_BIN_SYSTEM;
pub const IFED_PIME2_BIN_STANDARD_SYSTEM = IMEFMT.PIME2_BIN_STANDARD_SYSTEM;

pub const IMEUCT = enum(i32) {
    NONE = 0,
    STRING_SJIS = 1,
    STRING_UNICODE = 2,
    USER_DEFINED = 3,
    MAX = 4,
};
pub const IFED_UCT_NONE = IMEUCT.NONE;
pub const IFED_UCT_STRING_SJIS = IMEUCT.STRING_SJIS;
pub const IFED_UCT_STRING_UNICODE = IMEUCT.STRING_UNICODE;
pub const IFED_UCT_USER_DEFINED = IMEUCT.USER_DEFINED;
pub const IFED_UCT_MAX = IMEUCT.MAX;

pub const IMEWRD = extern struct {
    pwchReading: ?PWSTR align(1),
    pwchDisplay: ?PWSTR align(1),
    Anonymous: extern union {
        ulPos: u32 align(1),
        Anonymous: extern struct {
            nPos1: u16 align(1),
            nPos2: u16 align(1),
        } align(1),
    } align(1),
    rgulAttrs: [2]u32 align(1),
    cbComment: i32 align(1),
    uct: IMEUCT align(1),
    pvComment: ?*anyopaque align(1),
};

pub const IMESHF = extern struct {
    cbShf: u16 align(1),
    verDic: u16 align(1),
    szTitle: [48]CHAR align(1),
    szDescription: [256]CHAR align(1),
    szCopyright: [128]CHAR align(1),
};

pub const POSTBL = extern struct {
    nPos: u16 align(1),
    szName: ?*u8 align(1),
};

pub const IMEREL = enum(i32) {
    NONE = 0,
    NO = 1,
    GA = 2,
    WO = 3,
    NI = 4,
    DE = 5,
    YORI = 6,
    KARA = 7,
    MADE = 8,
    HE = 9,
    TO = 10,
    IDEOM = 11,
    FUKU_YOUGEN = 12,
    KEIYOU_YOUGEN = 13,
    KEIDOU1_YOUGEN = 14,
    KEIDOU2_YOUGEN = 15,
    TAIGEN = 16,
    YOUGEN = 17,
    RENTAI_MEI = 18,
    RENSOU = 19,
    KEIYOU_TO_YOUGEN = 20,
    KEIYOU_TARU_YOUGEN = 21,
    UNKNOWN1 = 22,
    UNKNOWN2 = 23,
    ALL = 24,
};
pub const IFED_REL_NONE = IMEREL.NONE;
pub const IFED_REL_NO = IMEREL.NO;
pub const IFED_REL_GA = IMEREL.GA;
pub const IFED_REL_WO = IMEREL.WO;
pub const IFED_REL_NI = IMEREL.NI;
pub const IFED_REL_DE = IMEREL.DE;
pub const IFED_REL_YORI = IMEREL.YORI;
pub const IFED_REL_KARA = IMEREL.KARA;
pub const IFED_REL_MADE = IMEREL.MADE;
pub const IFED_REL_HE = IMEREL.HE;
pub const IFED_REL_TO = IMEREL.TO;
pub const IFED_REL_IDEOM = IMEREL.IDEOM;
pub const IFED_REL_FUKU_YOUGEN = IMEREL.FUKU_YOUGEN;
pub const IFED_REL_KEIYOU_YOUGEN = IMEREL.KEIYOU_YOUGEN;
pub const IFED_REL_KEIDOU1_YOUGEN = IMEREL.KEIDOU1_YOUGEN;
pub const IFED_REL_KEIDOU2_YOUGEN = IMEREL.KEIDOU2_YOUGEN;
pub const IFED_REL_TAIGEN = IMEREL.TAIGEN;
pub const IFED_REL_YOUGEN = IMEREL.YOUGEN;
pub const IFED_REL_RENTAI_MEI = IMEREL.RENTAI_MEI;
pub const IFED_REL_RENSOU = IMEREL.RENSOU;
pub const IFED_REL_KEIYOU_TO_YOUGEN = IMEREL.KEIYOU_TO_YOUGEN;
pub const IFED_REL_KEIYOU_TARU_YOUGEN = IMEREL.KEIYOU_TARU_YOUGEN;
pub const IFED_REL_UNKNOWN1 = IMEREL.UNKNOWN1;
pub const IFED_REL_UNKNOWN2 = IMEREL.UNKNOWN2;
pub const IFED_REL_ALL = IMEREL.ALL;

pub const IMEDP = extern struct {
    wrdModifier: IMEWRD align(1),
    wrdModifiee: IMEWRD align(1),
    relID: IMEREL align(1),
};

pub const PFNLOG = *const fn (
    param0: ?*IMEDP,
    param1: HRESULT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IFEDictionary_Value = Guid.initString("019f7153-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFEDictionary = &IID_IFEDictionary_Value;
pub const IFEDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const IFEDictionary,
            pch_dict_path: ?*[260]u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeader: *const fn (
            self: *const IFEDictionary,
            pch_dict_path: ?*[260]u8,
            pshf: ?*IMESHF,
            pjfmt: ?*IMEFMT,
            pul_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayProperty: *const fn (
            self: *const IFEDictionary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosTable: *const fn (
            self: *const IFEDictionary,
            prg_pos_tbl: ?*?*POSTBL,
            pc_pos_tbl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: *const fn (
            self: *const IFEDictionary,
            pwch_first: ?[*:0]const u16,
            pwch_last: ?[*:0]const u16,
            pwch_display: ?[*:0]const u16,
            ul_pos: u32,
            ul_select: u32,
            ul_word_src: u32,
            pch_buffer: ?*u8,
            cb_buffer: u32,
            pc_wrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextWords: *const fn (
            self: *const IFEDictionary,
            pch_buffer: ?*u8,
            cb_buffer: u32,
            pc_wrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: *const fn (
            self: *const IFEDictionary,
            pch_dict_path: ?[*:0]const u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeader: *const fn (
            self: *const IFEDictionary,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistWord: *const fn (
            self: *const IFEDictionary,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistDependency: *const fn (
            self: *const IFEDictionary,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: *const fn (
            self: *const IFEDictionary,
            reg: IMEREG,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDependency: *const fn (
            self: *const IFEDictionary,
            reg: IMEREG,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDependencies: *const fn (
            self: *const IFEDictionary,
            pwch_kakari_reading: ?[*:0]const u16,
            pwch_kakari_display: ?[*:0]const u16,
            ul_kakari_pos: u32,
            pwch_uke_reading: ?[*:0]const u16,
            pwch_uke_display: ?[*:0]const u16,
            ul_uke_pos: u32,
            jrel: IMEREL,
            ul_word_src: u32,
            pch_buffer: ?*u8,
            cb_buffer: u32,
            pcdp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextDependencies: *const fn (
            self: *const IFEDictionary,
            pch_buffer: ?*u8,
            cb_buffer: u32,
            pc_dp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromOldMSIME: *const fn (
            self: *const IFEDictionary,
            pch_dic: ?[*:0]const u8,
            pfn_log: ?PFNLOG,
            reg: IMEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromUserToSys: *const fn (
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, pch_dict_path_: ?*[260]u8, pshf_: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Open(@as(*const IFEDictionary, @ptrCast(self)), pch_dict_path_, pshf_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Close(@as(*const IFEDictionary, @ptrCast(self)));
            }
            pub inline fn getHeader(self: *const T, pch_dict_path_: ?*[260]u8, pshf_: ?*IMESHF, pjfmt_: ?*IMEFMT, pul_type_: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetHeader(@as(*const IFEDictionary, @ptrCast(self)), pch_dict_path_, pshf_, pjfmt_, pul_type_);
            }
            pub inline fn displayProperty(self: *const T, hwnd_: ?HWND) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).DisplayProperty(@as(*const IFEDictionary, @ptrCast(self)), hwnd_);
            }
            pub inline fn getPosTable(self: *const T, prg_pos_tbl_: ?*?*POSTBL, pc_pos_tbl_: ?*i32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetPosTable(@as(*const IFEDictionary, @ptrCast(self)), prg_pos_tbl_, pc_pos_tbl_);
            }
            pub inline fn getWords(self: *const T, pwch_first_: ?[*:0]const u16, pwch_last_: ?[*:0]const u16, pwch_display_: ?[*:0]const u16, ul_pos_: u32, ul_select_: u32, ul_word_src_: u32, pch_buffer_: ?*u8, cb_buffer_: u32, pc_wrd_: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetWords(@as(*const IFEDictionary, @ptrCast(self)), pwch_first_, pwch_last_, pwch_display_, ul_pos_, ul_select_, ul_word_src_, pch_buffer_, cb_buffer_, pc_wrd_);
            }
            pub inline fn nextWords(self: *const T, pch_buffer_: ?*u8, cb_buffer_: u32, pc_wrd_: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).NextWords(@as(*const IFEDictionary, @ptrCast(self)), pch_buffer_, cb_buffer_, pc_wrd_);
            }
            pub inline fn create(self: *const T, pch_dict_path_: ?[*:0]const u8, pshf_: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Create(@as(*const IFEDictionary, @ptrCast(self)), pch_dict_path_, pshf_);
            }
            pub inline fn setHeader(self: *const T, pshf_: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).SetHeader(@as(*const IFEDictionary, @ptrCast(self)), pshf_);
            }
            pub inline fn existWord(self: *const T, pwrd_: ?*IMEWRD) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ExistWord(@as(*const IFEDictionary, @ptrCast(self)), pwrd_);
            }
            pub inline fn existDependency(self: *const T, pdp_: ?*IMEDP) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ExistDependency(@as(*const IFEDictionary, @ptrCast(self)), pdp_);
            }
            pub inline fn registerWord(self: *const T, reg_: IMEREG, pwrd_: ?*IMEWRD) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).RegisterWord(@as(*const IFEDictionary, @ptrCast(self)), reg_, pwrd_);
            }
            pub inline fn registerDependency(self: *const T, reg_: IMEREG, pdp_: ?*IMEDP) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).RegisterDependency(@as(*const IFEDictionary, @ptrCast(self)), reg_, pdp_);
            }
            pub inline fn getDependencies(self: *const T, pwch_kakari_reading_: ?[*:0]const u16, pwch_kakari_display_: ?[*:0]const u16, ul_kakari_pos_: u32, pwch_uke_reading_: ?[*:0]const u16, pwch_uke_display_: ?[*:0]const u16, ul_uke_pos_: u32, jrel_: IMEREL, ul_word_src_: u32, pch_buffer_: ?*u8, cb_buffer_: u32, pcdp_: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetDependencies(@as(*const IFEDictionary, @ptrCast(self)), pwch_kakari_reading_, pwch_kakari_display_, ul_kakari_pos_, pwch_uke_reading_, pwch_uke_display_, ul_uke_pos_, jrel_, ul_word_src_, pch_buffer_, cb_buffer_, pcdp_);
            }
            pub inline fn nextDependencies(self: *const T, pch_buffer_: ?*u8, cb_buffer_: u32, pc_dp_: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).NextDependencies(@as(*const IFEDictionary, @ptrCast(self)), pch_buffer_, cb_buffer_, pc_dp_);
            }
            pub inline fn convertFromOldMSIME(self: *const T, pch_dic_: ?[*:0]const u8, pfn_log_: ?PFNLOG, reg_: IMEREG) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ConvertFromOldMSIME(@as(*const IFEDictionary, @ptrCast(self)), pch_dic_, pfn_log_, reg_);
            }
            pub inline fn convertFromUserToSys(self: *const T) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ConvertFromUserToSys(@as(*const IFEDictionary, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEKMSINIT = extern struct {
    cbSize: i32 align(1),
    hWnd: ?HWND align(1),
};

pub const IMEKMSKEY = extern struct {
    dwStatus: u32 align(1),
    dwCompStatus: u32 align(1),
    dwVKEY: u32 align(1),
    Anonymous1: extern union {
        dwControl: u32 align(1),
        dwNotUsed: u32 align(1),
    } align(1),
    Anonymous2: extern union {
        pwszDscr: [31]u16 align(1),
        pwszNoUse: [31]u16 align(1),
    } align(1),
};

pub const IMEKMS = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    cKeyList: u32 align(1),
    pKeyList: ?*IMEKMSKEY align(1),
};

pub const IMEKMSNTFY = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    fSelect: BOOL align(1),
};

pub const IMEKMSKMP = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    idLang: u16 align(1),
    wVKStart: u16 align(1),
    wVKEnd: u16 align(1),
    cKeyList: i32 align(1),
    pKeyList: ?*IMEKMSKEY align(1),
};

pub const IMEKMSINVK = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    dwControl: u32 align(1),
};

pub const IMEKMSFUNCDESC = extern struct {
    cbSize: i32 align(1),
    idLang: u16 align(1),
    dwControl: u32 align(1),
    pwszDescription: [128]u16 align(1),
};

pub const fpCreateIFECommonInstanceType = *const fn (
    ppv_obj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFELanguageInstanceType = *const fn (
    clsid: ?*const Guid,
    ppv_obj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFEDictionaryInstanceType = *const fn (
    ppv_obj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const COMPOSITIONSTRING = extern struct {
    dwSize: u32,
    dwCompReadAttrLen: u32,
    dwCompReadAttrOffset: u32,
    dwCompReadClauseLen: u32,
    dwCompReadClauseOffset: u32,
    dwCompReadStrLen: u32,
    dwCompReadStrOffset: u32,
    dwCompAttrLen: u32,
    dwCompAttrOffset: u32,
    dwCompClauseLen: u32,
    dwCompClauseOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwCursorPos: u32,
    dwDeltaStart: u32,
    dwResultReadClauseLen: u32,
    dwResultReadClauseOffset: u32,
    dwResultReadStrLen: u32,
    dwResultReadStrOffset: u32,
    dwResultClauseLen: u32,
    dwResultClauseOffset: u32,
    dwResultStrLen: u32,
    dwResultStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const GUIDELINE = extern struct {
    dwSize: u32,
    dwLevel: u32,
    dwIndex: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const TRANSMSG = extern struct {
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const TRANSMSGLIST = extern struct {
    uMsgCount: u32,
    TransMsg: [1]TRANSMSG,
};

pub const CANDIDATEINFO = extern struct {
    dwSize: u32,
    dwCount: u32,
    dwOffset: [32]u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const INPUTCONTEXT = extern struct {
    hWnd: ?HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: extern union {
        A: LOGFONTA,
        W: LOGFONTW,
    },
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: [4]CANDIDATEFORM,
    hCompStr: ?HIMCC,
    hCandInfo: ?HIMCC,
    hGuideLine: ?HIMCC,
    hPrivate: ?HIMCC,
    dwNumMsgBuf: u32,
    hMsgBuf: ?HIMCC,
    fdwInit: u32,
    dwReserve: [3]u32,
};

pub const IMEINFO = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};

pub const SOFTKBDDATA = extern struct {
    uCount: u32,
    wCode: [256]u16,
};

pub const APPLETIDLIST = extern struct {
    count: i32,
    pIIDList: ?*Guid,
};

pub const IMESTRINGCANDIDATE = extern struct {
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMEITEM = extern struct {
    cbSize: i32,
    iType: i32,
    lpItemData: ?*anyopaque,
};

pub const IMEITEMCANDIDATE = extern struct {
    uCount: u32,
    imeItem: [1]IMEITEM,
};

pub const tabIMESTRINGINFO = extern struct {
    dwFarEastId: u32,
    lpwstr: ?PWSTR,
};

pub const tabIMEFAREASTINFO = extern struct {
    dwSize: u32,
    dwType: u32,
    dwData: [1]u32,
};

pub const IMESTRINGCANDIDATEINFO = extern struct {
    dwFarEastId: u32,
    lpFarEastInfo: ?*tabIMEFAREASTINFO,
    fInfoMask: u32,
    iSelIndex: i32,
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMECOMPOSITIONSTRINGINFO = extern struct {
    iCompStrLen: i32,
    iCaretPos: i32,
    iEditStart: i32,
    iEditLen: i32,
    iTargetStart: i32,
    iTargetLen: i32,
};

pub const IMECHARINFO = extern struct {
    wch: u16,
    dwCharInfo: u32,
};

pub const IMEAPPLETCFG = extern struct {
    dwConfig: u32,
    wchTitle: [64]u16,
    wchTitleFontFace: [32]u16,
    dwCharSet: u32,
    iCategory: i32,
    hIcon: ?HICON,
    langID: u16,
    dummy: u16,
    lReserved1: LPARAM,
};

pub const IMEAPPLETUI = extern struct {
    hwnd: ?HWND,
    dwStyle: u32,
    width: i32,
    height: i32,
    minWidth: i32,
    minHeight: i32,
    maxWidth: i32,
    maxHeight: i32,
    lReserved1: LPARAM,
    lReserved2: LPARAM,
};

pub const APPLYCANDEXPARAM = extern struct {
    dwSize: u32,
    lpwstrDisplay: ?PWSTR,
    lpwstrReading: ?PWSTR,
    dwReserved: u32,
};

const IID_IImeSpecifyApplets_Value = Guid.initString("5d8e643c-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImeSpecifyApplets = &IID_IImeSpecifyApplets_Value;
pub const IImeSpecifyApplets = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppletIIDList: *const fn (
            self: *const IImeSpecifyApplets,
            refiid: ?*const Guid,
            lp_i_i_d_list: ?*APPLETIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAppletIIDList(self: *const T, refiid_: ?*const Guid, lp_i_i_d_list_: ?*APPLETIDLIST) HRESULT {
                return @as(*const IImeSpecifyApplets.VTable, @ptrCast(self.vtable)).GetAppletIIDList(@as(*const IImeSpecifyApplets, @ptrCast(self)), refiid_, lp_i_i_d_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePadApplet_Value = Guid.initString("5d8e643b-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePadApplet = &IID_IImePadApplet_Value;
pub const IImePadApplet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IImePadApplet,
            lp_i_ime_pad: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: *const fn (
            self: *const IImePadApplet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppletConfig: *const fn (
            self: *const IImePadApplet,
            lp_applet_cfg: ?*IMEAPPLETCFG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUI: *const fn (
            self: *const IImePadApplet,
            hwnd_parent: ?HWND,
            lp_ime_applet_u_i: ?*IMEAPPLETUI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: *const fn (
            self: *const IImePadApplet,
            lp_ime_pad: ?*IUnknown,
            notify: i32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, lp_i_ime_pad_: ?*IUnknown) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IImePadApplet, @ptrCast(self)), lp_i_ime_pad_);
            }
            pub inline fn terminate(self: *const T) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IImePadApplet, @ptrCast(self)));
            }
            pub inline fn getAppletConfig(self: *const T, lp_applet_cfg_: ?*IMEAPPLETCFG) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).GetAppletConfig(@as(*const IImePadApplet, @ptrCast(self)), lp_applet_cfg_);
            }
            pub inline fn createUI(self: *const T, hwnd_parent_: ?HWND, lp_ime_applet_u_i_: ?*IMEAPPLETUI) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).CreateUI(@as(*const IImePadApplet, @ptrCast(self)), hwnd_parent_, lp_ime_applet_u_i_);
            }
            pub inline fn notify(self: *const T, lp_ime_pad_: ?*IUnknown, notify_: i32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Notify(@as(*const IImePadApplet, @ptrCast(self)), lp_ime_pad_, notify_, w_param_, l_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePad_Value = Guid.initString("5d8e643a-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePad = &IID_IImePad_Value;
pub const IImePad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Request: *const fn (
            self: *const IImePad,
            p_i_ime_pad_applet: ?*IImePadApplet,
            req_id: IME_PAD_REQUEST_FLAGS,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn request(self: *const T, p_i_ime_pad_applet_: ?*IImePadApplet, req_id_: IME_PAD_REQUEST_FLAGS, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IImePad.VTable, @ptrCast(self.vtable)).Request(@as(*const IImePad, @ptrCast(self)), p_i_ime_pad_applet_, req_id_, w_param_, l_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IImePlugInDictDictionaryList_Value = Guid.initString("98752974-b0a6-489b-8f6f-bff3769c8eeb");
pub const IID_IImePlugInDictDictionaryList = &IID_IImePlugInDictDictionaryList_Value;
pub const IImePlugInDictDictionaryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDictionariesInUse: *const fn (
            self: *const IImePlugInDictDictionaryList,
            prg_dictionary_g_u_i_d: ?*?*SAFEARRAY,
            prg_date_created: ?*?*SAFEARRAY,
            prgf_encrypted: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDictionary: *const fn (
            self: *const IImePlugInDictDictionaryList,
            bstr_dictionary_g_u_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDictionariesInUse(self: *const T, prg_dictionary_g_u_i_d_: ?*?*SAFEARRAY, prg_date_created_: ?*?*SAFEARRAY, prgf_encrypted_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IImePlugInDictDictionaryList.VTable, @ptrCast(self.vtable)).GetDictionariesInUse(@as(*const IImePlugInDictDictionaryList, @ptrCast(self)), prg_dictionary_g_u_i_d_, prg_date_created_, prgf_encrypted_);
            }
            pub inline fn deleteDictionary(self: *const T, bstr_dictionary_g_u_i_d_: ?BSTR) HRESULT {
                return @as(*const IImePlugInDictDictionaryList.VTable, @ptrCast(self.vtable)).DeleteDictionary(@as(*const IImePlugInDictDictionaryList, @ptrCast(self)), bstr_dictionary_g_u_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CActiveIMM_Value = Guid.initString("4955dd33-b159-11d0-8fcf-00aa006bcc59");
pub const CLSID_CActiveIMM = &CLSID_CActiveIMM_Value;

const IID_IEnumRegisterWordA_Value = Guid.initString("08c03412-f96b-11d0-a475-00aa006bcc59");
pub const IID_IEnumRegisterWordA = &IID_IEnumRegisterWordA_Value;
pub const IEnumRegisterWordA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumRegisterWordA,
            pp_enum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumRegisterWordA,
            ul_count: u32,
            rg_register_word: ?*REGISTERWORDA,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumRegisterWordA,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegisterWordA, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_register_word_: ?*REGISTERWORDA, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegisterWordA, @ptrCast(self)), ul_count_, rg_register_word_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegisterWordA, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegisterWordA, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRegisterWordW_Value = Guid.initString("4955dd31-b159-11d0-8fcf-00aa006bcc59");
pub const IID_IEnumRegisterWordW = &IID_IEnumRegisterWordW_Value;
pub const IEnumRegisterWordW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumRegisterWordW,
            pp_enum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumRegisterWordW,
            ul_count: u32,
            rg_register_word: ?*REGISTERWORDW,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumRegisterWordW,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegisterWordW, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_register_word_: ?*REGISTERWORDW, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegisterWordW, @ptrCast(self)), ul_count_, rg_register_word_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegisterWordW, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegisterWordW, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumInputContext_Value = Guid.initString("09b5eab0-f997-11d1-93d4-0060b067b86e");
pub const IID_IEnumInputContext = &IID_IEnumInputContext_Value;
pub const IEnumInputContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumInputContext,
            pp_enum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumInputContext,
            ul_count: u32,
            rg_input_context: ?*?HIMC,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumInputContext,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumInputContext, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, ul_count_: u32, rg_input_context_: ?*?HIMC, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumInputContext, @ptrCast(self)), ul_count_, rg_input_context_, pc_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumInputContext, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, ul_count_: u32) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumInputContext, @ptrCast(self)), ul_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMRegistrar_Value = Guid.initString("b3458082-bd00-11d1-939b-0060b067b86e");
pub const IID_IActiveIMMRegistrar = &IID_IActiveIMMRegistrar_Value;
pub const IActiveIMMRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterIME: *const fn (
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
            lgid: u16,
            psz_icon_file: ?[*:0]const u16,
            psz_desc: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterIME: *const fn (
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerIME(self: *const T, rclsid_: ?*const Guid, lgid_: u16, psz_icon_file_: ?[*:0]const u16, psz_desc_: ?[*:0]const u16) HRESULT {
                return @as(*const IActiveIMMRegistrar.VTable, @ptrCast(self.vtable)).RegisterIME(@as(*const IActiveIMMRegistrar, @ptrCast(self)), rclsid_, lgid_, psz_icon_file_, psz_desc_);
            }
            pub inline fn unregisterIME(self: *const T, rclsid_: ?*const Guid) HRESULT {
                return @as(*const IActiveIMMRegistrar.VTable, @ptrCast(self.vtable)).UnregisterIME(@as(*const IActiveIMMRegistrar, @ptrCast(self)), rclsid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMMessagePumpOwner_Value = Guid.initString("b5cf2cfa-8aeb-11d1-9364-0060b067b86e");
pub const IID_IActiveIMMMessagePumpOwner = &IID_IActiveIMMMessagePumpOwner_Value;
pub const IActiveIMMMessagePumpOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: *const fn (
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: *const fn (
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTranslateMessage: *const fn (
            self: *const IActiveIMMMessagePumpOwner,
            p_msg: ?*const MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IActiveIMMMessagePumpOwner,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IActiveIMMMessagePumpOwner,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Start(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)));
            }
            pub inline fn end(self: *const T) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).End(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)));
            }
            pub inline fn onTranslateMessage(self: *const T, p_msg_: ?*const MSG) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).OnTranslateMessage(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), p_msg_);
            }
            pub inline fn pause(self: *const T, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Pause(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), pdw_cookie_);
            }
            pub inline fn @"resume"(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Resume(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMApp_Value = Guid.initString("08c0e040-62d1-11d1-9326-0060b067b86e");
pub const IID_IActiveIMMApp = &IID_IActiveIMMApp_Value;
pub const IActiveIMMApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            h_i_m_e: ?HIMC,
            ph_prev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_wnd: ?HWND,
            dw_mode: u32,
            p_data: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_wnd: ?HWND,
            dw_mode: u32,
            p_data: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: *const fn (
            self: *const IActiveIMMApp,
            ph_i_m_c: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_e: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_register: ?PSTR,
            p_data: ?*anyopaque,
            p_enum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_register: ?PWSTR,
            p_data: ?*anyopaque,
            p_enum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            u_escape: u32,
            p_data: ?*anyopaque,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            u_escape: u32,
            p_data: ?*anyopaque,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            u_buf_len: u32,
            p_cand_list: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            u_buf_len: u32,
            p_cand_list: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            pdw_list_size: ?*u32,
            pdw_buf_len: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            pdw_list_size: ?*u32,
            pdw_buf_len: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_candidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            pl_copied: ?*i32,
            p_buf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            pl_copied: ?*i32,
            p_buf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            p_comp_form: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            ph_i_m_c: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            p_src: ?PSTR,
            u_buf_len: u32,
            u_flag: u32,
            p_dst: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            p_src: ?PWSTR,
            u_buf_len: u32,
            u_flag: u32,
            p_dst: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            pfdw_conversion: ?*u32,
            pfdw_sentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            ph_def_wnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_description: ?PSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_description: ?PWSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            p_buf: ?PSTR,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            p_buf: ?PWSTR,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_file_name: ?PSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_file_name: ?PWSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            fdw_index: u32,
            pdw_property: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            n_item: u32,
            p_style_buf: ?*STYLEBUFA,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            n_item: u32,
            p_style_buf: ?*STYLEBUFW,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            ppt_pos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            pu_virtual_key: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: *const fn (
            self: *const IActiveIMMApp,
            sz_i_m_e_file_name: ?PSTR,
            sz_layout_text: ?PSTR,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: *const fn (
            self: *const IActiveIMMApp,
            sz_i_m_e_file_name: ?PWSTR,
            sz_layout_text: ?PWSTR,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: *const fn (
            self: *const IActiveIMMApp,
            h_wnd_i_m_e: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: *const fn (
            self: *const IActiveIMMApp,
            h_wnd_i_m_e: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_action: u32,
            dw_index: u32,
            dw_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_register: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_register: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            p_candidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_comp: ?*anyopaque,
            dw_comp_len: u32,
            p_read: ?*anyopaque,
            dw_read_len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_comp: ?*anyopaque,
            dw_comp_len: u32,
            p_read: ?*anyopaque,
            dw_read_len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            p_comp_form: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            fdw_conversion: u32,
            fdw_sentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            f_open: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            ppt_pos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            dw_hot_key_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_unregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_unregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: *const fn (
            self: *const IActiveIMMApp,
            f_restore_layout: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: *const fn (
            self: *const IActiveIMMApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefWindowProc: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FilterClientWindows: *const fn (
            self: *const IActiveIMMApp,
            aa_class_list: ?*u16,
            u_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            u_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: *const fn (
            self: *const IActiveIMMApp,
            h_k_l: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: *const fn (
            self: *const IActiveIMMApp,
            h_wnd: ?HWND,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: *const fn (
            self: *const IActiveIMMApp,
            id_thread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
            dw_type: u32,
            p_ime_parent_menu: ?*IMEMENUITEMINFOA,
            p_ime_menu: ?*IMEMENUITEMINFOA,
            dw_size: u32,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: *const fn (
            self: *const IActiveIMMApp,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
            dw_type: u32,
            p_ime_parent_menu: ?*IMEMENUITEMINFOW,
            p_ime_menu: ?*IMEMENUITEMINFOW,
            dw_size: u32,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: *const fn (
            self: *const IActiveIMMApp,
            id_thread: u32,
            pp_enum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn associateContext(self: *const T, h_wnd_: ?HWND, h_i_m_e_: ?HIMC, ph_prev_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).AssociateContext(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, h_i_m_e_, ph_prev_);
            }
            pub inline fn configureIMEA(self: *const T, h_k_l_: ?HKL, h_wnd_: ?HWND, dw_mode_: u32, p_data_: ?*REGISTERWORDA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ConfigureIMEA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_wnd_, dw_mode_, p_data_);
            }
            pub inline fn configureIMEW(self: *const T, h_k_l_: ?HKL, h_wnd_: ?HWND, dw_mode_: u32, p_data_: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ConfigureIMEW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_wnd_, dw_mode_, p_data_);
            }
            pub inline fn createContext(self: *const T, ph_i_m_c_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IActiveIMMApp, @ptrCast(self)), ph_i_m_c_);
            }
            pub inline fn destroyContext(self: *const T, h_i_m_e_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).DestroyContext(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_e_);
            }
            pub inline fn enumRegisterWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_register_: ?PSTR, p_data_: ?*anyopaque, p_enum_: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumRegisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_, p_data_, p_enum_);
            }
            pub inline fn enumRegisterWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_register_: ?PWSTR, p_data_: ?*anyopaque, p_enum_: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumRegisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_, p_data_, p_enum_);
            }
            pub inline fn escapeA(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, u_escape_: u32, p_data_: ?*anyopaque, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EscapeA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_i_m_c_, u_escape_, p_data_, pl_result_);
            }
            pub inline fn escapeW(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, u_escape_: u32, p_data_: ?*anyopaque, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EscapeW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_i_m_c_, u_escape_, p_data_, pl_result_);
            }
            pub inline fn getCandidateListA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, u_buf_len_: u32, p_cand_list_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, u_buf_len_, p_cand_list_, pu_copied_);
            }
            pub inline fn getCandidateListW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, u_buf_len_: u32, p_cand_list_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, u_buf_len_, p_cand_list_, pu_copied_);
            }
            pub inline fn getCandidateListCountA(self: *const T, h_i_m_c_: ?HIMC, pdw_list_size_: ?*u32, pdw_buf_len_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListCountA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, pdw_list_size_, pdw_buf_len_);
            }
            pub inline fn getCandidateListCountW(self: *const T, h_i_m_c_: ?HIMC, pdw_list_size_: ?*u32, pdw_buf_len_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListCountW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, pdw_list_size_, pdw_buf_len_);
            }
            pub inline fn getCandidateWindow(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_candidate_: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateWindow(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, p_candidate_);
            }
            pub inline fn getCompositionFontA(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionFontA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn getCompositionFontW(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionFontW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn getCompositionStringA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, pl_copied_: ?*i32, p_buf_: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionStringA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, pl_copied_, p_buf_);
            }
            pub inline fn getCompositionStringW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, pl_copied_: ?*i32, p_buf_: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionStringW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, pl_copied_, p_buf_);
            }
            pub inline fn getCompositionWindow(self: *const T, h_i_m_c_: ?HIMC, p_comp_form_: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionWindow(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, p_comp_form_);
            }
            pub inline fn getContext(self: *const T, h_wnd_: ?HWND, ph_i_m_c_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, ph_i_m_c_);
            }
            pub inline fn getConversionListA(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, p_src_: ?PSTR, u_buf_len_: u32, u_flag_: u32, p_dst_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionListA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_i_m_c_, p_src_, u_buf_len_, u_flag_, p_dst_, pu_copied_);
            }
            pub inline fn getConversionListW(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, p_src_: ?PWSTR, u_buf_len_: u32, u_flag_: u32, p_dst_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionListW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, h_i_m_c_, p_src_, u_buf_len_, u_flag_, p_dst_, pu_copied_);
            }
            pub inline fn getConversionStatus(self: *const T, h_i_m_c_: ?HIMC, pfdw_conversion_: ?*u32, pfdw_sentence_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionStatus(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, pfdw_conversion_, pfdw_sentence_);
            }
            pub inline fn getDefaultIMEWnd(self: *const T, h_wnd_: ?HWND, ph_def_wnd_: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDefaultIMEWnd(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, ph_def_wnd_);
            }
            pub inline fn getDescriptionA(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_description_: ?PSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDescriptionA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, u_buf_len_, sz_description_, pu_copied_);
            }
            pub inline fn getDescriptionW(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_description_: ?PWSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDescriptionW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, u_buf_len_, sz_description_, pu_copied_);
            }
            pub inline fn getGuideLineA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, p_buf_: ?PSTR, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetGuideLineA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, p_buf_, pdw_result_);
            }
            pub inline fn getGuideLineW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, p_buf_: ?PWSTR, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetGuideLineW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, p_buf_, pdw_result_);
            }
            pub inline fn getIMEFileNameA(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_file_name_: ?PSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetIMEFileNameA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, u_buf_len_, sz_file_name_, pu_copied_);
            }
            pub inline fn getIMEFileNameW(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_file_name_: ?PWSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetIMEFileNameW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, u_buf_len_, sz_file_name_, pu_copied_);
            }
            pub inline fn getOpenStatus(self: *const T, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetOpenStatus(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_);
            }
            pub inline fn getProperty(self: *const T, h_k_l_: ?HKL, fdw_index_: u32, pdw_property_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, fdw_index_, pdw_property_);
            }
            pub inline fn getRegisterWordStyleA(self: *const T, h_k_l_: ?HKL, n_item_: u32, p_style_buf_: ?*STYLEBUFA, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, n_item_, p_style_buf_, pu_copied_);
            }
            pub inline fn getRegisterWordStyleW(self: *const T, h_k_l_: ?HKL, n_item_: u32, p_style_buf_: ?*STYLEBUFW, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, n_item_, p_style_buf_, pu_copied_);
            }
            pub inline fn getStatusWindowPos(self: *const T, h_i_m_c_: ?HIMC, ppt_pos_: ?*POINT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetStatusWindowPos(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, ppt_pos_);
            }
            pub inline fn getVirtualKey(self: *const T, h_wnd_: ?HWND, pu_virtual_key_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetVirtualKey(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, pu_virtual_key_);
            }
            pub inline fn installIMEA(self: *const T, sz_i_m_e_file_name_: ?PSTR, sz_layout_text_: ?PSTR, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).InstallIMEA(@as(*const IActiveIMMApp, @ptrCast(self)), sz_i_m_e_file_name_, sz_layout_text_, ph_k_l_);
            }
            pub inline fn installIMEW(self: *const T, sz_i_m_e_file_name_: ?PWSTR, sz_layout_text_: ?PWSTR, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).InstallIMEW(@as(*const IActiveIMMApp, @ptrCast(self)), sz_i_m_e_file_name_, sz_layout_text_, ph_k_l_);
            }
            pub inline fn isIME(self: *const T, h_k_l_: ?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsIME(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_);
            }
            pub inline fn isUIMessageA(self: *const T, h_wnd_i_m_e_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsUIMessageA(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_i_m_e_, msg_, w_param_, l_param_);
            }
            pub inline fn isUIMessageW(self: *const T, h_wnd_i_m_e_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsUIMessageW(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_i_m_e_, msg_, w_param_, l_param_);
            }
            pub inline fn notifyIME(self: *const T, h_i_m_c_: ?HIMC, dw_action_: u32, dw_index_: u32, dw_value_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).NotifyIME(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_action_, dw_index_, dw_value_);
            }
            pub inline fn registerWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_register_: ?PSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).RegisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_);
            }
            pub inline fn registerWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_register_: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).RegisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_);
            }
            pub inline fn releaseContext(self: *const T, h_wnd_: ?HWND, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ReleaseContext(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, h_i_m_c_);
            }
            pub inline fn setCandidateWindow(self: *const T, h_i_m_c_: ?HIMC, p_candidate_: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCandidateWindow(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, p_candidate_);
            }
            pub inline fn setCompositionFontA(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionFontA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn setCompositionFontW(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionFontW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn setCompositionStringA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_comp_: ?*anyopaque, dw_comp_len_: u32, p_read_: ?*anyopaque, dw_read_len_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionStringA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, p_comp_, dw_comp_len_, p_read_, dw_read_len_);
            }
            pub inline fn setCompositionStringW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_comp_: ?*anyopaque, dw_comp_len_: u32, p_read_: ?*anyopaque, dw_read_len_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionStringW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_index_, p_comp_, dw_comp_len_, p_read_, dw_read_len_);
            }
            pub inline fn setCompositionWindow(self: *const T, h_i_m_c_: ?HIMC, p_comp_form_: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionWindow(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, p_comp_form_);
            }
            pub inline fn setConversionStatus(self: *const T, h_i_m_c_: ?HIMC, fdw_conversion_: u32, fdw_sentence_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetConversionStatus(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, fdw_conversion_, fdw_sentence_);
            }
            pub inline fn setOpenStatus(self: *const T, h_i_m_c_: ?HIMC, f_open_: BOOL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetOpenStatus(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, f_open_);
            }
            pub inline fn setStatusWindowPos(self: *const T, h_i_m_c_: ?HIMC, ppt_pos_: ?*POINT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetStatusWindowPos(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, ppt_pos_);
            }
            pub inline fn simulateHotKey(self: *const T, h_wnd_: ?HWND, dw_hot_key_i_d_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SimulateHotKey(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, dw_hot_key_i_d_);
            }
            pub inline fn unregisterWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_unregister_: ?PSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).UnregisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_unregister_);
            }
            pub inline fn unregisterWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_unregister_: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).UnregisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_unregister_);
            }
            pub inline fn activate(self: *const T, f_restore_layout_: BOOL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).Activate(@as(*const IActiveIMMApp, @ptrCast(self)), f_restore_layout_);
            }
            pub inline fn deactivate(self: *const T) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const IActiveIMMApp, @ptrCast(self)));
            }
            pub inline fn onDefWindowProc(self: *const T, h_wnd_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).OnDefWindowProc(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, msg_, w_param_, l_param_, pl_result_);
            }
            pub inline fn filterClientWindows(self: *const T, aa_class_list_: ?*u16, u_size_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).FilterClientWindows(@as(*const IActiveIMMApp, @ptrCast(self)), aa_class_list_, u_size_);
            }
            pub inline fn getCodePageA(self: *const T, h_k_l_: ?HKL, u_code_page_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, u_code_page_);
            }
            pub inline fn getLangId(self: *const T, h_k_l_: ?HKL, plid_: ?*u16) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIMMApp, @ptrCast(self)), h_k_l_, plid_);
            }
            pub inline fn associateContextEx(self: *const T, h_wnd_: ?HWND, h_i_m_c_: ?HIMC, dw_flags_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).AssociateContextEx(@as(*const IActiveIMMApp, @ptrCast(self)), h_wnd_, h_i_m_c_, dw_flags_);
            }
            pub inline fn disableIME(self: *const T, id_thread_: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).DisableIME(@as(*const IActiveIMMApp, @ptrCast(self)), id_thread_);
            }
            pub inline fn getImeMenuItemsA(self: *const T, h_i_m_c_: ?HIMC, dw_flags_: u32, dw_type_: u32, p_ime_parent_menu_: ?*IMEMENUITEMINFOA, p_ime_menu_: ?*IMEMENUITEMINFOA, dw_size_: u32, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetImeMenuItemsA(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_flags_, dw_type_, p_ime_parent_menu_, p_ime_menu_, dw_size_, pdw_result_);
            }
            pub inline fn getImeMenuItemsW(self: *const T, h_i_m_c_: ?HIMC, dw_flags_: u32, dw_type_: u32, p_ime_parent_menu_: ?*IMEMENUITEMINFOW, p_ime_menu_: ?*IMEMENUITEMINFOW, dw_size_: u32, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetImeMenuItemsW(@as(*const IActiveIMMApp, @ptrCast(self)), h_i_m_c_, dw_flags_, dw_type_, p_ime_parent_menu_, p_ime_menu_, dw_size_, pdw_result_);
            }
            pub inline fn enumInputContext(self: *const T, id_thread_: u32, pp_enum_: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumInputContext(@as(*const IActiveIMMApp, @ptrCast(self)), id_thread_, pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMIME_Value = Guid.initString("08c03411-f96b-11d0-a475-00aa006bcc59");
pub const IID_IActiveIMMIME = &IID_IActiveIMMIME_Value;
pub const IActiveIMMIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            h_i_m_e: ?HIMC,
            ph_prev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_wnd: ?HWND,
            dw_mode: u32,
            p_data: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_wnd: ?HWND,
            dw_mode: u32,
            p_data: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: *const fn (
            self: *const IActiveIMMIME,
            ph_i_m_c: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_e: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_register: ?PSTR,
            p_data: ?*anyopaque,
            p_enum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_register: ?PWSTR,
            p_data: ?*anyopaque,
            p_enum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            u_escape: u32,
            p_data: ?*anyopaque,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            u_escape: u32,
            p_data: ?*anyopaque,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            u_buf_len: u32,
            p_cand_list: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            u_buf_len: u32,
            p_cand_list: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            pdw_list_size: ?*u32,
            pdw_buf_len: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            pdw_list_size: ?*u32,
            pdw_buf_len: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_candidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            pl_copied: ?*i32,
            p_buf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            pl_copied: ?*i32,
            p_buf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            p_comp_form: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            ph_i_m_c: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            p_src: ?PSTR,
            u_buf_len: u32,
            u_flag: u32,
            p_dst: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            h_i_m_c: ?HIMC,
            p_src: ?PWSTR,
            u_buf_len: u32,
            u_flag: u32,
            p_dst: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            pfdw_conversion: ?*u32,
            pfdw_sentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            ph_def_wnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_description: ?PSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_description: ?PWSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            p_buf: ?PSTR,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            dw_buf_len: u32,
            p_buf: ?PWSTR,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_file_name: ?PSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            u_buf_len: u32,
            sz_file_name: ?PWSTR,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            fdw_index: u32,
            pdw_property: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            n_item: u32,
            p_style_buf: ?*STYLEBUFA,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            n_item: u32,
            p_style_buf: ?*STYLEBUFW,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            ppt_pos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            pu_virtual_key: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: *const fn (
            self: *const IActiveIMMIME,
            sz_i_m_e_file_name: ?PSTR,
            sz_layout_text: ?PSTR,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: *const fn (
            self: *const IActiveIMMIME,
            sz_i_m_e_file_name: ?PWSTR,
            sz_layout_text: ?PWSTR,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: *const fn (
            self: *const IActiveIMMIME,
            h_wnd_i_m_e: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: *const fn (
            self: *const IActiveIMMIME,
            h_wnd_i_m_e: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_action: u32,
            dw_index: u32,
            dw_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_register: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_register: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            p_candidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_comp: ?*anyopaque,
            dw_comp_len: u32,
            p_read: ?*anyopaque,
            dw_read_len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_comp: ?*anyopaque,
            dw_comp_len: u32,
            p_read: ?*anyopaque,
            dw_read_len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            p_comp_form: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            fdw_conversion: u32,
            fdw_sentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            f_open: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            ppt_pos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            dw_hot_key_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PSTR,
            dw_style: u32,
            sz_unregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_unregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateMessage: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            pp_i_m_c: ?*?*INPUTCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCLockCount: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            pdw_lock_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIMCC: *const fn (
            self: *const IActiveIMMIME,
            dw_size: u32,
            ph_i_m_c_c: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyIMCC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMCC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMCC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReSizeIMCC: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
            dw_size: u32,
            ph_i_m_c_c: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCSize: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
            pdw_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCLockCount: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c_c: ?HIMCC,
            pdw_lock_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHotKey: *const fn (
            self: *const IActiveIMMIME,
            dw_hot_key_i_d: u32,
            pu_modifiers: ?*u32,
            pu_v_key: ?*u32,
            ph_k_l: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotKey: *const fn (
            self: *const IActiveIMMIME,
            dw_hot_key_i_d: u32,
            u_modifiers: u32,
            u_v_key: u32,
            h_k_l: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSoftKeyboard: *const fn (
            self: *const IActiveIMMIME,
            u_type: u32,
            h_owner: ?HWND,
            x: i32,
            y: i32,
            ph_soft_kbd_wnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroySoftKeyboard: *const fn (
            self: *const IActiveIMMIME,
            h_soft_kbd_wnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSoftKeyboard: *const fn (
            self: *const IActiveIMMIME,
            h_soft_kbd_wnd: ?HWND,
            n_cmd_show: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            u_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: *const fn (
            self: *const IActiveIMMIME,
            h_k_l: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeybdEvent: *const fn (
            self: *const IActiveIMMIME,
            lgid_i_m_e: u16,
            b_vk: u8,
            b_scan: u8,
            dw_flags: u32,
            dw_extra_info: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockModal: *const fn (
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockModal: *const fn (
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: *const fn (
            self: *const IActiveIMMIME,
            id_thread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
            dw_type: u32,
            p_ime_parent_menu: ?*IMEMENUITEMINFOA,
            p_ime_menu: ?*IMEMENUITEMINFOA,
            dw_size: u32,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            dw_flags: u32,
            dw_type: u32,
            p_ime_parent_menu: ?*IMEMENUITEMINFOW,
            p_ime_menu: ?*IMEMENUITEMINFOW,
            dw_size: u32,
            pdw_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: *const fn (
            self: *const IActiveIMMIME,
            id_thread: u32,
            pp_enum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageA: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            w_param: WPARAM,
            l_param: LPARAM,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageW: *const fn (
            self: *const IActiveIMMIME,
            h_i_m_c: ?HIMC,
            w_param: WPARAM,
            l_param: LPARAM,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCA: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            u_msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCW: *const fn (
            self: *const IActiveIMMIME,
            h_wnd: ?HWND,
            u_msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSleeping: *const fn (
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn associateContext(self: *const T, h_wnd_: ?HWND, h_i_m_e_: ?HIMC, ph_prev_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).AssociateContext(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, h_i_m_e_, ph_prev_);
            }
            pub inline fn configureIMEA(self: *const T, h_k_l_: ?HKL, h_wnd_: ?HWND, dw_mode_: u32, p_data_: ?*REGISTERWORDA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ConfigureIMEA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_wnd_, dw_mode_, p_data_);
            }
            pub inline fn configureIMEW(self: *const T, h_k_l_: ?HKL, h_wnd_: ?HWND, dw_mode_: u32, p_data_: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ConfigureIMEW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_wnd_, dw_mode_, p_data_);
            }
            pub inline fn createContext(self: *const T, ph_i_m_c_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IActiveIMMIME, @ptrCast(self)), ph_i_m_c_);
            }
            pub inline fn destroyContext(self: *const T, h_i_m_e_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroyContext(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_e_);
            }
            pub inline fn enumRegisterWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_register_: ?PSTR, p_data_: ?*anyopaque, p_enum_: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumRegisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_, p_data_, p_enum_);
            }
            pub inline fn enumRegisterWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_register_: ?PWSTR, p_data_: ?*anyopaque, p_enum_: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumRegisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_, p_data_, p_enum_);
            }
            pub inline fn escapeA(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, u_escape_: u32, p_data_: ?*anyopaque, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EscapeA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_i_m_c_, u_escape_, p_data_, pl_result_);
            }
            pub inline fn escapeW(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, u_escape_: u32, p_data_: ?*anyopaque, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EscapeW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_i_m_c_, u_escape_, p_data_, pl_result_);
            }
            pub inline fn getCandidateListA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, u_buf_len_: u32, p_cand_list_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, u_buf_len_, p_cand_list_, pu_copied_);
            }
            pub inline fn getCandidateListW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, u_buf_len_: u32, p_cand_list_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, u_buf_len_, p_cand_list_, pu_copied_);
            }
            pub inline fn getCandidateListCountA(self: *const T, h_i_m_c_: ?HIMC, pdw_list_size_: ?*u32, pdw_buf_len_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListCountA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, pdw_list_size_, pdw_buf_len_);
            }
            pub inline fn getCandidateListCountW(self: *const T, h_i_m_c_: ?HIMC, pdw_list_size_: ?*u32, pdw_buf_len_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListCountW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, pdw_list_size_, pdw_buf_len_);
            }
            pub inline fn getCandidateWindow(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_candidate_: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateWindow(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, p_candidate_);
            }
            pub inline fn getCompositionFontA(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionFontA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn getCompositionFontW(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionFontW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn getCompositionStringA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, pl_copied_: ?*i32, p_buf_: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionStringA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, pl_copied_, p_buf_);
            }
            pub inline fn getCompositionStringW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, pl_copied_: ?*i32, p_buf_: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionStringW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, pl_copied_, p_buf_);
            }
            pub inline fn getCompositionWindow(self: *const T, h_i_m_c_: ?HIMC, p_comp_form_: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionWindow(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, p_comp_form_);
            }
            pub inline fn getContext(self: *const T, h_wnd_: ?HWND, ph_i_m_c_: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, ph_i_m_c_);
            }
            pub inline fn getConversionListA(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, p_src_: ?PSTR, u_buf_len_: u32, u_flag_: u32, p_dst_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionListA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_i_m_c_, p_src_, u_buf_len_, u_flag_, p_dst_, pu_copied_);
            }
            pub inline fn getConversionListW(self: *const T, h_k_l_: ?HKL, h_i_m_c_: ?HIMC, p_src_: ?PWSTR, u_buf_len_: u32, u_flag_: u32, p_dst_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionListW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, h_i_m_c_, p_src_, u_buf_len_, u_flag_, p_dst_, pu_copied_);
            }
            pub inline fn getConversionStatus(self: *const T, h_i_m_c_: ?HIMC, pfdw_conversion_: ?*u32, pfdw_sentence_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionStatus(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, pfdw_conversion_, pfdw_sentence_);
            }
            pub inline fn getDefaultIMEWnd(self: *const T, h_wnd_: ?HWND, ph_def_wnd_: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDefaultIMEWnd(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, ph_def_wnd_);
            }
            pub inline fn getDescriptionA(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_description_: ?PSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDescriptionA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, u_buf_len_, sz_description_, pu_copied_);
            }
            pub inline fn getDescriptionW(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_description_: ?PWSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDescriptionW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, u_buf_len_, sz_description_, pu_copied_);
            }
            pub inline fn getGuideLineA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, p_buf_: ?PSTR, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetGuideLineA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, p_buf_, pdw_result_);
            }
            pub inline fn getGuideLineW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, dw_buf_len_: u32, p_buf_: ?PWSTR, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetGuideLineW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, dw_buf_len_, p_buf_, pdw_result_);
            }
            pub inline fn getIMEFileNameA(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_file_name_: ?PSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMEFileNameA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, u_buf_len_, sz_file_name_, pu_copied_);
            }
            pub inline fn getIMEFileNameW(self: *const T, h_k_l_: ?HKL, u_buf_len_: u32, sz_file_name_: ?PWSTR, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMEFileNameW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, u_buf_len_, sz_file_name_, pu_copied_);
            }
            pub inline fn getOpenStatus(self: *const T, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetOpenStatus(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_);
            }
            pub inline fn getProperty(self: *const T, h_k_l_: ?HKL, fdw_index_: u32, pdw_property_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, fdw_index_, pdw_property_);
            }
            pub inline fn getRegisterWordStyleA(self: *const T, h_k_l_: ?HKL, n_item_: u32, p_style_buf_: ?*STYLEBUFA, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, n_item_, p_style_buf_, pu_copied_);
            }
            pub inline fn getRegisterWordStyleW(self: *const T, h_k_l_: ?HKL, n_item_: u32, p_style_buf_: ?*STYLEBUFW, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, n_item_, p_style_buf_, pu_copied_);
            }
            pub inline fn getStatusWindowPos(self: *const T, h_i_m_c_: ?HIMC, ppt_pos_: ?*POINT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetStatusWindowPos(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, ppt_pos_);
            }
            pub inline fn getVirtualKey(self: *const T, h_wnd_: ?HWND, pu_virtual_key_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetVirtualKey(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, pu_virtual_key_);
            }
            pub inline fn installIMEA(self: *const T, sz_i_m_e_file_name_: ?PSTR, sz_layout_text_: ?PSTR, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).InstallIMEA(@as(*const IActiveIMMIME, @ptrCast(self)), sz_i_m_e_file_name_, sz_layout_text_, ph_k_l_);
            }
            pub inline fn installIMEW(self: *const T, sz_i_m_e_file_name_: ?PWSTR, sz_layout_text_: ?PWSTR, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).InstallIMEW(@as(*const IActiveIMMIME, @ptrCast(self)), sz_i_m_e_file_name_, sz_layout_text_, ph_k_l_);
            }
            pub inline fn isIME(self: *const T, h_k_l_: ?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsIME(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_);
            }
            pub inline fn isUIMessageA(self: *const T, h_wnd_i_m_e_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsUIMessageA(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_i_m_e_, msg_, w_param_, l_param_);
            }
            pub inline fn isUIMessageW(self: *const T, h_wnd_i_m_e_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsUIMessageW(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_i_m_e_, msg_, w_param_, l_param_);
            }
            pub inline fn notifyIME(self: *const T, h_i_m_c_: ?HIMC, dw_action_: u32, dw_index_: u32, dw_value_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).NotifyIME(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_action_, dw_index_, dw_value_);
            }
            pub inline fn registerWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_register_: ?PSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RegisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_);
            }
            pub inline fn registerWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_register_: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RegisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_register_);
            }
            pub inline fn releaseContext(self: *const T, h_wnd_: ?HWND, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ReleaseContext(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, h_i_m_c_);
            }
            pub inline fn setCandidateWindow(self: *const T, h_i_m_c_: ?HIMC, p_candidate_: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCandidateWindow(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, p_candidate_);
            }
            pub inline fn setCompositionFontA(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionFontA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn setCompositionFontW(self: *const T, h_i_m_c_: ?HIMC, plf_: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionFontW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, plf_);
            }
            pub inline fn setCompositionStringA(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_comp_: ?*anyopaque, dw_comp_len_: u32, p_read_: ?*anyopaque, dw_read_len_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionStringA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, p_comp_, dw_comp_len_, p_read_, dw_read_len_);
            }
            pub inline fn setCompositionStringW(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_comp_: ?*anyopaque, dw_comp_len_: u32, p_read_: ?*anyopaque, dw_read_len_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionStringW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_index_, p_comp_, dw_comp_len_, p_read_, dw_read_len_);
            }
            pub inline fn setCompositionWindow(self: *const T, h_i_m_c_: ?HIMC, p_comp_form_: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionWindow(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, p_comp_form_);
            }
            pub inline fn setConversionStatus(self: *const T, h_i_m_c_: ?HIMC, fdw_conversion_: u32, fdw_sentence_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetConversionStatus(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, fdw_conversion_, fdw_sentence_);
            }
            pub inline fn setOpenStatus(self: *const T, h_i_m_c_: ?HIMC, f_open_: BOOL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetOpenStatus(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, f_open_);
            }
            pub inline fn setStatusWindowPos(self: *const T, h_i_m_c_: ?HIMC, ppt_pos_: ?*POINT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetStatusWindowPos(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, ppt_pos_);
            }
            pub inline fn simulateHotKey(self: *const T, h_wnd_: ?HWND, dw_hot_key_i_d_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SimulateHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, dw_hot_key_i_d_);
            }
            pub inline fn unregisterWordA(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PSTR, dw_style_: u32, sz_unregister_: ?PSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnregisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_unregister_);
            }
            pub inline fn unregisterWordW(self: *const T, h_k_l_: ?HKL, sz_reading_: ?PWSTR, dw_style_: u32, sz_unregister_: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnregisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, sz_reading_, dw_style_, sz_unregister_);
            }
            pub inline fn generateMessage(self: *const T, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GenerateMessage(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_);
            }
            pub inline fn lockIMC(self: *const T, h_i_m_c_: ?HIMC, pp_i_m_c_: ?*?*INPUTCONTEXT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockIMC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, pp_i_m_c_);
            }
            pub inline fn unlockIMC(self: *const T, h_i_m_c_: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockIMC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_);
            }
            pub inline fn getIMCLockCount(self: *const T, h_i_m_c_: ?HIMC, pdw_lock_count_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCLockCount(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, pdw_lock_count_);
            }
            pub inline fn createIMCC(self: *const T, dw_size_: u32, ph_i_m_c_c_: ?*?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), dw_size_, ph_i_m_c_c_);
            }
            pub inline fn destroyIMCC(self: *const T, h_i_m_c_c_: ?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroyIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_);
            }
            pub inline fn lockIMCC(self: *const T, h_i_m_c_c_: ?HIMCC, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_, ppv_);
            }
            pub inline fn unlockIMCC(self: *const T, h_i_m_c_c_: ?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_);
            }
            pub inline fn reSizeIMCC(self: *const T, h_i_m_c_c_: ?HIMCC, dw_size_: u32, ph_i_m_c_c_: ?*?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ReSizeIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_, dw_size_, ph_i_m_c_c_);
            }
            pub inline fn getIMCCSize(self: *const T, h_i_m_c_c_: ?HIMCC, pdw_size_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCCSize(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_, pdw_size_);
            }
            pub inline fn getIMCCLockCount(self: *const T, h_i_m_c_c_: ?HIMCC, pdw_lock_count_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCCLockCount(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_c_, pdw_lock_count_);
            }
            pub inline fn getHotKey(self: *const T, dw_hot_key_i_d_: u32, pu_modifiers_: ?*u32, pu_v_key_: ?*u32, ph_k_l_: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), dw_hot_key_i_d_, pu_modifiers_, pu_v_key_, ph_k_l_);
            }
            pub inline fn setHotKey(self: *const T, dw_hot_key_i_d_: u32, u_modifiers_: u32, u_v_key_: u32, h_k_l_: ?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), dw_hot_key_i_d_, u_modifiers_, u_v_key_, h_k_l_);
            }
            pub inline fn createSoftKeyboard(self: *const T, u_type_: u32, h_owner_: ?HWND, x_: i32, y_: i32, ph_soft_kbd_wnd_: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateSoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), u_type_, h_owner_, x_, y_, ph_soft_kbd_wnd_);
            }
            pub inline fn destroySoftKeyboard(self: *const T, h_soft_kbd_wnd_: ?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroySoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), h_soft_kbd_wnd_);
            }
            pub inline fn showSoftKeyboard(self: *const T, h_soft_kbd_wnd_: ?HWND, n_cmd_show_: i32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ShowSoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), h_soft_kbd_wnd_, n_cmd_show_);
            }
            pub inline fn getCodePageA(self: *const T, h_k_l_: ?HKL, u_code_page_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, u_code_page_);
            }
            pub inline fn getLangId(self: *const T, h_k_l_: ?HKL, plid_: ?*u16) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIMMIME, @ptrCast(self)), h_k_l_, plid_);
            }
            pub inline fn keybdEvent(self: *const T, lgid_i_m_e_: u16, b_vk_: u8, b_scan_: u8, dw_flags_: u32, dw_extra_info_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).KeybdEvent(@as(*const IActiveIMMIME, @ptrCast(self)), lgid_i_m_e_, b_vk_, b_scan_, dw_flags_, dw_extra_info_);
            }
            pub inline fn lockModal(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockModal(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
            pub inline fn unlockModal(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockModal(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
            pub inline fn associateContextEx(self: *const T, h_wnd_: ?HWND, h_i_m_c_: ?HIMC, dw_flags_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).AssociateContextEx(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, h_i_m_c_, dw_flags_);
            }
            pub inline fn disableIME(self: *const T, id_thread_: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DisableIME(@as(*const IActiveIMMIME, @ptrCast(self)), id_thread_);
            }
            pub inline fn getImeMenuItemsA(self: *const T, h_i_m_c_: ?HIMC, dw_flags_: u32, dw_type_: u32, p_ime_parent_menu_: ?*IMEMENUITEMINFOA, p_ime_menu_: ?*IMEMENUITEMINFOA, dw_size_: u32, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetImeMenuItemsA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_flags_, dw_type_, p_ime_parent_menu_, p_ime_menu_, dw_size_, pdw_result_);
            }
            pub inline fn getImeMenuItemsW(self: *const T, h_i_m_c_: ?HIMC, dw_flags_: u32, dw_type_: u32, p_ime_parent_menu_: ?*IMEMENUITEMINFOW, p_ime_menu_: ?*IMEMENUITEMINFOW, dw_size_: u32, pdw_result_: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetImeMenuItemsW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, dw_flags_, dw_type_, p_ime_parent_menu_, p_ime_menu_, dw_size_, pdw_result_);
            }
            pub inline fn enumInputContext(self: *const T, id_thread_: u32, pp_enum_: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumInputContext(@as(*const IActiveIMMIME, @ptrCast(self)), id_thread_, pp_enum_);
            }
            pub inline fn requestMessageA(self: *const T, h_i_m_c_: ?HIMC, w_param_: WPARAM, l_param_: LPARAM, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RequestMessageA(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, w_param_, l_param_, pl_result_);
            }
            pub inline fn requestMessageW(self: *const T, h_i_m_c_: ?HIMC, w_param_: WPARAM, l_param_: LPARAM, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RequestMessageW(@as(*const IActiveIMMIME, @ptrCast(self)), h_i_m_c_, w_param_, l_param_, pl_result_);
            }
            pub inline fn sendIMCA(self: *const T, h_wnd_: ?HWND, u_msg_: u32, w_param_: WPARAM, l_param_: LPARAM, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SendIMCA(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, u_msg_, w_param_, l_param_, pl_result_);
            }
            pub inline fn sendIMCW(self: *const T, h_wnd_: ?HWND, u_msg_: u32, w_param_: WPARAM, l_param_: LPARAM, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SendIMCW(@as(*const IActiveIMMIME, @ptrCast(self)), h_wnd_, u_msg_, w_param_, l_param_, pl_result_);
            }
            pub inline fn isSleeping(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsSleeping(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME_Value = Guid.initString("6fe20962-d077-11d0-8fe7-00aa006bcc59");
pub const IID_IActiveIME = &IID_IActiveIME_Value;
pub const IActiveIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Inquire: *const fn (
            self: *const IActiveIME,
            dw_system_info_flags: u32,
            p_i_m_e_info: ?*IMEINFO,
            sz_wnd_class: ?PWSTR,
            pdw_private: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConversionList: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            sz_source: ?PWSTR,
            u_flag: u32,
            u_buf_len: u32,
            p_dest: ?*CANDIDATELIST,
            pu_copied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: *const fn (
            self: *const IActiveIME,
            h_k_l: ?HKL,
            h_wnd: ?HWND,
            dw_mode: u32,
            p_register_word: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: *const fn (
            self: *const IActiveIME,
            u_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Escape: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            u_escape: u32,
            p_data: ?*anyopaque,
            pl_result: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveContext: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            f_flag: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessKey: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            u_vir_key: u32,
            l_param: u32,
            pb_key_state: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            dw_action: u32,
            dw_index: u32,
            dw_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            f_select: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionString: *const fn (
            self: *const IActiveIME,
            h_i_m_c: ?HIMC,
            dw_index: u32,
            p_comp: ?*anyopaque,
            dw_comp_len: u32,
            p_read: ?*anyopaque,
            dw_read_len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ToAsciiEx: *const fn (
            self: *const IActiveIME,
            u_vir_key: u32,
            u_scan_code: u32,
            pb_key_state: ?*u8,
            fu_state: u32,
            h_i_m_c: ?HIMC,
            pdw_trans_buf: ?*u32,
            pu_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: *const fn (
            self: *const IActiveIME,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_string: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWord: *const fn (
            self: *const IActiveIME,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_string: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyle: *const fn (
            self: *const IActiveIME,
            n_item: u32,
            p_style_buf: ?*STYLEBUFW,
            pu_buf_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWord: *const fn (
            self: *const IActiveIME,
            sz_reading: ?PWSTR,
            dw_style: u32,
            sz_register: ?PWSTR,
            p_data: ?*anyopaque,
            pp_enum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: *const fn (
            self: *const IActiveIME,
            u_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: *const fn (
            self: *const IActiveIME,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn inquire(self: *const T, dw_system_info_flags_: u32, p_i_m_e_info_: ?*IMEINFO, sz_wnd_class_: ?PWSTR, pdw_private_: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Inquire(@as(*const IActiveIME, @ptrCast(self)), dw_system_info_flags_, p_i_m_e_info_, sz_wnd_class_, pdw_private_);
            }
            pub inline fn conversionList(self: *const T, h_i_m_c_: ?HIMC, sz_source_: ?PWSTR, u_flag_: u32, u_buf_len_: u32, p_dest_: ?*CANDIDATELIST, pu_copied_: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ConversionList(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, sz_source_, u_flag_, u_buf_len_, p_dest_, pu_copied_);
            }
            pub inline fn configure(self: *const T, h_k_l_: ?HKL, h_wnd_: ?HWND, dw_mode_: u32, p_register_word_: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Configure(@as(*const IActiveIME, @ptrCast(self)), h_k_l_, h_wnd_, dw_mode_, p_register_word_);
            }
            pub inline fn destroy(self: *const T, u_reserved_: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Destroy(@as(*const IActiveIME, @ptrCast(self)), u_reserved_);
            }
            pub inline fn escape(self: *const T, h_i_m_c_: ?HIMC, u_escape_: u32, p_data_: ?*anyopaque, pl_result_: ?*LRESULT) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Escape(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, u_escape_, p_data_, pl_result_);
            }
            pub inline fn setActiveContext(self: *const T, h_i_m_c_: ?HIMC, f_flag_: BOOL) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).SetActiveContext(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, f_flag_);
            }
            pub inline fn processKey(self: *const T, h_i_m_c_: ?HIMC, u_vir_key_: u32, l_param_: u32, pb_key_state_: ?*u8) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ProcessKey(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, u_vir_key_, l_param_, pb_key_state_);
            }
            pub inline fn notify(self: *const T, h_i_m_c_: ?HIMC, dw_action_: u32, dw_index_: u32, dw_value_: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Notify(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, dw_action_, dw_index_, dw_value_);
            }
            pub inline fn select(self: *const T, h_i_m_c_: ?HIMC, f_select_: BOOL) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Select(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, f_select_);
            }
            pub inline fn setCompositionString(self: *const T, h_i_m_c_: ?HIMC, dw_index_: u32, p_comp_: ?*anyopaque, dw_comp_len_: u32, p_read_: ?*anyopaque, dw_read_len_: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).SetCompositionString(@as(*const IActiveIME, @ptrCast(self)), h_i_m_c_, dw_index_, p_comp_, dw_comp_len_, p_read_, dw_read_len_);
            }
            pub inline fn toAsciiEx(self: *const T, u_vir_key_: u32, u_scan_code_: u32, pb_key_state_: ?*u8, fu_state_: u32, h_i_m_c_: ?HIMC, pdw_trans_buf_: ?*u32, pu_size_: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ToAsciiEx(@as(*const IActiveIME, @ptrCast(self)), u_vir_key_, u_scan_code_, pb_key_state_, fu_state_, h_i_m_c_, pdw_trans_buf_, pu_size_);
            }
            pub inline fn registerWord(self: *const T, sz_reading_: ?PWSTR, dw_style_: u32, sz_string_: ?PWSTR) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).RegisterWord(@as(*const IActiveIME, @ptrCast(self)), sz_reading_, dw_style_, sz_string_);
            }
            pub inline fn unregisterWord(self: *const T, sz_reading_: ?PWSTR, dw_style_: u32, sz_string_: ?PWSTR) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).UnregisterWord(@as(*const IActiveIME, @ptrCast(self)), sz_reading_, dw_style_, sz_string_);
            }
            pub inline fn getRegisterWordStyle(self: *const T, n_item_: u32, p_style_buf_: ?*STYLEBUFW, pu_buf_size_: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyle(@as(*const IActiveIME, @ptrCast(self)), n_item_, p_style_buf_, pu_buf_size_);
            }
            pub inline fn enumRegisterWord(self: *const T, sz_reading_: ?PWSTR, dw_style_: u32, sz_register_: ?PWSTR, p_data_: ?*anyopaque, pp_enum_: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).EnumRegisterWord(@as(*const IActiveIME, @ptrCast(self)), sz_reading_, dw_style_, sz_register_, p_data_, pp_enum_);
            }
            pub inline fn getCodePageA(self: *const T, u_code_page_: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIME, @ptrCast(self)), u_code_page_);
            }
            pub inline fn getLangId(self: *const T, plid_: ?*u16) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIME, @ptrCast(self)), plid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME2_Value = Guid.initString("e1c4bf0e-2d53-11d2-93e1-0060b067b86e");
pub const IID_IActiveIME2 = &IID_IActiveIME2_Value;
pub const IActiveIME2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveIME.VTable,
        Sleep: *const fn (
            self: *const IActiveIME2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unsleep: *const fn (
            self: *const IActiveIME2,
            f_dead: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveIME.MethodMixin(T);
            pub inline fn sleep(self: *const T) HRESULT {
                return @as(*const IActiveIME2.VTable, @ptrCast(self.vtable)).Sleep(@as(*const IActiveIME2, @ptrCast(self)));
            }
            pub inline fn unsleep(self: *const T, f_dead_: BOOL) HRESULT {
                return @as(*const IActiveIME2.VTable, @ptrCast(self.vtable)).Unsleep(@as(*const IActiveIME2, @ptrCast(self)), f_dead_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (82)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmInstallIMEA(
    lpsz_i_m_e_file_name: ?[*:0]const u8,
    lpsz_layout_text: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmInstallIMEW(
    lpsz_i_m_e_file_name: ?[*:0]const u16,
    lpsz_layout_text: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDefaultIMEWnd(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDescriptionA(
    param0: ?HKL,
    lpsz_description: ?[*:0]u8,
    u_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDescriptionW(
    param0: ?HKL,
    lpsz_description: ?[*:0]u16,
    u_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetIMEFileNameA(
    param0: ?HKL,
    lpsz_file_name: ?[*:0]u8,
    u_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetIMEFileNameW(
    param0: ?HKL,
    lpsz_file_name: ?[*:0]u16,
    u_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetProperty(
    param0: ?HKL,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsIME(
    param0: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSimulateHotKey(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmCreateContext() callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDestroyContext(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetContext(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmReleaseContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmAssociateContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmAssociateContextEx(
    param0: ?HWND,
    param1: ?HIMC,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionStringA(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_buf: ?*anyopaque,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionStringW(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_buf: ?*anyopaque,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionStringA(
    param0: ?HIMC,
    dw_index: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lp_comp: ?*anyopaque,
    dw_comp_len: u32,
    // TODO: what to do with BytesParamIndex 5?
    lp_read: ?*anyopaque,
    dw_read_len: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionStringW(
    param0: ?HIMC,
    dw_index: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lp_comp: ?*anyopaque,
    dw_comp_len: u32,
    // TODO: what to do with BytesParamIndex 5?
    lp_read: ?*anyopaque,
    dw_read_len: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListCountA(
    param0: ?HIMC,
    lpdw_list_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListCountW(
    param0: ?HIMC,
    lpdw_list_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListA(
    param0: ?HIMC,
    de_index: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_cand_list: ?*CANDIDATELIST,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListW(
    param0: ?HIMC,
    de_index: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_cand_list: ?*CANDIDATELIST,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetGuideLineA(
    param0: ?HIMC,
    dw_index: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lp_buf: ?PSTR,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetGuideLineW(
    param0: ?HIMC,
    dw_index: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lp_buf: ?PWSTR,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionStatus(
    param0: ?HIMC,
    lpfdw_conversion: ?*u32,
    lpfdw_sentence: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetConversionStatus(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetOpenStatus(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetOpenStatus(
    param0: ?HIMC,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmConfigureIMEA(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmConfigureIMEW(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEscapeA(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEscapeW(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionListA(
    param0: ?HKL,
    param1: ?HIMC,
    lp_src: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    lp_dst: ?*CANDIDATELIST,
    dw_buf_len: u32,
    u_flag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionListW(
    param0: ?HKL,
    param1: ?HIMC,
    lp_src: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    lp_dst: ?*CANDIDATELIST,
    dw_buf_len: u32,
    u_flag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmNotifyIME(
    param0: ?HIMC,
    dw_action: NOTIFY_IME_ACTION,
    dw_index: NOTIFY_IME_INDEX,
    dw_value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetStatusWindowPos(
    param0: ?HIMC,
    lppt_pos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetStatusWindowPos(
    param0: ?HIMC,
    lppt_pos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionWindow(
    param0: ?HIMC,
    lp_comp_form: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionWindow(
    param0: ?HIMC,
    lp_comp_form: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateWindow(
    param0: ?HIMC,
    param1: u32,
    lp_candidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCandidateWindow(
    param0: ?HIMC,
    lp_candidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsUIMessageA(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsUIMessageW(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetVirtualKey(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRegisterWordA(
    param0: ?HKL,
    lpsz_reading: ?[*:0]const u8,
    param2: u32,
    lpsz_register: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRegisterWordW(
    param0: ?HKL,
    lpsz_reading: ?[*:0]const u16,
    param2: u32,
    lpsz_register: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmUnregisterWordA(
    param0: ?HKL,
    lpsz_reading: ?[*:0]const u8,
    param2: u32,
    lpsz_unregister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmUnregisterWordW(
    param0: ?HKL,
    lpsz_reading: ?[*:0]const u16,
    param2: u32,
    lpsz_unregister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetRegisterWordStyleA(
    param0: ?HKL,
    n_item: u32,
    lp_style_buf: [*]STYLEBUFA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetRegisterWordStyleW(
    param0: ?HKL,
    n_item: u32,
    lp_style_buf: [*]STYLEBUFW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumRegisterWordA(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCA,
    lpsz_reading: ?[*:0]const u8,
    param3: u32,
    lpsz_register: ?[*:0]const u8,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumRegisterWordW(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCW,
    lpsz_reading: ?[*:0]const u16,
    param3: u32,
    lpsz_register: ?[*:0]const u16,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDisableIME(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumInputContext(
    id_thread: u32,
    lpfn: ?IMCENUMPROC,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetImeMenuItemsA(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lp_ime_parent_menu: ?*IMEMENUITEMINFOA,
    // TODO: what to do with BytesParamIndex 5?
    lp_ime_menu: ?*IMEMENUITEMINFOA,
    dw_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetImeMenuItemsW(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lp_ime_parent_menu: ?*IMEMENUITEMINFOW,
    // TODO: what to do with BytesParamIndex 5?
    lp_ime_menu: ?*IMEMENUITEMINFOW,
    dw_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDisableTextFrameService(
    id_thread: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "imm32" fn ImmDisableLegacyIME() callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetHotKey(
    param0: u32,
    lpu_modifiers: ?*u32,
    lpu_v_key: ?*u32,
    ph_k_l: ?*isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmSetHotKey(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGenerateMessage(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRequestMessageA(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRequestMessageW(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "imm32" fn ImmCreateSoftKeyboard(
    param0: u32,
    param1: ?HWND,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

pub extern "imm32" fn ImmDestroySoftKeyboard(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmShowSoftKeyboard(
    param0: ?HWND,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmLockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?*INPUTCONTEXT;

pub extern "imm32" fn ImmUnlockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetIMCLockCount(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "imm32" fn ImmCreateIMCC(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmDestroyIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmLockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "imm32" fn ImmUnlockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetIMCCLockCount(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "imm32" fn ImmReSizeIMCC(
    param0: ?HIMCC,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmGetIMCCSize(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (25)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDA;
        pub const STYLEBUF = thismodule.STYLEBUFA;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOA;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCA;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordA;
        pub const ImmInstallIME = thismodule.ImmInstallIMEA;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionA;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameA;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringA;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringA;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountA;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListA;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineA;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontA;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontA;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEA;
        pub const ImmEscape = thismodule.ImmEscapeA;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListA;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageA;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordA;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordA;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleA;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordA;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsA;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageA;
    },
    .wide => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDW;
        pub const STYLEBUF = thismodule.STYLEBUFW;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOW;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCW;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordW;
        pub const ImmInstallIME = thismodule.ImmInstallIMEW;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionW;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameW;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringW;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringW;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountW;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListW;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineW;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontW;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontW;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEW;
        pub const ImmEscape = thismodule.ImmEscapeW;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListW;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageW;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordW;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordW;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleW;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordW;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsW;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const REGISTERWORD = *opaque {};
        pub const STYLEBUF = *opaque {};
        pub const IMEMENUITEMINFO = *opaque {};
        pub const REGISTERWORDENUMPROC = *opaque {};
        pub const IEnumRegisterWord = *opaque {};
        pub const ImmInstallIME = *opaque {};
        pub const ImmGetDescription = *opaque {};
        pub const ImmGetIMEFileName = *opaque {};
        pub const ImmGetCompositionString = *opaque {};
        pub const ImmSetCompositionString = *opaque {};
        pub const ImmGetCandidateListCount = *opaque {};
        pub const ImmGetCandidateList = *opaque {};
        pub const ImmGetGuideLine = *opaque {};
        pub const ImmGetCompositionFont = *opaque {};
        pub const ImmSetCompositionFont = *opaque {};
        pub const ImmConfigureIME = *opaque {};
        pub const ImmEscape = *opaque {};
        pub const ImmGetConversionList = *opaque {};
        pub const ImmIsUIMessage = *opaque {};
        pub const ImmRegisterWord = *opaque {};
        pub const ImmUnregisterWord = *opaque {};
        pub const ImmGetRegisterWordStyle = *opaque {};
        pub const ImmEnumRegisterWord = *opaque {};
        pub const ImmGetImeMenuItems = *opaque {};
        pub const ImmRequestMessage = *opaque {};
    } else struct {
        pub const REGISTERWORD = @compileError("'REGISTERWORD' requires that UNICODE be set to true or false in the root module");
        pub const STYLEBUF = @compileError("'STYLEBUF' requires that UNICODE be set to true or false in the root module");
        pub const IMEMENUITEMINFO = @compileError("'IMEMENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORDENUMPROC = @compileError("'REGISTERWORDENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const IEnumRegisterWord = @compileError("'IEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmInstallIME = @compileError("'ImmInstallIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetDescription = @compileError("'ImmGetDescription' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetIMEFileName = @compileError("'ImmGetIMEFileName' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionString = @compileError("'ImmGetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionString = @compileError("'ImmSetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateListCount = @compileError("'ImmGetCandidateListCount' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateList = @compileError("'ImmGetCandidateList' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetGuideLine = @compileError("'ImmGetGuideLine' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionFont = @compileError("'ImmGetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionFont = @compileError("'ImmSetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmConfigureIME = @compileError("'ImmConfigureIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmEscape = @compileError("'ImmEscape' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetConversionList = @compileError("'ImmGetConversionList' requires that UNICODE be set to true or false in the root module");
        pub const ImmIsUIMessage = @compileError("'ImmIsUIMessage' requires that UNICODE be set to true or false in the root module");
        pub const ImmRegisterWord = @compileError("'ImmRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmUnregisterWord = @compileError("'ImmUnregisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetRegisterWordStyle = @compileError("'ImmGetRegisterWordStyle' requires that UNICODE be set to true or false in the root module");
        pub const ImmEnumRegisterWord = @compileError("'ImmEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetImeMenuItems = @compileError("'ImmGetImeMenuItems' requires that UNICODE be set to true or false in the root module");
        pub const ImmRequestMessage = @compileError("'ImmRequestMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (24)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HICON = @import("../../ui/windows_and_messaging.zig").HICON;
const HIMC = @import("../../globalization.zig").HIMC;
const HIMCC = @import("../../globalization.zig").HIMCC;
const HKL = @import("../../ui/text_services.zig").HKL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IClassFactory = @import("../../system/com.zig").IClassFactory;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LOGFONTA = @import("../../graphics/gdi.zig").LOGFONTA;
const LOGFONTW = @import("../../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const MSG = @import("../../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const SAFEARRAY = @import("../../system/com.zig").SAFEARRAY;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "IMCENUMPROC")) {
        _ = IMCENUMPROC;
    }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCA")) {
        _ = REGISTERWORDENUMPROCA;
    }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCW")) {
        _ = REGISTERWORDENUMPROCW;
    }
    if (@hasDecl(@This(), "PFNLOG")) {
        _ = PFNLOG;
    }
    if (@hasDecl(@This(), "fpCreateIFECommonInstanceType")) {
        _ = fpCreateIFECommonInstanceType;
    }
    if (@hasDecl(@This(), "fpCreateIFELanguageInstanceType")) {
        _ = fpCreateIFELanguageInstanceType;
    }
    if (@hasDecl(@This(), "fpCreateIFEDictionaryInstanceType")) {
        _ = fpCreateIFEDictionaryInstanceType;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
