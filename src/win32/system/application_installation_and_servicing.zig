//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (613)
//--------------------------------------------------------------------------------
pub const UIALL = @as(u32, 32768);
pub const LOGTOKEN_TYPE_MASK = @as(u32, 3);
pub const LOGTOKEN_UNSPECIFIED = @as(u32, 0);
pub const LOGTOKEN_NO_LOG = @as(u32, 1);
pub const LOGTOKEN_SETUPAPI_APPLOG = @as(u32, 2);
pub const LOGTOKEN_SETUPAPI_DEVLOG = @as(u32, 3);
pub const TXTLOG_SETUPAPI_DEVLOG = @as(u32, 1);
pub const TXTLOG_SETUPAPI_CMDLINE = @as(u32, 2);
pub const TXTLOG_SETUPAPI_BITS = @as(u32, 3);
pub const TXTLOG_ERROR = @as(u32, 1);
pub const TXTLOG_WARNING = @as(u32, 2);
pub const TXTLOG_SYSTEM_STATE_CHANGE = @as(u32, 3);
pub const TXTLOG_SUMMARY = @as(u32, 4);
pub const TXTLOG_DETAILS = @as(u32, 5);
pub const TXTLOG_VERBOSE = @as(u32, 6);
pub const TXTLOG_VERY_VERBOSE = @as(u32, 7);
pub const TXTLOG_RESERVED_FLAGS = @as(u32, 65520);
pub const TXTLOG_TIMESTAMP = @as(u32, 65536);
pub const TXTLOG_DEPTH_INCR = @as(u32, 131072);
pub const TXTLOG_DEPTH_DECR = @as(u32, 262144);
pub const TXTLOG_TAB_1 = @as(u32, 524288);
pub const TXTLOG_FLUSH_FILE = @as(u32, 1048576);
pub const TXTLOG_DEVINST = @as(u32, 1);
pub const TXTLOG_INF = @as(u32, 2);
pub const TXTLOG_FILEQ = @as(u32, 4);
pub const TXTLOG_COPYFILES = @as(u32, 8);
pub const TXTLOG_SIGVERIF = @as(u32, 32);
pub const TXTLOG_BACKUP = @as(u32, 128);
pub const TXTLOG_UI = @as(u32, 256);
pub const TXTLOG_UTIL = @as(u32, 512);
pub const TXTLOG_INFDB = @as(u32, 1024);
pub const TXTLOG_DRVSETUP = @as(u32, 4194304);
pub const TXTLOG_POLICY = @as(u32, 8388608);
pub const TXTLOG_NEWDEV = @as(u32, 16777216);
pub const TXTLOG_UMPNPMGR = @as(u32, 33554432);
pub const TXTLOG_DRIVER_STORE = @as(u32, 67108864);
pub const TXTLOG_SETUP = @as(u32, 134217728);
pub const TXTLOG_CMI = @as(u32, 268435456);
pub const TXTLOG_DEVMGR = @as(u32, 536870912);
pub const TXTLOG_INSTALLER = @as(u32, 1073741824);
pub const TXTLOG_VENDOR = @as(u32, 2147483648);
pub const CLSID_EvalCom2 = Guid.initString("6e5e1910-8053-4660-b795-6b612e29bc58");
pub const _WIN32_MSM = @as(u32, 100);
pub const LIBID_MsmMergeTypeLib = Guid.initString("0adda82f-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge2 = Guid.initString("f94985d5-29f9-4743-9805-99bc3f35b678");
pub const _WIN32_MSI = @as(u32, 500);
pub const MAX_GUID_CHARS = @as(u32, 38);
pub const MAX_FEATURE_CHARS = @as(u32, 38);
pub const INSTALLPROPERTY_PACKAGENAME = "PackageName";
pub const INSTALLPROPERTY_TRANSFORMS = "Transforms";
pub const INSTALLPROPERTY_LANGUAGE = "Language";
pub const INSTALLPROPERTY_PRODUCTNAME = "ProductName";
pub const INSTALLPROPERTY_ASSIGNMENTTYPE = "AssignmentType";
pub const INSTALLPROPERTY_INSTANCETYPE = "InstanceType";
pub const INSTALLPROPERTY_AUTHORIZED_LUA_APP = "AuthorizedLUAApp";
pub const INSTALLPROPERTY_PACKAGECODE = "PackageCode";
pub const INSTALLPROPERTY_VERSION = "Version";
pub const INSTALLPROPERTY_PRODUCTICON = "ProductIcon";
pub const INSTALLPROPERTY_INSTALLEDPRODUCTNAME = "InstalledProductName";
pub const INSTALLPROPERTY_VERSIONSTRING = "VersionString";
pub const INSTALLPROPERTY_HELPLINK = "HelpLink";
pub const INSTALLPROPERTY_HELPTELEPHONE = "HelpTelephone";
pub const INSTALLPROPERTY_INSTALLLOCATION = "InstallLocation";
pub const INSTALLPROPERTY_INSTALLSOURCE = "InstallSource";
pub const INSTALLPROPERTY_INSTALLDATE = "InstallDate";
pub const INSTALLPROPERTY_PUBLISHER = "Publisher";
pub const INSTALLPROPERTY_LOCALPACKAGE = "LocalPackage";
pub const INSTALLPROPERTY_URLINFOABOUT = "URLInfoAbout";
pub const INSTALLPROPERTY_URLUPDATEINFO = "URLUpdateInfo";
pub const INSTALLPROPERTY_VERSIONMINOR = "VersionMinor";
pub const INSTALLPROPERTY_VERSIONMAJOR = "VersionMajor";
pub const INSTALLPROPERTY_PRODUCTID = "ProductID";
pub const INSTALLPROPERTY_REGCOMPANY = "RegCompany";
pub const INSTALLPROPERTY_REGOWNER = "RegOwner";
pub const INSTALLPROPERTY_INSTALLEDLANGUAGE = "InstalledLanguage";
pub const INSTALLPROPERTY_UNINSTALLABLE = "Uninstallable";
pub const INSTALLPROPERTY_PRODUCTSTATE = "State";
pub const INSTALLPROPERTY_PATCHSTATE = "State";
pub const INSTALLPROPERTY_PATCHTYPE = "PatchType";
pub const INSTALLPROPERTY_LUAENABLED = "LUAEnabled";
pub const INSTALLPROPERTY_DISPLAYNAME = "DisplayName";
pub const INSTALLPROPERTY_MOREINFOURL = "MoreInfoURL";
pub const INSTALLPROPERTY_LASTUSEDSOURCE = "LastUsedSource";
pub const INSTALLPROPERTY_LASTUSEDTYPE = "LastUsedType";
pub const INSTALLPROPERTY_MEDIAPACKAGEPATH = "MediaPackagePath";
pub const INSTALLPROPERTY_DISKPROMPT = "DiskPrompt";
pub const MSI_INVALID_HASH_IS_FATAL = @as(u32, 1);
pub const ERROR_ROLLBACK_DISABLED = @as(u32, 1653);
pub const MSI_NULL_INTEGER = @as(u32, 2147483648);
pub const INSTALLMESSAGE_TYPEMASK = @as(i32, -16777216);
pub const STREAM_FORMAT_COMPLIB_MODULE = @as(u32, 0);
pub const STREAM_FORMAT_COMPLIB_MANIFEST = @as(u32, 1);
pub const STREAM_FORMAT_WIN32_MODULE = @as(u32, 2);
pub const STREAM_FORMAT_WIN32_MANIFEST = @as(u32, 4);
pub const IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_INSTALLED = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_PAYLOADRESIDENT = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED = @as(u32, 1);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED = @as(u32, 3);
pub const FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID = Guid.initString("8cedc215-ac4b-488b-93c0-a50a49cb2fb8");
pub const FUSION_REFCOUNT_FILEPATH_GUID = Guid.initString("b02f9d65-fb77-4f7a-afa5-b391309f11c9");
pub const FUSION_REFCOUNT_OPAQUE_STRING_GUID = Guid.initString("2ec93463-b0c3-45e1-8364-327e96aea856");
pub const SFC_DISABLE_NORMAL = @as(u32, 0);
pub const SFC_DISABLE_ASK = @as(u32, 1);
pub const SFC_DISABLE_ONCE = @as(u32, 2);
pub const SFC_DISABLE_SETUP = @as(u32, 3);
pub const SFC_DISABLE_NOPOPUPS = @as(u32, 4);
pub const SFC_SCAN_NORMAL = @as(u32, 0);
pub const SFC_SCAN_ALWAYS = @as(u32, 1);
pub const SFC_SCAN_ONCE = @as(u32, 2);
pub const SFC_SCAN_IMMEDIATE = @as(u32, 3);
pub const SFC_QUOTA_DEFAULT = @as(u32, 50);
pub const SFC_IDLE_TRIGGER = "WFP_IDLE_TRIGGER";
pub const IPROPNAME_PRODUCTNAME = "ProductName";
pub const IPROPNAME_PRODUCTCODE = "ProductCode";
pub const IPROPNAME_PRODUCTVERSION = "ProductVersion";
pub const IPROPNAME_INSTALLLANGUAGE = "ProductLanguage";
pub const IPROPNAME_MANUFACTURER = "Manufacturer";
pub const IPROPNAME_UPGRADECODE = "UpgradeCode";
pub const IPROPNAME_PIDTEMPLATE = "PIDTemplate";
pub const IPROPNAME_DISKPROMPT = "DiskPrompt";
pub const IPROPNAME_LEFTUNIT = "LeftUnit";
pub const IPROPNAME_ADMIN_PROPERTIES = "AdminProperties";
pub const IPROPNAME_DEFAULTUIFONT = "DefaultUIFont";
pub const IPROPNAME_ALLOWEDPROPERTIES = "SecureCustomProperties";
pub const IPROPNAME_ENABLEUSERCONTROL = "EnableUserControl";
pub const IPROPNAME_HIDDEN_PROPERTIES = "MsiHiddenProperties";
pub const IPROPNAME_USERNAME = "USERNAME";
pub const IPROPNAME_COMPANYNAME = "COMPANYNAME";
pub const IPROPNAME_PIDKEY = "PIDKEY";
pub const IPROPNAME_PATCH = "PATCH";
pub const IPROPNAME_MSIPATCHREMOVE = "MSIPATCHREMOVE";
pub const IPROPNAME_TARGETDIR = "TARGETDIR";
pub const IPROPNAME_ACTION = "ACTION";
pub const IPROPNAME_LIMITUI = "LIMITUI";
pub const IPROPNAME_LOGACTION = "LOGACTION";
pub const IPROPNAME_ALLUSERS = "ALLUSERS";
pub const IPROPNAME_INSTALLLEVEL = "INSTALLLEVEL";
pub const IPROPNAME_REBOOT = "REBOOT";
pub const IPROPNAME_REBOOTPROMPT = "REBOOTPROMPT";
pub const IPROPNAME_EXECUTEMODE = "EXECUTEMODE";
pub const IPROPVALUE_EXECUTEMODE_NONE = "NONE";
pub const IPROPVALUE_EXECUTEMODE_SCRIPT = "SCRIPT";
pub const IPROPNAME_EXECUTEACTION = "EXECUTEACTION";
pub const IPROPNAME_SOURCELIST = "SOURCELIST";
pub const IPROPNAME_ROOTDRIVE = "ROOTDRIVE";
pub const IPROPNAME_TRANSFORMS = "TRANSFORMS";
pub const IPROPNAME_TRANSFORMSATSOURCE = "TRANSFORMSATSOURCE";
pub const IPROPNAME_TRANSFORMSSECURE = "TRANSFORMSSECURE";
pub const IPROPNAME_SEQUENCE = "SEQUENCE";
pub const IPROPNAME_SHORTFILENAMES = "SHORTFILENAMES";
pub const IPROPNAME_PRIMARYFOLDER = "PRIMARYFOLDER";
pub const IPROPNAME_AFTERREBOOT = "AFTERREBOOT";
pub const IPROPNAME_NOCOMPANYNAME = "NOCOMPANYNAME";
pub const IPROPNAME_NOUSERNAME = "NOUSERNAME";
pub const IPROPNAME_DISABLEROLLBACK = "DISABLEROLLBACK";
pub const IPROPNAME_AVAILABLEFREEREG = "AVAILABLEFREEREG";
pub const IPROPNAME_DISABLEADVTSHORTCUTS = "DISABLEADVTSHORTCUTS";
pub const IPROPNAME_PATCHNEWPACKAGECODE = "PATCHNEWPACKAGECODE";
pub const IPROPNAME_PATCHNEWSUMMARYSUBJECT = "PATCHNEWSUMMARYSUBJECT";
pub const IPROPNAME_PATCHNEWSUMMARYCOMMENTS = "PATCHNEWSUMMARYCOMMENTS";
pub const IPROPNAME_PRODUCTLANGUAGE = "PRODUCTLANGUAGE";
pub const IPROPNAME_CHECKCRCS = "MSICHECKCRCS";
pub const IPROPNAME_MSINODISABLEMEDIA = "MSINODISABLEMEDIA";
pub const IPROPNAME_CARRYINGNDP = "CARRYINGNDP";
pub const IPROPVALUE__CARRYINGNDP_URTREINSTALL = "URTREINSTALL";
pub const IPROPVALUE__CARRYINGNDP_URTUPGRADE = "URTUPGRADE";
pub const IPROPNAME_ENFORCE_UPGRADE_COMPONENT_RULES = "MSIENFORCEUPGRADECOMPONENTRULES";
pub const IPROPNAME_MSINEWINSTANCE = "MSINEWINSTANCE";
pub const IPROPNAME_MSIINSTANCEGUID = "MSIINSTANCEGUID";
pub const IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY = "MSIPACKAGEDOWNLOADLOCALCOPY";
pub const IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY = "MSIPATCHDOWNLOADLOCALCOPY";
pub const IPROPNAME_MSIDISABLELUAPATCHING = "MSIDISABLELUAPATCHING";
pub const IPROPNAME_MSILOGGINGMODE = "MsiLogging";
pub const IPROPNAME_MSILOGFILELOCATION = "MsiLogFileLocation";
pub const IPROPNAME_MSI_RM_CONTROL = "MSIRESTARTMANAGERCONTROL";
pub const IPROPVALUE_MSI_RM_CONTROL_DISABLE = "Disable";
pub const IPROPVALUE_MSI_RM_CONTROL_DISABLESHUTDOWN = "DisableShutdown";
pub const IPROPNAME_MSI_RM_SESSION_KEY = "MsiRestartManagerSessionKey";
pub const IPROPNAME_MSI_REBOOT_PENDING = "MsiSystemRebootPending";
pub const IPROPNAME_MSI_RM_SHUTDOWN = "MSIRMSHUTDOWN";
pub const IPROPNAME_MSI_RM_DISABLE_RESTART = "MSIDISABLERMRESTART";
pub const IPROPNAME_MSI_UAC_DEPLOYMENT_COMPLIANT = "MSIDEPLOYMENTCOMPLIANT";
pub const IPROPNAME_MSI_USE_REAL_ADMIN_DETECTION = "MSIUSEREALADMINDETECTION";
pub const IPROPNAME_MSI_UNINSTALL_SUPERSEDED_COMPONENTS = "MSIUNINSTALLSUPERSEDEDCOMPONENTS";
pub const IPROPNAME_MSIDISABLEEEUI = "MSIDISABLEEEUI";
pub const IPROPNAME_MSI_FASTINSTALL = "MSIFASTINSTALL";
pub const IPROPNAME_INSTALLPERUSER = "MSIINSTALLPERUSER";
pub const IPROPNAME_INTERNALINSTALLEDPERUSER = "MSIINTERNALINSTALLEDPERUSER";
pub const IPROPNAME_ARPAUTHORIZEDCDFPREFIX = "ARPAUTHORIZEDCDFPREFIX";
pub const IPROPNAME_ARPCOMMENTS = "ARPCOMMENTS";
pub const IPROPNAME_ARPCONTACT = "ARPCONTACT";
pub const IPROPNAME_ARPHELPLINK = "ARPHELPLINK";
pub const IPROPNAME_ARPHELPTELEPHONE = "ARPHELPTELEPHONE";
pub const IPROPNAME_ARPINSTALLLOCATION = "ARPINSTALLLOCATION";
pub const IPROPNAME_ARPNOMODIFY = "ARPNOMODIFY";
pub const IPROPNAME_ARPNOREMOVE = "ARPNOREMOVE";
pub const IPROPNAME_ARPNOREPAIR = "ARPNOREPAIR";
pub const IPROPNAME_ARPREADME = "ARPREADME";
pub const IPROPNAME_ARPSIZE = "ARPSIZE";
pub const IPROPNAME_ARPSYSTEMCOMPONENT = "ARPSYSTEMCOMPONENT";
pub const IPROPNAME_ARPURLINFOABOUT = "ARPURLINFOABOUT";
pub const IPROPNAME_ARPURLUPDATEINFO = "ARPURLUPDATEINFO";
pub const IPROPNAME_ARPPRODUCTICON = "ARPPRODUCTICON";
pub const IPROPNAME_ARPSETTINGSIDENTIFIER = "MSIARPSETTINGSIDENTIFIER";
pub const IPROPNAME_ARPSHIMFLAGS = "SHIMFLAGS";
pub const IPROPNAME_ARPSHIMVERSIONNT = "SHIMVERSIONNT";
pub const IPROPNAME_ARPSHIMSERVICEPACKLEVEL = "SHIMSERVICEPACKLEVEL";
pub const IPROPNAME_INSTALLED = "Installed";
pub const IPROPNAME_PRODUCTSTATE = "ProductState";
pub const IPROPNAME_PRESELECTED = "Preselected";
pub const IPROPNAME_RESUME = "RESUME";
pub const IPROPNAME_UPDATESTARTED = "UpdateStarted";
pub const IPROPNAME_PRODUCTID = "ProductID";
pub const IPROPNAME_OUTOFDISKSPACE = "OutOfDiskSpace";
pub const IPROPNAME_OUTOFNORBDISKSPACE = "OutOfNoRbDiskSpace";
pub const IPROPNAME_COSTINGCOMPLETE = "CostingComplete";
pub const IPROPNAME_SOURCEDIR = "SourceDir";
pub const IPROPNAME_REPLACEDINUSEFILES = "ReplacedInUseFiles";
pub const IPROPNAME_PRIMARYFOLDER_PATH = "PrimaryVolumePath";
pub const IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE = "PrimaryVolumeSpaceAvailable";
pub const IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED = "PrimaryVolumeSpaceRequired";
pub const IPROPNAME_PRIMARYFOLDER_SPACEREMAINING = "PrimaryVolumeSpaceRemaining";
pub const IPROPNAME_ISADMINPACKAGE = "IsAdminPackage";
pub const IPROPNAME_ROLLBACKDISABLED = "RollbackDisabled";
pub const IPROPNAME_RESTRICTEDUSERCONTROL = "RestrictedUserControl";
pub const IPROPNAME_SOURCERESONLY = "MsiUISourceResOnly";
pub const IPROPNAME_HIDECANCEL = "MsiUIHideCancel";
pub const IPROPNAME_PROGRESSONLY = "MsiUIProgressOnly";
pub const IPROPNAME_UACONLY = "MsiUIUACOnly";
pub const IPROPNAME_TIME = "Time";
pub const IPROPNAME_DATE = "Date";
pub const IPROPNAME_DATETIME = "DateTime";
pub const IPROPNAME_ARM = "Arm";
pub const IPROPNAME_ARM64 = "Arm64";
pub const IPROPNAME_INTEL = "Intel";
pub const IPROPNAME_TEMPLATE_AMD64 = "AMD64";
pub const IPROPNAME_TEMPLATE_X64 = "x64";
pub const IPROPNAME_MSIAMD64 = "MsiAMD64";
pub const IPROPNAME_MSIX64 = "Msix64";
pub const IPROPNAME_INTEL64 = "Intel64";
pub const IPROPNAME_IA64 = "IA64";
pub const IPROPNAME_TEXTHEIGHT = "TextHeight";
pub const IPROPNAME_TEXTINTERNALLEADING = "TextInternalLeading";
pub const IPROPNAME_SCREENX = "ScreenX";
pub const IPROPNAME_SCREENY = "ScreenY";
pub const IPROPNAME_CAPTIONHEIGHT = "CaptionHeight";
pub const IPROPNAME_BORDERTOP = "BorderTop";
pub const IPROPNAME_BORDERSIDE = "BorderSide";
pub const IPROPNAME_COLORBITS = "ColorBits";
pub const IPROPNAME_PHYSICALMEMORY = "PhysicalMemory";
pub const IPROPNAME_VIRTUALMEMORY = "VirtualMemory";
pub const IPROPNAME_TEXTHEIGHT_CORRECTION = "TextHeightCorrection";
pub const IPROPNAME_MSITABLETPC = "MsiTabletPC";
pub const IPROPNAME_VERSIONNT = "VersionNT";
pub const IPROPNAME_VERSION9X = "Version9X";
pub const IPROPNAME_VERSIONNT64 = "VersionNT64";
pub const IPROPNAME_WINDOWSBUILD = "WindowsBuild";
pub const IPROPNAME_SERVICEPACKLEVEL = "ServicePackLevel";
pub const IPROPNAME_SERVICEPACKLEVELMINOR = "ServicePackLevelMinor";
pub const IPROPNAME_SHAREDWINDOWS = "SharedWindows";
pub const IPROPNAME_COMPUTERNAME = "ComputerName";
pub const IPROPNAME_SHELLADVTSUPPORT = "ShellAdvtSupport";
pub const IPROPNAME_OLEADVTSUPPORT = "OLEAdvtSupport";
pub const IPROPNAME_SYSTEMLANGUAGEID = "SystemLanguageID";
pub const IPROPNAME_TTCSUPPORT = "TTCSupport";
pub const IPROPNAME_TERMSERVER = "TerminalServer";
pub const IPROPNAME_REMOTEADMINTS = "RemoteAdminTS";
pub const IPROPNAME_REDIRECTEDDLLSUPPORT = "RedirectedDllSupport";
pub const IPROPNAME_NTPRODUCTTYPE = "MsiNTProductType";
pub const IPROPNAME_NTSUITEBACKOFFICE = "MsiNTSuiteBackOffice";
pub const IPROPNAME_NTSUITEDATACENTER = "MsiNTSuiteDataCenter";
pub const IPROPNAME_NTSUITEENTERPRISE = "MsiNTSuiteEnterprise";
pub const IPROPNAME_NTSUITESMALLBUSINESS = "MsiNTSuiteSmallBusiness";
pub const IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED = "MsiNTSuiteSmallBusinessRestricted";
pub const IPROPNAME_NTSUITEPERSONAL = "MsiNTSuitePersonal";
pub const IPROPNAME_NTSUITEWEBSERVER = "MsiNTSuiteWebServer";
pub const IPROPNAME_NETASSEMBLYSUPPORT = "MsiNetAssemblySupport";
pub const IPROPNAME_WIN32ASSEMBLYSUPPORT = "MsiWin32AssemblySupport";
pub const IPROPNAME_LOGONUSER = "LogonUser";
pub const IPROPNAME_USERSID = "UserSID";
pub const IPROPNAME_ADMINUSER = "AdminUser";
pub const IPROPNAME_USERLANGUAGEID = "UserLanguageID";
pub const IPROPNAME_PRIVILEGED = "Privileged";
pub const IPROPNAME_RUNNINGELEVATED = "MsiRunningElevated";
pub const IPROPNAME_TRUEADMINUSER = "MsiTrueAdminUser";
pub const IPROPNAME_WINDOWS_FOLDER = "WindowsFolder";
pub const IPROPNAME_SYSTEM_FOLDER = "SystemFolder";
pub const IPROPNAME_SYSTEM16_FOLDER = "System16Folder";
pub const IPROPNAME_WINDOWS_VOLUME = "WindowsVolume";
pub const IPROPNAME_TEMP_FOLDER = "TempFolder";
pub const IPROPNAME_PROGRAMFILES_FOLDER = "ProgramFilesFolder";
pub const IPROPNAME_COMMONFILES_FOLDER = "CommonFilesFolder";
pub const IPROPNAME_SYSTEM64_FOLDER = "System64Folder";
pub const IPROPNAME_PROGRAMFILES64_FOLDER = "ProgramFiles64Folder";
pub const IPROPNAME_COMMONFILES64_FOLDER = "CommonFiles64Folder";
pub const IPROPNAME_STARTMENU_FOLDER = "StartMenuFolder";
pub const IPROPNAME_PROGRAMMENU_FOLDER = "ProgramMenuFolder";
pub const IPROPNAME_STARTUP_FOLDER = "StartupFolder";
pub const IPROPNAME_NETHOOD_FOLDER = "NetHoodFolder";
pub const IPROPNAME_PERSONAL_FOLDER = "PersonalFolder";
pub const IPROPNAME_SENDTO_FOLDER = "SendToFolder";
pub const IPROPNAME_DESKTOP_FOLDER = "DesktopFolder";
pub const IPROPNAME_TEMPLATE_FOLDER = "TemplateFolder";
pub const IPROPNAME_FONTS_FOLDER = "FontsFolder";
pub const IPROPNAME_FAVORITES_FOLDER = "FavoritesFolder";
pub const IPROPNAME_RECENT_FOLDER = "RecentFolder";
pub const IPROPNAME_APPDATA_FOLDER = "AppDataFolder";
pub const IPROPNAME_PRINTHOOD_FOLDER = "PrintHoodFolder";
pub const IPROPNAME_ADMINTOOLS_FOLDER = "AdminToolsFolder";
pub const IPROPNAME_COMMONAPPDATA_FOLDER = "CommonAppDataFolder";
pub const IPROPNAME_LOCALAPPDATA_FOLDER = "LocalAppDataFolder";
pub const IPROPNAME_MYPICTURES_FOLDER = "MyPicturesFolder";
pub const IPROPNAME_FEATUREADDLOCAL = "ADDLOCAL";
pub const IPROPNAME_FEATUREADDSOURCE = "ADDSOURCE";
pub const IPROPNAME_FEATUREADDDEFAULT = "ADDDEFAULT";
pub const IPROPNAME_FEATUREREMOVE = "REMOVE";
pub const IPROPNAME_FEATUREADVERTISE = "ADVERTISE";
pub const IPROPVALUE_FEATURE_ALL = "ALL";
pub const IPROPNAME_COMPONENTADDLOCAL = "COMPADDLOCAL";
pub const IPROPNAME_COMPONENTADDSOURCE = "COMPADDSOURCE";
pub const IPROPNAME_COMPONENTADDDEFAULT = "COMPADDDEFAULT";
pub const IPROPNAME_FILEADDLOCAL = "FILEADDLOCAL";
pub const IPROPNAME_FILEADDSOURCE = "FILEADDSOURCE";
pub const IPROPNAME_FILEADDDEFAULT = "FILEADDDEFAULT";
pub const IPROPNAME_REINSTALL = "REINSTALL";
pub const IPROPNAME_REINSTALLMODE = "REINSTALLMODE";
pub const IPROPNAME_PROMPTROLLBACKCOST = "PROMPTROLLBACKCOST";
pub const IPROPVALUE_RBCOST_PROMPT = "P";
pub const IPROPVALUE_RBCOST_SILENT = "D";
pub const IPROPVALUE_RBCOST_FAIL = "F";
pub const IPROPNAME_CUSTOMACTIONDATA = "CustomActionData";
pub const IACTIONNAME_INSTALL = "INSTALL";
pub const IACTIONNAME_ADVERTISE = "ADVERTISE";
pub const IACTIONNAME_ADMIN = "ADMIN";
pub const IACTIONNAME_SEQUENCE = "SEQUENCE";
pub const IACTIONNAME_COLLECTUSERINFO = "CollectUserInfo";
pub const IACTIONNAME_FIRSTRUN = "FirstRun";
pub const PID_TITLE = @as(u32, 2);
pub const PID_SUBJECT = @as(u32, 3);
pub const PID_AUTHOR = @as(u32, 4);
pub const PID_KEYWORDS = @as(u32, 5);
pub const PID_COMMENTS = @as(u32, 6);
pub const PID_TEMPLATE = @as(u32, 7);
pub const PID_LASTAUTHOR = @as(u32, 8);
pub const PID_REVNUMBER = @as(u32, 9);
pub const PID_EDITTIME = @as(u32, 10);
pub const PID_LASTPRINTED = @as(u32, 11);
pub const PID_CREATE_DTM = @as(u32, 12);
pub const PID_LASTSAVE_DTM = @as(u32, 13);
pub const PID_PAGECOUNT = @as(u32, 14);
pub const PID_WORDCOUNT = @as(u32, 15);
pub const PID_CHARCOUNT = @as(u32, 16);
pub const PID_THUMBNAIL = @as(u32, 17);
pub const PID_APPNAME = @as(u32, 18);
pub const PID_MSIVERSION = @as(u32, 14);
pub const PID_MSISOURCE = @as(u32, 15);
pub const PID_MSIRESTRICT = @as(u32, 16);
pub const PATCH_OPTION_USE_BEST = @as(u32, 0);
pub const PATCH_OPTION_USE_LZX_BEST = @as(u32, 3);
pub const PATCH_OPTION_USE_LZX_A = @as(u32, 1);
pub const PATCH_OPTION_USE_LZX_B = @as(u32, 2);
pub const PATCH_OPTION_USE_LZX_LARGE = @as(u32, 4);
pub const PATCH_OPTION_NO_BINDFIX = @as(u32, 65536);
pub const PATCH_OPTION_NO_LOCKFIX = @as(u32, 131072);
pub const PATCH_OPTION_NO_REBASE = @as(u32, 262144);
pub const PATCH_OPTION_FAIL_IF_SAME_FILE = @as(u32, 524288);
pub const PATCH_OPTION_FAIL_IF_BIGGER = @as(u32, 1048576);
pub const PATCH_OPTION_NO_CHECKSUM = @as(u32, 2097152);
pub const PATCH_OPTION_NO_RESTIMEFIX = @as(u32, 4194304);
pub const PATCH_OPTION_NO_TIMESTAMP = @as(u32, 8388608);
pub const PATCH_OPTION_SIGNATURE_MD5 = @as(u32, 16777216);
pub const PATCH_OPTION_INTERLEAVE_FILES = @as(u32, 1073741824);
pub const PATCH_OPTION_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_OPTION_VALID_FLAGS = @as(u32, 3237937159);
pub const PATCH_SYMBOL_NO_IMAGEHLP = @as(u32, 1);
pub const PATCH_SYMBOL_NO_FAILURES = @as(u32, 2);
pub const PATCH_SYMBOL_UNDECORATED_TOO = @as(u32, 4);
pub const PATCH_SYMBOL_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_TRANSFORM_PE_RESOURCE_2 = @as(u32, 256);
pub const PATCH_TRANSFORM_PE_IRELOC_2 = @as(u32, 512);
pub const APPLY_OPTION_FAIL_IF_EXACT = @as(u32, 1);
pub const APPLY_OPTION_FAIL_IF_CLOSE = @as(u32, 2);
pub const APPLY_OPTION_TEST_ONLY = @as(u32, 4);
pub const APPLY_OPTION_VALID_FLAGS = @as(u32, 7);
pub const ERROR_PATCH_ENCODE_FAILURE = @as(u32, 3222155521);
pub const ERROR_PATCH_INVALID_OPTIONS = @as(u32, 3222155522);
pub const ERROR_PATCH_SAME_FILE = @as(u32, 3222155523);
pub const ERROR_PATCH_RETAIN_RANGES_DIFFER = @as(u32, 3222155524);
pub const ERROR_PATCH_BIGGER_THAN_COMPRESSED = @as(u32, 3222155525);
pub const ERROR_PATCH_IMAGEHLP_FAILURE = @as(u32, 3222155526);
pub const ERROR_PATCH_DECODE_FAILURE = @as(u32, 3222159617);
pub const ERROR_PATCH_CORRUPT = @as(u32, 3222159618);
pub const ERROR_PATCH_NEWER_FORMAT = @as(u32, 3222159619);
pub const ERROR_PATCH_WRONG_FILE = @as(u32, 3222159620);
pub const ERROR_PATCH_NOT_NECESSARY = @as(u32, 3222159621);
pub const ERROR_PATCH_NOT_AVAILABLE = @as(u32, 3222159622);
pub const ERROR_PCW_BASE = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_DOESNT_EXIST = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_BAD_FORMAT = @as(u32, 3222163714);
pub const ERROR_PCW_CANT_CREATE_TEMP_FOLDER = @as(u32, 3222163715);
pub const ERROR_PCW_MISSING_PATCH_PATH = @as(u32, 3222163716);
pub const ERROR_PCW_CANT_OVERWRITE_PATCH = @as(u32, 3222163717);
pub const ERROR_PCW_CANT_CREATE_PATCH_FILE = @as(u32, 3222163718);
pub const ERROR_PCW_MISSING_PATCH_GUID = @as(u32, 3222163719);
pub const ERROR_PCW_BAD_PATCH_GUID = @as(u32, 3222163720);
pub const ERROR_PCW_BAD_GUIDS_TO_REPLACE = @as(u32, 3222163721);
pub const ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST = @as(u32, 3222163722);
pub const ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH = @as(u32, 3222163723);
pub const ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS = @as(u32, 3222163725);
pub const ERROR_PCW_OODS_COPYING_MSI = @as(u32, 3222163726);
pub const ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG = @as(u32, 3222163727);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_NAME = @as(u32, 3222163728);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_NAME = @as(u32, 3222163729);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG = @as(u32, 3222163730);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY = @as(u32, 3222163731);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163732);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI = @as(u32, 3222163733);
pub const ERROR_PCW_UPGRADED_IMAGE_COMPRESSED = @as(u32, 3222163734);
pub const ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG = @as(u32, 3222163735);
pub const ERROR_PCW_BAD_TARGET_IMAGE_NAME = @as(u32, 3222163736);
pub const ERROR_PCW_DUP_TARGET_IMAGE_NAME = @as(u32, 3222163737);
pub const ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG = @as(u32, 3222163738);
pub const ERROR_PCW_TARGET_IMAGE_PATH_EMPTY = @as(u32, 3222163739);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163740);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI = @as(u32, 3222163741);
pub const ERROR_PCW_TARGET_IMAGE_COMPRESSED = @as(u32, 3222163742);
pub const ERROR_PCW_TARGET_BAD_PROD_VALIDATE = @as(u32, 3222163743);
pub const ERROR_PCW_TARGET_BAD_PROD_CODE_VAL = @as(u32, 3222163744);
pub const ERROR_PCW_UPGRADED_MISSING_SRC_FILES = @as(u32, 3222163745);
pub const ERROR_PCW_TARGET_MISSING_SRC_FILES = @as(u32, 3222163746);
pub const ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG = @as(u32, 3222163747);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_NAME = @as(u32, 3222163748);
pub const ERROR_PCW_DUP_IMAGE_FAMILY_NAME = @as(u32, 3222163749);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP = @as(u32, 3222163750);
pub const ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163751);
pub const ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163752);
pub const ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163753);
pub const ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY = @as(u32, 3222163754);
pub const ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163755);
pub const ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD = @as(u32, 3222163756);
pub const ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE = @as(u32, 3222163757);
pub const ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE = @as(u32, 3222163758);
pub const ERROR_PCW_EXTFILE_MISSING_FILE = @as(u32, 3222163759);
pub const ERROR_PCW_BAD_FILE_SEQUENCE_START = @as(u32, 3222163770);
pub const ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER = @as(u32, 3222163771);
pub const ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE = @as(u32, 3222163772);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_DISKID = @as(u32, 3222163773);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART = @as(u32, 3222163774);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY = @as(u32, 3222163775);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED = @as(u32, 3222163776);
pub const ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE = @as(u32, 3222163777);
pub const ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD = @as(u32, 3222163778);
pub const ERROR_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222163779);
pub const ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222163780);
pub const ERROR_PCW_CANNOT_WRITE_DDF = @as(u32, 3222163781);
pub const ERROR_PCW_CANNOT_RUN_MAKECAB = @as(u32, 3222163782);
pub const ERROR_PCW_WRITE_SUMMARY_PROPERTIES = @as(u32, 3222163787);
pub const ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163788);
pub const ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163789);
pub const ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163790);
pub const ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD = @as(u32, 3222163791);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG = @as(u32, 3222163792);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST = @as(u32, 3222163793);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI = @as(u32, 3222163794);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE = @as(u32, 3222163795);
pub const ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD = @as(u32, 3222163796);
pub const ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY = @as(u32, 3222163797);
pub const ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163798);
pub const ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY = @as(u32, 3222163799);
pub const ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG = @as(u32, 3222163800);
pub const ERROR_PCW_BAD_FAMILY_RANGE_NAME = @as(u32, 3222163801);
pub const ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY = @as(u32, 3222163802);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163803);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS = @as(u32, 3222163804);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS = @as(u32, 3222163805);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS = @as(u32, 3222163806);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS = @as(u32, 3222163807);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS = @as(u32, 3222163808);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS = @as(u32, 3222163809);
pub const ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH = @as(u32, 3222163810);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS = @as(u32, 3222163811);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS = @as(u32, 3222163812);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS = @as(u32, 3222163813);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS = @as(u32, 3222163814);
pub const ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH = @as(u32, 3222163815);
pub const ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS = @as(u32, 3222163816);
pub const ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS = @as(u32, 3222163817);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS = @as(u32, 3222163819);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS = @as(u32, 3222163820);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS = @as(u32, 3222163821);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS = @as(u32, 3222163822);
pub const ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH = @as(u32, 3222163823);
pub const ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS = @as(u32, 3222163824);
pub const ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS = @as(u32, 3222163825);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM = @as(u32, 3222163827);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO = @as(u32, 3222163828);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND = @as(u32, 3222163829);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND = @as(u32, 3222163830);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE = @as(u32, 3222163831);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION = @as(u32, 3222163832);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE = @as(u32, 3222163833);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE = @as(u32, 3222163834);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION = @as(u32, 3222163835);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE = @as(u32, 3222163836);
pub const ERROR_PCW_MATCHED_PRODUCT_VERSIONS = @as(u32, 3222163837);
pub const ERROR_PCW_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222163838);
pub const ERROR_PCW_OBSOLETION_WITH_MSI30 = @as(u32, 3222163839);
pub const ERROR_PCW_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222163840);
pub const ERROR_PCW_CANNOT_CREATE_TABLE = @as(u32, 3222163841);
pub const ERROR_PCW_CANT_GENERATE_SEQUENCEINFO_MAJORUPGD = @as(u32, 3222163842);
pub const ERROR_PCW_MAJOR_UPGD_WITHOUT_SEQUENCING = @as(u32, 3222163843);
pub const ERROR_PCW_BAD_PRODUCTVERSION_VALIDATION = @as(u32, 3222163844);
pub const ERROR_PCW_BAD_TRANSFORMSET = @as(u32, 3222163845);
pub const ERROR_PCW_BAD_TGT_UPD_IMAGES = @as(u32, 3222163846);
pub const ERROR_PCW_BAD_SUPERCEDENCE = @as(u32, 3222163847);
pub const ERROR_PCW_BAD_SEQUENCE = @as(u32, 3222163848);
pub const ERROR_PCW_BAD_TARGET = @as(u32, 3222163849);
pub const ERROR_PCW_NULL_PATCHFAMILY = @as(u32, 3222163850);
pub const ERROR_PCW_NULL_SEQUENCE_NUMBER = @as(u32, 3222163851);
pub const ERROR_PCW_BAD_VERSION_STRING = @as(u32, 3222163852);
pub const ERROR_PCW_BAD_MAJOR_VERSION = @as(u32, 3222163853);
pub const ERROR_PCW_SEQUENCING_BAD_TARGET = @as(u32, 3222163854);
pub const ERROR_PCW_PATCHMETADATA_PROP_NOT_SET = @as(u32, 3222163855);
pub const ERROR_PCW_INVALID_PATCHMETADATA_PROP = @as(u32, 3222163856);
pub const ERROR_PCW_INVALID_SUPERCEDENCE = @as(u32, 3222163857);
pub const ERROR_PCW_DUPLICATE_SEQUENCE_RECORD = @as(u32, 3222163858);
pub const ERROR_PCW_WRONG_PATCHMETADATA_STRD_PROP = @as(u32, 3222163859);
pub const ERROR_PCW_INVALID_PARAMETER = @as(u32, 3222163860);
pub const ERROR_PCW_CREATEFILE_LOG_FAILED = @as(u32, 3222163861);
pub const ERROR_PCW_INVALID_LOG_LEVEL = @as(u32, 3222163862);
pub const ERROR_PCW_INVALID_UI_LEVEL = @as(u32, 3222163863);
pub const ERROR_PCW_ERROR_WRITING_TO_LOG = @as(u32, 3222163864);
pub const ERROR_PCW_OUT_OF_MEMORY = @as(u32, 3222163865);
pub const ERROR_PCW_UNKNOWN_ERROR = @as(u32, 3222163866);
pub const ERROR_PCW_UNKNOWN_INFO = @as(u32, 3222163867);
pub const ERROR_PCW_UNKNOWN_WARN = @as(u32, 3222163868);
pub const ERROR_PCW_OPEN_VIEW = @as(u32, 3222163869);
pub const ERROR_PCW_EXECUTE_VIEW = @as(u32, 3222163870);
pub const ERROR_PCW_VIEW_FETCH = @as(u32, 3222163871);
pub const ERROR_PCW_FAILED_EXPAND_PATH = @as(u32, 3222163872);
pub const ERROR_PCW_INTERNAL_ERROR = @as(u32, 3222163969);
pub const ERROR_PCW_INVALID_PCP_PROPERTY = @as(u32, 3222163970);
pub const ERROR_PCW_INVALID_PCP_TARGETIMAGES = @as(u32, 3222163971);
pub const ERROR_PCW_LAX_VALIDATION_FLAGS = @as(u32, 3222163972);
pub const ERROR_PCW_FAILED_CREATE_TRANSFORM = @as(u32, 3222163973);
pub const ERROR_PCW_CANT_DELETE_TEMP_FOLDER = @as(u32, 3222163974);
pub const ERROR_PCW_MISSING_DIRECTORY_TABLE = @as(u32, 3222163975);
pub const ERROR_PCW_INVALID_SUPERSEDENCE_VALUE = @as(u32, 3222163976);
pub const ERROR_PCW_INVALID_PATCH_TYPE_SEQUENCING = @as(u32, 3222163977);
pub const ERROR_PCW_CANT_READ_FILE = @as(u32, 3222163978);
pub const ERROR_PCW_TARGET_WRONG_PRODUCT_VERSION_COMP = @as(u32, 3222163979);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILESTOIGNORE = @as(u32, 3222163980);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDIMAGES = @as(u32, 3222163981);
pub const ERROR_PCW_INVALID_PCP_EXTERNALFILES = @as(u32, 3222163982);
pub const ERROR_PCW_INVALID_PCP_IMAGEFAMILIES = @as(u32, 3222163983);
pub const ERROR_PCW_INVALID_PCP_PATCHSEQUENCE = @as(u32, 3222163984);
pub const ERROR_PCW_INVALID_PCP_TARGETFILES_OPTIONALDATA = @as(u32, 3222163985);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILES_OPTIONALDATA = @as(u32, 3222163986);
pub const ERROR_PCW_MISSING_PATCHMETADATA = @as(u32, 3222163987);
pub const ERROR_PCW_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163988);
pub const ERROR_PCW_INVALID_RANGE_ELEMENT = @as(u32, 3222163989);
pub const ERROR_PCW_INVALID_MAJOR_VERSION = @as(u32, 3222163990);
pub const ERROR_PCW_INVALID_PCP_PROPERTIES = @as(u32, 3222163991);
pub const ERROR_PCW_INVALID_PCP_FAMILYFILERANGES = @as(u32, 3222163992);
pub const INFO_BASE = @as(u32, 3222229249);
pub const INFO_PASSED_MAIN_CONTROL = @as(u32, 3222229249);
pub const INFO_ENTERING_PHASE_I_VALIDATION = @as(u32, 3222229250);
pub const INFO_ENTERING_PHASE_I = @as(u32, 3222229251);
pub const INFO_PCP_PATH = @as(u32, 3222229252);
pub const INFO_TEMP_DIR = @as(u32, 3222229253);
pub const INFO_SET_OPTIONS = @as(u32, 3222229254);
pub const INFO_PROPERTY = @as(u32, 3222229255);
pub const INFO_ENTERING_PHASE_II = @as(u32, 3222229256);
pub const INFO_ENTERING_PHASE_III = @as(u32, 3222229257);
pub const INFO_ENTERING_PHASE_IV = @as(u32, 3222229258);
pub const INFO_ENTERING_PHASE_V = @as(u32, 3222229259);
pub const INFO_GENERATING_METADATA = @as(u32, 3222229265);
pub const INFO_TEMP_DIR_CLEANUP = @as(u32, 3222229266);
pub const INFO_PATCHCACHE_FILEINFO_FAILURE = @as(u32, 3222229267);
pub const INFO_PATCHCACHE_PCI_READFAILURE = @as(u32, 3222229268);
pub const INFO_PATCHCACHE_PCI_WRITEFAILURE = @as(u32, 3222229269);
pub const INFO_USING_USER_MSI_FOR_PATCH_TABLES = @as(u32, 3222229270);
pub const INFO_SUCCESSFUL_PATCH_CREATION = @as(u32, 3222229271);
pub const WARN_BASE = @as(u32, 3222294785);
pub const WARN_MAJOR_UPGRADE_PATCH = @as(u32, 3222294785);
pub const WARN_SEQUENCE_DATA_GENERATION_DISABLED = @as(u32, 3222294786);
pub const WARN_SEQUENCE_DATA_SUPERSEDENCE_IGNORED = @as(u32, 3222294787);
pub const WARN_IMPROPER_TRANSFORM_VALIDATION = @as(u32, 3222294788);
pub const WARN_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222294789);
pub const WARN_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222294790);
pub const WARN_INVALID_TRANSFORM_VALIDATION = @as(u32, 3222294791);
pub const WARN_BAD_MAJOR_VERSION = @as(u32, 3222294792);
pub const WARN_FILE_VERSION_DOWNREV = @as(u32, 3222294793);
pub const WARN_EQUAL_FILE_VERSION = @as(u32, 3222294794);
pub const WARN_PATCHPROPERTYNOTSET = @as(u32, 3222294795);
pub const WARN_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222294802);
pub const WARN_OBSOLETION_WITH_MSI30 = @as(u32, 3222294801);
pub const WARN_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222294803);
pub const DELTA_MAX_HASH_SIZE = @as(u32, 32);
pub const cchMaxInteger = @as(i32, 12);
pub const LOGNONE = @as(u32, 0);
pub const LOGINFO = @as(u32, 1);
pub const LOGWARN = @as(u32, 2);
pub const LOGERR = @as(u32, 4);
pub const LOGPERFMESSAGES = @as(u32, 8);
pub const LOGALL = @as(u32, 15);
pub const UINONE = @as(u32, 0);
pub const UILOGBITS = @as(u32, 15);
pub const DEFAULT_MINIMUM_REQUIRED_MSI_VERSION = @as(u32, 100);
pub const DEFAULT_FILE_SEQUENCE_START = @as(u32, 2);
pub const DEFAULT_DISK_ID = @as(u32, 2);

//--------------------------------------------------------------------------------
// Section: Types (179)
//--------------------------------------------------------------------------------
pub const MSIASSEMBLYINFO = enum(u32) {
    NETASSEMBLY = 0,
    WIN32ASSEMBLY = 1,
};
pub const MSIASSEMBLYINFO_NETASSEMBLY = MSIASSEMBLYINFO.NETASSEMBLY;
pub const MSIASSEMBLYINFO_WIN32ASSEMBLY = MSIASSEMBLYINFO.WIN32ASSEMBLY;

pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION = enum(u32) {
    UNINSTALLED = 1,
    STILL_IN_USE = 2,
    ALREADY_UNINSTALLED = 3,
    DELETE_PENDING = 4,
};
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.STILL_IN_USE;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.ALREADY_UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.DELETE_PENDING;

pub const QUERYASMINFO_FLAGS = enum(u32) {
    E = 1,
    _,
    pub fn initFlags(o: struct {
        E: u1 = 0,
    }) QUERYASMINFO_FLAGS {
        return @as(QUERYASMINFO_FLAGS, @enumFromInt((if (o.E == 1) @intFromEnum(QUERYASMINFO_FLAGS.E) else 0)));
    }
};
pub const QUERYASMINFO_FLAG_VALIDATE = QUERYASMINFO_FLAGS.E;

// TODO: this type has a FreeFunc 'MsiCloseHandle', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const MSIHANDLE = u32;

pub const RESULTTYPES = enum(i32) {
    Unknown = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
};
pub const ieUnknown = RESULTTYPES.Unknown;
pub const ieError = RESULTTYPES.Error;
pub const ieWarning = RESULTTYPES.Warning;
pub const ieInfo = RESULTTYPES.Info;

pub const STATUSTYPES = enum(i32) {
    GetCUB = 0,
    ICECount = 1,
    Merge = 2,
    SummaryInfo = 3,
    CreateEngine = 4,
    Starting = 5,
    RunICE = 6,
    Shutdown = 7,
    Success = 8,
    Fail = 9,
    Cancel = 10,
};
pub const ieStatusGetCUB = STATUSTYPES.GetCUB;
pub const ieStatusICECount = STATUSTYPES.ICECount;
pub const ieStatusMerge = STATUSTYPES.Merge;
pub const ieStatusSummaryInfo = STATUSTYPES.SummaryInfo;
pub const ieStatusCreateEngine = STATUSTYPES.CreateEngine;
pub const ieStatusStarting = STATUSTYPES.Starting;
pub const ieStatusRunICE = STATUSTYPES.RunICE;
pub const ieStatusShutdown = STATUSTYPES.Shutdown;
pub const ieStatusSuccess = STATUSTYPES.Success;
pub const ieStatusFail = STATUSTYPES.Fail;
pub const ieStatusCancel = STATUSTYPES.Cancel;

pub const LPDISPLAYVAL = *const fn (
    p_context: ?*anyopaque,
    ui_type: RESULTTYPES,
    szw_val: ?[*:0]const u16,
    szw_description: ?[*:0]const u16,
    szw_location: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPEVALCOMCALLBACK = *const fn (
    i_status: STATUSTYPES,
    sz_data: ?[*:0]const u16,
    p_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IValidate_Value = Guid.initString("e482e5c6-e31e-4143-a2e6-dbc3d8e4b8d3");
pub const IID_IValidate = &IID_IValidate_Value;
pub const IValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDatabase: *const fn (
            self: *const IValidate,
            sz_database: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenCUB: *const fn (
            self: *const IValidate,
            sz_c_u_b_file: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: *const fn (
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseCUB: *const fn (
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplay: *const fn (
            self: *const IValidate,
            p_display_function: ?LPDISPLAYVAL,
            p_context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: *const fn (
            self: *const IValidate,
            p_status_function: ?LPEVALCOMCALLBACK,
            p_context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: *const fn (
            self: *const IValidate,
            wz_i_c_es: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn openDatabase(self: *const T, sz_database_: ?[*:0]const u16) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).OpenDatabase(@as(*const IValidate, @ptrCast(self)), sz_database_);
            }
            pub inline fn openCUB(self: *const T, sz_c_u_b_file_: ?[*:0]const u16) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).OpenCUB(@as(*const IValidate, @ptrCast(self)), sz_c_u_b_file_);
            }
            pub inline fn closeDatabase(self: *const T) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).CloseDatabase(@as(*const IValidate, @ptrCast(self)));
            }
            pub inline fn closeCUB(self: *const T) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).CloseCUB(@as(*const IValidate, @ptrCast(self)));
            }
            pub inline fn setDisplay(self: *const T, p_display_function_: ?LPDISPLAYVAL, p_context_: ?*anyopaque) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).SetDisplay(@as(*const IValidate, @ptrCast(self)), p_display_function_, p_context_);
            }
            pub inline fn setStatus(self: *const T, p_status_function_: ?LPEVALCOMCALLBACK, p_context_: ?*anyopaque) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).SetStatus(@as(*const IValidate, @ptrCast(self)), p_status_function_, p_context_);
            }
            pub inline fn validate(self: *const T, wz_i_c_es_: ?[*:0]const u16) HRESULT {
                return @as(*const IValidate.VTable, @ptrCast(self.vtable)).Validate(@as(*const IValidate, @ptrCast(self)), wz_i_c_es_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MsmMerge_Value = Guid.initString("0adda830-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge = &CLSID_MsmMerge_Value;

pub const msmErrorType = enum(i32) {
    LanguageUnsupported = 1,
    LanguageFailed = 2,
    Exclusion = 3,
    TableMerge = 4,
    ResequenceMerge = 5,
    FileCreate = 6,
    DirCreate = 7,
    FeatureRequired = 8,
};
pub const msmErrorLanguageUnsupported = msmErrorType.LanguageUnsupported;
pub const msmErrorLanguageFailed = msmErrorType.LanguageFailed;
pub const msmErrorExclusion = msmErrorType.Exclusion;
pub const msmErrorTableMerge = msmErrorType.TableMerge;
pub const msmErrorResequenceMerge = msmErrorType.ResequenceMerge;
pub const msmErrorFileCreate = msmErrorType.FileCreate;
pub const msmErrorDirCreate = msmErrorType.DirCreate;
pub const msmErrorFeatureRequired = msmErrorType.FeatureRequired;

const IID_IEnumMsmString_Value = Guid.initString("0adda826-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmString = &IID_IEnumMsmString_Value;
pub const IEnumMsmString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMsmString,
            c_fetch: u32,
            rgbstr_strings: ?*?BSTR,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMsmString,
            c_skip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMsmString,
            pemsm_strings: ?*?*IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_fetch_: u32, rgbstr_strings_: ?*?BSTR, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMsmString.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMsmString, @ptrCast(self)), c_fetch_, rgbstr_strings_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_skip_: u32) HRESULT {
                return @as(*const IEnumMsmString.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMsmString, @ptrCast(self)), c_skip_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMsmString.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMsmString, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pemsm_strings_: ?*?*IEnumMsmString) HRESULT {
                return @as(*const IEnumMsmString.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMsmString, @ptrCast(self)), pemsm_strings_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmStrings_Value = Guid.initString("0adda827-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmStrings = &IID_IMsmStrings_Value;
pub const IMsmStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmStrings,
            item: i32,
            @"return": ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmStrings,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmStrings,
            new_enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getItem(self: *const T, item_: i32, return_: ?*?BSTR) HRESULT {
                return @as(*const IMsmStrings.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMsmStrings, @ptrCast(self)), item_, return_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IMsmStrings.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMsmStrings, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IUnknown) HRESULT {
                return @as(*const IMsmStrings.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMsmStrings, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmError_Value = Guid.initString("0adda828-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmError = &IID_IMsmError_Value;
pub const IMsmError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_type: ?*msmErrorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_language: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseTable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_table: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseKeys: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_keys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleTable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_table: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleKeys: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmError,
            error_keys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, error_type_: ?*msmErrorType) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IMsmError, @ptrCast(self)), error_type_);
            }
            pub inline fn getPath(self: *const T, error_path_: ?*?BSTR) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IMsmError, @ptrCast(self)), error_path_);
            }
            pub inline fn getLanguage(self: *const T, error_language_: ?*i16) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_Language(@as(*const IMsmError, @ptrCast(self)), error_language_);
            }
            pub inline fn getDatabaseTable(self: *const T, error_table_: ?*?BSTR) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_DatabaseTable(@as(*const IMsmError, @ptrCast(self)), error_table_);
            }
            pub inline fn getDatabaseKeys(self: *const T, error_keys_: ?*?*IMsmStrings) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_DatabaseKeys(@as(*const IMsmError, @ptrCast(self)), error_keys_);
            }
            pub inline fn getModuleTable(self: *const T, error_table_: ?*?BSTR) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_ModuleTable(@as(*const IMsmError, @ptrCast(self)), error_table_);
            }
            pub inline fn getModuleKeys(self: *const T, error_keys_: ?*?*IMsmStrings) HRESULT {
                return @as(*const IMsmError.VTable, @ptrCast(self.vtable)).get_ModuleKeys(@as(*const IMsmError, @ptrCast(self)), error_keys_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmError_Value = Guid.initString("0adda829-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmError = &IID_IEnumMsmError_Value;
pub const IEnumMsmError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMsmError,
            c_fetch: u32,
            rgmsm_errors: ?*?*IMsmError,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMsmError,
            c_skip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMsmError,
            pemsm_errors: ?*?*IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_fetch_: u32, rgmsm_errors_: ?*?*IMsmError, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMsmError.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMsmError, @ptrCast(self)), c_fetch_, rgmsm_errors_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_skip_: u32) HRESULT {
                return @as(*const IEnumMsmError.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMsmError, @ptrCast(self)), c_skip_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMsmError.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMsmError, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pemsm_errors_: ?*?*IEnumMsmError) HRESULT {
                return @as(*const IEnumMsmError.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMsmError, @ptrCast(self)), pemsm_errors_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmErrors_Value = Guid.initString("0adda82a-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmErrors = &IID_IMsmErrors_Value;
pub const IMsmErrors = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmErrors,
            item: i32,
            @"return": ?*?*IMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmErrors,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmErrors,
            new_enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getItem(self: *const T, item_: i32, return_: ?*?*IMsmError) HRESULT {
                return @as(*const IMsmErrors.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMsmErrors, @ptrCast(self)), item_, return_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IMsmErrors.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMsmErrors, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IUnknown) HRESULT {
                return @as(*const IMsmErrors.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMsmErrors, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependency_Value = Guid.initString("0adda82b-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependency = &IID_IMsmDependency_Value;
pub const IMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Module: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependency,
            module: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependency,
            language: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependency,
            version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getModule(self: *const T, module_: ?*?BSTR) HRESULT {
                return @as(*const IMsmDependency.VTable, @ptrCast(self.vtable)).get_Module(@as(*const IMsmDependency, @ptrCast(self)), module_);
            }
            pub inline fn getLanguage(self: *const T, language_: ?*i16) HRESULT {
                return @as(*const IMsmDependency.VTable, @ptrCast(self.vtable)).get_Language(@as(*const IMsmDependency, @ptrCast(self)), language_);
            }
            pub inline fn getVersion(self: *const T, version_: ?*?BSTR) HRESULT {
                return @as(*const IMsmDependency.VTable, @ptrCast(self.vtable)).get_Version(@as(*const IMsmDependency, @ptrCast(self)), version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmDependency_Value = Guid.initString("0adda82c-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmDependency = &IID_IEnumMsmDependency_Value;
pub const IEnumMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMsmDependency,
            c_fetch: u32,
            rgmsm_dependencies: ?*?*IMsmDependency,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMsmDependency,
            c_skip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMsmDependency,
            pemsm_dependencies: ?*?*IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_fetch_: u32, rgmsm_dependencies_: ?*?*IMsmDependency, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMsmDependency.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMsmDependency, @ptrCast(self)), c_fetch_, rgmsm_dependencies_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_skip_: u32) HRESULT {
                return @as(*const IEnumMsmDependency.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMsmDependency, @ptrCast(self)), c_skip_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMsmDependency.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMsmDependency, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pemsm_dependencies_: ?*?*IEnumMsmDependency) HRESULT {
                return @as(*const IEnumMsmDependency.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMsmDependency, @ptrCast(self)), pemsm_dependencies_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependencies_Value = Guid.initString("0adda82d-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependencies = &IID_IMsmDependencies_Value;
pub const IMsmDependencies = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependencies,
            item: i32,
            @"return": ?*?*IMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependencies,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmDependencies,
            new_enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getItem(self: *const T, item_: i32, return_: ?*?*IMsmDependency) HRESULT {
                return @as(*const IMsmDependencies.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMsmDependencies, @ptrCast(self)), item_, return_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IMsmDependencies.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMsmDependencies, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IUnknown) HRESULT {
                return @as(*const IMsmDependencies.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMsmDependencies, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmMerge_Value = Guid.initString("0adda82e-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmMerge = &IID_IMsmMerge_Value;
pub const IMsmMerge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OpenDatabase: *const fn (
            self: *const IMsmMerge,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenModule: *const fn (
            self: *const IMsmMerge,
            path: ?BSTR,
            language: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: *const fn (
            self: *const IMsmMerge,
            commit: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseModule: *const fn (
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLog: *const fn (
            self: *const IMsmMerge,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLog: *const fn (
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Log: *const fn (
            self: *const IMsmMerge,
            message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Errors: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmMerge,
            errors: ?*?*IMsmErrors,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dependencies: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmMerge,
            dependencies: ?*?*IMsmDependencies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: *const fn (
            self: *const IMsmMerge,
            feature: ?BSTR,
            redirect_dir: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: *const fn (
            self: *const IMsmMerge,
            feature: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractCAB: *const fn (
            self: *const IMsmMerge,
            file_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractFiles: *const fn (
            self: *const IMsmMerge,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn openDatabase(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).OpenDatabase(@as(*const IMsmMerge, @ptrCast(self)), path_);
            }
            pub inline fn openModule(self: *const T, path_: ?BSTR, language_: i16) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).OpenModule(@as(*const IMsmMerge, @ptrCast(self)), path_, language_);
            }
            pub inline fn closeDatabase(self: *const T, commit_: i16) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).CloseDatabase(@as(*const IMsmMerge, @ptrCast(self)), commit_);
            }
            pub inline fn closeModule(self: *const T) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).CloseModule(@as(*const IMsmMerge, @ptrCast(self)));
            }
            pub inline fn openLog(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).OpenLog(@as(*const IMsmMerge, @ptrCast(self)), path_);
            }
            pub inline fn closeLog(self: *const T) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).CloseLog(@as(*const IMsmMerge, @ptrCast(self)));
            }
            pub inline fn log(self: *const T, message_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).Log(@as(*const IMsmMerge, @ptrCast(self)), message_);
            }
            pub inline fn getErrors(self: *const T, errors_: ?*?*IMsmErrors) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).get_Errors(@as(*const IMsmMerge, @ptrCast(self)), errors_);
            }
            pub inline fn getDependencies(self: *const T, dependencies_: ?*?*IMsmDependencies) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).get_Dependencies(@as(*const IMsmMerge, @ptrCast(self)), dependencies_);
            }
            pub inline fn merge(self: *const T, feature_: ?BSTR, redirect_dir_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).Merge(@as(*const IMsmMerge, @ptrCast(self)), feature_, redirect_dir_);
            }
            pub inline fn connect(self: *const T, feature_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).Connect(@as(*const IMsmMerge, @ptrCast(self)), feature_);
            }
            pub inline fn extractCAB(self: *const T, file_name_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).ExtractCAB(@as(*const IMsmMerge, @ptrCast(self)), file_name_);
            }
            pub inline fn extractFiles(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IMsmMerge.VTable, @ptrCast(self.vtable)).ExtractFiles(@as(*const IMsmMerge, @ptrCast(self)), path_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmGetFiles_Value = Guid.initString("7041ae26-2d78-11d2-888a-00a0c981b015");
pub const IID_IMsmGetFiles = &IID_IMsmGetFiles_Value;
pub const IMsmGetFiles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleFiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMsmGetFiles,
            files: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getModuleFiles(self: *const T, files_: ?*?*IMsmStrings) HRESULT {
                return @as(*const IMsmGetFiles.VTable, @ptrCast(self.vtable)).get_ModuleFiles(@as(*const IMsmGetFiles, @ptrCast(self)), files_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PMSIHANDLE = extern struct {
    m_h: MSIHANDLE,
};

pub const INSTALLMESSAGE = enum(i32) {
    FATALEXIT = 0,
    ERROR = 16777216,
    WARNING = 33554432,
    USER = 50331648,
    INFO = 67108864,
    FILESINUSE = 83886080,
    RESOLVESOURCE = 100663296,
    OUTOFDISKSPACE = 117440512,
    ACTIONSTART = 134217728,
    ACTIONDATA = 150994944,
    PROGRESS = 167772160,
    COMMONDATA = 184549376,
    INITIALIZE = 201326592,
    TERMINATE = 218103808,
    SHOWDIALOG = 234881024,
    PERFORMANCE = 251658240,
    RMFILESINUSE = 419430400,
    INSTALLSTART = 436207616,
    INSTALLEND = 452984832,
};
pub const INSTALLMESSAGE_FATALEXIT = INSTALLMESSAGE.FATALEXIT;
pub const INSTALLMESSAGE_ERROR = INSTALLMESSAGE.ERROR;
pub const INSTALLMESSAGE_WARNING = INSTALLMESSAGE.WARNING;
pub const INSTALLMESSAGE_USER = INSTALLMESSAGE.USER;
pub const INSTALLMESSAGE_INFO = INSTALLMESSAGE.INFO;
pub const INSTALLMESSAGE_FILESINUSE = INSTALLMESSAGE.FILESINUSE;
pub const INSTALLMESSAGE_RESOLVESOURCE = INSTALLMESSAGE.RESOLVESOURCE;
pub const INSTALLMESSAGE_OUTOFDISKSPACE = INSTALLMESSAGE.OUTOFDISKSPACE;
pub const INSTALLMESSAGE_ACTIONSTART = INSTALLMESSAGE.ACTIONSTART;
pub const INSTALLMESSAGE_ACTIONDATA = INSTALLMESSAGE.ACTIONDATA;
pub const INSTALLMESSAGE_PROGRESS = INSTALLMESSAGE.PROGRESS;
pub const INSTALLMESSAGE_COMMONDATA = INSTALLMESSAGE.COMMONDATA;
pub const INSTALLMESSAGE_INITIALIZE = INSTALLMESSAGE.INITIALIZE;
pub const INSTALLMESSAGE_TERMINATE = INSTALLMESSAGE.TERMINATE;
pub const INSTALLMESSAGE_SHOWDIALOG = INSTALLMESSAGE.SHOWDIALOG;
pub const INSTALLMESSAGE_PERFORMANCE = INSTALLMESSAGE.PERFORMANCE;
pub const INSTALLMESSAGE_RMFILESINUSE = INSTALLMESSAGE.RMFILESINUSE;
pub const INSTALLMESSAGE_INSTALLSTART = INSTALLMESSAGE.INSTALLSTART;
pub const INSTALLMESSAGE_INSTALLEND = INSTALLMESSAGE.INSTALLEND;

pub const INSTALLUI_HANDLERA = *const fn (
    pv_context: ?*anyopaque,
    i_message_type: u32,
    sz_message: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUI_HANDLERW = *const fn (
    pv_context: ?*anyopaque,
    i_message_type: u32,
    sz_message: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PINSTALLUI_HANDLER_RECORD = *const fn (
    pv_context: ?*anyopaque,
    i_message_type: u32,
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUILEVEL = enum(i32) {
    NOCHANGE = 0,
    DEFAULT = 1,
    NONE = 2,
    BASIC = 3,
    REDUCED = 4,
    FULL = 5,
    ENDDIALOG = 128,
    PROGRESSONLY = 64,
    HIDECANCEL = 32,
    SOURCERESONLY = 256,
    UACONLY = 512,
};
pub const INSTALLUILEVEL_NOCHANGE = INSTALLUILEVEL.NOCHANGE;
pub const INSTALLUILEVEL_DEFAULT = INSTALLUILEVEL.DEFAULT;
pub const INSTALLUILEVEL_NONE = INSTALLUILEVEL.NONE;
pub const INSTALLUILEVEL_BASIC = INSTALLUILEVEL.BASIC;
pub const INSTALLUILEVEL_REDUCED = INSTALLUILEVEL.REDUCED;
pub const INSTALLUILEVEL_FULL = INSTALLUILEVEL.FULL;
pub const INSTALLUILEVEL_ENDDIALOG = INSTALLUILEVEL.ENDDIALOG;
pub const INSTALLUILEVEL_PROGRESSONLY = INSTALLUILEVEL.PROGRESSONLY;
pub const INSTALLUILEVEL_HIDECANCEL = INSTALLUILEVEL.HIDECANCEL;
pub const INSTALLUILEVEL_SOURCERESONLY = INSTALLUILEVEL.SOURCERESONLY;
pub const INSTALLUILEVEL_UACONLY = INSTALLUILEVEL.UACONLY;

pub const INSTALLSTATE = enum(i32) {
    NOTUSED = -7,
    BADCONFIG = -6,
    INCOMPLETE = -5,
    SOURCEABSENT = -4,
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    BROKEN = 0,
    ADVERTISED = 1,
    // REMOVED = 1, this enum value conflicts with ADVERTISED
    ABSENT = 2,
    LOCAL = 3,
    SOURCE = 4,
    DEFAULT = 5,
};
pub const INSTALLSTATE_NOTUSED = INSTALLSTATE.NOTUSED;
pub const INSTALLSTATE_BADCONFIG = INSTALLSTATE.BADCONFIG;
pub const INSTALLSTATE_INCOMPLETE = INSTALLSTATE.INCOMPLETE;
pub const INSTALLSTATE_SOURCEABSENT = INSTALLSTATE.SOURCEABSENT;
pub const INSTALLSTATE_MOREDATA = INSTALLSTATE.MOREDATA;
pub const INSTALLSTATE_INVALIDARG = INSTALLSTATE.INVALIDARG;
pub const INSTALLSTATE_UNKNOWN = INSTALLSTATE.UNKNOWN;
pub const INSTALLSTATE_BROKEN = INSTALLSTATE.BROKEN;
pub const INSTALLSTATE_ADVERTISED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_REMOVED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_ABSENT = INSTALLSTATE.ABSENT;
pub const INSTALLSTATE_LOCAL = INSTALLSTATE.LOCAL;
pub const INSTALLSTATE_SOURCE = INSTALLSTATE.SOURCE;
pub const INSTALLSTATE_DEFAULT = INSTALLSTATE.DEFAULT;

pub const USERINFOSTATE = enum(i32) {
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    ABSENT = 0,
    PRESENT = 1,
};
pub const USERINFOSTATE_MOREDATA = USERINFOSTATE.MOREDATA;
pub const USERINFOSTATE_INVALIDARG = USERINFOSTATE.INVALIDARG;
pub const USERINFOSTATE_UNKNOWN = USERINFOSTATE.UNKNOWN;
pub const USERINFOSTATE_ABSENT = USERINFOSTATE.ABSENT;
pub const USERINFOSTATE_PRESENT = USERINFOSTATE.PRESENT;

pub const INSTALLLEVEL = enum(i32) {
    DEFAULT = 0,
    MINIMUM = 1,
    MAXIMUM = 65535,
};
pub const INSTALLLEVEL_DEFAULT = INSTALLLEVEL.DEFAULT;
pub const INSTALLLEVEL_MINIMUM = INSTALLLEVEL.MINIMUM;
pub const INSTALLLEVEL_MAXIMUM = INSTALLLEVEL.MAXIMUM;

pub const REINSTALLMODE = enum(i32) {
    REPAIR = 1,
    FILEMISSING = 2,
    FILEOLDERVERSION = 4,
    FILEEQUALVERSION = 8,
    FILEEXACT = 16,
    FILEVERIFY = 32,
    FILEREPLACE = 64,
    MACHINEDATA = 128,
    USERDATA = 256,
    SHORTCUT = 512,
    PACKAGE = 1024,
};
pub const REINSTALLMODE_REPAIR = REINSTALLMODE.REPAIR;
pub const REINSTALLMODE_FILEMISSING = REINSTALLMODE.FILEMISSING;
pub const REINSTALLMODE_FILEOLDERVERSION = REINSTALLMODE.FILEOLDERVERSION;
pub const REINSTALLMODE_FILEEQUALVERSION = REINSTALLMODE.FILEEQUALVERSION;
pub const REINSTALLMODE_FILEEXACT = REINSTALLMODE.FILEEXACT;
pub const REINSTALLMODE_FILEVERIFY = REINSTALLMODE.FILEVERIFY;
pub const REINSTALLMODE_FILEREPLACE = REINSTALLMODE.FILEREPLACE;
pub const REINSTALLMODE_MACHINEDATA = REINSTALLMODE.MACHINEDATA;
pub const REINSTALLMODE_USERDATA = REINSTALLMODE.USERDATA;
pub const REINSTALLMODE_SHORTCUT = REINSTALLMODE.SHORTCUT;
pub const REINSTALLMODE_PACKAGE = REINSTALLMODE.PACKAGE;

pub const INSTALLOGMODE = enum(i32) {
    FATALEXIT = 1,
    ERROR = 2,
    WARNING = 4,
    USER = 8,
    INFO = 16,
    RESOLVESOURCE = 64,
    OUTOFDISKSPACE = 128,
    ACTIONSTART = 256,
    ACTIONDATA = 512,
    COMMONDATA = 2048,
    PROPERTYDUMP = 1024,
    VERBOSE = 4096,
    EXTRADEBUG = 8192,
    LOGONLYONERROR = 16384,
    LOGPERFORMANCE = 32768,
    // PROGRESS = 1024, this enum value conflicts with PROPERTYDUMP
    // INITIALIZE = 4096, this enum value conflicts with VERBOSE
    // TERMINATE = 8192, this enum value conflicts with EXTRADEBUG
    // SHOWDIALOG = 16384, this enum value conflicts with LOGONLYONERROR
    FILESINUSE = 32,
    RMFILESINUSE = 33554432,
    INSTALLSTART = 67108864,
    INSTALLEND = 134217728,
};
pub const INSTALLLOGMODE_FATALEXIT = INSTALLOGMODE.FATALEXIT;
pub const INSTALLLOGMODE_ERROR = INSTALLOGMODE.ERROR;
pub const INSTALLLOGMODE_WARNING = INSTALLOGMODE.WARNING;
pub const INSTALLLOGMODE_USER = INSTALLOGMODE.USER;
pub const INSTALLLOGMODE_INFO = INSTALLOGMODE.INFO;
pub const INSTALLLOGMODE_RESOLVESOURCE = INSTALLOGMODE.RESOLVESOURCE;
pub const INSTALLLOGMODE_OUTOFDISKSPACE = INSTALLOGMODE.OUTOFDISKSPACE;
pub const INSTALLLOGMODE_ACTIONSTART = INSTALLOGMODE.ACTIONSTART;
pub const INSTALLLOGMODE_ACTIONDATA = INSTALLOGMODE.ACTIONDATA;
pub const INSTALLLOGMODE_COMMONDATA = INSTALLOGMODE.COMMONDATA;
pub const INSTALLLOGMODE_PROPERTYDUMP = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_VERBOSE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_EXTRADEBUG = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_LOGONLYONERROR = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_LOGPERFORMANCE = INSTALLOGMODE.LOGPERFORMANCE;
pub const INSTALLLOGMODE_PROGRESS = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_INITIALIZE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_TERMINATE = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_SHOWDIALOG = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_FILESINUSE = INSTALLOGMODE.FILESINUSE;
pub const INSTALLLOGMODE_RMFILESINUSE = INSTALLOGMODE.RMFILESINUSE;
pub const INSTALLLOGMODE_INSTALLSTART = INSTALLOGMODE.INSTALLSTART;
pub const INSTALLLOGMODE_INSTALLEND = INSTALLOGMODE.INSTALLEND;

pub const INSTALLLOGATTRIBUTES = enum(i32) {
    APPEND = 1,
    FLUSHEACHLINE = 2,
};
pub const INSTALLLOGATTRIBUTES_APPEND = INSTALLLOGATTRIBUTES.APPEND;
pub const INSTALLLOGATTRIBUTES_FLUSHEACHLINE = INSTALLLOGATTRIBUTES.FLUSHEACHLINE;

pub const INSTALLFEATUREATTRIBUTE = enum(i32) {
    FAVORLOCAL = 1,
    FAVORSOURCE = 2,
    FOLLOWPARENT = 4,
    FAVORADVERTISE = 8,
    DISALLOWADVERTISE = 16,
    NOUNSUPPORTEDADVERTISE = 32,
};
pub const INSTALLFEATUREATTRIBUTE_FAVORLOCAL = INSTALLFEATUREATTRIBUTE.FAVORLOCAL;
pub const INSTALLFEATUREATTRIBUTE_FAVORSOURCE = INSTALLFEATUREATTRIBUTE.FAVORSOURCE;
pub const INSTALLFEATUREATTRIBUTE_FOLLOWPARENT = INSTALLFEATUREATTRIBUTE.FOLLOWPARENT;
pub const INSTALLFEATUREATTRIBUTE_FAVORADVERTISE = INSTALLFEATUREATTRIBUTE.FAVORADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE = INSTALLFEATUREATTRIBUTE.DISALLOWADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = INSTALLFEATUREATTRIBUTE.NOUNSUPPORTEDADVERTISE;

pub const INSTALLMODE = enum(i32) {
    NODETECTION_ANY = -4,
    NOSOURCERESOLUTION = -3,
    NODETECTION = -2,
    EXISTING = -1,
    DEFAULT = 0,
};
pub const INSTALLMODE_NODETECTION_ANY = INSTALLMODE.NODETECTION_ANY;
pub const INSTALLMODE_NOSOURCERESOLUTION = INSTALLMODE.NOSOURCERESOLUTION;
pub const INSTALLMODE_NODETECTION = INSTALLMODE.NODETECTION;
pub const INSTALLMODE_EXISTING = INSTALLMODE.EXISTING;
pub const INSTALLMODE_DEFAULT = INSTALLMODE.DEFAULT;

pub const MSIPATCHSTATE = enum(i32) {
    INVALID = 0,
    APPLIED = 1,
    SUPERSEDED = 2,
    OBSOLETED = 4,
    REGISTERED = 8,
    ALL = 15,
};
pub const MSIPATCHSTATE_INVALID = MSIPATCHSTATE.INVALID;
pub const MSIPATCHSTATE_APPLIED = MSIPATCHSTATE.APPLIED;
pub const MSIPATCHSTATE_SUPERSEDED = MSIPATCHSTATE.SUPERSEDED;
pub const MSIPATCHSTATE_OBSOLETED = MSIPATCHSTATE.OBSOLETED;
pub const MSIPATCHSTATE_REGISTERED = MSIPATCHSTATE.REGISTERED;
pub const MSIPATCHSTATE_ALL = MSIPATCHSTATE.ALL;

pub const MSIINSTALLCONTEXT = enum(i32) {
    FIRSTVISIBLE = 0,
    // NONE = 0, this enum value conflicts with FIRSTVISIBLE
    USERMANAGED = 1,
    USERUNMANAGED = 2,
    MACHINE = 4,
    ALL = 7,
    ALLUSERMANAGED = 8,
};
pub const MSIINSTALLCONTEXT_FIRSTVISIBLE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_NONE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_USERMANAGED = MSIINSTALLCONTEXT.USERMANAGED;
pub const MSIINSTALLCONTEXT_USERUNMANAGED = MSIINSTALLCONTEXT.USERUNMANAGED;
pub const MSIINSTALLCONTEXT_MACHINE = MSIINSTALLCONTEXT.MACHINE;
pub const MSIINSTALLCONTEXT_ALL = MSIINSTALLCONTEXT.ALL;
pub const MSIINSTALLCONTEXT_ALLUSERMANAGED = MSIINSTALLCONTEXT.ALLUSERMANAGED;

pub const MSIPATCHDATATYPE = enum(i32) {
    PATCHFILE = 0,
    XMLPATH = 1,
    XMLBLOB = 2,
};
pub const MSIPATCH_DATATYPE_PATCHFILE = MSIPATCHDATATYPE.PATCHFILE;
pub const MSIPATCH_DATATYPE_XMLPATH = MSIPATCHDATATYPE.XMLPATH;
pub const MSIPATCH_DATATYPE_XMLBLOB = MSIPATCHDATATYPE.XMLBLOB;

pub const MSIPATCHSEQUENCEINFOA = extern struct {
    szPatchData: ?[*:0]const u8,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const MSIPATCHSEQUENCEINFOW = extern struct {
    szPatchData: ?[*:0]const u16,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const SCRIPTFLAGS = enum(i32) {
    CACHEINFO = 1,
    SHORTCUTS = 4,
    MACHINEASSIGN = 8,
    REGDATA_CNFGINFO = 32,
    VALIDATE_TRANSFORMS_LIST = 64,
    REGDATA_CLASSINFO = 128,
    REGDATA_EXTENSIONINFO = 256,
    REGDATA_APPINFO = 384,
    REGDATA = 416,
};
pub const SCRIPTFLAGS_CACHEINFO = SCRIPTFLAGS.CACHEINFO;
pub const SCRIPTFLAGS_SHORTCUTS = SCRIPTFLAGS.SHORTCUTS;
pub const SCRIPTFLAGS_MACHINEASSIGN = SCRIPTFLAGS.MACHINEASSIGN;
pub const SCRIPTFLAGS_REGDATA_CNFGINFO = SCRIPTFLAGS.REGDATA_CNFGINFO;
pub const SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST = SCRIPTFLAGS.VALIDATE_TRANSFORMS_LIST;
pub const SCRIPTFLAGS_REGDATA_CLASSINFO = SCRIPTFLAGS.REGDATA_CLASSINFO;
pub const SCRIPTFLAGS_REGDATA_EXTENSIONINFO = SCRIPTFLAGS.REGDATA_EXTENSIONINFO;
pub const SCRIPTFLAGS_REGDATA_APPINFO = SCRIPTFLAGS.REGDATA_APPINFO;
pub const SCRIPTFLAGS_REGDATA = SCRIPTFLAGS.REGDATA;

pub const ADVERTISEFLAGS = enum(i32) {
    MACHINEASSIGN = 0,
    USERASSIGN = 1,
};
pub const ADVERTISEFLAGS_MACHINEASSIGN = ADVERTISEFLAGS.MACHINEASSIGN;
pub const ADVERTISEFLAGS_USERASSIGN = ADVERTISEFLAGS.USERASSIGN;

pub const INSTALLTYPE = enum(i32) {
    DEFAULT = 0,
    NETWORK_IMAGE = 1,
    SINGLE_INSTANCE = 2,
};
pub const INSTALLTYPE_DEFAULT = INSTALLTYPE.DEFAULT;
pub const INSTALLTYPE_NETWORK_IMAGE = INSTALLTYPE.NETWORK_IMAGE;
pub const INSTALLTYPE_SINGLE_INSTANCE = INSTALLTYPE.SINGLE_INSTANCE;

pub const MSIFILEHASHINFO = extern struct {
    dwFileHashInfoSize: u32,
    dwData: [4]u32,
};

pub const MSIARCHITECTUREFLAGS = enum(i32) {
    X86 = 1,
    IA64 = 2,
    AMD64 = 4,
    ARM = 8,
};
pub const MSIARCHITECTUREFLAGS_X86 = MSIARCHITECTUREFLAGS.X86;
pub const MSIARCHITECTUREFLAGS_IA64 = MSIARCHITECTUREFLAGS.IA64;
pub const MSIARCHITECTUREFLAGS_AMD64 = MSIARCHITECTUREFLAGS.AMD64;
pub const MSIARCHITECTUREFLAGS_ARM = MSIARCHITECTUREFLAGS.ARM;

pub const MSIOPENPACKAGEFLAGS = enum(i32) {
    E = 1,
};
pub const MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = MSIOPENPACKAGEFLAGS.E;

pub const MSIADVERTISEOPTIONFLAGS = enum(i32) {
    E = 1,
};
pub const MSIADVERTISEOPTIONFLAGS_INSTANCE = MSIADVERTISEOPTIONFLAGS.E;

pub const MSISOURCETYPE = enum(i32) {
    UNKNOWN = 0,
    NETWORK = 1,
    URL = 2,
    MEDIA = 4,
};
pub const MSISOURCETYPE_UNKNOWN = MSISOURCETYPE.UNKNOWN;
pub const MSISOURCETYPE_NETWORK = MSISOURCETYPE.NETWORK;
pub const MSISOURCETYPE_URL = MSISOURCETYPE.URL;
pub const MSISOURCETYPE_MEDIA = MSISOURCETYPE.MEDIA;

pub const MSICODE = enum(i32) {
    RODUCT = 0,
    ATCH = 1073741824,
};
pub const MSICODE_PRODUCT = MSICODE.RODUCT;
pub const MSICODE_PATCH = MSICODE.ATCH;

pub const MSITRANSACTION = enum(i32) {
    CHAIN_EMBEDDEDUI = 1,
    JOIN_EXISTING_EMBEDDEDUI = 2,
};
pub const MSITRANSACTION_CHAIN_EMBEDDEDUI = MSITRANSACTION.CHAIN_EMBEDDEDUI;
pub const MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI = MSITRANSACTION.JOIN_EXISTING_EMBEDDEDUI;

pub const MSITRANSACTIONSTATE = enum(u32) {
    ROLLBACK = 0,
    COMMIT = 1,
};
pub const MSITRANSACTIONSTATE_ROLLBACK = MSITRANSACTIONSTATE.ROLLBACK;
pub const MSITRANSACTIONSTATE_COMMIT = MSITRANSACTIONSTATE.COMMIT;

pub const MSIDBSTATE = enum(i32) {
    ERROR = -1,
    READ = 0,
    WRITE = 1,
};
pub const MSIDBSTATE_ERROR = MSIDBSTATE.ERROR;
pub const MSIDBSTATE_READ = MSIDBSTATE.READ;
pub const MSIDBSTATE_WRITE = MSIDBSTATE.WRITE;

pub const MSIMODIFY = enum(i32) {
    SEEK = -1,
    REFRESH = 0,
    INSERT = 1,
    UPDATE = 2,
    ASSIGN = 3,
    REPLACE = 4,
    MERGE = 5,
    DELETE = 6,
    INSERT_TEMPORARY = 7,
    VALIDATE = 8,
    VALIDATE_NEW = 9,
    VALIDATE_FIELD = 10,
    VALIDATE_DELETE = 11,
};
pub const MSIMODIFY_SEEK = MSIMODIFY.SEEK;
pub const MSIMODIFY_REFRESH = MSIMODIFY.REFRESH;
pub const MSIMODIFY_INSERT = MSIMODIFY.INSERT;
pub const MSIMODIFY_UPDATE = MSIMODIFY.UPDATE;
pub const MSIMODIFY_ASSIGN = MSIMODIFY.ASSIGN;
pub const MSIMODIFY_REPLACE = MSIMODIFY.REPLACE;
pub const MSIMODIFY_MERGE = MSIMODIFY.MERGE;
pub const MSIMODIFY_DELETE = MSIMODIFY.DELETE;
pub const MSIMODIFY_INSERT_TEMPORARY = MSIMODIFY.INSERT_TEMPORARY;
pub const MSIMODIFY_VALIDATE = MSIMODIFY.VALIDATE;
pub const MSIMODIFY_VALIDATE_NEW = MSIMODIFY.VALIDATE_NEW;
pub const MSIMODIFY_VALIDATE_FIELD = MSIMODIFY.VALIDATE_FIELD;
pub const MSIMODIFY_VALIDATE_DELETE = MSIMODIFY.VALIDATE_DELETE;

pub const MSICOLINFO = enum(i32) {
    NAMES = 0,
    TYPES = 1,
};
pub const MSICOLINFO_NAMES = MSICOLINFO.NAMES;
pub const MSICOLINFO_TYPES = MSICOLINFO.TYPES;

pub const MSICONDITION = enum(i32) {
    FALSE = 0,
    TRUE = 1,
    NONE = 2,
    ERROR = 3,
};
pub const MSICONDITION_FALSE = MSICONDITION.FALSE;
pub const MSICONDITION_TRUE = MSICONDITION.TRUE;
pub const MSICONDITION_NONE = MSICONDITION.NONE;
pub const MSICONDITION_ERROR = MSICONDITION.ERROR;

pub const MSICOSTTREE = enum(i32) {
    SELFONLY = 0,
    CHILDREN = 1,
    PARENTS = 2,
    RESERVED = 3,
};
pub const MSICOSTTREE_SELFONLY = MSICOSTTREE.SELFONLY;
pub const MSICOSTTREE_CHILDREN = MSICOSTTREE.CHILDREN;
pub const MSICOSTTREE_PARENTS = MSICOSTTREE.PARENTS;
pub const MSICOSTTREE_RESERVED = MSICOSTTREE.RESERVED;

pub const MSIDBERROR = enum(i32) {
    INVALIDARG = -3,
    MOREDATA = -2,
    FUNCTIONERROR = -1,
    NOERROR = 0,
    DUPLICATEKEY = 1,
    REQUIRED = 2,
    BADLINK = 3,
    OVERFLOW = 4,
    UNDERFLOW = 5,
    NOTINSET = 6,
    BADVERSION = 7,
    BADCASE = 8,
    BADGUID = 9,
    BADWILDCARD = 10,
    BADIDENTIFIER = 11,
    BADLANGUAGE = 12,
    BADFILENAME = 13,
    BADPATH = 14,
    BADCONDITION = 15,
    BADFORMATTED = 16,
    BADTEMPLATE = 17,
    BADDEFAULTDIR = 18,
    BADREGPATH = 19,
    BADCUSTOMSOURCE = 20,
    BADPROPERTY = 21,
    MISSINGDATA = 22,
    BADCATEGORY = 23,
    BADKEYTABLE = 24,
    BADMAXMINVALUES = 25,
    BADCABINET = 26,
    BADSHORTCUT = 27,
    STRINGOVERFLOW = 28,
    BADLOCALIZEATTRIB = 29,
};
pub const MSIDBERROR_INVALIDARG = MSIDBERROR.INVALIDARG;
pub const MSIDBERROR_MOREDATA = MSIDBERROR.MOREDATA;
pub const MSIDBERROR_FUNCTIONERROR = MSIDBERROR.FUNCTIONERROR;
pub const MSIDBERROR_NOERROR = MSIDBERROR.NOERROR;
pub const MSIDBERROR_DUPLICATEKEY = MSIDBERROR.DUPLICATEKEY;
pub const MSIDBERROR_REQUIRED = MSIDBERROR.REQUIRED;
pub const MSIDBERROR_BADLINK = MSIDBERROR.BADLINK;
pub const MSIDBERROR_OVERFLOW = MSIDBERROR.OVERFLOW;
pub const MSIDBERROR_UNDERFLOW = MSIDBERROR.UNDERFLOW;
pub const MSIDBERROR_NOTINSET = MSIDBERROR.NOTINSET;
pub const MSIDBERROR_BADVERSION = MSIDBERROR.BADVERSION;
pub const MSIDBERROR_BADCASE = MSIDBERROR.BADCASE;
pub const MSIDBERROR_BADGUID = MSIDBERROR.BADGUID;
pub const MSIDBERROR_BADWILDCARD = MSIDBERROR.BADWILDCARD;
pub const MSIDBERROR_BADIDENTIFIER = MSIDBERROR.BADIDENTIFIER;
pub const MSIDBERROR_BADLANGUAGE = MSIDBERROR.BADLANGUAGE;
pub const MSIDBERROR_BADFILENAME = MSIDBERROR.BADFILENAME;
pub const MSIDBERROR_BADPATH = MSIDBERROR.BADPATH;
pub const MSIDBERROR_BADCONDITION = MSIDBERROR.BADCONDITION;
pub const MSIDBERROR_BADFORMATTED = MSIDBERROR.BADFORMATTED;
pub const MSIDBERROR_BADTEMPLATE = MSIDBERROR.BADTEMPLATE;
pub const MSIDBERROR_BADDEFAULTDIR = MSIDBERROR.BADDEFAULTDIR;
pub const MSIDBERROR_BADREGPATH = MSIDBERROR.BADREGPATH;
pub const MSIDBERROR_BADCUSTOMSOURCE = MSIDBERROR.BADCUSTOMSOURCE;
pub const MSIDBERROR_BADPROPERTY = MSIDBERROR.BADPROPERTY;
pub const MSIDBERROR_MISSINGDATA = MSIDBERROR.MISSINGDATA;
pub const MSIDBERROR_BADCATEGORY = MSIDBERROR.BADCATEGORY;
pub const MSIDBERROR_BADKEYTABLE = MSIDBERROR.BADKEYTABLE;
pub const MSIDBERROR_BADMAXMINVALUES = MSIDBERROR.BADMAXMINVALUES;
pub const MSIDBERROR_BADCABINET = MSIDBERROR.BADCABINET;
pub const MSIDBERROR_BADSHORTCUT = MSIDBERROR.BADSHORTCUT;
pub const MSIDBERROR_STRINGOVERFLOW = MSIDBERROR.STRINGOVERFLOW;
pub const MSIDBERROR_BADLOCALIZEATTRIB = MSIDBERROR.BADLOCALIZEATTRIB;

pub const MSIRUNMODE = enum(i32) {
    ADMIN = 0,
    ADVERTISE = 1,
    MAINTENANCE = 2,
    ROLLBACKENABLED = 3,
    LOGENABLED = 4,
    OPERATIONS = 5,
    REBOOTATEND = 6,
    REBOOTNOW = 7,
    CABINET = 8,
    SOURCESHORTNAMES = 9,
    TARGETSHORTNAMES = 10,
    RESERVED11 = 11,
    WINDOWS9X = 12,
    ZAWENABLED = 13,
    RESERVED14 = 14,
    RESERVED15 = 15,
    SCHEDULED = 16,
    ROLLBACK = 17,
    COMMIT = 18,
};
pub const MSIRUNMODE_ADMIN = MSIRUNMODE.ADMIN;
pub const MSIRUNMODE_ADVERTISE = MSIRUNMODE.ADVERTISE;
pub const MSIRUNMODE_MAINTENANCE = MSIRUNMODE.MAINTENANCE;
pub const MSIRUNMODE_ROLLBACKENABLED = MSIRUNMODE.ROLLBACKENABLED;
pub const MSIRUNMODE_LOGENABLED = MSIRUNMODE.LOGENABLED;
pub const MSIRUNMODE_OPERATIONS = MSIRUNMODE.OPERATIONS;
pub const MSIRUNMODE_REBOOTATEND = MSIRUNMODE.REBOOTATEND;
pub const MSIRUNMODE_REBOOTNOW = MSIRUNMODE.REBOOTNOW;
pub const MSIRUNMODE_CABINET = MSIRUNMODE.CABINET;
pub const MSIRUNMODE_SOURCESHORTNAMES = MSIRUNMODE.SOURCESHORTNAMES;
pub const MSIRUNMODE_TARGETSHORTNAMES = MSIRUNMODE.TARGETSHORTNAMES;
pub const MSIRUNMODE_RESERVED11 = MSIRUNMODE.RESERVED11;
pub const MSIRUNMODE_WINDOWS9X = MSIRUNMODE.WINDOWS9X;
pub const MSIRUNMODE_ZAWENABLED = MSIRUNMODE.ZAWENABLED;
pub const MSIRUNMODE_RESERVED14 = MSIRUNMODE.RESERVED14;
pub const MSIRUNMODE_RESERVED15 = MSIRUNMODE.RESERVED15;
pub const MSIRUNMODE_SCHEDULED = MSIRUNMODE.SCHEDULED;
pub const MSIRUNMODE_ROLLBACK = MSIRUNMODE.ROLLBACK;
pub const MSIRUNMODE_COMMIT = MSIRUNMODE.COMMIT;

pub const MSITRANSFORM_ERROR = enum(i32) {
    ADDEXISTINGROW = 1,
    DELMISSINGROW = 2,
    ADDEXISTINGTABLE = 4,
    DELMISSINGTABLE = 8,
    UPDATEMISSINGROW = 16,
    CHANGECODEPAGE = 32,
    VIEWTRANSFORM = 256,
    NONE = 0,
};
pub const MSITRANSFORM_ERROR_ADDEXISTINGROW = MSITRANSFORM_ERROR.ADDEXISTINGROW;
pub const MSITRANSFORM_ERROR_DELMISSINGROW = MSITRANSFORM_ERROR.DELMISSINGROW;
pub const MSITRANSFORM_ERROR_ADDEXISTINGTABLE = MSITRANSFORM_ERROR.ADDEXISTINGTABLE;
pub const MSITRANSFORM_ERROR_DELMISSINGTABLE = MSITRANSFORM_ERROR.DELMISSINGTABLE;
pub const MSITRANSFORM_ERROR_UPDATEMISSINGROW = MSITRANSFORM_ERROR.UPDATEMISSINGROW;
pub const MSITRANSFORM_ERROR_CHANGECODEPAGE = MSITRANSFORM_ERROR.CHANGECODEPAGE;
pub const MSITRANSFORM_ERROR_VIEWTRANSFORM = MSITRANSFORM_ERROR.VIEWTRANSFORM;
pub const MSITRANSFORM_ERROR_NONE = MSITRANSFORM_ERROR.NONE;

pub const MSITRANSFORM_VALIDATE = enum(i32) {
    LANGUAGE = 1,
    PRODUCT = 2,
    PLATFORM = 4,
    MAJORVERSION = 8,
    MINORVERSION = 16,
    UPDATEVERSION = 32,
    NEWLESSBASEVERSION = 64,
    NEWLESSEQUALBASEVERSION = 128,
    NEWEQUALBASEVERSION = 256,
    NEWGREATEREQUALBASEVERSION = 512,
    NEWGREATERBASEVERSION = 1024,
    UPGRADECODE = 2048,
};
pub const MSITRANSFORM_VALIDATE_LANGUAGE = MSITRANSFORM_VALIDATE.LANGUAGE;
pub const MSITRANSFORM_VALIDATE_PRODUCT = MSITRANSFORM_VALIDATE.PRODUCT;
pub const MSITRANSFORM_VALIDATE_PLATFORM = MSITRANSFORM_VALIDATE.PLATFORM;
pub const MSITRANSFORM_VALIDATE_MAJORVERSION = MSITRANSFORM_VALIDATE.MAJORVERSION;
pub const MSITRANSFORM_VALIDATE_MINORVERSION = MSITRANSFORM_VALIDATE.MINORVERSION;
pub const MSITRANSFORM_VALIDATE_UPDATEVERSION = MSITRANSFORM_VALIDATE.UPDATEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATEREQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATERBASEVERSION;
pub const MSITRANSFORM_VALIDATE_UPGRADECODE = MSITRANSFORM_VALIDATE.UPGRADECODE;

pub const ASSEMBLY_INFO = extern struct {
    cbAssemblyInfo: u32,
    dwAssemblyFlags: u32,
    uliAssemblySizeInKB: ULARGE_INTEGER,
    pszCurrentAssemblyPathBuf: ?PWSTR,
    cchBuf: u32,
};

pub const FUSION_INSTALL_REFERENCE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    guidScheme: Guid,
    szIdentifier: ?[*:0]const u16,
    szNonCannonicalData: ?[*:0]const u16,
};

pub const ASM_NAME = enum(i32) {
    PUBLIC_KEY = 0,
    PUBLIC_KEY_TOKEN = 1,
    HASH_VALUE = 2,
    NAME = 3,
    MAJOR_VERSION = 4,
    MINOR_VERSION = 5,
    BUILD_NUMBER = 6,
    REVISION_NUMBER = 7,
    CULTURE = 8,
    PROCESSOR_ID_ARRAY = 9,
    OSINFO_ARRAY = 10,
    HASH_ALGID = 11,
    ALIAS = 12,
    CODEBASE_URL = 13,
    CODEBASE_LASTMOD = 14,
    NULL_PUBLIC_KEY = 15,
    NULL_PUBLIC_KEY_TOKEN = 16,
    CUSTOM = 17,
    NULL_CUSTOM = 18,
    MVID = 19,
    MAX_PARAMS = 20,
};
pub const ASM_NAME_PUBLIC_KEY = ASM_NAME.PUBLIC_KEY;
pub const ASM_NAME_PUBLIC_KEY_TOKEN = ASM_NAME.PUBLIC_KEY_TOKEN;
pub const ASM_NAME_HASH_VALUE = ASM_NAME.HASH_VALUE;
pub const ASM_NAME_NAME = ASM_NAME.NAME;
pub const ASM_NAME_MAJOR_VERSION = ASM_NAME.MAJOR_VERSION;
pub const ASM_NAME_MINOR_VERSION = ASM_NAME.MINOR_VERSION;
pub const ASM_NAME_BUILD_NUMBER = ASM_NAME.BUILD_NUMBER;
pub const ASM_NAME_REVISION_NUMBER = ASM_NAME.REVISION_NUMBER;
pub const ASM_NAME_CULTURE = ASM_NAME.CULTURE;
pub const ASM_NAME_PROCESSOR_ID_ARRAY = ASM_NAME.PROCESSOR_ID_ARRAY;
pub const ASM_NAME_OSINFO_ARRAY = ASM_NAME.OSINFO_ARRAY;
pub const ASM_NAME_HASH_ALGID = ASM_NAME.HASH_ALGID;
pub const ASM_NAME_ALIAS = ASM_NAME.ALIAS;
pub const ASM_NAME_CODEBASE_URL = ASM_NAME.CODEBASE_URL;
pub const ASM_NAME_CODEBASE_LASTMOD = ASM_NAME.CODEBASE_LASTMOD;
pub const ASM_NAME_NULL_PUBLIC_KEY = ASM_NAME.NULL_PUBLIC_KEY;
pub const ASM_NAME_NULL_PUBLIC_KEY_TOKEN = ASM_NAME.NULL_PUBLIC_KEY_TOKEN;
pub const ASM_NAME_CUSTOM = ASM_NAME.CUSTOM;
pub const ASM_NAME_NULL_CUSTOM = ASM_NAME.NULL_CUSTOM;
pub const ASM_NAME_MVID = ASM_NAME.MVID;
pub const ASM_NAME_MAX_PARAMS = ASM_NAME.MAX_PARAMS;

pub const ASM_BIND_FLAGS = enum(u32) {
    FORCE_CACHE_INSTALL = 1,
    RFS_INTEGRITY_CHECK = 2,
    RFS_MODULE_CHECK = 4,
    BINPATH_PROBE_ONLY = 8,
    SHARED_BINPATH_HINT = 16,
    PARENT_ASM_HINT = 32,
    _,
    pub fn initFlags(o: struct {
        FORCE_CACHE_INSTALL: u1 = 0,
        RFS_INTEGRITY_CHECK: u1 = 0,
        RFS_MODULE_CHECK: u1 = 0,
        BINPATH_PROBE_ONLY: u1 = 0,
        SHARED_BINPATH_HINT: u1 = 0,
        PARENT_ASM_HINT: u1 = 0,
    }) ASM_BIND_FLAGS {
        return @as(ASM_BIND_FLAGS, @enumFromInt((if (o.FORCE_CACHE_INSTALL == 1) @intFromEnum(ASM_BIND_FLAGS.FORCE_CACHE_INSTALL) else 0) | (if (o.RFS_INTEGRITY_CHECK == 1) @intFromEnum(ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK) else 0) | (if (o.RFS_MODULE_CHECK == 1) @intFromEnum(ASM_BIND_FLAGS.RFS_MODULE_CHECK) else 0) | (if (o.BINPATH_PROBE_ONLY == 1) @intFromEnum(ASM_BIND_FLAGS.BINPATH_PROBE_ONLY) else 0) | (if (o.SHARED_BINPATH_HINT == 1) @intFromEnum(ASM_BIND_FLAGS.SHARED_BINPATH_HINT) else 0) | (if (o.PARENT_ASM_HINT == 1) @intFromEnum(ASM_BIND_FLAGS.PARENT_ASM_HINT) else 0)));
    }
};
pub const ASM_BINDF_FORCE_CACHE_INSTALL = ASM_BIND_FLAGS.FORCE_CACHE_INSTALL;
pub const ASM_BINDF_RFS_INTEGRITY_CHECK = ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK;
pub const ASM_BINDF_RFS_MODULE_CHECK = ASM_BIND_FLAGS.RFS_MODULE_CHECK;
pub const ASM_BINDF_BINPATH_PROBE_ONLY = ASM_BIND_FLAGS.BINPATH_PROBE_ONLY;
pub const ASM_BINDF_SHARED_BINPATH_HINT = ASM_BIND_FLAGS.SHARED_BINPATH_HINT;
pub const ASM_BINDF_PARENT_ASM_HINT = ASM_BIND_FLAGS.PARENT_ASM_HINT;

pub const ASM_DISPLAY_FLAGS = enum(i32) {
    VERSION = 1,
    CULTURE = 2,
    PUBLIC_KEY_TOKEN = 4,
    PUBLIC_KEY = 8,
    CUSTOM = 16,
    PROCESSORARCHITECTURE = 32,
    LANGUAGEID = 64,
};
pub const ASM_DISPLAYF_VERSION = ASM_DISPLAY_FLAGS.VERSION;
pub const ASM_DISPLAYF_CULTURE = ASM_DISPLAY_FLAGS.CULTURE;
pub const ASM_DISPLAYF_PUBLIC_KEY_TOKEN = ASM_DISPLAY_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_DISPLAYF_PUBLIC_KEY = ASM_DISPLAY_FLAGS.PUBLIC_KEY;
pub const ASM_DISPLAYF_CUSTOM = ASM_DISPLAY_FLAGS.CUSTOM;
pub const ASM_DISPLAYF_PROCESSORARCHITECTURE = ASM_DISPLAY_FLAGS.PROCESSORARCHITECTURE;
pub const ASM_DISPLAYF_LANGUAGEID = ASM_DISPLAY_FLAGS.LANGUAGEID;

pub const ASM_CMP_FLAGS = enum(i32) {
    NAME = 1,
    MAJOR_VERSION = 2,
    MINOR_VERSION = 4,
    BUILD_NUMBER = 8,
    REVISION_NUMBER = 16,
    PUBLIC_KEY_TOKEN = 32,
    CULTURE = 64,
    CUSTOM = 128,
    ALL = 255,
    DEFAULT = 256,
};
pub const ASM_CMPF_NAME = ASM_CMP_FLAGS.NAME;
pub const ASM_CMPF_MAJOR_VERSION = ASM_CMP_FLAGS.MAJOR_VERSION;
pub const ASM_CMPF_MINOR_VERSION = ASM_CMP_FLAGS.MINOR_VERSION;
pub const ASM_CMPF_BUILD_NUMBER = ASM_CMP_FLAGS.BUILD_NUMBER;
pub const ASM_CMPF_REVISION_NUMBER = ASM_CMP_FLAGS.REVISION_NUMBER;
pub const ASM_CMPF_PUBLIC_KEY_TOKEN = ASM_CMP_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_CMPF_CULTURE = ASM_CMP_FLAGS.CULTURE;
pub const ASM_CMPF_CUSTOM = ASM_CMP_FLAGS.CUSTOM;
pub const ASM_CMPF_ALL = ASM_CMP_FLAGS.ALL;
pub const ASM_CMPF_DEFAULT = ASM_CMP_FLAGS.DEFAULT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyName_Value = Guid.initString("cd193bc0-b4bc-11d2-9833-00c04fc31d2e");
pub const IID_IAssemblyName = &IID_IAssemblyName_Value;
pub const IAssemblyName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperty: *const fn (
            self: *const IAssemblyName,
            property_id: u32,
            pv_property: ?*anyopaque,
            cb_property: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const IAssemblyName,
            property_id: u32,
            pv_property: ?*anyopaque,
            pcb_property: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: *const fn (
            self: *const IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: *const fn (
            self: *const IAssemblyName,
            sz_display_name: ?[*:0]u16,
            pcc_display_name: ?*u32,
            dw_display_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: *const fn (
            self: *const IAssemblyName,
            ref_i_i_d: ?*const Guid,
            p_unk_reserved1: ?*IUnknown,
            p_unk_reserved2: ?*IUnknown,
            sz_reserved: ?[*:0]const u16,
            ll_reserved: i64,
            pv_reserved: ?*anyopaque,
            cb_reserved: u32,
            pp_reserved: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn (
            self: *const IAssemblyName,
            lpcw_buffer: ?*u32,
            pwz_name: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn (
            self: *const IAssemblyName,
            pdw_version_hi: ?*u32,
            pdw_version_low: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const IAssemblyName,
            p_name: ?*IAssemblyName,
            dw_cmp_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IAssemblyName,
            p_name: ?*?*IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setProperty(self: *const T, property_id_: u32, pv_property_: ?*anyopaque, cb_property_: u32) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IAssemblyName, @ptrCast(self)), property_id_, pv_property_, cb_property_);
            }
            pub inline fn getProperty(self: *const T, property_id_: u32, pv_property_: ?*anyopaque, pcb_property_: ?*u32) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IAssemblyName, @ptrCast(self)), property_id_, pv_property_, pcb_property_);
            }
            pub inline fn finalize(self: *const T) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).Finalize(@as(*const IAssemblyName, @ptrCast(self)));
            }
            pub inline fn getDisplayName(self: *const T, sz_display_name_: ?[*:0]u16, pcc_display_name_: ?*u32, dw_display_flags_: u32) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IAssemblyName, @ptrCast(self)), sz_display_name_, pcc_display_name_, dw_display_flags_);
            }
            pub inline fn reserved(self: *const T, ref_i_i_d_: ?*const Guid, p_unk_reserved1_: ?*IUnknown, p_unk_reserved2_: ?*IUnknown, sz_reserved_: ?[*:0]const u16, ll_reserved_: i64, pv_reserved_: ?*anyopaque, cb_reserved_: u32, pp_reserved_: ?*?*anyopaque) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).Reserved(@as(*const IAssemblyName, @ptrCast(self)), ref_i_i_d_, p_unk_reserved1_, p_unk_reserved2_, sz_reserved_, ll_reserved_, pv_reserved_, cb_reserved_, pp_reserved_);
            }
            pub inline fn getName(self: *const T, lpcw_buffer_: ?*u32, pwz_name_: ?[*:0]u16) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAssemblyName, @ptrCast(self)), lpcw_buffer_, pwz_name_);
            }
            pub inline fn getVersion(self: *const T, pdw_version_hi_: ?*u32, pdw_version_low_: ?*u32) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IAssemblyName, @ptrCast(self)), pdw_version_hi_, pdw_version_low_);
            }
            pub inline fn isEqual(self: *const T, p_name_: ?*IAssemblyName, dw_cmp_flags_: u32) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IAssemblyName, @ptrCast(self)), p_name_, dw_cmp_flags_);
            }
            pub inline fn clone(self: *const T, p_name_: ?*?*IAssemblyName) HRESULT {
                return @as(*const IAssemblyName.VTable, @ptrCast(self.vtable)).Clone(@as(*const IAssemblyName, @ptrCast(self)), p_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCacheItem_Value = Guid.initString("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCacheItem = &IID_IAssemblyCacheItem_Value;
pub const IAssemblyCacheItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: *const fn (
            self: *const IAssemblyCacheItem,
            dw_flags: u32,
            psz_stream_name: ?[*:0]const u16,
            dw_format: u32,
            dw_format_flags: u32,
            pp_i_stream: ?*?*IStream,
            puli_max_size: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IAssemblyCacheItem,
            dw_flags: u32,
            pul_disposition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItem: *const fn (
            self: *const IAssemblyCacheItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createStream(self: *const T, dw_flags_: u32, psz_stream_name_: ?[*:0]const u16, dw_format_: u32, dw_format_flags_: u32, pp_i_stream_: ?*?*IStream, puli_max_size_: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IAssemblyCacheItem.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const IAssemblyCacheItem, @ptrCast(self)), dw_flags_, psz_stream_name_, dw_format_, dw_format_flags_, pp_i_stream_, puli_max_size_);
            }
            pub inline fn commit(self: *const T, dw_flags_: u32, pul_disposition_: ?*u32) HRESULT {
                return @as(*const IAssemblyCacheItem.VTable, @ptrCast(self.vtable)).Commit(@as(*const IAssemblyCacheItem, @ptrCast(self)), dw_flags_, pul_disposition_);
            }
            pub inline fn abortItem(self: *const T) HRESULT {
                return @as(*const IAssemblyCacheItem.VTable, @ptrCast(self.vtable)).AbortItem(@as(*const IAssemblyCacheItem, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCache_Value = Guid.initString("e707dcde-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCache = &IID_IAssemblyCache_Value;
pub const IAssemblyCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UninstallAssembly: *const fn (
            self: *const IAssemblyCache,
            dw_flags: u32,
            psz_assembly_name: ?[*:0]const u16,
            p_ref_data: ?*FUSION_INSTALL_REFERENCE,
            pul_disposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssemblyInfo: *const fn (
            self: *const IAssemblyCache,
            dw_flags: QUERYASMINFO_FLAGS,
            psz_assembly_name: ?[*:0]const u16,
            p_asm_info: ?*ASSEMBLY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAssemblyCacheItem: *const fn (
            self: *const IAssemblyCache,
            dw_flags: u32,
            pv_reserved: ?*anyopaque,
            pp_asm_item: ?*?*IAssemblyCacheItem,
            psz_assembly_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: *const fn (
            self: *const IAssemblyCache,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallAssembly: *const fn (
            self: *const IAssemblyCache,
            dw_flags: u32,
            psz_manifest_file_path: ?[*:0]const u16,
            p_ref_data: ?*FUSION_INSTALL_REFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn uninstallAssembly(self: *const T, dw_flags_: u32, psz_assembly_name_: ?[*:0]const u16, p_ref_data_: ?*FUSION_INSTALL_REFERENCE, pul_disposition_: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION) HRESULT {
                return @as(*const IAssemblyCache.VTable, @ptrCast(self.vtable)).UninstallAssembly(@as(*const IAssemblyCache, @ptrCast(self)), dw_flags_, psz_assembly_name_, p_ref_data_, pul_disposition_);
            }
            pub inline fn queryAssemblyInfo(self: *const T, dw_flags_: QUERYASMINFO_FLAGS, psz_assembly_name_: ?[*:0]const u16, p_asm_info_: ?*ASSEMBLY_INFO) HRESULT {
                return @as(*const IAssemblyCache.VTable, @ptrCast(self.vtable)).QueryAssemblyInfo(@as(*const IAssemblyCache, @ptrCast(self)), dw_flags_, psz_assembly_name_, p_asm_info_);
            }
            pub inline fn createAssemblyCacheItem(self: *const T, dw_flags_: u32, pv_reserved_: ?*anyopaque, pp_asm_item_: ?*?*IAssemblyCacheItem, psz_assembly_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IAssemblyCache.VTable, @ptrCast(self.vtable)).CreateAssemblyCacheItem(@as(*const IAssemblyCache, @ptrCast(self)), dw_flags_, pv_reserved_, pp_asm_item_, psz_assembly_name_);
            }
            pub inline fn reserved(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAssemblyCache.VTable, @ptrCast(self.vtable)).Reserved(@as(*const IAssemblyCache, @ptrCast(self)), pp_unk_);
            }
            pub inline fn installAssembly(self: *const T, dw_flags_: u32, psz_manifest_file_path_: ?[*:0]const u16, p_ref_data_: ?*FUSION_INSTALL_REFERENCE) HRESULT {
                return @as(*const IAssemblyCache.VTable, @ptrCast(self.vtable)).InstallAssembly(@as(*const IAssemblyCache, @ptrCast(self)), dw_flags_, psz_manifest_file_path_, p_ref_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CREATE_ASM_NAME_OBJ_FLAGS = enum(i32) {
    PARSE_DISPLAY_NAME = 1,
    SET_DEFAULT_VALUES = 2,
};
pub const CANOF_PARSE_DISPLAY_NAME = CREATE_ASM_NAME_OBJ_FLAGS.PARSE_DISPLAY_NAME;
pub const CANOF_SET_DEFAULT_VALUES = CREATE_ASM_NAME_OBJ_FLAGS.SET_DEFAULT_VALUES;

pub const PROTECTED_FILE_DATA = extern struct {
    FileName: [260]u16,
    FileNumber: u32,
};

pub const msidbControlAttributes = enum(i32) {
    AttributesVisible = 1,
    AttributesEnabled = 2,
    AttributesSunken = 4,
    AttributesIndirect = 8,
    AttributesInteger = 16,
    AttributesRTLRO = 32,
    AttributesRightAligned = 64,
    AttributesLeftScroll = 128,
    AttributesBiDi = 224,
    AttributesTransparent = 65536,
    AttributesNoPrefix = 131072,
    AttributesNoWrap = 262144,
    AttributesFormatSize = 524288,
    AttributesUsersLanguage = 1048576,
    // AttributesMultiline = 65536, this enum value conflicts with AttributesTransparent
    AttributesPasswordInput = 2097152,
    // AttributesProgress95 = 65536, this enum value conflicts with AttributesTransparent
    // AttributesRemovableVolume = 65536, this enum value conflicts with AttributesTransparent
    // AttributesFixedVolume = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesRemoteVolume = 262144, this enum value conflicts with AttributesNoWrap
    // AttributesCDROMVolume = 524288, this enum value conflicts with AttributesFormatSize
    // AttributesRAMDiskVolume = 1048576, this enum value conflicts with AttributesUsersLanguage
    // AttributesFloppyVolume = 2097152, this enum value conflicts with AttributesPasswordInput
    ShowRollbackCost = 4194304,
    // AttributesSorted = 65536, this enum value conflicts with AttributesTransparent
    // AttributesComboList = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesImageHandle = 65536, this enum value conflicts with AttributesTransparent
    // AttributesPushLike = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesBitmap = 262144, this enum value conflicts with AttributesNoWrap
    // AttributesIcon = 524288, this enum value conflicts with AttributesFormatSize
    // AttributesFixedSize = 1048576, this enum value conflicts with AttributesUsersLanguage
    // AttributesIconSize16 = 2097152, this enum value conflicts with AttributesPasswordInput
    // AttributesIconSize32 = 4194304, this enum value conflicts with ShowRollbackCost
    AttributesIconSize48 = 6291456,
    AttributesElevationShield = 8388608,
    AttributesHasBorder = 16777216,
};
pub const msidbControlAttributesVisible = msidbControlAttributes.AttributesVisible;
pub const msidbControlAttributesEnabled = msidbControlAttributes.AttributesEnabled;
pub const msidbControlAttributesSunken = msidbControlAttributes.AttributesSunken;
pub const msidbControlAttributesIndirect = msidbControlAttributes.AttributesIndirect;
pub const msidbControlAttributesInteger = msidbControlAttributes.AttributesInteger;
pub const msidbControlAttributesRTLRO = msidbControlAttributes.AttributesRTLRO;
pub const msidbControlAttributesRightAligned = msidbControlAttributes.AttributesRightAligned;
pub const msidbControlAttributesLeftScroll = msidbControlAttributes.AttributesLeftScroll;
pub const msidbControlAttributesBiDi = msidbControlAttributes.AttributesBiDi;
pub const msidbControlAttributesTransparent = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesNoPrefix = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesNoWrap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesFormatSize = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesUsersLanguage = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesMultiline = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPasswordInput = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesProgress95 = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesRemovableVolume = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesFixedVolume = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesRemoteVolume = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesCDROMVolume = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesRAMDiskVolume = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesFloppyVolume = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlShowRollbackCost = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesSorted = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesComboList = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesImageHandle = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPushLike = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesBitmap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesIcon = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesFixedSize = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesIconSize16 = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesIconSize32 = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesIconSize48 = msidbControlAttributes.AttributesIconSize48;
pub const msidbControlAttributesElevationShield = msidbControlAttributes.AttributesElevationShield;
pub const msidbControlAttributesHasBorder = msidbControlAttributes.AttributesHasBorder;

pub const msidbLocatorType = enum(i32) {
    Directory = 0,
    FileName = 1,
    RawValue = 2,
    @"64bit" = 16,
};
pub const msidbLocatorTypeDirectory = msidbLocatorType.Directory;
pub const msidbLocatorTypeFileName = msidbLocatorType.FileName;
pub const msidbLocatorTypeRawValue = msidbLocatorType.RawValue;
pub const msidbLocatorType64bit = msidbLocatorType.@"64bit";

pub const msidbComponentAttributes = enum(i32) {
    LocalOnly = 0,
    SourceOnly = 1,
    Optional = 2,
    RegistryKeyPath = 4,
    SharedDllRefCount = 8,
    Permanent = 16,
    ODBCDataSource = 32,
    Transitive = 64,
    NeverOverwrite = 128,
    @"64bit" = 256,
    DisableRegistryReflection = 512,
    UninstallOnSupersedence = 1024,
    Shared = 2048,
};
pub const msidbComponentAttributesLocalOnly = msidbComponentAttributes.LocalOnly;
pub const msidbComponentAttributesSourceOnly = msidbComponentAttributes.SourceOnly;
pub const msidbComponentAttributesOptional = msidbComponentAttributes.Optional;
pub const msidbComponentAttributesRegistryKeyPath = msidbComponentAttributes.RegistryKeyPath;
pub const msidbComponentAttributesSharedDllRefCount = msidbComponentAttributes.SharedDllRefCount;
pub const msidbComponentAttributesPermanent = msidbComponentAttributes.Permanent;
pub const msidbComponentAttributesODBCDataSource = msidbComponentAttributes.ODBCDataSource;
pub const msidbComponentAttributesTransitive = msidbComponentAttributes.Transitive;
pub const msidbComponentAttributesNeverOverwrite = msidbComponentAttributes.NeverOverwrite;
pub const msidbComponentAttributes64bit = msidbComponentAttributes.@"64bit";
pub const msidbComponentAttributesDisableRegistryReflection = msidbComponentAttributes.DisableRegistryReflection;
pub const msidbComponentAttributesUninstallOnSupersedence = msidbComponentAttributes.UninstallOnSupersedence;
pub const msidbComponentAttributesShared = msidbComponentAttributes.Shared;

pub const msidbAssemblyAttributes = enum(i32) {
    URT = 0,
    Win32 = 1,
};
pub const msidbAssemblyAttributesURT = msidbAssemblyAttributes.URT;
pub const msidbAssemblyAttributesWin32 = msidbAssemblyAttributes.Win32;

pub const msidbCustomActionType = enum(i32) {
    Dll = 1,
    Exe = 2,
    TextData = 3,
    JScript = 5,
    VBScript = 6,
    Install = 7,
    BinaryData = 0,
    SourceFile = 16,
    Directory = 32,
    Property = 48,
    Continue = 64,
    Async = 128,
    FirstSequence = 256,
    OncePerProcess = 512,
    ClientRepeat = 768,
    InScript = 1024,
    // Rollback = 256, this enum value conflicts with FirstSequence
    // Commit = 512, this enum value conflicts with OncePerProcess
    NoImpersonate = 2048,
    TSAware = 16384,
    @"64BitScript" = 4096,
    HideTarget = 8192,
    PatchUninstall = 32768,
};
pub const msidbCustomActionTypeDll = msidbCustomActionType.Dll;
pub const msidbCustomActionTypeExe = msidbCustomActionType.Exe;
pub const msidbCustomActionTypeTextData = msidbCustomActionType.TextData;
pub const msidbCustomActionTypeJScript = msidbCustomActionType.JScript;
pub const msidbCustomActionTypeVBScript = msidbCustomActionType.VBScript;
pub const msidbCustomActionTypeInstall = msidbCustomActionType.Install;
pub const msidbCustomActionTypeBinaryData = msidbCustomActionType.BinaryData;
pub const msidbCustomActionTypeSourceFile = msidbCustomActionType.SourceFile;
pub const msidbCustomActionTypeDirectory = msidbCustomActionType.Directory;
pub const msidbCustomActionTypeProperty = msidbCustomActionType.Property;
pub const msidbCustomActionTypeContinue = msidbCustomActionType.Continue;
pub const msidbCustomActionTypeAsync = msidbCustomActionType.Async;
pub const msidbCustomActionTypeFirstSequence = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeOncePerProcess = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeClientRepeat = msidbCustomActionType.ClientRepeat;
pub const msidbCustomActionTypeInScript = msidbCustomActionType.InScript;
pub const msidbCustomActionTypeRollback = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeCommit = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeNoImpersonate = msidbCustomActionType.NoImpersonate;
pub const msidbCustomActionTypeTSAware = msidbCustomActionType.TSAware;
pub const msidbCustomActionType64BitScript = msidbCustomActionType.@"64BitScript";
pub const msidbCustomActionTypeHideTarget = msidbCustomActionType.HideTarget;
pub const msidbCustomActionTypePatchUninstall = msidbCustomActionType.PatchUninstall;

pub const msidbDialogAttributes = enum(i32) {
    Visible = 1,
    Modal = 2,
    Minimize = 4,
    SysModal = 8,
    KeepModeless = 16,
    TrackDiskSpace = 32,
    UseCustomPalette = 64,
    RTLRO = 128,
    RightAligned = 256,
    LeftScroll = 512,
    BiDi = 896,
    Error = 65536,
};
pub const msidbDialogAttributesVisible = msidbDialogAttributes.Visible;
pub const msidbDialogAttributesModal = msidbDialogAttributes.Modal;
pub const msidbDialogAttributesMinimize = msidbDialogAttributes.Minimize;
pub const msidbDialogAttributesSysModal = msidbDialogAttributes.SysModal;
pub const msidbDialogAttributesKeepModeless = msidbDialogAttributes.KeepModeless;
pub const msidbDialogAttributesTrackDiskSpace = msidbDialogAttributes.TrackDiskSpace;
pub const msidbDialogAttributesUseCustomPalette = msidbDialogAttributes.UseCustomPalette;
pub const msidbDialogAttributesRTLRO = msidbDialogAttributes.RTLRO;
pub const msidbDialogAttributesRightAligned = msidbDialogAttributes.RightAligned;
pub const msidbDialogAttributesLeftScroll = msidbDialogAttributes.LeftScroll;
pub const msidbDialogAttributesBiDi = msidbDialogAttributes.BiDi;
pub const msidbDialogAttributesError = msidbDialogAttributes.Error;

pub const msidbFeatureAttributes = enum(i32) {
    FavorLocal = 0,
    FavorSource = 1,
    FollowParent = 2,
    FavorAdvertise = 4,
    DisallowAdvertise = 8,
    UIDisallowAbsent = 16,
    NoUnsupportedAdvertise = 32,
};
pub const msidbFeatureAttributesFavorLocal = msidbFeatureAttributes.FavorLocal;
pub const msidbFeatureAttributesFavorSource = msidbFeatureAttributes.FavorSource;
pub const msidbFeatureAttributesFollowParent = msidbFeatureAttributes.FollowParent;
pub const msidbFeatureAttributesFavorAdvertise = msidbFeatureAttributes.FavorAdvertise;
pub const msidbFeatureAttributesDisallowAdvertise = msidbFeatureAttributes.DisallowAdvertise;
pub const msidbFeatureAttributesUIDisallowAbsent = msidbFeatureAttributes.UIDisallowAbsent;
pub const msidbFeatureAttributesNoUnsupportedAdvertise = msidbFeatureAttributes.NoUnsupportedAdvertise;

pub const msidbFileAttributes = enum(i32) {
    ReadOnly = 1,
    Hidden = 2,
    System = 4,
    Reserved0 = 8,
    IsolatedComp = 16,
    Reserved1 = 64,
    Reserved2 = 128,
    Reserved3 = 256,
    Vital = 512,
    Checksum = 1024,
    PatchAdded = 4096,
    Noncompressed = 8192,
    Compressed = 16384,
    Reserved4 = 32768,
};
pub const msidbFileAttributesReadOnly = msidbFileAttributes.ReadOnly;
pub const msidbFileAttributesHidden = msidbFileAttributes.Hidden;
pub const msidbFileAttributesSystem = msidbFileAttributes.System;
pub const msidbFileAttributesReserved0 = msidbFileAttributes.Reserved0;
pub const msidbFileAttributesIsolatedComp = msidbFileAttributes.IsolatedComp;
pub const msidbFileAttributesReserved1 = msidbFileAttributes.Reserved1;
pub const msidbFileAttributesReserved2 = msidbFileAttributes.Reserved2;
pub const msidbFileAttributesReserved3 = msidbFileAttributes.Reserved3;
pub const msidbFileAttributesVital = msidbFileAttributes.Vital;
pub const msidbFileAttributesChecksum = msidbFileAttributes.Checksum;
pub const msidbFileAttributesPatchAdded = msidbFileAttributes.PatchAdded;
pub const msidbFileAttributesNoncompressed = msidbFileAttributes.Noncompressed;
pub const msidbFileAttributesCompressed = msidbFileAttributes.Compressed;
pub const msidbFileAttributesReserved4 = msidbFileAttributes.Reserved4;

pub const msidbIniFileAction = enum(i32) {
    AddLine = 0,
    CreateLine = 1,
    RemoveLine = 2,
    AddTag = 3,
    RemoveTag = 4,
};
pub const msidbIniFileActionAddLine = msidbIniFileAction.AddLine;
pub const msidbIniFileActionCreateLine = msidbIniFileAction.CreateLine;
pub const msidbIniFileActionRemoveLine = msidbIniFileAction.RemoveLine;
pub const msidbIniFileActionAddTag = msidbIniFileAction.AddTag;
pub const msidbIniFileActionRemoveTag = msidbIniFileAction.RemoveTag;

pub const msidbMoveFileOptions = enum(i32) {
    e = 1,
};
pub const msidbMoveFileOptionsMove = msidbMoveFileOptions.e;

pub const msidbODBCDataSourceRegistration = enum(i32) {
    Machine = 0,
    User = 1,
};
pub const msidbODBCDataSourceRegistrationPerMachine = msidbODBCDataSourceRegistration.Machine;
pub const msidbODBCDataSourceRegistrationPerUser = msidbODBCDataSourceRegistration.User;

pub const msidbClassAttributes = enum(i32) {
    h = 1,
};
pub const msidbClassAttributesRelativePath = msidbClassAttributes.h;

pub const msidbPatchAttributes = enum(i32) {
    l = 1,
};
pub const msidbPatchAttributesNonVital = msidbPatchAttributes.l;

pub const msidbRegistryRoot = enum(i32) {
    ClassesRoot = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    Users = 3,
};
pub const msidbRegistryRootClassesRoot = msidbRegistryRoot.ClassesRoot;
pub const msidbRegistryRootCurrentUser = msidbRegistryRoot.CurrentUser;
pub const msidbRegistryRootLocalMachine = msidbRegistryRoot.LocalMachine;
pub const msidbRegistryRootUsers = msidbRegistryRoot.Users;

pub const msidbRemoveFileInstallMode = enum(i32) {
    Install = 1,
    Remove = 2,
    Both = 3,
};
pub const msidbRemoveFileInstallModeOnInstall = msidbRemoveFileInstallMode.Install;
pub const msidbRemoveFileInstallModeOnRemove = msidbRemoveFileInstallMode.Remove;
pub const msidbRemoveFileInstallModeOnBoth = msidbRemoveFileInstallMode.Both;

pub const msidbServiceControlEvent = enum(i32) {
    Start = 1,
    Stop = 2,
    Delete = 8,
    UninstallStart = 16,
    UninstallStop = 32,
    UninstallDelete = 128,
};
pub const msidbServiceControlEventStart = msidbServiceControlEvent.Start;
pub const msidbServiceControlEventStop = msidbServiceControlEvent.Stop;
pub const msidbServiceControlEventDelete = msidbServiceControlEvent.Delete;
pub const msidbServiceControlEventUninstallStart = msidbServiceControlEvent.UninstallStart;
pub const msidbServiceControlEventUninstallStop = msidbServiceControlEvent.UninstallStop;
pub const msidbServiceControlEventUninstallDelete = msidbServiceControlEvent.UninstallDelete;

pub const msidbServiceConfigEvent = enum(i32) {
    Install = 1,
    Uninstall = 2,
    Reinstall = 4,
};
pub const msidbServiceConfigEventInstall = msidbServiceConfigEvent.Install;
pub const msidbServiceConfigEventUninstall = msidbServiceConfigEvent.Uninstall;
pub const msidbServiceConfigEventReinstall = msidbServiceConfigEvent.Reinstall;

pub const msidbServiceInstallErrorControl = enum(i32) {
    l = 32768,
};
pub const msidbServiceInstallErrorControlVital = msidbServiceInstallErrorControl.l;

pub const msidbTextStyleStyleBits = enum(i32) {
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Strike = 8,
};
pub const msidbTextStyleStyleBitsBold = msidbTextStyleStyleBits.Bold;
pub const msidbTextStyleStyleBitsItalic = msidbTextStyleStyleBits.Italic;
pub const msidbTextStyleStyleBitsUnderline = msidbTextStyleStyleBits.Underline;
pub const msidbTextStyleStyleBitsStrike = msidbTextStyleStyleBits.Strike;

pub const msidbUpgradeAttributes = enum(i32) {
    MigrateFeatures = 1,
    OnlyDetect = 2,
    IgnoreRemoveFailure = 4,
    VersionMinInclusive = 256,
    VersionMaxInclusive = 512,
    LanguagesExclusive = 1024,
};
pub const msidbUpgradeAttributesMigrateFeatures = msidbUpgradeAttributes.MigrateFeatures;
pub const msidbUpgradeAttributesOnlyDetect = msidbUpgradeAttributes.OnlyDetect;
pub const msidbUpgradeAttributesIgnoreRemoveFailure = msidbUpgradeAttributes.IgnoreRemoveFailure;
pub const msidbUpgradeAttributesVersionMinInclusive = msidbUpgradeAttributes.VersionMinInclusive;
pub const msidbUpgradeAttributesVersionMaxInclusive = msidbUpgradeAttributes.VersionMaxInclusive;
pub const msidbUpgradeAttributesLanguagesExclusive = msidbUpgradeAttributes.LanguagesExclusive;

pub const msidbEmbeddedUIAttributes = enum(i32) {
    UI = 1,
    HandlesBasic = 2,
};
pub const msidbEmbeddedUI = msidbEmbeddedUIAttributes.UI;
pub const msidbEmbeddedHandlesBasic = msidbEmbeddedUIAttributes.HandlesBasic;

pub const msidbSumInfoSourceType = enum(i32) {
    SFN = 1,
    Compressed = 2,
    AdminImage = 4,
    LUAPackage = 8,
};
pub const msidbSumInfoSourceTypeSFN = msidbSumInfoSourceType.SFN;
pub const msidbSumInfoSourceTypeCompressed = msidbSumInfoSourceType.Compressed;
pub const msidbSumInfoSourceTypeAdminImage = msidbSumInfoSourceType.AdminImage;
pub const msidbSumInfoSourceTypeLUAPackage = msidbSumInfoSourceType.LUAPackage;

pub const msirbRebootType = enum(i32) {
    Immediate = 1,
    Deferred = 2,
};
pub const msirbRebootImmediate = msirbRebootType.Immediate;
pub const msirbRebootDeferred = msirbRebootType.Deferred;

pub const msirbRebootReason = enum(i32) {
    UndeterminedReason = 0,
    InUseFilesReason = 1,
    ScheduleRebootReason = 2,
    ForceRebootReason = 3,
    CustomActionReason = 4,
};
pub const msirbRebootUndeterminedReason = msirbRebootReason.UndeterminedReason;
pub const msirbRebootInUseFilesReason = msirbRebootReason.InUseFilesReason;
pub const msirbRebootScheduleRebootReason = msirbRebootReason.ScheduleRebootReason;
pub const msirbRebootForceRebootReason = msirbRebootReason.ForceRebootReason;
pub const msirbRebootCustomActionReason = msirbRebootReason.CustomActionReason;

pub const msifiFastInstallBits = enum(i32) {
    NoSR = 1,
    QuickCosting = 2,
    LessPrgMsg = 4,
};
pub const msifiFastInstallNoSR = msifiFastInstallBits.NoSR;
pub const msifiFastInstallQuickCosting = msifiFastInstallBits.QuickCosting;
pub const msifiFastInstallLessPrgMsg = msifiFastInstallBits.LessPrgMsg;

const CLSID_PMSvc_Value = Guid.initString("b9e511fc-e364-497a-a121-b7b3612cedce");
pub const CLSID_PMSvc = &CLSID_PMSvc_Value;

pub const TILE_TEMPLATE_TYPE = enum(i32) {
    INVALID = 0,
    FLIP = 5,
    DEEPLINK = 13,
    CYCLE = 14,
    METROCOUNT = 1,
    AGILESTORE = 2,
    GAMES = 3,
    CALENDAR = 4,
    MUSICVIDEO = 7,
    PEOPLE = 10,
    CONTACT = 11,
    GROUP = 12,
    DEFAULT = 15,
    BADGE = 16,
    BLOCK = 17,
    TEXT01 = 18,
    TEXT02 = 19,
    TEXT03 = 20,
    TEXT04 = 21,
    TEXT05 = 22,
    TEXT06 = 23,
    TEXT07 = 24,
    TEXT08 = 25,
    TEXT09 = 26,
    TEXT10 = 27,
    TEXT11 = 28,
    IMAGE = 29,
    IMAGECOLLECTION = 30,
    IMAGEANDTEXT01 = 31,
    IMAGEANDTEXT02 = 32,
    BLOCKANDTEXT01 = 33,
    BLOCKANDTEXT02 = 34,
    PEEKIMAGEANDTEXT01 = 35,
    PEEKIMAGEANDTEXT02 = 36,
    PEEKIMAGEANDTEXT03 = 37,
    PEEKIMAGEANDTEXT04 = 38,
    PEEKIMAGE01 = 39,
    PEEKIMAGE02 = 40,
    PEEKIMAGE03 = 41,
    PEEKIMAGE04 = 42,
    PEEKIMAGE05 = 43,
    PEEKIMAGE06 = 44,
    PEEKIMAGECOLLECTION01 = 45,
    PEEKIMAGECOLLECTION02 = 46,
    PEEKIMAGECOLLECTION03 = 47,
    PEEKIMAGECOLLECTION04 = 48,
    PEEKIMAGECOLLECTION05 = 49,
    PEEKIMAGECOLLECTION06 = 50,
    SMALLIMAGEANDTEXT01 = 51,
    SMALLIMAGEANDTEXT02 = 52,
    SMALLIMAGEANDTEXT03 = 53,
    SMALLIMAGEANDTEXT04 = 54,
    SMALLIMAGEANDTEXT05 = 55,
    METROCOUNTQUEUE = 56,
    SEARCH = 57,
    TILEFLYOUT01 = 58,
    FOLDER = 59,
    ALL = 100,
};
pub const TILE_TEMPLATE_INVALID = TILE_TEMPLATE_TYPE.INVALID;
pub const TILE_TEMPLATE_FLIP = TILE_TEMPLATE_TYPE.FLIP;
pub const TILE_TEMPLATE_DEEPLINK = TILE_TEMPLATE_TYPE.DEEPLINK;
pub const TILE_TEMPLATE_CYCLE = TILE_TEMPLATE_TYPE.CYCLE;
pub const TILE_TEMPLATE_METROCOUNT = TILE_TEMPLATE_TYPE.METROCOUNT;
pub const TILE_TEMPLATE_AGILESTORE = TILE_TEMPLATE_TYPE.AGILESTORE;
pub const TILE_TEMPLATE_GAMES = TILE_TEMPLATE_TYPE.GAMES;
pub const TILE_TEMPLATE_CALENDAR = TILE_TEMPLATE_TYPE.CALENDAR;
pub const TILE_TEMPLATE_MUSICVIDEO = TILE_TEMPLATE_TYPE.MUSICVIDEO;
pub const TILE_TEMPLATE_PEOPLE = TILE_TEMPLATE_TYPE.PEOPLE;
pub const TILE_TEMPLATE_CONTACT = TILE_TEMPLATE_TYPE.CONTACT;
pub const TILE_TEMPLATE_GROUP = TILE_TEMPLATE_TYPE.GROUP;
pub const TILE_TEMPLATE_DEFAULT = TILE_TEMPLATE_TYPE.DEFAULT;
pub const TILE_TEMPLATE_BADGE = TILE_TEMPLATE_TYPE.BADGE;
pub const TILE_TEMPLATE_BLOCK = TILE_TEMPLATE_TYPE.BLOCK;
pub const TILE_TEMPLATE_TEXT01 = TILE_TEMPLATE_TYPE.TEXT01;
pub const TILE_TEMPLATE_TEXT02 = TILE_TEMPLATE_TYPE.TEXT02;
pub const TILE_TEMPLATE_TEXT03 = TILE_TEMPLATE_TYPE.TEXT03;
pub const TILE_TEMPLATE_TEXT04 = TILE_TEMPLATE_TYPE.TEXT04;
pub const TILE_TEMPLATE_TEXT05 = TILE_TEMPLATE_TYPE.TEXT05;
pub const TILE_TEMPLATE_TEXT06 = TILE_TEMPLATE_TYPE.TEXT06;
pub const TILE_TEMPLATE_TEXT07 = TILE_TEMPLATE_TYPE.TEXT07;
pub const TILE_TEMPLATE_TEXT08 = TILE_TEMPLATE_TYPE.TEXT08;
pub const TILE_TEMPLATE_TEXT09 = TILE_TEMPLATE_TYPE.TEXT09;
pub const TILE_TEMPLATE_TEXT10 = TILE_TEMPLATE_TYPE.TEXT10;
pub const TILE_TEMPLATE_TEXT11 = TILE_TEMPLATE_TYPE.TEXT11;
pub const TILE_TEMPLATE_IMAGE = TILE_TEMPLATE_TYPE.IMAGE;
pub const TILE_TEMPLATE_IMAGECOLLECTION = TILE_TEMPLATE_TYPE.IMAGECOLLECTION;
pub const TILE_TEMPLATE_IMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT01;
pub const TILE_TEMPLATE_IMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT02;
pub const TILE_TEMPLATE_BLOCKANDTEXT01 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT01;
pub const TILE_TEMPLATE_BLOCKANDTEXT02 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT01;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT03;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT04;
pub const TILE_TEMPLATE_PEEKIMAGE01 = TILE_TEMPLATE_TYPE.PEEKIMAGE01;
pub const TILE_TEMPLATE_PEEKIMAGE02 = TILE_TEMPLATE_TYPE.PEEKIMAGE02;
pub const TILE_TEMPLATE_PEEKIMAGE03 = TILE_TEMPLATE_TYPE.PEEKIMAGE03;
pub const TILE_TEMPLATE_PEEKIMAGE04 = TILE_TEMPLATE_TYPE.PEEKIMAGE04;
pub const TILE_TEMPLATE_PEEKIMAGE05 = TILE_TEMPLATE_TYPE.PEEKIMAGE05;
pub const TILE_TEMPLATE_PEEKIMAGE06 = TILE_TEMPLATE_TYPE.PEEKIMAGE06;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION01 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION01;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION02 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION02;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION03 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION03;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION04 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION04;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION05 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION05;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION06 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION06;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT01;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT02;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT03;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT04;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT05 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT05;
pub const TILE_TEMPLATE_METROCOUNTQUEUE = TILE_TEMPLATE_TYPE.METROCOUNTQUEUE;
pub const TILE_TEMPLATE_SEARCH = TILE_TEMPLATE_TYPE.SEARCH;
pub const TILE_TEMPLATE_TILEFLYOUT01 = TILE_TEMPLATE_TYPE.TILEFLYOUT01;
pub const TILE_TEMPLATE_FOLDER = TILE_TEMPLATE_TYPE.FOLDER;
pub const TILE_TEMPLATE_ALL = TILE_TEMPLATE_TYPE.ALL;

pub const PM_APP_GENRE = enum(i32) {
    GAMES = 0,
    OTHER = 1,
    INVALID = 2,
};
pub const PM_APP_GENRE_GAMES = PM_APP_GENRE.GAMES;
pub const PM_APP_GENRE_OTHER = PM_APP_GENRE.OTHER;
pub const PM_APP_GENRE_INVALID = PM_APP_GENRE.INVALID;

pub const PM_APPLICATION_INSTALL_TYPE = enum(i32) {
    NORMAL = 0,
    IN_ROM = 1,
    PA = 2,
    DEBUG = 3,
    ENTERPRISE = 4,
    INVALID = 5,
};
pub const PM_APPLICATION_INSTALL_NORMAL = PM_APPLICATION_INSTALL_TYPE.NORMAL;
pub const PM_APPLICATION_INSTALL_IN_ROM = PM_APPLICATION_INSTALL_TYPE.IN_ROM;
pub const PM_APPLICATION_INSTALL_PA = PM_APPLICATION_INSTALL_TYPE.PA;
pub const PM_APPLICATION_INSTALL_DEBUG = PM_APPLICATION_INSTALL_TYPE.DEBUG;
pub const PM_APPLICATION_INSTALL_ENTERPRISE = PM_APPLICATION_INSTALL_TYPE.ENTERPRISE;
pub const PM_APPLICATION_INSTALL_INVALID = PM_APPLICATION_INSTALL_TYPE.INVALID;

pub const PM_APPLICATION_STATE = enum(i32) {
    MIN = 0,
    INSTALLED = 1,
    INSTALLING = 2,
    UPDATING = 3,
    UNINSTALLING = 4,
    LICENSE_UPDATING = 5,
    MOVING = 6,
    DISABLED_SD_CARD = 7,
    DISABLED_ENTERPRISE = 8,
    DISABLED_BACKING_UP = 9,
    DISABLED_MDIL_BINDING = 10,
    // MAX = 10, this enum value conflicts with DISABLED_MDIL_BINDING
    INVALID = 11,
};
pub const PM_APPLICATION_STATE_MIN = PM_APPLICATION_STATE.MIN;
pub const PM_APPLICATION_STATE_INSTALLED = PM_APPLICATION_STATE.INSTALLED;
pub const PM_APPLICATION_STATE_INSTALLING = PM_APPLICATION_STATE.INSTALLING;
pub const PM_APPLICATION_STATE_UPDATING = PM_APPLICATION_STATE.UPDATING;
pub const PM_APPLICATION_STATE_UNINSTALLING = PM_APPLICATION_STATE.UNINSTALLING;
pub const PM_APPLICATION_STATE_LICENSE_UPDATING = PM_APPLICATION_STATE.LICENSE_UPDATING;
pub const PM_APPLICATION_STATE_MOVING = PM_APPLICATION_STATE.MOVING;
pub const PM_APPLICATION_STATE_DISABLED_SD_CARD = PM_APPLICATION_STATE.DISABLED_SD_CARD;
pub const PM_APPLICATION_STATE_DISABLED_ENTERPRISE = PM_APPLICATION_STATE.DISABLED_ENTERPRISE;
pub const PM_APPLICATION_STATE_DISABLED_BACKING_UP = PM_APPLICATION_STATE.DISABLED_BACKING_UP;
pub const PM_APPLICATION_STATE_DISABLED_MDIL_BINDING = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_MAX = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_INVALID = PM_APPLICATION_STATE.INVALID;

pub const PM_APPLICATION_HUBTYPE = enum(i32) {
    NONMUSIC = 0,
    MUSIC = 1,
    INVALID = 2,
};
pub const PM_APPLICATION_HUBTYPE_NONMUSIC = PM_APPLICATION_HUBTYPE.NONMUSIC;
pub const PM_APPLICATION_HUBTYPE_MUSIC = PM_APPLICATION_HUBTYPE.MUSIC;
pub const PM_APPLICATION_HUBTYPE_INVALID = PM_APPLICATION_HUBTYPE.INVALID;

pub const PM_TILE_HUBTYPE = enum(i32) {
    MUSIC = 1,
    MOSETTINGS = 268435456,
    GAMES = 536870912,
    APPLIST = 1073741824,
    STARTMENU = -2147483648,
    LOCKSCREEN = 16777216,
    KIDZONE = 33554432,
    CACHED = 67108864,
    INVALID = 67108865,
};
pub const PM_TILE_HUBTYPE_MUSIC = PM_TILE_HUBTYPE.MUSIC;
pub const PM_TILE_HUBTYPE_MOSETTINGS = PM_TILE_HUBTYPE.MOSETTINGS;
pub const PM_TILE_HUBTYPE_GAMES = PM_TILE_HUBTYPE.GAMES;
pub const PM_TILE_HUBTYPE_APPLIST = PM_TILE_HUBTYPE.APPLIST;
pub const PM_TILE_HUBTYPE_STARTMENU = PM_TILE_HUBTYPE.STARTMENU;
pub const PM_TILE_HUBTYPE_LOCKSCREEN = PM_TILE_HUBTYPE.LOCKSCREEN;
pub const PM_TILE_HUBTYPE_KIDZONE = PM_TILE_HUBTYPE.KIDZONE;
pub const PM_TILE_HUBTYPE_CACHED = PM_TILE_HUBTYPE.CACHED;
pub const PM_TILE_HUBTYPE_INVALID = PM_TILE_HUBTYPE.INVALID;

pub const PM_STARTTILE_TYPE = enum(i32) {
    PRIMARY = 1,
    SECONDARY = 2,
    APPLIST = 3,
    APPLISTPRIMARY = 4,
    INVALID = 5,
};
pub const PM_STARTTILE_TYPE_PRIMARY = PM_STARTTILE_TYPE.PRIMARY;
pub const PM_STARTTILE_TYPE_SECONDARY = PM_STARTTILE_TYPE.SECONDARY;
pub const PM_STARTTILE_TYPE_APPLIST = PM_STARTTILE_TYPE.APPLIST;
pub const PM_STARTTILE_TYPE_APPLISTPRIMARY = PM_STARTTILE_TYPE.APPLISTPRIMARY;
pub const PM_STARTTILE_TYPE_INVALID = PM_STARTTILE_TYPE.INVALID;

pub const PM_TASK_TYPE = enum(i32) {
    NORMAL = 0,
    DEFAULT = 1,
    SETTINGS = 2,
    BACKGROUNDSERVICEAGENT = 3,
    BACKGROUNDWORKER = 4,
    INVALID = 5,
};
pub const PM_TASK_TYPE_NORMAL = PM_TASK_TYPE.NORMAL;
pub const PM_TASK_TYPE_DEFAULT = PM_TASK_TYPE.DEFAULT;
pub const PM_TASK_TYPE_SETTINGS = PM_TASK_TYPE.SETTINGS;
pub const PM_TASK_TYPE_BACKGROUNDSERVICEAGENT = PM_TASK_TYPE.BACKGROUNDSERVICEAGENT;
pub const PM_TASK_TYPE_BACKGROUNDWORKER = PM_TASK_TYPE.BACKGROUNDWORKER;
pub const PM_TASK_TYPE_INVALID = PM_TASK_TYPE.INVALID;

pub const PACKMAN_RUNTIME = enum(i32) {
    NATIVE = 1,
    SILVERLIGHTMOBILE = 2,
    XNA = 3,
    MODERN_NATIVE = 4,
    JUPITER = 5,
    INVALID = 6,
};
pub const PACKMAN_RUNTIME_NATIVE = PACKMAN_RUNTIME.NATIVE;
pub const PACKMAN_RUNTIME_SILVERLIGHTMOBILE = PACKMAN_RUNTIME.SILVERLIGHTMOBILE;
pub const PACKMAN_RUNTIME_XNA = PACKMAN_RUNTIME.XNA;
pub const PACKMAN_RUNTIME_MODERN_NATIVE = PACKMAN_RUNTIME.MODERN_NATIVE;
pub const PACKMAN_RUNTIME_JUPITER = PACKMAN_RUNTIME.JUPITER;
pub const PACKMAN_RUNTIME_INVALID = PACKMAN_RUNTIME.INVALID;

pub const PM_ACTIVATION_POLICY = enum(i32) {
    RESUME = 0,
    RESUMESAMEPARAMS = 1,
    REPLACE = 2,
    REPLACESAMEPARAMS = 3,
    MULTISESSION = 4,
    REPLACE_IGNOREFOREGROUND = 5,
    UNKNOWN = 6,
    INVALID = 7,
};
pub const PM_ACTIVATION_POLICY_RESUME = PM_ACTIVATION_POLICY.RESUME;
pub const PM_ACTIVATION_POLICY_RESUMESAMEPARAMS = PM_ACTIVATION_POLICY.RESUMESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_REPLACE = PM_ACTIVATION_POLICY.REPLACE;
pub const PM_ACTIVATION_POLICY_REPLACESAMEPARAMS = PM_ACTIVATION_POLICY.REPLACESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_MULTISESSION = PM_ACTIVATION_POLICY.MULTISESSION;
pub const PM_ACTIVATION_POLICY_REPLACE_IGNOREFOREGROUND = PM_ACTIVATION_POLICY.REPLACE_IGNOREFOREGROUND;
pub const PM_ACTIVATION_POLICY_UNKNOWN = PM_ACTIVATION_POLICY.UNKNOWN;
pub const PM_ACTIVATION_POLICY_INVALID = PM_ACTIVATION_POLICY.INVALID;

pub const PM_TASK_TRANSITION = enum(i32) {
    DEFAULT = 0,
    NONE = 1,
    TURNSTILE = 2,
    SLIDE = 3,
    SWIVEL = 4,
    READERBOARD = 5,
    CUSTOM = 6,
    INVALID = 7,
};
pub const PM_TASK_TRANSITION_DEFAULT = PM_TASK_TRANSITION.DEFAULT;
pub const PM_TASK_TRANSITION_NONE = PM_TASK_TRANSITION.NONE;
pub const PM_TASK_TRANSITION_TURNSTILE = PM_TASK_TRANSITION.TURNSTILE;
pub const PM_TASK_TRANSITION_SLIDE = PM_TASK_TRANSITION.SLIDE;
pub const PM_TASK_TRANSITION_SWIVEL = PM_TASK_TRANSITION.SWIVEL;
pub const PM_TASK_TRANSITION_READERBOARD = PM_TASK_TRANSITION.READERBOARD;
pub const PM_TASK_TRANSITION_CUSTOM = PM_TASK_TRANSITION.CUSTOM;
pub const PM_TASK_TRANSITION_INVALID = PM_TASK_TRANSITION.INVALID;

pub const PM_ENUM_APP_FILTER = enum(i32) {
    ALL = 0,
    VISIBLE = 1,
    GENRE = 2,
    NONGAMES = 3,
    HUBTYPE = 4,
    PINABLEONKIDZONE = 5,
    ALL_INCLUDE_MODERN = 6,
    FRAMEWORK = 7,
    MAX = 8,
};
pub const PM_APP_FILTER_ALL = PM_ENUM_APP_FILTER.ALL;
pub const PM_APP_FILTER_VISIBLE = PM_ENUM_APP_FILTER.VISIBLE;
pub const PM_APP_FILTER_GENRE = PM_ENUM_APP_FILTER.GENRE;
pub const PM_APP_FILTER_NONGAMES = PM_ENUM_APP_FILTER.NONGAMES;
pub const PM_APP_FILTER_HUBTYPE = PM_ENUM_APP_FILTER.HUBTYPE;
pub const PM_APP_FILTER_PINABLEONKIDZONE = PM_ENUM_APP_FILTER.PINABLEONKIDZONE;
pub const PM_APP_FILTER_ALL_INCLUDE_MODERN = PM_ENUM_APP_FILTER.ALL_INCLUDE_MODERN;
pub const PM_APP_FILTER_FRAMEWORK = PM_ENUM_APP_FILTER.FRAMEWORK;
pub const PM_APP_FILTER_MAX = PM_ENUM_APP_FILTER.MAX;

pub const PM_ENUM_TILE_FILTER = enum(i32) {
    APPLIST = 8,
    PINNED = 9,
    HUBTYPE = 10,
    APP_ALL = 11,
    MAX = 12,
};
pub const PM_TILE_FILTER_APPLIST = PM_ENUM_TILE_FILTER.APPLIST;
pub const PM_TILE_FILTER_PINNED = PM_ENUM_TILE_FILTER.PINNED;
pub const PM_TILE_FILTER_HUBTYPE = PM_ENUM_TILE_FILTER.HUBTYPE;
pub const PM_TILE_FILTER_APP_ALL = PM_ENUM_TILE_FILTER.APP_ALL;
pub const PM_TILE_FILTER_MAX = PM_ENUM_TILE_FILTER.MAX;

pub const PM_ENUM_TASK_FILTER = enum(i32) {
    APP_ALL = 12,
    TASK_TYPE = 13,
    DEHYD_SUPRESSING = 14,
    APP_TASK_TYPE = 15,
    BGEXECUTION = 16,
    MAX = 17,
};
pub const PM_TASK_FILTER_APP_ALL = PM_ENUM_TASK_FILTER.APP_ALL;
pub const PM_TASK_FILTER_TASK_TYPE = PM_ENUM_TASK_FILTER.TASK_TYPE;
pub const PM_TASK_FILTER_DEHYD_SUPRESSING = PM_ENUM_TASK_FILTER.DEHYD_SUPRESSING;
pub const PM_TASK_FILTER_APP_TASK_TYPE = PM_ENUM_TASK_FILTER.APP_TASK_TYPE;
pub const PM_TASK_FILTER_BGEXECUTION = PM_ENUM_TASK_FILTER.BGEXECUTION;
pub const PM_TASK_FILTER_MAX = PM_ENUM_TASK_FILTER.MAX;

pub const PM_ENUM_EXTENSION_FILTER = enum(i32) {
    BY_CONSUMER = 17,
    // APPCONNECT = 17, this enum value conflicts with BY_CONSUMER
    PROTOCOL_ALL = 18,
    FTASSOC_FILETYPE_ALL = 19,
    FTASSOC_CONTENTTYPE_ALL = 20,
    FTASSOC_APPLICATION_ALL = 21,
    SHARETARGET_ALL = 22,
    FILEOPENPICKER_ALL = 23,
    FILESAVEPICKER_ALL = 24,
    CACHEDFILEUPDATER_ALL = 25,
    MAX = 26,
};
pub const PM_ENUM_EXTENSION_FILTER_BY_CONSUMER = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_APPCONNECT = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_PROTOCOL_ALL = PM_ENUM_EXTENSION_FILTER.PROTOCOL_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_FILETYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_FILETYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_CONTENTTYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_CONTENTTYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_APPLICATION_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_APPLICATION_ALL;
pub const PM_ENUM_EXTENSION_FILTER_SHARETARGET_ALL = PM_ENUM_EXTENSION_FILTER.SHARETARGET_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILEOPENPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILEOPENPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILESAVEPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILESAVEPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_CACHEDFILEUPDATER_ALL = PM_ENUM_EXTENSION_FILTER.CACHEDFILEUPDATER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_MAX = PM_ENUM_EXTENSION_FILTER.MAX;

pub const PM_ENUM_BSA_FILTER = enum(i32) {
    ALL = 26,
    BY_TASKID = 27,
    BY_PRODUCTID = 28,
    BY_PERIODIC = 29,
    BY_ALL_LAUNCHONBOOT = 30,
    MAX = 31,
};
pub const PM_ENUM_BSA_FILTER_ALL = PM_ENUM_BSA_FILTER.ALL;
pub const PM_ENUM_BSA_FILTER_BY_TASKID = PM_ENUM_BSA_FILTER.BY_TASKID;
pub const PM_ENUM_BSA_FILTER_BY_PRODUCTID = PM_ENUM_BSA_FILTER.BY_PRODUCTID;
pub const PM_ENUM_BSA_FILTER_BY_PERIODIC = PM_ENUM_BSA_FILTER.BY_PERIODIC;
pub const PM_ENUM_BSA_FILTER_BY_ALL_LAUNCHONBOOT = PM_ENUM_BSA_FILTER.BY_ALL_LAUNCHONBOOT;
pub const PM_ENUM_BSA_FILTER_MAX = PM_ENUM_BSA_FILTER.MAX;

pub const PM_ENUM_BW_FILTER = enum(i32) {
    BOOTWORKER_ALL = 31,
    BY_TASKID = 32,
    MAX = 33,
};
pub const PM_ENUM_BW_FILTER_BOOTWORKER_ALL = PM_ENUM_BW_FILTER.BOOTWORKER_ALL;
pub const PM_ENUM_BW_FILTER_BY_TASKID = PM_ENUM_BW_FILTER.BY_TASKID;
pub const PM_ENUM_BW_FILTER_MAX = PM_ENUM_BW_FILTER.MAX;

pub const _tagAPPTASKTYPE = extern struct {
    ProductID: Guid,
    TaskType: PM_TASK_TYPE,
};

pub const PM_EXTENSIONCONSUMER = extern struct {
    ConsumerPID: Guid,
    ExtensionID: ?BSTR,
};

pub const PM_BSATASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_BWTASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_ENUM_FILTER = extern struct {
    FilterType: i32,
    FilterParameter: extern union {
        Dummy: i32,
        Genre: PM_APP_GENRE,
        AppHubType: PM_APPLICATION_HUBTYPE,
        HubType: PM_TILE_HUBTYPE,
        Tasktype: PM_TASK_TYPE,
        TaskProductID: Guid,
        TileProductID: Guid,
        AppTaskType: _tagAPPTASKTYPE,
        Consumer: PM_EXTENSIONCONSUMER,
        BSATask: PM_BSATASKID,
        BSAProductID: Guid,
        BWTask: PM_BWTASKID,
        ProtocolName: ?BSTR,
        FileType: ?BSTR,
        ContentType: ?BSTR,
        AppSupportedFileExtPID: Guid,
        ShareTargetFileType: ?BSTR,
    },
};

pub const PM_LIVETILE_RECURRENCE_TYPE = enum(i32) {
    INSTANT = 0,
    ONETIME = 1,
    INTERVAL = 2,
    // MAX = 2, this enum value conflicts with INTERVAL
};
pub const PM_LIVETILE_RECURRENCE_TYPE_INSTANT = PM_LIVETILE_RECURRENCE_TYPE.INSTANT;
pub const PM_LIVETILE_RECURRENCE_TYPE_ONETIME = PM_LIVETILE_RECURRENCE_TYPE.ONETIME;
pub const PM_LIVETILE_RECURRENCE_TYPE_INTERVAL = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;
pub const PM_LIVETILE_RECURRENCE_TYPE_MAX = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;

pub const PM_TILE_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    SQUARE310X310 = 3,
    TALL150X310 = 4,
    INVALID = 5,
};
pub const PM_TILE_SIZE_SMALL = PM_TILE_SIZE.SMALL;
pub const PM_TILE_SIZE_MEDIUM = PM_TILE_SIZE.MEDIUM;
pub const PM_TILE_SIZE_LARGE = PM_TILE_SIZE.LARGE;
pub const PM_TILE_SIZE_SQUARE310X310 = PM_TILE_SIZE.SQUARE310X310;
pub const PM_TILE_SIZE_TALL150X310 = PM_TILE_SIZE.TALL150X310;
pub const PM_TILE_SIZE_INVALID = PM_TILE_SIZE.INVALID;

pub const PM_LOGO_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    INVALID = 3,
};
pub const PM_LOGO_SIZE_SMALL = PM_LOGO_SIZE.SMALL;
pub const PM_LOGO_SIZE_MEDIUM = PM_LOGO_SIZE.MEDIUM;
pub const PM_LOGO_SIZE_LARGE = PM_LOGO_SIZE.LARGE;
pub const PM_LOGO_SIZE_INVALID = PM_LOGO_SIZE.INVALID;

pub const PM_STARTAPPBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    AppTitle: ?BSTR,
    IconPath: ?BSTR,
    IsUninstallable: BOOL,
    AppInstallType: PM_APPLICATION_INSTALL_TYPE,
    InstanceID: Guid,
    State: PM_APPLICATION_STATE,
    IsModern: BOOL,
    IsModernLightUp: BOOL,
    LightUpSupportMask: u16,
};

pub const PM_INVOCATIONINFO = extern struct {
    URIBaseOrAUMID: ?BSTR,
    URIFragmentOrArgs: ?BSTR,
};

pub const PM_STARTTILEBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    TileID: ?BSTR,
    TemplateType: TILE_TEMPLATE_TYPE,
    HubPosition: [32]u32,
    HubVisibilityBitmask: u32,
    IsDefault: BOOL,
    TileType: PM_STARTTILE_TYPE,
    pbPropBlob: ?*u8,
    cbPropBlob: u32,
    IsRestoring: BOOL,
    IsModern: BOOL,
    InvocationInfo: PM_INVOCATIONINFO,
};

pub const PM_INSTALLINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    IsUninstallDisabled: BOOL,
    DeploymentOptions: u32,
    OfferID: Guid,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO_LEGACY = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
    DeploymentOptions: u32,
};

const IID_IPMApplicationInfo_Value = Guid.initString("50afb58a-438c-4088-9789-f8c4899829c7");
pub const IID_IPMApplicationInfo = &IID_IPMApplicationInfo_Value;
pub const IPMApplicationInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstanceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_instance_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfferID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_offer_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultTask: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_default_task: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppTitle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_app_title: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_app_icon_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_notified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppInstallType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_app_install_type: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_state: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRevoked: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_revoked: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdateAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_update_available: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallDate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_install_date: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsUninstallable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_uninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_themable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsTrial: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_trial: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_install_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRoot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_data_root: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Genre: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_genre: ?*PM_APP_GENRE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Publisher: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_publisher: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_author: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_major_ver: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_minor_ver: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_publisher_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMultiCore: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_multi_core: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersionLightUp: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_major_ver: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersionLightUp: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_minor_ver: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UpdateAvailable: *const fn (
            self: *const IPMApplicationInfo,
            is_update_available: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotificationState: *const fn (
            self: *const IPMApplicationInfo,
            is_notified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IconPath: *const fn (
            self: *const IPMApplicationInfo,
            app_icon_path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UninstallableState: *const fn (
            self: *const IPMApplicationInfo,
            is_uninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPinableOnKidZone: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_pinable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyPreInstalled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_preinstalled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInstallOnSD: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_install_on_s_d: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutOnSD: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_optout_on_s_d: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutBackupRestore: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_optout_backup_restore: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseDisabled: *const fn (
            self: *const IPMApplicationInfo,
            is_disabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseUninstallable: *const fn (
            self: *const IPMApplicationInfo,
            is_uninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            is_disabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseUninstallable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            is_uninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsVisibleOnAppList: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_visible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInboxApp: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_inbox_app: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StorageID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_storage_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAppBlob: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_blob: ?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMovable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_movable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeploymentAppEnumerationHubFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            hub_type: ?*PM_TILE_HUBTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedDate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_modified_date: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyRestored: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            p_is_restored: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShouldDeferMdilBind: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            pf_defer_mdil_bind: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFullyPreInstall: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfo,
            pf_is_fully_pre_install: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsMdilMaintenanceNeeded: *const fn (
            self: *const IPMApplicationInfo,
            f_is_mdil_maintenance_needed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Title: *const fn (
            self: *const IPMApplicationInfo,
            app_title: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getInstanceID(self: *const T, p_instance_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_InstanceID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_instance_i_d_);
            }
            pub inline fn getOfferID(self: *const T, p_offer_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_OfferID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_offer_i_d_);
            }
            pub inline fn getDefaultTask(self: *const T, p_default_task_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_DefaultTask(@as(*const IPMApplicationInfo, @ptrCast(self)), p_default_task_);
            }
            pub inline fn getAppTitle(self: *const T, p_app_title_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppTitle(@as(*const IPMApplicationInfo, @ptrCast(self)), p_app_title_);
            }
            pub inline fn getIconPath(self: *const T, p_app_icon_path_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IconPath(@as(*const IPMApplicationInfo, @ptrCast(self)), p_app_icon_path_);
            }
            pub inline fn getNotificationState(self: *const T, p_is_notified_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_NotificationState(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_notified_);
            }
            pub inline fn getAppInstallType(self: *const T, p_app_install_type_: ?*PM_APPLICATION_INSTALL_TYPE) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppInstallType(@as(*const IPMApplicationInfo, @ptrCast(self)), p_app_install_type_);
            }
            pub inline fn getState(self: *const T, p_state_: ?*PM_APPLICATION_STATE) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_State(@as(*const IPMApplicationInfo, @ptrCast(self)), p_state_);
            }
            pub inline fn getIsRevoked(self: *const T, p_is_revoked_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsRevoked(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_revoked_);
            }
            pub inline fn getUpdateAvailable(self: *const T, p_is_update_available_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_UpdateAvailable(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_update_available_);
            }
            pub inline fn getInstallDate(self: *const T, p_install_date_: ?*FILETIME) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_InstallDate(@as(*const IPMApplicationInfo, @ptrCast(self)), p_install_date_);
            }
            pub inline fn getIsUninstallable(self: *const T, p_is_uninstallable_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsUninstallable(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_uninstallable_);
            }
            pub inline fn getIsThemable(self: *const T, p_is_themable_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsThemable(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_themable_);
            }
            pub inline fn getIsTrial(self: *const T, p_is_trial_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsTrial(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_trial_);
            }
            pub inline fn getInstallPath(self: *const T, p_install_path_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_InstallPath(@as(*const IPMApplicationInfo, @ptrCast(self)), p_install_path_);
            }
            pub inline fn getDataRoot(self: *const T, p_data_root_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_DataRoot(@as(*const IPMApplicationInfo, @ptrCast(self)), p_data_root_);
            }
            pub inline fn getGenre(self: *const T, p_genre_: ?*PM_APP_GENRE) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_Genre(@as(*const IPMApplicationInfo, @ptrCast(self)), p_genre_);
            }
            pub inline fn getPublisher(self: *const T, p_publisher_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_Publisher(@as(*const IPMApplicationInfo, @ptrCast(self)), p_publisher_);
            }
            pub inline fn getAuthor(self: *const T, p_author_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_Author(@as(*const IPMApplicationInfo, @ptrCast(self)), p_author_);
            }
            pub inline fn getDescription(self: *const T, p_description_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IPMApplicationInfo, @ptrCast(self)), p_description_);
            }
            pub inline fn getVersion(self: *const T, p_version_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_Version(@as(*const IPMApplicationInfo, @ptrCast(self)), p_version_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMApplicationInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
            pub inline fn getAppPlatMajorVersion(self: *const T, p_major_ver_: ?*u8) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppPlatMajorVersion(@as(*const IPMApplicationInfo, @ptrCast(self)), p_major_ver_);
            }
            pub inline fn getAppPlatMinorVersion(self: *const T, p_minor_ver_: ?*u8) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppPlatMinorVersion(@as(*const IPMApplicationInfo, @ptrCast(self)), p_minor_ver_);
            }
            pub inline fn getPublisherID(self: *const T, p_publisher_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_PublisherID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_publisher_i_d_);
            }
            pub inline fn getIsMultiCore(self: *const T, p_is_multi_core_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsMultiCore(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_multi_core_);
            }
            pub inline fn getSID(self: *const T, p_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_SID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_s_i_d_);
            }
            pub inline fn getAppPlatMajorVersionLightUp(self: *const T, p_major_ver_: ?*u8) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppPlatMajorVersionLightUp(@as(*const IPMApplicationInfo, @ptrCast(self)), p_major_ver_);
            }
            pub inline fn getAppPlatMinorVersionLightUp(self: *const T, p_minor_ver_: ?*u8) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_AppPlatMinorVersionLightUp(@as(*const IPMApplicationInfo, @ptrCast(self)), p_minor_ver_);
            }
            pub inline fn setUpdateAvailable(self: *const T, is_update_available_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_UpdateAvailable(@as(*const IPMApplicationInfo, @ptrCast(self)), is_update_available_);
            }
            pub inline fn setNotificationState(self: *const T, is_notified_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_NotificationState(@as(*const IPMApplicationInfo, @ptrCast(self)), is_notified_);
            }
            pub inline fn setIconPath(self: *const T, app_icon_path_: ?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_IconPath(@as(*const IPMApplicationInfo, @ptrCast(self)), app_icon_path_);
            }
            pub inline fn setUninstallableState(self: *const T, is_uninstallable_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_UninstallableState(@as(*const IPMApplicationInfo, @ptrCast(self)), is_uninstallable_);
            }
            pub inline fn getIsPinableOnKidZone(self: *const T, p_is_pinable_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsPinableOnKidZone(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_pinable_);
            }
            pub inline fn getIsOriginallyPreInstalled(self: *const T, p_is_preinstalled_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsOriginallyPreInstalled(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_preinstalled_);
            }
            pub inline fn getIsInstallOnSD(self: *const T, p_is_install_on_s_d_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsInstallOnSD(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_install_on_s_d_);
            }
            pub inline fn getIsOptoutOnSD(self: *const T, p_is_optout_on_s_d_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsOptoutOnSD(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_optout_on_s_d_);
            }
            pub inline fn getIsOptoutBackupRestore(self: *const T, p_is_optout_backup_restore_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsOptoutBackupRestore(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_optout_backup_restore_);
            }
            pub inline fn setEnterpriseDisabled(self: *const T, is_disabled_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_EnterpriseDisabled(@as(*const IPMApplicationInfo, @ptrCast(self)), is_disabled_);
            }
            pub inline fn setEnterpriseUninstallable(self: *const T, is_uninstallable_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_EnterpriseUninstallable(@as(*const IPMApplicationInfo, @ptrCast(self)), is_uninstallable_);
            }
            pub inline fn getEnterpriseDisabled(self: *const T, is_disabled_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_EnterpriseDisabled(@as(*const IPMApplicationInfo, @ptrCast(self)), is_disabled_);
            }
            pub inline fn getEnterpriseUninstallable(self: *const T, is_uninstallable_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_EnterpriseUninstallable(@as(*const IPMApplicationInfo, @ptrCast(self)), is_uninstallable_);
            }
            pub inline fn getIsVisibleOnAppList(self: *const T, p_is_visible_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsVisibleOnAppList(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_visible_);
            }
            pub inline fn getIsInboxApp(self: *const T, p_is_inbox_app_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsInboxApp(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_inbox_app_);
            }
            pub inline fn getStorageID(self: *const T, p_storage_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_StorageID(@as(*const IPMApplicationInfo, @ptrCast(self)), p_storage_i_d_);
            }
            pub inline fn getStartAppBlob(self: *const T, p_blob_: ?*PM_STARTAPPBLOB) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_StartAppBlob(@as(*const IPMApplicationInfo, @ptrCast(self)), p_blob_);
            }
            pub inline fn getIsMovable(self: *const T, p_is_movable_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsMovable(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_movable_);
            }
            pub inline fn getDeploymentAppEnumerationHubFilter(self: *const T, hub_type_: ?*PM_TILE_HUBTYPE) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_DeploymentAppEnumerationHubFilter(@as(*const IPMApplicationInfo, @ptrCast(self)), hub_type_);
            }
            pub inline fn getModifiedDate(self: *const T, p_modified_date_: ?*FILETIME) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_ModifiedDate(@as(*const IPMApplicationInfo, @ptrCast(self)), p_modified_date_);
            }
            pub inline fn getIsOriginallyRestored(self: *const T, p_is_restored_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsOriginallyRestored(@as(*const IPMApplicationInfo, @ptrCast(self)), p_is_restored_);
            }
            pub inline fn getShouldDeferMdilBind(self: *const T, pf_defer_mdil_bind_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_ShouldDeferMdilBind(@as(*const IPMApplicationInfo, @ptrCast(self)), pf_defer_mdil_bind_);
            }
            pub inline fn getIsFullyPreInstall(self: *const T, pf_is_fully_pre_install_: ?*BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).get_IsFullyPreInstall(@as(*const IPMApplicationInfo, @ptrCast(self)), pf_is_fully_pre_install_);
            }
            pub inline fn setIsMdilMaintenanceNeeded(self: *const T, f_is_mdil_maintenance_needed_: BOOL) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_IsMdilMaintenanceNeeded(@as(*const IPMApplicationInfo, @ptrCast(self)), f_is_mdil_maintenance_needed_);
            }
            pub inline fn setTitle(self: *const T, app_title_: ?BSTR) HRESULT {
                return @as(*const IPMApplicationInfo.VTable, @ptrCast(self.vtable)).set_Title(@as(*const IPMApplicationInfo, @ptrCast(self)), app_title_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTilePropertyInfo_Value = Guid.initString("6c2b8017-1efa-42a7-86c0-6d4b640bf528");
pub const IID_IPMTilePropertyInfo = &IID_IPMTilePropertyInfo_Value;
pub const IPMTilePropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTilePropertyInfo,
            p_prop_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTilePropertyInfo,
            p_prop_value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Property: *const fn (
            self: *const IPMTilePropertyInfo,
            prop_value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPropertyID(self: *const T, p_prop_i_d_: ?*u32) HRESULT {
                return @as(*const IPMTilePropertyInfo.VTable, @ptrCast(self.vtable)).get_PropertyID(@as(*const IPMTilePropertyInfo, @ptrCast(self)), p_prop_i_d_);
            }
            pub inline fn getPropertyValue(self: *const T, p_prop_value_: ?*?BSTR) HRESULT {
                return @as(*const IPMTilePropertyInfo.VTable, @ptrCast(self.vtable)).get_PropertyValue(@as(*const IPMTilePropertyInfo, @ptrCast(self)), p_prop_value_);
            }
            pub inline fn setProperty(self: *const T, prop_value_: ?BSTR) HRESULT {
                return @as(*const IPMTilePropertyInfo.VTable, @ptrCast(self.vtable)).set_Property(@as(*const IPMTilePropertyInfo, @ptrCast(self)), prop_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTilePropertyEnumerator_Value = Guid.initString("cc4cd629-9047-4250-aac8-930e47812421");
pub const IID_IPMTilePropertyEnumerator = &IID_IPMTilePropertyEnumerator_Value;
pub const IPMTilePropertyEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTilePropertyEnumerator,
            pp_prop_info: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_prop_info_: ?*?*IPMTilePropertyInfo) HRESULT {
                return @as(*const IPMTilePropertyEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMTilePropertyEnumerator, @ptrCast(self)), pp_prop_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTileInfo_Value = Guid.initString("d1604833-2b08-4001-82cd-183ad734f752");
pub const IID_IPMTileInfo = &IID_IPMTileInfo_Value;
pub const IPMTileInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_tile_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_template_type: ?*TILE_TEMPLATE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubPinnedState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            p_pinned: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            p_position: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNotified: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_is_notified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_is_default: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_task_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_start_tile_type: ?*PM_STARTTILE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_is_themable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyById: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            prop_i_d: u32,
            pp_prop_info: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            pp_tile_prop_enum: ?*?*IPMTilePropertyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubTileSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            p_size: ?*PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPosition: *const fn (
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotifiedState: *const fn (
            self: *const IPMTileInfo,
            notified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPinnedState: *const fn (
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            pinned: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubTileSize: *const fn (
            self: *const IPMTileInfo,
            hub_type: PM_TILE_HUBTYPE,
            size: PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_InvocationInfo: *const fn (
            self: *const IPMTileInfo,
            task_name: ?BSTR,
            task_parameters: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTileBlob: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_blob: ?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRestoring: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_is_restoring: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsAutoRestoreDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfo,
            p_is_auto_restore_disabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsRestoring: *const fn (
            self: *const IPMTileInfo,
            restoring: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsAutoRestoreDisabled: *const fn (
            self: *const IPMTileInfo,
            auto_restore_disabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMTileInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getTileID(self: *const T, p_tile_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_TileID(@as(*const IPMTileInfo, @ptrCast(self)), p_tile_i_d_);
            }
            pub inline fn getTemplateType(self: *const T, p_template_type_: ?*TILE_TEMPLATE_TYPE) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_TemplateType(@as(*const IPMTileInfo, @ptrCast(self)), p_template_type_);
            }
            pub inline fn getHubPinnedState(self: *const T, hub_type_: PM_TILE_HUBTYPE, p_pinned_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_HubPinnedState(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, p_pinned_);
            }
            pub inline fn getHubPosition(self: *const T, hub_type_: PM_TILE_HUBTYPE, p_position_: ?*u32) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_HubPosition(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, p_position_);
            }
            pub inline fn getIsNotified(self: *const T, p_is_notified_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_IsNotified(@as(*const IPMTileInfo, @ptrCast(self)), p_is_notified_);
            }
            pub inline fn getIsDefault(self: *const T, p_is_default_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_IsDefault(@as(*const IPMTileInfo, @ptrCast(self)), p_is_default_);
            }
            pub inline fn getTaskID(self: *const T, p_task_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_TaskID(@as(*const IPMTileInfo, @ptrCast(self)), p_task_i_d_);
            }
            pub inline fn getTileType(self: *const T, p_start_tile_type_: ?*PM_STARTTILE_TYPE) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_TileType(@as(*const IPMTileInfo, @ptrCast(self)), p_start_tile_type_);
            }
            pub inline fn getIsThemable(self: *const T, p_is_themable_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_IsThemable(@as(*const IPMTileInfo, @ptrCast(self)), p_is_themable_);
            }
            pub inline fn getPropertyById(self: *const T, prop_i_d_: u32, pp_prop_info_: ?*?*IPMTilePropertyInfo) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_PropertyById(@as(*const IPMTileInfo, @ptrCast(self)), prop_i_d_, pp_prop_info_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMTileInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
            pub inline fn getPropertyEnum(self: *const T, pp_tile_prop_enum_: ?*?*IPMTilePropertyEnumerator) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_PropertyEnum(@as(*const IPMTileInfo, @ptrCast(self)), pp_tile_prop_enum_);
            }
            pub inline fn getHubTileSize(self: *const T, hub_type_: PM_TILE_HUBTYPE, p_size_: ?*PM_TILE_SIZE) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_HubTileSize(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, p_size_);
            }
            pub inline fn setHubPosition(self: *const T, hub_type_: PM_TILE_HUBTYPE, position_: u32) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_HubPosition(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, position_);
            }
            pub inline fn setNotifiedState(self: *const T, notified_: BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_NotifiedState(@as(*const IPMTileInfo, @ptrCast(self)), notified_);
            }
            pub inline fn setHubPinnedState(self: *const T, hub_type_: PM_TILE_HUBTYPE, pinned_: BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_HubPinnedState(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, pinned_);
            }
            pub inline fn setHubTileSize(self: *const T, hub_type_: PM_TILE_HUBTYPE, size_: PM_TILE_SIZE) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_HubTileSize(@as(*const IPMTileInfo, @ptrCast(self)), hub_type_, size_);
            }
            pub inline fn setInvocationInfo(self: *const T, task_name_: ?BSTR, task_parameters_: ?BSTR) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_InvocationInfo(@as(*const IPMTileInfo, @ptrCast(self)), task_name_, task_parameters_);
            }
            pub inline fn getStartTileBlob(self: *const T, p_blob_: ?*PM_STARTTILEBLOB) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_StartTileBlob(@as(*const IPMTileInfo, @ptrCast(self)), p_blob_);
            }
            pub inline fn getIsRestoring(self: *const T, p_is_restoring_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_IsRestoring(@as(*const IPMTileInfo, @ptrCast(self)), p_is_restoring_);
            }
            pub inline fn getIsAutoRestoreDisabled(self: *const T, p_is_auto_restore_disabled_: ?*BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).get_IsAutoRestoreDisabled(@as(*const IPMTileInfo, @ptrCast(self)), p_is_auto_restore_disabled_);
            }
            pub inline fn setIsRestoring(self: *const T, restoring_: BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_IsRestoring(@as(*const IPMTileInfo, @ptrCast(self)), restoring_);
            }
            pub inline fn setIsAutoRestoreDisabled(self: *const T, auto_restore_disabled_: BOOL) HRESULT {
                return @as(*const IPMTileInfo.VTable, @ptrCast(self.vtable)).set_IsAutoRestoreDisabled(@as(*const IPMTileInfo, @ptrCast(self)), auto_restore_disabled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTileInfoEnumerator_Value = Guid.initString("ded83065-e462-4b2c-acb5-e39cea61c874");
pub const IID_IPMTileInfoEnumerator = &IID_IPMTileInfoEnumerator_Value;
pub const IPMTileInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTileInfoEnumerator,
            pp_tile_info: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_tile_info_: ?*?*IPMTileInfo) HRESULT {
                return @as(*const IPMTileInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMTileInfoEnumerator, @ptrCast(self)), pp_tile_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMApplicationInfoEnumerator_Value = Guid.initString("0ec42a96-4d46-4dc6-a3d9-a7acaac0f5fa");
pub const IID_IPMApplicationInfoEnumerator = &IID_IPMApplicationInfoEnumerator_Value;
pub const IPMApplicationInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMApplicationInfoEnumerator,
            pp_app_info: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_app_info_: ?*?*IPMApplicationInfo) HRESULT {
                return @as(*const IPMApplicationInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMApplicationInfoEnumerator, @ptrCast(self)), pp_app_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMLiveTileJobInfo_Value = Guid.initString("6009a81f-4710-4697-b5f6-2208f6057b8e");
pub const IID_IPMLiveTileJobInfo = &IID_IPMLiveTileJobInfo_Value;
pub const IPMLiveTileJobInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_tile_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextSchedule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_next_schedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NextSchedule: *const fn (
            self: *const IPMLiveTileJobInfo,
            ft_next_schedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartSchedule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_start_schedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_StartSchedule: *const fn (
            self: *const IPMLiveTileJobInfo,
            ft_start_schedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntervalDuration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_interval_duration: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IntervalDuration: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_interval_duration: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunForever: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            is_run_forever: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunForever: *const fn (
            self: *const IPMLiveTileJobInfo,
            f_run_forever: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxRunCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_max_run_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_MaxRunCount: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_max_run_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_run_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunCount: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_run_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecurrenceType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_recurrence_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RecurrenceType: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_recurrence_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileXML: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_tile_xml: [*]?*u8,
            pcb_tile_xml: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_TileXML: *const fn (
            self: *const IPMLiveTileJobInfo,
            p_tile_xml: [*:0]u8,
            cb_tile_xml: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UrlXML: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_url_x_m_l: [*]?*u8,
            pcb_url_x_m_l: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UrlXML: *const fn (
            self: *const IPMLiveTileJobInfo,
            p_url_x_m_l: [*:0]u8,
            cb_url_x_m_l: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttemptCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_attempt_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_AttemptCount: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_attempt_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfo,
            p_download_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_DownloadState: *const fn (
            self: *const IPMLiveTileJobInfo,
            ul_download_state: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getTileID(self: *const T, p_tile_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_TileID(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_tile_i_d_);
            }
            pub inline fn getNextSchedule(self: *const T, p_next_schedule_: ?*FILETIME) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_NextSchedule(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_next_schedule_);
            }
            pub inline fn setNextSchedule(self: *const T, ft_next_schedule_: FILETIME) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_NextSchedule(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ft_next_schedule_);
            }
            pub inline fn getStartSchedule(self: *const T, p_start_schedule_: ?*FILETIME) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_StartSchedule(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_start_schedule_);
            }
            pub inline fn setStartSchedule(self: *const T, ft_start_schedule_: FILETIME) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_StartSchedule(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ft_start_schedule_);
            }
            pub inline fn getIntervalDuration(self: *const T, p_interval_duration_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_IntervalDuration(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_interval_duration_);
            }
            pub inline fn setIntervalDuration(self: *const T, ul_interval_duration_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_IntervalDuration(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_interval_duration_);
            }
            pub inline fn getRunForever(self: *const T, is_run_forever_: ?*BOOL) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_RunForever(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), is_run_forever_);
            }
            pub inline fn setRunForever(self: *const T, f_run_forever_: BOOL) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_RunForever(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), f_run_forever_);
            }
            pub inline fn getMaxRunCount(self: *const T, p_max_run_count_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_MaxRunCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_max_run_count_);
            }
            pub inline fn setMaxRunCount(self: *const T, ul_max_run_count_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_MaxRunCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_max_run_count_);
            }
            pub inline fn getRunCount(self: *const T, p_run_count_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_RunCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_run_count_);
            }
            pub inline fn setRunCount(self: *const T, ul_run_count_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_RunCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_run_count_);
            }
            pub inline fn getRecurrenceType(self: *const T, p_recurrence_type_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_RecurrenceType(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_recurrence_type_);
            }
            pub inline fn setRecurrenceType(self: *const T, ul_recurrence_type_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_RecurrenceType(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_recurrence_type_);
            }
            pub inline fn getTileXML(self: *const T, p_tile_xml_: [*]?*u8, pcb_tile_xml_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_TileXML(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_tile_xml_, pcb_tile_xml_);
            }
            pub inline fn setTileXML(self: *const T, p_tile_xml_: [*:0]u8, cb_tile_xml_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_TileXML(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_tile_xml_, cb_tile_xml_);
            }
            pub inline fn getUrlXML(self: *const T, p_url_x_m_l_: [*]?*u8, pcb_url_x_m_l_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_UrlXML(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_url_x_m_l_, pcb_url_x_m_l_);
            }
            pub inline fn setUrlXML(self: *const T, p_url_x_m_l_: [*:0]u8, cb_url_x_m_l_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_UrlXML(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_url_x_m_l_, cb_url_x_m_l_);
            }
            pub inline fn getAttemptCount(self: *const T, p_attempt_count_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_AttemptCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_attempt_count_);
            }
            pub inline fn setAttemptCount(self: *const T, ul_attempt_count_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_AttemptCount(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_attempt_count_);
            }
            pub inline fn getDownloadState(self: *const T, p_download_state_: ?*u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).get_DownloadState(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), p_download_state_);
            }
            pub inline fn setDownloadState(self: *const T, ul_download_state_: u32) HRESULT {
                return @as(*const IPMLiveTileJobInfo.VTable, @ptrCast(self.vtable)).set_DownloadState(@as(*const IPMLiveTileJobInfo, @ptrCast(self)), ul_download_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMLiveTileJobInfoEnumerator_Value = Guid.initString("bc042582-9415-4f36-9f99-06f104c07c03");
pub const IID_IPMLiveTileJobInfoEnumerator = &IID_IPMLiveTileJobInfoEnumerator_Value;
pub const IPMLiveTileJobInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMLiveTileJobInfoEnumerator,
            pp_live_tile_job_info: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_live_tile_job_info_: ?*?*IPMLiveTileJobInfo) HRESULT {
                return @as(*const IPMLiveTileJobInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMLiveTileJobInfoEnumerator, @ptrCast(self)), pp_live_tile_job_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMDeploymentManager_Value = Guid.initString("35f785fa-1979-4a8b-bc8f-fd70eb0d1544");
pub const IID_IPMDeploymentManager = &IID_IPMDeploymentManager_Value;
pub const IPMDeploymentManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportDownloadBegin: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadProgress: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            us_progress: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadComplete: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            hr_result: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginInstall: *const fn (
            self: *const IPMDeploymentManager,
            p_install_info: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdate: *const fn (
            self: *const IPMDeploymentManager,
            p_update_info: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeployPackage: *const fn (
            self: *const IPMDeploymentManager,
            p_install_info: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackageLegacy: *const fn (
            self: *const IPMDeploymentManager,
            p_update_info: ?*PM_UPDATEINFO_LEGACY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstall: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppInstall: *const fn (
            self: *const IPMDeploymentManager,
            p_install_info: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppUpdate: *const fn (
            self: *const IPMDeploymentManager,
            p_update_info: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateLicense: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            offer_i_d: Guid,
            pb_license: [*:0]u8,
            cb_license: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallenge: *const fn (
            self: *const IPMDeploymentManager,
            package_path: ?BSTR,
            ppb_challenge: [*]?*u8,
            pcb_challenge: ?*u32,
            ppb_k_i_d: ?[*]?*u8,
            pcb_k_i_d: ?*u32,
            ppb_device_i_d: ?[*]?*u8,
            pcb_device_i_d: ?*u32,
            ppb_salt_value: ?[*]?*u8,
            pcb_salt_value: ?*u32,
            ppb_k_g_v_value: ?[*]?*u8,
            pcb_k_g_v_value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            ppb_challenge: [*]?*u8,
            pcb_license: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID2: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            ppb_challenge: [*]?*u8,
            pcb_license: ?*u32,
            ppb_k_i_d: ?[*]?*u8,
            pcb_k_i_d: ?*u32,
            ppb_device_i_d: ?[*]?*u8,
            pcb_device_i_d: ?*u32,
            ppb_salt_value: ?[*]?*u8,
            pcb_salt_value: ?*u32,
            ppb_k_g_v_value: ?[*]?*u8,
            pcb_k_g_v_value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeLicense: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindMdilBinaries: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            file_names: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindAllMdilBinaries: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            instance_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegenerateXbf: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            assembly_paths: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXbfForCurrentLocale: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginProvision: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            x_m_lpath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeprovision: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSQLCEDatabases: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationsNeedMaintenance: *const fn (
            self: *const IPMDeploymentManager,
            required_maintenance_operations: u32,
            pc_applications: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateChamberProfile: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnterprisePolicyIsApplicationAllowed: *const fn (
            self: *const IPMDeploymentManager,
            product_id: Guid,
            publisher_name: ?[*:0]const u16,
            p_is_allowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackage: *const fn (
            self: *const IPMDeploymentManager,
            p_update_info: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportRestoreCancelled: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveResourceString: *const fn (
            self: *const IPMDeploymentManager,
            resource_string: ?[*:0]const u16,
            p_resolved_resource_string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateCapabilitiesForModernApps: *const fn (
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadStatusUpdate: *const fn (
            self: *const IPMDeploymentManager,
            product_id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstallWithOptions: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            removal_options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindDeferredMdilBinaries: *const fn (
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXamlLightupXbfForCurrentLocale: *const fn (
            self: *const IPMDeploymentManager,
            package_family_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddLicenseForAppx: *const fn (
            self: *const IPMDeploymentManager,
            product_i_d: Guid,
            pb_license: [*:0]u8,
            cb_license: u32,
            pb_play_ready_header: ?[*:0]u8,
            cb_play_ready_header: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FixJunctionsForAppsOnSDCard: *const fn (
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reportDownloadBegin(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReportDownloadBegin(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn reportDownloadProgress(self: *const T, product_i_d_: Guid, us_progress_: u16) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReportDownloadProgress(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, us_progress_);
            }
            pub inline fn reportDownloadComplete(self: *const T, product_i_d_: Guid, hr_result_: HRESULT) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReportDownloadComplete(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, hr_result_);
            }
            pub inline fn beginInstall(self: *const T, p_install_info_: ?*PM_INSTALLINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginInstall(@as(*const IPMDeploymentManager, @ptrCast(self)), p_install_info_);
            }
            pub inline fn beginUpdate(self: *const T, p_update_info_: ?*PM_UPDATEINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUpdate(@as(*const IPMDeploymentManager, @ptrCast(self)), p_update_info_);
            }
            pub inline fn beginDeployPackage(self: *const T, p_install_info_: ?*PM_INSTALLINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginDeployPackage(@as(*const IPMDeploymentManager, @ptrCast(self)), p_install_info_);
            }
            pub inline fn beginUpdateDeployedPackageLegacy(self: *const T, p_update_info_: ?*PM_UPDATEINFO_LEGACY) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUpdateDeployedPackageLegacy(@as(*const IPMDeploymentManager, @ptrCast(self)), p_update_info_);
            }
            pub inline fn beginUninstall(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUninstall(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn beginEnterpriseAppInstall(self: *const T, p_install_info_: ?*PM_INSTALLINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginEnterpriseAppInstall(@as(*const IPMDeploymentManager, @ptrCast(self)), p_install_info_);
            }
            pub inline fn beginEnterpriseAppUpdate(self: *const T, p_update_info_: ?*PM_UPDATEINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginEnterpriseAppUpdate(@as(*const IPMDeploymentManager, @ptrCast(self)), p_update_info_);
            }
            pub inline fn beginUpdateLicense(self: *const T, product_i_d_: Guid, offer_i_d_: Guid, pb_license_: [*:0]u8, cb_license_: u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUpdateLicense(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, offer_i_d_, pb_license_, cb_license_);
            }
            pub inline fn getLicenseChallenge(self: *const T, package_path_: ?BSTR, ppb_challenge_: [*]?*u8, pcb_challenge_: ?*u32, ppb_k_i_d_: ?[*]?*u8, pcb_k_i_d_: ?*u32, ppb_device_i_d_: ?[*]?*u8, pcb_device_i_d_: ?*u32, ppb_salt_value_: ?[*]?*u8, pcb_salt_value_: ?*u32, ppb_k_g_v_value_: ?[*]?*u8, pcb_k_g_v_value_: ?*u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).GetLicenseChallenge(@as(*const IPMDeploymentManager, @ptrCast(self)), package_path_, ppb_challenge_, pcb_challenge_, ppb_k_i_d_, pcb_k_i_d_, ppb_device_i_d_, pcb_device_i_d_, ppb_salt_value_, pcb_salt_value_, ppb_k_g_v_value_, pcb_k_g_v_value_);
            }
            pub inline fn getLicenseChallengeByProductID(self: *const T, product_i_d_: Guid, ppb_challenge_: [*]?*u8, pcb_license_: ?*u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).GetLicenseChallengeByProductID(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, ppb_challenge_, pcb_license_);
            }
            pub inline fn getLicenseChallengeByProductID2(self: *const T, product_i_d_: Guid, ppb_challenge_: [*]?*u8, pcb_license_: ?*u32, ppb_k_i_d_: ?[*]?*u8, pcb_k_i_d_: ?*u32, ppb_device_i_d_: ?[*]?*u8, pcb_device_i_d_: ?*u32, ppb_salt_value_: ?[*]?*u8, pcb_salt_value_: ?*u32, ppb_k_g_v_value_: ?[*]?*u8, pcb_k_g_v_value_: ?*u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).GetLicenseChallengeByProductID2(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, ppb_challenge_, pcb_license_, ppb_k_i_d_, pcb_k_i_d_, ppb_device_i_d_, pcb_device_i_d_, ppb_salt_value_, pcb_salt_value_, ppb_k_g_v_value_, pcb_k_g_v_value_);
            }
            pub inline fn revokeLicense(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).RevokeLicense(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn rebindMdilBinaries(self: *const T, product_i_d_: Guid, file_names_: ?*SAFEARRAY) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).RebindMdilBinaries(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, file_names_);
            }
            pub inline fn rebindAllMdilBinaries(self: *const T, product_i_d_: Guid, instance_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).RebindAllMdilBinaries(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, instance_i_d_);
            }
            pub inline fn regenerateXbf(self: *const T, product_i_d_: Guid, assembly_paths_: ?*SAFEARRAY) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).RegenerateXbf(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, assembly_paths_);
            }
            pub inline fn generateXbfForCurrentLocale(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).GenerateXbfForCurrentLocale(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn beginProvision(self: *const T, product_i_d_: Guid, x_m_lpath_: ?BSTR) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginProvision(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, x_m_lpath_);
            }
            pub inline fn beginDeprovision(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginDeprovision(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn reindexSQLCEDatabases(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReindexSQLCEDatabases(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn setApplicationsNeedMaintenance(self: *const T, required_maintenance_operations_: u32, pc_applications_: ?*u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).SetApplicationsNeedMaintenance(@as(*const IPMDeploymentManager, @ptrCast(self)), required_maintenance_operations_, pc_applications_);
            }
            pub inline fn updateChamberProfile(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).UpdateChamberProfile(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn enterprisePolicyIsApplicationAllowed(self: *const T, product_id_: Guid, publisher_name_: ?[*:0]const u16, p_is_allowed_: ?*BOOL) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).EnterprisePolicyIsApplicationAllowed(@as(*const IPMDeploymentManager, @ptrCast(self)), product_id_, publisher_name_, p_is_allowed_);
            }
            pub inline fn beginUpdateDeployedPackage(self: *const T, p_update_info_: ?*PM_UPDATEINFO) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUpdateDeployedPackage(@as(*const IPMDeploymentManager, @ptrCast(self)), p_update_info_);
            }
            pub inline fn reportRestoreCancelled(self: *const T, product_i_d_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReportRestoreCancelled(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_);
            }
            pub inline fn resolveResourceString(self: *const T, resource_string_: ?[*:0]const u16, p_resolved_resource_string_: ?*?BSTR) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ResolveResourceString(@as(*const IPMDeploymentManager, @ptrCast(self)), resource_string_, p_resolved_resource_string_);
            }
            pub inline fn updateCapabilitiesForModernApps(self: *const T) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).UpdateCapabilitiesForModernApps(@as(*const IPMDeploymentManager, @ptrCast(self)));
            }
            pub inline fn reportDownloadStatusUpdate(self: *const T, product_id_: Guid) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).ReportDownloadStatusUpdate(@as(*const IPMDeploymentManager, @ptrCast(self)), product_id_);
            }
            pub inline fn beginUninstallWithOptions(self: *const T, product_i_d_: Guid, removal_options_: u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BeginUninstallWithOptions(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, removal_options_);
            }
            pub inline fn bindDeferredMdilBinaries(self: *const T) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).BindDeferredMdilBinaries(@as(*const IPMDeploymentManager, @ptrCast(self)));
            }
            pub inline fn generateXamlLightupXbfForCurrentLocale(self: *const T, package_family_name_: ?BSTR) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).GenerateXamlLightupXbfForCurrentLocale(@as(*const IPMDeploymentManager, @ptrCast(self)), package_family_name_);
            }
            pub inline fn addLicenseForAppx(self: *const T, product_i_d_: Guid, pb_license_: [*:0]u8, cb_license_: u32, pb_play_ready_header_: ?[*:0]u8, cb_play_ready_header_: u32) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).AddLicenseForAppx(@as(*const IPMDeploymentManager, @ptrCast(self)), product_i_d_, pb_license_, cb_license_, pb_play_ready_header_, cb_play_ready_header_);
            }
            pub inline fn fixJunctionsForAppsOnSDCard(self: *const T) HRESULT {
                return @as(*const IPMDeploymentManager.VTable, @ptrCast(self.vtable)).FixJunctionsForAppsOnSDCard(@as(*const IPMDeploymentManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMEnumerationManager_Value = Guid.initString("698d57c2-292d-4cf3-b73c-d95a6922ed9a");
pub const IID_IPMEnumerationManager = &IID_IPMEnumerationManager_Value;
pub const IPMEnumerationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllApplications: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_app_enum: ?*?*IPMApplicationInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllTiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_tile_enum: ?*?*IPMTileInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllTasks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_task_enum: ?*?*IPMTaskInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllExtensions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_extension_enum: ?*?*IPMExtensionInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllBackgroundServiceAgents: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_b_s_a_enum: ?*?*IPMBackgroundServiceAgentInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllBackgroundWorkers: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_b_s_w_enum: ?*?*IPMBackgroundWorkerInfoEnumerator,
            filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            pp_app_info: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            tile_i_d: ?BSTR,
            pp_tile_info: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            task_i_d: ?BSTR,
            pp_task_info: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskInfoEx: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            task_i_d: ?[*:0]const u16,
            pp_task_info: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundServiceAgentInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            b_s_a_i_d: u32,
            pp_task_info: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllLiveTileJobs: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            pp_live_tile_job_enum: ?*?*IPMLiveTileJobInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LiveTileJob: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            tile_i_d: ?BSTR,
            recurrence_type: PM_LIVETILE_RECURRENCE_TYPE,
            pp_live_tile_job_info: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfoExternal: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            product_i_d: Guid,
            pp_app_info: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileHandlerGenericLogo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            file_type: ?BSTR,
            logo_size: PM_LOGO_SIZE,
            p_logo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfoFromAccessClaims: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            sys_app_i_d0: ?BSTR,
            sys_app_i_d1: ?BSTR,
            pp_app_info: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTileEnumeratorBlob: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            filter: PM_ENUM_FILTER,
            pc_tiles: ?*u32,
            pp_tile_blobs: [*]?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAppEnumeratorBlob: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMEnumerationManager,
            filter: PM_ENUM_FILTER,
            pc_apps: ?*u32,
            pp_app_blobs: [*]?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAllApplications(self: *const T, pp_app_enum_: ?*?*IPMApplicationInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllApplications(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_app_enum_, filter_);
            }
            pub inline fn getAllTiles(self: *const T, pp_tile_enum_: ?*?*IPMTileInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllTiles(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_tile_enum_, filter_);
            }
            pub inline fn getAllTasks(self: *const T, pp_task_enum_: ?*?*IPMTaskInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllTasks(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_task_enum_, filter_);
            }
            pub inline fn getAllExtensions(self: *const T, pp_extension_enum_: ?*?*IPMExtensionInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllExtensions(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_extension_enum_, filter_);
            }
            pub inline fn getAllBackgroundServiceAgents(self: *const T, pp_b_s_a_enum_: ?*?*IPMBackgroundServiceAgentInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllBackgroundServiceAgents(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_b_s_a_enum_, filter_);
            }
            pub inline fn getAllBackgroundWorkers(self: *const T, pp_b_s_w_enum_: ?*?*IPMBackgroundWorkerInfoEnumerator, filter_: PM_ENUM_FILTER) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllBackgroundWorkers(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_b_s_w_enum_, filter_);
            }
            pub inline fn getApplicationInfo(self: *const T, product_i_d_: Guid, pp_app_info_: ?*?*IPMApplicationInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_ApplicationInfo(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, pp_app_info_);
            }
            pub inline fn getTileInfo(self: *const T, product_i_d_: Guid, tile_i_d_: ?BSTR, pp_tile_info_: ?*?*IPMTileInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_TileInfo(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, tile_i_d_, pp_tile_info_);
            }
            pub inline fn getTaskInfo(self: *const T, product_i_d_: Guid, task_i_d_: ?BSTR, pp_task_info_: ?*?*IPMTaskInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_TaskInfo(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, task_i_d_, pp_task_info_);
            }
            pub inline fn getTaskInfoEx(self: *const T, product_i_d_: Guid, task_i_d_: ?[*:0]const u16, pp_task_info_: ?*?*IPMTaskInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_TaskInfoEx(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, task_i_d_, pp_task_info_);
            }
            pub inline fn getBackgroundServiceAgentInfo(self: *const T, b_s_a_i_d_: u32, pp_task_info_: ?*?*IPMBackgroundServiceAgentInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_BackgroundServiceAgentInfo(@as(*const IPMEnumerationManager, @ptrCast(self)), b_s_a_i_d_, pp_task_info_);
            }
            pub inline fn getAllLiveTileJobs(self: *const T, pp_live_tile_job_enum_: ?*?*IPMLiveTileJobInfoEnumerator) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_AllLiveTileJobs(@as(*const IPMEnumerationManager, @ptrCast(self)), pp_live_tile_job_enum_);
            }
            pub inline fn getLiveTileJob(self: *const T, product_i_d_: Guid, tile_i_d_: ?BSTR, recurrence_type_: PM_LIVETILE_RECURRENCE_TYPE, pp_live_tile_job_info_: ?*?*IPMLiveTileJobInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_LiveTileJob(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, tile_i_d_, recurrence_type_, pp_live_tile_job_info_);
            }
            pub inline fn getApplicationInfoExternal(self: *const T, product_i_d_: Guid, pp_app_info_: ?*?*IPMApplicationInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_ApplicationInfoExternal(@as(*const IPMEnumerationManager, @ptrCast(self)), product_i_d_, pp_app_info_);
            }
            pub inline fn getFileHandlerGenericLogo(self: *const T, file_type_: ?BSTR, logo_size_: PM_LOGO_SIZE, p_logo_: ?*?BSTR) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_FileHandlerGenericLogo(@as(*const IPMEnumerationManager, @ptrCast(self)), file_type_, logo_size_, p_logo_);
            }
            pub inline fn getApplicationInfoFromAccessClaims(self: *const T, sys_app_i_d0_: ?BSTR, sys_app_i_d1_: ?BSTR, pp_app_info_: ?*?*IPMApplicationInfo) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_ApplicationInfoFromAccessClaims(@as(*const IPMEnumerationManager, @ptrCast(self)), sys_app_i_d0_, sys_app_i_d1_, pp_app_info_);
            }
            pub inline fn getStartTileEnumeratorBlob(self: *const T, filter_: PM_ENUM_FILTER, pc_tiles_: ?*u32, pp_tile_blobs_: [*]?*PM_STARTTILEBLOB) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_StartTileEnumeratorBlob(@as(*const IPMEnumerationManager, @ptrCast(self)), filter_, pc_tiles_, pp_tile_blobs_);
            }
            pub inline fn getStartAppEnumeratorBlob(self: *const T, filter_: PM_ENUM_FILTER, pc_apps_: ?*u32, pp_app_blobs_: [*]?*PM_STARTAPPBLOB) HRESULT {
                return @as(*const IPMEnumerationManager.VTable, @ptrCast(self.vtable)).get_StartAppEnumeratorBlob(@as(*const IPMEnumerationManager, @ptrCast(self)), filter_, pc_apps_, pp_app_blobs_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTaskInfo_Value = Guid.initString("bf1d8c33-1bf5-4ee0-b549-6b9dd3834942");
pub const IID_IPMTaskInfo = &IID_IPMTaskInfo_Value;
pub const IPMTaskInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_task_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NavigationPage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_navigation_page: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskTransition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_task_transition: ?*PM_TASK_TRANSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuntimeType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_runtimetype: ?*PACKMAN_RUNTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActivationPolicy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_activation_policy: ?*PM_ACTIVATION_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_task_type: ?*PM_TASK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImagePath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_image_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageParams: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_image_params: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallRootFolder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_install_root_folder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRootFolder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_data_root_folder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSingleInstanceHost: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_is_single_instance_host: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInteropEnabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_is_interop_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_application_state: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_install_type: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_target_major_version: ?*u8,
            p_target_minor_version: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerPixel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_bits_per_pixel: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressesDehydration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_suppresses_dehydration: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundExecutionAbilities: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_background_execution_abilities: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptedForExtendedMem: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfo,
            p_is_opted_in: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMTaskInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getTaskID(self: *const T, p_task_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_TaskID(@as(*const IPMTaskInfo, @ptrCast(self)), p_task_i_d_);
            }
            pub inline fn getNavigationPage(self: *const T, p_navigation_page_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_NavigationPage(@as(*const IPMTaskInfo, @ptrCast(self)), p_navigation_page_);
            }
            pub inline fn getTaskTransition(self: *const T, p_task_transition_: ?*PM_TASK_TRANSITION) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_TaskTransition(@as(*const IPMTaskInfo, @ptrCast(self)), p_task_transition_);
            }
            pub inline fn getRuntimeType(self: *const T, p_runtimetype_: ?*PACKMAN_RUNTIME) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_RuntimeType(@as(*const IPMTaskInfo, @ptrCast(self)), p_runtimetype_);
            }
            pub inline fn getActivationPolicy(self: *const T, p_activation_policy_: ?*PM_ACTIVATION_POLICY) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_ActivationPolicy(@as(*const IPMTaskInfo, @ptrCast(self)), p_activation_policy_);
            }
            pub inline fn getTaskType(self: *const T, p_task_type_: ?*PM_TASK_TYPE) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_TaskType(@as(*const IPMTaskInfo, @ptrCast(self)), p_task_type_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMTaskInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
            pub inline fn getImagePath(self: *const T, p_image_path_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_ImagePath(@as(*const IPMTaskInfo, @ptrCast(self)), p_image_path_);
            }
            pub inline fn getImageParams(self: *const T, p_image_params_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_ImageParams(@as(*const IPMTaskInfo, @ptrCast(self)), p_image_params_);
            }
            pub inline fn getInstallRootFolder(self: *const T, p_install_root_folder_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_InstallRootFolder(@as(*const IPMTaskInfo, @ptrCast(self)), p_install_root_folder_);
            }
            pub inline fn getDataRootFolder(self: *const T, p_data_root_folder_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_DataRootFolder(@as(*const IPMTaskInfo, @ptrCast(self)), p_data_root_folder_);
            }
            pub inline fn getIsSingleInstanceHost(self: *const T, p_is_single_instance_host_: ?*BOOL) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_IsSingleInstanceHost(@as(*const IPMTaskInfo, @ptrCast(self)), p_is_single_instance_host_);
            }
            pub inline fn getIsInteropEnabled(self: *const T, p_is_interop_enabled_: ?*BOOL) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_IsInteropEnabled(@as(*const IPMTaskInfo, @ptrCast(self)), p_is_interop_enabled_);
            }
            pub inline fn getApplicationState(self: *const T, p_application_state_: ?*PM_APPLICATION_STATE) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_ApplicationState(@as(*const IPMTaskInfo, @ptrCast(self)), p_application_state_);
            }
            pub inline fn getInstallType(self: *const T, p_install_type_: ?*PM_APPLICATION_INSTALL_TYPE) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_InstallType(@as(*const IPMTaskInfo, @ptrCast(self)), p_install_type_);
            }
            pub inline fn getVersion(self: *const T, p_target_major_version_: ?*u8, p_target_minor_version_: ?*u8) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_Version(@as(*const IPMTaskInfo, @ptrCast(self)), p_target_major_version_, p_target_minor_version_);
            }
            pub inline fn getBitsPerPixel(self: *const T, p_bits_per_pixel_: ?*u16) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_BitsPerPixel(@as(*const IPMTaskInfo, @ptrCast(self)), p_bits_per_pixel_);
            }
            pub inline fn getSuppressesDehydration(self: *const T, p_suppresses_dehydration_: ?*BOOL) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_SuppressesDehydration(@as(*const IPMTaskInfo, @ptrCast(self)), p_suppresses_dehydration_);
            }
            pub inline fn getBackgroundExecutionAbilities(self: *const T, p_background_execution_abilities_: ?*?BSTR) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_BackgroundExecutionAbilities(@as(*const IPMTaskInfo, @ptrCast(self)), p_background_execution_abilities_);
            }
            pub inline fn getIsOptedForExtendedMem(self: *const T, p_is_opted_in_: ?*BOOL) HRESULT {
                return @as(*const IPMTaskInfo.VTable, @ptrCast(self.vtable)).get_IsOptedForExtendedMem(@as(*const IPMTaskInfo, @ptrCast(self)), p_is_opted_in_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTaskInfoEnumerator_Value = Guid.initString("0630b0f8-0bbc-4821-be74-c7995166ed2a");
pub const IID_IPMTaskInfoEnumerator = &IID_IPMTaskInfoEnumerator_Value;
pub const IPMTaskInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMTaskInfoEnumerator,
            pp_task_info: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_task_info_: ?*?*IPMTaskInfo) HRESULT {
                return @as(*const IPMTaskInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMTaskInfoEnumerator, @ptrCast(self)), pp_task_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionInfo_Value = Guid.initString("49acde79-9788-4d0a-8aa0-1746afdb9e9d");
pub const IID_IPMExtensionInfo = &IID_IPMExtensionInfo_Value;
pub const IPMExtensionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierPID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_supplier_p_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierTaskID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_supplier_t_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_title: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_icon_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtraFile: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_file_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupplierPID(self: *const T, p_supplier_p_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_SupplierPID(@as(*const IPMExtensionInfo, @ptrCast(self)), p_supplier_p_i_d_);
            }
            pub inline fn getSupplierTaskID(self: *const T, p_supplier_t_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_SupplierTaskID(@as(*const IPMExtensionInfo, @ptrCast(self)), p_supplier_t_i_d_);
            }
            pub inline fn getTitle(self: *const T, p_title_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IPMExtensionInfo, @ptrCast(self)), p_title_);
            }
            pub inline fn getIconPath(self: *const T, p_icon_path_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_IconPath(@as(*const IPMExtensionInfo, @ptrCast(self)), p_icon_path_);
            }
            pub inline fn getExtraFile(self: *const T, p_file_path_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_ExtraFile(@as(*const IPMExtensionInfo, @ptrCast(self)), p_file_path_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMExtensionInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileExtensionInfo_Value = Guid.initString("6b87cb6c-0b88-4989-a4ec-033714f710d4");
pub const IID_IPMExtensionFileExtensionInfo = &IID_IPMExtensionFileExtensionInfo_Value;
pub const IPMExtensionFileExtensionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            p_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            p_display_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Logo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            logo_size: PM_LOGO_SIZE,
            p_logo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            file_type: ?BSTR,
            p_content_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            content_type: ?BSTR,
            p_file_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileExtensionInfo,
            pcb_types: ?*u32,
            pp_types: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, p_name_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), p_name_);
            }
            pub inline fn getDisplayName(self: *const T, p_display_name_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_DisplayName(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), p_display_name_);
            }
            pub inline fn getLogo(self: *const T, logo_size_: PM_LOGO_SIZE, p_logo_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_Logo(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), logo_size_, p_logo_);
            }
            pub inline fn getContentType(self: *const T, file_type_: ?BSTR, p_content_type_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_ContentType(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), file_type_, p_content_type_);
            }
            pub inline fn getFileType(self: *const T, content_type_: ?BSTR, p_file_type_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_FileType(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), content_type_, p_file_type_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
            pub inline fn getAllFileTypes(self: *const T, pcb_types_: ?*u32, pp_types_: [*]?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileExtensionInfo.VTable, @ptrCast(self.vtable)).get_AllFileTypes(@as(*const IPMExtensionFileExtensionInfo, @ptrCast(self)), pcb_types_, pp_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionProtocolInfo_Value = Guid.initString("1e3fa036-51eb-4453-baff-b8d8e4b46c8e");
pub const IID_IPMExtensionProtocolInfo = &IID_IPMExtensionProtocolInfo_Value;
pub const IPMExtensionProtocolInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionProtocolInfo,
            p_protocol: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionProtocolInfo,
            p_image_urn: ?*?BSTR,
            p_parameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProtocol(self: *const T, p_protocol_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionProtocolInfo.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const IPMExtensionProtocolInfo, @ptrCast(self)), p_protocol_);
            }
            pub inline fn getInvocationInfo(self: *const T, p_image_urn_: ?*?BSTR, p_parameters_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionProtocolInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMExtensionProtocolInfo, @ptrCast(self)), p_image_urn_, p_parameters_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionShareTargetInfo_Value = Guid.initString("5471f48b-c65c-4656-8c70-242e31195fea");
pub const IID_IPMExtensionShareTargetInfo = &IID_IPMExtensionShareTargetInfo_Value;
pub const IPMExtensionShareTargetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionShareTargetInfo,
            pc_types: ?*u32,
            pp_types: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllDataFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionShareTargetInfo,
            pc_data_formats: ?*u32,
            pp_data_formats: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionShareTargetInfo,
            p_supports_all_types: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAllFileTypes(self: *const T, pc_types_: ?*u32, pp_types_: [*]?*?BSTR) HRESULT {
                return @as(*const IPMExtensionShareTargetInfo.VTable, @ptrCast(self.vtable)).get_AllFileTypes(@as(*const IPMExtensionShareTargetInfo, @ptrCast(self)), pc_types_, pp_types_);
            }
            pub inline fn getAllDataFormats(self: *const T, pc_data_formats_: ?*u32, pp_data_formats_: [*]?*?BSTR) HRESULT {
                return @as(*const IPMExtensionShareTargetInfo.VTable, @ptrCast(self.vtable)).get_AllDataFormats(@as(*const IPMExtensionShareTargetInfo, @ptrCast(self)), pc_data_formats_, pp_data_formats_);
            }
            pub inline fn getSupportsAllFileTypes(self: *const T, p_supports_all_types_: ?*BOOL) HRESULT {
                return @as(*const IPMExtensionShareTargetInfo.VTable, @ptrCast(self.vtable)).get_SupportsAllFileTypes(@as(*const IPMExtensionShareTargetInfo, @ptrCast(self)), p_supports_all_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionContractInfo_Value = Guid.initString("e5666373-7ba1-467c-b819-b175db1c295b");
pub const IID_IPMExtensionContractInfo = &IID_IPMExtensionContractInfo_Value;
pub const IPMExtensionContractInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionContractInfo,
            p_a_u_m_i_d: ?*?BSTR,
            p_args: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInvocationInfo(self: *const T, p_a_u_m_i_d_: ?*?BSTR, p_args_: ?*?BSTR) HRESULT {
                return @as(*const IPMExtensionContractInfo.VTable, @ptrCast(self.vtable)).get_InvocationInfo(@as(*const IPMExtensionContractInfo, @ptrCast(self)), p_a_u_m_i_d_, p_args_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileOpenPickerInfo_Value = Guid.initString("6dc91d25-9606-420c-9a78-e034a3418345");
pub const IID_IPMExtensionFileOpenPickerInfo = &IID_IPMExtensionFileOpenPickerInfo_Value;
pub const IPMExtensionFileOpenPickerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileOpenPickerInfo,
            pc_types: ?*u32,
            pp_types: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileOpenPickerInfo,
            p_supports_all_types: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAllFileTypes(self: *const T, pc_types_: ?*u32, pp_types_: [*]?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileOpenPickerInfo.VTable, @ptrCast(self.vtable)).get_AllFileTypes(@as(*const IPMExtensionFileOpenPickerInfo, @ptrCast(self)), pc_types_, pp_types_);
            }
            pub inline fn getSupportsAllFileTypes(self: *const T, p_supports_all_types_: ?*BOOL) HRESULT {
                return @as(*const IPMExtensionFileOpenPickerInfo.VTable, @ptrCast(self.vtable)).get_SupportsAllFileTypes(@as(*const IPMExtensionFileOpenPickerInfo, @ptrCast(self)), p_supports_all_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileSavePickerInfo_Value = Guid.initString("38005cba-f81a-493e-a0f8-922c8680da43");
pub const IID_IPMExtensionFileSavePickerInfo = &IID_IPMExtensionFileSavePickerInfo_Value;
pub const IPMExtensionFileSavePickerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileSavePickerInfo,
            pc_types: ?*u32,
            pp_types: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionFileSavePickerInfo,
            p_supports_all_types: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAllFileTypes(self: *const T, pc_types_: ?*u32, pp_types_: [*]?*?BSTR) HRESULT {
                return @as(*const IPMExtensionFileSavePickerInfo.VTable, @ptrCast(self.vtable)).get_AllFileTypes(@as(*const IPMExtensionFileSavePickerInfo, @ptrCast(self)), pc_types_, pp_types_);
            }
            pub inline fn getSupportsAllFileTypes(self: *const T, p_supports_all_types_: ?*BOOL) HRESULT {
                return @as(*const IPMExtensionFileSavePickerInfo.VTable, @ptrCast(self.vtable)).get_SupportsAllFileTypes(@as(*const IPMExtensionFileSavePickerInfo, @ptrCast(self)), p_supports_all_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionCachedFileUpdaterInfo_Value = Guid.initString("e2d77509-4e58-4ba9-af7e-b642e370e1b0");
pub const IID_IPMExtensionCachedFileUpdaterInfo = &IID_IPMExtensionCachedFileUpdaterInfo_Value;
pub const IPMExtensionCachedFileUpdaterInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsUpdates: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionCachedFileUpdaterInfo,
            p_supports_updates: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupportsUpdates(self: *const T, p_supports_updates_: ?*BOOL) HRESULT {
                return @as(*const IPMExtensionCachedFileUpdaterInfo.VTable, @ptrCast(self.vtable)).get_SupportsUpdates(@as(*const IPMExtensionCachedFileUpdaterInfo, @ptrCast(self)), p_supports_updates_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionInfoEnumerator_Value = Guid.initString("403b9e82-1171-4573-8e6f-6f33f39b83dd");
pub const IID_IPMExtensionInfoEnumerator = &IID_IPMExtensionInfoEnumerator_Value;
pub const IPMExtensionInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMExtensionInfoEnumerator,
            pp_extension_info: ?*?*IPMExtensionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_extension_info_: ?*?*IPMExtensionInfo) HRESULT {
                return @as(*const IPMExtensionInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMExtensionInfoEnumerator, @ptrCast(self)), pp_extension_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundServiceAgentInfo_Value = Guid.initString("3a8b46da-928c-4879-998c-09dc96f3d490");
pub const IID_IPMBackgroundServiceAgentInfo = &IID_IPMBackgroundServiceAgentInfo_Value;
pub const IPMBackgroundServiceAgentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_task_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BSAID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_b_s_a_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSpecifier: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_b_g_specifier: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_b_g_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_b_g_source: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_b_g_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPeriodic: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_is_periodic: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_is_scheduled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduleAllowed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_is_schedule_allowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsLaunchOnBoot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfo,
            p_launch_on_boot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduled: *const fn (
            self: *const IPMBackgroundServiceAgentInfo,
            is_scheduled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduleAllowed: *const fn (
            self: *const IPMBackgroundServiceAgentInfo,
            is_schedule_allowed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getTaskID(self: *const T, p_task_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_TaskID(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_task_i_d_);
            }
            pub inline fn getBSAID(self: *const T, p_b_s_a_i_d_: ?*u32) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_BSAID(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_b_s_a_i_d_);
            }
            pub inline fn getBGSpecifier(self: *const T, p_b_g_specifier_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_BGSpecifier(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_b_g_specifier_);
            }
            pub inline fn getBGName(self: *const T, p_b_g_name_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_BGName(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_b_g_name_);
            }
            pub inline fn getBGSource(self: *const T, p_b_g_source_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_BGSource(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_b_g_source_);
            }
            pub inline fn getBGType(self: *const T, p_b_g_type_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_BGType(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_b_g_type_);
            }
            pub inline fn getIsPeriodic(self: *const T, p_is_periodic_: ?*BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_IsPeriodic(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_is_periodic_);
            }
            pub inline fn getIsScheduled(self: *const T, p_is_scheduled_: ?*BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_IsScheduled(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_is_scheduled_);
            }
            pub inline fn getIsScheduleAllowed(self: *const T, p_is_schedule_allowed_: ?*BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_IsScheduleAllowed(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_is_schedule_allowed_);
            }
            pub inline fn getDescription(self: *const T, p_description_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_description_);
            }
            pub inline fn getIsLaunchOnBoot(self: *const T, p_launch_on_boot_: ?*BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).get_IsLaunchOnBoot(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), p_launch_on_boot_);
            }
            pub inline fn setIsScheduled(self: *const T, is_scheduled_: BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).set_IsScheduled(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), is_scheduled_);
            }
            pub inline fn setIsScheduleAllowed(self: *const T, is_schedule_allowed_: BOOL) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfo.VTable, @ptrCast(self.vtable)).set_IsScheduleAllowed(@as(*const IPMBackgroundServiceAgentInfo, @ptrCast(self)), is_schedule_allowed_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundWorkerInfo_Value = Guid.initString("7dd4531b-d3bf-4b6b-94f3-69c098b1497d");
pub const IID_IPMBackgroundWorkerInfo = &IID_IPMBackgroundWorkerInfo_Value;
pub const IPMBackgroundWorkerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_product_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_task_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_b_g_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxStartupLatency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_max_startup_latency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedRuntime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_expected_runtime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBootWorker: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfo,
            p_is_boot_worker: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProductID(self: *const T, p_product_i_d_: ?*Guid) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_ProductID(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_product_i_d_);
            }
            pub inline fn getTaskID(self: *const T, p_task_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_TaskID(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_task_i_d_);
            }
            pub inline fn getBGName(self: *const T, p_b_g_name_: ?*?BSTR) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_BGName(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_b_g_name_);
            }
            pub inline fn getMaxStartupLatency(self: *const T, p_max_startup_latency_: ?*u32) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_MaxStartupLatency(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_max_startup_latency_);
            }
            pub inline fn getExpectedRuntime(self: *const T, p_expected_runtime_: ?*u32) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_ExpectedRuntime(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_expected_runtime_);
            }
            pub inline fn getIsBootWorker(self: *const T, p_is_boot_worker_: ?*BOOL) HRESULT {
                return @as(*const IPMBackgroundWorkerInfo.VTable, @ptrCast(self.vtable)).get_IsBootWorker(@as(*const IPMBackgroundWorkerInfo, @ptrCast(self)), p_is_boot_worker_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundServiceAgentInfoEnumerator_Value = Guid.initString("18eb2072-ab56-43b3-872c-beafb7a6b391");
pub const IID_IPMBackgroundServiceAgentInfoEnumerator = &IID_IPMBackgroundServiceAgentInfoEnumerator_Value;
pub const IPMBackgroundServiceAgentInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundServiceAgentInfoEnumerator,
            pp_b_s_a_info: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_b_s_a_info_: ?*?*IPMBackgroundServiceAgentInfo) HRESULT {
                return @as(*const IPMBackgroundServiceAgentInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMBackgroundServiceAgentInfoEnumerator, @ptrCast(self)), pp_b_s_a_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundWorkerInfoEnumerator_Value = Guid.initString("87f479f8-90d8-4ec7-92b9-72787e2f636b");
pub const IID_IPMBackgroundWorkerInfoEnumerator = &IID_IPMBackgroundWorkerInfoEnumerator_Value;
pub const IPMBackgroundWorkerInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPMBackgroundWorkerInfoEnumerator,
            pp_b_w_info: ?*?*IPMBackgroundWorkerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNext(self: *const T, pp_b_w_info_: ?*?*IPMBackgroundWorkerInfo) HRESULT {
                return @as(*const IPMBackgroundWorkerInfoEnumerator.VTable, @ptrCast(self.vtable)).get_Next(@as(*const IPMBackgroundWorkerInfoEnumerator, @ptrCast(self)), pp_b_w_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PPATCH_PROGRESS_CALLBACK = *const fn (
    callback_context: ?*anyopaque,
    current_position: u32,
    maximum_position: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PPATCH_SYMLOAD_CALLBACK = *const fn (
    which_file: u32,
    symbol_file_name: ?[*:0]const u8,
    sym_type: u32,
    symbol_file_check_sum: u32,
    symbol_file_time_date: u32,
    image_file_check_sum: u32,
    image_file_time_date: u32,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PATCH_IGNORE_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
};

pub const PATCH_RETAIN_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
    OffsetInNewFile: u32,
};

pub const PATCH_OLD_FILE_INFO_A = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u8,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_W = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u16,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_H = extern struct {
    SizeOfThisStruct: u32,
    OldFileHandle: ?HANDLE,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO = extern struct {
    SizeOfThisStruct: u32,
    Anonymous: extern union {
        OldFileNameA: ?[*:0]const u8,
        OldFileNameW: ?[*:0]const u16,
        OldFileHandle: ?HANDLE,
    },
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_INTERLEAVE_MAP = extern struct {
    CountRanges: u32,
    Range: [1]extern struct {
        OldOffset: u32,
        OldLength: u32,
        NewLength: u32,
    },
};

pub const PATCH_OPTION_DATA = extern struct {
    SizeOfThisStruct: u32,
    SymbolOptionFlags: u32,
    NewFileSymbolPath: ?[*:0]const u8,
    OldFileSymbolPathArray: ?*?PSTR,
    ExtendedOptionFlags: u32,
    SymLoadCallback: ?PPATCH_SYMLOAD_CALLBACK,
    SymLoadContext: ?*anyopaque,
    InterleaveMapArray: ?*?*PATCH_INTERLEAVE_MAP,
    MaxLzxWindowSize: u32,
};

pub const DELTA_INPUT = extern struct {
    Anonymous: extern union {
        lpcStart: ?*const anyopaque,
        lpStart: ?*anyopaque,
    },
    uSize: usize,
    Editable: BOOL,
};

pub const DELTA_OUTPUT = extern struct {
    lpStart: ?*anyopaque,
    uSize: usize,
};

pub const DELTA_HASH = extern struct {
    HashSize: u32,
    HashValue: [32]u8,
};

pub const DELTA_HEADER_INFO = extern struct {
    FileTypeSet: i64,
    FileType: i64,
    Flags: i64,
    TargetSize: usize,
    TargetFileTime: FILETIME,
    TargetHashAlgId: u32,
    TargetHash: DELTA_HASH,
};

pub const ACTIVATION_CONTEXT_QUERY_INDEX = extern struct {
    ulAssemblyIndex: u32,
    ulFileIndexInAssembly: u32,
};

pub const ASSEMBLY_FILE_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulFilenameLength: u32,
    ulPathLength: u32,
    lpFileName: ?[*:0]const u16,
    lpFilePath: ?[*:0]const u16,
};

pub const ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulEncodedAssemblyIdentityLength: u32,
    ulManifestPathType: u32,
    ulManifestPathLength: u32,
    liManifestLastWriteTime: LARGE_INTEGER,
    ulPolicyPathType: u32,
    ulPolicyPathLength: u32,
    liPolicyLastWriteTime: LARGE_INTEGER,
    ulMetadataSatelliteRosterIndex: u32,
    ulManifestVersionMajor: u32,
    ulManifestVersionMinor: u32,
    ulPolicyVersionMajor: u32,
    ulPolicyVersionMinor: u32,
    ulAssemblyDirectoryNameLength: u32,
    lpAssemblyEncodedAssemblyIdentity: ?[*:0]const u16,
    lpAssemblyManifestPath: ?[*:0]const u16,
    lpAssemblyPolicyPath: ?[*:0]const u16,
    lpAssemblyDirectoryName: ?[*:0]const u16,
    ulFileCount: u32,
};

pub const ACTCTX_REQUESTED_RUN_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    AS_INVOKER = 1,
    HIGHEST_AVAILABLE = 2,
    REQUIRE_ADMIN = 3,
    NUMBERS = 4,
};
pub const ACTCTX_RUN_LEVEL_UNSPECIFIED = ACTCTX_REQUESTED_RUN_LEVEL.UNSPECIFIED;
pub const ACTCTX_RUN_LEVEL_AS_INVOKER = ACTCTX_REQUESTED_RUN_LEVEL.AS_INVOKER;
pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = ACTCTX_REQUESTED_RUN_LEVEL.HIGHEST_AVAILABLE;
pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = ACTCTX_REQUESTED_RUN_LEVEL.REQUIRE_ADMIN;
pub const ACTCTX_RUN_LEVEL_NUMBERS = ACTCTX_REQUESTED_RUN_LEVEL.NUMBERS;

pub const ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = extern struct {
    ulFlags: u32,
    RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    UiAccess: u32,
};

pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE = enum(i32) {
    UNKNOWN = 0,
    OS = 1,
    MITIGATION = 2,
    MAXVERSIONTESTED = 3,
};
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.UNKNOWN;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.OS;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MITIGATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MAXVERSIONTESTED;

pub const COMPATIBILITY_CONTEXT_ELEMENT = extern struct {
    Id: Guid,
    Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    MaxVersionTested: u64,
};

pub const ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = extern struct {
    ElementCount: u32,
    Elements: [1]COMPATIBILITY_CONTEXT_ELEMENT,
};

pub const ACTIVATION_CONTEXT_DETAILED_INFORMATION = extern struct {
    dwFlags: u32,
    ulFormatVersion: u32,
    ulAssemblyCount: u32,
    ulRootManifestPathType: u32,
    ulRootManifestPathChars: u32,
    ulRootConfigurationPathType: u32,
    ulRootConfigurationPathChars: u32,
    ulAppDirPathType: u32,
    ulAppDirPathChars: u32,
    lpRootManifestPath: ?[*:0]const u16,
    lpRootConfigurationPath: ?[*:0]const u16,
    lpAppDirPath: ?[*:0]const u16,
};

pub const ACTCTXA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u8,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u8,
    lpResourceName: ?[*:0]const u8,
    lpApplicationName: ?[*:0]const u8,
    hModule: ?HINSTANCE,
};

pub const ACTCTXW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u16,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u16,
    lpResourceName: ?[*:0]const u16,
    lpApplicationName: ?[*:0]const u16,
    hModule: ?HINSTANCE,
};

pub const ACTCTX_SECTION_KEYED_DATA = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: ?*anyopaque,
    ulLength: u32,
    lpSectionGlobalData: ?*anyopaque,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: ?*anyopaque,
    ulSectionTotalLength: u32,
    hActCtx: ?HANDLE,
    ulAssemblyRosterIndex: u32,
    ulFlags: u32,
    AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
};

//--------------------------------------------------------------------------------
// Section: Functions (322)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCloseHandle(
    h_any: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCloseAllHandles() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetInternalUI(
    dw_u_i_level: INSTALLUILEVEL,
    ph_wnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) INSTALLUILEVEL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIA(
    pui_handler: ?INSTALLUI_HANDLERA,
    dw_message_filter: u32,
    pv_context: ?*anyopaque,
    retval: *?INSTALLUI_HANDLERA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIW(
    pui_handler: ?INSTALLUI_HANDLERW,
    dw_message_filter: u32,
    pv_context: ?*anyopaque,
    retval: *?INSTALLUI_HANDLERW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIRecord(
    pui_handler: ?PINSTALLUI_HANDLER_RECORD,
    dw_message_filter: u32,
    pv_context: ?*anyopaque,
    ppui_prev_handler: ?PINSTALLUI_HANDLER_RECORD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableLogA(
    dw_log_mode: INSTALLOGMODE,
    sz_log_file: ?[*:0]const u8,
    dw_log_attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableLogW(
    dw_log_mode: INSTALLOGMODE,
    sz_log_file: ?[*:0]const u16,
    dw_log_attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryProductStateA(
    sz_product: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryProductStateW(
    sz_product: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoA(
    sz_product: ?[*:0]const u8,
    sz_attribute: ?[*:0]const u8,
    lp_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoW(
    sz_product: ?[*:0]const u16,
    sz_attribute: ?[*:0]const u16,
    lp_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoExA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    sz_property: ?[*:0]const u8,
    sz_value: ?[*:0]u8,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoExW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    sz_property: ?[*:0]const u16,
    sz_value: ?[*:0]u16,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallProductA(
    sz_package_path: ?[*:0]const u8,
    sz_command_line: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallProductW(
    sz_package_path: ?[*:0]const u16,
    sz_command_line: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductA(
    sz_product: ?[*:0]const u8,
    i_install_level: INSTALLLEVEL,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductW(
    sz_product: ?[*:0]const u16,
    i_install_level: INSTALLLEVEL,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductExA(
    sz_product: ?[*:0]const u8,
    i_install_level: INSTALLLEVEL,
    e_install_state: INSTALLSTATE,
    sz_command_line: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductExW(
    sz_product: ?[*:0]const u16,
    i_install_level: INSTALLLEVEL,
    e_install_state: INSTALLSTATE,
    sz_command_line: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallProductA(
    sz_product: ?[*:0]const u8,
    sz_reinstall_mode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallProductW(
    sz_product: ?[*:0]const u16,
    sz_reinstall_mode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductExA(
    sz_package_path: ?[*:0]const u8,
    sz_scriptfile_path: ?[*:0]const u8,
    sz_transforms: ?[*:0]const u8,
    lgid_language: u16,
    dw_platform: u32,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductExW(
    sz_package_path: ?[*:0]const u16,
    sz_scriptfile_path: ?[*:0]const u16,
    sz_transforms: ?[*:0]const u16,
    lgid_language: u16,
    dw_platform: u32,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductA(
    sz_package_path: ?[*:0]const u8,
    sz_scriptfile_path: ?[*:0]const u8,
    sz_transforms: ?[*:0]const u8,
    lgid_language: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductW(
    sz_package_path: ?[*:0]const u16,
    sz_scriptfile_path: ?[*:0]const u16,
    sz_transforms: ?[*:0]const u16,
    lgid_language: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessAdvertiseScriptA(
    sz_script_file: ?[*:0]const u8,
    sz_icon_folder: ?[*:0]const u8,
    h_reg_data: ?HKEY,
    f_shortcuts: BOOL,
    f_remove_items: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessAdvertiseScriptW(
    sz_script_file: ?[*:0]const u16,
    sz_icon_folder: ?[*:0]const u16,
    h_reg_data: ?HKEY,
    f_shortcuts: BOOL,
    f_remove_items: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseScriptA(
    sz_script_file: ?[*:0]const u8,
    dw_flags: u32,
    ph_reg_data: ?*?HKEY,
    f_remove_items: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseScriptW(
    sz_script_file: ?[*:0]const u16,
    dw_flags: u32,
    ph_reg_data: ?*?HKEY,
    f_remove_items: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoFromScriptA(
    sz_script_file: ?[*:0]const u8,
    lp_product_buf39: ?PSTR,
    plgid_language: ?*u16,
    pdw_version: ?*u32,
    lp_name_buf: ?[*:0]u8,
    pcch_name_buf: ?*u32,
    lp_package_buf: ?[*:0]u8,
    pcch_package_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoFromScriptW(
    sz_script_file: ?[*:0]const u16,
    lp_product_buf39: ?PWSTR,
    plgid_language: ?*u16,
    pdw_version: ?*u32,
    lp_name_buf: ?[*:0]u16,
    pcch_name_buf: ?*u32,
    lp_package_buf: ?[*:0]u16,
    pcch_package_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductCodeA(
    sz_component: ?[*:0]const u8,
    lp_buf39: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductCodeW(
    sz_component: ?[*:0]const u16,
    lp_buf39: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetUserInfoA(
    sz_product: ?[*:0]const u8,
    lp_user_name_buf: ?[*:0]u8,
    pcch_user_name_buf: ?*u32,
    lp_org_name_buf: ?[*:0]u8,
    pcch_org_name_buf: ?*u32,
    lp_serial_buf: ?[*:0]u8,
    pcch_serial_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetUserInfoW(
    sz_product: ?[*:0]const u16,
    lp_user_name_buf: ?[*:0]u16,
    pcch_user_name_buf: ?*u32,
    lp_org_name_buf: ?[*:0]u16,
    pcch_org_name_buf: ?*u32,
    lp_serial_buf: ?[*:0]u16,
    pcch_serial_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCollectUserInfoA(
    sz_product: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCollectUserInfoW(
    sz_product: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyPatchA(
    sz_patch_package: ?[*:0]const u8,
    sz_install_package: ?[*:0]const u8,
    e_install_type: INSTALLTYPE,
    sz_command_line: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyPatchW(
    sz_patch_package: ?[*:0]const u16,
    sz_install_package: ?[*:0]const u16,
    e_install_type: INSTALLTYPE,
    sz_command_line: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoA(
    sz_patch: ?[*:0]const u8,
    sz_attribute: ?[*:0]const u8,
    lp_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoW(
    sz_patch: ?[*:0]const u16,
    sz_attribute: ?[*:0]const u16,
    lp_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesA(
    sz_product: ?[*:0]const u8,
    i_patch_index: u32,
    lp_patch_buf: ?PSTR,
    lp_transforms_buf: [*:0]u8,
    pcch_transforms_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesW(
    sz_product: ?[*:0]const u16,
    i_patch_index: u32,
    lp_patch_buf: ?PWSTR,
    lp_transforms_buf: [*:0]u16,
    pcch_transforms_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRemovePatchesA(
    sz_patch_list: ?[*:0]const u8,
    sz_product_code: ?[*:0]const u8,
    e_uninstall_type: INSTALLTYPE,
    sz_property_list: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRemovePatchesW(
    sz_patch_list: ?[*:0]const u16,
    sz_product_code: ?[*:0]const u16,
    e_uninstall_type: INSTALLTYPE,
    sz_property_list: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msi" fn MsiExtractPatchXMLDataA(
    sz_patch_path: ?[*:0]const u8,
    dw_reserved: u32,
    sz_x_m_l_data: ?[*:0]u8,
    pcch_x_m_l_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msi" fn MsiExtractPatchXMLDataW(
    sz_patch_path: ?[*:0]const u16,
    dw_reserved: u32,
    sz_x_m_l_data: ?[*:0]u16,
    pcch_x_m_l_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoExA(
    sz_patch_code: ?[*:0]const u8,
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    sz_property: ?[*:0]const u8,
    lp_value: ?[*:0]u8,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoExW(
    sz_patch_code: ?[*:0]const u16,
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    sz_property: ?[*:0]const u16,
    lp_value: ?[*:0]u16,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyMultiplePatchesA(
    sz_patch_packages: ?[*:0]const u8,
    sz_product_code: ?[*:0]const u8,
    sz_properties_list: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyMultiplePatchesW(
    sz_patch_packages: ?[*:0]const u16,
    sz_product_code: ?[*:0]const u16,
    sz_properties_list: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDeterminePatchSequenceA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    c_patch_info: u32,
    p_patch_info: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDeterminePatchSequenceW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    c_patch_info: u32,
    p_patch_info: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDetermineApplicablePatchesA(
    sz_product_package_path: ?[*:0]const u8,
    c_patch_info: u32,
    p_patch_info: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDetermineApplicablePatchesW(
    sz_product_package_path: ?[*:0]const u16,
    c_patch_info: u32,
    p_patch_info: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesExA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: u32,
    dw_filter: u32,
    dw_index: u32,
    sz_patch_code: ?PSTR,
    sz_target_product_code: ?PSTR,
    pdw_target_product_context: ?*MSIINSTALLCONTEXT,
    sz_target_user_sid: ?[*:0]u8,
    pcch_target_user_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesExW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: u32,
    dw_filter: u32,
    dw_index: u32,
    sz_patch_code: ?PWSTR,
    sz_target_product_code: ?PWSTR,
    pdw_target_product_context: ?*MSIINSTALLCONTEXT,
    sz_target_user_sid: ?[*:0]u16,
    pcch_target_user_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateExA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    sz_feature: ?[*:0]const u8,
    pdw_state: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateExW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    sz_feature: ?[*:0]const u16,
    pdw_state: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureExA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
    dw_install_mode: u32,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureExW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
    dw_install_mode: u32,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureUsageA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
    pdw_use_count: ?*u32,
    pw_date_used: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureUsageW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
    pdw_use_count: ?*u32,
    pw_date_used: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureFeatureA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureFeatureW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallFeatureA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
    dw_reinstall_mode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallFeatureW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
    dw_reinstall_mode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideComponentA(
    sz_product: ?[*:0]const u8,
    sz_feature: ?[*:0]const u8,
    sz_component: ?[*:0]const u8,
    dw_install_mode: INSTALLMODE,
    lp_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideComponentW(
    sz_product: ?[*:0]const u16,
    sz_feature: ?[*:0]const u16,
    sz_component: ?[*:0]const u16,
    dw_install_mode: INSTALLMODE,
    lp_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentA(
    sz_category: ?[*:0]const u8,
    sz_qualifier: ?[*:0]const u8,
    dw_install_mode: INSTALLMODE,
    lp_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentW(
    sz_category: ?[*:0]const u16,
    sz_qualifier: ?[*:0]const u16,
    dw_install_mode: INSTALLMODE,
    lp_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentExA(
    sz_category: ?[*:0]const u8,
    sz_qualifier: ?[*:0]const u8,
    dw_install_mode: INSTALLMODE,
    sz_product: ?[*:0]const u8,
    dw_unused1: u32,
    dw_unused2: u32,
    lp_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentExW(
    sz_category: ?[*:0]const u16,
    sz_qualifier: ?[*:0]const u16,
    dw_install_mode: INSTALLMODE,
    sz_product: ?[*:0]const u16,
    dw_unused1: u32,
    dw_unused2: u32,
    lp_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentPathA(
    sz_product: ?[*:0]const u8,
    sz_component: ?[*:0]const u8,
    lp_path_buf: ?[*:0]u8,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentPathW(
    sz_product: ?[*:0]const u16,
    sz_component: ?[*:0]const u16,
    lp_path_buf: ?[*:0]u16,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExA() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows8.0'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExW() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideAssemblyA(
    sz_assembly_name: ?[*:0]const u8,
    sz_app_context: ?[*:0]const u8,
    dw_install_mode: INSTALLMODE,
    dw_assembly_info: MSIASSEMBLYINFO,
    lp_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideAssemblyW(
    sz_assembly_name: ?[*:0]const u16,
    sz_app_context: ?[*:0]const u16,
    dw_install_mode: INSTALLMODE,
    dw_assembly_info: MSIASSEMBLYINFO,
    lp_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryComponentStateA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    sz_component_code: ?[*:0]const u8,
    pdw_state: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryComponentStateW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    sz_component_code: ?[*:0]const u16,
    pdw_state: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsA(
    i_product_index: u32,
    lp_product_buf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsW(
    i_product_index: u32,
    lp_product_buf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsExA(
    sz_product_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: u32,
    dw_index: u32,
    sz_installed_product_code: ?PSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u8,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsExW(
    sz_product_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: u32,
    dw_index: u32,
    sz_installed_product_code: ?PWSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u16,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumRelatedProductsA(
    lp_upgrade_code: ?[*:0]const u8,
    dw_reserved: u32,
    i_product_index: u32,
    lp_product_buf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumRelatedProductsW(
    lp_upgrade_code: ?[*:0]const u16,
    dw_reserved: u32,
    i_product_index: u32,
    lp_product_buf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumFeaturesA(
    sz_product: ?[*:0]const u8,
    i_feature_index: u32,
    lp_feature_buf: ?PSTR,
    lp_parent_buf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumFeaturesW(
    sz_product: ?[*:0]const u16,
    i_feature_index: u32,
    lp_feature_buf: ?PWSTR,
    lp_parent_buf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsA(
    i_component_index: u32,
    lp_component_buf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsW(
    i_component_index: u32,
    lp_component_buf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsExA(
    sz_user_sid: ?[*:0]const u8,
    dw_context: u32,
    dw_index: u32,
    sz_installed_component_code: ?PSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u8,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsExW(
    sz_user_sid: ?[*:0]const u16,
    dw_context: u32,
    dw_index: u32,
    sz_installed_component_code: ?PWSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u16,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsA(
    sz_component: ?[*:0]const u8,
    i_product_index: u32,
    lp_product_buf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsW(
    sz_component: ?[*:0]const u16,
    i_product_index: u32,
    lp_product_buf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsExA(
    sz_component: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_product_index: u32,
    sz_product_buf: ?PSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u8,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsExW(
    sz_component: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_product_index: u32,
    sz_product_buf: ?PWSTR,
    pdw_installed_context: ?*MSIINSTALLCONTEXT,
    sz_sid: ?[*:0]u16,
    pcch_sid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentQualifiersA(
    sz_component: ?[*:0]const u8,
    i_index: u32,
    lp_qualifier_buf: [*:0]u8,
    pcch_qualifier_buf: ?*u32,
    lp_application_data_buf: ?[*:0]u8,
    pcch_application_data_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentQualifiersW(
    sz_component: ?[*:0]const u16,
    i_index: u32,
    lp_qualifier_buf: [*:0]u16,
    pcch_qualifier_buf: ?*u32,
    lp_application_data_buf: ?[*:0]u16,
    pcch_application_data_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenProductA(
    sz_product: ?[*:0]const u8,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenProductW(
    sz_product: ?[*:0]const u16,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageA(
    sz_package_path: ?[*:0]const u8,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageW(
    sz_package_path: ?[*:0]const u16,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageExA(
    sz_package_path: ?[*:0]const u8,
    dw_options: u32,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageExW(
    sz_package_path: ?[*:0]const u16,
    dw_options: u32,
    h_product: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchFileListA(
    sz_product_code: ?[*:0]const u8,
    sz_patch_packages: ?[*:0]const u8,
    pc_files: ?*u32,
    pph_file_records: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchFileListW(
    sz_product_code: ?[*:0]const u16,
    sz_patch_packages: ?[*:0]const u16,
    pc_files: ?*u32,
    pph_file_records: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductPropertyA(
    h_product: MSIHANDLE,
    sz_property: ?[*:0]const u8,
    lp_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductPropertyW(
    h_product: MSIHANDLE,
    sz_property: ?[*:0]const u16,
    lp_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyPackageA(
    sz_package_path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyPackageW(
    sz_package_path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureInfoA(
    h_product: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    lp_attributes: ?*u32,
    lp_title_buf: ?[*:0]u8,
    pcch_title_buf: ?*u32,
    lp_help_buf: ?[*:0]u8,
    pcch_help_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureInfoW(
    h_product: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    lp_attributes: ?*u32,
    lp_title_buf: ?[*:0]u16,
    pcch_title_buf: ?*u32,
    lp_help_buf: ?[*:0]u16,
    pcch_help_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingComponentA(
    sz_product: ?[*:0]const u8,
    sz_component: ?[*:0]const u8,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingComponentW(
    sz_product: ?[*:0]const u16,
    sz_component: ?[*:0]const u16,
    e_install_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingFileA(
    sz_product: ?[*:0]const u8,
    sz_file: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingFileW(
    sz_product: ?[*:0]const u16,
    sz_file: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiLocateComponentA(
    sz_component: ?[*:0]const u8,
    lp_path_buf: ?[*:0]u8,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiLocateComponentW(
    sz_component: ?[*:0]const u16,
    lp_path_buf: ?[*:0]u16,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllA(
    sz_product: ?[*:0]const u8,
    sz_user_name: ?[*:0]const u8,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllW(
    sz_product: ?[*:0]const u16,
    sz_user_name: ?[*:0]const u16,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceA(
    sz_product: ?[*:0]const u8,
    sz_user_name: ?[*:0]const u8,
    dw_reserved: u32,
    sz_source: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceW(
    sz_product: ?[*:0]const u16,
    sz_user_name: ?[*:0]const u16,
    dw_reserved: u32,
    sz_source: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionA(
    sz_product: ?[*:0]const u8,
    sz_user_name: ?[*:0]const u8,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionW(
    sz_product: ?[*:0]const u16,
    sz_user_name: ?[*:0]const u16,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceExA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_source: ?[*:0]const u8,
    dw_index: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceExW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_source: ?[*:0]const u16,
    dw_index: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddMediaDiskA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_disk_id: u32,
    sz_volume_label: ?[*:0]const u8,
    sz_disk_prompt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddMediaDiskW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_disk_id: u32,
    sz_volume_label: ?[*:0]const u16,
    sz_disk_prompt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearSourceA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_source: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearSourceW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_source: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearMediaDiskA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_disk_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearMediaDiskW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_disk_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllExA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllExW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionExA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionExW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListSetInfoA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_property: ?[*:0]const u8,
    sz_value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListSetInfoW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_property: ?[*:0]const u16,
    sz_value: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListGetInfoA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_property: ?[*:0]const u8,
    sz_value: ?[*:0]u8,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListGetInfoW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    sz_property: ?[*:0]const u16,
    sz_value: ?[*:0]u16,
    pcch_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumSourcesA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_index: u32,
    sz_source: ?[*:0]u8,
    pcch_source: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumSourcesW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_index: u32,
    sz_source: ?[*:0]u16,
    pcch_source: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumMediaDisksA(
    sz_product_code_or_patch_code: ?[*:0]const u8,
    sz_user_sid: ?[*:0]const u8,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_index: u32,
    pdw_disk_id: ?*u32,
    sz_volume_label: ?[*:0]u8,
    pcch_volume_label: ?*u32,
    sz_disk_prompt: ?[*:0]u8,
    pcch_disk_prompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumMediaDisksW(
    sz_product_code_or_patch_code: ?[*:0]const u16,
    sz_user_sid: ?[*:0]const u16,
    dw_context: MSIINSTALLCONTEXT,
    dw_options: u32,
    dw_index: u32,
    pdw_disk_id: ?*u32,
    sz_volume_label: ?[*:0]u16,
    pcch_volume_label: ?*u32,
    sz_disk_prompt: ?[*:0]u16,
    pcch_disk_prompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileVersionA(
    sz_file_path: ?[*:0]const u8,
    lp_version_buf: ?[*:0]u8,
    pcch_version_buf: ?*u32,
    lp_lang_buf: ?[*:0]u8,
    pcch_lang_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileVersionW(
    sz_file_path: ?[*:0]const u16,
    lp_version_buf: ?[*:0]u16,
    pcch_version_buf: ?*u32,
    lp_lang_buf: ?[*:0]u16,
    pcch_lang_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileHashA(
    sz_file_path: ?[*:0]const u8,
    dw_options: u32,
    p_hash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileHashW(
    sz_file_path: ?[*:0]const u16,
    dw_options: u32,
    p_hash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileSignatureInformationA(
    sz_signed_object_path: ?[*:0]const u8,
    dw_flags: u32,
    ppc_cert_context: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pb_hash_data: ?*u8,
    pcb_hash_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileSignatureInformationW(
    sz_signed_object_path: ?[*:0]const u16,
    dw_flags: u32,
    ppc_cert_context: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pb_hash_data: ?*u8,
    pcb_hash_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetShortcutTargetA(
    sz_shortcut_path: ?[*:0]const u8,
    sz_product_code: ?PSTR,
    sz_feature_id: ?PSTR,
    sz_component_code: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetShortcutTargetW(
    sz_shortcut_path: ?[*:0]const u16,
    sz_product_code: ?PWSTR,
    sz_feature_id: ?PWSTR,
    sz_component_code: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiIsProductElevatedA(
    sz_product: ?[*:0]const u8,
    pf_elevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiIsProductElevatedW(
    sz_product: ?[*:0]const u16,
    pf_elevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiNotifySidChangeA(
    p_old_sid: ?[*:0]const u8,
    p_new_sid: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiNotifySidChangeW(
    p_old_sid: ?[*:0]const u16,
    p_new_sid: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiBeginTransactionA(
    sz_name: ?[*:0]const u8,
    dw_transaction_attributes: u32,
    ph_transaction_handle: ?*MSIHANDLE,
    ph_change_of_owner_event: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiBeginTransactionW(
    sz_name: ?[*:0]const u16,
    dw_transaction_attributes: u32,
    ph_transaction_handle: ?*MSIHANDLE,
    ph_change_of_owner_event: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEndTransaction(
    dw_transaction_state: MSITRANSACTIONSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiJoinTransaction(
    h_transaction_handle: MSIHANDLE,
    dw_transaction_attributes: u32,
    ph_change_of_owner_event: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseOpenViewA(
    h_database: MSIHANDLE,
    sz_query: ?[*:0]const u8,
    ph_view: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseOpenViewW(
    h_database: MSIHANDLE,
    sz_query: ?[*:0]const u16,
    ph_view: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetErrorA(
    h_view: MSIHANDLE,
    sz_column_name_buffer: ?[*:0]u8,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetErrorW(
    h_view: MSIHANDLE,
    sz_column_name_buffer: ?[*:0]u16,
    pcch_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewExecute(
    h_view: MSIHANDLE,
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewFetch(
    h_view: MSIHANDLE,
    ph_record: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewModify(
    h_view: MSIHANDLE,
    e_modify_mode: MSIMODIFY,
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetColumnInfo(
    h_view: MSIHANDLE,
    e_column_info: MSICOLINFO,
    ph_record: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewClose(
    h_view: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysA(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u8,
    ph_record: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysW(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u16,
    ph_record: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseIsTablePersistentA(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseIsTablePersistentW(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSummaryInformationA(
    h_database: MSIHANDLE,
    sz_database_path: ?[*:0]const u8,
    ui_update_count: u32,
    ph_summary_info: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSummaryInformationW(
    h_database: MSIHANDLE,
    sz_database_path: ?[*:0]const u16,
    ui_update_count: u32,
    ph_summary_info: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyCount(
    h_summary_info: MSIHANDLE,
    pui_property_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoSetPropertyA(
    h_summary_info: MSIHANDLE,
    ui_property: u32,
    ui_data_type: u32,
    i_value: i32,
    pft_value: ?*FILETIME,
    sz_value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoSetPropertyW(
    h_summary_info: MSIHANDLE,
    ui_property: u32,
    ui_data_type: u32,
    i_value: i32,
    pft_value: ?*FILETIME,
    sz_value: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyA(
    h_summary_info: MSIHANDLE,
    ui_property: u32,
    pui_data_type: ?*u32,
    pi_value: ?*i32,
    pft_value: ?*FILETIME,
    sz_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyW(
    h_summary_info: MSIHANDLE,
    ui_property: u32,
    pui_data_type: ?*u32,
    pi_value: ?*i32,
    pft_value: ?*FILETIME,
    sz_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoPersist(
    h_summary_info: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenDatabaseA(
    sz_database_path: ?[*:0]const u8,
    sz_persist: ?[*:0]const u8,
    ph_database: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenDatabaseW(
    sz_database_path: ?[*:0]const u16,
    sz_persist: ?[*:0]const u16,
    ph_database: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseImportA(
    h_database: MSIHANDLE,
    sz_folder_path: ?[*:0]const u8,
    sz_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseImportW(
    h_database: MSIHANDLE,
    sz_folder_path: ?[*:0]const u16,
    sz_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseExportA(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u8,
    sz_folder_path: ?[*:0]const u8,
    sz_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseExportW(
    h_database: MSIHANDLE,
    sz_table_name: ?[*:0]const u16,
    sz_folder_path: ?[*:0]const u16,
    sz_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseMergeA(
    h_database: MSIHANDLE,
    h_database_merge: MSIHANDLE,
    sz_table_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseMergeW(
    h_database: MSIHANDLE,
    h_database_merge: MSIHANDLE,
    sz_table_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGenerateTransformA(
    h_database: MSIHANDLE,
    h_database_reference: MSIHANDLE,
    sz_transform_file: ?[*:0]const u8,
    i_reserved1: i32,
    i_reserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGenerateTransformW(
    h_database: MSIHANDLE,
    h_database_reference: MSIHANDLE,
    sz_transform_file: ?[*:0]const u16,
    i_reserved1: i32,
    i_reserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseApplyTransformA(
    h_database: MSIHANDLE,
    sz_transform_file: ?[*:0]const u8,
    i_error_conditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseApplyTransformW(
    h_database: MSIHANDLE,
    sz_transform_file: ?[*:0]const u16,
    i_error_conditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateTransformSummaryInfoA(
    h_database: MSIHANDLE,
    h_database_reference: MSIHANDLE,
    sz_transform_file: ?[*:0]const u8,
    i_error_conditions: MSITRANSFORM_ERROR,
    i_validation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateTransformSummaryInfoW(
    h_database: MSIHANDLE,
    h_database_reference: MSIHANDLE,
    sz_transform_file: ?[*:0]const u16,
    i_error_conditions: MSITRANSFORM_ERROR,
    i_validation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseCommit(
    h_database: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetDatabaseState(
    h_database: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIDBSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateRecord(
    c_params: u32,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordIsNull(
    h_record: MSIHANDLE,
    i_field: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordDataSize(
    h_record: MSIHANDLE,
    i_field: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetInteger(
    h_record: MSIHANDLE,
    i_field: u32,
    i_value: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStringA(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStringW(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_value: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetInteger(
    h_record: MSIHANDLE,
    i_field: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetStringA(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetStringW(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetFieldCount(
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStreamA(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_file_path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStreamW(
    h_record: MSIHANDLE,
    i_field: u32,
    sz_file_path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordReadStream(
    h_record: MSIHANDLE,
    i_field: u32,
    // TODO: what to do with BytesParamIndex 3?
    sz_data_buf: ?PSTR,
    pcb_data_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordClearData(
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetActiveDatabase(
    h_install: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetPropertyA(
    h_install: MSIHANDLE,
    sz_name: ?[*:0]const u8,
    sz_value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetPropertyW(
    h_install: MSIHANDLE,
    sz_name: ?[*:0]const u16,
    sz_value: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPropertyA(
    h_install: MSIHANDLE,
    sz_name: ?[*:0]const u8,
    sz_value_buf: ?[*:0]u8,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPropertyW(
    h_install: MSIHANDLE,
    sz_name: ?[*:0]const u16,
    sz_value_buf: ?[*:0]u16,
    pcch_value_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetLanguage(
    h_install: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetMode(
    h_install: MSIHANDLE,
    e_run_mode: MSIRUNMODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetMode(
    h_install: MSIHANDLE,
    e_run_mode: MSIRUNMODE,
    f_state: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiFormatRecordA(
    h_install: MSIHANDLE,
    h_record: MSIHANDLE,
    sz_result_buf: ?[*:0]u8,
    pcch_result_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiFormatRecordW(
    h_install: MSIHANDLE,
    h_record: MSIHANDLE,
    sz_result_buf: ?[*:0]u16,
    pcch_result_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDoActionA(
    h_install: MSIHANDLE,
    sz_action: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDoActionW(
    h_install: MSIHANDLE,
    sz_action: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSequenceA(
    h_install: MSIHANDLE,
    sz_table: ?[*:0]const u8,
    i_sequence_mode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSequenceW(
    h_install: MSIHANDLE,
    sz_table: ?[*:0]const u16,
    i_sequence_mode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessMessage(
    h_install: MSIHANDLE,
    e_message_type: INSTALLMESSAGE,
    h_record: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEvaluateConditionA(
    h_install: MSIHANDLE,
    sz_condition: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEvaluateConditionW(
    h_install: MSIHANDLE,
    sz_condition: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureStateA(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    pi_installed: ?*INSTALLSTATE,
    pi_action: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureStateW(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    pi_installed: ?*INSTALLSTATE,
    pi_action: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureStateA(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    i_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureStateW(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    i_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureAttributesA(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    dw_attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureAttributesW(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    dw_attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentStateA(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u8,
    pi_installed: ?*INSTALLSTATE,
    pi_action: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentStateW(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u16,
    pi_installed: ?*INSTALLSTATE,
    pi_action: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetComponentStateA(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u8,
    i_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetComponentStateW(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u16,
    i_state: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureCostA(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    i_cost_tree: MSICOSTTREE,
    i_state: INSTALLSTATE,
    pi_cost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureCostW(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    i_cost_tree: MSICOSTTREE,
    i_state: INSTALLSTATE,
    pi_cost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentCostsA(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u8,
    dw_index: u32,
    i_state: INSTALLSTATE,
    sz_drive_buf: [*:0]u8,
    pcch_drive_buf: ?*u32,
    pi_cost: ?*i32,
    pi_temp_cost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentCostsW(
    h_install: MSIHANDLE,
    sz_component: ?[*:0]const u16,
    dw_index: u32,
    i_state: INSTALLSTATE,
    sz_drive_buf: [*:0]u16,
    pcch_drive_buf: ?*u32,
    pi_cost: ?*i32,
    pi_temp_cost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetInstallLevel(
    h_install: MSIHANDLE,
    i_install_level: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureValidStatesA(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u8,
    lp_install_states: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureValidStatesW(
    h_install: MSIHANDLE,
    sz_feature: ?[*:0]const u16,
    lp_install_states: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSourcePathA(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u8,
    sz_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSourcePathW(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u16,
    sz_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetTargetPathA(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u8,
    sz_path_buf: ?[*:0]u8,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetTargetPathW(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u16,
    sz_path_buf: ?[*:0]u16,
    pcch_path_buf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetTargetPathA(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u8,
    sz_folder_path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetTargetPathW(
    h_install: MSIHANDLE,
    sz_folder: ?[*:0]const u16,
    sz_folder_path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyDiskSpace(
    h_install: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableUIPreview(
    h_database: MSIHANDLE,
    ph_preview: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewDialogA(
    h_preview: MSIHANDLE,
    sz_dialog_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewDialogW(
    h_preview: MSIHANDLE,
    sz_dialog_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewBillboardA(
    h_preview: MSIHANDLE,
    sz_control_name: ?[*:0]const u8,
    sz_billboard: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewBillboardW(
    h_preview: MSIHANDLE,
    sz_control_name: ?[*:0]const u16,
    sz_billboard: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetLastErrorRecord() callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcGetNextProtectedFile(
    rpc_handle: ?HANDLE,
    prot_file_data: ?*PROTECTED_FILE_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcIsFileProtected(
    rpc_handle: ?HANDLE,
    prot_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "sfc" fn SfcIsKeyProtected(
    key_handle: ?HKEY,
    sub_key_name: ?[*:0]const u16,
    key_sam: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "sfc" fn SfpVerifyFile(
    psz_file_name: ?[*:0]const u8,
    psz_error: [*:0]u8,
    dw_err_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileA(
    old_file_name: ?[*:0]const u8,
    new_file_name: ?[*:0]const u8,
    patch_file_name: ?[*:0]const u8,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileW(
    old_file_name: ?[*:0]const u16,
    new_file_name: ?[*:0]const u16,
    patch_file_name: ?[*:0]const u16,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandles(
    old_file_handle: ?HANDLE,
    new_file_handle: ?HANDLE,
    patch_file_handle: ?HANDLE,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExA(
    old_file_count: u32,
    old_file_info_array: [*]PATCH_OLD_FILE_INFO_A,
    new_file_name: ?[*:0]const u8,
    patch_file_name: ?[*:0]const u8,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExW(
    old_file_count: u32,
    old_file_info_array: [*]PATCH_OLD_FILE_INFO_W,
    new_file_name: ?[*:0]const u16,
    patch_file_name: ?[*:0]const u16,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandlesEx(
    old_file_count: u32,
    old_file_info_array: [*]PATCH_OLD_FILE_INFO_H,
    new_file_handle: ?HANDLE,
    patch_file_handle: ?HANDLE,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileA(
    patch_file_name: ?[*:0]const u8,
    patch_header_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileW(
    patch_file_name: ?[*:0]const u16,
    patch_header_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileByHandles(
    patch_file_handle: ?HANDLE,
    patch_header_file_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileA(
    patch_file_name: ?[*:0]const u8,
    old_file_name: ?[*:0]const u8,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileW(
    patch_file_name: ?[*:0]const u16,
    old_file_name: ?[*:0]const u16,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByHandles(
    patch_file_handle: ?HANDLE,
    old_file_handle: ?HANDLE,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    patch_file_buffer: ?*u8,
    patch_file_size: u32,
    // TODO: what to do with BytesParamIndex 3?
    old_file_buffer: ?*u8,
    old_file_size: u32,
    new_file_size: ?*u32,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileA(
    patch_file_name: ?[*:0]const u8,
    old_file_name: ?[*:0]const u8,
    new_file_name: ?[*:0]const u8,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileW(
    patch_file_name: ?[*:0]const u16,
    old_file_name: ?[*:0]const u16,
    new_file_name: ?[*:0]const u16,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandles(
    patch_file_handle: ?HANDLE,
    old_file_handle: ?HANDLE,
    new_file_handle: ?HANDLE,
    apply_option_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExA(
    patch_file_name: ?[*:0]const u8,
    old_file_name: ?[*:0]const u8,
    new_file_name: ?[*:0]const u8,
    apply_option_flags: u32,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExW(
    patch_file_name: ?[*:0]const u16,
    old_file_name: ?[*:0]const u16,
    new_file_name: ?[*:0]const u16,
    apply_option_flags: u32,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandlesEx(
    patch_file_handle: ?HANDLE,
    old_file_handle: ?HANDLE,
    new_file_handle: ?HANDLE,
    apply_option_flags: u32,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    patch_file_mapped: ?*u8,
    patch_file_size: u32,
    // TODO: what to do with BytesParamIndex 3?
    old_file_mapped: ?*u8,
    old_file_size: u32,
    // TODO: what to do with BytesParamIndex 5?
    new_file_buffer: ?*?*u8,
    new_file_buffer_size: u32,
    new_file_actual_size: ?*u32,
    new_file_time: ?*FILETIME,
    apply_option_flags: u32,
    progress_callback: ?PPATCH_PROGRESS_CALLBACK,
    callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureA(
    file_name: ?[*:0]const u8,
    option_flags: u32,
    option_data: ?*anyopaque,
    ignore_range_count: u32,
    ignore_range_array: ?[*]PATCH_IGNORE_RANGE,
    retain_range_count: u32,
    retain_range_array: ?[*]PATCH_RETAIN_RANGE,
    signature_buffer_size: u32,
    // TODO: what to do with BytesParamIndex 7?
    signature_buffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureW(
    file_name: ?[*:0]const u16,
    option_flags: u32,
    option_data: ?*anyopaque,
    ignore_range_count: u32,
    ignore_range_array: ?[*]PATCH_IGNORE_RANGE,
    retain_range_count: u32,
    retain_range_array: ?[*]PATCH_RETAIN_RANGE,
    signature_buffer_size: u32,
    // TODO: what to do with BytesParamIndex 7?
    signature_buffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByHandle(
    file_handle: ?HANDLE,
    option_flags: u32,
    option_data: ?*anyopaque,
    ignore_range_count: u32,
    ignore_range_array: ?[*]PATCH_IGNORE_RANGE,
    retain_range_count: u32,
    retain_range_array: ?[*]PATCH_RETAIN_RANGE,
    signature_buffer_size: u32,
    // TODO: what to do with BytesParamIndex 7?
    signature_buffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByBuffer(
    // TODO: what to do with BytesParamIndex 1?
    file_buffer_writable: ?*u8,
    file_size: u32,
    option_flags: u32,
    option_data: ?*anyopaque,
    ignore_range_count: u32,
    ignore_range_array: ?[*]PATCH_IGNORE_RANGE,
    retain_range_count: u32,
    retain_range_array: ?[*]PATCH_RETAIN_RANGE,
    signature_buffer_size: u32,
    // TODO: what to do with BytesParamIndex 8?
    signature_buffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn NormalizeFileForPatchSignature(
    // TODO: what to do with BytesParamIndex 1?
    file_buffer: ?*anyopaque,
    file_size: u32,
    option_flags: u32,
    option_data: ?*PATCH_OPTION_DATA,
    new_file_coff_base: u32,
    new_file_coff_time: u32,
    ignore_range_count: u32,
    ignore_range_array: ?[*]PATCH_IGNORE_RANGE,
    retain_range_count: u32,
    retain_range_array: ?[*]PATCH_RETAIN_RANGE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "msdelta" fn GetDeltaInfoB(
    delta: DELTA_INPUT,
    lp_header_info: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoA(
    lp_delta_name: ?[*:0]const u8,
    lp_header_info: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoW(
    lp_delta_name: ?[*:0]const u16,
    lp_header_info: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaGetReverseB(
    apply_flags: i64,
    source: DELTA_INPUT,
    delta: DELTA_INPUT,
    lp_reverse_file_time: ?*const FILETIME,
    lp_target: ?*DELTA_OUTPUT,
    lp_target_reverse: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaB(
    apply_flags: i64,
    source: DELTA_INPUT,
    delta: DELTA_INPUT,
    lp_target: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaProvidedB(
    apply_flags: i64,
    source: DELTA_INPUT,
    delta: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lp_target: ?*anyopaque,
    u_target_size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaA(
    apply_flags: i64,
    lp_source_name: ?[*:0]const u8,
    lp_delta_name: ?[*:0]const u8,
    lp_target_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaW(
    apply_flags: i64,
    lp_source_name: ?[*:0]const u16,
    lp_delta_name: ?[*:0]const u16,
    lp_target_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaB(
    file_type_set: i64,
    set_flags: i64,
    reset_flags: i64,
    source: DELTA_INPUT,
    target: DELTA_INPUT,
    source_options: DELTA_INPUT,
    target_options: DELTA_INPUT,
    global_options: DELTA_INPUT,
    lp_target_file_time: ?*const FILETIME,
    hash_alg_id: u32,
    lp_delta: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaA(
    file_type_set: i64,
    set_flags: i64,
    reset_flags: i64,
    lp_source_name: ?[*:0]const u8,
    lp_target_name: ?[*:0]const u8,
    lp_source_options_name: ?[*:0]const u8,
    lp_target_options_name: ?[*:0]const u8,
    global_options: DELTA_INPUT,
    lp_target_file_time: ?*const FILETIME,
    hash_alg_id: u32,
    lp_delta_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaW(
    file_type_set: i64,
    set_flags: i64,
    reset_flags: i64,
    lp_source_name: ?[*:0]const u16,
    lp_target_name: ?[*:0]const u16,
    lp_source_options_name: ?[*:0]const u16,
    lp_target_options_name: ?[*:0]const u16,
    global_options: DELTA_INPUT,
    lp_target_file_time: ?*const FILETIME,
    hash_alg_id: u32,
    lp_delta_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureB(
    file_type_set: i64,
    hash_alg_id: u32,
    source: DELTA_INPUT,
    lp_hash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureA(
    file_type_set: i64,
    hash_alg_id: u32,
    lp_source_name: ?[*:0]const u8,
    lp_hash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureW(
    file_type_set: i64,
    hash_alg_id: u32,
    lp_source_name: ?[*:0]const u16,
    lp_hash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaNormalizeProvidedB(
    file_type_set: i64,
    normalize_flags: i64,
    normalize_options: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lp_source: ?*anyopaque,
    u_source_size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaFree(
    lp_memory: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateActCtxA(
    p_act_ctx: ?*ACTCTXA,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateActCtxW(
    p_act_ctx: ?*ACTCTXW,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn AddRefActCtx(
    h_act_ctx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReleaseActCtx(
    h_act_ctx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ZombifyActCtx(
    h_act_ctx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ActivateActCtx(
    h_act_ctx: ?HANDLE,
    lp_cookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeactivateActCtx(
    dw_flags: u32,
    ul_cookie: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetCurrentActCtx(
    lph_act_ctx: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionStringA(
    dw_flags: u32,
    lp_extension_guid: ?*const Guid,
    ul_section_id: u32,
    lp_string_to_find: ?[*:0]const u8,
    returned_data: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionStringW(
    dw_flags: u32,
    lp_extension_guid: ?*const Guid,
    ul_section_id: u32,
    lp_string_to_find: ?[*:0]const u16,
    returned_data: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionGuid(
    dw_flags: u32,
    lp_extension_guid: ?*const Guid,
    ul_section_id: u32,
    lp_guid_to_find: ?*const Guid,
    returned_data: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn QueryActCtxW(
    dw_flags: u32,
    h_act_ctx: ?HANDLE,
    pv_sub_instance: ?*anyopaque,
    ul_info_class: u32,
    // TODO: what to do with BytesParamIndex 5?
    pv_buffer: ?*anyopaque,
    cb_buffer: usize,
    pcb_written_or_required: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn QueryActCtxSettingsW(
    dw_flags: u32,
    h_act_ctx: ?HANDLE,
    settings_name_space: ?[*:0]const u16,
    setting_name: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 5?
    pv_buffer: ?PWSTR,
    dw_buffer: usize,
    pdw_written_or_required: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (133)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERA;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOA;
        pub const PATCH_OLD_FILE_INFO_ = thismodule.PATCH_OLD_FILE_INFO_A;
        pub const ACTCTX = thismodule.ACTCTXA;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIA;
        pub const MsiEnableLog = thismodule.MsiEnableLogA;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateA;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoA;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExA;
        pub const MsiInstallProduct = thismodule.MsiInstallProductA;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductA;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExA;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductA;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExA;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductA;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptA;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptA;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptA;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeA;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoA;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoA;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchA;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoA;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesA;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesA;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataA;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExA;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesA;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceA;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesA;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExA;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateA;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExA;
        pub const MsiUseFeature = thismodule.MsiUseFeatureA;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExA;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageA;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureA;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureA;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentA;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentA;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExA;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathA;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExA;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyA;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateA;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsA;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExA;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsA;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesA;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsA;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExA;
        pub const MsiEnumClients = thismodule.MsiEnumClientsA;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExA;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersA;
        pub const MsiOpenProduct = thismodule.MsiOpenProductA;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageA;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExA;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListA;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyA;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageA;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoA;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentA;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileA;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentA;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllA;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceA;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionA;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExA;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskA;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceA;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskA;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExA;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExA;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoA;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoA;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesA;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksA;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionA;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashA;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationA;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetA;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedA;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeA;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionA;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewA;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorA;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysA;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentA;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationA;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyA;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyA;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseA;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportA;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportA;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeA;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformA;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformA;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoA;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringA;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringA;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamA;
        pub const MsiSetProperty = thismodule.MsiSetPropertyA;
        pub const MsiGetProperty = thismodule.MsiGetPropertyA;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordA;
        pub const MsiDoAction = thismodule.MsiDoActionA;
        pub const MsiSequence = thismodule.MsiSequenceA;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionA;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateA;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateA;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesA;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateA;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateA;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostA;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsA;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesA;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathA;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathA;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathA;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogA;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardA;
        pub const CreatePatchFile = thismodule.CreatePatchFileA;
        pub const CreatePatchFileEx = thismodule.CreatePatchFileExA;
        pub const ExtractPatchHeaderToFile = thismodule.ExtractPatchHeaderToFileA;
        pub const TestApplyPatchToFile = thismodule.TestApplyPatchToFileA;
        pub const ApplyPatchToFile = thismodule.ApplyPatchToFileA;
        pub const ApplyPatchToFileEx = thismodule.ApplyPatchToFileExA;
        pub const GetFilePatchSignature = thismodule.GetFilePatchSignatureA;
        pub const GetDeltaInfo = thismodule.GetDeltaInfoA;
        pub const ApplyDelta = thismodule.ApplyDeltaA;
        pub const CreateDelta = thismodule.CreateDeltaA;
        pub const GetDeltaSignature = thismodule.GetDeltaSignatureA;
        pub const CreateActCtx = thismodule.CreateActCtxA;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringA;
    },
    .wide => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERW;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOW;
        pub const PATCH_OLD_FILE_INFO_ = thismodule.PATCH_OLD_FILE_INFO_W;
        pub const ACTCTX = thismodule.ACTCTXW;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIW;
        pub const MsiEnableLog = thismodule.MsiEnableLogW;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateW;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoW;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExW;
        pub const MsiInstallProduct = thismodule.MsiInstallProductW;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductW;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExW;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductW;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExW;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductW;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptW;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptW;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptW;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeW;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoW;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoW;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchW;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoW;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesW;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesW;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataW;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExW;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesW;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceW;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesW;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExW;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateW;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExW;
        pub const MsiUseFeature = thismodule.MsiUseFeatureW;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExW;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageW;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureW;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureW;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentW;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentW;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExW;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathW;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExW;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyW;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateW;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsW;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExW;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsW;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesW;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsW;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExW;
        pub const MsiEnumClients = thismodule.MsiEnumClientsW;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExW;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersW;
        pub const MsiOpenProduct = thismodule.MsiOpenProductW;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageW;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExW;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListW;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyW;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageW;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoW;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentW;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileW;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentW;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllW;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceW;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionW;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExW;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskW;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceW;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskW;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExW;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExW;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoW;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoW;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesW;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksW;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionW;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashW;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationW;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetW;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedW;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeW;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionW;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewW;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorW;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysW;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentW;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationW;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyW;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyW;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseW;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportW;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportW;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeW;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformW;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformW;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoW;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringW;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringW;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamW;
        pub const MsiSetProperty = thismodule.MsiSetPropertyW;
        pub const MsiGetProperty = thismodule.MsiGetPropertyW;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordW;
        pub const MsiDoAction = thismodule.MsiDoActionW;
        pub const MsiSequence = thismodule.MsiSequenceW;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionW;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateW;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateW;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesW;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateW;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateW;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostW;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsW;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesW;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathW;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathW;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathW;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogW;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardW;
        pub const CreatePatchFile = thismodule.CreatePatchFileW;
        pub const CreatePatchFileEx = thismodule.CreatePatchFileExW;
        pub const ExtractPatchHeaderToFile = thismodule.ExtractPatchHeaderToFileW;
        pub const TestApplyPatchToFile = thismodule.TestApplyPatchToFileW;
        pub const ApplyPatchToFile = thismodule.ApplyPatchToFileW;
        pub const ApplyPatchToFileEx = thismodule.ApplyPatchToFileExW;
        pub const GetFilePatchSignature = thismodule.GetFilePatchSignatureW;
        pub const GetDeltaInfo = thismodule.GetDeltaInfoW;
        pub const ApplyDelta = thismodule.ApplyDeltaW;
        pub const CreateDelta = thismodule.CreateDeltaW;
        pub const GetDeltaSignature = thismodule.GetDeltaSignatureW;
        pub const CreateActCtx = thismodule.CreateActCtxW;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const INSTALLUI_HANDLER = *opaque {};
        pub const MSIPATCHSEQUENCEINFO = *opaque {};
        pub const PATCH_OLD_FILE_INFO_ = *opaque {};
        pub const ACTCTX = *opaque {};
        pub const MsiSetExternalUI = *opaque {};
        pub const MsiEnableLog = *opaque {};
        pub const MsiQueryProductState = *opaque {};
        pub const MsiGetProductInfo = *opaque {};
        pub const MsiGetProductInfoEx = *opaque {};
        pub const MsiInstallProduct = *opaque {};
        pub const MsiConfigureProduct = *opaque {};
        pub const MsiConfigureProductEx = *opaque {};
        pub const MsiReinstallProduct = *opaque {};
        pub const MsiAdvertiseProductEx = *opaque {};
        pub const MsiAdvertiseProduct = *opaque {};
        pub const MsiProcessAdvertiseScript = *opaque {};
        pub const MsiAdvertiseScript = *opaque {};
        pub const MsiGetProductInfoFromScript = *opaque {};
        pub const MsiGetProductCode = *opaque {};
        pub const MsiGetUserInfo = *opaque {};
        pub const MsiCollectUserInfo = *opaque {};
        pub const MsiApplyPatch = *opaque {};
        pub const MsiGetPatchInfo = *opaque {};
        pub const MsiEnumPatches = *opaque {};
        pub const MsiRemovePatches = *opaque {};
        pub const MsiExtractPatchXMLData = *opaque {};
        pub const MsiGetPatchInfoEx = *opaque {};
        pub const MsiApplyMultiplePatches = *opaque {};
        pub const MsiDeterminePatchSequence = *opaque {};
        pub const MsiDetermineApplicablePatches = *opaque {};
        pub const MsiEnumPatchesEx = *opaque {};
        pub const MsiQueryFeatureState = *opaque {};
        pub const MsiQueryFeatureStateEx = *opaque {};
        pub const MsiUseFeature = *opaque {};
        pub const MsiUseFeatureEx = *opaque {};
        pub const MsiGetFeatureUsage = *opaque {};
        pub const MsiConfigureFeature = *opaque {};
        pub const MsiReinstallFeature = *opaque {};
        pub const MsiProvideComponent = *opaque {};
        pub const MsiProvideQualifiedComponent = *opaque {};
        pub const MsiProvideQualifiedComponentEx = *opaque {};
        pub const MsiGetComponentPath = *opaque {};
        pub const MsiGetComponentPathEx = *opaque {};
        pub const MsiProvideAssembly = *opaque {};
        pub const MsiQueryComponentState = *opaque {};
        pub const MsiEnumProducts = *opaque {};
        pub const MsiEnumProductsEx = *opaque {};
        pub const MsiEnumRelatedProducts = *opaque {};
        pub const MsiEnumFeatures = *opaque {};
        pub const MsiEnumComponents = *opaque {};
        pub const MsiEnumComponentsEx = *opaque {};
        pub const MsiEnumClients = *opaque {};
        pub const MsiEnumClientsEx = *opaque {};
        pub const MsiEnumComponentQualifiers = *opaque {};
        pub const MsiOpenProduct = *opaque {};
        pub const MsiOpenPackage = *opaque {};
        pub const MsiOpenPackageEx = *opaque {};
        pub const MsiGetPatchFileList = *opaque {};
        pub const MsiGetProductProperty = *opaque {};
        pub const MsiVerifyPackage = *opaque {};
        pub const MsiGetFeatureInfo = *opaque {};
        pub const MsiInstallMissingComponent = *opaque {};
        pub const MsiInstallMissingFile = *opaque {};
        pub const MsiLocateComponent = *opaque {};
        pub const MsiSourceListClearAll = *opaque {};
        pub const MsiSourceListAddSource = *opaque {};
        pub const MsiSourceListForceResolution = *opaque {};
        pub const MsiSourceListAddSourceEx = *opaque {};
        pub const MsiSourceListAddMediaDisk = *opaque {};
        pub const MsiSourceListClearSource = *opaque {};
        pub const MsiSourceListClearMediaDisk = *opaque {};
        pub const MsiSourceListClearAllEx = *opaque {};
        pub const MsiSourceListForceResolutionEx = *opaque {};
        pub const MsiSourceListSetInfo = *opaque {};
        pub const MsiSourceListGetInfo = *opaque {};
        pub const MsiSourceListEnumSources = *opaque {};
        pub const MsiSourceListEnumMediaDisks = *opaque {};
        pub const MsiGetFileVersion = *opaque {};
        pub const MsiGetFileHash = *opaque {};
        pub const MsiGetFileSignatureInformation = *opaque {};
        pub const MsiGetShortcutTarget = *opaque {};
        pub const MsiIsProductElevated = *opaque {};
        pub const MsiNotifySidChange = *opaque {};
        pub const MsiBeginTransaction = *opaque {};
        pub const MsiDatabaseOpenView = *opaque {};
        pub const MsiViewGetError = *opaque {};
        pub const MsiDatabaseGetPrimaryKeys = *opaque {};
        pub const MsiDatabaseIsTablePersistent = *opaque {};
        pub const MsiGetSummaryInformation = *opaque {};
        pub const MsiSummaryInfoSetProperty = *opaque {};
        pub const MsiSummaryInfoGetProperty = *opaque {};
        pub const MsiOpenDatabase = *opaque {};
        pub const MsiDatabaseImport = *opaque {};
        pub const MsiDatabaseExport = *opaque {};
        pub const MsiDatabaseMerge = *opaque {};
        pub const MsiDatabaseGenerateTransform = *opaque {};
        pub const MsiDatabaseApplyTransform = *opaque {};
        pub const MsiCreateTransformSummaryInfo = *opaque {};
        pub const MsiRecordSetString = *opaque {};
        pub const MsiRecordGetString = *opaque {};
        pub const MsiRecordSetStream = *opaque {};
        pub const MsiSetProperty = *opaque {};
        pub const MsiGetProperty = *opaque {};
        pub const MsiFormatRecord = *opaque {};
        pub const MsiDoAction = *opaque {};
        pub const MsiSequence = *opaque {};
        pub const MsiEvaluateCondition = *opaque {};
        pub const MsiGetFeatureState = *opaque {};
        pub const MsiSetFeatureState = *opaque {};
        pub const MsiSetFeatureAttributes = *opaque {};
        pub const MsiGetComponentState = *opaque {};
        pub const MsiSetComponentState = *opaque {};
        pub const MsiGetFeatureCost = *opaque {};
        pub const MsiEnumComponentCosts = *opaque {};
        pub const MsiGetFeatureValidStates = *opaque {};
        pub const MsiGetSourcePath = *opaque {};
        pub const MsiGetTargetPath = *opaque {};
        pub const MsiSetTargetPath = *opaque {};
        pub const MsiPreviewDialog = *opaque {};
        pub const MsiPreviewBillboard = *opaque {};
        pub const CreatePatchFile = *opaque {};
        pub const CreatePatchFileEx = *opaque {};
        pub const ExtractPatchHeaderToFile = *opaque {};
        pub const TestApplyPatchToFile = *opaque {};
        pub const ApplyPatchToFile = *opaque {};
        pub const ApplyPatchToFileEx = *opaque {};
        pub const GetFilePatchSignature = *opaque {};
        pub const GetDeltaInfo = *opaque {};
        pub const ApplyDelta = *opaque {};
        pub const CreateDelta = *opaque {};
        pub const GetDeltaSignature = *opaque {};
        pub const CreateActCtx = *opaque {};
        pub const FindActCtxSectionString = *opaque {};
    } else struct {
        pub const INSTALLUI_HANDLER = @compileError("'INSTALLUI_HANDLER' requires that UNICODE be set to true or false in the root module");
        pub const MSIPATCHSEQUENCEINFO = @compileError("'MSIPATCHSEQUENCEINFO' requires that UNICODE be set to true or false in the root module");
        pub const PATCH_OLD_FILE_INFO_ = @compileError("'PATCH_OLD_FILE_INFO_' requires that UNICODE be set to true or false in the root module");
        pub const ACTCTX = @compileError("'ACTCTX' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetExternalUI = @compileError("'MsiSetExternalUI' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnableLog = @compileError("'MsiEnableLog' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryProductState = @compileError("'MsiQueryProductState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfo = @compileError("'MsiGetProductInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoEx = @compileError("'MsiGetProductInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallProduct = @compileError("'MsiInstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProduct = @compileError("'MsiConfigureProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProductEx = @compileError("'MsiConfigureProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallProduct = @compileError("'MsiReinstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProductEx = @compileError("'MsiAdvertiseProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProduct = @compileError("'MsiAdvertiseProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiProcessAdvertiseScript = @compileError("'MsiProcessAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseScript = @compileError("'MsiAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoFromScript = @compileError("'MsiGetProductInfoFromScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductCode = @compileError("'MsiGetProductCode' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetUserInfo = @compileError("'MsiGetUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiCollectUserInfo = @compileError("'MsiCollectUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyPatch = @compileError("'MsiApplyPatch' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfo = @compileError("'MsiGetPatchInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatches = @compileError("'MsiEnumPatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiRemovePatches = @compileError("'MsiRemovePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiExtractPatchXMLData = @compileError("'MsiExtractPatchXMLData' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfoEx = @compileError("'MsiGetPatchInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyMultiplePatches = @compileError("'MsiApplyMultiplePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiDeterminePatchSequence = @compileError("'MsiDeterminePatchSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiDetermineApplicablePatches = @compileError("'MsiDetermineApplicablePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatchesEx = @compileError("'MsiEnumPatchesEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureState = @compileError("'MsiQueryFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureStateEx = @compileError("'MsiQueryFeatureStateEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeature = @compileError("'MsiUseFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeatureEx = @compileError("'MsiUseFeatureEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureUsage = @compileError("'MsiGetFeatureUsage' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureFeature = @compileError("'MsiConfigureFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallFeature = @compileError("'MsiReinstallFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideComponent = @compileError("'MsiProvideComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponent = @compileError("'MsiProvideQualifiedComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponentEx = @compileError("'MsiProvideQualifiedComponentEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPath = @compileError("'MsiGetComponentPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPathEx = @compileError("'MsiGetComponentPathEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideAssembly = @compileError("'MsiProvideAssembly' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryComponentState = @compileError("'MsiQueryComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProducts = @compileError("'MsiEnumProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProductsEx = @compileError("'MsiEnumProductsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumRelatedProducts = @compileError("'MsiEnumRelatedProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumFeatures = @compileError("'MsiEnumFeatures' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponents = @compileError("'MsiEnumComponents' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentsEx = @compileError("'MsiEnumComponentsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClients = @compileError("'MsiEnumClients' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClientsEx = @compileError("'MsiEnumClientsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentQualifiers = @compileError("'MsiEnumComponentQualifiers' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenProduct = @compileError("'MsiOpenProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackage = @compileError("'MsiOpenPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackageEx = @compileError("'MsiOpenPackageEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchFileList = @compileError("'MsiGetPatchFileList' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductProperty = @compileError("'MsiGetProductProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiVerifyPackage = @compileError("'MsiVerifyPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureInfo = @compileError("'MsiGetFeatureInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingComponent = @compileError("'MsiInstallMissingComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingFile = @compileError("'MsiInstallMissingFile' requires that UNICODE be set to true or false in the root module");
        pub const MsiLocateComponent = @compileError("'MsiLocateComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAll = @compileError("'MsiSourceListClearAll' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSource = @compileError("'MsiSourceListAddSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolution = @compileError("'MsiSourceListForceResolution' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSourceEx = @compileError("'MsiSourceListAddSourceEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddMediaDisk = @compileError("'MsiSourceListAddMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearSource = @compileError("'MsiSourceListClearSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearMediaDisk = @compileError("'MsiSourceListClearMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAllEx = @compileError("'MsiSourceListClearAllEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolutionEx = @compileError("'MsiSourceListForceResolutionEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListSetInfo = @compileError("'MsiSourceListSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListGetInfo = @compileError("'MsiSourceListGetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumSources = @compileError("'MsiSourceListEnumSources' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumMediaDisks = @compileError("'MsiSourceListEnumMediaDisks' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileVersion = @compileError("'MsiGetFileVersion' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileHash = @compileError("'MsiGetFileHash' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileSignatureInformation = @compileError("'MsiGetFileSignatureInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetShortcutTarget = @compileError("'MsiGetShortcutTarget' requires that UNICODE be set to true or false in the root module");
        pub const MsiIsProductElevated = @compileError("'MsiIsProductElevated' requires that UNICODE be set to true or false in the root module");
        pub const MsiNotifySidChange = @compileError("'MsiNotifySidChange' requires that UNICODE be set to true or false in the root module");
        pub const MsiBeginTransaction = @compileError("'MsiBeginTransaction' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseOpenView = @compileError("'MsiDatabaseOpenView' requires that UNICODE be set to true or false in the root module");
        pub const MsiViewGetError = @compileError("'MsiViewGetError' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGetPrimaryKeys = @compileError("'MsiDatabaseGetPrimaryKeys' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseIsTablePersistent = @compileError("'MsiDatabaseIsTablePersistent' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSummaryInformation = @compileError("'MsiGetSummaryInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoSetProperty = @compileError("'MsiSummaryInfoSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoGetProperty = @compileError("'MsiSummaryInfoGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenDatabase = @compileError("'MsiOpenDatabase' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseImport = @compileError("'MsiDatabaseImport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseExport = @compileError("'MsiDatabaseExport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseMerge = @compileError("'MsiDatabaseMerge' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGenerateTransform = @compileError("'MsiDatabaseGenerateTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseApplyTransform = @compileError("'MsiDatabaseApplyTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiCreateTransformSummaryInfo = @compileError("'MsiCreateTransformSummaryInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetString = @compileError("'MsiRecordSetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordGetString = @compileError("'MsiRecordGetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetStream = @compileError("'MsiRecordSetStream' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetProperty = @compileError("'MsiSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProperty = @compileError("'MsiGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiFormatRecord = @compileError("'MsiFormatRecord' requires that UNICODE be set to true or false in the root module");
        pub const MsiDoAction = @compileError("'MsiDoAction' requires that UNICODE be set to true or false in the root module");
        pub const MsiSequence = @compileError("'MsiSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiEvaluateCondition = @compileError("'MsiEvaluateCondition' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureState = @compileError("'MsiGetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureState = @compileError("'MsiSetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureAttributes = @compileError("'MsiSetFeatureAttributes' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentState = @compileError("'MsiGetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetComponentState = @compileError("'MsiSetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureCost = @compileError("'MsiGetFeatureCost' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentCosts = @compileError("'MsiEnumComponentCosts' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureValidStates = @compileError("'MsiGetFeatureValidStates' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSourcePath = @compileError("'MsiGetSourcePath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetTargetPath = @compileError("'MsiGetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetTargetPath = @compileError("'MsiSetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewDialog = @compileError("'MsiPreviewDialog' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewBillboard = @compileError("'MsiPreviewBillboard' requires that UNICODE be set to true or false in the root module");
        pub const CreatePatchFile = @compileError("'CreatePatchFile' requires that UNICODE be set to true or false in the root module");
        pub const CreatePatchFileEx = @compileError("'CreatePatchFileEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractPatchHeaderToFile = @compileError("'ExtractPatchHeaderToFile' requires that UNICODE be set to true or false in the root module");
        pub const TestApplyPatchToFile = @compileError("'TestApplyPatchToFile' requires that UNICODE be set to true or false in the root module");
        pub const ApplyPatchToFile = @compileError("'ApplyPatchToFile' requires that UNICODE be set to true or false in the root module");
        pub const ApplyPatchToFileEx = @compileError("'ApplyPatchToFileEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFilePatchSignature = @compileError("'GetFilePatchSignature' requires that UNICODE be set to true or false in the root module");
        pub const GetDeltaInfo = @compileError("'GetDeltaInfo' requires that UNICODE be set to true or false in the root module");
        pub const ApplyDelta = @compileError("'ApplyDelta' requires that UNICODE be set to true or false in the root module");
        pub const CreateDelta = @compileError("'CreateDelta' requires that UNICODE be set to true or false in the root module");
        pub const GetDeltaSignature = @compileError("'GetDeltaSignature' requires that UNICODE be set to true or false in the root module");
        pub const CreateActCtx = @compileError("'CreateActCtx' requires that UNICODE be set to true or false in the root module");
        pub const FindActCtxSectionString = @compileError("'FindActCtxSectionString' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = @import("../system/windows_programming.zig").ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CERT_CONTEXT = @import("../security/cryptography.zig").CERT_CONTEXT;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPDISPLAYVAL")) {
        _ = LPDISPLAYVAL;
    }
    if (@hasDecl(@This(), "LPEVALCOMCALLBACK")) {
        _ = LPEVALCOMCALLBACK;
    }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERA")) {
        _ = INSTALLUI_HANDLERA;
    }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERW")) {
        _ = INSTALLUI_HANDLERW;
    }
    if (@hasDecl(@This(), "PINSTALLUI_HANDLER_RECORD")) {
        _ = PINSTALLUI_HANDLER_RECORD;
    }
    if (@hasDecl(@This(), "PPATCH_PROGRESS_CALLBACK")) {
        _ = PPATCH_PROGRESS_CALLBACK;
    }
    if (@hasDecl(@This(), "PPATCH_SYMLOAD_CALLBACK")) {
        _ = PPATCH_SYMLOAD_CALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
