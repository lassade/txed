//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (12)
//--------------------------------------------------------------------------------
pub const NETWORK_ALIVE_LAN = @as(u32, 1);
pub const NETWORK_ALIVE_WAN = @as(u32, 2);
pub const NETWORK_ALIVE_AOL = @as(u32, 4);
pub const NETWORK_ALIVE_INTERNET = @as(u32, 8);
pub const CONNECTION_AOL = @as(u32, 4);
pub const SENSGUID_PUBLISHER = Guid.initString("5fee1bd6-5b9b-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_SUBSCRIBER_LCE = Guid.initString("d3938ab0-5b9d-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_SUBSCRIBER_WININET = Guid.initString("d3938ab5-5b9d-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_NETWORK = Guid.initString("d5978620-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_LOGON = Guid.initString("d5978630-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_ONNOW = Guid.initString("d5978640-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_LOGON2 = Guid.initString("d5978650-5b9f-11d1-8dd2-00aa004abd5e");

//--------------------------------------------------------------------------------
// Section: Types (8)
//--------------------------------------------------------------------------------
pub const SENS_CONNECTION_TYPE = enum(u32) {
    LAN = 0,
    WAN = 1,
};
pub const CONNECTION_LAN = SENS_CONNECTION_TYPE.LAN;
pub const CONNECTION_WAN = SENS_CONNECTION_TYPE.WAN;

pub const QOCINFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwInSpeed: u32,
    dwOutSpeed: u32,
};

const CLSID_SENS_Value = Guid.initString("d597cafe-5b9f-11d1-8dd2-00aa004abd5e");
pub const CLSID_SENS = &CLSID_SENS_Value;

pub const SENS_QOCINFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwOutSpeed: u32,
    dwInSpeed: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensNetwork_Value = Guid.initString("d597bab1-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensNetwork = &IID_ISensNetwork_Value;
pub const ISensNetwork = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConnectionMade: *const fn (
            self: *const ISensNetwork,
            bstr_connection: ?BSTR,
            ul_type: u32,
            lp_q_o_c_info: ?*SENS_QOCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionMadeNoQOCInfo: *const fn (
            self: *const ISensNetwork,
            bstr_connection: ?BSTR,
            ul_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionLost: *const fn (
            self: *const ISensNetwork,
            bstr_connection: ?BSTR,
            ul_type: SENS_CONNECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestinationReachable: *const fn (
            self: *const ISensNetwork,
            bstr_destination: ?BSTR,
            bstr_connection: ?BSTR,
            ul_type: u32,
            lp_q_o_c_info: ?*SENS_QOCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestinationReachableNoQOCInfo: *const fn (
            self: *const ISensNetwork,
            bstr_destination: ?BSTR,
            bstr_connection: ?BSTR,
            ul_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn connectionMade(self: *const T, bstr_connection_: ?BSTR, ul_type_: u32, lp_q_o_c_info_: ?*SENS_QOCINFO) HRESULT {
                return @as(*const ISensNetwork.VTable, @ptrCast(self.vtable)).ConnectionMade(@as(*const ISensNetwork, @ptrCast(self)), bstr_connection_, ul_type_, lp_q_o_c_info_);
            }
            pub inline fn connectionMadeNoQOCInfo(self: *const T, bstr_connection_: ?BSTR, ul_type_: u32) HRESULT {
                return @as(*const ISensNetwork.VTable, @ptrCast(self.vtable)).ConnectionMadeNoQOCInfo(@as(*const ISensNetwork, @ptrCast(self)), bstr_connection_, ul_type_);
            }
            pub inline fn connectionLost(self: *const T, bstr_connection_: ?BSTR, ul_type_: SENS_CONNECTION_TYPE) HRESULT {
                return @as(*const ISensNetwork.VTable, @ptrCast(self.vtable)).ConnectionLost(@as(*const ISensNetwork, @ptrCast(self)), bstr_connection_, ul_type_);
            }
            pub inline fn destinationReachable(self: *const T, bstr_destination_: ?BSTR, bstr_connection_: ?BSTR, ul_type_: u32, lp_q_o_c_info_: ?*SENS_QOCINFO) HRESULT {
                return @as(*const ISensNetwork.VTable, @ptrCast(self.vtable)).DestinationReachable(@as(*const ISensNetwork, @ptrCast(self)), bstr_destination_, bstr_connection_, ul_type_, lp_q_o_c_info_);
            }
            pub inline fn destinationReachableNoQOCInfo(self: *const T, bstr_destination_: ?BSTR, bstr_connection_: ?BSTR, ul_type_: u32) HRESULT {
                return @as(*const ISensNetwork.VTable, @ptrCast(self.vtable)).DestinationReachableNoQOCInfo(@as(*const ISensNetwork, @ptrCast(self)), bstr_destination_, bstr_connection_, ul_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensOnNow_Value = Guid.initString("d597bab2-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensOnNow = &IID_ISensOnNow_Value;
pub const ISensOnNow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OnACPower: *const fn (
            self: *const ISensOnNow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBatteryPower: *const fn (
            self: *const ISensOnNow,
            dw_battery_life_percent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BatteryLow: *const fn (
            self: *const ISensOnNow,
            dw_battery_life_percent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn onACPower(self: *const T) HRESULT {
                return @as(*const ISensOnNow.VTable, @ptrCast(self.vtable)).OnACPower(@as(*const ISensOnNow, @ptrCast(self)));
            }
            pub inline fn onBatteryPower(self: *const T, dw_battery_life_percent_: u32) HRESULT {
                return @as(*const ISensOnNow.VTable, @ptrCast(self.vtable)).OnBatteryPower(@as(*const ISensOnNow, @ptrCast(self)), dw_battery_life_percent_);
            }
            pub inline fn batteryLow(self: *const T, dw_battery_life_percent_: u32) HRESULT {
                return @as(*const ISensOnNow.VTable, @ptrCast(self.vtable)).BatteryLow(@as(*const ISensOnNow, @ptrCast(self)), dw_battery_life_percent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensLogon_Value = Guid.initString("d597bab3-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensLogon = &IID_ISensLogon_Value;
pub const ISensLogon = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Logon: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logoff: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartShell: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayLock: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUnlock: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartScreenSaver: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopScreenSaver: *const fn (
            self: *const ISensLogon,
            bstr_user_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn logon(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).Logon(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn logoff(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).Logoff(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn startShell(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).StartShell(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn displayLock(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).DisplayLock(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn displayUnlock(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).DisplayUnlock(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn startScreenSaver(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).StartScreenSaver(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
            pub inline fn stopScreenSaver(self: *const T, bstr_user_name_: ?BSTR) HRESULT {
                return @as(*const ISensLogon.VTable, @ptrCast(self.vtable)).StopScreenSaver(@as(*const ISensLogon, @ptrCast(self)), bstr_user_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensLogon2_Value = Guid.initString("d597bab4-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensLogon2 = &IID_ISensLogon2_Value;
pub const ISensLogon2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Logon: *const fn (
            self: *const ISensLogon2,
            bstr_user_name: ?BSTR,
            dw_session_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logoff: *const fn (
            self: *const ISensLogon2,
            bstr_user_name: ?BSTR,
            dw_session_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionDisconnect: *const fn (
            self: *const ISensLogon2,
            bstr_user_name: ?BSTR,
            dw_session_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionReconnect: *const fn (
            self: *const ISensLogon2,
            bstr_user_name: ?BSTR,
            dw_session_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostShell: *const fn (
            self: *const ISensLogon2,
            bstr_user_name: ?BSTR,
            dw_session_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn logon(self: *const T, bstr_user_name_: ?BSTR, dw_session_id_: u32) HRESULT {
                return @as(*const ISensLogon2.VTable, @ptrCast(self.vtable)).Logon(@as(*const ISensLogon2, @ptrCast(self)), bstr_user_name_, dw_session_id_);
            }
            pub inline fn logoff(self: *const T, bstr_user_name_: ?BSTR, dw_session_id_: u32) HRESULT {
                return @as(*const ISensLogon2.VTable, @ptrCast(self.vtable)).Logoff(@as(*const ISensLogon2, @ptrCast(self)), bstr_user_name_, dw_session_id_);
            }
            pub inline fn sessionDisconnect(self: *const T, bstr_user_name_: ?BSTR, dw_session_id_: u32) HRESULT {
                return @as(*const ISensLogon2.VTable, @ptrCast(self.vtable)).SessionDisconnect(@as(*const ISensLogon2, @ptrCast(self)), bstr_user_name_, dw_session_id_);
            }
            pub inline fn sessionReconnect(self: *const T, bstr_user_name_: ?BSTR, dw_session_id_: u32) HRESULT {
                return @as(*const ISensLogon2.VTable, @ptrCast(self.vtable)).SessionReconnect(@as(*const ISensLogon2, @ptrCast(self)), bstr_user_name_, dw_session_id_);
            }
            pub inline fn postShell(self: *const T, bstr_user_name_: ?BSTR, dw_session_id_: u32) HRESULT {
                return @as(*const ISensLogon2.VTable, @ptrCast(self.vtable)).PostShell(@as(*const ISensLogon2, @ptrCast(self)), bstr_user_name_, dw_session_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (3)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsDestinationReachableA(
    lpsz_destination: ?[*:0]const u8,
    lp_q_o_c_info: ?*QOCINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsDestinationReachableW(
    lpsz_destination: ?[*:0]const u16,
    lp_q_o_c_info: ?*QOCINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsNetworkAlive(
    lpdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (1)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const IsDestinationReachable = thismodule.IsDestinationReachableA;
    },
    .wide => struct {
        pub const IsDestinationReachable = thismodule.IsDestinationReachableW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const IsDestinationReachable = *opaque {};
    } else struct {
        pub const IsDestinationReachable = @compileError("'IsDestinationReachable' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
