//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (1)
//--------------------------------------------------------------------------------
pub const NV_MEMORY_RANGE = extern struct {
    BaseAddress: ?*anyopaque,
    Length: usize,
};

//--------------------------------------------------------------------------------
// Section: Functions (7)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlGetNonVolatileToken(
            // TODO: what to do with BytesParamIndex 1?
            nv_buffer: ?*anyopaque,
            size: usize,
            nv_token: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlFreeNonVolatileToken(
            nv_token: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlFlushNonVolatileMemory(
            nv_token: ?*anyopaque,
            // TODO: what to do with BytesParamIndex 2?
            nv_buffer: ?*anyopaque,
            size: usize,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlDrainNonVolatileFlush(
            nv_token: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlWriteNonVolatileMemory(
            nv_token: ?*anyopaque,
            // TODO: what to do with BytesParamIndex 3?
            nv_destination: ?*anyopaque,
            // TODO: what to do with BytesParamIndex 3?
            source: ?*const anyopaque,
            size: usize,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlFillNonVolatileMemory(
            nv_token: ?*anyopaque,
            // TODO: what to do with BytesParamIndex 2?
            nv_destination: ?*anyopaque,
            size: usize,
            value: u8,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "ntdll" fn RtlFlushNonVolatileMemoryRanges(
            nv_token: ?*anyopaque,
            nv_ranges: [*]NV_MEMORY_RANGE,
            num_ranges: usize,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (0)
//--------------------------------------------------------------------------------

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
