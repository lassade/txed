//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (40)
//--------------------------------------------------------------------------------
pub const MARSHALINTERFACE_MIN = @as(u32, 500);
pub const ASYNC_MODE_COMPATIBILITY = @as(i32, 1);
pub const ASYNC_MODE_DEFAULT = @as(i32, 0);
pub const STGTY_REPEAT = @as(i32, 256);
pub const STG_TOEND = @as(i32, -1);
pub const STG_LAYOUT_SEQUENTIAL = @as(i32, 0);
pub const STG_LAYOUT_INTERLEAVED = @as(i32, 1);
pub const _CRT_INTERNAL_COMBASE_SYMBOL_PREFIX = "_";
pub const COM_RIGHTS_EXECUTE = @as(u32, 1);
pub const COM_RIGHTS_EXECUTE_LOCAL = @as(u32, 2);
pub const COM_RIGHTS_EXECUTE_REMOTE = @as(u32, 4);
pub const COM_RIGHTS_ACTIVATE_LOCAL = @as(u32, 8);
pub const COM_RIGHTS_ACTIVATE_REMOTE = @as(u32, 16);
pub const COM_RIGHTS_RESERVED1 = @as(u32, 32);
pub const COM_RIGHTS_RESERVED2 = @as(u32, 64);
pub const CWMO_MAX_HANDLES = @as(u32, 56);
pub const ROTREGFLAGS_ALLOWANYCLIENT = @as(u32, 1);
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP = @as(u32, 1);
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND = @as(u32, 2);
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY = @as(u32, 4);
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN = @as(u32, 8);
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION = @as(u32, 16);
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY = @as(u32, 32);
pub const APPIDREGFLAGS_RESERVED1 = @as(u32, 64);
pub const APPIDREGFLAGS_RESERVED2 = @as(u32, 128);
pub const APPIDREGFLAGS_RESERVED3 = @as(u32, 256);
pub const APPIDREGFLAGS_RESERVED4 = @as(u32, 512);
pub const APPIDREGFLAGS_RESERVED5 = @as(u32, 1024);
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU = @as(u32, 2048);
pub const APPIDREGFLAGS_RESERVED7 = @as(u32, 4096);
pub const APPIDREGFLAGS_RESERVED8 = @as(u32, 8192);
pub const APPIDREGFLAGS_RESERVED9 = @as(u32, 16384);
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES = @as(u32, 1);
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL = @as(u32, 2);
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES = @as(u32, 4);
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL = @as(u32, 8);
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE = @as(u32, 16);
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL = @as(u32, 32);
pub const MAXLSN = @as(u64, 9223372036854775807);
pub const DMUS_ERRBASE = @as(u32, 4096);

//--------------------------------------------------------------------------------
// Section: Types (232)
//--------------------------------------------------------------------------------
// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const LPEXCEPFINO_DEFERRED_FILLIN = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const URI_CREATE_FLAGS = enum(u32) {
    ALLOW_RELATIVE = 1,
    ALLOW_IMPLICIT_WILDCARD_SCHEME = 2,
    ALLOW_IMPLICIT_FILE_SCHEME = 4,
    NOFRAG = 8,
    NO_CANONICALIZE = 16,
    CANONICALIZE = 256,
    FILE_USE_DOS_PATH = 32,
    DECODE_EXTRA_INFO = 64,
    NO_DECODE_EXTRA_INFO = 128,
    CRACK_UNKNOWN_SCHEMES = 512,
    NO_CRACK_UNKNOWN_SCHEMES = 1024,
    PRE_PROCESS_HTML_URI = 2048,
    NO_PRE_PROCESS_HTML_URI = 4096,
    IE_SETTINGS = 8192,
    NO_IE_SETTINGS = 16384,
    NO_ENCODE_FORBIDDEN_CHARACTERS = 32768,
    NORMALIZE_INTL_CHARACTERS = 65536,
    CANONICALIZE_ABSOLUTE = 131072,
    _,
    pub fn initFlags(o: struct {
        ALLOW_RELATIVE: u1 = 0,
        ALLOW_IMPLICIT_WILDCARD_SCHEME: u1 = 0,
        ALLOW_IMPLICIT_FILE_SCHEME: u1 = 0,
        NOFRAG: u1 = 0,
        NO_CANONICALIZE: u1 = 0,
        CANONICALIZE: u1 = 0,
        FILE_USE_DOS_PATH: u1 = 0,
        DECODE_EXTRA_INFO: u1 = 0,
        NO_DECODE_EXTRA_INFO: u1 = 0,
        CRACK_UNKNOWN_SCHEMES: u1 = 0,
        NO_CRACK_UNKNOWN_SCHEMES: u1 = 0,
        PRE_PROCESS_HTML_URI: u1 = 0,
        NO_PRE_PROCESS_HTML_URI: u1 = 0,
        IE_SETTINGS: u1 = 0,
        NO_IE_SETTINGS: u1 = 0,
        NO_ENCODE_FORBIDDEN_CHARACTERS: u1 = 0,
        NORMALIZE_INTL_CHARACTERS: u1 = 0,
        CANONICALIZE_ABSOLUTE: u1 = 0,
    }) URI_CREATE_FLAGS {
        return @as(URI_CREATE_FLAGS, @enumFromInt((if (o.ALLOW_RELATIVE == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_RELATIVE) else 0) | (if (o.ALLOW_IMPLICIT_WILDCARD_SCHEME == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME) else 0) | (if (o.ALLOW_IMPLICIT_FILE_SCHEME == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME) else 0) | (if (o.NOFRAG == 1) @intFromEnum(URI_CREATE_FLAGS.NOFRAG) else 0) | (if (o.NO_CANONICALIZE == 1) @intFromEnum(URI_CREATE_FLAGS.NO_CANONICALIZE) else 0) | (if (o.CANONICALIZE == 1) @intFromEnum(URI_CREATE_FLAGS.CANONICALIZE) else 0) | (if (o.FILE_USE_DOS_PATH == 1) @intFromEnum(URI_CREATE_FLAGS.FILE_USE_DOS_PATH) else 0) | (if (o.DECODE_EXTRA_INFO == 1) @intFromEnum(URI_CREATE_FLAGS.DECODE_EXTRA_INFO) else 0) | (if (o.NO_DECODE_EXTRA_INFO == 1) @intFromEnum(URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO) else 0) | (if (o.CRACK_UNKNOWN_SCHEMES == 1) @intFromEnum(URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES) else 0) | (if (o.NO_CRACK_UNKNOWN_SCHEMES == 1) @intFromEnum(URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES) else 0) | (if (o.PRE_PROCESS_HTML_URI == 1) @intFromEnum(URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI) else 0) | (if (o.NO_PRE_PROCESS_HTML_URI == 1) @intFromEnum(URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI) else 0) | (if (o.IE_SETTINGS == 1) @intFromEnum(URI_CREATE_FLAGS.IE_SETTINGS) else 0) | (if (o.NO_IE_SETTINGS == 1) @intFromEnum(URI_CREATE_FLAGS.NO_IE_SETTINGS) else 0) | (if (o.NO_ENCODE_FORBIDDEN_CHARACTERS == 1) @intFromEnum(URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS) else 0) | (if (o.NORMALIZE_INTL_CHARACTERS == 1) @intFromEnum(URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS) else 0) | (if (o.CANONICALIZE_ABSOLUTE == 1) @intFromEnum(URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE) else 0)));
    }
};
pub const Uri_CREATE_ALLOW_RELATIVE = URI_CREATE_FLAGS.ALLOW_RELATIVE;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME;
pub const Uri_CREATE_NOFRAG = URI_CREATE_FLAGS.NOFRAG;
pub const Uri_CREATE_NO_CANONICALIZE = URI_CREATE_FLAGS.NO_CANONICALIZE;
pub const Uri_CREATE_CANONICALIZE = URI_CREATE_FLAGS.CANONICALIZE;
pub const Uri_CREATE_FILE_USE_DOS_PATH = URI_CREATE_FLAGS.FILE_USE_DOS_PATH;
pub const Uri_CREATE_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.DECODE_EXTRA_INFO;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_IE_SETTINGS = URI_CREATE_FLAGS.IE_SETTINGS;
pub const Uri_CREATE_NO_IE_SETTINGS = URI_CREATE_FLAGS.NO_IE_SETTINGS;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE;

pub const RPC_C_AUTHN_LEVEL = enum(u32) {
    DEFAULT = 0,
    NONE = 1,
    CONNECT = 2,
    CALL = 3,
    PKT = 4,
    PKT_INTEGRITY = 5,
    PKT_PRIVACY = 6,
};
pub const RPC_C_AUTHN_LEVEL_DEFAULT = RPC_C_AUTHN_LEVEL.DEFAULT;
pub const RPC_C_AUTHN_LEVEL_NONE = RPC_C_AUTHN_LEVEL.NONE;
pub const RPC_C_AUTHN_LEVEL_CONNECT = RPC_C_AUTHN_LEVEL.CONNECT;
pub const RPC_C_AUTHN_LEVEL_CALL = RPC_C_AUTHN_LEVEL.CALL;
pub const RPC_C_AUTHN_LEVEL_PKT = RPC_C_AUTHN_LEVEL.PKT;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = RPC_C_AUTHN_LEVEL.PKT_INTEGRITY;
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY = RPC_C_AUTHN_LEVEL.PKT_PRIVACY;

pub const RPC_C_IMP_LEVEL = enum(u32) {
    DEFAULT = 0,
    ANONYMOUS = 1,
    IDENTIFY = 2,
    IMPERSONATE = 3,
    DELEGATE = 4,
};
pub const RPC_C_IMP_LEVEL_DEFAULT = RPC_C_IMP_LEVEL.DEFAULT;
pub const RPC_C_IMP_LEVEL_ANONYMOUS = RPC_C_IMP_LEVEL.ANONYMOUS;
pub const RPC_C_IMP_LEVEL_IDENTIFY = RPC_C_IMP_LEVEL.IDENTIFY;
pub const RPC_C_IMP_LEVEL_IMPERSONATE = RPC_C_IMP_LEVEL.IMPERSONATE;
pub const RPC_C_IMP_LEVEL_DELEGATE = RPC_C_IMP_LEVEL.DELEGATE;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const CO_MTA_USAGE_COOKIE = isize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const CO_DEVICE_CATALOG_COOKIE = isize;

pub const DVASPECT = enum(i32) {
    CONTENT = 1,
    THUMBNAIL = 2,
    ICON = 4,
    DOCPRINT = 8,
};
pub const DVASPECT_CONTENT = DVASPECT.CONTENT;
pub const DVASPECT_THUMBNAIL = DVASPECT.THUMBNAIL;
pub const DVASPECT_ICON = DVASPECT.ICON;
pub const DVASPECT_DOCPRINT = DVASPECT.DOCPRINT;

pub const CY = extern union {
    Anonymous: extern struct {
        Lo: u32,
        Hi: i32,
    },
    int64: i64,
};

pub const CSPLATFORM = extern struct {
    dwPlatformId: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
    dwProcessorArch: u32,
};

pub const QUERYCONTEXT = extern struct {
    dwContext: u32,
    Platform: CSPLATFORM,
    Locale: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
};

pub const TYSPEC = enum(i32) {
    CLSID = 0,
    FILEEXT = 1,
    MIMETYPE = 2,
    FILENAME = 3,
    PROGID = 4,
    PACKAGENAME = 5,
    OBJECTID = 6,
};
pub const TYSPEC_CLSID = TYSPEC.CLSID;
pub const TYSPEC_FILEEXT = TYSPEC.FILEEXT;
pub const TYSPEC_MIMETYPE = TYSPEC.MIMETYPE;
pub const TYSPEC_FILENAME = TYSPEC.FILENAME;
pub const TYSPEC_PROGID = TYSPEC.PROGID;
pub const TYSPEC_PACKAGENAME = TYSPEC.PACKAGENAME;
pub const TYSPEC_OBJECTID = TYSPEC.OBJECTID;

pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: extern struct {
        clsid: Guid,
        pFileExt: ?PWSTR,
        pMimeType: ?PWSTR,
        pProgId: ?PWSTR,
        pFileName: ?PWSTR,
        ByName: extern struct {
            pPackageName: ?PWSTR,
            PolicyId: Guid,
        },
        ByObjectId: extern struct {
            ObjectId: Guid,
            PolicyId: Guid,
        },
    },
};

pub const REGCLS = enum(i32) {
    SINGLEUSE = 0,
    MULTIPLEUSE = 1,
    MULTI_SEPARATE = 2,
    SUSPENDED = 4,
    SURROGATE = 8,
    AGILE = 16,
};
pub const REGCLS_SINGLEUSE = REGCLS.SINGLEUSE;
pub const REGCLS_MULTIPLEUSE = REGCLS.MULTIPLEUSE;
pub const REGCLS_MULTI_SEPARATE = REGCLS.MULTI_SEPARATE;
pub const REGCLS_SUSPENDED = REGCLS.SUSPENDED;
pub const REGCLS_SURROGATE = REGCLS.SURROGATE;
pub const REGCLS_AGILE = REGCLS.AGILE;

pub const COINITBASE = enum(i32) {
    D = 0,
};
pub const COINITBASE_MULTITHREADED = COINITBASE.D;

pub const COAUTHIDENTITY = extern struct {
    User: ?*u16,
    UserLength: u32,
    Domain: ?*u16,
    DomainLength: u32,
    Password: ?*u16,
    PasswordLength: u32,
    Flags: u32,
};

pub const COAUTHINFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pwszServerPrincName: ?PWSTR,
    dwAuthnLevel: u32,
    dwImpersonationLevel: u32,
    pAuthIdentityData: ?*COAUTHIDENTITY,
    dwCapabilities: u32,
};

pub const MEMCTX = enum(i32) {
    TASK = 1,
    SHARED = 2,
    MACSYSTEM = 3,
    UNKNOWN = -1,
    SAME = -2,
};
pub const MEMCTX_TASK = MEMCTX.TASK;
pub const MEMCTX_SHARED = MEMCTX.SHARED;
pub const MEMCTX_MACSYSTEM = MEMCTX.MACSYSTEM;
pub const MEMCTX_UNKNOWN = MEMCTX.UNKNOWN;
pub const MEMCTX_SAME = MEMCTX.SAME;

pub const CLSCTX = enum(u32) {
    INPROC_SERVER = 1,
    INPROC_HANDLER = 2,
    LOCAL_SERVER = 4,
    INPROC_SERVER16 = 8,
    REMOTE_SERVER = 16,
    INPROC_HANDLER16 = 32,
    RESERVED1 = 64,
    RESERVED2 = 128,
    RESERVED3 = 256,
    RESERVED4 = 512,
    NO_CODE_DOWNLOAD = 1024,
    RESERVED5 = 2048,
    NO_CUSTOM_MARSHAL = 4096,
    ENABLE_CODE_DOWNLOAD = 8192,
    NO_FAILURE_LOG = 16384,
    DISABLE_AAA = 32768,
    ENABLE_AAA = 65536,
    FROM_DEFAULT_CONTEXT = 131072,
    ACTIVATE_X86_SERVER = 262144,
    // ACTIVATE_32_BIT_SERVER = 262144, this enum value conflicts with ACTIVATE_X86_SERVER
    ACTIVATE_64_BIT_SERVER = 524288,
    ENABLE_CLOAKING = 1048576,
    APPCONTAINER = 4194304,
    ACTIVATE_AAA_AS_IU = 8388608,
    RESERVED6 = 16777216,
    ACTIVATE_ARM32_SERVER = 33554432,
    PS_DLL = 2147483648,
    ALL = 23,
    SERVER = 21,
    _,
    pub fn initFlags(o: struct {
        INPROC_SERVER: u1 = 0,
        INPROC_HANDLER: u1 = 0,
        LOCAL_SERVER: u1 = 0,
        INPROC_SERVER16: u1 = 0,
        REMOTE_SERVER: u1 = 0,
        INPROC_HANDLER16: u1 = 0,
        RESERVED1: u1 = 0,
        RESERVED2: u1 = 0,
        RESERVED3: u1 = 0,
        RESERVED4: u1 = 0,
        NO_CODE_DOWNLOAD: u1 = 0,
        RESERVED5: u1 = 0,
        NO_CUSTOM_MARSHAL: u1 = 0,
        ENABLE_CODE_DOWNLOAD: u1 = 0,
        NO_FAILURE_LOG: u1 = 0,
        DISABLE_AAA: u1 = 0,
        ENABLE_AAA: u1 = 0,
        FROM_DEFAULT_CONTEXT: u1 = 0,
        ACTIVATE_X86_SERVER: u1 = 0,
        ACTIVATE_64_BIT_SERVER: u1 = 0,
        ENABLE_CLOAKING: u1 = 0,
        APPCONTAINER: u1 = 0,
        ACTIVATE_AAA_AS_IU: u1 = 0,
        RESERVED6: u1 = 0,
        ACTIVATE_ARM32_SERVER: u1 = 0,
        PS_DLL: u1 = 0,
        ALL: u1 = 0,
        SERVER: u1 = 0,
    }) CLSCTX {
        return @as(CLSCTX, @enumFromInt((if (o.INPROC_SERVER == 1) @intFromEnum(CLSCTX.INPROC_SERVER) else 0) | (if (o.INPROC_HANDLER == 1) @intFromEnum(CLSCTX.INPROC_HANDLER) else 0) | (if (o.LOCAL_SERVER == 1) @intFromEnum(CLSCTX.LOCAL_SERVER) else 0) | (if (o.INPROC_SERVER16 == 1) @intFromEnum(CLSCTX.INPROC_SERVER16) else 0) | (if (o.REMOTE_SERVER == 1) @intFromEnum(CLSCTX.REMOTE_SERVER) else 0) | (if (o.INPROC_HANDLER16 == 1) @intFromEnum(CLSCTX.INPROC_HANDLER16) else 0) | (if (o.RESERVED1 == 1) @intFromEnum(CLSCTX.RESERVED1) else 0) | (if (o.RESERVED2 == 1) @intFromEnum(CLSCTX.RESERVED2) else 0) | (if (o.RESERVED3 == 1) @intFromEnum(CLSCTX.RESERVED3) else 0) | (if (o.RESERVED4 == 1) @intFromEnum(CLSCTX.RESERVED4) else 0) | (if (o.NO_CODE_DOWNLOAD == 1) @intFromEnum(CLSCTX.NO_CODE_DOWNLOAD) else 0) | (if (o.RESERVED5 == 1) @intFromEnum(CLSCTX.RESERVED5) else 0) | (if (o.NO_CUSTOM_MARSHAL == 1) @intFromEnum(CLSCTX.NO_CUSTOM_MARSHAL) else 0) | (if (o.ENABLE_CODE_DOWNLOAD == 1) @intFromEnum(CLSCTX.ENABLE_CODE_DOWNLOAD) else 0) | (if (o.NO_FAILURE_LOG == 1) @intFromEnum(CLSCTX.NO_FAILURE_LOG) else 0) | (if (o.DISABLE_AAA == 1) @intFromEnum(CLSCTX.DISABLE_AAA) else 0) | (if (o.ENABLE_AAA == 1) @intFromEnum(CLSCTX.ENABLE_AAA) else 0) | (if (o.FROM_DEFAULT_CONTEXT == 1) @intFromEnum(CLSCTX.FROM_DEFAULT_CONTEXT) else 0) | (if (o.ACTIVATE_X86_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_X86_SERVER) else 0) | (if (o.ACTIVATE_64_BIT_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_64_BIT_SERVER) else 0) | (if (o.ENABLE_CLOAKING == 1) @intFromEnum(CLSCTX.ENABLE_CLOAKING) else 0) | (if (o.APPCONTAINER == 1) @intFromEnum(CLSCTX.APPCONTAINER) else 0) | (if (o.ACTIVATE_AAA_AS_IU == 1) @intFromEnum(CLSCTX.ACTIVATE_AAA_AS_IU) else 0) | (if (o.RESERVED6 == 1) @intFromEnum(CLSCTX.RESERVED6) else 0) | (if (o.ACTIVATE_ARM32_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_ARM32_SERVER) else 0) | (if (o.PS_DLL == 1) @intFromEnum(CLSCTX.PS_DLL) else 0) | (if (o.ALL == 1) @intFromEnum(CLSCTX.ALL) else 0) | (if (o.SERVER == 1) @intFromEnum(CLSCTX.SERVER) else 0)));
    }
};
pub const CLSCTX_INPROC_SERVER = CLSCTX.INPROC_SERVER;
pub const CLSCTX_INPROC_HANDLER = CLSCTX.INPROC_HANDLER;
pub const CLSCTX_LOCAL_SERVER = CLSCTX.LOCAL_SERVER;
pub const CLSCTX_INPROC_SERVER16 = CLSCTX.INPROC_SERVER16;
pub const CLSCTX_REMOTE_SERVER = CLSCTX.REMOTE_SERVER;
pub const CLSCTX_INPROC_HANDLER16 = CLSCTX.INPROC_HANDLER16;
pub const CLSCTX_RESERVED1 = CLSCTX.RESERVED1;
pub const CLSCTX_RESERVED2 = CLSCTX.RESERVED2;
pub const CLSCTX_RESERVED3 = CLSCTX.RESERVED3;
pub const CLSCTX_RESERVED4 = CLSCTX.RESERVED4;
pub const CLSCTX_NO_CODE_DOWNLOAD = CLSCTX.NO_CODE_DOWNLOAD;
pub const CLSCTX_RESERVED5 = CLSCTX.RESERVED5;
pub const CLSCTX_NO_CUSTOM_MARSHAL = CLSCTX.NO_CUSTOM_MARSHAL;
pub const CLSCTX_ENABLE_CODE_DOWNLOAD = CLSCTX.ENABLE_CODE_DOWNLOAD;
pub const CLSCTX_NO_FAILURE_LOG = CLSCTX.NO_FAILURE_LOG;
pub const CLSCTX_DISABLE_AAA = CLSCTX.DISABLE_AAA;
pub const CLSCTX_ENABLE_AAA = CLSCTX.ENABLE_AAA;
pub const CLSCTX_FROM_DEFAULT_CONTEXT = CLSCTX.FROM_DEFAULT_CONTEXT;
pub const CLSCTX_ACTIVATE_X86_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_64_BIT_SERVER = CLSCTX.ACTIVATE_64_BIT_SERVER;
pub const CLSCTX_ENABLE_CLOAKING = CLSCTX.ENABLE_CLOAKING;
pub const CLSCTX_APPCONTAINER = CLSCTX.APPCONTAINER;
pub const CLSCTX_ACTIVATE_AAA_AS_IU = CLSCTX.ACTIVATE_AAA_AS_IU;
pub const CLSCTX_RESERVED6 = CLSCTX.RESERVED6;
pub const CLSCTX_ACTIVATE_ARM32_SERVER = CLSCTX.ACTIVATE_ARM32_SERVER;
pub const CLSCTX_PS_DLL = CLSCTX.PS_DLL;
pub const CLSCTX_ALL = CLSCTX.ALL;
pub const CLSCTX_SERVER = CLSCTX.SERVER;

pub const MSHLFLAGS = enum(i32) {
    NORMAL = 0,
    TABLESTRONG = 1,
    TABLEWEAK = 2,
    NOPING = 4,
    RESERVED1 = 8,
    RESERVED2 = 16,
    RESERVED3 = 32,
    RESERVED4 = 64,
};
pub const MSHLFLAGS_NORMAL = MSHLFLAGS.NORMAL;
pub const MSHLFLAGS_TABLESTRONG = MSHLFLAGS.TABLESTRONG;
pub const MSHLFLAGS_TABLEWEAK = MSHLFLAGS.TABLEWEAK;
pub const MSHLFLAGS_NOPING = MSHLFLAGS.NOPING;
pub const MSHLFLAGS_RESERVED1 = MSHLFLAGS.RESERVED1;
pub const MSHLFLAGS_RESERVED2 = MSHLFLAGS.RESERVED2;
pub const MSHLFLAGS_RESERVED3 = MSHLFLAGS.RESERVED3;
pub const MSHLFLAGS_RESERVED4 = MSHLFLAGS.RESERVED4;

pub const MSHCTX = enum(i32) {
    LOCAL = 0,
    NOSHAREDMEM = 1,
    DIFFERENTMACHINE = 2,
    INPROC = 3,
    CROSSCTX = 4,
    CONTAINER = 5,
};
pub const MSHCTX_LOCAL = MSHCTX.LOCAL;
pub const MSHCTX_NOSHAREDMEM = MSHCTX.NOSHAREDMEM;
pub const MSHCTX_DIFFERENTMACHINE = MSHCTX.DIFFERENTMACHINE;
pub const MSHCTX_INPROC = MSHCTX.INPROC;
pub const MSHCTX_CROSSCTX = MSHCTX.CROSSCTX;
pub const MSHCTX_CONTAINER = MSHCTX.CONTAINER;

pub const BYTE_BLOB = extern struct {
    clSize: u32,
    abData: [1]u8,
};

pub const WORD_BLOB = extern struct {
    clSize: u32,
    asData: [1]u16,
};

pub const DWORD_BLOB = extern struct {
    clSize: u32,
    alData: [1]u32,
};

pub const FLAGGED_BYTE_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    abData: [1]u8,
};

pub const FLAGGED_WORD_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    asData: [1]u16,
};

pub const BYTE_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u8,
};

pub const SHORT_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u16,
};

pub const LONG_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u32,
};

pub const HYPER_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*i64,
};

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: ?*u8,
};

pub const IEnumContextProps = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IContext = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IUnknown_Value = Guid.initString("00000000-0000-0000-c000-000000000046");
pub const IID_IUnknown = &IID_IUnknown_Value;
pub const IUnknown = extern struct {
    pub const VTable = extern struct {
        QueryInterface: *const fn (
            self: *const IUnknown,
            riid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: *const fn (
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: *const fn (
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn queryInterface(self: *const T, riid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).QueryInterface(@as(*const IUnknown, @ptrCast(self)), riid_, ppv_object_);
            }
            pub inline fn addRef(self: *const T) u32 {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).AddRef(@as(*const IUnknown, @ptrCast(self)));
            }
            pub inline fn release(self: *const T) u32 {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).Release(@as(*const IUnknown, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIUnknown_Value = Guid.initString("000e0000-0000-0000-c000-000000000046");
pub const IID_AsyncIUnknown = &IID_AsyncIUnknown_Value;
pub const AsyncIUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryInterface: *const fn (
            self: *const AsyncIUnknown,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryInterface: *const fn (
            self: *const AsyncIUnknown,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_AddRef: *const fn (
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_AddRef: *const fn (
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Begin_Release: *const fn (
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Release: *const fn (
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginQueryInterface(self: *const T, riid_: ?*const Guid) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_QueryInterface(@as(*const AsyncIUnknown, @ptrCast(self)), riid_);
            }
            pub inline fn finishQueryInterface(self: *const T, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_QueryInterface(@as(*const AsyncIUnknown, @ptrCast(self)), ppv_object_);
            }
            pub inline fn beginAddRef(self: *const T) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_AddRef(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            pub inline fn finishAddRef(self: *const T) u32 {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_AddRef(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            pub inline fn beginRelease(self: *const T) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_Release(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            pub inline fn finishRelease(self: *const T) u32 {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_Release(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory_Value = Guid.initString("00000001-0000-0000-c000-000000000046");
pub const IID_IClassFactory = &IID_IClassFactory_Value;
pub const IClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: *const fn (
            self: *const IClassFactory,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockServer: *const fn (
            self: *const IClassFactory,
            f_lock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createInstance(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const IClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IClassFactory, @ptrCast(self)), p_unk_outer_, riid_, ppv_object_);
            }
            pub inline fn lockServer(self: *const T, f_lock_: BOOL) HRESULT {
                return @as(*const IClassFactory.VTable, @ptrCast(self.vtable)).LockServer(@as(*const IClassFactory, @ptrCast(self)), f_lock_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COSERVERINFO = extern struct {
    dwReserved1: u32,
    pwszName: ?PWSTR,
    pAuthInfo: ?*COAUTHINFO,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INoMarshal_Value = Guid.initString("ecc8691b-c1db-4dc0-855e-65f6c551af49");
pub const IID_INoMarshal = &IID_INoMarshal_Value;
pub const INoMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAgileObject_Value = Guid.initString("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90");
pub const IID_IAgileObject = &IID_IAgileObject_Value;
pub const IAgileObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActivationFilter_Value = Guid.initString("00000017-0000-0000-c000-000000000046");
pub const IID_IActivationFilter = &IID_IActivationFilter_Value;
pub const IActivationFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActivation: *const fn (
            self: *const IActivationFilter,
            dw_activation_type: u32,
            rclsid: ?*const Guid,
            p_replacement_cls_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn handleActivation(self: *const T, dw_activation_type_: u32, rclsid_: ?*const Guid, p_replacement_cls_id_: ?*Guid) HRESULT {
                return @as(*const IActivationFilter.VTable, @ptrCast(self.vtable)).HandleActivation(@as(*const IActivationFilter, @ptrCast(self)), dw_activation_type_, rclsid_, p_replacement_cls_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMalloc_Value = Guid.initString("00000002-0000-0000-c000-000000000046");
pub const IID_IMalloc = &IID_IMalloc_Value;
pub const IMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: *const fn (
            self: *const IMalloc,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        Realloc: *const fn (
            self: *const IMalloc,
            pv: ?*anyopaque,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        Free: *const fn (
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetSize: *const fn (
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        DidAlloc: *const fn (
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        HeapMinimize: *const fn (
            self: *const IMalloc,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn alloc(self: *const T, cb_: usize) ?*anyopaque {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IMalloc, @ptrCast(self)), cb_);
            }
            pub inline fn realloc(self: *const T, pv_: ?*anyopaque, cb_: usize) ?*anyopaque {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Realloc(@as(*const IMalloc, @ptrCast(self)), pv_, cb_);
            }
            pub inline fn free(self: *const T, pv_: ?*anyopaque) void {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Free(@as(*const IMalloc, @ptrCast(self)), pv_);
            }
            pub inline fn getSize(self: *const T, pv_: ?*anyopaque) usize {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IMalloc, @ptrCast(self)), pv_);
            }
            pub inline fn didAlloc(self: *const T, pv_: ?*anyopaque) i32 {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).DidAlloc(@as(*const IMalloc, @ptrCast(self)), pv_);
            }
            pub inline fn heapMinimize(self: *const T) void {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).HeapMinimize(@as(*const IMalloc, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStdMarshalInfo_Value = Guid.initString("00000018-0000-0000-c000-000000000046");
pub const IID_IStdMarshalInfo = &IID_IStdMarshalInfo_Value;
pub const IStdMarshalInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassForHandler: *const fn (
            self: *const IStdMarshalInfo,
            dw_dest_context: u32,
            pv_dest_context: ?*anyopaque,
            p_clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getClassForHandler(self: *const T, dw_dest_context_: u32, pv_dest_context_: ?*anyopaque, p_clsid_: ?*Guid) HRESULT {
                return @as(*const IStdMarshalInfo.VTable, @ptrCast(self.vtable)).GetClassForHandler(@as(*const IStdMarshalInfo, @ptrCast(self)), dw_dest_context_, pv_dest_context_, p_clsid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EXTCONN = enum(i32) {
    STRONG = 1,
    WEAK = 2,
    CALLABLE = 4,
};
pub const EXTCONN_STRONG = EXTCONN.STRONG;
pub const EXTCONN_WEAK = EXTCONN.WEAK;
pub const EXTCONN_CALLABLE = EXTCONN.CALLABLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IExternalConnection_Value = Guid.initString("00000019-0000-0000-c000-000000000046");
pub const IID_IExternalConnection = &IID_IExternalConnection_Value;
pub const IExternalConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddConnection: *const fn (
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseConnection: *const fn (
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
            f_last_release_closes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addConnection(self: *const T, extconn_: u32, reserved_: u32) u32 {
                return @as(*const IExternalConnection.VTable, @ptrCast(self.vtable)).AddConnection(@as(*const IExternalConnection, @ptrCast(self)), extconn_, reserved_);
            }
            pub inline fn releaseConnection(self: *const T, extconn_: u32, reserved_: u32, f_last_release_closes_: BOOL) u32 {
                return @as(*const IExternalConnection.VTable, @ptrCast(self.vtable)).ReleaseConnection(@as(*const IExternalConnection, @ptrCast(self)), extconn_, reserved_, f_last_release_closes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MULTI_QI = extern struct {
    pIID: ?*const Guid,
    pItf: ?*IUnknown,
    hr: HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMultiQI_Value = Guid.initString("00000020-0000-0000-c000-000000000046");
pub const IID_IMultiQI = &IID_IMultiQI_Value;
pub const IMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryMultipleInterfaces: *const fn (
            self: *const IMultiQI,
            c_m_q_is: u32,
            p_m_q_is: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryMultipleInterfaces(self: *const T, c_m_q_is_: u32, p_m_q_is_: [*]MULTI_QI) HRESULT {
                return @as(*const IMultiQI.VTable, @ptrCast(self.vtable)).QueryMultipleInterfaces(@as(*const IMultiQI, @ptrCast(self)), c_m_q_is_, p_m_q_is_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIMultiQI_Value = Guid.initString("000e0020-0000-0000-c000-000000000046");
pub const IID_AsyncIMultiQI = &IID_AsyncIMultiQI_Value;
pub const AsyncIMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryMultipleInterfaces: *const fn (
            self: *const AsyncIMultiQI,
            c_m_q_is: u32,
            p_m_q_is: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryMultipleInterfaces: *const fn (
            self: *const AsyncIMultiQI,
            p_m_q_is: ?*MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginQueryMultipleInterfaces(self: *const T, c_m_q_is_: u32, p_m_q_is_: [*]MULTI_QI) HRESULT {
                return @as(*const AsyncIMultiQI.VTable, @ptrCast(self.vtable)).Begin_QueryMultipleInterfaces(@as(*const AsyncIMultiQI, @ptrCast(self)), c_m_q_is_, p_m_q_is_);
            }
            pub inline fn finishQueryMultipleInterfaces(self: *const T, p_m_q_is_: ?*MULTI_QI) HRESULT {
                return @as(*const AsyncIMultiQI.VTable, @ptrCast(self.vtable)).Finish_QueryMultipleInterfaces(@as(*const AsyncIMultiQI, @ptrCast(self)), p_m_q_is_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInternalUnknown_Value = Guid.initString("00000021-0000-0000-c000-000000000046");
pub const IID_IInternalUnknown = &IID_IInternalUnknown_Value;
pub const IInternalUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInternalInterface: *const fn (
            self: *const IInternalUnknown,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryInternalInterface(self: *const T, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IInternalUnknown.VTable, @ptrCast(self.vtable)).QueryInternalInterface(@as(*const IInternalUnknown, @ptrCast(self)), riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumUnknown_Value = Guid.initString("00000100-0000-0000-c000-000000000046");
pub const IID_IEnumUnknown = &IID_IEnumUnknown_Value;
pub const IEnumUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumUnknown,
            celt: u32,
            rgelt: [*]?*IUnknown,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumUnknown,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumUnknown,
            ppenum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IUnknown, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumUnknown, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumUnknown, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumUnknown, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumUnknown, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumString_Value = Guid.initString("00000101-0000-0000-c000-000000000046");
pub const IID_IEnumString = &IID_IEnumString_Value;
pub const IEnumString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumString,
            celt: u32,
            rgelt: [*]?PWSTR,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumString,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumString,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?PWSTR, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumString, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumString, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumString, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumString) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumString, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISequentialStream_Value = Guid.initString("0c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISequentialStream = &IID_ISequentialStream_Value;
pub const ISequentialStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: *const fn (
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*anyopaque,
            cb: u32,
            pcb_read: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: *const fn (
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*const anyopaque,
            cb: u32,
            pcb_written: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn read(self: *const T, pv_: ?*anyopaque, cb_: u32, pcb_read_: ?*u32) HRESULT {
                return @as(*const ISequentialStream.VTable, @ptrCast(self.vtable)).Read(@as(*const ISequentialStream, @ptrCast(self)), pv_, cb_, pcb_read_);
            }
            pub inline fn write(self: *const T, pv_: ?*const anyopaque, cb_: u32, pcb_written_: ?*u32) HRESULT {
                return @as(*const ISequentialStream.VTable, @ptrCast(self.vtable)).Write(@as(*const ISequentialStream, @ptrCast(self)), pv_, cb_, pcb_written_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STATSTG = extern struct {
    pwcsName: ?PWSTR,
    type: u32,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: u32,
    grfLocksSupported: u32,
    clsid: Guid,
    grfStateBits: u32,
    reserved: u32,
};

pub const STGTY = enum(i32) {
    STORAGE = 1,
    STREAM = 2,
    LOCKBYTES = 3,
    PROPERTY = 4,
};
pub const STGTY_STORAGE = STGTY.STORAGE;
pub const STGTY_STREAM = STGTY.STREAM;
pub const STGTY_LOCKBYTES = STGTY.LOCKBYTES;
pub const STGTY_PROPERTY = STGTY.PROPERTY;

pub const STREAM_SEEK = enum(u32) {
    SET = 0,
    CUR = 1,
    END = 2,
};
pub const STREAM_SEEK_SET = STREAM_SEEK.SET;
pub const STREAM_SEEK_CUR = STREAM_SEEK.CUR;
pub const STREAM_SEEK_END = STREAM_SEEK.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_IStream_Value = Guid.initString("0000000c-0000-0000-c000-000000000046");
pub const IID_IStream = &IID_IStream_Value;
pub const IStream = extern struct {
    pub const VTable = extern struct {
        base: ISequentialStream.VTable,
        Seek: *const fn (
            self: *const IStream,
            dlib_move: LARGE_INTEGER,
            dw_origin: STREAM_SEEK,
            plib_new_position: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: *const fn (
            self: *const IStream,
            lib_new_size: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: *const fn (
            self: *const IStream,
            pstm: ?*IStream,
            cb: ULARGE_INTEGER,
            pcb_read: ?*ULARGE_INTEGER,
            pcb_written: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IStream,
            grf_commit_flags: STGC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: *const fn (
            self: *const IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRegion: *const fn (
            self: *const IStream,
            lib_offset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dw_lock_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRegion: *const fn (
            self: *const IStream,
            lib_offset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dw_lock_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: *const fn (
            self: *const IStream,
            pstatstg: ?*STATSTG,
            grf_stat_flag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IStream,
            ppstm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISequentialStream.MethodMixin(T);
            pub inline fn seek(self: *const T, dlib_move_: LARGE_INTEGER, dw_origin_: STREAM_SEEK, plib_new_position_: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const IStream, @ptrCast(self)), dlib_move_, dw_origin_, plib_new_position_);
            }
            pub inline fn setSize(self: *const T, lib_new_size_: ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).SetSize(@as(*const IStream, @ptrCast(self)), lib_new_size_);
            }
            pub inline fn copyTo(self: *const T, pstm_: ?*IStream, cb_: ULARGE_INTEGER, pcb_read_: ?*ULARGE_INTEGER, pcb_written_: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IStream, @ptrCast(self)), pstm_, cb_, pcb_read_, pcb_written_);
            }
            pub inline fn commit(self: *const T, grf_commit_flags_: STGC) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Commit(@as(*const IStream, @ptrCast(self)), grf_commit_flags_);
            }
            pub inline fn revert(self: *const T) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Revert(@as(*const IStream, @ptrCast(self)));
            }
            pub inline fn lockRegion(self: *const T, lib_offset_: ULARGE_INTEGER, cb_: ULARGE_INTEGER, dw_lock_type_: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).LockRegion(@as(*const IStream, @ptrCast(self)), lib_offset_, cb_, dw_lock_type_);
            }
            pub inline fn unlockRegion(self: *const T, lib_offset_: ULARGE_INTEGER, cb_: ULARGE_INTEGER, dw_lock_type_: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).UnlockRegion(@as(*const IStream, @ptrCast(self)), lib_offset_, cb_, dw_lock_type_);
            }
            pub inline fn stat(self: *const T, pstatstg_: ?*STATSTG, grf_stat_flag_: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Stat(@as(*const IStream, @ptrCast(self)), pstatstg_, grf_stat_flag_);
            }
            pub inline fn clone(self: *const T, ppstm_: ?*?*IStream) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const IStream, @ptrCast(self)), ppstm_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOLEMESSAGE = extern struct {
    reserved1: ?*anyopaque,
    dataRepresentation: u32,
    Buffer: ?*anyopaque,
    cbBuffer: u32,
    iMethod: u32,
    reserved2: [5]?*anyopaque,
    rpcFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcChannelBuffer_Value = Guid.initString("d5f56b60-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcChannelBuffer = &IID_IRpcChannelBuffer_Value;
pub const IRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: *const fn (
            self: *const IRpcChannelBuffer,
            p_message: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendReceive: *const fn (
            self: *const IRpcChannelBuffer,
            p_message: ?*RPCOLEMESSAGE,
            p_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: *const fn (
            self: *const IRpcChannelBuffer,
            p_message: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtx: *const fn (
            self: *const IRpcChannelBuffer,
            pdw_dest_context: ?*u32,
            ppv_dest_context: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: *const fn (
            self: *const IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBuffer(self: *const T, p_message_: ?*RPCOLEMESSAGE, riid_: ?*const Guid) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IRpcChannelBuffer, @ptrCast(self)), p_message_, riid_);
            }
            pub inline fn sendReceive(self: *const T, p_message_: ?*RPCOLEMESSAGE, p_status_: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).SendReceive(@as(*const IRpcChannelBuffer, @ptrCast(self)), p_message_, p_status_);
            }
            pub inline fn freeBuffer(self: *const T, p_message_: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IRpcChannelBuffer, @ptrCast(self)), p_message_);
            }
            pub inline fn getDestCtx(self: *const T, pdw_dest_context_: ?*u32, ppv_dest_context_: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetDestCtx(@as(*const IRpcChannelBuffer, @ptrCast(self)), pdw_dest_context_, ppv_dest_context_);
            }
            pub inline fn isConnected(self: *const T) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const IRpcChannelBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer2_Value = Guid.initString("594f31d0-7f19-11d0-b194-00a0c90dc8bf");
pub const IID_IRpcChannelBuffer2 = &IID_IRpcChannelBuffer2_Value;
pub const IRpcChannelBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer.VTable,
        GetProtocolVersion: *const fn (
            self: *const IRpcChannelBuffer2,
            pdw_version: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer.MethodMixin(T);
            pub inline fn getProtocolVersion(self: *const T, pdw_version_: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer2.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IRpcChannelBuffer2, @ptrCast(self)), pdw_version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAsyncRpcChannelBuffer_Value = Guid.initString("a5029fb6-3c34-11d1-9c99-00c04fb998aa");
pub const IID_IAsyncRpcChannelBuffer = &IID_IAsyncRpcChannelBuffer_Value;
pub const IAsyncRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: *const fn (
            self: *const IAsyncRpcChannelBuffer,
            p_msg: ?*RPCOLEMESSAGE,
            p_sync: ?*ISynchronize,
            pul_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: *const fn (
            self: *const IAsyncRpcChannelBuffer,
            p_msg: ?*RPCOLEMESSAGE,
            pul_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: *const fn (
            self: *const IAsyncRpcChannelBuffer,
            p_msg: ?*RPCOLEMESSAGE,
            pdw_dest_context: ?*u32,
            ppv_dest_context: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
            pub inline fn send(self: *const T, p_msg_: ?*RPCOLEMESSAGE, p_sync_: ?*ISynchronize, pul_status_: ?*u32) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).Send(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), p_msg_, p_sync_, pul_status_);
            }
            pub inline fn receive(self: *const T, p_msg_: ?*RPCOLEMESSAGE, pul_status_: ?*u32) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).Receive(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), p_msg_, pul_status_);
            }
            pub inline fn getDestCtxEx(self: *const T, p_msg_: ?*RPCOLEMESSAGE, pdw_dest_context_: ?*u32, ppv_dest_context_: ?*?*anyopaque) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetDestCtxEx(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), p_msg_, pdw_dest_context_, ppv_dest_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer3_Value = Guid.initString("25b15600-0115-11d0-bf0d-00aa00b8dfd2");
pub const IID_IRpcChannelBuffer3 = &IID_IRpcChannelBuffer3_Value;
pub const IRpcChannelBuffer3 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            pul_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            ul_size: u32,
            pul_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
            p_interface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            pdw_dest_context: ?*u32,
            ppv_dest_context: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            p_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAsync: *const fn (
            self: *const IRpcChannelBuffer3,
            p_msg: ?*RPCOLEMESSAGE,
            p_async_mgr: ?*IAsyncManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
            pub inline fn send(self: *const T, p_msg_: ?*RPCOLEMESSAGE, pul_status_: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Send(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, pul_status_);
            }
            pub inline fn receive(self: *const T, p_msg_: ?*RPCOLEMESSAGE, ul_size_: u32, pul_status_: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Receive(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, ul_size_, pul_status_);
            }
            pub inline fn cancel(self: *const T, p_msg_: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_);
            }
            pub inline fn getCallContext(self: *const T, p_msg_: ?*RPCOLEMESSAGE, riid_: ?*const Guid, p_interface_: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetCallContext(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, riid_, p_interface_);
            }
            pub inline fn getDestCtxEx(self: *const T, p_msg_: ?*RPCOLEMESSAGE, pdw_dest_context_: ?*u32, ppv_dest_context_: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetDestCtxEx(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, pdw_dest_context_, ppv_dest_context_);
            }
            pub inline fn getState(self: *const T, p_msg_: ?*RPCOLEMESSAGE, p_state_: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetState(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, p_state_);
            }
            pub inline fn registerAsync(self: *const T, p_msg_: ?*RPCOLEMESSAGE, p_async_mgr_: ?*IAsyncManager) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).RegisterAsync(@as(*const IRpcChannelBuffer3, @ptrCast(self)), p_msg_, p_async_mgr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcSyntaxNegotiate_Value = Guid.initString("58a08519-24c8-4935-b482-3fd823333a4f");
pub const IID_IRpcSyntaxNegotiate = &IID_IRpcSyntaxNegotiate_Value;
pub const IRpcSyntaxNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateSyntax: *const fn (
            self: *const IRpcSyntaxNegotiate,
            p_msg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn negotiateSyntax(self: *const T, p_msg_: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcSyntaxNegotiate.VTable, @ptrCast(self.vtable)).NegotiateSyntax(@as(*const IRpcSyntaxNegotiate, @ptrCast(self)), p_msg_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcProxyBuffer_Value = Guid.initString("d5f56a34-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcProxyBuffer = &IID_IRpcProxyBuffer_Value;
pub const IRpcProxyBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: *const fn (
            self: *const IRpcProxyBuffer,
            p_rpc_channel_buffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IRpcProxyBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn connect(self: *const T, p_rpc_channel_buffer_: ?*IRpcChannelBuffer) HRESULT {
                return @as(*const IRpcProxyBuffer.VTable, @ptrCast(self.vtable)).Connect(@as(*const IRpcProxyBuffer, @ptrCast(self)), p_rpc_channel_buffer_);
            }
            pub inline fn disconnect(self: *const T) void {
                return @as(*const IRpcProxyBuffer.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IRpcProxyBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcStubBuffer_Value = Guid.initString("d5f56afc-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcStubBuffer = &IID_IRpcStubBuffer_Value;
pub const IRpcStubBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: *const fn (
            self: *const IRpcStubBuffer,
            p_unk_server: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Invoke: *const fn (
            self: *const IRpcStubBuffer,
            _prpcmsg: ?*RPCOLEMESSAGE,
            _p_rpc_channel_buffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIIDSupported: *const fn (
            self: *const IRpcStubBuffer,
            riid: ?*const Guid,
            retval: *?*IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CountRefs: *const fn (
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        DebugServerQueryInterface: *const fn (
            self: *const IRpcStubBuffer,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugServerRelease: *const fn (
            self: *const IRpcStubBuffer,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn connect(self: *const T, p_unk_server_: ?*IUnknown) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Connect(@as(*const IRpcStubBuffer, @ptrCast(self)), p_unk_server_);
            }
            pub inline fn disconnect(self: *const T) void {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IRpcStubBuffer, @ptrCast(self)));
            }
            pub inline fn invoke(self: *const T, _prpcmsg_: ?*RPCOLEMESSAGE, _p_rpc_channel_buffer_: ?*IRpcChannelBuffer) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IRpcStubBuffer, @ptrCast(self)), _prpcmsg_, _p_rpc_channel_buffer_);
            }
            pub inline fn isIIDSupported(self: *const T, riid_: ?*const Guid) ?*IRpcStubBuffer {
                var retval: ?*IRpcStubBuffer = undefined;
                @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).IsIIDSupported(@as(*const IRpcStubBuffer, @ptrCast(self)), riid_, &retval);
                return retval;
            }
            pub inline fn countRefs(self: *const T) u32 {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).CountRefs(@as(*const IRpcStubBuffer, @ptrCast(self)));
            }
            pub inline fn debugServerQueryInterface(self: *const T, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).DebugServerQueryInterface(@as(*const IRpcStubBuffer, @ptrCast(self)), ppv_);
            }
            pub inline fn debugServerRelease(self: *const T, pv_: ?*anyopaque) void {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).DebugServerRelease(@as(*const IRpcStubBuffer, @ptrCast(self)), pv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPSFactoryBuffer_Value = Guid.initString("d5f569d0-593b-101a-b569-08002b2dbf7a");
pub const IID_IPSFactoryBuffer = &IID_IPSFactoryBuffer_Value;
pub const IPSFactoryBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxy: *const fn (
            self: *const IPSFactoryBuffer,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_proxy: ?*?*IRpcProxyBuffer,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStub: *const fn (
            self: *const IPSFactoryBuffer,
            riid: ?*const Guid,
            p_unk_server: ?*IUnknown,
            pp_stub: ?*?*IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createProxy(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_proxy_: ?*?*IRpcProxyBuffer, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IPSFactoryBuffer.VTable, @ptrCast(self.vtable)).CreateProxy(@as(*const IPSFactoryBuffer, @ptrCast(self)), p_unk_outer_, riid_, pp_proxy_, ppv_);
            }
            pub inline fn createStub(self: *const T, riid_: ?*const Guid, p_unk_server_: ?*IUnknown, pp_stub_: ?*?*IRpcStubBuffer) HRESULT {
                return @as(*const IPSFactoryBuffer.VTable, @ptrCast(self.vtable)).CreateStub(@as(*const IPSFactoryBuffer, @ptrCast(self)), riid_, p_unk_server_, pp_stub_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SChannelHookCallInfo = extern struct {
    iid: Guid,
    cbSize: u32,
    uCausality: Guid,
    dwServerPid: u32,
    iMethod: u32,
    pObject: ?*anyopaque,
};

const IID_IChannelHook_Value = Guid.initString("1008c4a0-7613-11cf-9af1-0020af6e72f4");
pub const IID_IChannelHook = &IID_IChannelHook_Value;
pub const IChannelHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClientGetSize: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            p_data_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientFillBuffer: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            p_data_size: ?*u32,
            p_data_buffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientNotify: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            cb_data_size: u32,
            p_data_buffer: ?*anyopaque,
            l_data_rep: u32,
            hr_fault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerNotify: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            cb_data_size: u32,
            p_data_buffer: ?*anyopaque,
            l_data_rep: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerGetSize: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            hr_fault: HRESULT,
            p_data_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerFillBuffer: *const fn (
            self: *const IChannelHook,
            u_extent: ?*const Guid,
            riid: ?*const Guid,
            p_data_size: ?*u32,
            p_data_buffer: ?*anyopaque,
            hr_fault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clientGetSize(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, p_data_size_: ?*u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientGetSize(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, p_data_size_);
            }
            pub inline fn clientFillBuffer(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, p_data_size_: ?*u32, p_data_buffer_: ?*anyopaque) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientFillBuffer(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, p_data_size_, p_data_buffer_);
            }
            pub inline fn clientNotify(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, cb_data_size_: u32, p_data_buffer_: ?*anyopaque, l_data_rep_: u32, hr_fault_: HRESULT) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientNotify(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, cb_data_size_, p_data_buffer_, l_data_rep_, hr_fault_);
            }
            pub inline fn serverNotify(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, cb_data_size_: u32, p_data_buffer_: ?*anyopaque, l_data_rep_: u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerNotify(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, cb_data_size_, p_data_buffer_, l_data_rep_);
            }
            pub inline fn serverGetSize(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, hr_fault_: HRESULT, p_data_size_: ?*u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerGetSize(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, hr_fault_, p_data_size_);
            }
            pub inline fn serverFillBuffer(self: *const T, u_extent_: ?*const Guid, riid_: ?*const Guid, p_data_size_: ?*u32, p_data_buffer_: ?*anyopaque, hr_fault_: HRESULT) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerFillBuffer(@as(*const IChannelHook, @ptrCast(self)), u_extent_, riid_, p_data_size_, p_data_buffer_, hr_fault_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pPrincipalName: ?PWSTR,
    hr: HRESULT,
};

pub const EOLE_AUTHENTICATION_CAPABILITIES = enum(i32) {
    NONE = 0,
    MUTUAL_AUTH = 1,
    STATIC_CLOAKING = 32,
    DYNAMIC_CLOAKING = 64,
    ANY_AUTHORITY = 128,
    MAKE_FULLSIC = 256,
    DEFAULT = 2048,
    SECURE_REFS = 2,
    ACCESS_CONTROL = 4,
    APPID = 8,
    DYNAMIC = 16,
    REQUIRE_FULLSIC = 512,
    AUTO_IMPERSONATE = 1024,
    DISABLE_AAA = 4096,
    NO_CUSTOM_MARSHAL = 8192,
    RESERVED1 = 16384,
};
pub const EOAC_NONE = EOLE_AUTHENTICATION_CAPABILITIES.NONE;
pub const EOAC_MUTUAL_AUTH = EOLE_AUTHENTICATION_CAPABILITIES.MUTUAL_AUTH;
pub const EOAC_STATIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.STATIC_CLOAKING;
pub const EOAC_DYNAMIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC_CLOAKING;
pub const EOAC_ANY_AUTHORITY = EOLE_AUTHENTICATION_CAPABILITIES.ANY_AUTHORITY;
pub const EOAC_MAKE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.MAKE_FULLSIC;
pub const EOAC_DEFAULT = EOLE_AUTHENTICATION_CAPABILITIES.DEFAULT;
pub const EOAC_SECURE_REFS = EOLE_AUTHENTICATION_CAPABILITIES.SECURE_REFS;
pub const EOAC_ACCESS_CONTROL = EOLE_AUTHENTICATION_CAPABILITIES.ACCESS_CONTROL;
pub const EOAC_APPID = EOLE_AUTHENTICATION_CAPABILITIES.APPID;
pub const EOAC_DYNAMIC = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC;
pub const EOAC_REQUIRE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.REQUIRE_FULLSIC;
pub const EOAC_AUTO_IMPERSONATE = EOLE_AUTHENTICATION_CAPABILITIES.AUTO_IMPERSONATE;
pub const EOAC_DISABLE_AAA = EOLE_AUTHENTICATION_CAPABILITIES.DISABLE_AAA;
pub const EOAC_NO_CUSTOM_MARSHAL = EOLE_AUTHENTICATION_CAPABILITIES.NO_CUSTOM_MARSHAL;
pub const EOAC_RESERVED1 = EOLE_AUTHENTICATION_CAPABILITIES.RESERVED1;

pub const SOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pAuthInfo: ?*anyopaque,
};

pub const SOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: u32,
    aAuthInfo: ?*SOLE_AUTHENTICATION_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClientSecurity_Value = Guid.initString("0000013d-0000-0000-c000-000000000046");
pub const IID_IClientSecurity = &IID_IClientSecurity_Value;
pub const IClientSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: *const fn (
            self: *const IClientSecurity,
            p_proxy: ?*IUnknown,
            p_authn_svc: ?*u32,
            p_authz_svc: ?*u32,
            p_server_princ_name: ?*?*u16,
            p_authn_level: ?*RPC_C_AUTHN_LEVEL,
            p_imp_level: ?*RPC_C_IMP_LEVEL,
            p_auth_info: ?*?*anyopaque,
            p_capabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlanket: *const fn (
            self: *const IClientSecurity,
            p_proxy: ?*IUnknown,
            dw_authn_svc: u32,
            dw_authz_svc: u32,
            p_server_princ_name: ?PWSTR,
            dw_authn_level: RPC_C_AUTHN_LEVEL,
            dw_imp_level: RPC_C_IMP_LEVEL,
            p_auth_info: ?*anyopaque,
            dw_capabilities: EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProxy: *const fn (
            self: *const IClientSecurity,
            p_proxy: ?*IUnknown,
            pp_copy: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryBlanket(self: *const T, p_proxy_: ?*IUnknown, p_authn_svc_: ?*u32, p_authz_svc_: ?*u32, p_server_princ_name_: ?*?*u16, p_authn_level_: ?*RPC_C_AUTHN_LEVEL, p_imp_level_: ?*RPC_C_IMP_LEVEL, p_auth_info_: ?*?*anyopaque, p_capabilites_: ?*EOLE_AUTHENTICATION_CAPABILITIES) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).QueryBlanket(@as(*const IClientSecurity, @ptrCast(self)), p_proxy_, p_authn_svc_, p_authz_svc_, p_server_princ_name_, p_authn_level_, p_imp_level_, p_auth_info_, p_capabilites_);
            }
            pub inline fn setBlanket(self: *const T, p_proxy_: ?*IUnknown, dw_authn_svc_: u32, dw_authz_svc_: u32, p_server_princ_name_: ?PWSTR, dw_authn_level_: RPC_C_AUTHN_LEVEL, dw_imp_level_: RPC_C_IMP_LEVEL, p_auth_info_: ?*anyopaque, dw_capabilities_: EOLE_AUTHENTICATION_CAPABILITIES) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).SetBlanket(@as(*const IClientSecurity, @ptrCast(self)), p_proxy_, dw_authn_svc_, dw_authz_svc_, p_server_princ_name_, dw_authn_level_, dw_imp_level_, p_auth_info_, dw_capabilities_);
            }
            pub inline fn copyProxy(self: *const T, p_proxy_: ?*IUnknown, pp_copy_: ?*?*IUnknown) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).CopyProxy(@as(*const IClientSecurity, @ptrCast(self)), p_proxy_, pp_copy_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IServerSecurity_Value = Guid.initString("0000013e-0000-0000-c000-000000000046");
pub const IID_IServerSecurity = &IID_IServerSecurity_Value;
pub const IServerSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: *const fn (
            self: *const IServerSecurity,
            p_authn_svc: ?*u32,
            p_authz_svc: ?*u32,
            p_server_princ_name: ?*?*u16,
            p_authn_level: ?*u32,
            p_imp_level: ?*u32,
            p_privs: ?*?*anyopaque,
            p_capabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImpersonateClient: *const fn (
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToSelf: *const fn (
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsImpersonating: *const fn (
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryBlanket(self: *const T, p_authn_svc_: ?*u32, p_authz_svc_: ?*u32, p_server_princ_name_: ?*?*u16, p_authn_level_: ?*u32, p_imp_level_: ?*u32, p_privs_: ?*?*anyopaque, p_capabilities_: ?*u32) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).QueryBlanket(@as(*const IServerSecurity, @ptrCast(self)), p_authn_svc_, p_authz_svc_, p_server_princ_name_, p_authn_level_, p_imp_level_, p_privs_, p_capabilities_);
            }
            pub inline fn impersonateClient(self: *const T) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).ImpersonateClient(@as(*const IServerSecurity, @ptrCast(self)));
            }
            pub inline fn revertToSelf(self: *const T) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).RevertToSelf(@as(*const IServerSecurity, @ptrCast(self)));
            }
            pub inline fn isImpersonating(self: *const T) BOOL {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).IsImpersonating(@as(*const IServerSecurity, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOPT_PROPERTIES = enum(i32) {
    RPCTIMEOUT = 1,
    SERVER_LOCALITY = 2,
    RESERVED1 = 4,
    RESERVED2 = 5,
    RESERVED3 = 8,
    RESERVED4 = 16,
};
pub const COMBND_RPCTIMEOUT = RPCOPT_PROPERTIES.RPCTIMEOUT;
pub const COMBND_SERVER_LOCALITY = RPCOPT_PROPERTIES.SERVER_LOCALITY;
pub const COMBND_RESERVED1 = RPCOPT_PROPERTIES.RESERVED1;
pub const COMBND_RESERVED2 = RPCOPT_PROPERTIES.RESERVED2;
pub const COMBND_RESERVED3 = RPCOPT_PROPERTIES.RESERVED3;
pub const COMBND_RESERVED4 = RPCOPT_PROPERTIES.RESERVED4;

pub const RPCOPT_SERVER_LOCALITY_VALUES = enum(i32) {
    PROCESS_LOCAL = 0,
    MACHINE_LOCAL = 1,
    REMOTE = 2,
};
pub const SERVER_LOCALITY_PROCESS_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.PROCESS_LOCAL;
pub const SERVER_LOCALITY_MACHINE_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.MACHINE_LOCAL;
pub const SERVER_LOCALITY_REMOTE = RPCOPT_SERVER_LOCALITY_VALUES.REMOTE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcOptions_Value = Guid.initString("00000144-0000-0000-c000-000000000046");
pub const IID_IRpcOptions = &IID_IRpcOptions_Value;
pub const IRpcOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: *const fn (
            self: *const IRpcOptions,
            p_prx: ?*IUnknown,
            dw_property: RPCOPT_PROPERTIES,
            dw_value: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: *const fn (
            self: *const IRpcOptions,
            p_prx: ?*IUnknown,
            dw_property: RPCOPT_PROPERTIES,
            pdw_value: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn set(self: *const T, p_prx_: ?*IUnknown, dw_property_: RPCOPT_PROPERTIES, dw_value_: usize) HRESULT {
                return @as(*const IRpcOptions.VTable, @ptrCast(self.vtable)).Set(@as(*const IRpcOptions, @ptrCast(self)), p_prx_, dw_property_, dw_value_);
            }
            pub inline fn query(self: *const T, p_prx_: ?*IUnknown, dw_property_: RPCOPT_PROPERTIES, pdw_value_: ?*usize) HRESULT {
                return @as(*const IRpcOptions.VTable, @ptrCast(self.vtable)).Query(@as(*const IRpcOptions, @ptrCast(self)), p_prx_, dw_property_, pdw_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const GLOBALOPT_PROPERTIES = enum(i32) {
    EXCEPTION_HANDLING = 1,
    APPID = 2,
    RPC_THREADPOOL_SETTING = 3,
    RO_SETTINGS = 4,
    UNMARSHALING_POLICY = 5,
    PROPERTIES_RESERVED1 = 6,
    PROPERTIES_RESERVED2 = 7,
    PROPERTIES_RESERVED3 = 8,
};
pub const COMGLB_EXCEPTION_HANDLING = GLOBALOPT_PROPERTIES.EXCEPTION_HANDLING;
pub const COMGLB_APPID = GLOBALOPT_PROPERTIES.APPID;
pub const COMGLB_RPC_THREADPOOL_SETTING = GLOBALOPT_PROPERTIES.RPC_THREADPOOL_SETTING;
pub const COMGLB_RO_SETTINGS = GLOBALOPT_PROPERTIES.RO_SETTINGS;
pub const COMGLB_UNMARSHALING_POLICY = GLOBALOPT_PROPERTIES.UNMARSHALING_POLICY;
pub const COMGLB_PROPERTIES_RESERVED1 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED1;
pub const COMGLB_PROPERTIES_RESERVED2 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED2;
pub const COMGLB_PROPERTIES_RESERVED3 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED3;

pub const GLOBALOPT_EH_VALUES = enum(i32) {
    HANDLE = 0,
    DONOT_HANDLE_FATAL = 1,
    // DONOT_HANDLE = 1, this enum value conflicts with DONOT_HANDLE_FATAL
    DONOT_HANDLE_ANY = 2,
};
pub const COMGLB_EXCEPTION_HANDLE = GLOBALOPT_EH_VALUES.HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_ANY = GLOBALOPT_EH_VALUES.DONOT_HANDLE_ANY;

pub const GLOBALOPT_RPCTP_VALUES = enum(i32) {
    DEFAULT_POOL = 0,
    PRIVATE_POOL = 1,
};
pub const COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = GLOBALOPT_RPCTP_VALUES.DEFAULT_POOL;
pub const COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = GLOBALOPT_RPCTP_VALUES.PRIVATE_POOL;

pub const GLOBALOPT_RO_FLAGS = enum(i32) {
    STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    FAST_RUNDOWN = 8,
    RESERVED1 = 16,
    RESERVED2 = 32,
    RESERVED3 = 64,
    STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    RESERVED4 = 256,
    RESERVED5 = 512,
    RESERVED6 = 1024,
};
pub const COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_REMOVE_TOUCH_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES;
pub const COMGLB_FAST_RUNDOWN = GLOBALOPT_RO_FLAGS.FAST_RUNDOWN;
pub const COMGLB_RESERVED1 = GLOBALOPT_RO_FLAGS.RESERVED1;
pub const COMGLB_RESERVED2 = GLOBALOPT_RO_FLAGS.RESERVED2;
pub const COMGLB_RESERVED3 = GLOBALOPT_RO_FLAGS.RESERVED3;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES;
pub const COMGLB_RESERVED4 = GLOBALOPT_RO_FLAGS.RESERVED4;
pub const COMGLB_RESERVED5 = GLOBALOPT_RO_FLAGS.RESERVED5;
pub const COMGLB_RESERVED6 = GLOBALOPT_RO_FLAGS.RESERVED6;

pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = enum(i32) {
    NORMAL = 0,
    STRONG = 1,
    HYBRID = 2,
};
pub const COMGLB_UNMARSHALING_POLICY_NORMAL = GLOBALOPT_UNMARSHALING_POLICY_VALUES.NORMAL;
pub const COMGLB_UNMARSHALING_POLICY_STRONG = GLOBALOPT_UNMARSHALING_POLICY_VALUES.STRONG;
pub const COMGLB_UNMARSHALING_POLICY_HYBRID = GLOBALOPT_UNMARSHALING_POLICY_VALUES.HYBRID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IGlobalOptions_Value = Guid.initString("0000015b-0000-0000-c000-000000000046");
pub const IID_IGlobalOptions = &IID_IGlobalOptions_Value;
pub const IGlobalOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: *const fn (
            self: *const IGlobalOptions,
            dw_property: GLOBALOPT_PROPERTIES,
            dw_value: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: *const fn (
            self: *const IGlobalOptions,
            dw_property: GLOBALOPT_PROPERTIES,
            pdw_value: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn set(self: *const T, dw_property_: GLOBALOPT_PROPERTIES, dw_value_: usize) HRESULT {
                return @as(*const IGlobalOptions.VTable, @ptrCast(self.vtable)).Set(@as(*const IGlobalOptions, @ptrCast(self)), dw_property_, dw_value_);
            }
            pub inline fn query(self: *const T, dw_property_: GLOBALOPT_PROPERTIES, pdw_value_: ?*usize) HRESULT {
                return @as(*const IGlobalOptions.VTable, @ptrCast(self.vtable)).Query(@as(*const IGlobalOptions, @ptrCast(self)), dw_property_, pdw_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogate_Value = Guid.initString("00000022-0000-0000-c000-000000000046");
pub const IID_ISurrogate = &IID_ISurrogate_Value;
pub const ISurrogate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadDllServer: *const fn (
            self: *const ISurrogate,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeSurrogate: *const fn (
            self: *const ISurrogate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn loadDllServer(self: *const T, clsid_: ?*const Guid) HRESULT {
                return @as(*const ISurrogate.VTable, @ptrCast(self.vtable)).LoadDllServer(@as(*const ISurrogate, @ptrCast(self)), clsid_);
            }
            pub inline fn freeSurrogate(self: *const T) HRESULT {
                return @as(*const ISurrogate.VTable, @ptrCast(self.vtable)).FreeSurrogate(@as(*const ISurrogate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGlobalInterfaceTable_Value = Guid.initString("00000146-0000-0000-c000-000000000046");
pub const IID_IGlobalInterfaceTable = &IID_IGlobalInterfaceTable_Value;
pub const IGlobalInterfaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterInterfaceInGlobal: *const fn (
            self: *const IGlobalInterfaceTable,
            p_unk: ?*IUnknown,
            riid: ?*const Guid,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeInterfaceFromGlobal: *const fn (
            self: *const IGlobalInterfaceTable,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterfaceFromGlobal: *const fn (
            self: *const IGlobalInterfaceTable,
            dw_cookie: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerInterfaceInGlobal(self: *const T, p_unk_: ?*IUnknown, riid_: ?*const Guid, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).RegisterInterfaceInGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), p_unk_, riid_, pdw_cookie_);
            }
            pub inline fn revokeInterfaceFromGlobal(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).RevokeInterfaceFromGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn getInterfaceFromGlobal(self: *const T, dw_cookie_: u32, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).GetInterfaceFromGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), dw_cookie_, riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronize_Value = Guid.initString("00000030-0000-0000-c000-000000000046");
pub const IID_ISynchronize = &IID_ISynchronize_Value;
pub const ISynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: *const fn (
            self: *const ISynchronize,
            dw_flags: u32,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Signal: *const fn (
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn wait(self: *const T, dw_flags_: u32, dw_milliseconds_: u32) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Wait(@as(*const ISynchronize, @ptrCast(self)), dw_flags_, dw_milliseconds_);
            }
            pub inline fn signal(self: *const T) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Signal(@as(*const ISynchronize, @ptrCast(self)));
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISynchronize, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeHandle_Value = Guid.initString("00000031-0000-0000-c000-000000000046");
pub const IID_ISynchronizeHandle = &IID_ISynchronizeHandle_Value;
pub const ISynchronizeHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandle: *const fn (
            self: *const ISynchronizeHandle,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getHandle(self: *const T, ph_: ?*?HANDLE) HRESULT {
                return @as(*const ISynchronizeHandle.VTable, @ptrCast(self.vtable)).GetHandle(@as(*const ISynchronizeHandle, @ptrCast(self)), ph_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeEvent_Value = Guid.initString("00000032-0000-0000-c000-000000000046");
pub const IID_ISynchronizeEvent = &IID_ISynchronizeEvent_Value;
pub const ISynchronizeEvent = extern struct {
    pub const VTable = extern struct {
        base: ISynchronizeHandle.VTable,
        SetEventHandle: *const fn (
            self: *const ISynchronizeEvent,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISynchronizeHandle.MethodMixin(T);
            pub inline fn setEventHandle(self: *const T, ph_: ?*?HANDLE) HRESULT {
                return @as(*const ISynchronizeEvent.VTable, @ptrCast(self.vtable)).SetEventHandle(@as(*const ISynchronizeEvent, @ptrCast(self)), ph_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeContainer_Value = Guid.initString("00000033-0000-0000-c000-000000000046");
pub const IID_ISynchronizeContainer = &IID_ISynchronizeContainer_Value;
pub const ISynchronizeContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSynchronize: *const fn (
            self: *const ISynchronizeContainer,
            p_sync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitMultiple: *const fn (
            self: *const ISynchronizeContainer,
            dw_flags: u32,
            dw_time_out: u32,
            pp_sync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addSynchronize(self: *const T, p_sync_: ?*ISynchronize) HRESULT {
                return @as(*const ISynchronizeContainer.VTable, @ptrCast(self.vtable)).AddSynchronize(@as(*const ISynchronizeContainer, @ptrCast(self)), p_sync_);
            }
            pub inline fn waitMultiple(self: *const T, dw_flags_: u32, dw_time_out_: u32, pp_sync_: ?*?*ISynchronize) HRESULT {
                return @as(*const ISynchronizeContainer.VTable, @ptrCast(self.vtable)).WaitMultiple(@as(*const ISynchronizeContainer, @ptrCast(self)), dw_flags_, dw_time_out_, pp_sync_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISynchronizeMutex_Value = Guid.initString("00000025-0000-0000-c000-000000000046");
pub const IID_ISynchronizeMutex = &IID_ISynchronizeMutex_Value;
pub const ISynchronizeMutex = extern struct {
    pub const VTable = extern struct {
        base: ISynchronize.VTable,
        ReleaseMutex: *const fn (
            self: *const ISynchronizeMutex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISynchronize.MethodMixin(T);
            pub inline fn releaseMutex(self: *const T) HRESULT {
                return @as(*const ISynchronizeMutex.VTable, @ptrCast(self.vtable)).ReleaseMutex(@as(*const ISynchronizeMutex, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICancelMethodCalls_Value = Guid.initString("00000029-0000-0000-c000-000000000046");
pub const IID_ICancelMethodCalls = &IID_ICancelMethodCalls_Value;
pub const ICancelMethodCalls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: *const fn (
            self: *const ICancelMethodCalls,
            ul_seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestCancel: *const fn (
            self: *const ICancelMethodCalls,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn cancel(self: *const T, ul_seconds_: u32) HRESULT {
                return @as(*const ICancelMethodCalls.VTable, @ptrCast(self.vtable)).Cancel(@as(*const ICancelMethodCalls, @ptrCast(self)), ul_seconds_);
            }
            pub inline fn testCancel(self: *const T) HRESULT {
                return @as(*const ICancelMethodCalls.VTable, @ptrCast(self.vtable)).TestCancel(@as(*const ICancelMethodCalls, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DCOM_CALL_STATE = enum(i32) {
    NONE = 0,
    CALL_COMPLETE = 1,
    CALL_CANCELED = 2,
};
pub const DCOM_NONE = DCOM_CALL_STATE.NONE;
pub const DCOM_CALL_COMPLETE = DCOM_CALL_STATE.CALL_COMPLETE;
pub const DCOM_CALL_CANCELED = DCOM_CALL_STATE.CALL_CANCELED;

const IID_IAsyncManager_Value = Guid.initString("0000002a-0000-0000-c000-000000000046");
pub const IID_IAsyncManager = &IID_IAsyncManager_Value;
pub const IAsyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteCall: *const fn (
            self: *const IAsyncManager,
            result: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: *const fn (
            self: *const IAsyncManager,
            riid: ?*const Guid,
            p_interface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IAsyncManager,
            pul_state_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn completeCall(self: *const T, result_: HRESULT) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).CompleteCall(@as(*const IAsyncManager, @ptrCast(self)), result_);
            }
            pub inline fn getCallContext(self: *const T, riid_: ?*const Guid, p_interface_: ?*?*anyopaque) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).GetCallContext(@as(*const IAsyncManager, @ptrCast(self)), riid_, p_interface_);
            }
            pub inline fn getState(self: *const T, pul_state_flags_: ?*u32) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAsyncManager, @ptrCast(self)), pul_state_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFactory_Value = Guid.initString("1c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICallFactory = &IID_ICallFactory_Value;
pub const ICallFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCall: *const fn (
            self: *const ICallFactory,
            riid: ?*const Guid,
            p_ctrl_unk: ?*IUnknown,
            riid2: ?*const Guid,
            ppv: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createCall(self: *const T, riid_: ?*const Guid, p_ctrl_unk_: ?*IUnknown, riid2_: ?*const Guid, ppv_: ?*?*IUnknown) HRESULT {
                return @as(*const ICallFactory.VTable, @ptrCast(self.vtable)).CreateCall(@as(*const ICallFactory, @ptrCast(self)), riid_, p_ctrl_unk_, riid2_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcHelper_Value = Guid.initString("00000149-0000-0000-c000-000000000046");
pub const IID_IRpcHelper = &IID_IRpcHelper_Value;
pub const IRpcHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDCOMProtocolVersion: *const fn (
            self: *const IRpcHelper,
            p_com_version: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDFromOBJREF: *const fn (
            self: *const IRpcHelper,
            p_obj_ref: ?*anyopaque,
            piid: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDCOMProtocolVersion(self: *const T, p_com_version_: ?*u32) HRESULT {
                return @as(*const IRpcHelper.VTable, @ptrCast(self.vtable)).GetDCOMProtocolVersion(@as(*const IRpcHelper, @ptrCast(self)), p_com_version_);
            }
            pub inline fn getIIDFromOBJREF(self: *const T, p_obj_ref_: ?*anyopaque, piid_: ?*?*Guid) HRESULT {
                return @as(*const IRpcHelper.VTable, @ptrCast(self.vtable)).GetIIDFromOBJREF(@as(*const IRpcHelper, @ptrCast(self)), p_obj_ref_, piid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IReleaseMarshalBuffers_Value = Guid.initString("eb0cb9e8-7996-11d2-872e-0000f8080859");
pub const IID_IReleaseMarshalBuffers = &IID_IReleaseMarshalBuffers_Value;
pub const IReleaseMarshalBuffers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReleaseMarshalBuffer: *const fn (
            self: *const IReleaseMarshalBuffers,
            p_msg: ?*RPCOLEMESSAGE,
            dw_flags: u32,
            p_chnl: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn releaseMarshalBuffer(self: *const T, p_msg_: ?*RPCOLEMESSAGE, dw_flags_: u32, p_chnl_: ?*IUnknown) HRESULT {
                return @as(*const IReleaseMarshalBuffers.VTable, @ptrCast(self.vtable)).ReleaseMarshalBuffer(@as(*const IReleaseMarshalBuffers, @ptrCast(self)), p_msg_, dw_flags_, p_chnl_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWaitMultiple_Value = Guid.initString("0000002b-0000-0000-c000-000000000046");
pub const IID_IWaitMultiple = &IID_IWaitMultiple_Value;
pub const IWaitMultiple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitMultiple: *const fn (
            self: *const IWaitMultiple,
            timeout: u32,
            p_sync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSynchronize: *const fn (
            self: *const IWaitMultiple,
            p_sync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn waitMultiple(self: *const T, timeout_: u32, p_sync_: ?*?*ISynchronize) HRESULT {
                return @as(*const IWaitMultiple.VTable, @ptrCast(self.vtable)).WaitMultiple(@as(*const IWaitMultiple, @ptrCast(self)), timeout_, p_sync_);
            }
            pub inline fn addSynchronize(self: *const T, p_sync_: ?*ISynchronize) HRESULT {
                return @as(*const IWaitMultiple.VTable, @ptrCast(self.vtable)).AddSynchronize(@as(*const IWaitMultiple, @ptrCast(self)), p_sync_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrTrackingControl_Value = Guid.initString("00000147-0000-0000-c000-000000000046");
pub const IID_IAddrTrackingControl = &IID_IAddrTrackingControl_Value;
pub const IAddrTrackingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableCOMDynamicAddrTracking: *const fn (
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableCOMDynamicAddrTracking: *const fn (
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enableCOMDynamicAddrTracking(self: *const T) HRESULT {
                return @as(*const IAddrTrackingControl.VTable, @ptrCast(self.vtable)).EnableCOMDynamicAddrTracking(@as(*const IAddrTrackingControl, @ptrCast(self)));
            }
            pub inline fn disableCOMDynamicAddrTracking(self: *const T) HRESULT {
                return @as(*const IAddrTrackingControl.VTable, @ptrCast(self.vtable)).DisableCOMDynamicAddrTracking(@as(*const IAddrTrackingControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrExclusionControl_Value = Guid.initString("00000148-0000-0000-c000-000000000046");
pub const IID_IAddrExclusionControl = &IID_IAddrExclusionControl_Value;
pub const IAddrExclusionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentAddrExclusionList: *const fn (
            self: *const IAddrExclusionControl,
            riid: ?*const Guid,
            pp_enumerator: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAddrExclusionList: *const fn (
            self: *const IAddrExclusionControl,
            p_enumerator: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrentAddrExclusionList(self: *const T, riid_: ?*const Guid, pp_enumerator_: ?*?*anyopaque) HRESULT {
                return @as(*const IAddrExclusionControl.VTable, @ptrCast(self.vtable)).GetCurrentAddrExclusionList(@as(*const IAddrExclusionControl, @ptrCast(self)), riid_, pp_enumerator_);
            }
            pub inline fn updateAddrExclusionList(self: *const T, p_enumerator_: ?*IUnknown) HRESULT {
                return @as(*const IAddrExclusionControl.VTable, @ptrCast(self.vtable)).UpdateAddrExclusionList(@as(*const IAddrExclusionControl, @ptrCast(self)), p_enumerator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeByte_Value = Guid.initString("db2f3aca-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeByte = &IID_IPipeByte_Value;
pub const IPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: *const fn (
            self: *const IPipeByte,
            buf: [*:0]u8,
            c_request: u32,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: *const fn (
            self: *const IPipeByte,
            buf: [*:0]u8,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn pull(self: *const T, buf_: [*:0]u8, c_request_: u32, pc_returned_: ?*u32) HRESULT {
                return @as(*const IPipeByte.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeByte, @ptrCast(self)), buf_, c_request_, pc_returned_);
            }
            pub inline fn push(self: *const T, buf_: [*:0]u8, c_sent_: u32) HRESULT {
                return @as(*const IPipeByte.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeByte, @ptrCast(self)), buf_, c_sent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeByte_Value = Guid.initString("db2f3acb-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeByte = &IID_AsyncIPipeByte_Value;
pub const AsyncIPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: *const fn (
            self: *const AsyncIPipeByte,
            c_request: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: *const fn (
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: *const fn (
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: *const fn (
            self: *const AsyncIPipeByte,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginPull(self: *const T, c_request_: u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeByte, @ptrCast(self)), c_request_);
            }
            pub inline fn finishPull(self: *const T, buf_: [*:0]u8, pc_returned_: ?*u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeByte, @ptrCast(self)), buf_, pc_returned_);
            }
            pub inline fn beginPush(self: *const T, buf_: [*:0]u8, c_sent_: u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeByte, @ptrCast(self)), buf_, c_sent_);
            }
            pub inline fn finishPush(self: *const T) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeByte, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeLong_Value = Guid.initString("db2f3acc-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeLong = &IID_IPipeLong_Value;
pub const IPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: *const fn (
            self: *const IPipeLong,
            buf: [*]i32,
            c_request: u32,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: *const fn (
            self: *const IPipeLong,
            buf: [*]i32,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn pull(self: *const T, buf_: [*]i32, c_request_: u32, pc_returned_: ?*u32) HRESULT {
                return @as(*const IPipeLong.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeLong, @ptrCast(self)), buf_, c_request_, pc_returned_);
            }
            pub inline fn push(self: *const T, buf_: [*]i32, c_sent_: u32) HRESULT {
                return @as(*const IPipeLong.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeLong, @ptrCast(self)), buf_, c_sent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeLong_Value = Guid.initString("db2f3acd-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeLong = &IID_AsyncIPipeLong_Value;
pub const AsyncIPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: *const fn (
            self: *const AsyncIPipeLong,
            c_request: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: *const fn (
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: *const fn (
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: *const fn (
            self: *const AsyncIPipeLong,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginPull(self: *const T, c_request_: u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeLong, @ptrCast(self)), c_request_);
            }
            pub inline fn finishPull(self: *const T, buf_: [*]i32, pc_returned_: ?*u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeLong, @ptrCast(self)), buf_, pc_returned_);
            }
            pub inline fn beginPush(self: *const T, buf_: [*]i32, c_sent_: u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeLong, @ptrCast(self)), buf_, c_sent_);
            }
            pub inline fn finishPush(self: *const T) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeLong, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeDouble_Value = Guid.initString("db2f3ace-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeDouble = &IID_IPipeDouble_Value;
pub const IPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: *const fn (
            self: *const IPipeDouble,
            buf: [*]f64,
            c_request: u32,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: *const fn (
            self: *const IPipeDouble,
            buf: [*]f64,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn pull(self: *const T, buf_: [*]f64, c_request_: u32, pc_returned_: ?*u32) HRESULT {
                return @as(*const IPipeDouble.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeDouble, @ptrCast(self)), buf_, c_request_, pc_returned_);
            }
            pub inline fn push(self: *const T, buf_: [*]f64, c_sent_: u32) HRESULT {
                return @as(*const IPipeDouble.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeDouble, @ptrCast(self)), buf_, c_sent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeDouble_Value = Guid.initString("db2f3acf-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeDouble = &IID_AsyncIPipeDouble_Value;
pub const AsyncIPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: *const fn (
            self: *const AsyncIPipeDouble,
            c_request: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: *const fn (
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            pc_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: *const fn (
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            c_sent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: *const fn (
            self: *const AsyncIPipeDouble,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginPull(self: *const T, c_request_: u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeDouble, @ptrCast(self)), c_request_);
            }
            pub inline fn finishPull(self: *const T, buf_: [*]f64, pc_returned_: ?*u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeDouble, @ptrCast(self)), buf_, pc_returned_);
            }
            pub inline fn beginPush(self: *const T, buf_: [*]f64, c_sent_: u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeDouble, @ptrCast(self)), buf_, c_sent_);
            }
            pub inline fn finishPush(self: *const T) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeDouble, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APTTYPEQUALIFIER = enum(i32) {
    NONE = 0,
    IMPLICIT_MTA = 1,
    NA_ON_MTA = 2,
    NA_ON_STA = 3,
    NA_ON_IMPLICIT_MTA = 4,
    NA_ON_MAINSTA = 5,
    APPLICATION_STA = 6,
    RESERVED_1 = 7,
};
pub const APTTYPEQUALIFIER_NONE = APTTYPEQUALIFIER.NONE;
pub const APTTYPEQUALIFIER_IMPLICIT_MTA = APTTYPEQUALIFIER.IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MTA = APTTYPEQUALIFIER.NA_ON_MTA;
pub const APTTYPEQUALIFIER_NA_ON_STA = APTTYPEQUALIFIER.NA_ON_STA;
pub const APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = APTTYPEQUALIFIER.NA_ON_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MAINSTA = APTTYPEQUALIFIER.NA_ON_MAINSTA;
pub const APTTYPEQUALIFIER_APPLICATION_STA = APTTYPEQUALIFIER.APPLICATION_STA;
pub const APTTYPEQUALIFIER_RESERVED_1 = APTTYPEQUALIFIER.RESERVED_1;

pub const APTTYPE = enum(i32) {
    CURRENT = -1,
    STA = 0,
    MTA = 1,
    NA = 2,
    MAINSTA = 3,
};
pub const APTTYPE_CURRENT = APTTYPE.CURRENT;
pub const APTTYPE_STA = APTTYPE.STA;
pub const APTTYPE_MTA = APTTYPE.MTA;
pub const APTTYPE_NA = APTTYPE.NA;
pub const APTTYPE_MAINSTA = APTTYPE.MAINSTA;

pub const THDTYPE = enum(i32) {
    BLOCKMESSAGES = 0,
    PROCESSMESSAGES = 1,
};
pub const THDTYPE_BLOCKMESSAGES = THDTYPE.BLOCKMESSAGES;
pub const THDTYPE_PROCESSMESSAGES = THDTYPE.PROCESSMESSAGES;

// TODO: this type is limited to platform 'windows5.0'
const IID_IComThreadingInfo_Value = Guid.initString("000001ce-0000-0000-c000-000000000046");
pub const IID_IComThreadingInfo = &IID_IComThreadingInfo_Value;
pub const IComThreadingInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentApartmentType: *const fn (
            self: *const IComThreadingInfo,
            p_apt_type: ?*APTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadType: *const fn (
            self: *const IComThreadingInfo,
            p_thread_type: ?*THDTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLogicalThreadId: *const fn (
            self: *const IComThreadingInfo,
            pguid_logical_thread_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentLogicalThreadId: *const fn (
            self: *const IComThreadingInfo,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrentApartmentType(self: *const T, p_apt_type_: ?*APTTYPE) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentApartmentType(@as(*const IComThreadingInfo, @ptrCast(self)), p_apt_type_);
            }
            pub inline fn getCurrentThreadType(self: *const T, p_thread_type_: ?*THDTYPE) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentThreadType(@as(*const IComThreadingInfo, @ptrCast(self)), p_thread_type_);
            }
            pub inline fn getCurrentLogicalThreadId(self: *const T, pguid_logical_thread_id_: ?*Guid) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentLogicalThreadId(@as(*const IComThreadingInfo, @ptrCast(self)), pguid_logical_thread_id_);
            }
            pub inline fn setCurrentLogicalThreadId(self: *const T, rguid_: ?*const Guid) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).SetCurrentLogicalThreadId(@as(*const IComThreadingInfo, @ptrCast(self)), rguid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessInitControl_Value = Guid.initString("72380d55-8d2b-43a3-8513-2b6ef31434e9");
pub const IID_IProcessInitControl = &IID_IProcessInitControl_Value;
pub const IProcessInitControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetInitializerTimeout: *const fn (
            self: *const IProcessInitControl,
            dw_seconds_remaining: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn resetInitializerTimeout(self: *const T, dw_seconds_remaining_: u32) HRESULT {
                return @as(*const IProcessInitControl.VTable, @ptrCast(self.vtable)).ResetInitializerTimeout(@as(*const IProcessInitControl, @ptrCast(self)), dw_seconds_remaining_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFastRundown_Value = Guid.initString("00000040-0000-0000-c000-000000000046");
pub const IID_IFastRundown = &IID_IFastRundown_Value;
pub const IFastRundown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = enum(i32) {
    SOURCE_IS_APP_CONTAINER = 0,
    CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
    CONTEXT_ATTRIBUTE_RESERVED_18 = -2147483631,
};
pub const CO_MARSHALING_SOURCE_IS_APP_CONTAINER = CO_MARSHALING_CONTEXT_ATTRIBUTES.SOURCE_IS_APP_CONTAINER;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_1;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_2;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_3;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_4;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_5;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_6;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_7;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_8;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_9;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_10;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_11;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_12;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_13;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_14;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_15;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_16;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_17;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_18;

pub const MachineGlobalObjectTableRegistrationToken__ = extern struct {
    unused: i32,
};

const IID_IMachineGlobalObjectTable_Value = Guid.initString("26d709ac-f70b-4421-a96f-d2878fafb00d");
pub const IID_IMachineGlobalObjectTable = &IID_IMachineGlobalObjectTable_Value;
pub const IMachineGlobalObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObject: *const fn (
            self: *const IMachineGlobalObjectTable,
            clsid: ?*const Guid,
            identifier: ?[*:0]const u16,
            object: ?*IUnknown,
            token: ?*?*MachineGlobalObjectTableRegistrationToken__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: *const fn (
            self: *const IMachineGlobalObjectTable,
            clsid: ?*const Guid,
            identifier: ?[*:0]const u16,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObject: *const fn (
            self: *const IMachineGlobalObjectTable,
            token: ?*MachineGlobalObjectTableRegistrationToken__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerObject(self: *const T, clsid_: ?*const Guid, identifier_: ?[*:0]const u16, object_: ?*IUnknown, token_: ?*?*MachineGlobalObjectTableRegistrationToken__) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).RegisterObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), clsid_, identifier_, object_, token_);
            }
            pub inline fn getObject(self: *const T, clsid_: ?*const Guid, identifier_: ?[*:0]const u16, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), clsid_, identifier_, riid_, ppv_);
            }
            pub inline fn revokeObject(self: *const T, token_: ?*MachineGlobalObjectTableRegistrationToken__) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).RevokeObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), token_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMallocSpy_Value = Guid.initString("0000001d-0000-0000-c000-000000000046");
pub const IID_IMallocSpy = &IID_IMallocSpy_Value;
pub const IMallocSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreAlloc: *const fn (
            self: *const IMallocSpy,
            cb_request: usize,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostAlloc: *const fn (
            self: *const IMallocSpy,
            p_actual: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PreFree: *const fn (
            self: *const IMallocSpy,
            p_request: ?*anyopaque,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostFree: *const fn (
            self: *const IMallocSpy,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PreRealloc: *const fn (
            self: *const IMallocSpy,
            p_request: ?*anyopaque,
            cb_request: usize,
            pp_new_request: ?*?*anyopaque,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostRealloc: *const fn (
            self: *const IMallocSpy,
            p_actual: ?*anyopaque,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PreGetSize: *const fn (
            self: *const IMallocSpy,
            p_request: ?*anyopaque,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostGetSize: *const fn (
            self: *const IMallocSpy,
            cb_actual: usize,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PreDidAlloc: *const fn (
            self: *const IMallocSpy,
            p_request: ?*anyopaque,
            f_spyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostDidAlloc: *const fn (
            self: *const IMallocSpy,
            p_request: ?*anyopaque,
            f_spyed: BOOL,
            f_actual: i32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        PreHeapMinimize: *const fn (
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PostHeapMinimize: *const fn (
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn preAlloc(self: *const T, cb_request_: usize) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreAlloc(@as(*const IMallocSpy, @ptrCast(self)), cb_request_);
            }
            pub inline fn postAlloc(self: *const T, p_actual_: ?*anyopaque) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostAlloc(@as(*const IMallocSpy, @ptrCast(self)), p_actual_);
            }
            pub inline fn preFree(self: *const T, p_request_: ?*anyopaque, f_spyed_: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreFree(@as(*const IMallocSpy, @ptrCast(self)), p_request_, f_spyed_);
            }
            pub inline fn postFree(self: *const T, f_spyed_: BOOL) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostFree(@as(*const IMallocSpy, @ptrCast(self)), f_spyed_);
            }
            pub inline fn preRealloc(self: *const T, p_request_: ?*anyopaque, cb_request_: usize, pp_new_request_: ?*?*anyopaque, f_spyed_: BOOL) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreRealloc(@as(*const IMallocSpy, @ptrCast(self)), p_request_, cb_request_, pp_new_request_, f_spyed_);
            }
            pub inline fn postRealloc(self: *const T, p_actual_: ?*anyopaque, f_spyed_: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostRealloc(@as(*const IMallocSpy, @ptrCast(self)), p_actual_, f_spyed_);
            }
            pub inline fn preGetSize(self: *const T, p_request_: ?*anyopaque, f_spyed_: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreGetSize(@as(*const IMallocSpy, @ptrCast(self)), p_request_, f_spyed_);
            }
            pub inline fn postGetSize(self: *const T, cb_actual_: usize, f_spyed_: BOOL) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostGetSize(@as(*const IMallocSpy, @ptrCast(self)), cb_actual_, f_spyed_);
            }
            pub inline fn preDidAlloc(self: *const T, p_request_: ?*anyopaque, f_spyed_: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreDidAlloc(@as(*const IMallocSpy, @ptrCast(self)), p_request_, f_spyed_);
            }
            pub inline fn postDidAlloc(self: *const T, p_request_: ?*anyopaque, f_spyed_: BOOL, f_actual_: i32) i32 {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostDidAlloc(@as(*const IMallocSpy, @ptrCast(self)), p_request_, f_spyed_, f_actual_);
            }
            pub inline fn preHeapMinimize(self: *const T) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreHeapMinimize(@as(*const IMallocSpy, @ptrCast(self)));
            }
            pub inline fn postHeapMinimize(self: *const T) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostHeapMinimize(@as(*const IMallocSpy, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BIND_OPTS = extern struct {
    cbStruct: u32,
    grfFlags: u32,
    grfMode: u32,
    dwTickCountDeadline: u32,
};

pub const BIND_OPTS2 = extern struct {
    __AnonymousBase_objidl_L9017_C36: BIND_OPTS,
    dwTrackFlags: u32,
    dwClassContext: u32,
    locale: u32,
    pServerInfo: ?*COSERVERINFO,
};

pub const BIND_OPTS3 = extern struct {
    __AnonymousBase_objidl_L9041_C36: BIND_OPTS2,
    hwnd: ?HWND,
};

pub const BIND_FLAGS = enum(i32) {
    MAYBOTHERUSER = 1,
    JUSTTESTEXISTENCE = 2,
};
pub const BIND_MAYBOTHERUSER = BIND_FLAGS.MAYBOTHERUSER;
pub const BIND_JUSTTESTEXISTENCE = BIND_FLAGS.JUSTTESTEXISTENCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBindCtx_Value = Guid.initString("0000000e-0000-0000-c000-000000000046");
pub const IID_IBindCtx = &IID_IBindCtx_Value;
pub const IBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObjectBound: *const fn (
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectBound: *const fn (
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBoundObjects: *const fn (
            self: *const IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBindOptions: *const fn (
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindOptions: *const fn (
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningObjectTable: *const fn (
            self: *const IBindCtx,
            pprot: ?*?*IRunningObjectTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterObjectParam: *const fn (
            self: *const IBindCtx,
            psz_key: ?PWSTR,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectParam: *const fn (
            self: *const IBindCtx,
            psz_key: ?PWSTR,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumObjectParam: *const fn (
            self: *const IBindCtx,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectParam: *const fn (
            self: *const IBindCtx,
            psz_key: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerObjectBound(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RegisterObjectBound(@as(*const IBindCtx, @ptrCast(self)), punk_);
            }
            pub inline fn revokeObjectBound(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RevokeObjectBound(@as(*const IBindCtx, @ptrCast(self)), punk_);
            }
            pub inline fn releaseBoundObjects(self: *const T) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).ReleaseBoundObjects(@as(*const IBindCtx, @ptrCast(self)));
            }
            pub inline fn setBindOptions(self: *const T, pbindopts_: ?*BIND_OPTS) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).SetBindOptions(@as(*const IBindCtx, @ptrCast(self)), pbindopts_);
            }
            pub inline fn getBindOptions(self: *const T, pbindopts_: ?*BIND_OPTS) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetBindOptions(@as(*const IBindCtx, @ptrCast(self)), pbindopts_);
            }
            pub inline fn getRunningObjectTable(self: *const T, pprot_: ?*?*IRunningObjectTable) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetRunningObjectTable(@as(*const IBindCtx, @ptrCast(self)), pprot_);
            }
            pub inline fn registerObjectParam(self: *const T, psz_key_: ?PWSTR, punk_: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RegisterObjectParam(@as(*const IBindCtx, @ptrCast(self)), psz_key_, punk_);
            }
            pub inline fn getObjectParam(self: *const T, psz_key_: ?PWSTR, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetObjectParam(@as(*const IBindCtx, @ptrCast(self)), psz_key_, ppunk_);
            }
            pub inline fn enumObjectParam(self: *const T, ppenum_: ?*?*IEnumString) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).EnumObjectParam(@as(*const IBindCtx, @ptrCast(self)), ppenum_);
            }
            pub inline fn revokeObjectParam(self: *const T, psz_key_: ?PWSTR) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RevokeObjectParam(@as(*const IBindCtx, @ptrCast(self)), psz_key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMoniker_Value = Guid.initString("00000102-0000-0000-c000-000000000046");
pub const IID_IEnumMoniker = &IID_IEnumMoniker_Value;
pub const IEnumMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMoniker,
            celt: u32,
            rgelt: [*]?*IMoniker,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMoniker,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMoniker,
            ppenum: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IMoniker, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMoniker, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMoniker, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMoniker, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMoniker, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableObject_Value = Guid.initString("00000126-0000-0000-c000-000000000046");
pub const IID_IRunnableObject = &IID_IRunnableObject_Value;
pub const IRunnableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRunningClass: *const fn (
            self: *const IRunnableObject,
            lp_clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: *const fn (
            self: *const IRunnableObject,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: *const fn (
            self: *const IRunnableObject,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        LockRunning: *const fn (
            self: *const IRunnableObject,
            f_lock: BOOL,
            f_last_unlock_closes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContainedObject: *const fn (
            self: *const IRunnableObject,
            f_contained: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRunningClass(self: *const T, lp_clsid_: ?*Guid) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).GetRunningClass(@as(*const IRunnableObject, @ptrCast(self)), lp_clsid_);
            }
            pub inline fn run(self: *const T, pbc_: ?*IBindCtx) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).Run(@as(*const IRunnableObject, @ptrCast(self)), pbc_);
            }
            pub inline fn isRunning(self: *const T) BOOL {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IRunnableObject, @ptrCast(self)));
            }
            pub inline fn lockRunning(self: *const T, f_lock_: BOOL, f_last_unlock_closes_: BOOL) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).LockRunning(@as(*const IRunnableObject, @ptrCast(self)), f_lock_, f_last_unlock_closes_);
            }
            pub inline fn setContainedObject(self: *const T, f_contained_: BOOL) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).SetContainedObject(@as(*const IRunnableObject, @ptrCast(self)), f_contained_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunningObjectTable_Value = Guid.initString("00000010-0000-0000-c000-000000000046");
pub const IID_IRunningObjectTable = &IID_IRunningObjectTable_Value;
pub const IRunningObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const IRunningObjectTable,
            grf_flags: u32,
            punk_object: ?*IUnknown,
            pmk_object_name: ?*IMoniker,
            pdw_register: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revoke: *const fn (
            self: *const IRunningObjectTable,
            dw_register: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: *const fn (
            self: *const IRunningObjectTable,
            pmk_object_name: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: *const fn (
            self: *const IRunningObjectTable,
            pmk_object_name: ?*IMoniker,
            ppunk_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NoteChangeTime: *const fn (
            self: *const IRunningObjectTable,
            dw_register: u32,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: *const fn (
            self: *const IRunningObjectTable,
            pmk_object_name: ?*IMoniker,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRunning: *const fn (
            self: *const IRunningObjectTable,
            ppenum_moniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T, grf_flags_: u32, punk_object_: ?*IUnknown, pmk_object_name_: ?*IMoniker, pdw_register_: ?*u32) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).Register(@as(*const IRunningObjectTable, @ptrCast(self)), grf_flags_, punk_object_, pmk_object_name_, pdw_register_);
            }
            pub inline fn revoke(self: *const T, dw_register_: u32) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).Revoke(@as(*const IRunningObjectTable, @ptrCast(self)), dw_register_);
            }
            pub inline fn isRunning(self: *const T, pmk_object_name_: ?*IMoniker) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IRunningObjectTable, @ptrCast(self)), pmk_object_name_);
            }
            pub inline fn getObject(self: *const T, pmk_object_name_: ?*IMoniker, ppunk_object_: ?*?*IUnknown) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IRunningObjectTable, @ptrCast(self)), pmk_object_name_, ppunk_object_);
            }
            pub inline fn noteChangeTime(self: *const T, dw_register_: u32, pfiletime_: ?*FILETIME) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).NoteChangeTime(@as(*const IRunningObjectTable, @ptrCast(self)), dw_register_, pfiletime_);
            }
            pub inline fn getTimeOfLastChange(self: *const T, pmk_object_name_: ?*IMoniker, pfiletime_: ?*FILETIME) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).GetTimeOfLastChange(@as(*const IRunningObjectTable, @ptrCast(self)), pmk_object_name_, pfiletime_);
            }
            pub inline fn enumRunning(self: *const T, ppenum_moniker_: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).EnumRunning(@as(*const IRunningObjectTable, @ptrCast(self)), ppenum_moniker_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersist_Value = Guid.initString("0000010c-0000-0000-c000-000000000046");
pub const IID_IPersist = &IID_IPersist_Value;
pub const IPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: *const fn (
            self: *const IPersist,
            p_class_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getClassID(self: *const T, p_class_i_d_: ?*Guid) HRESULT {
                return @as(*const IPersist.VTable, @ptrCast(self.vtable)).GetClassID(@as(*const IPersist, @ptrCast(self)), p_class_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStream_Value = Guid.initString("00000109-0000-0000-c000-000000000046");
pub const IID_IPersistStream = &IID_IPersistStream_Value;
pub const IPersistStream = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: *const fn (
            self: *const IPersistStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistStream,
            p_stm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistStream,
            p_stm: ?*IStream,
            f_clear_dirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: *const fn (
            self: *const IPersistStream,
            pcb_size: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn isDirty(self: *const T) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStream, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, p_stm_: ?*IStream) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStream, @ptrCast(self)), p_stm_);
            }
            pub inline fn save(self: *const T, p_stm_: ?*IStream, f_clear_dirty_: BOOL) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStream, @ptrCast(self)), p_stm_, f_clear_dirty_);
            }
            pub inline fn getSizeMax(self: *const T, pcb_size_: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistStream, @ptrCast(self)), pcb_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MKSYS = enum(i32) {
    NONE = 0,
    GENERICCOMPOSITE = 1,
    FILEMONIKER = 2,
    ANTIMONIKER = 3,
    ITEMMONIKER = 4,
    POINTERMONIKER = 5,
    CLASSMONIKER = 7,
    OBJREFMONIKER = 8,
    SESSIONMONIKER = 9,
    LUAMONIKER = 10,
};
pub const MKSYS_NONE = MKSYS.NONE;
pub const MKSYS_GENERICCOMPOSITE = MKSYS.GENERICCOMPOSITE;
pub const MKSYS_FILEMONIKER = MKSYS.FILEMONIKER;
pub const MKSYS_ANTIMONIKER = MKSYS.ANTIMONIKER;
pub const MKSYS_ITEMMONIKER = MKSYS.ITEMMONIKER;
pub const MKSYS_POINTERMONIKER = MKSYS.POINTERMONIKER;
pub const MKSYS_CLASSMONIKER = MKSYS.CLASSMONIKER;
pub const MKSYS_OBJREFMONIKER = MKSYS.OBJREFMONIKER;
pub const MKSYS_SESSIONMONIKER = MKSYS.SESSIONMONIKER;
pub const MKSYS_LUAMONIKER = MKSYS.LUAMONIKER;

pub const MKREDUCE = enum(i32) {
    ONE = 196608,
    TOUSER = 131072,
    THROUGHUSER = 65536,
    ALL = 0,
};
pub const MKRREDUCE_ONE = MKREDUCE.ONE;
pub const MKRREDUCE_TOUSER = MKREDUCE.TOUSER;
pub const MKRREDUCE_THROUGHUSER = MKREDUCE.THROUGHUSER;
pub const MKRREDUCE_ALL = MKREDUCE.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMoniker_Value = Guid.initString("0000000f-0000-0000-c000-000000000046");
pub const IID_IMoniker = &IID_IMoniker_Value;
pub const IMoniker = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        BindToObject: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            riid_result: ?*const Guid,
            ppv_result: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStorage: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reduce: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            dw_reduce_how_far: u32,
            ppmk_to_left: ?*?*IMoniker,
            ppmk_reduced: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposeWith: *const fn (
            self: *const IMoniker,
            pmk_right: ?*IMoniker,
            f_only_if_not_generic: BOOL,
            ppmk_composite: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: *const fn (
            self: *const IMoniker,
            f_forward: BOOL,
            ppenum_moniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const IMoniker,
            pmk_other_moniker: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: *const fn (
            self: *const IMoniker,
            pdw_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            pmk_newly_running: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            p_file_time: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Inverse: *const fn (
            self: *const IMoniker,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommonPrefixWith: *const fn (
            self: *const IMoniker,
            pmk_other: ?*IMoniker,
            ppmk_prefix: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RelativePathTo: *const fn (
            self: *const IMoniker,
            pmk_other: ?*IMoniker,
            ppmk_rel_path: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            ppsz_display_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseDisplayName: *const fn (
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmk_to_left: ?*IMoniker,
            psz_display_name: ?PWSTR,
            pch_eaten: ?*u32,
            ppmk_out: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSystemMoniker: *const fn (
            self: *const IMoniker,
            pdw_mksys: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistStream.MethodMixin(T);
            pub inline fn bindToObject(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, riid_result_: ?*const Guid, ppv_result_: ?*?*anyopaque) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).BindToObject(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, riid_result_, ppv_result_);
            }
            pub inline fn bindToStorage(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).BindToStorage(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, riid_, ppv_obj_);
            }
            pub inline fn reduce(self: *const T, pbc_: ?*IBindCtx, dw_reduce_how_far_: u32, ppmk_to_left_: ?*?*IMoniker, ppmk_reduced_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Reduce(@as(*const IMoniker, @ptrCast(self)), pbc_, dw_reduce_how_far_, ppmk_to_left_, ppmk_reduced_);
            }
            pub inline fn composeWith(self: *const T, pmk_right_: ?*IMoniker, f_only_if_not_generic_: BOOL, ppmk_composite_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).ComposeWith(@as(*const IMoniker, @ptrCast(self)), pmk_right_, f_only_if_not_generic_, ppmk_composite_);
            }
            pub inline fn @"enum"(self: *const T, f_forward_: BOOL, ppenum_moniker_: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Enum(@as(*const IMoniker, @ptrCast(self)), f_forward_, ppenum_moniker_);
            }
            pub inline fn isEqual(self: *const T, pmk_other_moniker_: ?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IMoniker, @ptrCast(self)), pmk_other_moniker_);
            }
            pub inline fn hash(self: *const T, pdw_hash_: ?*u32) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Hash(@as(*const IMoniker, @ptrCast(self)), pdw_hash_);
            }
            pub inline fn isRunning(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, pmk_newly_running_: ?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, pmk_newly_running_);
            }
            pub inline fn getTimeOfLastChange(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, p_file_time_: ?*FILETIME) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).GetTimeOfLastChange(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, p_file_time_);
            }
            pub inline fn inverse(self: *const T, ppmk_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Inverse(@as(*const IMoniker, @ptrCast(self)), ppmk_);
            }
            pub inline fn commonPrefixWith(self: *const T, pmk_other_: ?*IMoniker, ppmk_prefix_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).CommonPrefixWith(@as(*const IMoniker, @ptrCast(self)), pmk_other_, ppmk_prefix_);
            }
            pub inline fn relativePathTo(self: *const T, pmk_other_: ?*IMoniker, ppmk_rel_path_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).RelativePathTo(@as(*const IMoniker, @ptrCast(self)), pmk_other_, ppmk_rel_path_);
            }
            pub inline fn getDisplayName(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, ppsz_display_name_: ?*?PWSTR) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, ppsz_display_name_);
            }
            pub inline fn parseDisplayName(self: *const T, pbc_: ?*IBindCtx, pmk_to_left_: ?*IMoniker, psz_display_name_: ?PWSTR, pch_eaten_: ?*u32, ppmk_out_: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).ParseDisplayName(@as(*const IMoniker, @ptrCast(self)), pbc_, pmk_to_left_, psz_display_name_, pch_eaten_, ppmk_out_);
            }
            pub inline fn isSystemMoniker(self: *const T, pdw_mksys_: ?*u32) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsSystemMoniker(@as(*const IMoniker, @ptrCast(self)), pdw_mksys_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IROTData_Value = Guid.initString("f29f6bc0-5021-11ce-aa15-00006901293f");
pub const IID_IROTData = &IID_IROTData_Value;
pub const IROTData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetComparisonData: *const fn (
            self: *const IROTData,
            pb_data: [*:0]u8,
            cb_max: u32,
            pcb_data: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getComparisonData(self: *const T, pb_data_: [*:0]u8, cb_max_: u32, pcb_data_: ?*u32) HRESULT {
                return @as(*const IROTData.VTable, @ptrCast(self.vtable)).GetComparisonData(@as(*const IROTData, @ptrCast(self)), pb_data_, cb_max_, pcb_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFile_Value = Guid.initString("0000010b-0000-0000-c000-000000000046");
pub const IID_IPersistFile = &IID_IPersistFile_Value;
pub const IPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: *const fn (
            self: *const IPersistFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistFile,
            psz_file_name: ?[*:0]const u16,
            dw_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistFile,
            psz_file_name: ?[*:0]const u16,
            f_remember: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: *const fn (
            self: *const IPersistFile,
            psz_file_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: *const fn (
            self: *const IPersistFile,
            ppsz_file_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn isDirty(self: *const T) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistFile, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, psz_file_name_: ?[*:0]const u16, dw_mode_: u32) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistFile, @ptrCast(self)), psz_file_name_, dw_mode_);
            }
            pub inline fn save(self: *const T, psz_file_name_: ?[*:0]const u16, f_remember_: BOOL) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistFile, @ptrCast(self)), psz_file_name_, f_remember_);
            }
            pub inline fn saveCompleted(self: *const T, psz_file_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IPersistFile, @ptrCast(self)), psz_file_name_);
            }
            pub inline fn getCurFile(self: *const T, ppsz_file_name_: ?*?PWSTR) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IPersistFile, @ptrCast(self)), ppsz_file_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVTARGETDEVICE = extern struct {
    tdSize: u32,
    tdDriverNameOffset: u16,
    tdDeviceNameOffset: u16,
    tdPortNameOffset: u16,
    tdExtDevmodeOffset: u16,
    tdData: [1]u8,
};

pub const FORMATETC = extern struct {
    cfFormat: u16,
    ptd: ?*DVTARGETDEVICE,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFORMATETC_Value = Guid.initString("00000103-0000-0000-c000-000000000046");
pub const IID_IEnumFORMATETC = &IID_IEnumFORMATETC_Value;
pub const IEnumFORMATETC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumFORMATETC,
            celt: u32,
            rgelt: [*]FORMATETC,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumFORMATETC,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumFORMATETC,
            ppenum: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]FORMATETC, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFORMATETC, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFORMATETC, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFORMATETC, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumFORMATETC) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFORMATETC, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ADVF = enum(i32) {
    _NODATA = 1,
    _PRIMEFIRST = 2,
    _ONLYONCE = 4,
    _DATAONSTOP = 64,
    CACHE_NOHANDLER = 8,
    CACHE_FORCEBUILTIN = 16,
    CACHE_ONSAVE = 32,
};
pub const ADVF_NODATA = ADVF._NODATA;
pub const ADVF_PRIMEFIRST = ADVF._PRIMEFIRST;
pub const ADVF_ONLYONCE = ADVF._ONLYONCE;
pub const ADVF_DATAONSTOP = ADVF._DATAONSTOP;
pub const ADVFCACHE_NOHANDLER = ADVF.CACHE_NOHANDLER;
pub const ADVFCACHE_FORCEBUILTIN = ADVF.CACHE_FORCEBUILTIN;
pub const ADVFCACHE_ONSAVE = ADVF.CACHE_ONSAVE;

pub const STATDATA = extern struct {
    formatetc: FORMATETC,
    advf: u32,
    pAdvSink: ?*IAdviseSink,
    dwConnection: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATDATA_Value = Guid.initString("00000105-0000-0000-c000-000000000046");
pub const IID_IEnumSTATDATA = &IID_IEnumSTATDATA_Value;
pub const IEnumSTATDATA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSTATDATA,
            celt: u32,
            rgelt: [*]STATDATA,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSTATDATA,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSTATDATA,
            ppenum: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]STATDATA, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATDATA, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATDATA, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATDATA, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATDATA, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TYMED = enum(i32) {
    HGLOBAL = 1,
    FILE = 2,
    ISTREAM = 4,
    ISTORAGE = 8,
    GDI = 16,
    MFPICT = 32,
    ENHMF = 64,
    NULL = 0,
};
pub const TYMED_HGLOBAL = TYMED.HGLOBAL;
pub const TYMED_FILE = TYMED.FILE;
pub const TYMED_ISTREAM = TYMED.ISTREAM;
pub const TYMED_ISTORAGE = TYMED.ISTORAGE;
pub const TYMED_GDI = TYMED.GDI;
pub const TYMED_MFPICT = TYMED.MFPICT;
pub const TYMED_ENHMF = TYMED.ENHMF;
pub const TYMED_NULL = TYMED.NULL;

pub const RemSTGMEDIUM = extern struct {
    tymed: u32,
    dwHandleType: u32,
    pData: u32,
    pUnkForRelease: u32,
    cbData: u32,
    data: [1]u8,
};

pub const STGMEDIUM = extern struct {
    tymed: u32,
    Anonymous: extern union {
        hBitmap: ?HBITMAP,
        hMetaFilePict: ?*anyopaque,
        hEnhMetaFile: ?HENHMETAFILE,
        hGlobal: isize,
        lpszFileName: ?PWSTR,
        pstm: ?*IStream,
        pstg: ?*IStorage,
    },
    pUnkForRelease: ?*IUnknown,
};

pub const GDI_OBJECT = extern struct {
    ObjectType: u32,
    u: extern struct {
        hBitmap: ?*userHBITMAP,
        hPalette: ?*userHPALETTE,
        hGeneric: ?*userHGLOBAL,
    },
};

pub const userSTGMEDIUM = extern struct {
    pub const _STGMEDIUM_UNION = extern struct {
        tymed: u32,
        u: extern struct {
            hMetaFilePict: ?*userHMETAFILEPICT,
            hHEnhMetaFile: ?*userHENHMETAFILE,
            hGdiHandle: ?*GDI_OBJECT,
            hGlobal: ?*userHGLOBAL,
            lpszFileName: ?PWSTR,
            pstm: ?*BYTE_BLOB,
            pstg: ?*BYTE_BLOB,
        },
    };
    pUnkForRelease: ?*IUnknown,
};

pub const userFLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: userSTGMEDIUM,
};

pub const FLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: STGMEDIUM,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink_Value = Guid.initString("0000010f-0000-0000-c000-000000000046");
pub const IID_IAdviseSink = &IID_IAdviseSink_Value;
pub const IAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataChange: *const fn (
            self: *const IAdviseSink,
            p_formatetc: ?*FORMATETC,
            p_stgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnViewChange: *const fn (
            self: *const IAdviseSink,
            dw_aspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnRename: *const fn (
            self: *const IAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSave: *const fn (
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnClose: *const fn (
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onDataChange(self: *const T, p_formatetc_: ?*FORMATETC, p_stgmed_: ?*STGMEDIUM) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnDataChange(@as(*const IAdviseSink, @ptrCast(self)), p_formatetc_, p_stgmed_);
            }
            pub inline fn onViewChange(self: *const T, dw_aspect_: u32, lindex_: i32) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnViewChange(@as(*const IAdviseSink, @ptrCast(self)), dw_aspect_, lindex_);
            }
            pub inline fn onRename(self: *const T, pmk_: ?*IMoniker) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnRename(@as(*const IAdviseSink, @ptrCast(self)), pmk_);
            }
            pub inline fn onSave(self: *const T) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnSave(@as(*const IAdviseSink, @ptrCast(self)));
            }
            pub inline fn onClose(self: *const T) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IAdviseSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink_Value = Guid.initString("00000150-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink = &IID_AsyncIAdviseSink_Value;
pub const AsyncIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_OnDataChange: *const fn (
            self: *const AsyncIAdviseSink,
            p_formatetc: ?*FORMATETC,
            p_stgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnDataChange: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnViewChange: *const fn (
            self: *const AsyncIAdviseSink,
            dw_aspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnViewChange: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnRename: *const fn (
            self: *const AsyncIAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnRename: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnSave: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnSave: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnClose: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnClose: *const fn (
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginOnDataChange(self: *const T, p_formatetc_: ?*FORMATETC, p_stgmed_: ?*STGMEDIUM) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnDataChange(@as(*const AsyncIAdviseSink, @ptrCast(self)), p_formatetc_, p_stgmed_);
            }
            pub inline fn finishOnDataChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnDataChange(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn beginOnViewChange(self: *const T, dw_aspect_: u32, lindex_: i32) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnViewChange(@as(*const AsyncIAdviseSink, @ptrCast(self)), dw_aspect_, lindex_);
            }
            pub inline fn finishOnViewChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnViewChange(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn beginOnRename(self: *const T, pmk_: ?*IMoniker) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnRename(@as(*const AsyncIAdviseSink, @ptrCast(self)), pmk_);
            }
            pub inline fn finishOnRename(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnRename(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn beginOnSave(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnSave(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn finishOnSave(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnSave(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn beginOnClose(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnClose(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            pub inline fn finishOnClose(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnClose(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink2_Value = Guid.initString("00000125-0000-0000-c000-000000000046");
pub const IID_IAdviseSink2 = &IID_IAdviseSink2_Value;
pub const IAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnLinkSrcChange: *const fn (
            self: *const IAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAdviseSink.MethodMixin(T);
            pub inline fn onLinkSrcChange(self: *const T, pmk_: ?*IMoniker) void {
                return @as(*const IAdviseSink2.VTable, @ptrCast(self.vtable)).OnLinkSrcChange(@as(*const IAdviseSink2, @ptrCast(self)), pmk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink2_Value = Guid.initString("00000151-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink2 = &IID_AsyncIAdviseSink2_Value;
pub const AsyncIAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: AsyncIAdviseSink.VTable,
        Begin_OnLinkSrcChange: *const fn (
            self: *const AsyncIAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnLinkSrcChange: *const fn (
            self: *const AsyncIAdviseSink2,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace AsyncIAdviseSink.MethodMixin(T);
            pub inline fn beginOnLinkSrcChange(self: *const T, pmk_: ?*IMoniker) void {
                return @as(*const AsyncIAdviseSink2.VTable, @ptrCast(self.vtable)).Begin_OnLinkSrcChange(@as(*const AsyncIAdviseSink2, @ptrCast(self)), pmk_);
            }
            pub inline fn finishOnLinkSrcChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink2.VTable, @ptrCast(self.vtable)).Finish_OnLinkSrcChange(@as(*const AsyncIAdviseSink2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DATADIR = enum(i32) {
    GET = 1,
    SET = 2,
};
pub const DATADIR_GET = DATADIR.GET;
pub const DATADIR_SET = DATADIR.SET;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataObject_Value = Guid.initString("0000010e-0000-0000-c000-000000000046");
pub const IID_IDataObject = &IID_IDataObject_Value;
pub const IDataObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn (
            self: *const IDataObject,
            pformatetc_in: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataHere: *const fn (
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryGetData: *const fn (
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCanonicalFormatEtc: *const fn (
            self: *const IDataObject,
            pformatect_in: ?*FORMATETC,
            pformatetc_out: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: *const fn (
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
            f_release: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFormatEtc: *const fn (
            self: *const IDataObject,
            dw_direction: u32,
            ppenum_format_etc: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DAdvise: *const fn (
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            advf: u32,
            p_adv_sink: ?*IAdviseSink,
            pdw_connection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DUnadvise: *const fn (
            self: *const IDataObject,
            dw_connection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDAdvise: *const fn (
            self: *const IDataObject,
            ppenum_advise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getData(self: *const T, pformatetc_in_: ?*FORMATETC, pmedium_: ?*STGMEDIUM) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetData(@as(*const IDataObject, @ptrCast(self)), pformatetc_in_, pmedium_);
            }
            pub inline fn getDataHere(self: *const T, pformatetc_: ?*FORMATETC, pmedium_: ?*STGMEDIUM) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetDataHere(@as(*const IDataObject, @ptrCast(self)), pformatetc_, pmedium_);
            }
            pub inline fn queryGetData(self: *const T, pformatetc_: ?*FORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).QueryGetData(@as(*const IDataObject, @ptrCast(self)), pformatetc_);
            }
            pub inline fn getCanonicalFormatEtc(self: *const T, pformatect_in_: ?*FORMATETC, pformatetc_out_: ?*FORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetCanonicalFormatEtc(@as(*const IDataObject, @ptrCast(self)), pformatect_in_, pformatetc_out_);
            }
            pub inline fn setData(self: *const T, pformatetc_: ?*FORMATETC, pmedium_: ?*STGMEDIUM, f_release_: BOOL) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).SetData(@as(*const IDataObject, @ptrCast(self)), pformatetc_, pmedium_, f_release_);
            }
            pub inline fn enumFormatEtc(self: *const T, dw_direction_: u32, ppenum_format_etc_: ?*?*IEnumFORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).EnumFormatEtc(@as(*const IDataObject, @ptrCast(self)), dw_direction_, ppenum_format_etc_);
            }
            pub inline fn dAdvise(self: *const T, pformatetc_: ?*FORMATETC, advf_: u32, p_adv_sink_: ?*IAdviseSink, pdw_connection_: ?*u32) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).DAdvise(@as(*const IDataObject, @ptrCast(self)), pformatetc_, advf_, p_adv_sink_, pdw_connection_);
            }
            pub inline fn dUnadvise(self: *const T, dw_connection_: u32) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).DUnadvise(@as(*const IDataObject, @ptrCast(self)), dw_connection_);
            }
            pub inline fn enumDAdvise(self: *const T, ppenum_advise_: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).EnumDAdvise(@as(*const IDataObject, @ptrCast(self)), ppenum_advise_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataAdviseHolder_Value = Guid.initString("00000110-0000-0000-c000-000000000046");
pub const IID_IDataAdviseHolder = &IID_IDataAdviseHolder_Value;
pub const IDataAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: *const fn (
            self: *const IDataAdviseHolder,
            p_data_object: ?*IDataObject,
            p_fetc: ?*FORMATETC,
            advf: u32,
            p_advise: ?*IAdviseSink,
            pdw_connection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IDataAdviseHolder,
            dw_connection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAdvise: *const fn (
            self: *const IDataAdviseHolder,
            ppenum_advise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnDataChange: *const fn (
            self: *const IDataAdviseHolder,
            p_data_object: ?*IDataObject,
            dw_reserved: u32,
            advf: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn advise(self: *const T, p_data_object_: ?*IDataObject, p_fetc_: ?*FORMATETC, advf_: u32, p_advise_: ?*IAdviseSink, pdw_connection_: ?*u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).Advise(@as(*const IDataAdviseHolder, @ptrCast(self)), p_data_object_, p_fetc_, advf_, p_advise_, pdw_connection_);
            }
            pub inline fn unadvise(self: *const T, dw_connection_: u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IDataAdviseHolder, @ptrCast(self)), dw_connection_);
            }
            pub inline fn enumAdvise(self: *const T, ppenum_advise_: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).EnumAdvise(@as(*const IDataAdviseHolder, @ptrCast(self)), ppenum_advise_);
            }
            pub inline fn sendOnDataChange(self: *const T, p_data_object_: ?*IDataObject, dw_reserved_: u32, advf_: u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).SendOnDataChange(@as(*const IDataAdviseHolder, @ptrCast(self)), p_data_object_, dw_reserved_, advf_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CALLTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
    ASYNC = 3,
    TOPLEVEL_CALLPENDING = 4,
    ASYNC_CALLPENDING = 5,
};
pub const CALLTYPE_TOPLEVEL = CALLTYPE.TOPLEVEL;
pub const CALLTYPE_NESTED = CALLTYPE.NESTED;
pub const CALLTYPE_ASYNC = CALLTYPE.ASYNC;
pub const CALLTYPE_TOPLEVEL_CALLPENDING = CALLTYPE.TOPLEVEL_CALLPENDING;
pub const CALLTYPE_ASYNC_CALLPENDING = CALLTYPE.ASYNC_CALLPENDING;

pub const SERVERCALL = enum(i32) {
    ISHANDLED = 0,
    REJECTED = 1,
    RETRYLATER = 2,
};
pub const SERVERCALL_ISHANDLED = SERVERCALL.ISHANDLED;
pub const SERVERCALL_REJECTED = SERVERCALL.REJECTED;
pub const SERVERCALL_RETRYLATER = SERVERCALL.RETRYLATER;

pub const PENDINGTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
};
pub const PENDINGTYPE_TOPLEVEL = PENDINGTYPE.TOPLEVEL;
pub const PENDINGTYPE_NESTED = PENDINGTYPE.NESTED;

pub const PENDINGMSG = enum(i32) {
    CANCELCALL = 0,
    WAITNOPROCESS = 1,
    WAITDEFPROCESS = 2,
};
pub const PENDINGMSG_CANCELCALL = PENDINGMSG.CANCELCALL;
pub const PENDINGMSG_WAITNOPROCESS = PENDINGMSG.WAITNOPROCESS;
pub const PENDINGMSG_WAITDEFPROCESS = PENDINGMSG.WAITDEFPROCESS;

pub const INTERFACEINFO = extern struct {
    pUnk: ?*IUnknown,
    iid: Guid,
    wMethod: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassActivator_Value = Guid.initString("00000140-0000-0000-c000-000000000046");
pub const IID_IClassActivator = &IID_IClassActivator_Value;
pub const IClassActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassObject: *const fn (
            self: *const IClassActivator,
            rclsid: ?*const Guid,
            dw_class_context: u32,
            locale: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getClassObject(self: *const T, rclsid_: ?*const Guid, dw_class_context_: u32, locale_: u32, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IClassActivator.VTable, @ptrCast(self.vtable)).GetClassObject(@as(*const IClassActivator, @ptrCast(self)), rclsid_, dw_class_context_, locale_, riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressNotify_Value = Guid.initString("a9d758a0-4617-11cf-95fc-00aa00680db4");
pub const IID_IProgressNotify = &IID_IProgressNotify_Value;
pub const IProgressNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnProgress: *const fn (
            self: *const IProgressNotify,
            dw_progress_current: u32,
            dw_progress_maximum: u32,
            f_accurate: BOOL,
            f_owner: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onProgress(self: *const T, dw_progress_current_: u32, dw_progress_maximum_: u32, f_accurate_: BOOL, f_owner_: BOOL) HRESULT {
                return @as(*const IProgressNotify.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IProgressNotify, @ptrCast(self)), dw_progress_current_, dw_progress_maximum_, f_accurate_, f_owner_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const StorageLayout = extern struct {
    LayoutType: u32,
    pwcsElementName: ?PWSTR,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBlockingLock_Value = Guid.initString("30f3d47a-6447-11d1-8e3c-00c04fb9386d");
pub const IID_IBlockingLock = &IID_IBlockingLock_Value;
pub const IBlockingLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: *const fn (
            self: *const IBlockingLock,
            dw_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlock: *const fn (
            self: *const IBlockingLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn lock(self: *const T, dw_timeout_: u32) HRESULT {
                return @as(*const IBlockingLock.VTable, @ptrCast(self.vtable)).Lock(@as(*const IBlockingLock, @ptrCast(self)), dw_timeout_);
            }
            pub inline fn unlock(self: *const T) HRESULT {
                return @as(*const IBlockingLock.VTable, @ptrCast(self.vtable)).Unlock(@as(*const IBlockingLock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimeAndNoticeControl_Value = Guid.initString("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4");
pub const IID_ITimeAndNoticeControl = &IID_ITimeAndNoticeControl_Value;
pub const ITimeAndNoticeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuppressChanges: *const fn (
            self: *const ITimeAndNoticeControl,
            res1: u32,
            res2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn suppressChanges(self: *const T, res1_: u32, res2_: u32) HRESULT {
                return @as(*const ITimeAndNoticeControl.VTable, @ptrCast(self.vtable)).SuppressChanges(@as(*const ITimeAndNoticeControl, @ptrCast(self)), res1_, res2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IOplockStorage_Value = Guid.initString("8d19c834-8879-11d1-83e9-00c04fc2c6d4");
pub const IID_IOplockStorage = &IID_IOplockStorage_Value;
pub const IOplockStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStorageEx: *const fn (
            self: *const IOplockStorage,
            pwcs_name: ?[*:0]const u16,
            grf_mode: u32,
            stgfmt: u32,
            grf_attrs: u32,
            riid: ?*const Guid,
            ppstg_open: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStorageEx: *const fn (
            self: *const IOplockStorage,
            pwcs_name: ?[*:0]const u16,
            grf_mode: u32,
            stgfmt: u32,
            grf_attrs: u32,
            riid: ?*const Guid,
            ppstg_open: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createStorageEx(self: *const T, pwcs_name_: ?[*:0]const u16, grf_mode_: u32, stgfmt_: u32, grf_attrs_: u32, riid_: ?*const Guid, ppstg_open_: ?*?*anyopaque) HRESULT {
                return @as(*const IOplockStorage.VTable, @ptrCast(self.vtable)).CreateStorageEx(@as(*const IOplockStorage, @ptrCast(self)), pwcs_name_, grf_mode_, stgfmt_, grf_attrs_, riid_, ppstg_open_);
            }
            pub inline fn openStorageEx(self: *const T, pwcs_name_: ?[*:0]const u16, grf_mode_: u32, stgfmt_: u32, grf_attrs_: u32, riid_: ?*const Guid, ppstg_open_: ?*?*anyopaque) HRESULT {
                return @as(*const IOplockStorage.VTable, @ptrCast(self.vtable)).OpenStorageEx(@as(*const IOplockStorage, @ptrCast(self)), pwcs_name_, grf_mode_, stgfmt_, grf_attrs_, riid_, ppstg_open_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlMon_Value = Guid.initString("00000026-0000-0000-c000-000000000046");
pub const IID_IUrlMon = &IID_IUrlMon_Value;
pub const IUrlMon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsyncGetClassBits: *const fn (
            self: *const IUrlMon,
            rclsid: ?*const Guid,
            psz_t_y_p_e: ?[*:0]const u16,
            psz_ext: ?[*:0]const u16,
            dw_file_version_m_s: u32,
            dw_file_version_l_s: u32,
            psz_code_base: ?[*:0]const u16,
            pbc: ?*IBindCtx,
            dw_class_context: u32,
            riid: ?*const Guid,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn asyncGetClassBits(self: *const T, rclsid_: ?*const Guid, psz_t_y_p_e_: ?[*:0]const u16, psz_ext_: ?[*:0]const u16, dw_file_version_m_s_: u32, dw_file_version_l_s_: u32, psz_code_base_: ?[*:0]const u16, pbc_: ?*IBindCtx, dw_class_context_: u32, riid_: ?*const Guid, flags_: u32) HRESULT {
                return @as(*const IUrlMon.VTable, @ptrCast(self.vtable)).AsyncGetClassBits(@as(*const IUrlMon, @ptrCast(self)), rclsid_, psz_t_y_p_e_, psz_ext_, dw_file_version_m_s_, dw_file_version_l_s_, psz_code_base_, pbc_, dw_class_context_, riid_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IForegroundTransfer_Value = Guid.initString("00000145-0000-0000-c000-000000000046");
pub const IID_IForegroundTransfer = &IID_IForegroundTransfer_Value;
pub const IForegroundTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowForegroundTransfer: *const fn (
            self: *const IForegroundTransfer,
            lpv_reserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn allowForegroundTransfer(self: *const T, lpv_reserved_: ?*anyopaque) HRESULT {
                return @as(*const IForegroundTransfer.VTable, @ptrCast(self.vtable)).AllowForegroundTransfer(@as(*const IForegroundTransfer, @ptrCast(self)), lpv_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ApplicationType = enum(i32) {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const ServerApplication = ApplicationType.ServerApplication;
pub const LibraryApplication = ApplicationType.LibraryApplication;

pub const ShutdownType = enum(i32) {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const IdleShutdown = ShutdownType.IdleShutdown;
pub const ForcedShutdown = ShutdownType.ForcedShutdown;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessLock_Value = Guid.initString("000001d5-0000-0000-c000-000000000046");
pub const IID_IProcessLock = &IID_IProcessLock_Value;
pub const IProcessLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefOnProcess: *const fn (
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseRefOnProcess: *const fn (
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addRefOnProcess(self: *const T) u32 {
                return @as(*const IProcessLock.VTable, @ptrCast(self.vtable)).AddRefOnProcess(@as(*const IProcessLock, @ptrCast(self)));
            }
            pub inline fn releaseRefOnProcess(self: *const T) u32 {
                return @as(*const IProcessLock.VTable, @ptrCast(self.vtable)).ReleaseRefOnProcess(@as(*const IProcessLock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogateService_Value = Guid.initString("000001d4-0000-0000-c000-000000000046");
pub const IID_ISurrogateService = &IID_ISurrogateService_Value;
pub const ISurrogateService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const ISurrogateService,
            rguid_process_i_d: ?*const Guid,
            p_process_lock: ?*IProcessLock,
            pf_application_aware: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationLaunch: *const fn (
            self: *const ISurrogateService,
            rguid_appl_i_d: ?*const Guid,
            app_type: ApplicationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationFree: *const fn (
            self: *const ISurrogateService,
            rguid_appl_i_d: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatalogRefresh: *const fn (
            self: *const ISurrogateService,
            ul_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessShutdown: *const fn (
            self: *const ISurrogateService,
            shutdown_type: ShutdownType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, rguid_process_i_d_: ?*const Guid, p_process_lock_: ?*IProcessLock, pf_application_aware_: ?*BOOL) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).Init(@as(*const ISurrogateService, @ptrCast(self)), rguid_process_i_d_, p_process_lock_, pf_application_aware_);
            }
            pub inline fn applicationLaunch(self: *const T, rguid_appl_i_d_: ?*const Guid, app_type_: ApplicationType) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ApplicationLaunch(@as(*const ISurrogateService, @ptrCast(self)), rguid_appl_i_d_, app_type_);
            }
            pub inline fn applicationFree(self: *const T, rguid_appl_i_d_: ?*const Guid) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ApplicationFree(@as(*const ISurrogateService, @ptrCast(self)), rguid_appl_i_d_);
            }
            pub inline fn catalogRefresh(self: *const T, ul_reserved_: u32) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).CatalogRefresh(@as(*const ISurrogateService, @ptrCast(self)), ul_reserved_);
            }
            pub inline fn processShutdown(self: *const T, shutdown_type_: ShutdownType) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ProcessShutdown(@as(*const ISurrogateService, @ptrCast(self)), shutdown_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInitializeSpy_Value = Guid.initString("00000034-0000-0000-c000-000000000046");
pub const IID_IInitializeSpy = &IID_IInitializeSpy_Value;
pub const IInitializeSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreInitialize: *const fn (
            self: *const IInitializeSpy,
            dw_co_init: u32,
            dw_cur_thread_apt_refs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostInitialize: *const fn (
            self: *const IInitializeSpy,
            hr_co_init: HRESULT,
            dw_co_init: u32,
            dw_new_thread_apt_refs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUninitialize: *const fn (
            self: *const IInitializeSpy,
            dw_cur_thread_apt_refs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUninitialize: *const fn (
            self: *const IInitializeSpy,
            dw_new_thread_apt_refs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn preInitialize(self: *const T, dw_co_init_: u32, dw_cur_thread_apt_refs_: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PreInitialize(@as(*const IInitializeSpy, @ptrCast(self)), dw_co_init_, dw_cur_thread_apt_refs_);
            }
            pub inline fn postInitialize(self: *const T, hr_co_init_: HRESULT, dw_co_init_: u32, dw_new_thread_apt_refs_: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PostInitialize(@as(*const IInitializeSpy, @ptrCast(self)), hr_co_init_, dw_co_init_, dw_new_thread_apt_refs_);
            }
            pub inline fn preUninitialize(self: *const T, dw_cur_thread_apt_refs_: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PreUninitialize(@as(*const IInitializeSpy, @ptrCast(self)), dw_cur_thread_apt_refs_);
            }
            pub inline fn postUninitialize(self: *const T, dw_new_thread_apt_refs_: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PostUninitialize(@as(*const IInitializeSpy, @ptrCast(self)), dw_new_thread_apt_refs_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COINIT = enum(u32) {
    APARTMENTTHREADED = 2,
    MULTITHREADED = 0,
    DISABLE_OLE1DDE = 4,
    SPEED_OVER_MEMORY = 8,
    _,
    pub fn initFlags(o: struct {
        APARTMENTTHREADED: u1 = 0,
        MULTITHREADED: u1 = 0,
        DISABLE_OLE1DDE: u1 = 0,
        SPEED_OVER_MEMORY: u1 = 0,
    }) COINIT {
        return @as(COINIT, @enumFromInt((if (o.APARTMENTTHREADED == 1) @intFromEnum(COINIT.APARTMENTTHREADED) else 0) | (if (o.MULTITHREADED == 1) @intFromEnum(COINIT.MULTITHREADED) else 0) | (if (o.DISABLE_OLE1DDE == 1) @intFromEnum(COINIT.DISABLE_OLE1DDE) else 0) | (if (o.SPEED_OVER_MEMORY == 1) @intFromEnum(COINIT.SPEED_OVER_MEMORY) else 0)));
    }
};
pub const COINIT_APARTMENTTHREADED = COINIT.APARTMENTTHREADED;
pub const COINIT_MULTITHREADED = COINIT.MULTITHREADED;
pub const COINIT_DISABLE_OLE1DDE = COINIT.DISABLE_OLE1DDE;
pub const COINIT_SPEED_OVER_MEMORY = COINIT.SPEED_OVER_MEMORY;

pub const COMSD = enum(i32) {
    LAUNCHPERMISSIONS = 0,
    ACCESSPERMISSIONS = 1,
    LAUNCHRESTRICTIONS = 2,
    ACCESSRESTRICTIONS = 3,
};
pub const SD_LAUNCHPERMISSIONS = COMSD.LAUNCHPERMISSIONS;
pub const SD_ACCESSPERMISSIONS = COMSD.ACCESSPERMISSIONS;
pub const SD_LAUNCHRESTRICTIONS = COMSD.LAUNCHRESTRICTIONS;
pub const SD_ACCESSRESTRICTIONS = COMSD.ACCESSRESTRICTIONS;

const IID_IServiceProvider_Value = Guid.initString("6d5140c1-7436-11ce-8034-00aa006009fa");
pub const IID_IServiceProvider = &IID_IServiceProvider_Value;
pub const IServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: *const fn (
            self: *const IServiceProvider,
            guid_service: ?*const Guid,
            riid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryService(self: *const T, guid_service_: ?*const Guid, riid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const IServiceProvider.VTable, @ptrCast(self.vtable)).QueryService(@as(*const IServiceProvider, @ptrCast(self)), guid_service_, riid_, ppv_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COWAIT_FLAGS = enum(i32) {
    DEFAULT = 0,
    WAITALL = 1,
    ALERTABLE = 2,
    INPUTAVAILABLE = 4,
    DISPATCH_CALLS = 8,
    DISPATCH_WINDOW_MESSAGES = 16,
};
pub const COWAIT_DEFAULT = COWAIT_FLAGS.DEFAULT;
pub const COWAIT_WAITALL = COWAIT_FLAGS.WAITALL;
pub const COWAIT_ALERTABLE = COWAIT_FLAGS.ALERTABLE;
pub const COWAIT_INPUTAVAILABLE = COWAIT_FLAGS.INPUTAVAILABLE;
pub const COWAIT_DISPATCH_CALLS = COWAIT_FLAGS.DISPATCH_CALLS;
pub const COWAIT_DISPATCH_WINDOW_MESSAGES = COWAIT_FLAGS.DISPATCH_WINDOW_MESSAGES;

pub const CWMO_FLAGS = enum(i32) {
    EFAULT = 0,
    ISPATCH_CALLS = 1,
    ISPATCH_WINDOW_MESSAGES = 2,
};
pub const CWMO_DEFAULT = CWMO_FLAGS.EFAULT;
pub const CWMO_DISPATCH_CALLS = CWMO_FLAGS.ISPATCH_CALLS;
pub const CWMO_DISPATCH_WINDOW_MESSAGES = CWMO_FLAGS.ISPATCH_WINDOW_MESSAGES;

pub const LPFNGETCLASSOBJECT = *const fn (
    param0: ?*const Guid,
    param1: ?*const Guid,
    param2: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNCANUNLOADNOW = *const fn () callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumGUID_Value = Guid.initString("0002e000-0000-0000-c000-000000000046");
pub const IID_IEnumGUID = &IID_IEnumGUID_Value;
pub const IEnumGUID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumGUID,
            celt: u32,
            rgelt: [*]Guid,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumGUID,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumGUID,
            ppenum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]Guid, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumGUID, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumGUID, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumGUID, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumGUID, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO = extern struct {
    catid: Guid,
    lcid: u32,
    szDescription: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumCATEGORYINFO_Value = Guid.initString("0002e011-0000-0000-c000-000000000046");
pub const IID_IEnumCATEGORYINFO = &IID_IEnumCATEGORYINFO_Value;
pub const IEnumCATEGORYINFO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumCATEGORYINFO,
            celt: u32,
            rgelt: [*]CATEGORYINFO,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumCATEGORYINFO,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumCATEGORYINFO,
            ppenum: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]CATEGORYINFO, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCATEGORYINFO, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumCATEGORYINFO) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatRegister_Value = Guid.initString("0002e012-0000-0000-c000-000000000046");
pub const IID_ICatRegister = &IID_ICatRegister_Value;
pub const ICatRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategories: *const fn (
            self: *const ICatRegister,
            c_categories: u32,
            rg_category_info: [*]CATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterCategories: *const fn (
            self: *const ICatRegister,
            c_categories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassImplCategories: *const fn (
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            c_categories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassImplCategories: *const fn (
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            c_categories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassReqCategories: *const fn (
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            c_categories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassReqCategories: *const fn (
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            c_categories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerCategories(self: *const T, c_categories_: u32, rg_category_info_: [*]CATEGORYINFO) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterCategories(@as(*const ICatRegister, @ptrCast(self)), c_categories_, rg_category_info_);
            }
            pub inline fn unRegisterCategories(self: *const T, c_categories_: u32, rgcatid_: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterCategories(@as(*const ICatRegister, @ptrCast(self)), c_categories_, rgcatid_);
            }
            pub inline fn registerClassImplCategories(self: *const T, rclsid_: ?*const Guid, c_categories_: u32, rgcatid_: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterClassImplCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid_, c_categories_, rgcatid_);
            }
            pub inline fn unRegisterClassImplCategories(self: *const T, rclsid_: ?*const Guid, c_categories_: u32, rgcatid_: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterClassImplCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid_, c_categories_, rgcatid_);
            }
            pub inline fn registerClassReqCategories(self: *const T, rclsid_: ?*const Guid, c_categories_: u32, rgcatid_: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterClassReqCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid_, c_categories_, rgcatid_);
            }
            pub inline fn unRegisterClassReqCategories(self: *const T, rclsid_: ?*const Guid, c_categories_: u32, rgcatid_: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterClassReqCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid_, c_categories_, rgcatid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatInformation_Value = Guid.initString("0002e013-0000-0000-c000-000000000046");
pub const IID_ICatInformation = &IID_ICatInformation_Value;
pub const ICatInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCategories: *const fn (
            self: *const ICatInformation,
            lcid: u32,
            ppenum_category_info: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryDesc: *const fn (
            self: *const ICatInformation,
            rcatid: ?*Guid,
            lcid: u32,
            psz_desc: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumClassesOfCategories: *const fn (
            self: *const ICatInformation,
            c_implemented: u32,
            rgcatid_impl: [*]const Guid,
            c_required: u32,
            rgcatid_req: [*]const Guid,
            ppenum_clsid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsClassOfCategories: *const fn (
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            c_implemented: u32,
            rgcatid_impl: [*]const Guid,
            c_required: u32,
            rgcatid_req: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumImplCategoriesOfClass: *const fn (
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenum_catid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumReqCategoriesOfClass: *const fn (
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenum_catid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumCategories(self: *const T, lcid_: u32, ppenum_category_info_: ?*?*IEnumCATEGORYINFO) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumCategories(@as(*const ICatInformation, @ptrCast(self)), lcid_, ppenum_category_info_);
            }
            pub inline fn getCategoryDesc(self: *const T, rcatid_: ?*Guid, lcid_: u32, psz_desc_: ?*?PWSTR) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).GetCategoryDesc(@as(*const ICatInformation, @ptrCast(self)), rcatid_, lcid_, psz_desc_);
            }
            pub inline fn enumClassesOfCategories(self: *const T, c_implemented_: u32, rgcatid_impl_: [*]const Guid, c_required_: u32, rgcatid_req_: [*]const Guid, ppenum_clsid_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumClassesOfCategories(@as(*const ICatInformation, @ptrCast(self)), c_implemented_, rgcatid_impl_, c_required_, rgcatid_req_, ppenum_clsid_);
            }
            pub inline fn isClassOfCategories(self: *const T, rclsid_: ?*const Guid, c_implemented_: u32, rgcatid_impl_: [*]const Guid, c_required_: u32, rgcatid_req_: [*]const Guid) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).IsClassOfCategories(@as(*const ICatInformation, @ptrCast(self)), rclsid_, c_implemented_, rgcatid_impl_, c_required_, rgcatid_req_);
            }
            pub inline fn enumImplCategoriesOfClass(self: *const T, rclsid_: ?*const Guid, ppenum_catid_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumImplCategoriesOfClass(@as(*const ICatInformation, @ptrCast(self)), rclsid_, ppenum_catid_);
            }
            pub inline fn enumReqCategoriesOfClass(self: *const T, rclsid_: ?*const Guid, ppenum_catid_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumReqCategoriesOfClass(@as(*const ICatInformation, @ptrCast(self)), rclsid_, ppenum_catid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ComCallData = extern struct {
    dwDispid: u32,
    dwReserved: u32,
    pUserDefined: ?*anyopaque,
};

pub const PFNCONTEXTCALL = *const fn (
    p_param: ?*ComCallData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextCallback_Value = Guid.initString("000001da-0000-0000-c000-000000000046");
pub const IID_IContextCallback = &IID_IContextCallback_Value;
pub const IContextCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ContextCallback: *const fn (
            self: *const IContextCallback,
            pfn_callback: ?PFNCONTEXTCALL,
            p_param: ?*ComCallData,
            riid: ?*const Guid,
            i_method: i32,
            p_unk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn contextCallback(self: *const T, pfn_callback_: ?PFNCONTEXTCALL, p_param_: ?*ComCallData, riid_: ?*const Guid, i_method_: i32, p_unk_: ?*IUnknown) HRESULT {
                return @as(*const IContextCallback.VTable, @ptrCast(self.vtable)).ContextCallback(@as(*const IContextCallback, @ptrCast(self)), pfn_callback_, p_param_, riid_, i_method_, p_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBinding_Value = Guid.initString("79eac9c0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBinding = &IID_IBinding_Value;
pub const IBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: *const fn (
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: *const fn (
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPriority: *const fn (
            self: *const IBinding,
            n_priority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: *const fn (
            self: *const IBinding,
            pn_priority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindResult: *const fn (
            self: *const IBinding,
            pclsid_protocol: ?*Guid,
            pdw_result: ?*u32,
            psz_result: ?*?PWSTR,
            pdw_reserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn abort(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Abort(@as(*const IBinding, @ptrCast(self)));
            }
            pub inline fn @"suspend"(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IBinding, @ptrCast(self)));
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Resume(@as(*const IBinding, @ptrCast(self)));
            }
            pub inline fn setPriority(self: *const T, n_priority_: i32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).SetPriority(@as(*const IBinding, @ptrCast(self)), n_priority_);
            }
            pub inline fn getPriority(self: *const T, pn_priority_: ?*i32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IBinding, @ptrCast(self)), pn_priority_);
            }
            pub inline fn getBindResult(self: *const T, pclsid_protocol_: ?*Guid, pdw_result_: ?*u32, psz_result_: ?*?PWSTR, pdw_reserved_: ?*u32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).GetBindResult(@as(*const IBinding, @ptrCast(self)), pclsid_protocol_, pdw_result_, psz_result_, pdw_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BINDINFOF = enum(i32) {
    STGMEDDATA = 1,
    DEXTRAINFO = 2,
};
pub const BINDINFOF_URLENCODESTGMEDDATA = BINDINFOF.STGMEDDATA;
pub const BINDINFOF_URLENCODEDEXTRAINFO = BINDINFOF.DEXTRAINFO;

pub const BINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    stgmedData: STGMEDIUM,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

const IID_IBindStatusCallback_Value = Guid.initString("79eac9c1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindStatusCallback = &IID_IBindStatusCallback_Value;
pub const IBindStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartBinding: *const fn (
            self: *const IBindStatusCallback,
            dw_reserved: u32,
            pib: ?*IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: *const fn (
            self: *const IBindStatusCallback,
            pn_priority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLowResource: *const fn (
            self: *const IBindStatusCallback,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: *const fn (
            self: *const IBindStatusCallback,
            ul_progress: u32,
            ul_progress_max: u32,
            ul_status_code: u32,
            sz_status_text: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStopBinding: *const fn (
            self: *const IBindStatusCallback,
            hresult: HRESULT,
            sz_error: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindInfo: *const fn (
            self: *const IBindStatusCallback,
            grf_b_i_n_d_f: ?*u32,
            pbindinfo: ?*BINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataAvailable: *const fn (
            self: *const IBindStatusCallback,
            grf_b_s_c_f: u32,
            dw_size: u32,
            pformatetc: ?*FORMATETC,
            pstgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnObjectAvailable: *const fn (
            self: *const IBindStatusCallback,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onStartBinding(self: *const T, dw_reserved_: u32, pib_: ?*IBinding) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnStartBinding(@as(*const IBindStatusCallback, @ptrCast(self)), dw_reserved_, pib_);
            }
            pub inline fn getPriority(self: *const T, pn_priority_: ?*i32) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IBindStatusCallback, @ptrCast(self)), pn_priority_);
            }
            pub inline fn onLowResource(self: *const T, reserved_: u32) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnLowResource(@as(*const IBindStatusCallback, @ptrCast(self)), reserved_);
            }
            pub inline fn onProgress(self: *const T, ul_progress_: u32, ul_progress_max_: u32, ul_status_code_: u32, sz_status_text_: ?[*:0]const u16) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IBindStatusCallback, @ptrCast(self)), ul_progress_, ul_progress_max_, ul_status_code_, sz_status_text_);
            }
            pub inline fn onStopBinding(self: *const T, hresult_: HRESULT, sz_error_: ?[*:0]const u16) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnStopBinding(@as(*const IBindStatusCallback, @ptrCast(self)), hresult_, sz_error_);
            }
            pub inline fn getBindInfo(self: *const T, grf_b_i_n_d_f_: ?*u32, pbindinfo_: ?*BINDINFO) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).GetBindInfo(@as(*const IBindStatusCallback, @ptrCast(self)), grf_b_i_n_d_f_, pbindinfo_);
            }
            pub inline fn onDataAvailable(self: *const T, grf_b_s_c_f_: u32, dw_size_: u32, pformatetc_: ?*FORMATETC, pstgmed_: ?*STGMEDIUM) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnDataAvailable(@as(*const IBindStatusCallback, @ptrCast(self)), grf_b_s_c_f_, dw_size_, pformatetc_, pstgmed_);
            }
            pub inline fn onObjectAvailable(self: *const T, riid_: ?*const Guid, punk_: ?*IUnknown) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnObjectAvailable(@as(*const IBindStatusCallback, @ptrCast(self)), riid_, punk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindStatusCallbackEx_Value = Guid.initString("aaa74ef9-8ee7-4659-88d9-f8c504da73cc");
pub const IID_IBindStatusCallbackEx = &IID_IBindStatusCallbackEx_Value;
pub const IBindStatusCallbackEx = extern struct {
    pub const VTable = extern struct {
        base: IBindStatusCallback.VTable,
        GetBindInfoEx: *const fn (
            self: *const IBindStatusCallbackEx,
            grf_b_i_n_d_f: ?*u32,
            pbindinfo: ?*BINDINFO,
            grf_b_i_n_d_f2: ?*u32,
            pdw_reserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBindStatusCallback.MethodMixin(T);
            pub inline fn getBindInfoEx(self: *const T, grf_b_i_n_d_f_: ?*u32, pbindinfo_: ?*BINDINFO, grf_b_i_n_d_f2_: ?*u32, pdw_reserved_: ?*u32) HRESULT {
                return @as(*const IBindStatusCallbackEx.VTable, @ptrCast(self.vtable)).GetBindInfoEx(@as(*const IBindStatusCallbackEx, @ptrCast(self)), grf_b_i_n_d_f_, pbindinfo_, grf_b_i_n_d_f2_, pdw_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuthenticate_Value = Guid.initString("79eac9d0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IAuthenticate = &IID_IAuthenticate_Value;
pub const IAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Authenticate: *const fn (
            self: *const IAuthenticate,
            phwnd: ?*?HWND,
            psz_username: ?*?PWSTR,
            psz_password: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn authenticate(self: *const T, phwnd_: ?*?HWND, psz_username_: ?*?PWSTR, psz_password_: ?*?PWSTR) HRESULT {
                return @as(*const IAuthenticate.VTable, @ptrCast(self.vtable)).Authenticate(@as(*const IAuthenticate, @ptrCast(self)), phwnd_, psz_username_, psz_password_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUTHENTICATEINFO = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

const IID_IAuthenticateEx_Value = Guid.initString("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd");
pub const IID_IAuthenticateEx = &IID_IAuthenticateEx_Value;
pub const IAuthenticateEx = extern struct {
    pub const VTable = extern struct {
        base: IAuthenticate.VTable,
        AuthenticateEx: *const fn (
            self: *const IAuthenticateEx,
            phwnd: ?*?HWND,
            psz_username: ?*?PWSTR,
            psz_password: ?*?PWSTR,
            pauthinfo: ?*AUTHENTICATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAuthenticate.MethodMixin(T);
            pub inline fn authenticateEx(self: *const T, phwnd_: ?*?HWND, psz_username_: ?*?PWSTR, psz_password_: ?*?PWSTR, pauthinfo_: ?*AUTHENTICATEINFO) HRESULT {
                return @as(*const IAuthenticateEx.VTable, @ptrCast(self.vtable)).AuthenticateEx(@as(*const IAuthenticateEx, @ptrCast(self)), phwnd_, psz_username_, psz_password_, pauthinfo_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Uri_PROPERTY = enum(i32) {
    ABSOLUTE_URI = 0,
    // STRING_START = 0, this enum value conflicts with ABSOLUTE_URI
    AUTHORITY = 1,
    DISPLAY_URI = 2,
    DOMAIN = 3,
    EXTENSION = 4,
    FRAGMENT = 5,
    HOST = 6,
    PASSWORD = 7,
    PATH = 8,
    PATH_AND_QUERY = 9,
    QUERY = 10,
    RAW_URI = 11,
    SCHEME_NAME = 12,
    USER_INFO = 13,
    USER_NAME = 14,
    // STRING_LAST = 14, this enum value conflicts with USER_NAME
    HOST_TYPE = 15,
    // DWORD_START = 15, this enum value conflicts with HOST_TYPE
    PORT = 16,
    SCHEME = 17,
    ZONE = 18,
    // DWORD_LAST = 18, this enum value conflicts with ZONE
};
pub const Uri_PROPERTY_ABSOLUTE_URI = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_STRING_START = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_AUTHORITY = Uri_PROPERTY.AUTHORITY;
pub const Uri_PROPERTY_DISPLAY_URI = Uri_PROPERTY.DISPLAY_URI;
pub const Uri_PROPERTY_DOMAIN = Uri_PROPERTY.DOMAIN;
pub const Uri_PROPERTY_EXTENSION = Uri_PROPERTY.EXTENSION;
pub const Uri_PROPERTY_FRAGMENT = Uri_PROPERTY.FRAGMENT;
pub const Uri_PROPERTY_HOST = Uri_PROPERTY.HOST;
pub const Uri_PROPERTY_PASSWORD = Uri_PROPERTY.PASSWORD;
pub const Uri_PROPERTY_PATH = Uri_PROPERTY.PATH;
pub const Uri_PROPERTY_PATH_AND_QUERY = Uri_PROPERTY.PATH_AND_QUERY;
pub const Uri_PROPERTY_QUERY = Uri_PROPERTY.QUERY;
pub const Uri_PROPERTY_RAW_URI = Uri_PROPERTY.RAW_URI;
pub const Uri_PROPERTY_SCHEME_NAME = Uri_PROPERTY.SCHEME_NAME;
pub const Uri_PROPERTY_USER_INFO = Uri_PROPERTY.USER_INFO;
pub const Uri_PROPERTY_USER_NAME = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_STRING_LAST = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_HOST_TYPE = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_DWORD_START = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_PORT = Uri_PROPERTY.PORT;
pub const Uri_PROPERTY_SCHEME = Uri_PROPERTY.SCHEME;
pub const Uri_PROPERTY_ZONE = Uri_PROPERTY.ZONE;
pub const Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY.ZONE;

const IID_IUri_Value = Guid.initString("a39ee748-6a27-4817-a6f2-13914bef5890");
pub const IID_IUri = &IID_IUri_Value;
pub const IUri = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyBSTR: *const fn (
            self: *const IUri,
            uri_prop: Uri_PROPERTY,
            pbstr_property: ?*?BSTR,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyLength: *const fn (
            self: *const IUri,
            uri_prop: Uri_PROPERTY,
            pcch_property: ?*u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDWORD: *const fn (
            self: *const IUri,
            uri_prop: Uri_PROPERTY,
            pdw_property: ?*u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasProperty: *const fn (
            self: *const IUri,
            uri_prop: Uri_PROPERTY,
            pf_has_property: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAbsoluteUri: *const fn (
            self: *const IUri,
            pbstr_absolute_uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthority: *const fn (
            self: *const IUri,
            pbstr_authority: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayUri: *const fn (
            self: *const IUri,
            pbstr_display_string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomain: *const fn (
            self: *const IUri,
            pbstr_domain: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: *const fn (
            self: *const IUri,
            pbstr_extension: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: *const fn (
            self: *const IUri,
            pbstr_fragment: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: *const fn (
            self: *const IUri,
            pbstr_host: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: *const fn (
            self: *const IUri,
            pbstr_password: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: *const fn (
            self: *const IUri,
            pbstr_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPathAndQuery: *const fn (
            self: *const IUri,
            pbstr_path_and_query: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: *const fn (
            self: *const IUri,
            pbstr_query: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawUri: *const fn (
            self: *const IUri,
            pbstr_raw_uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: *const fn (
            self: *const IUri,
            pbstr_scheme_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserInfo: *const fn (
            self: *const IUri,
            pbstr_user_info: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: *const fn (
            self: *const IUri,
            pbstr_user_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHostType: *const fn (
            self: *const IUri,
            pdw_host_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: *const fn (
            self: *const IUri,
            pdw_port: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheme: *const fn (
            self: *const IUri,
            pdw_scheme: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZone: *const fn (
            self: *const IUri,
            pdw_zone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: *const fn (
            self: *const IUri,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const IUri,
            p_uri: ?*IUri,
            pf_equal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPropertyBSTR(self: *const T, uri_prop_: Uri_PROPERTY, pbstr_property_: ?*?BSTR, dw_flags_: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyBSTR(@as(*const IUri, @ptrCast(self)), uri_prop_, pbstr_property_, dw_flags_);
            }
            pub inline fn getPropertyLength(self: *const T, uri_prop_: Uri_PROPERTY, pcch_property_: ?*u32, dw_flags_: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyLength(@as(*const IUri, @ptrCast(self)), uri_prop_, pcch_property_, dw_flags_);
            }
            pub inline fn getPropertyDWORD(self: *const T, uri_prop_: Uri_PROPERTY, pdw_property_: ?*u32, dw_flags_: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyDWORD(@as(*const IUri, @ptrCast(self)), uri_prop_, pdw_property_, dw_flags_);
            }
            pub inline fn hasProperty(self: *const T, uri_prop_: Uri_PROPERTY, pf_has_property_: ?*BOOL) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).HasProperty(@as(*const IUri, @ptrCast(self)), uri_prop_, pf_has_property_);
            }
            pub inline fn getAbsoluteUri(self: *const T, pbstr_absolute_uri_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetAbsoluteUri(@as(*const IUri, @ptrCast(self)), pbstr_absolute_uri_);
            }
            pub inline fn getAuthority(self: *const T, pbstr_authority_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetAuthority(@as(*const IUri, @ptrCast(self)), pbstr_authority_);
            }
            pub inline fn getDisplayUri(self: *const T, pbstr_display_string_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetDisplayUri(@as(*const IUri, @ptrCast(self)), pbstr_display_string_);
            }
            pub inline fn getDomain(self: *const T, pbstr_domain_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetDomain(@as(*const IUri, @ptrCast(self)), pbstr_domain_);
            }
            pub inline fn getExtension(self: *const T, pbstr_extension_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const IUri, @ptrCast(self)), pbstr_extension_);
            }
            pub inline fn getFragment(self: *const T, pbstr_fragment_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetFragment(@as(*const IUri, @ptrCast(self)), pbstr_fragment_);
            }
            pub inline fn getHost(self: *const T, pbstr_host_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUri, @ptrCast(self)), pbstr_host_);
            }
            pub inline fn getPassword(self: *const T, pbstr_password_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPassword(@as(*const IUri, @ptrCast(self)), pbstr_password_);
            }
            pub inline fn getPath(self: *const T, pbstr_path_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IUri, @ptrCast(self)), pbstr_path_);
            }
            pub inline fn getPathAndQuery(self: *const T, pbstr_path_and_query_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPathAndQuery(@as(*const IUri, @ptrCast(self)), pbstr_path_and_query_);
            }
            pub inline fn getQuery(self: *const T, pbstr_query_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IUri, @ptrCast(self)), pbstr_query_);
            }
            pub inline fn getRawUri(self: *const T, pbstr_raw_uri_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetRawUri(@as(*const IUri, @ptrCast(self)), pbstr_raw_uri_);
            }
            pub inline fn getSchemeName(self: *const T, pbstr_scheme_name_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetSchemeName(@as(*const IUri, @ptrCast(self)), pbstr_scheme_name_);
            }
            pub inline fn getUserInfo(self: *const T, pbstr_user_info_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetUserInfo(@as(*const IUri, @ptrCast(self)), pbstr_user_info_);
            }
            pub inline fn getUserName(self: *const T, pbstr_user_name_: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetUserName(@as(*const IUri, @ptrCast(self)), pbstr_user_name_);
            }
            pub inline fn getHostType(self: *const T, pdw_host_type_: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetHostType(@as(*const IUri, @ptrCast(self)), pdw_host_type_);
            }
            pub inline fn getPort(self: *const T, pdw_port_: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPort(@as(*const IUri, @ptrCast(self)), pdw_port_);
            }
            pub inline fn getScheme(self: *const T, pdw_scheme_: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetScheme(@as(*const IUri, @ptrCast(self)), pdw_scheme_);
            }
            pub inline fn getZone(self: *const T, pdw_zone_: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetZone(@as(*const IUri, @ptrCast(self)), pdw_zone_);
            }
            pub inline fn getProperties(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IUri, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn isEqual(self: *const T, p_uri_: ?*IUri, pf_equal_: ?*BOOL) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IUri, @ptrCast(self)), p_uri_, pf_equal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilder_Value = Guid.initString("4221b2e1-8955-46c0-bd5b-de9897565de7");
pub const IID_IUriBuilder = &IID_IUriBuilder_Value;
pub const IUriBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateUriSimple: *const fn (
            self: *const IUriBuilder,
            dw_allow_encoding_property_mask: u32,
            dw_reserved: usize,
            pp_i_uri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUri: *const fn (
            self: *const IUriBuilder,
            dw_create_flags: u32,
            dw_allow_encoding_property_mask: u32,
            dw_reserved: usize,
            pp_i_uri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUriWithFlags: *const fn (
            self: *const IUriBuilder,
            dw_create_flags: u32,
            dw_uri_builder_flags: u32,
            dw_allow_encoding_property_mask: u32,
            dw_reserved: usize,
            pp_i_uri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIUri: *const fn (
            self: *const IUriBuilder,
            pp_i_uri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIUri: *const fn (
            self: *const IUriBuilder,
            p_i_uri: ?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: *const fn (
            self: *const IUriBuilder,
            pcch_fragment: ?*u32,
            ppwz_fragment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: *const fn (
            self: *const IUriBuilder,
            pcch_host: ?*u32,
            ppwz_host: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: *const fn (
            self: *const IUriBuilder,
            pcch_password: ?*u32,
            ppwz_password: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: *const fn (
            self: *const IUriBuilder,
            pcch_path: ?*u32,
            ppwz_path: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: *const fn (
            self: *const IUriBuilder,
            pf_has_port: ?*BOOL,
            pdw_port: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: *const fn (
            self: *const IUriBuilder,
            pcch_query: ?*u32,
            ppwz_query: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: *const fn (
            self: *const IUriBuilder,
            pcch_scheme_name: ?*u32,
            ppwz_scheme_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: *const fn (
            self: *const IUriBuilder,
            pcch_user_name: ?*u32,
            ppwz_user_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFragment: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHost: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassword: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPort: *const fn (
            self: *const IUriBuilder,
            f_has_port: BOOL,
            dw_new_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuery: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSchemeName: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserName: *const fn (
            self: *const IUriBuilder,
            pwz_new_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProperties: *const fn (
            self: *const IUriBuilder,
            dw_property_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasBeenModified: *const fn (
            self: *const IUriBuilder,
            pf_modified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createUriSimple(self: *const T, dw_allow_encoding_property_mask_: u32, dw_reserved_: usize, pp_i_uri_: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUriSimple(@as(*const IUriBuilder, @ptrCast(self)), dw_allow_encoding_property_mask_, dw_reserved_, pp_i_uri_);
            }
            pub inline fn createUri(self: *const T, dw_create_flags_: u32, dw_allow_encoding_property_mask_: u32, dw_reserved_: usize, pp_i_uri_: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUri(@as(*const IUriBuilder, @ptrCast(self)), dw_create_flags_, dw_allow_encoding_property_mask_, dw_reserved_, pp_i_uri_);
            }
            pub inline fn createUriWithFlags(self: *const T, dw_create_flags_: u32, dw_uri_builder_flags_: u32, dw_allow_encoding_property_mask_: u32, dw_reserved_: usize, pp_i_uri_: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUriWithFlags(@as(*const IUriBuilder, @ptrCast(self)), dw_create_flags_, dw_uri_builder_flags_, dw_allow_encoding_property_mask_, dw_reserved_, pp_i_uri_);
            }
            pub inline fn getIUri(self: *const T, pp_i_uri_: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetIUri(@as(*const IUriBuilder, @ptrCast(self)), pp_i_uri_);
            }
            pub inline fn setIUri(self: *const T, p_i_uri_: ?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetIUri(@as(*const IUriBuilder, @ptrCast(self)), p_i_uri_);
            }
            pub inline fn getFragment(self: *const T, pcch_fragment_: ?*u32, ppwz_fragment_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetFragment(@as(*const IUriBuilder, @ptrCast(self)), pcch_fragment_, ppwz_fragment_);
            }
            pub inline fn getHost(self: *const T, pcch_host_: ?*u32, ppwz_host_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUriBuilder, @ptrCast(self)), pcch_host_, ppwz_host_);
            }
            pub inline fn getPassword(self: *const T, pcch_password_: ?*u32, ppwz_password_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPassword(@as(*const IUriBuilder, @ptrCast(self)), pcch_password_, ppwz_password_);
            }
            pub inline fn getPath(self: *const T, pcch_path_: ?*u32, ppwz_path_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IUriBuilder, @ptrCast(self)), pcch_path_, ppwz_path_);
            }
            pub inline fn getPort(self: *const T, pf_has_port_: ?*BOOL, pdw_port_: ?*u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPort(@as(*const IUriBuilder, @ptrCast(self)), pf_has_port_, pdw_port_);
            }
            pub inline fn getQuery(self: *const T, pcch_query_: ?*u32, ppwz_query_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IUriBuilder, @ptrCast(self)), pcch_query_, ppwz_query_);
            }
            pub inline fn getSchemeName(self: *const T, pcch_scheme_name_: ?*u32, ppwz_scheme_name_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetSchemeName(@as(*const IUriBuilder, @ptrCast(self)), pcch_scheme_name_, ppwz_scheme_name_);
            }
            pub inline fn getUserName(self: *const T, pcch_user_name_: ?*u32, ppwz_user_name_: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetUserName(@as(*const IUriBuilder, @ptrCast(self)), pcch_user_name_, ppwz_user_name_);
            }
            pub inline fn setFragment(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetFragment(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setHost(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetHost(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setPassword(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPassword(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setPath(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setPort(self: *const T, f_has_port_: BOOL, dw_new_value_: u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPort(@as(*const IUriBuilder, @ptrCast(self)), f_has_port_, dw_new_value_);
            }
            pub inline fn setQuery(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetQuery(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setSchemeName(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetSchemeName(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn setUserName(self: *const T, pwz_new_value_: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetUserName(@as(*const IUriBuilder, @ptrCast(self)), pwz_new_value_);
            }
            pub inline fn removeProperties(self: *const T, dw_property_mask_: u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).RemoveProperties(@as(*const IUriBuilder, @ptrCast(self)), dw_property_mask_);
            }
            pub inline fn hasBeenModified(self: *const T, pf_modified_: ?*BOOL) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).HasBeenModified(@as(*const IUriBuilder, @ptrCast(self)), pf_modified_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHost_Value = Guid.initString("fc4801a1-2ba9-11cf-a229-00aa003d7352");
pub const IID_IBindHost = &IID_IBindHost_Value;
pub const IBindHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMoniker: *const fn (
            self: *const IBindHost,
            sz_name: ?PWSTR,
            p_b_c: ?*IBindCtx,
            ppmk: ?*?*IMoniker,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToStorage: *const fn (
            self: *const IBindHost,
            p_mk: ?*IMoniker,
            p_b_c: ?*IBindCtx,
            p_b_s_c: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToObject: *const fn (
            self: *const IBindHost,
            p_mk: ?*IMoniker,
            p_b_c: ?*IBindCtx,
            p_b_s_c: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createMoniker(self: *const T, sz_name_: ?PWSTR, p_b_c_: ?*IBindCtx, ppmk_: ?*?*IMoniker, dw_reserved_: u32) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).CreateMoniker(@as(*const IBindHost, @ptrCast(self)), sz_name_, p_b_c_, ppmk_, dw_reserved_);
            }
            pub inline fn monikerBindToStorage(self: *const T, p_mk_: ?*IMoniker, p_b_c_: ?*IBindCtx, p_b_s_c_: ?*IBindStatusCallback, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).MonikerBindToStorage(@as(*const IBindHost, @ptrCast(self)), p_mk_, p_b_c_, p_b_s_c_, riid_, ppv_obj_);
            }
            pub inline fn monikerBindToObject(self: *const T, p_mk_: ?*IMoniker, p_b_c_: ?*IBindCtx, p_b_s_c_: ?*IBindStatusCallback, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).MonikerBindToObject(@as(*const IBindHost, @ptrCast(self)), p_mk_, p_b_c_, p_b_s_c_, riid_, ppv_obj_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SAFEARRAYBOUND = extern struct {
    cElements: u32,
    lLbound: i32,
};

pub const SAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    pvData: ?*anyopaque,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const VARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                llVal: i64,
                lVal: i32,
                bVal: u8,
                iVal: i16,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                bstrVal: ?BSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                parray: ?*SAFEARRAY,
                pbVal: ?*u8,
                piVal: ?*i16,
                plVal: ?*i32,
                pllVal: ?*i64,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                __OBSOLETE__VARIANT_PBOOL: ?*i16,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*VARIANT,
                byref: ?*anyopaque,
                cVal: CHAR,
                uiVal: u16,
                ulVal: u32,
                ullVal: u64,
                intVal: i32,
                uintVal: u32,
                pdecVal: ?*DECIMAL,
                pcVal: ?PSTR,
                puiVal: ?*u16,
                pulVal: ?*u32,
                pullVal: ?*u64,
                pintVal: ?*i32,
                puintVal: ?*u32,
                Anonymous: extern struct {
                    pvRecord: ?*anyopaque,
                    pRecInfo: ?*IRecordInfo,
                },
            },
        },
        decVal: DECIMAL,
    },
};

pub const TYPEKIND = enum(i32) {
    ENUM = 0,
    RECORD = 1,
    MODULE = 2,
    INTERFACE = 3,
    DISPATCH = 4,
    COCLASS = 5,
    ALIAS = 6,
    UNION = 7,
    MAX = 8,
};
pub const TKIND_ENUM = TYPEKIND.ENUM;
pub const TKIND_RECORD = TYPEKIND.RECORD;
pub const TKIND_MODULE = TYPEKIND.MODULE;
pub const TKIND_INTERFACE = TYPEKIND.INTERFACE;
pub const TKIND_DISPATCH = TYPEKIND.DISPATCH;
pub const TKIND_COCLASS = TYPEKIND.COCLASS;
pub const TKIND_ALIAS = TYPEKIND.ALIAS;
pub const TKIND_UNION = TYPEKIND.UNION;
pub const TKIND_MAX = TYPEKIND.MAX;

pub const TYPEDESC = extern struct {
    Anonymous: extern union {
        lptdesc: ?*TYPEDESC,
        lpadesc: ?*ARRAYDESC,
        hreftype: u32,
    },
    vt: u16,
};

pub const IDLDESC = extern struct {
    dwReserved: usize,
    wIDLFlags: u16,
};

pub const ELEMDESC = extern struct {
    tdesc: TYPEDESC,
    Anonymous: extern union {
        idldesc: IDLDESC,
        paramdesc: PARAMDESC,
    },
};

pub const TYPEATTR = extern struct {
    guid: Guid,
    lcid: u32,
    dwReserved: u32,
    memidConstructor: i32,
    memidDestructor: i32,
    lpstrSchema: ?PWSTR,
    cbSizeInstance: u32,
    typekind: TYPEKIND,
    cFuncs: u16,
    cVars: u16,
    cImplTypes: u16,
    cbSizeVft: u16,
    cbAlignment: u16,
    wTypeFlags: u16,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};

pub const DISPPARAMS = extern struct {
    rgvarg: ?*VARIANT,
    rgdispidNamedArgs: ?*i32,
    cArgs: u32,
    cNamedArgs: u32,
};

pub const EXCEPINFO = extern struct {
    wCode: u16,
    wReserved: u16,
    bstrSource: ?BSTR,
    bstrDescription: ?BSTR,
    bstrHelpFile: ?BSTR,
    dwHelpContext: u32,
    pvReserved: ?*anyopaque,
    pfnDeferredFillIn: ?LPEXCEPFINO_DEFERRED_FILLIN,
    scode: i32,
};

pub const CALLCONV = enum(i32) {
    FASTCALL = 0,
    CDECL = 1,
    MSCPASCAL = 2,
    // PASCAL = 2, this enum value conflicts with MSCPASCAL
    MACPASCAL = 3,
    STDCALL = 4,
    FPFASTCALL = 5,
    SYSCALL = 6,
    MPWCDECL = 7,
    MPWPASCAL = 8,
    MAX = 9,
};
pub const CC_FASTCALL = CALLCONV.FASTCALL;
pub const CC_CDECL = CALLCONV.CDECL;
pub const CC_MSCPASCAL = CALLCONV.MSCPASCAL;
pub const CC_PASCAL = CALLCONV.MSCPASCAL;
pub const CC_MACPASCAL = CALLCONV.MACPASCAL;
pub const CC_STDCALL = CALLCONV.STDCALL;
pub const CC_FPFASTCALL = CALLCONV.FPFASTCALL;
pub const CC_SYSCALL = CALLCONV.SYSCALL;
pub const CC_MPWCDECL = CALLCONV.MPWCDECL;
pub const CC_MPWPASCAL = CALLCONV.MPWPASCAL;
pub const CC_MAX = CALLCONV.MAX;

pub const FUNCKIND = enum(i32) {
    VIRTUAL = 0,
    PUREVIRTUAL = 1,
    NONVIRTUAL = 2,
    STATIC = 3,
    DISPATCH = 4,
};
pub const FUNC_VIRTUAL = FUNCKIND.VIRTUAL;
pub const FUNC_PUREVIRTUAL = FUNCKIND.PUREVIRTUAL;
pub const FUNC_NONVIRTUAL = FUNCKIND.NONVIRTUAL;
pub const FUNC_STATIC = FUNCKIND.STATIC;
pub const FUNC_DISPATCH = FUNCKIND.DISPATCH;

pub const INVOKEKIND = enum(i32) {
    FUNC = 1,
    PROPERTYGET = 2,
    PROPERTYPUT = 4,
    PROPERTYPUTREF = 8,
};
pub const INVOKE_FUNC = INVOKEKIND.FUNC;
pub const INVOKE_PROPERTYGET = INVOKEKIND.PROPERTYGET;
pub const INVOKE_PROPERTYPUT = INVOKEKIND.PROPERTYPUT;
pub const INVOKE_PROPERTYPUTREF = INVOKEKIND.PROPERTYPUTREF;

pub const FUNCDESC = extern struct {
    memid: i32,
    lprgscode: ?*i32,
    lprgelemdescParam: ?*ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: i16,
    cParamsOpt: i16,
    oVft: i16,
    cScodes: i16,
    elemdescFunc: ELEMDESC,
    wFuncFlags: u16,
};

pub const VARKIND = enum(i32) {
    PERINSTANCE = 0,
    STATIC = 1,
    CONST = 2,
    DISPATCH = 3,
};
pub const VAR_PERINSTANCE = VARKIND.PERINSTANCE;
pub const VAR_STATIC = VARKIND.STATIC;
pub const VAR_CONST = VARKIND.CONST;
pub const VAR_DISPATCH = VARKIND.DISPATCH;

pub const VARDESC = extern struct {
    memid: i32,
    lpstrSchema: ?PWSTR,
    Anonymous: extern union {
        oInst: u32,
        lpvarValue: ?*VARIANT,
    },
    elemdescVar: ELEMDESC,
    wVarFlags: u16,
    varkind: VARKIND,
};

pub const CUSTDATAITEM = extern struct {
    guid: Guid,
    varValue: VARIANT,
};

pub const CUSTDATA = extern struct {
    cCustData: u32,
    prgCustData: ?*CUSTDATAITEM,
};

const IID_IDispatch_Value = Guid.initString("00020400-0000-0000-c000-000000000046");
pub const IID_IDispatch = &IID_IDispatch_Value;
pub const IDispatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: *const fn (
            self: *const IDispatch,
            pctinfo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfo: *const fn (
            self: *const IDispatch,
            i_t_info: u32,
            lcid: u32,
            pp_t_info: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: *const fn (
            self: *const IDispatch,
            riid: ?*const Guid,
            rgsz_names: [*]?PWSTR,
            c_names: u32,
            lcid: u32,
            rg_disp_id: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: *const fn (
            self: *const IDispatch,
            disp_id_member: i32,
            riid: ?*const Guid,
            lcid: u32,
            w_flags: u16,
            p_disp_params: ?*DISPPARAMS,
            p_var_result: ?*VARIANT,
            p_excep_info: ?*EXCEPINFO,
            pu_arg_err: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTypeInfoCount(self: *const T, pctinfo_: ?*u32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetTypeInfoCount(@as(*const IDispatch, @ptrCast(self)), pctinfo_);
            }
            pub inline fn getTypeInfo(self: *const T, i_t_info_: u32, lcid_: u32, pp_t_info_: ?*?*ITypeInfo) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const IDispatch, @ptrCast(self)), i_t_info_, lcid_, pp_t_info_);
            }
            pub inline fn getIDsOfNames(self: *const T, riid_: ?*const Guid, rgsz_names_: [*]?PWSTR, c_names_: u32, lcid_: u32, rg_disp_id_: [*]i32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetIDsOfNames(@as(*const IDispatch, @ptrCast(self)), riid_, rgsz_names_, c_names_, lcid_, rg_disp_id_);
            }
            pub inline fn invoke(self: *const T, disp_id_member_: i32, riid_: ?*const Guid, lcid_: u32, w_flags_: u16, p_disp_params_: ?*DISPPARAMS, p_var_result_: ?*VARIANT, p_excep_info_: ?*EXCEPINFO, pu_arg_err_: ?*u32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IDispatch, @ptrCast(self)), disp_id_member_, riid_, lcid_, w_flags_, p_disp_params_, p_var_result_, p_excep_info_, pu_arg_err_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DESCKIND = enum(i32) {
    NONE = 0,
    FUNCDESC = 1,
    VARDESC = 2,
    TYPECOMP = 3,
    IMPLICITAPPOBJ = 4,
    MAX = 5,
};
pub const DESCKIND_NONE = DESCKIND.NONE;
pub const DESCKIND_FUNCDESC = DESCKIND.FUNCDESC;
pub const DESCKIND_VARDESC = DESCKIND.VARDESC;
pub const DESCKIND_TYPECOMP = DESCKIND.TYPECOMP;
pub const DESCKIND_IMPLICITAPPOBJ = DESCKIND.IMPLICITAPPOBJ;
pub const DESCKIND_MAX = DESCKIND.MAX;

pub const BINDPTR = extern union {
    lpfuncdesc: ?*FUNCDESC,
    lpvardesc: ?*VARDESC,
    lptcomp: ?*ITypeComp,
};

const IID_ITypeComp_Value = Guid.initString("00020403-0000-0000-c000-000000000046");
pub const IID_ITypeComp = &IID_ITypeComp_Value;
pub const ITypeComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: *const fn (
            self: *const ITypeComp,
            sz_name: ?PWSTR,
            l_hash_val: u32,
            w_flags: u16,
            pp_t_info: ?*?*ITypeInfo,
            p_desc_kind: ?*DESCKIND,
            p_bind_ptr: ?*BINDPTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindType: *const fn (
            self: *const ITypeComp,
            sz_name: ?PWSTR,
            l_hash_val: u32,
            pp_t_info: ?*?*ITypeInfo,
            pp_t_comp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn bind(self: *const T, sz_name_: ?PWSTR, l_hash_val_: u32, w_flags_: u16, pp_t_info_: ?*?*ITypeInfo, p_desc_kind_: ?*DESCKIND, p_bind_ptr_: ?*BINDPTR) HRESULT {
                return @as(*const ITypeComp.VTable, @ptrCast(self.vtable)).Bind(@as(*const ITypeComp, @ptrCast(self)), sz_name_, l_hash_val_, w_flags_, pp_t_info_, p_desc_kind_, p_bind_ptr_);
            }
            pub inline fn bindType(self: *const T, sz_name_: ?PWSTR, l_hash_val_: u32, pp_t_info_: ?*?*ITypeInfo, pp_t_comp_: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeComp.VTable, @ptrCast(self.vtable)).BindType(@as(*const ITypeComp, @ptrCast(self)), sz_name_, l_hash_val_, pp_t_info_, pp_t_comp_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo_Value = Guid.initString("00020401-0000-0000-c000-000000000046");
pub const IID_ITypeInfo = &IID_ITypeInfo_Value;
pub const ITypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeAttr: *const fn (
            self: *const ITypeInfo,
            pp_type_attr: ?*?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: *const fn (
            self: *const ITypeInfo,
            pp_t_comp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncDesc: *const fn (
            self: *const ITypeInfo,
            index: u32,
            pp_func_desc: ?*?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarDesc: *const fn (
            self: *const ITypeInfo,
            index: u32,
            pp_var_desc: ?*?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: *const fn (
            self: *const ITypeInfo,
            memid: i32,
            rg_bstr_names: [*]?BSTR,
            c_max_names: u32,
            pc_names: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeOfImplType: *const fn (
            self: *const ITypeInfo,
            index: u32,
            p_ref_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeFlags: *const fn (
            self: *const ITypeInfo,
            index: u32,
            p_impl_type_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: *const fn (
            self: *const ITypeInfo,
            rgsz_names: [*]?PWSTR,
            c_names: u32,
            p_mem_id: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: *const fn (
            self: *const ITypeInfo,
            pv_instance: ?*anyopaque,
            memid: i32,
            w_flags: u16,
            p_disp_params: ?*DISPPARAMS,
            p_var_result: ?*VARIANT,
            p_excep_info: ?*EXCEPINFO,
            pu_arg_err: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: *const fn (
            self: *const ITypeInfo,
            memid: i32,
            p_bstr_name: ?*?BSTR,
            p_bstr_doc_string: ?*?BSTR,
            pdw_help_context: ?*u32,
            p_bstr_help_file: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDllEntry: *const fn (
            self: *const ITypeInfo,
            memid: i32,
            inv_kind: INVOKEKIND,
            p_bstr_dll_name: ?*?BSTR,
            p_bstr_name: ?*?BSTR,
            pw_ordinal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeInfo: *const fn (
            self: *const ITypeInfo,
            h_ref_type: u32,
            pp_t_info: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddressOfMember: *const fn (
            self: *const ITypeInfo,
            memid: i32,
            inv_kind: INVOKEKIND,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: *const fn (
            self: *const ITypeInfo,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMops: *const fn (
            self: *const ITypeInfo,
            memid: i32,
            p_bstr_mops: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingTypeLib: *const fn (
            self: *const ITypeInfo,
            pp_t_lib: ?*?*ITypeLib,
            p_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTypeAttr: *const fn (
            self: *const ITypeInfo,
            p_type_attr: ?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseFuncDesc: *const fn (
            self: *const ITypeInfo,
            p_func_desc: ?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseVarDesc: *const fn (
            self: *const ITypeInfo,
            p_var_desc: ?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTypeAttr(self: *const T, pp_type_attr_: ?*?*TYPEATTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetTypeAttr(@as(*const ITypeInfo, @ptrCast(self)), pp_type_attr_);
            }
            pub inline fn getTypeComp(self: *const T, pp_t_comp_: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetTypeComp(@as(*const ITypeInfo, @ptrCast(self)), pp_t_comp_);
            }
            pub inline fn getFuncDesc(self: *const T, index_: u32, pp_func_desc_: ?*?*FUNCDESC) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetFuncDesc(@as(*const ITypeInfo, @ptrCast(self)), index_, pp_func_desc_);
            }
            pub inline fn getVarDesc(self: *const T, index_: u32, pp_var_desc_: ?*?*VARDESC) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetVarDesc(@as(*const ITypeInfo, @ptrCast(self)), index_, pp_var_desc_);
            }
            pub inline fn getNames(self: *const T, memid_: i32, rg_bstr_names_: [*]?BSTR, c_max_names_: u32, pc_names_: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetNames(@as(*const ITypeInfo, @ptrCast(self)), memid_, rg_bstr_names_, c_max_names_, pc_names_);
            }
            pub inline fn getRefTypeOfImplType(self: *const T, index_: u32, p_ref_type_: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetRefTypeOfImplType(@as(*const ITypeInfo, @ptrCast(self)), index_, p_ref_type_);
            }
            pub inline fn getImplTypeFlags(self: *const T, index_: u32, p_impl_type_flags_: ?*i32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetImplTypeFlags(@as(*const ITypeInfo, @ptrCast(self)), index_, p_impl_type_flags_);
            }
            pub inline fn getIDsOfNames(self: *const T, rgsz_names_: [*]?PWSTR, c_names_: u32, p_mem_id_: [*]i32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetIDsOfNames(@as(*const ITypeInfo, @ptrCast(self)), rgsz_names_, c_names_, p_mem_id_);
            }
            pub inline fn invoke(self: *const T, pv_instance_: ?*anyopaque, memid_: i32, w_flags_: u16, p_disp_params_: ?*DISPPARAMS, p_var_result_: ?*VARIANT, p_excep_info_: ?*EXCEPINFO, pu_arg_err_: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ITypeInfo, @ptrCast(self)), pv_instance_, memid_, w_flags_, p_disp_params_, p_var_result_, p_excep_info_, pu_arg_err_);
            }
            pub inline fn getDocumentation(self: *const T, memid_: i32, p_bstr_name_: ?*?BSTR, p_bstr_doc_string_: ?*?BSTR, pdw_help_context_: ?*u32, p_bstr_help_file_: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetDocumentation(@as(*const ITypeInfo, @ptrCast(self)), memid_, p_bstr_name_, p_bstr_doc_string_, pdw_help_context_, p_bstr_help_file_);
            }
            pub inline fn getDllEntry(self: *const T, memid_: i32, inv_kind_: INVOKEKIND, p_bstr_dll_name_: ?*?BSTR, p_bstr_name_: ?*?BSTR, pw_ordinal_: ?*u16) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetDllEntry(@as(*const ITypeInfo, @ptrCast(self)), memid_, inv_kind_, p_bstr_dll_name_, p_bstr_name_, pw_ordinal_);
            }
            pub inline fn getRefTypeInfo(self: *const T, h_ref_type_: u32, pp_t_info_: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetRefTypeInfo(@as(*const ITypeInfo, @ptrCast(self)), h_ref_type_, pp_t_info_);
            }
            pub inline fn addressOfMember(self: *const T, memid_: i32, inv_kind_: INVOKEKIND, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).AddressOfMember(@as(*const ITypeInfo, @ptrCast(self)), memid_, inv_kind_, ppv_);
            }
            pub inline fn createInstance(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const ITypeInfo, @ptrCast(self)), p_unk_outer_, riid_, ppv_obj_);
            }
            pub inline fn getMops(self: *const T, memid_: i32, p_bstr_mops_: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetMops(@as(*const ITypeInfo, @ptrCast(self)), memid_, p_bstr_mops_);
            }
            pub inline fn getContainingTypeLib(self: *const T, pp_t_lib_: ?*?*ITypeLib, p_index_: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetContainingTypeLib(@as(*const ITypeInfo, @ptrCast(self)), pp_t_lib_, p_index_);
            }
            pub inline fn releaseTypeAttr(self: *const T, p_type_attr_: ?*TYPEATTR) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseTypeAttr(@as(*const ITypeInfo, @ptrCast(self)), p_type_attr_);
            }
            pub inline fn releaseFuncDesc(self: *const T, p_func_desc_: ?*FUNCDESC) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseFuncDesc(@as(*const ITypeInfo, @ptrCast(self)), p_func_desc_);
            }
            pub inline fn releaseVarDesc(self: *const T, p_var_desc_: ?*VARDESC) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseVarDesc(@as(*const ITypeInfo, @ptrCast(self)), p_var_desc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo2_Value = Guid.initString("00020412-0000-0000-c000-000000000046");
pub const IID_ITypeInfo2 = &IID_ITypeInfo2_Value;
pub const ITypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeInfo.VTable,
        GetTypeKind: *const fn (
            self: *const ITypeInfo2,
            p_type_kind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeFlags: *const fn (
            self: *const ITypeInfo2,
            p_type_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncIndexOfMemId: *const fn (
            self: *const ITypeInfo2,
            memid: i32,
            inv_kind: INVOKEKIND,
            p_func_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarIndexOfMemId: *const fn (
            self: *const ITypeInfo2,
            memid: i32,
            p_var_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustData: *const fn (
            self: *const ITypeInfo2,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamCustData: *const fn (
            self: *const ITypeInfo2,
            index_func: u32,
            index_param: u32,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: *const fn (
            self: *const ITypeInfo2,
            memid: i32,
            lcid: u32,
            pbstr_help_string: ?*?BSTR,
            pdw_help_string_context: ?*u32,
            pbstr_help_string_dll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: *const fn (
            self: *const ITypeInfo2,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllFuncCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllParamCustData: *const fn (
            self: *const ITypeInfo2,
            index_func: u32,
            index_param: u32,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVarCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllImplTypeCustData: *const fn (
            self: *const ITypeInfo2,
            index: u32,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITypeInfo.MethodMixin(T);
            pub inline fn getTypeKind(self: *const T, p_type_kind_: ?*TYPEKIND) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetTypeKind(@as(*const ITypeInfo2, @ptrCast(self)), p_type_kind_);
            }
            pub inline fn getTypeFlags(self: *const T, p_type_flags_: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetTypeFlags(@as(*const ITypeInfo2, @ptrCast(self)), p_type_flags_);
            }
            pub inline fn getFuncIndexOfMemId(self: *const T, memid_: i32, inv_kind_: INVOKEKIND, p_func_index_: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetFuncIndexOfMemId(@as(*const ITypeInfo2, @ptrCast(self)), memid_, inv_kind_, p_func_index_);
            }
            pub inline fn getVarIndexOfMemId(self: *const T, memid_: i32, p_var_index_: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetVarIndexOfMemId(@as(*const ITypeInfo2, @ptrCast(self)), memid_, p_var_index_);
            }
            pub inline fn getCustData(self: *const T, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetCustData(@as(*const ITypeInfo2, @ptrCast(self)), guid_, p_var_val_);
            }
            pub inline fn getFuncCustData(self: *const T, index_: u32, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetFuncCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, guid_, p_var_val_);
            }
            pub inline fn getParamCustData(self: *const T, index_func_: u32, index_param_: u32, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetParamCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_func_, index_param_, guid_, p_var_val_);
            }
            pub inline fn getVarCustData(self: *const T, index_: u32, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetVarCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, guid_, p_var_val_);
            }
            pub inline fn getImplTypeCustData(self: *const T, index_: u32, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetImplTypeCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, guid_, p_var_val_);
            }
            pub inline fn getDocumentation2(self: *const T, memid_: i32, lcid_: u32, pbstr_help_string_: ?*?BSTR, pdw_help_string_context_: ?*u32, pbstr_help_string_dll_: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetDocumentation2(@as(*const ITypeInfo2, @ptrCast(self)), memid_, lcid_, pbstr_help_string_, pdw_help_string_context_, pbstr_help_string_dll_);
            }
            pub inline fn getAllCustData(self: *const T, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllCustData(@as(*const ITypeInfo2, @ptrCast(self)), p_cust_data_);
            }
            pub inline fn getAllFuncCustData(self: *const T, index_: u32, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllFuncCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, p_cust_data_);
            }
            pub inline fn getAllParamCustData(self: *const T, index_func_: u32, index_param_: u32, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllParamCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_func_, index_param_, p_cust_data_);
            }
            pub inline fn getAllVarCustData(self: *const T, index_: u32, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllVarCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, p_cust_data_);
            }
            pub inline fn getAllImplTypeCustData(self: *const T, index_: u32, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllImplTypeCustData(@as(*const ITypeInfo2, @ptrCast(self)), index_, p_cust_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYSKIND = enum(i32) {
    WIN16 = 0,
    WIN32 = 1,
    MAC = 2,
    WIN64 = 3,
};
pub const SYS_WIN16 = SYSKIND.WIN16;
pub const SYS_WIN32 = SYSKIND.WIN32;
pub const SYS_MAC = SYSKIND.MAC;
pub const SYS_WIN64 = SYSKIND.WIN64;

pub const TLIBATTR = extern struct {
    guid: Guid,
    lcid: u32,
    syskind: SYSKIND,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    wLibFlags: u16,
};

const IID_ITypeLib_Value = Guid.initString("00020402-0000-0000-c000-000000000046");
pub const IID_ITypeLib = &IID_ITypeLib_Value;
pub const ITypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: *const fn (
            self: *const ITypeLib,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetTypeInfo: *const fn (
            self: *const ITypeLib,
            index: u32,
            pp_t_info: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoType: *const fn (
            self: *const ITypeLib,
            index: u32,
            p_t_kind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoOfGuid: *const fn (
            self: *const ITypeLib,
            guid: ?*const Guid,
            pp_tinfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibAttr: *const fn (
            self: *const ITypeLib,
            pp_t_lib_attr: ?*?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: *const fn (
            self: *const ITypeLib,
            pp_t_comp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: *const fn (
            self: *const ITypeLib,
            index: i32,
            p_bstr_name: ?*?BSTR,
            p_bstr_doc_string: ?*?BSTR,
            pdw_help_context: ?*u32,
            p_bstr_help_file: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsName: *const fn (
            self: *const ITypeLib,
            sz_name_buf: ?PWSTR,
            l_hash_val: u32,
            pf_name: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindName: *const fn (
            self: *const ITypeLib,
            sz_name_buf: ?PWSTR,
            l_hash_val: u32,
            pp_t_info: [*]?*ITypeInfo,
            rg_mem_id: [*]i32,
            pc_found: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTLibAttr: *const fn (
            self: *const ITypeLib,
            p_t_lib_attr: ?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTypeInfoCount(self: *const T) u32 {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoCount(@as(*const ITypeLib, @ptrCast(self)));
            }
            pub inline fn getTypeInfo(self: *const T, index_: u32, pp_t_info_: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const ITypeLib, @ptrCast(self)), index_, pp_t_info_);
            }
            pub inline fn getTypeInfoType(self: *const T, index_: u32, p_t_kind_: ?*TYPEKIND) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoType(@as(*const ITypeLib, @ptrCast(self)), index_, p_t_kind_);
            }
            pub inline fn getTypeInfoOfGuid(self: *const T, guid_: ?*const Guid, pp_tinfo_: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoOfGuid(@as(*const ITypeLib, @ptrCast(self)), guid_, pp_tinfo_);
            }
            pub inline fn getLibAttr(self: *const T, pp_t_lib_attr_: ?*?*TLIBATTR) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetLibAttr(@as(*const ITypeLib, @ptrCast(self)), pp_t_lib_attr_);
            }
            pub inline fn getTypeComp(self: *const T, pp_t_comp_: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeComp(@as(*const ITypeLib, @ptrCast(self)), pp_t_comp_);
            }
            pub inline fn getDocumentation(self: *const T, index_: i32, p_bstr_name_: ?*?BSTR, p_bstr_doc_string_: ?*?BSTR, pdw_help_context_: ?*u32, p_bstr_help_file_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetDocumentation(@as(*const ITypeLib, @ptrCast(self)), index_, p_bstr_name_, p_bstr_doc_string_, pdw_help_context_, p_bstr_help_file_);
            }
            pub inline fn isName(self: *const T, sz_name_buf_: ?PWSTR, l_hash_val_: u32, pf_name_: ?*BOOL) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).IsName(@as(*const ITypeLib, @ptrCast(self)), sz_name_buf_, l_hash_val_, pf_name_);
            }
            pub inline fn findName(self: *const T, sz_name_buf_: ?PWSTR, l_hash_val_: u32, pp_t_info_: [*]?*ITypeInfo, rg_mem_id_: [*]i32, pc_found_: ?*u16) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).FindName(@as(*const ITypeLib, @ptrCast(self)), sz_name_buf_, l_hash_val_, pp_t_info_, rg_mem_id_, pc_found_);
            }
            pub inline fn releaseTLibAttr(self: *const T, p_t_lib_attr_: ?*TLIBATTR) void {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).ReleaseTLibAttr(@as(*const ITypeLib, @ptrCast(self)), p_t_lib_attr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLib2_Value = Guid.initString("00020411-0000-0000-c000-000000000046");
pub const IID_ITypeLib2 = &IID_ITypeLib2_Value;
pub const ITypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeLib.VTable,
        GetCustData: *const fn (
            self: *const ITypeLib2,
            guid: ?*const Guid,
            p_var_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibStatistics: *const fn (
            self: *const ITypeLib2,
            pc_unique_names: ?*u32,
            pcch_unique_names: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: *const fn (
            self: *const ITypeLib2,
            index: i32,
            lcid: u32,
            pbstr_help_string: ?*?BSTR,
            pdw_help_string_context: ?*u32,
            pbstr_help_string_dll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: *const fn (
            self: *const ITypeLib2,
            p_cust_data: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITypeLib.MethodMixin(T);
            pub inline fn getCustData(self: *const T, guid_: ?*const Guid, p_var_val_: ?*VARIANT) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetCustData(@as(*const ITypeLib2, @ptrCast(self)), guid_, p_var_val_);
            }
            pub inline fn getLibStatistics(self: *const T, pc_unique_names_: ?*u32, pcch_unique_names_: ?*u32) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetLibStatistics(@as(*const ITypeLib2, @ptrCast(self)), pc_unique_names_, pcch_unique_names_);
            }
            pub inline fn getDocumentation2(self: *const T, index_: i32, lcid_: u32, pbstr_help_string_: ?*?BSTR, pdw_help_string_context_: ?*u32, pbstr_help_string_dll_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetDocumentation2(@as(*const ITypeLib2, @ptrCast(self)), index_, lcid_, pbstr_help_string_, pdw_help_string_context_, pbstr_help_string_dll_);
            }
            pub inline fn getAllCustData(self: *const T, p_cust_data_: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetAllCustData(@as(*const ITypeLib2, @ptrCast(self)), p_cust_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorInfo_Value = Guid.initString("1cf2b120-547d-101b-8e65-08002b2bd119");
pub const IID_IErrorInfo = &IID_IErrorInfo_Value;
pub const IErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: *const fn (
            self: *const IErrorInfo,
            p_g_u_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: *const fn (
            self: *const IErrorInfo,
            p_bstr_source: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: *const fn (
            self: *const IErrorInfo,
            p_bstr_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpFile: *const fn (
            self: *const IErrorInfo,
            p_bstr_help_file: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpContext: *const fn (
            self: *const IErrorInfo,
            pdw_help_context: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getGUID(self: *const T, p_g_u_i_d_: ?*Guid) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const IErrorInfo, @ptrCast(self)), p_g_u_i_d_);
            }
            pub inline fn getSource(self: *const T, p_bstr_source_: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetSource(@as(*const IErrorInfo, @ptrCast(self)), p_bstr_source_);
            }
            pub inline fn getDescription(self: *const T, p_bstr_description_: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IErrorInfo, @ptrCast(self)), p_bstr_description_);
            }
            pub inline fn getHelpFile(self: *const T, p_bstr_help_file_: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetHelpFile(@as(*const IErrorInfo, @ptrCast(self)), p_bstr_help_file_);
            }
            pub inline fn getHelpContext(self: *const T, pdw_help_context_: ?*u32) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetHelpContext(@as(*const IErrorInfo, @ptrCast(self)), pdw_help_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISupportErrorInfo_Value = Guid.initString("df0b3d60-548f-101b-8e65-08002b2bd119");
pub const IID_ISupportErrorInfo = &IID_ISupportErrorInfo_Value;
pub const ISupportErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InterfaceSupportsErrorInfo: *const fn (
            self: *const ISupportErrorInfo,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn interfaceSupportsErrorInfo(self: *const T, riid_: ?*const Guid) HRESULT {
                return @as(*const ISupportErrorInfo.VTable, @ptrCast(self.vtable)).InterfaceSupportsErrorInfo(@as(*const ISupportErrorInfo, @ptrCast(self)), riid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLog_Value = Guid.initString("3127ca40-446e-11ce-8135-00aa004bb851");
pub const IID_IErrorLog = &IID_IErrorLog_Value;
pub const IErrorLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddError: *const fn (
            self: *const IErrorLog,
            psz_prop_name: ?[*:0]const u16,
            p_excep_info: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addError(self: *const T, psz_prop_name_: ?[*:0]const u16, p_excep_info_: ?*EXCEPINFO) HRESULT {
                return @as(*const IErrorLog.VTable, @ptrCast(self.vtable)).AddError(@as(*const IErrorLog, @ptrCast(self)), psz_prop_name_, p_excep_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistrationReader_Value = Guid.initString("ed6a8a2a-b160-4e77-8f73-aa7435cd5c27");
pub const IID_ITypeLibRegistrationReader = &IID_ITypeLibRegistrationReader_Value;
pub const ITypeLibRegistrationReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumTypeLibRegistrations: *const fn (
            self: *const ITypeLibRegistrationReader,
            pp_enum_unknown: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumTypeLibRegistrations(self: *const T, pp_enum_unknown_: ?*?*IEnumUnknown) HRESULT {
                return @as(*const ITypeLibRegistrationReader.VTable, @ptrCast(self.vtable)).EnumTypeLibRegistrations(@as(*const ITypeLibRegistrationReader, @ptrCast(self)), pp_enum_unknown_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistration_Value = Guid.initString("76a3e735-02df-4a12-98eb-043ad3600af3");
pub const IID_ITypeLibRegistration = &IID_ITypeLibRegistration_Value;
pub const ITypeLibRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuid: *const fn (
            self: *const ITypeLibRegistration,
            p_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn (
            self: *const ITypeLibRegistration,
            p_version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLcid: *const fn (
            self: *const ITypeLibRegistration,
            p_lcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin32Path: *const fn (
            self: *const ITypeLibRegistration,
            p_win32_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin64Path: *const fn (
            self: *const ITypeLibRegistration,
            p_win64_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: *const fn (
            self: *const ITypeLibRegistration,
            p_display_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: *const fn (
            self: *const ITypeLibRegistration,
            p_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpDir: *const fn (
            self: *const ITypeLibRegistration,
            p_help_dir: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getGuid(self: *const T, p_guid_: ?*Guid) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const ITypeLibRegistration, @ptrCast(self)), p_guid_);
            }
            pub inline fn getVersion(self: *const T, p_version_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ITypeLibRegistration, @ptrCast(self)), p_version_);
            }
            pub inline fn getLcid(self: *const T, p_lcid_: ?*u32) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetLcid(@as(*const ITypeLibRegistration, @ptrCast(self)), p_lcid_);
            }
            pub inline fn getWin32Path(self: *const T, p_win32_path_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetWin32Path(@as(*const ITypeLibRegistration, @ptrCast(self)), p_win32_path_);
            }
            pub inline fn getWin64Path(self: *const T, p_win64_path_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetWin64Path(@as(*const ITypeLibRegistration, @ptrCast(self)), p_win64_path_);
            }
            pub inline fn getDisplayName(self: *const T, p_display_name_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const ITypeLibRegistration, @ptrCast(self)), p_display_name_);
            }
            pub inline fn getFlags(self: *const T, p_flags_: ?*u32) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const ITypeLibRegistration, @ptrCast(self)), p_flags_);
            }
            pub inline fn getHelpDir(self: *const T, p_help_dir_: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetHelpDir(@as(*const ITypeLibRegistration, @ptrCast(self)), p_help_dir_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONNECTDATA = extern struct {
    pUnk: ?*IUnknown,
    dwCookie: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnections_Value = Guid.initString("b196b287-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnections = &IID_IEnumConnections_Value;
pub const IEnumConnections = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumConnections,
            c_connections: u32,
            rgcd: [*]CONNECTDATA,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumConnections,
            c_connections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumConnections,
            pp_enum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_connections_: u32, rgcd_: [*]CONNECTDATA, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumConnections, @ptrCast(self)), c_connections_, rgcd_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_connections_: u32) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumConnections, @ptrCast(self)), c_connections_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumConnections, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumConnections) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumConnections, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPoint_Value = Guid.initString("b196b286-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPoint = &IID_IConnectionPoint_Value;
pub const IConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectionInterface: *const fn (
            self: *const IConnectionPoint,
            p_i_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectionPointContainer: *const fn (
            self: *const IConnectionPoint,
            pp_c_p_c: ?*?*IConnectionPointContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn (
            self: *const IConnectionPoint,
            p_unk_sink: ?*IUnknown,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IConnectionPoint,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumConnections: *const fn (
            self: *const IConnectionPoint,
            pp_enum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getConnectionInterface(self: *const T, p_i_i_d_: ?*Guid) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).GetConnectionInterface(@as(*const IConnectionPoint, @ptrCast(self)), p_i_i_d_);
            }
            pub inline fn getConnectionPointContainer(self: *const T, pp_c_p_c_: ?*?*IConnectionPointContainer) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).GetConnectionPointContainer(@as(*const IConnectionPoint, @ptrCast(self)), pp_c_p_c_);
            }
            pub inline fn advise(self: *const T, p_unk_sink_: ?*IUnknown, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).Advise(@as(*const IConnectionPoint, @ptrCast(self)), p_unk_sink_, pdw_cookie_);
            }
            pub inline fn unadvise(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IConnectionPoint, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn enumConnections(self: *const T, pp_enum_: ?*?*IEnumConnections) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).EnumConnections(@as(*const IConnectionPoint, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnectionPoints_Value = Guid.initString("b196b285-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnectionPoints = &IID_IEnumConnectionPoints_Value;
pub const IEnumConnectionPoints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumConnectionPoints,
            c_connections: u32,
            pp_c_p: [*]?*IConnectionPoint,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumConnectionPoints,
            c_connections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumConnectionPoints,
            pp_enum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_connections_: u32, pp_c_p_: [*]?*IConnectionPoint, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumConnectionPoints, @ptrCast(self)), c_connections_, pp_c_p_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_connections_: u32) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumConnectionPoints, @ptrCast(self)), c_connections_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumConnectionPoints, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumConnectionPoints) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumConnectionPoints, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPointContainer_Value = Guid.initString("b196b284-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPointContainer = &IID_IConnectionPointContainer_Value;
pub const IConnectionPointContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnectionPoints: *const fn (
            self: *const IConnectionPointContainer,
            pp_enum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindConnectionPoint: *const fn (
            self: *const IConnectionPointContainer,
            riid: ?*const Guid,
            pp_c_p: ?*?*IConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumConnectionPoints(self: *const T, pp_enum_: ?*?*IEnumConnectionPoints) HRESULT {
                return @as(*const IConnectionPointContainer.VTable, @ptrCast(self.vtable)).EnumConnectionPoints(@as(*const IConnectionPointContainer, @ptrCast(self)), pp_enum_);
            }
            pub inline fn findConnectionPoint(self: *const T, riid_: ?*const Guid, pp_c_p_: ?*?*IConnectionPoint) HRESULT {
                return @as(*const IConnectionPointContainer.VTable, @ptrCast(self.vtable)).FindConnectionPoint(@as(*const IConnectionPointContainer, @ptrCast(self)), riid_, pp_c_p_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistMemory_Value = Guid.initString("bd1ae5e0-a6ae-11ce-bd37-504200c10000");
pub const IID_IPersistMemory = &IID_IPersistMemory_Value;
pub const IPersistMemory = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: *const fn (
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistMemory,
            p_mem: [*]u8,
            cb_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistMemory,
            p_mem: [*]u8,
            f_clear_dirty: BOOL,
            cb_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: *const fn (
            self: *const IPersistMemory,
            p_cb_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: *const fn (
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn isDirty(self: *const T) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistMemory, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, p_mem_: [*]u8, cb_size_: u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistMemory, @ptrCast(self)), p_mem_, cb_size_);
            }
            pub inline fn save(self: *const T, p_mem_: [*]u8, f_clear_dirty_: BOOL, cb_size_: u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistMemory, @ptrCast(self)), p_mem_, f_clear_dirty_, cb_size_);
            }
            pub inline fn getSizeMax(self: *const T, p_cb_size_: ?*u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistMemory, @ptrCast(self)), p_cb_size_);
            }
            pub inline fn initNew(self: *const T) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistMemory, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStreamInit_Value = Guid.initString("7fd52380-4e07-101b-ae2d-08002b2ec713");
pub const IID_IPersistStreamInit = &IID_IPersistStreamInit_Value;
pub const IPersistStreamInit = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: *const fn (
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistStreamInit,
            p_stm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistStreamInit,
            p_stm: ?*IStream,
            f_clear_dirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: *const fn (
            self: *const IPersistStreamInit,
            p_cb_size: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: *const fn (
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn isDirty(self: *const T) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStreamInit, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, p_stm_: ?*IStream) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStreamInit, @ptrCast(self)), p_stm_);
            }
            pub inline fn save(self: *const T, p_stm_: ?*IStream, f_clear_dirty_: BOOL) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStreamInit, @ptrCast(self)), p_stm_, f_clear_dirty_);
            }
            pub inline fn getSizeMax(self: *const T, p_cb_size_: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistStreamInit, @ptrCast(self)), p_cb_size_);
            }
            pub inline fn initNew(self: *const T) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistStreamInit, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (110)
//--------------------------------------------------------------------------------
pub extern "ole32" fn CoBuildVersion() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitialize(
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterMallocSpy(
    p_malloc_spy: ?*IMallocSpy,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeMallocSpy() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoRegisterInitializeSpy(
    p_spy: ?*IInitializeSpy,
    puli_cookie: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeInitializeSpy(
    uli_cookie: ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetSystemSecurityPermissions(
    com_s_d_type: COMSD,
    pp_s_d: ?*?PSECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoLoadLibrary(
    lpsz_lib_name: ?PWSTR,
    b_auto_free: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeLibrary(
    h_inst: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeAllLibraries() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoAllowSetForegroundWindow(
    p_unk: ?*IUnknown,
    lpv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn DcomChannelSetHResult(
    pv_reserved: ?*anyopaque,
    pul_reserved: ?*u32,
    apps_h_r: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsOle1Class(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromProgIDEx(
    lpsz_prog_i_d: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFileTimeToDosDateTime(
    lp_file_time: ?*FILETIME,
    lp_dos_date: ?*u16,
    lp_dos_time: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDosDateTimeToFileTime(
    n_dos_date: u16,
    n_dos_time: u16,
    lp_file_time: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFileTimeNow(
    lp_file_time: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRegisterChannelHook(
    extension_uuid: ?*const Guid,
    p_channel_hook: ?*IChannelHook,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTreatAsClass(
    clsid_old: ?*const Guid,
    clsid_new: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateDataAdviseHolder(
    pp_d_a_holder: ?*?*IDataAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateDataCache(
    p_unk_outer: ?*IUnknown,
    rclsid: ?*const Guid,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoInstall(
    pbc: ?*IBindCtx,
    dw_flags: u32,
    p_class_spec: ?*uCLSSPEC,
    p_query: ?*QUERYCONTEXT,
    psz_code_base: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn BindMoniker(
    pmk: ?*IMoniker,
    grf_opt: u32,
    iid_result: ?*const Guid,
    ppv_result: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetObject(
    psz_name: ?[*:0]const u16,
    p_bind_options: ?*BIND_OPTS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MkParseDisplayName(
    pbc: ?*IBindCtx,
    sz_user_name: ?[*:0]const u16,
    pch_eaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerRelativePathTo(
    pmk_src: ?*IMoniker,
    pmk_dest: ?*IMoniker,
    ppmk_rel_path: ?*?*IMoniker,
    dw_reserved: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerCommonPrefixWith(
    pmk_this: ?*IMoniker,
    pmk_other: ?*IMoniker,
    ppmk_common: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateBindCtx(
    reserved: u32,
    ppbc: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateGenericComposite(
    pmk_first: ?*IMoniker,
    pmk_rest: ?*IMoniker,
    ppmk_composite: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetClassFile(
    sz_filename: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateClassMoniker(
    rclsid: ?*const Guid,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateFileMoniker(
    lpsz_path_name: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateItemMoniker(
    lpsz_delim: ?[*:0]const u16,
    lpsz_item: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateAntiMoniker(
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreatePointerMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateObjrefMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetRunningObjectTable(
    reserved: u32,
    pprot: ?*?*IRunningObjectTable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CreateStdProgressIndicator(
    hwnd_parent: ?HWND,
    psz_title: ?[*:0]const u16,
    p_ibsc_caller: ?*IBindStatusCallback,
    pp_ibsc: ?*?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetMalloc(
    dw_mem_context: u32,
    pp_malloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoUninitialize() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCurrentProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitializeEx(
    pv_reserved: ?*anyopaque,
    dw_co_init: COINIT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCallerTID(
    lpdw_t_i_d: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCurrentLogicalThreadId(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetContextToken(
    p_token: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ole32" fn CoGetApartmentType(
    p_apt_type: ?*APTTYPE,
    p_apt_qualifier: ?*APTTYPEQUALIFIER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoIncrementMTAUsage(
    p_cookie: ?*CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoDecrementMTAUsage(
    cookie: CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ole32" fn CoAllowUnmarshalerCLSID(
    clsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetObjectContext(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetClassObject(
    rclsid: ?*const Guid,
    dw_cls_context: CLSCTX,
    pv_reserved: ?*anyopaque,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterClassObject(
    rclsid: ?*const Guid,
    p_unk: ?*IUnknown,
    dw_cls_context: CLSCTX,
    flags: REGCLS,
    lpdw_register: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeClassObject(
    dw_register: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoResumeClassObjects() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSuspendClassObjects() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoAddRefServerProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoReleaseServerProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetPSClsid(
    riid: ?*const Guid,
    p_clsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterPSClsid(
    riid: ?*const Guid,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterSurrogate(
    p_surrogate: ?*ISurrogate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDisconnectObject(
    p_unk: ?*IUnknown,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoLockObjectExternal(
    p_unk: ?*IUnknown,
    f_lock: BOOL,
    f_last_unlock_releases: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsHandlerConnected(
    p_unk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateFreeThreadedMarshaler(
    punk_outer: ?*IUnknown,
    ppunk_marshal: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeUnusedLibraries() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoFreeUnusedLibrariesEx(
    dw_unload_delay: u32,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ole32" fn CoDisconnectContext(
    dw_timeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitializeSecurity(
    p_sec_desc: ?PSECURITY_DESCRIPTOR,
    c_auth_svc: i32,
    as_auth_svc: ?*SOLE_AUTHENTICATION_SERVICE,
    p_reserved1: ?*anyopaque,
    dw_authn_level: RPC_C_AUTHN_LEVEL,
    dw_imp_level: RPC_C_IMP_LEVEL,
    p_auth_list: ?*anyopaque,
    dw_capabilities: EOLE_AUTHENTICATION_CAPABILITIES,
    p_reserved3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCallContext(
    riid: ?*const Guid,
    pp_interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryProxyBlanket(
    p_proxy: ?*IUnknown,
    pw_authn_svc: ?*u32,
    p_authz_svc: ?*u32,
    p_server_princ_name: ?*?PWSTR,
    p_authn_level: ?*u32,
    p_imp_level: ?*u32,
    p_auth_info: ?*?*anyopaque,
    p_capabilites: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSetProxyBlanket(
    p_proxy: ?*IUnknown,
    dw_authn_svc: u32,
    dw_authz_svc: u32,
    p_server_princ_name: ?PWSTR,
    dw_authn_level: RPC_C_AUTHN_LEVEL,
    dw_imp_level: RPC_C_IMP_LEVEL,
    p_auth_info: ?*anyopaque,
    dw_capabilities: EOLE_AUTHENTICATION_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCopyProxy(
    p_proxy: ?*IUnknown,
    pp_copy: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryClientBlanket(
    p_authn_svc: ?*u32,
    p_authz_svc: ?*u32,
    p_server_princ_name: ?*?PWSTR,
    p_authn_level: ?*u32,
    p_imp_level: ?*u32,
    p_privs: ?*?*anyopaque,
    p_capabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoImpersonateClient() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevertToSelf() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryAuthenticationServices(
    pc_auth_svc: ?*u32,
    as_auth_svc: ?*?*SOLE_AUTHENTICATION_SERVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSwitchCallContext(
    p_new_object: ?*IUnknown,
    pp_old_object: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateInstance(
    rclsid: ?*const Guid,
    p_unk_outer: ?*IUnknown,
    dw_cls_context: CLSCTX,
    riid: *const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateInstanceEx(
    clsid: ?*const Guid,
    punk_outer: ?*IUnknown,
    dw_cls_ctx: CLSCTX,
    p_server_info: ?*COSERVERINFO,
    dw_count: u32,
    p_results: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ole32" fn CoCreateInstanceFromApp(
    clsid: ?*const Guid,
    punk_outer: ?*IUnknown,
    dw_cls_ctx: CLSCTX,
    reserved: ?*anyopaque,
    dw_count: u32,
    p_results: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoRegisterActivationFilter(
    p_activation_filter: ?*IActivationFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCancelObject(
    dw_thread_id: u32,
    iid: ?*const Guid,
    pp_unk: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSetCancelObject(
    p_unk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCancelCall(
    dw_thread_id: u32,
    ul_timeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTestCancel() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoEnableCallCancellation(
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDisableCallCancellation(
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromCLSID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromString(
    lpsz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromIID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn IIDFromString(
    lpsz: ?[*:0]const u16,
    lpiid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ProgIDFromCLSID(
    clsid: ?*const Guid,
    lplpsz_prog_i_d: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromProgID(
    lpsz_prog_i_d: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromGUID2(
    rguid: ?*const Guid,
    lpsz: [*:0]u16,
    cch_max: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateGuid(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoWaitForMultipleHandles(
    dw_flags: u32,
    dw_timeout: u32,
    c_handles: u32,
    p_handles: [*]?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoWaitForMultipleObjects(
    dw_flags: u32,
    dw_timeout: u32,
    c_handles: u32,
    p_handles: [*]const ?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetTreatAsClass(
    clsid_old: ?*const Guid,
    p_clsid_new: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoInvalidateRemoteMachineBindings(
    psz_machine_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemRealloc(
    pv: ?*anyopaque,
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn CoRegisterDeviceCatalog(
    device_instance_id: ?[*:0]const u16,
    cookie: ?*CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRevokeDeviceCatalog(
    cookie: CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUri(
    pwz_u_r_i: ?[*:0]const u16,
    dw_flags: URI_CREATE_FLAGS,
    dw_reserved: usize,
    pp_u_r_i: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriWithFragment(
    pwz_u_r_i: ?[*:0]const u16,
    pwz_fragment: ?[*:0]const u16,
    dw_flags: u32,
    dw_reserved: usize,
    pp_u_r_i: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriFromMultiByteString(
    psz_a_n_s_i_input_uri: ?[*:0]const u8,
    dw_encoding_flags: u32,
    dw_code_page: u32,
    dw_create_flags: u32,
    dw_reserved: usize,
    pp_uri: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateIUriBuilder(
    p_i_uri: ?*IUri,
    dw_flags: u32,
    dw_reserved: usize,
    pp_i_uri_builder: ?*?*IUriBuilder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SetErrorInfo(
    dw_reserved: u32,
    perrinfo: ?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetErrorInfo(
    dw_reserved: u32,
    pperrinfo: ?*?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (28)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ARRAYDESC = @import("../system/ole.zig").ARRAYDESC;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const DECIMAL = @import("../foundation.zig").DECIMAL;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HENHMETAFILE = @import("../graphics/gdi.zig").HENHMETAFILE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IRecordInfo = @import("../system/ole.zig").IRecordInfo;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PARAMDESC = @import("../system/ole.zig").PARAMDESC;
const PSECURITY_DESCRIPTOR = @import("../security.zig").PSECURITY_DESCRIPTOR;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const STGC = @import("../system/com/structured_storage.zig").STGC;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;
const userHBITMAP = @import("../system/system_services.zig").userHBITMAP;
const userHENHMETAFILE = @import("../system/system_services.zig").userHENHMETAFILE;
const userHGLOBAL = @import("../system/system_services.zig").userHGLOBAL;
const userHMETAFILEPICT = @import("../system/system_services.zig").userHMETAFILEPICT;
const userHPALETTE = @import("../system/system_services.zig").userHPALETTE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNGETCLASSOBJECT")) {
        _ = LPFNGETCLASSOBJECT;
    }
    if (@hasDecl(@This(), "LPFNCANUNLOADNOW")) {
        _ = LPFNCANUNLOADNOW;
    }
    if (@hasDecl(@This(), "PFNCONTEXTCALL")) {
        _ = PFNCONTEXTCALL;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (7)
//--------------------------------------------------------------------------------
pub const call_obj = @import("com/call_obj.zig");
pub const channel_credentials = @import("com/channel_credentials.zig");
pub const events = @import("com/events.zig");
pub const marshal = @import("com/marshal.zig");
pub const structured_storage = @import("com/structured_storage.zig");
pub const ui = @import("com/ui.zig");
pub const urlmon = @import("com/urlmon.zig");
