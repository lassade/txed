//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (218)
//--------------------------------------------------------------------------------
pub const PROP_ID_SECURE_MIN = @as(u32, 26608);
pub const PROP_ID_SECURE_MAX = @as(u32, 26623);
pub const MAPI_DIM = @as(u32, 1);
pub const fMapiUnicode = @as(u32, 0);
pub const hrSuccess = @as(u32, 0);
pub const MAPI_P1 = @as(u32, 268435456);
pub const MAPI_SUBMITTED = @as(u32, 2147483648);
pub const MAPI_SHORTTERM = @as(u32, 128);
pub const MAPI_NOTRECIP = @as(u32, 64);
pub const MAPI_THISSESSION = @as(u32, 32);
pub const MAPI_NOW = @as(u32, 16);
pub const MAPI_NOTRESERVED = @as(u32, 8);
pub const MAPI_COMPOUND = @as(u32, 128);
pub const cchProfileNameMax = @as(u32, 64);
pub const cchProfilePassMax = @as(u32, 64);
pub const MV_FLAG = @as(u32, 4096);
pub const PROP_ID_NULL = @as(u32, 0);
pub const PROP_ID_INVALID = @as(u32, 65535);
pub const MV_INSTANCE = @as(u32, 8192);
pub const TABLE_CHANGED = @as(u32, 1);
pub const TABLE_ERROR = @as(u32, 2);
pub const TABLE_ROW_ADDED = @as(u32, 3);
pub const TABLE_ROW_DELETED = @as(u32, 4);
pub const TABLE_ROW_MODIFIED = @as(u32, 5);
pub const TABLE_SORT_DONE = @as(u32, 6);
pub const TABLE_RESTRICT_DONE = @as(u32, 7);
pub const TABLE_SETCOL_DONE = @as(u32, 8);
pub const TABLE_RELOAD = @as(u32, 9);
pub const szMAPINotificationMsg = "MAPI Notify window message";
pub const MAPI_ERROR_VERSION = @as(i32, 0);
pub const MAPI_USE_DEFAULT = @as(u32, 64);
pub const MNID_ID = @as(u32, 0);
pub const MNID_STRING = @as(u32, 1);
pub const WAB_LOCAL_CONTAINERS = @as(u32, 1048576);
pub const WAB_PROFILE_CONTENTS = @as(u32, 2097152);
pub const WAB_IGNORE_PROFILES = @as(u32, 8388608);
pub const MAPI_ONE_OFF_NO_RICH_INFO = @as(u32, 1);
pub const UI_SERVICE = @as(u32, 2);
pub const SERVICE_UI_ALWAYS = @as(u32, 2);
pub const SERVICE_UI_ALLOWED = @as(u32, 16);
pub const UI_CURRENT_PROVIDER_FIRST = @as(u32, 4);
pub const WABOBJECT_LDAPURL_RETURN_MAILUSER = @as(u32, 1);
pub const WABOBJECT_ME_NEW = @as(u32, 1);
pub const WABOBJECT_ME_NOCREATE = @as(u32, 2);
pub const WAB_VCARD_FILE = @as(u32, 0);
pub const WAB_VCARD_STREAM = @as(u32, 1);
pub const WAB_USE_OE_SENDMAIL = @as(u32, 1);
pub const WAB_ENABLE_PROFILES = @as(u32, 4194304);
pub const WAB_DISPLAY_LDAPURL = @as(u32, 1);
pub const WAB_CONTEXT_ADRLIST = @as(u32, 2);
pub const WAB_DISPLAY_ISNTDS = @as(u32, 4);
pub const WAB_DLL_NAME = "WAB32.DLL";
pub const WAB_DLL_PATH_KEY = "Software\\Microsoft\\WAB\\DLLPath";
pub const E_IMAPI_REQUEST_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600702));
pub const E_IMAPI_RECORDER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600701));
pub const S_IMAPI_SPEEDADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141124));
pub const S_IMAPI_ROTATIONADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141125));
pub const S_IMAPI_BOTHADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141126));
pub const E_IMAPI_BURN_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600697));
pub const S_IMAPI_COMMAND_HAS_SENSE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141632));
pub const E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600191));
pub const E_IMAPI_RECORDER_MEDIA_NO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600190));
pub const E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600189));
pub const E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600188));
pub const E_IMAPI_RECORDER_MEDIA_BECOMING_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600187));
pub const E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600186));
pub const E_IMAPI_RECORDER_MEDIA_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600185));
pub const E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600184));
pub const E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600183));
pub const E_IMAPI_RECORDER_NO_SUCH_FEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600182));
pub const E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600181));
pub const E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600180));
pub const E_IMAPI_RECORDER_COMMAND_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600179));
pub const E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600178));
pub const E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600177));
pub const E_IMAPI_RECORDER_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600176));
pub const E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600175));
pub const E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600174));
pub const E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599937));
pub const E_IMAPI_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599936));
pub const E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599935));
pub const S_IMAPI_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141890));
pub const E_IMAPI_DF2DATA_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599680));
pub const E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599679));
pub const E_IMAPI_DF2DATA_INVALID_MEDIA_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599678));
pub const E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599677));
pub const E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599676));
pub const E_IMAPI_DF2DATA_MEDIA_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599675));
pub const E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599674));
pub const E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599673));
pub const E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599672));
pub const E_IMAPI_DF2TAO_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599424));
pub const E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599423));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599422));
pub const E_IMAPI_DF2TAO_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599421));
pub const E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599420));
pub const E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599419));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599418));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599417));
pub const E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599416));
pub const E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599415));
pub const E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599414));
pub const E_IMAPI_DF2TAO_INVALID_ISRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599413));
pub const E_IMAPI_DF2TAO_INVALID_MCN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599412));
pub const E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599411));
pub const E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599410));
pub const E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599409));
pub const E_IMAPI_DF2RAW_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599168));
pub const E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599167));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599166));
pub const E_IMAPI_DF2RAW_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599165));
pub const E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599164));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599162));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599161));
pub const E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599159));
pub const E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599158));
pub const E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599155));
pub const E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599154));
pub const E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599153));
pub const E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599152));
pub const E_IMAPI_ERASE_RECORDER_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340224));
pub const E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340223));
pub const E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340222));
pub const E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340221));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340220));
pub const E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340219));
pub const E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340218));
pub const E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340217));
pub const E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340216));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598391));
pub const E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598390));
pub const E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598389));
pub const E_IMAPI_RAW_IMAGE_IS_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339968));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339967));
pub const E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339966));
pub const E_IMAPI_RAW_IMAGE_NO_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339965));
pub const E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339964));
pub const E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339963));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339962));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339961));
pub const S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11143688));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339959));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339958));
pub const FACILITY_IMAPI2 = @as(u32, 170);
pub const IMAPI_E_FSI_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555392));
pub const IMAPI_E_INVALID_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555391));
pub const IMAPI_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555390));
pub const IMAPI_E_NO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555389));
pub const IMAPI_E_INVALID_VOLUME_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555388));
pub const IMAPI_E_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555387));
pub const IMAPI_E_FILE_SYSTEM_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555386));
pub const IMAPI_E_NOT_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555384));
pub const IMAPI_E_NOT_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555383));
pub const IMAPI_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555382));
pub const IMAPI_E_NOT_IN_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555381));
pub const IMAPI_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555376));
pub const IMAPI_E_RESTRICTED_NAME_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555375));
pub const IMAPI_E_DUP_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555374));
pub const IMAPI_E_NO_UNIQUE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555373));
pub const IMAPI_E_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555368));
pub const IMAPI_E_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555367));
pub const IMAPI_E_DIR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555366));
pub const IMAPI_E_IMAGE_SIZE_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555360));
pub const IMAPI_E_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555359));
pub const IMAPI_E_DATA_STREAM_INCONSISTENCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555352));
pub const IMAPI_E_DATA_STREAM_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555351));
pub const IMAPI_E_DATA_STREAM_CREATE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555350));
pub const IMAPI_E_DIRECTORY_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555349));
pub const IMAPI_E_TOO_MANY_DIRS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555344));
pub const IMAPI_E_ISO9660_LEVELS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555343));
pub const IMAPI_E_DATA_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555342));
pub const IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555341));
pub const IMAPI_E_STASHFILE_OPEN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555336));
pub const IMAPI_E_STASHFILE_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555335));
pub const IMAPI_E_STASHFILE_WRITE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555334));
pub const IMAPI_E_STASHFILE_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555333));
pub const IMAPI_E_INVALID_WORKING_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555328));
pub const IMAPI_E_WORKING_DIRECTORY_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555327));
pub const IMAPI_E_STASHFILE_MOVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555326));
pub const IMAPI_E_BOOT_IMAGE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555320));
pub const IMAPI_E_BOOT_OBJECT_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555319));
pub const IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555318));
pub const IMAPI_E_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555312));
pub const IMAPI_E_NO_SUPPORTED_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555311));
pub const IMAPI_E_FILE_SYSTEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555310));
pub const IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555309));
pub const IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555308));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555307));
pub const IMAPI_E_IMPORT_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555306));
pub const IMAPI_E_IMPORT_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555305));
pub const IMAPI_E_DISC_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555304));
pub const IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555303));
pub const IMAPI_E_UDF_NOT_WRITE_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555302));
pub const IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555301));
pub const IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555300));
pub const IMAPI_E_MULTISESSION_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555299));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555298));
pub const IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11186527));
pub const IMAPI_E_PROPERTY_NOT_ACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555296));
pub const IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555295));
pub const IMAPI_E_BAD_MULTISESSION_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555294));
pub const IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555293));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555136));
pub const IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555135));
pub const IMAPI_E_IMAGEMANAGER_NO_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555134));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555133));
pub const MAPI_E_CALL_FAILED = @as(i32, -2147467259);
pub const MAPI_E_NOT_ENOUGH_MEMORY = @as(i32, -2147024882);
pub const MAPI_E_INVALID_PARAMETER = @as(i32, -2147024809);
pub const MAPI_E_INTERFACE_NOT_SUPPORTED = @as(i32, -2147467262);
pub const MAPI_E_NO_ACCESS = @as(i32, -2147024891);
pub const TAD_ALL_ROWS = @as(u32, 1);
pub const PRILOWEST = @as(i32, -32768);
pub const PRIHIGHEST = @as(u32, 32767);
pub const PRIUSER = @as(u32, 0);
pub const OPENSTREAMONFILE = "OpenStreamOnFile";
pub const szHrDispatchNotifications = "HrDispatchNotifications";
pub const szScCreateConversationIndex = "ScCreateConversationIndex";

//--------------------------------------------------------------------------------
// Section: Types (129)
//--------------------------------------------------------------------------------
pub const ENTRYID = extern struct {
    abFlags: [4]u8,
    ab: [1]u8,
};

pub const MAPIUID = extern struct {
    ab: [16]u8,
};

pub const SPropTagArray = extern struct {
    cValues: u32,
    aulPropTag: [1]u32,
};

pub const SBinary = extern struct {
    cb: u32,
    lpb: ?*u8,
};

pub const SShortArray = extern struct {
    cValues: u32,
    lpi: ?*i16,
};

pub const SGuidArray = extern struct {
    cValues: u32,
    lpguid: ?*Guid,
};

pub const SRealArray = extern struct {
    cValues: u32,
    lpflt: ?*f32,
};

pub const SLongArray = extern struct {
    cValues: u32,
    lpl: ?*i32,
};

pub const SLargeIntegerArray = extern struct {
    cValues: u32,
    lpli: ?*LARGE_INTEGER,
};

pub const SDateTimeArray = extern struct {
    cValues: u32,
    lpft: ?*FILETIME,
};

pub const SAppTimeArray = extern struct {
    cValues: u32,
    lpat: ?*f64,
};

pub const SCurrencyArray = extern struct {
    cValues: u32,
    lpcur: ?*CY,
};

pub const SBinaryArray = extern struct {
    cValues: u32,
    lpbin: ?*SBinary,
};

pub const SDoubleArray = extern struct {
    cValues: u32,
    lpdbl: ?*f64,
};

pub const SWStringArray = extern struct {
    cValues: u32,
    lppszW: ?*?PWSTR,
};

pub const SLPSTRArray = extern struct {
    cValues: u32,
    lppszA: ?*?PSTR,
};

pub const _PV = extern union {
    i: i16,
    l: i32,
    ul: u32,
    flt: f32,
    dbl: f64,
    b: u16,
    cur: CY,
    at: f64,
    ft: FILETIME,
    lpszA: ?PSTR,
    bin: SBinary,
    lpszW: ?PWSTR,
    lpguid: ?*Guid,
    li: LARGE_INTEGER,
    MVi: SShortArray,
    MVl: SLongArray,
    MVflt: SRealArray,
    MVdbl: SDoubleArray,
    MVcur: SCurrencyArray,
    MVat: SAppTimeArray,
    MVft: SDateTimeArray,
    MVbin: SBinaryArray,
    MVszA: SLPSTRArray,
    MVszW: SWStringArray,
    MVguid: SGuidArray,
    MVli: SLargeIntegerArray,
    err: i32,
    x: i32,
};

pub const SPropValue = extern struct {
    ulPropTag: u32,
    dwAlignPad: u32,
    Value: _PV,
};

pub const SPropProblem = extern struct {
    ulIndex: u32,
    ulPropTag: u32,
    scode: i32,
};

pub const SPropProblemArray = extern struct {
    cProblem: u32,
    aProblem: [1]SPropProblem,
};

pub const FLATENTRY = extern struct {
    cb: u32,
    abEntry: [1]u8,
};

pub const FLATENTRYLIST = extern struct {
    cEntries: u32,
    cbEntries: u32,
    abEntries: [1]u8,
};

pub const MTSID = extern struct {
    cb: u32,
    ab: [1]u8,
};

pub const FLATMTSIDLIST = extern struct {
    cMTSIDs: u32,
    cbMTSIDs: u32,
    abMTSIDs: [1]u8,
};

pub const ADRENTRY = extern struct {
    ulReserved1: u32,
    cValues: u32,
    rgPropVals: ?*SPropValue,
};

pub const ADRLIST = extern struct {
    cEntries: u32,
    aEntries: [1]ADRENTRY,
};

pub const SRow = extern struct {
    ulAdrEntryPad: u32,
    cValues: u32,
    lpProps: ?*SPropValue,
};

pub const SRowSet = extern struct {
    cRows: u32,
    aRow: [1]SRow,
};

pub const LPALLOCATEBUFFER = *const fn (
    cb_size: u32,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPALLOCATEMORE = *const fn (
    cb_size: u32,
    lp_object: ?*anyopaque,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFREEBUFFER = *const fn (
    lp_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MAPIERROR = extern struct {
    ulVersion: u32,
    lpszError: ?*i8,
    lpszComponent: ?*i8,
    ulLowLevelError: u32,
    ulContext: u32,
};

pub const ERROR_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    scode: i32,
    ulFlags: u32,
    lpMAPIError: ?*MAPIERROR,
};

pub const NEWMAIL_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    ulFlags: u32,
    lpszMessageClass: ?*i8,
    ulMessageFlags: u32,
};

pub const OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    ulObjType: u32,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    cbOldID: u32,
    lpOldID: ?*ENTRYID,
    cbOldParentID: u32,
    lpOldParentID: ?*ENTRYID,
    lpPropTagArray: ?*SPropTagArray,
};

pub const TABLE_NOTIFICATION = extern struct {
    ulTableEvent: u32,
    hResult: HRESULT,
    propIndex: SPropValue,
    propPrior: SPropValue,
    row: SRow,
    ulPad: u32,
};

pub const EXTENDED_NOTIFICATION = extern struct {
    ulEvent: u32,
    cb: u32,
    pbEventParameters: ?*u8,
};

pub const STATUS_OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cValues: u32,
    lpPropVals: ?*SPropValue,
};

pub const NOTIFICATION = extern struct {
    ulEventType: u32,
    ulAlignPad: u32,
    info: extern union {
        err: ERROR_NOTIFICATION,
        newmail: NEWMAIL_NOTIFICATION,
        obj: OBJECT_NOTIFICATION,
        tab: TABLE_NOTIFICATION,
        ext: EXTENDED_NOTIFICATION,
        statobj: STATUS_OBJECT_NOTIFICATION,
    },
};

pub const IMAPIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: *const fn (
            self: *const IMAPIAdviseSink,
            c_notif: u32,
            lp_notifications: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onNotify(self: *const T, c_notif_: u32, lp_notifications_: ?*NOTIFICATION) u32 {
                return @as(*const IMAPIAdviseSink.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IMAPIAdviseSink, @ptrCast(self)), c_notif_, lp_notifications_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPNOTIFCALLBACK = *const fn (
    lpv_context: ?*anyopaque,
    c_notification: u32,
    lp_notifications: ?*NOTIFICATION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMAPIProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: *const fn (
            self: *const IMAPIProgress,
            ul_value: u32,
            ul_count: u32,
            ul_total: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: *const fn (
            self: *const IMAPIProgress,
            lpul_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMax: *const fn (
            self: *const IMAPIProgress,
            lpul_max: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMin: *const fn (
            self: *const IMAPIProgress,
            lpul_min: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLimits: *const fn (
            self: *const IMAPIProgress,
            lpul_min: ?*u32,
            lpul_max: ?*u32,
            lpul_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn progress(self: *const T, ul_value_: u32, ul_count_: u32, ul_total_: u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).Progress(@as(*const IMAPIProgress, @ptrCast(self)), ul_value_, ul_count_, ul_total_);
            }
            pub inline fn getFlags(self: *const T, lpul_flags_: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMAPIProgress, @ptrCast(self)), lpul_flags_);
            }
            pub inline fn getMax(self: *const T, lpul_max_: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetMax(@as(*const IMAPIProgress, @ptrCast(self)), lpul_max_);
            }
            pub inline fn getMin(self: *const T, lpul_min_: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetMin(@as(*const IMAPIProgress, @ptrCast(self)), lpul_min_);
            }
            pub inline fn setLimits(self: *const T, lpul_min_: ?*u32, lpul_max_: ?*u32, lpul_flags_: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).SetLimits(@as(*const IMAPIProgress, @ptrCast(self)), lpul_min_, lpul_max_, lpul_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MAPINAMEID = extern struct {
    lpguid: ?*Guid,
    ulKind: u32,
    Kind: extern union {
        lID: i32,
        lpwstrName: ?PWSTR,
    },
};

pub const IMAPIProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn (
            self: *const IMAPIProp,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveChanges: *const fn (
            self: *const IMAPIProp,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProps: *const fn (
            self: *const IMAPIProp,
            lp_prop_tag_array: ?*SPropTagArray,
            ul_flags: u32,
            lpc_values: ?*u32,
            lpp_prop_array: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropList: *const fn (
            self: *const IMAPIProp,
            ul_flags: u32,
            lpp_prop_tag_array: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProperty: *const fn (
            self: *const IMAPIProp,
            ul_prop_tag: u32,
            lpiid: ?*Guid,
            ul_interface_options: u32,
            ul_flags: u32,
            lpp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProps: *const fn (
            self: *const IMAPIProp,
            c_values: u32,
            lp_prop_array: ?*SPropValue,
            lpp_problems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProps: *const fn (
            self: *const IMAPIProp,
            lp_prop_tag_array: ?*SPropTagArray,
            lpp_problems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: *const fn (
            self: *const IMAPIProp,
            ciid_exclude: u32,
            rgiid_exclude: ?*Guid,
            lp_exclude_props: ?*SPropTagArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            lp_interface: ?*Guid,
            lp_dest_obj: ?*anyopaque,
            ul_flags: u32,
            lpp_problems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProps: *const fn (
            self: *const IMAPIProp,
            lp_include_props: ?*SPropTagArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            lp_interface: ?*Guid,
            lp_dest_obj: ?*anyopaque,
            ul_flags: u32,
            lpp_problems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamesFromIDs: *const fn (
            self: *const IMAPIProp,
            lpp_prop_tags: ?*?*SPropTagArray,
            lp_prop_set_guid: ?*Guid,
            ul_flags: u32,
            lpc_prop_names: ?*u32,
            lppp_prop_names: ?*?*?*MAPINAMEID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsFromNames: *const fn (
            self: *const IMAPIProp,
            c_prop_names: u32,
            lpp_prop_names: ?*?*MAPINAMEID,
            ul_flags: u32,
            lpp_prop_tags: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPIProp, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn saveChanges(self: *const T, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).SaveChanges(@as(*const IMAPIProp, @ptrCast(self)), ul_flags_);
            }
            pub inline fn getProps(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, ul_flags_: u32, lpc_values_: ?*u32, lpp_prop_array_: ?*?*SPropValue) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetProps(@as(*const IMAPIProp, @ptrCast(self)), lp_prop_tag_array_, ul_flags_, lpc_values_, lpp_prop_array_);
            }
            pub inline fn getPropList(self: *const T, ul_flags_: u32, lpp_prop_tag_array_: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetPropList(@as(*const IMAPIProp, @ptrCast(self)), ul_flags_, lpp_prop_tag_array_);
            }
            pub inline fn openProperty(self: *const T, ul_prop_tag_: u32, lpiid_: ?*Guid, ul_interface_options_: u32, ul_flags_: u32, lpp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).OpenProperty(@as(*const IMAPIProp, @ptrCast(self)), ul_prop_tag_, lpiid_, ul_interface_options_, ul_flags_, lpp_unk_);
            }
            pub inline fn setProps(self: *const T, c_values_: u32, lp_prop_array_: ?*SPropValue, lpp_problems_: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).SetProps(@as(*const IMAPIProp, @ptrCast(self)), c_values_, lp_prop_array_, lpp_problems_);
            }
            pub inline fn deleteProps(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, lpp_problems_: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).DeleteProps(@as(*const IMAPIProp, @ptrCast(self)), lp_prop_tag_array_, lpp_problems_);
            }
            pub inline fn copyTo(self: *const T, ciid_exclude_: u32, rgiid_exclude_: ?*Guid, lp_exclude_props_: ?*SPropTagArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, lp_interface_: ?*Guid, lp_dest_obj_: ?*anyopaque, ul_flags_: u32, lpp_problems_: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IMAPIProp, @ptrCast(self)), ciid_exclude_, rgiid_exclude_, lp_exclude_props_, ul_u_i_param_, lp_progress_, lp_interface_, lp_dest_obj_, ul_flags_, lpp_problems_);
            }
            pub inline fn copyProps(self: *const T, lp_include_props_: ?*SPropTagArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, lp_interface_: ?*Guid, lp_dest_obj_: ?*anyopaque, ul_flags_: u32, lpp_problems_: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).CopyProps(@as(*const IMAPIProp, @ptrCast(self)), lp_include_props_, ul_u_i_param_, lp_progress_, lp_interface_, lp_dest_obj_, ul_flags_, lpp_problems_);
            }
            pub inline fn getNamesFromIDs(self: *const T, lpp_prop_tags_: ?*?*SPropTagArray, lp_prop_set_guid_: ?*Guid, ul_flags_: u32, lpc_prop_names_: ?*u32, lppp_prop_names_: ?*?*?*MAPINAMEID) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetNamesFromIDs(@as(*const IMAPIProp, @ptrCast(self)), lpp_prop_tags_, lp_prop_set_guid_, ul_flags_, lpc_prop_names_, lppp_prop_names_);
            }
            pub inline fn getIDsFromNames(self: *const T, c_prop_names_: u32, lpp_prop_names_: ?*?*MAPINAMEID, ul_flags_: u32, lpp_prop_tags_: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetIDsFromNames(@as(*const IMAPIProp, @ptrCast(self)), c_prop_names_, lpp_prop_names_, ul_flags_, lpp_prop_tags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SSortOrder = extern struct {
    ulPropTag: u32,
    ulOrder: u32,
};

pub const SSortOrderSet = extern struct {
    cSorts: u32,
    cCategories: u32,
    cExpanded: u32,
    aSort: [1]SSortOrder,
};

pub const SAndRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SOrRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SNotRestriction = extern struct {
    ulReserved: u32,
    lpRes: ?*SRestriction,
};

pub const SContentRestriction = extern struct {
    ulFuzzyLevel: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SBitMaskRestriction = extern struct {
    relBMR: u32,
    ulPropTag: u32,
    ulMask: u32,
};

pub const SPropertyRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SComparePropsRestriction = extern struct {
    relop: u32,
    ulPropTag1: u32,
    ulPropTag2: u32,
};

pub const SSizeRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    cb: u32,
};

pub const SExistRestriction = extern struct {
    ulReserved1: u32,
    ulPropTag: u32,
    ulReserved2: u32,
};

pub const SSubRestriction = extern struct {
    ulSubObject: u32,
    lpRes: ?*SRestriction,
};

pub const SCommentRestriction = extern struct {
    cValues: u32,
    lpRes: ?*SRestriction,
    lpProp: ?*SPropValue,
};

pub const SRestriction = extern struct {
    rt: u32,
    res: extern union {
        resCompareProps: SComparePropsRestriction,
        resAnd: SAndRestriction,
        resOr: SOrRestriction,
        resNot: SNotRestriction,
        resContent: SContentRestriction,
        resProperty: SPropertyRestriction,
        resBitMask: SBitMaskRestriction,
        resSize: SSizeRestriction,
        resExist: SExistRestriction,
        resSub: SSubRestriction,
        resComment: SCommentRestriction,
    },
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMAPITable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn (
            self: *const IMAPITable,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn (
            self: *const IMAPITable,
            ul_event_mask: u32,
            lp_advise_sink: ?*IMAPIAdviseSink,
            lpul_connection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IMAPITable,
            ul_connection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IMAPITable,
            lpul_table_status: ?*u32,
            lpul_table_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumns: *const fn (
            self: *const IMAPITable,
            lp_prop_tag_array: ?*SPropTagArray,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryColumns: *const fn (
            self: *const IMAPITable,
            ul_flags: u32,
            lp_prop_tag_array: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowCount: *const fn (
            self: *const IMAPITable,
            ul_flags: u32,
            lpul_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRow: *const fn (
            self: *const IMAPITable,
            bk_origin: u32,
            l_row_count: i32,
            lpl_rows_sought: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRowApprox: *const fn (
            self: *const IMAPITable,
            ul_numerator: u32,
            ul_denominator: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPosition: *const fn (
            self: *const IMAPITable,
            lpul_row: ?*u32,
            lpul_numerator: ?*u32,
            lpul_denominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRow: *const fn (
            self: *const IMAPITable,
            lp_restriction: ?*SRestriction,
            bk_origin: u32,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Restrict: *const fn (
            self: *const IMAPITable,
            lp_restriction: ?*SRestriction,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBookmark: *const fn (
            self: *const IMAPITable,
            lpbk_position: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBookmark: *const fn (
            self: *const IMAPITable,
            bk_position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SortTable: *const fn (
            self: *const IMAPITable,
            lp_sort_criteria: ?*SSortOrderSet,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySortOrder: *const fn (
            self: *const IMAPITable,
            lpp_sort_criteria: ?*?*SSortOrderSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRows: *const fn (
            self: *const IMAPITable,
            l_row_count: i32,
            ul_flags: u32,
            lpp_rows: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: *const fn (
            self: *const IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandRow: *const fn (
            self: *const IMAPITable,
            cb_instance_key: u32,
            pb_instance_key: ?*u8,
            ul_row_count: u32,
            ul_flags: u32,
            lpp_rows: ?*?*SRowSet,
            lpul_more_rows: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CollapseRow: *const fn (
            self: *const IMAPITable,
            cb_instance_key: u32,
            pb_instance_key: ?*u8,
            ul_flags: u32,
            lpul_row_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: *const fn (
            self: *const IMAPITable,
            ul_flags: u32,
            ul_timeout: u32,
            lpul_table_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCollapseState: *const fn (
            self: *const IMAPITable,
            ul_flags: u32,
            cb_instance_key: u32,
            lpb_instance_key: ?*u8,
            lpcb_collapse_state: ?*u32,
            lppb_collapse_state: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCollapseState: *const fn (
            self: *const IMAPITable,
            ul_flags: u32,
            cb_collapse_state: u32,
            pb_collapse_state: ?*u8,
            lpbk_location: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPITable, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn advise(self: *const T, ul_event_mask_: u32, lp_advise_sink_: ?*IMAPIAdviseSink, lpul_connection_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMAPITable, @ptrCast(self)), ul_event_mask_, lp_advise_sink_, lpul_connection_);
            }
            pub inline fn unadvise(self: *const T, ul_connection_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IMAPITable, @ptrCast(self)), ul_connection_);
            }
            pub inline fn getStatus(self: *const T, lpul_table_status_: ?*u32, lpul_table_type_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMAPITable, @ptrCast(self)), lpul_table_status_, lpul_table_type_);
            }
            pub inline fn setColumns(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, ul_flags_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SetColumns(@as(*const IMAPITable, @ptrCast(self)), lp_prop_tag_array_, ul_flags_);
            }
            pub inline fn queryColumns(self: *const T, ul_flags_: u32, lp_prop_tag_array_: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryColumns(@as(*const IMAPITable, @ptrCast(self)), ul_flags_, lp_prop_tag_array_);
            }
            pub inline fn getRowCount(self: *const T, ul_flags_: u32, lpul_count_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetRowCount(@as(*const IMAPITable, @ptrCast(self)), ul_flags_, lpul_count_);
            }
            pub inline fn seekRow(self: *const T, bk_origin_: u32, l_row_count_: i32, lpl_rows_sought_: ?*i32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SeekRow(@as(*const IMAPITable, @ptrCast(self)), bk_origin_, l_row_count_, lpl_rows_sought_);
            }
            pub inline fn seekRowApprox(self: *const T, ul_numerator_: u32, ul_denominator_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SeekRowApprox(@as(*const IMAPITable, @ptrCast(self)), ul_numerator_, ul_denominator_);
            }
            pub inline fn queryPosition(self: *const T, lpul_row_: ?*u32, lpul_numerator_: ?*u32, lpul_denominator_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryPosition(@as(*const IMAPITable, @ptrCast(self)), lpul_row_, lpul_numerator_, lpul_denominator_);
            }
            pub inline fn findRow(self: *const T, lp_restriction_: ?*SRestriction, bk_origin_: u32, ul_flags_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).FindRow(@as(*const IMAPITable, @ptrCast(self)), lp_restriction_, bk_origin_, ul_flags_);
            }
            pub inline fn restrict(self: *const T, lp_restriction_: ?*SRestriction, ul_flags_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Restrict(@as(*const IMAPITable, @ptrCast(self)), lp_restriction_, ul_flags_);
            }
            pub inline fn createBookmark(self: *const T, lpbk_position_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).CreateBookmark(@as(*const IMAPITable, @ptrCast(self)), lpbk_position_);
            }
            pub inline fn freeBookmark(self: *const T, bk_position_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).FreeBookmark(@as(*const IMAPITable, @ptrCast(self)), bk_position_);
            }
            pub inline fn sortTable(self: *const T, lp_sort_criteria_: ?*SSortOrderSet, ul_flags_: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SortTable(@as(*const IMAPITable, @ptrCast(self)), lp_sort_criteria_, ul_flags_);
            }
            pub inline fn querySortOrder(self: *const T, lpp_sort_criteria_: ?*?*SSortOrderSet) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QuerySortOrder(@as(*const IMAPITable, @ptrCast(self)), lpp_sort_criteria_);
            }
            pub inline fn queryRows(self: *const T, l_row_count_: i32, ul_flags_: u32, lpp_rows_: ?*?*SRowSet) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryRows(@as(*const IMAPITable, @ptrCast(self)), l_row_count_, ul_flags_, lpp_rows_);
            }
            pub inline fn abort(self: *const T) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Abort(@as(*const IMAPITable, @ptrCast(self)));
            }
            pub inline fn expandRow(self: *const T, cb_instance_key_: u32, pb_instance_key_: ?*u8, ul_row_count_: u32, ul_flags_: u32, lpp_rows_: ?*?*SRowSet, lpul_more_rows_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).ExpandRow(@as(*const IMAPITable, @ptrCast(self)), cb_instance_key_, pb_instance_key_, ul_row_count_, ul_flags_, lpp_rows_, lpul_more_rows_);
            }
            pub inline fn collapseRow(self: *const T, cb_instance_key_: u32, pb_instance_key_: ?*u8, ul_flags_: u32, lpul_row_count_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).CollapseRow(@as(*const IMAPITable, @ptrCast(self)), cb_instance_key_, pb_instance_key_, ul_flags_, lpul_row_count_);
            }
            pub inline fn waitForCompletion(self: *const T, ul_flags_: u32, ul_timeout_: u32, lpul_table_status_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).WaitForCompletion(@as(*const IMAPITable, @ptrCast(self)), ul_flags_, ul_timeout_, lpul_table_status_);
            }
            pub inline fn getCollapseState(self: *const T, ul_flags_: u32, cb_instance_key_: u32, lpb_instance_key_: ?*u8, lpcb_collapse_state_: ?*u32, lppb_collapse_state_: ?*?*u8) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetCollapseState(@as(*const IMAPITable, @ptrCast(self)), ul_flags_, cb_instance_key_, lpb_instance_key_, lpcb_collapse_state_, lppb_collapse_state_);
            }
            pub inline fn setCollapseState(self: *const T, ul_flags_: u32, cb_collapse_state_: u32, pb_collapse_state_: ?*u8, lpbk_location_: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SetCollapseState(@as(*const IMAPITable, @ptrCast(self)), ul_flags_, cb_collapse_state_, pb_collapse_state_, lpbk_location_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IProfSect = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIStatus = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        ValidateState: *const fn (
            self: *const IMAPIStatus,
            ul_u_i_param: usize,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SettingsDialog: *const fn (
            self: *const IMAPIStatus,
            ul_u_i_param: usize,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangePassword: *const fn (
            self: *const IMAPIStatus,
            lp_old_pass: ?*i8,
            lp_new_pass: ?*i8,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushQueues: *const fn (
            self: *const IMAPIStatus,
            ul_u_i_param: usize,
            cb_target_transport: u32,
            lp_target_transport: ?[*]ENTRYID,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn validateState(self: *const T, ul_u_i_param_: usize, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).ValidateState(@as(*const IMAPIStatus, @ptrCast(self)), ul_u_i_param_, ul_flags_);
            }
            pub inline fn settingsDialog(self: *const T, ul_u_i_param_: usize, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).SettingsDialog(@as(*const IMAPIStatus, @ptrCast(self)), ul_u_i_param_, ul_flags_);
            }
            pub inline fn changePassword(self: *const T, lp_old_pass_: ?*i8, lp_new_pass_: ?*i8, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).ChangePassword(@as(*const IMAPIStatus, @ptrCast(self)), lp_old_pass_, lp_new_pass_, ul_flags_);
            }
            pub inline fn flushQueues(self: *const T, ul_u_i_param_: usize, cb_target_transport_: u32, lp_target_transport_: ?[*]ENTRYID, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).FlushQueues(@as(*const IMAPIStatus, @ptrCast(self)), ul_u_i_param_, cb_target_transport_, lp_target_transport_, ul_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetContentsTable: *const fn (
            self: *const IMAPIContainer,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHierarchyTable: *const fn (
            self: *const IMAPIContainer,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: *const fn (
            self: *const IMAPIContainer,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpul_obj_type: ?*u32,
            lpp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchCriteria: *const fn (
            self: *const IMAPIContainer,
            lp_restriction: ?*SRestriction,
            lp_container_list: ?*SBinaryArray,
            ul_search_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchCriteria: *const fn (
            self: *const IMAPIContainer,
            ul_flags: u32,
            lpp_restriction: ?*?*SRestriction,
            lpp_container_list: ?*?*SBinaryArray,
            lpul_search_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn getContentsTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetContentsTable(@as(*const IMAPIContainer, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn getHierarchyTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetHierarchyTable(@as(*const IMAPIContainer, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn openEntry(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, lp_interface_: ?*Guid, ul_flags_: u32, lpul_obj_type_: ?*u32, lpp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IMAPIContainer, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, lp_interface_, ul_flags_, lpul_obj_type_, lpp_unk_);
            }
            pub inline fn setSearchCriteria(self: *const T, lp_restriction_: ?*SRestriction, lp_container_list_: ?*SBinaryArray, ul_search_flags_: u32) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).SetSearchCriteria(@as(*const IMAPIContainer, @ptrCast(self)), lp_restriction_, lp_container_list_, ul_search_flags_);
            }
            pub inline fn getSearchCriteria(self: *const T, ul_flags_: u32, lpp_restriction_: ?*?*SRestriction, lpp_container_list_: ?*?*SBinaryArray, lpul_search_state_: ?*u32) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetSearchCriteria(@as(*const IMAPIContainer, @ptrCast(self)), ul_flags_, lpp_restriction_, lpp_container_list_, lpul_search_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _flaglist = extern struct {
    cFlags: u32,
    ulFlag: [1]u32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IABContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: *const fn (
            self: *const IABContainer,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_create_flags: u32,
            lpp_m_a_p_i_prop_entry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: *const fn (
            self: *const IABContainer,
            lp_entries: ?*SBinaryArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: *const fn (
            self: *const IABContainer,
            lp_entries: ?*SBinaryArray,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: *const fn (
            self: *const IABContainer,
            lp_prop_tag_array: ?*SPropTagArray,
            ul_flags: u32,
            lp_adr_list: ?*ADRLIST,
            lp_flag_list: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            pub inline fn createEntry(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_create_flags_: u32, lpp_m_a_p_i_prop_entry_: ?*?*IMAPIProp) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).CreateEntry(@as(*const IABContainer, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_create_flags_, lpp_m_a_p_i_prop_entry_);
            }
            pub inline fn copyEntries(self: *const T, lp_entries_: ?*SBinaryArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).CopyEntries(@as(*const IABContainer, @ptrCast(self)), lp_entries_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn deleteEntries(self: *const T, lp_entries_: ?*SBinaryArray, ul_flags_: u32) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).DeleteEntries(@as(*const IABContainer, @ptrCast(self)), lp_entries_, ul_flags_);
            }
            pub inline fn resolveNames(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, ul_flags_: u32, lp_adr_list_: ?*ADRLIST, lp_flag_list_: ?*_flaglist) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).ResolveNames(@as(*const IABContainer, @ptrCast(self)), lp_prop_tag_array_, ul_flags_, lp_adr_list_, lp_flag_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMailUser = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDistList = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: *const fn (
            self: *const IDistList,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_create_flags: u32,
            lpp_m_a_p_i_prop_entry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: *const fn (
            self: *const IDistList,
            lp_entries: ?*SBinaryArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: *const fn (
            self: *const IDistList,
            lp_entries: ?*SBinaryArray,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: *const fn (
            self: *const IDistList,
            lp_prop_tag_array: ?*SPropTagArray,
            ul_flags: u32,
            lp_adr_list: ?*ADRLIST,
            lp_flag_list: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            pub inline fn createEntry(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_create_flags_: u32, lpp_m_a_p_i_prop_entry_: ?*?*IMAPIProp) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).CreateEntry(@as(*const IDistList, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_create_flags_, lpp_m_a_p_i_prop_entry_);
            }
            pub inline fn copyEntries(self: *const T, lp_entries_: ?*SBinaryArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).CopyEntries(@as(*const IDistList, @ptrCast(self)), lp_entries_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn deleteEntries(self: *const T, lp_entries_: ?*SBinaryArray, ul_flags_: u32) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).DeleteEntries(@as(*const IDistList, @ptrCast(self)), lp_entries_, ul_flags_);
            }
            pub inline fn resolveNames(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, ul_flags_: u32, lp_adr_list_: ?*ADRLIST, lp_flag_list_: ?*_flaglist) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).ResolveNames(@as(*const IDistList, @ptrCast(self)), lp_prop_tag_array_, ul_flags_, lp_adr_list_, lp_flag_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIFolder = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateMessage: *const fn (
            self: *const IMAPIFolder,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpp_message: ?*?*IMessage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyMessages: *const fn (
            self: *const IMAPIFolder,
            lp_msg_list: ?*SBinaryArray,
            lp_interface: ?*Guid,
            lp_dest_folder: ?*anyopaque,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMessages: *const fn (
            self: *const IMAPIFolder,
            lp_msg_list: ?*SBinaryArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFolder: *const fn (
            self: *const IMAPIFolder,
            ul_folder_type: u32,
            lpsz_folder_name: ?*i8,
            lpsz_folder_comment: ?*i8,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpp_folder: ?*?*IMAPIFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyFolder: *const fn (
            self: *const IMAPIFolder,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            lp_interface: ?*Guid,
            lp_dest_folder: ?*anyopaque,
            lpsz_new_folder_name: ?*i8,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFolder: *const fn (
            self: *const IMAPIFolder,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlags: *const fn (
            self: *const IMAPIFolder,
            lp_msg_list: ?*SBinaryArray,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageStatus: *const fn (
            self: *const IMAPIFolder,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_flags: u32,
            lpul_message_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMessageStatus: *const fn (
            self: *const IMAPIFolder,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_new_status: u32,
            ul_new_status_mask: u32,
            lpul_old_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveContentsSort: *const fn (
            self: *const IMAPIFolder,
            lp_sort_criteria: ?*SSortOrderSet,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmptyFolder: *const fn (
            self: *const IMAPIFolder,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            pub inline fn createMessage(self: *const T, lp_interface_: ?*Guid, ul_flags_: u32, lpp_message_: ?*?*IMessage) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CreateMessage(@as(*const IMAPIFolder, @ptrCast(self)), lp_interface_, ul_flags_, lpp_message_);
            }
            pub inline fn copyMessages(self: *const T, lp_msg_list_: ?*SBinaryArray, lp_interface_: ?*Guid, lp_dest_folder_: ?*anyopaque, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CopyMessages(@as(*const IMAPIFolder, @ptrCast(self)), lp_msg_list_, lp_interface_, lp_dest_folder_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn deleteMessages(self: *const T, lp_msg_list_: ?*SBinaryArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).DeleteMessages(@as(*const IMAPIFolder, @ptrCast(self)), lp_msg_list_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn createFolder(self: *const T, ul_folder_type_: u32, lpsz_folder_name_: ?*i8, lpsz_folder_comment_: ?*i8, lp_interface_: ?*Guid, ul_flags_: u32, lpp_folder_: ?*?*IMAPIFolder) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CreateFolder(@as(*const IMAPIFolder, @ptrCast(self)), ul_folder_type_, lpsz_folder_name_, lpsz_folder_comment_, lp_interface_, ul_flags_, lpp_folder_);
            }
            pub inline fn copyFolder(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, lp_interface_: ?*Guid, lp_dest_folder_: ?*anyopaque, lpsz_new_folder_name_: ?*i8, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CopyFolder(@as(*const IMAPIFolder, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, lp_interface_, lp_dest_folder_, lpsz_new_folder_name_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn deleteFolder(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).DeleteFolder(@as(*const IMAPIFolder, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn setReadFlags(self: *const T, lp_msg_list_: ?*SBinaryArray, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SetReadFlags(@as(*const IMAPIFolder, @ptrCast(self)), lp_msg_list_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn getMessageStatus(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_flags_: u32, lpul_message_status_: ?*u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).GetMessageStatus(@as(*const IMAPIFolder, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_flags_, lpul_message_status_);
            }
            pub inline fn setMessageStatus(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_new_status_: u32, ul_new_status_mask_: u32, lpul_old_status_: ?*u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SetMessageStatus(@as(*const IMAPIFolder, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_new_status_, ul_new_status_mask_, lpul_old_status_);
            }
            pub inline fn saveContentsSort(self: *const T, lp_sort_criteria_: ?*SSortOrderSet, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SaveContentsSort(@as(*const IMAPIFolder, @ptrCast(self)), lp_sort_criteria_, ul_flags_);
            }
            pub inline fn emptyFolder(self: *const T, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).EmptyFolder(@as(*const IMAPIFolder, @ptrCast(self)), ul_u_i_param_, lp_progress_, ul_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMsgStore = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        Advise: *const fn (
            self: *const IMsgStore,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_event_mask: u32,
            lp_advise_sink: ?*IMAPIAdviseSink,
            lpul_connection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IMsgStore,
            ul_connection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: *const fn (
            self: *const IMsgStore,
            cb_entry_i_d1: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d1: ?*ENTRYID,
            cb_entry_i_d2: u32,
            // TODO: what to do with BytesParamIndex 2?
            lp_entry_i_d2: ?*ENTRYID,
            ul_flags: u32,
            lpul_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: *const fn (
            self: *const IMsgStore,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpul_obj_type: ?*u32,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReceiveFolder: *const fn (
            self: *const IMsgStore,
            lpsz_message_class: ?*i8,
            ul_flags: u32,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 2?
            lp_entry_i_d: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolder: *const fn (
            self: *const IMsgStore,
            lpsz_message_class: ?*i8,
            ul_flags: u32,
            lpcb_entry_i_d: ?*u32,
            lpp_entry_i_d: ?*?*ENTRYID,
            lppsz_explicit_class: ?*?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolderTable: *const fn (
            self: *const IMsgStore,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoreLogoff: *const fn (
            self: *const IMsgStore,
            lpul_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortSubmit: *const fn (
            self: *const IMsgStore,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 0?
            lp_entry_i_d: ?*ENTRYID,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutgoingQueue: *const fn (
            self: *const IMsgStore,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLockState: *const fn (
            self: *const IMsgStore,
            lp_message: ?*IMessage,
            ul_lock_state: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishedMsg: *const fn (
            self: *const IMsgStore,
            ul_flags: u32,
            cb_entry_i_d: u32,
            // TODO: what to do with BytesParamIndex 1?
            lp_entry_i_d: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyNewMail: *const fn (
            self: *const IMsgStore,
            lp_notification: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn advise(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_event_mask_: u32, lp_advise_sink_: ?*IMAPIAdviseSink, lpul_connection_: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMsgStore, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_event_mask_, lp_advise_sink_, lpul_connection_);
            }
            pub inline fn unadvise(self: *const T, ul_connection_: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IMsgStore, @ptrCast(self)), ul_connection_);
            }
            pub inline fn compareEntryIDs(self: *const T, cb_entry_i_d1_: u32, lp_entry_i_d1_: ?*ENTRYID, cb_entry_i_d2_: u32, lp_entry_i_d2_: ?*ENTRYID, ul_flags_: u32, lpul_result_: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).CompareEntryIDs(@as(*const IMsgStore, @ptrCast(self)), cb_entry_i_d1_, lp_entry_i_d1_, cb_entry_i_d2_, lp_entry_i_d2_, ul_flags_, lpul_result_);
            }
            pub inline fn openEntry(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, lp_interface_: ?*Guid, ul_flags_: u32, lpul_obj_type_: ?*u32, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IMsgStore, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, lp_interface_, ul_flags_, lpul_obj_type_, pp_unk_);
            }
            pub inline fn setReceiveFolder(self: *const T, lpsz_message_class_: ?*i8, ul_flags_: u32, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).SetReceiveFolder(@as(*const IMsgStore, @ptrCast(self)), lpsz_message_class_, ul_flags_, cb_entry_i_d_, lp_entry_i_d_);
            }
            pub inline fn getReceiveFolder(self: *const T, lpsz_message_class_: ?*i8, ul_flags_: u32, lpcb_entry_i_d_: ?*u32, lpp_entry_i_d_: ?*?*ENTRYID, lppsz_explicit_class_: ?*?*i8) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetReceiveFolder(@as(*const IMsgStore, @ptrCast(self)), lpsz_message_class_, ul_flags_, lpcb_entry_i_d_, lpp_entry_i_d_, lppsz_explicit_class_);
            }
            pub inline fn getReceiveFolderTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetReceiveFolderTable(@as(*const IMsgStore, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn storeLogoff(self: *const T, lpul_flags_: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).StoreLogoff(@as(*const IMsgStore, @ptrCast(self)), lpul_flags_);
            }
            pub inline fn abortSubmit(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_flags_: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).AbortSubmit(@as(*const IMsgStore, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_flags_);
            }
            pub inline fn getOutgoingQueue(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetOutgoingQueue(@as(*const IMsgStore, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn setLockState(self: *const T, lp_message_: ?*IMessage, ul_lock_state_: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).SetLockState(@as(*const IMsgStore, @ptrCast(self)), lp_message_, ul_lock_state_);
            }
            pub inline fn finishedMsg(self: *const T, ul_flags_: u32, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).FinishedMsg(@as(*const IMsgStore, @ptrCast(self)), ul_flags_, cb_entry_i_d_, lp_entry_i_d_);
            }
            pub inline fn notifyNewMail(self: *const T, lp_notification_: ?*NOTIFICATION) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).NotifyNewMail(@as(*const IMsgStore, @ptrCast(self)), lp_notification_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMessage = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetAttachmentTable: *const fn (
            self: *const IMessage,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenAttach: *const fn (
            self: *const IMessage,
            ul_attachment_num: u32,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpp_attach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAttach: *const fn (
            self: *const IMessage,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpul_attachment_num: ?*u32,
            lpp_attach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAttach: *const fn (
            self: *const IMessage,
            ul_attachment_num: u32,
            ul_u_i_param: usize,
            lp_progress: ?*IMAPIProgress,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecipientTable: *const fn (
            self: *const IMessage,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyRecipients: *const fn (
            self: *const IMessage,
            ul_flags: u32,
            lp_mods: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitMessage: *const fn (
            self: *const IMessage,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlag: *const fn (
            self: *const IMessage,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn getAttachmentTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).GetAttachmentTable(@as(*const IMessage, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn openAttach(self: *const T, ul_attachment_num_: u32, lp_interface_: ?*Guid, ul_flags_: u32, lpp_attach_: ?*?*IAttach) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).OpenAttach(@as(*const IMessage, @ptrCast(self)), ul_attachment_num_, lp_interface_, ul_flags_, lpp_attach_);
            }
            pub inline fn createAttach(self: *const T, lp_interface_: ?*Guid, ul_flags_: u32, lpul_attachment_num_: ?*u32, lpp_attach_: ?*?*IAttach) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).CreateAttach(@as(*const IMessage, @ptrCast(self)), lp_interface_, ul_flags_, lpul_attachment_num_, lpp_attach_);
            }
            pub inline fn deleteAttach(self: *const T, ul_attachment_num_: u32, ul_u_i_param_: usize, lp_progress_: ?*IMAPIProgress, ul_flags_: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).DeleteAttach(@as(*const IMessage, @ptrCast(self)), ul_attachment_num_, ul_u_i_param_, lp_progress_, ul_flags_);
            }
            pub inline fn getRecipientTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).GetRecipientTable(@as(*const IMessage, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn modifyRecipients(self: *const T, ul_flags_: u32, lp_mods_: ?*ADRLIST) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).ModifyRecipients(@as(*const IMessage, @ptrCast(self)), ul_flags_, lp_mods_);
            }
            pub inline fn submitMessage(self: *const T, ul_flags_: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).SubmitMessage(@as(*const IMessage, @ptrCast(self)), ul_flags_);
            }
            pub inline fn setReadFlag(self: *const T, ul_flags_: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).SetReadFlag(@as(*const IMessage, @ptrCast(self)), ul_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IAttach = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPFNABSDI = *const fn (
    ul_u_i_param: usize,
    lpvmsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNDISMISS = *const fn (
    ul_u_i_param: usize,
    lpv_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFNBUTTON = *const fn (
    ul_u_i_param: usize,
    lpv_context: ?*anyopaque,
    cb_entry_i_d: u32,
    lp_selection: ?*ENTRYID,
    ul_flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ADRPARM = extern struct {
    cbABContEntryID: u32,
    lpABContEntryID: ?*ENTRYID,
    ulFlags: u32,
    lpReserved: ?*anyopaque,
    ulHelpContext: u32,
    lpszHelpFileName: ?*i8,
    lpfnABSDI: ?LPFNABSDI,
    lpfnDismiss: ?LPFNDISMISS,
    lpvDismissContext: ?*anyopaque,
    lpszCaption: ?*i8,
    lpszNewEntryTitle: ?*i8,
    lpszDestWellsTitle: ?*i8,
    cDestFields: u32,
    nDestFieldFocus: u32,
    lppszDestTitles: ?*?*i8,
    lpulDestComps: ?*u32,
    lpContRestriction: ?*SRestriction,
    lpHierRestriction: ?*SRestriction,
};

pub const IMAPIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn (
            self: *const IMAPIControl,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: *const fn (
            self: *const IMAPIControl,
            ul_flags: u32,
            ul_u_i_param: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IMAPIControl,
            ul_flags: u32,
            lpul_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPIControl, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn activate(self: *const T, ul_flags_: u32, ul_u_i_param_: usize) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMAPIControl, @ptrCast(self)), ul_flags_, ul_u_i_param_);
            }
            pub inline fn getState(self: *const T, ul_flags_: u32, lpul_state_: ?*u32) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMAPIControl, @ptrCast(self)), ul_flags_, lpul_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DTBLLABEL = extern struct {
    ulbLpszLabelName: u32,
    ulFlags: u32,
};

pub const DTBLEDIT = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPropTag: u32,
};

pub const DTBLLBX = extern struct {
    ulFlags: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCOMBOBOX = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPRPropertyName: u32,
    ulPRTableName: u32,
};

pub const DTBLDDLBX = extern struct {
    ulFlags: u32,
    ulPRDisplayProperty: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCHECKBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRPropertyName: u32,
};

pub const DTBLGROUPBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
};

pub const DTBLBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRControl: u32,
};

pub const DTBLPAGE = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulbLpszComponent: u32,
    ulContext: u32,
};

pub const DTBLRADIOBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulcButtons: u32,
    ulPropTag: u32,
    lReturnValue: i32,
};

pub const DTBLMVLISTBOX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const DTBLMVDDLBX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const IProviderAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn (
            self: *const IProviderAdmin,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderTable: *const fn (
            self: *const IProviderAdmin,
            ul_flags: u32,
            lpp_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProvider: *const fn (
            self: *const IProviderAdmin,
            lpsz_provider: ?*i8,
            c_values: u32,
            lp_props: [*]SPropValue,
            ul_u_i_param: usize,
            ul_flags: u32,
            lp_u_i_d: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProvider: *const fn (
            self: *const IProviderAdmin,
            lp_u_i_d: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProfileSection: *const fn (
            self: *const IProviderAdmin,
            lp_u_i_d: ?*MAPIUID,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpp_prof_sect: ?*?*IProfSect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IProviderAdmin, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn getProviderTable(self: *const T, ul_flags_: u32, lpp_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).GetProviderTable(@as(*const IProviderAdmin, @ptrCast(self)), ul_flags_, lpp_table_);
            }
            pub inline fn createProvider(self: *const T, lpsz_provider_: ?*i8, c_values_: u32, lp_props_: [*]SPropValue, ul_u_i_param_: usize, ul_flags_: u32, lp_u_i_d_: ?*MAPIUID) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).CreateProvider(@as(*const IProviderAdmin, @ptrCast(self)), lpsz_provider_, c_values_, lp_props_, ul_u_i_param_, ul_flags_, lp_u_i_d_);
            }
            pub inline fn deleteProvider(self: *const T, lp_u_i_d_: ?*MAPIUID) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).DeleteProvider(@as(*const IProviderAdmin, @ptrCast(self)), lp_u_i_d_);
            }
            pub inline fn openProfileSection(self: *const T, lp_u_i_d_: ?*MAPIUID, lp_interface_: ?*Guid, ul_flags_: u32, lpp_prof_sect_: ?*?*IProfSect) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).OpenProfileSection(@as(*const IProviderAdmin, @ptrCast(self)), lp_u_i_d_, lp_interface_, ul_flags_, lpp_prof_sect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Gender = enum(i32) {
    Unspecified = 0,
    Female = 1,
    Male = 2,
};
pub const genderUnspecified = Gender.Unspecified;
pub const genderFemale = Gender.Female;
pub const genderMale = Gender.Male;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const CALLERRELEASE = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const ITableData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrGetView: *const fn (
            self: *const ITableData,
            lp_s_sort_order_set: ?*SSortOrderSet,
            lpf_caller_release: ?*?CALLERRELEASE,
            ul_caller_data: u32,
            lpp_m_a_p_i_table: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRow: *const fn (
            self: *const ITableData,
            param0: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRow: *const fn (
            self: *const ITableData,
            lp_s_prop_value: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrQueryRow: *const fn (
            self: *const ITableData,
            lps_prop_value: ?*SPropValue,
            lpp_s_row: ?*?*SRow,
            lpuli_row: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrEnumRow: *const fn (
            self: *const ITableData,
            ul_row_number: u32,
            lpp_s_row: ?*?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrNotify: *const fn (
            self: *const ITableData,
            ul_flags: u32,
            c_values: u32,
            lp_s_prop_value: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrInsertRow: *const fn (
            self: *const ITableData,
            uli_row: u32,
            lp_s_row: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRows: *const fn (
            self: *const ITableData,
            ul_flags: u32,
            lp_s_row_set: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRows: *const fn (
            self: *const ITableData,
            ul_flags: u32,
            lprowset_to_delete: ?*SRowSet,
            c_rows_deleted: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn hrGetView(self: *const T, lp_s_sort_order_set_: ?*SSortOrderSet, lpf_caller_release_: ?*?CALLERRELEASE, ul_caller_data_: u32, lpp_m_a_p_i_table_: ?*?*IMAPITable) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrGetView(@as(*const ITableData, @ptrCast(self)), lp_s_sort_order_set_, lpf_caller_release_, ul_caller_data_, lpp_m_a_p_i_table_);
            }
            pub inline fn hrModifyRow(self: *const T, param0_: ?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrModifyRow(@as(*const ITableData, @ptrCast(self)), param0_);
            }
            pub inline fn hrDeleteRow(self: *const T, lp_s_prop_value_: ?*SPropValue) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrDeleteRow(@as(*const ITableData, @ptrCast(self)), lp_s_prop_value_);
            }
            pub inline fn hrQueryRow(self: *const T, lps_prop_value_: ?*SPropValue, lpp_s_row_: ?*?*SRow, lpuli_row_: ?*u32) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrQueryRow(@as(*const ITableData, @ptrCast(self)), lps_prop_value_, lpp_s_row_, lpuli_row_);
            }
            pub inline fn hrEnumRow(self: *const T, ul_row_number_: u32, lpp_s_row_: ?*?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrEnumRow(@as(*const ITableData, @ptrCast(self)), ul_row_number_, lpp_s_row_);
            }
            pub inline fn hrNotify(self: *const T, ul_flags_: u32, c_values_: u32, lp_s_prop_value_: ?*SPropValue) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrNotify(@as(*const ITableData, @ptrCast(self)), ul_flags_, c_values_, lp_s_prop_value_);
            }
            pub inline fn hrInsertRow(self: *const T, uli_row_: u32, lp_s_row_: ?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrInsertRow(@as(*const ITableData, @ptrCast(self)), uli_row_, lp_s_row_);
            }
            pub inline fn hrModifyRows(self: *const T, ul_flags_: u32, lp_s_row_set_: ?*SRowSet) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrModifyRows(@as(*const ITableData, @ptrCast(self)), ul_flags_, lp_s_row_set_);
            }
            pub inline fn hrDeleteRows(self: *const T, ul_flags_: u32, lprowset_to_delete_: ?*SRowSet, c_rows_deleted_: ?*u32) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrDeleteRows(@as(*const ITableData, @ptrCast(self)), ul_flags_, lprowset_to_delete_, c_rows_deleted_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IPropData = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        HrSetObjAccess: *const fn (
            self: *const IPropData,
            ul_access: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrSetPropAccess: *const fn (
            self: *const IPropData,
            lp_prop_tag_array: ?*SPropTagArray,
            rgul_access: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrGetPropAccess: *const fn (
            self: *const IPropData,
            lpp_prop_tag_array: ?*?*SPropTagArray,
            lprgul_access: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrAddObjProps: *const fn (
            self: *const IPropData,
            lpp_prop_tag_array: ?*SPropTagArray,
            lprgul_access: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn hrSetObjAccess(self: *const T, ul_access_: u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrSetObjAccess(@as(*const IPropData, @ptrCast(self)), ul_access_);
            }
            pub inline fn hrSetPropAccess(self: *const T, lp_prop_tag_array_: ?*SPropTagArray, rgul_access_: ?*u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrSetPropAccess(@as(*const IPropData, @ptrCast(self)), lp_prop_tag_array_, rgul_access_);
            }
            pub inline fn hrGetPropAccess(self: *const T, lpp_prop_tag_array_: ?*?*SPropTagArray, lprgul_access_: ?*?*u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrGetPropAccess(@as(*const IPropData, @ptrCast(self)), lpp_prop_tag_array_, lprgul_access_);
            }
            pub inline fn hrAddObjProps(self: *const T, lpp_prop_tag_array_: ?*SPropTagArray, lprgul_access_: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrAddObjProps(@as(*const IPropData, @ptrCast(self)), lpp_prop_tag_array_, lprgul_access_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FNIDLE = *const fn (
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFNIDLE = *const fn () callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPOPENSTREAMONFILE = *const fn (
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_free_buffer: ?LPFREEBUFFER,
    ul_flags: u32,
    lpsz_file_name: ?*i8,
    lpsz_prefix: ?*i8,
    lpp_stream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DTCTL = extern struct {
    ulCtlType: u32,
    ulCtlFlags: u32,
    lpbNotif: ?*u8,
    cbNotif: u32,
    lpszFilter: ?*i8,
    ulItemID: u32,
    ctl: extern union {
        lpv: ?*anyopaque,
        lplabel: ?*DTBLLABEL,
        lpedit: ?*DTBLEDIT,
        lplbx: ?*DTBLLBX,
        lpcombobox: ?*DTBLCOMBOBOX,
        lpddlbx: ?*DTBLDDLBX,
        lpcheckbox: ?*DTBLCHECKBOX,
        lpgroupbox: ?*DTBLGROUPBOX,
        lpbutton: ?*DTBLBUTTON,
        lpradiobutton: ?*DTBLRADIOBUTTON,
        lpmvlbx: ?*DTBLMVLISTBOX,
        lpmvddlbx: ?*DTBLMVDDLBX,
        lppage: ?*DTBLPAGE,
    },
};

pub const DTPAGE = extern struct {
    cctl: u32,
    lpszResourceName: ?*i8,
    Anonymous: extern union {
        lpszComponent: ?*i8,
        ulItemID: u32,
    },
    lpctl: ?*DTCTL,
};

pub const LPDISPATCHNOTIFICATIONS = *const fn (
    ul_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPCREATECONVERSATIONINDEX = *const fn (
    cb_parent: u32,
    lpb_parent: ?*u8,
    lpcb_conv_index: ?*u32,
    lppb_conv_index: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub const IAddrBook = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        OpenEntry: *const fn (
            self: *const IAddrBook,
            cb_entry_i_d: u32,
            lp_entry_i_d: ?*ENTRYID,
            lp_interface: ?*Guid,
            ul_flags: u32,
            lpul_obj_type: ?*u32,
            lpp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: *const fn (
            self: *const IAddrBook,
            cb_entry_i_d1: u32,
            lp_entry_i_d1: ?*ENTRYID,
            cb_entry_i_d2: u32,
            lp_entry_i_d2: ?*ENTRYID,
            ul_flags: u32,
            lpul_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn (
            self: *const IAddrBook,
            cb_entry_i_d: u32,
            lp_entry_i_d: ?*ENTRYID,
            ul_event_mask: u32,
            lp_advise_sink: ?*IMAPIAdviseSink,
            lpul_connection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IAddrBook,
            ul_connection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOneOff: *const fn (
            self: *const IAddrBook,
            lpsz_name: ?*i8,
            lpsz_adr_type: ?*i8,
            lpsz_address: ?*i8,
            ul_flags: u32,
            lpcb_entry_i_d: ?*u32,
            lpp_entry_i_d: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewEntry: *const fn (
            self: *const IAddrBook,
            ul_u_i_param: u32,
            ul_flags: u32,
            cb_e_i_d_container: u32,
            lp_e_i_d_container: ?*ENTRYID,
            cb_e_i_d_new_entry_tpl: u32,
            lp_e_i_d_new_entry_tpl: ?*ENTRYID,
            lpcb_e_i_d_new_entry: ?*u32,
            lpp_e_i_d_new_entry: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveName: *const fn (
            self: *const IAddrBook,
            ul_u_i_param: usize,
            ul_flags: u32,
            lpsz_new_entry_title: ?*i8,
            lp_adr_list: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Address: *const fn (
            self: *const IAddrBook,
            lpul_u_i_param: ?*u32,
            lp_adr_parms: ?*ADRPARM,
            lpp_adr_list: ?*?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Details: *const fn (
            self: *const IAddrBook,
            lpul_u_i_param: ?*usize,
            lpfn_dismiss: ?LPFNDISMISS,
            lpv_dismiss_context: ?*anyopaque,
            cb_entry_i_d: u32,
            lp_entry_i_d: ?*ENTRYID,
            lpf_button_callback: ?LPFNBUTTON,
            lpv_button_context: ?*anyopaque,
            lpsz_button_text: ?*i8,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecipOptions: *const fn (
            self: *const IAddrBook,
            ul_u_i_param: u32,
            ul_flags: u32,
            lp_recip: ?*ADRENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDefaultRecipOpt: *const fn (
            self: *const IAddrBook,
            lpsz_adr_type: ?*i8,
            ul_flags: u32,
            lpc_values: ?*u32,
            lpp_options: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAB: *const fn (
            self: *const IAddrBook,
            lpcb_entry_i_d: ?*u32,
            lpp_entry_i_d: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPAB: *const fn (
            self: *const IAddrBook,
            cb_entry_i_d: u32,
            lp_entry_i_d: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultDir: *const fn (
            self: *const IAddrBook,
            lpcb_entry_i_d: ?*u32,
            lpp_entry_i_d: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDir: *const fn (
            self: *const IAddrBook,
            cb_entry_i_d: u32,
            lp_entry_i_d: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchPath: *const fn (
            self: *const IAddrBook,
            ul_flags: u32,
            lpp_search_path: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchPath: *const fn (
            self: *const IAddrBook,
            ul_flags: u32,
            lp_search_path: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareRecips: *const fn (
            self: *const IAddrBook,
            ul_flags: u32,
            lp_prop_tag_array: ?*SPropTagArray,
            lp_recip_list: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            pub inline fn openEntry(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, lp_interface_: ?*Guid, ul_flags_: u32, lpul_obj_type_: ?*u32, lpp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IAddrBook, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, lp_interface_, ul_flags_, lpul_obj_type_, lpp_unk_);
            }
            pub inline fn compareEntryIDs(self: *const T, cb_entry_i_d1_: u32, lp_entry_i_d1_: ?*ENTRYID, cb_entry_i_d2_: u32, lp_entry_i_d2_: ?*ENTRYID, ul_flags_: u32, lpul_result_: ?*u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).CompareEntryIDs(@as(*const IAddrBook, @ptrCast(self)), cb_entry_i_d1_, lp_entry_i_d1_, cb_entry_i_d2_, lp_entry_i_d2_, ul_flags_, lpul_result_);
            }
            pub inline fn advise(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, ul_event_mask_: u32, lp_advise_sink_: ?*IMAPIAdviseSink, lpul_connection_: ?*u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Advise(@as(*const IAddrBook, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_, ul_event_mask_, lp_advise_sink_, lpul_connection_);
            }
            pub inline fn unadvise(self: *const T, ul_connection_: u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IAddrBook, @ptrCast(self)), ul_connection_);
            }
            pub inline fn createOneOff(self: *const T, lpsz_name_: ?*i8, lpsz_adr_type_: ?*i8, lpsz_address_: ?*i8, ul_flags_: u32, lpcb_entry_i_d_: ?*u32, lpp_entry_i_d_: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).CreateOneOff(@as(*const IAddrBook, @ptrCast(self)), lpsz_name_, lpsz_adr_type_, lpsz_address_, ul_flags_, lpcb_entry_i_d_, lpp_entry_i_d_);
            }
            pub inline fn newEntry(self: *const T, ul_u_i_param_: u32, ul_flags_: u32, cb_e_i_d_container_: u32, lp_e_i_d_container_: ?*ENTRYID, cb_e_i_d_new_entry_tpl_: u32, lp_e_i_d_new_entry_tpl_: ?*ENTRYID, lpcb_e_i_d_new_entry_: ?*u32, lpp_e_i_d_new_entry_: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).NewEntry(@as(*const IAddrBook, @ptrCast(self)), ul_u_i_param_, ul_flags_, cb_e_i_d_container_, lp_e_i_d_container_, cb_e_i_d_new_entry_tpl_, lp_e_i_d_new_entry_tpl_, lpcb_e_i_d_new_entry_, lpp_e_i_d_new_entry_);
            }
            pub inline fn resolveName(self: *const T, ul_u_i_param_: usize, ul_flags_: u32, lpsz_new_entry_title_: ?*i8, lp_adr_list_: ?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).ResolveName(@as(*const IAddrBook, @ptrCast(self)), ul_u_i_param_, ul_flags_, lpsz_new_entry_title_, lp_adr_list_);
            }
            pub inline fn address(self: *const T, lpul_u_i_param_: ?*u32, lp_adr_parms_: ?*ADRPARM, lpp_adr_list_: ?*?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Address(@as(*const IAddrBook, @ptrCast(self)), lpul_u_i_param_, lp_adr_parms_, lpp_adr_list_);
            }
            pub inline fn details(self: *const T, lpul_u_i_param_: ?*usize, lpfn_dismiss_: ?LPFNDISMISS, lpv_dismiss_context_: ?*anyopaque, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID, lpf_button_callback_: ?LPFNBUTTON, lpv_button_context_: ?*anyopaque, lpsz_button_text_: ?*i8, ul_flags_: u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Details(@as(*const IAddrBook, @ptrCast(self)), lpul_u_i_param_, lpfn_dismiss_, lpv_dismiss_context_, cb_entry_i_d_, lp_entry_i_d_, lpf_button_callback_, lpv_button_context_, lpsz_button_text_, ul_flags_);
            }
            pub inline fn recipOptions(self: *const T, ul_u_i_param_: u32, ul_flags_: u32, lp_recip_: ?*ADRENTRY) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).RecipOptions(@as(*const IAddrBook, @ptrCast(self)), ul_u_i_param_, ul_flags_, lp_recip_);
            }
            pub inline fn queryDefaultRecipOpt(self: *const T, lpsz_adr_type_: ?*i8, ul_flags_: u32, lpc_values_: ?*u32, lpp_options_: ?*?*SPropValue) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).QueryDefaultRecipOpt(@as(*const IAddrBook, @ptrCast(self)), lpsz_adr_type_, ul_flags_, lpc_values_, lpp_options_);
            }
            pub inline fn getPAB(self: *const T, lpcb_entry_i_d_: ?*u32, lpp_entry_i_d_: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetPAB(@as(*const IAddrBook, @ptrCast(self)), lpcb_entry_i_d_, lpp_entry_i_d_);
            }
            pub inline fn setPAB(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetPAB(@as(*const IAddrBook, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_);
            }
            pub inline fn getDefaultDir(self: *const T, lpcb_entry_i_d_: ?*u32, lpp_entry_i_d_: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetDefaultDir(@as(*const IAddrBook, @ptrCast(self)), lpcb_entry_i_d_, lpp_entry_i_d_);
            }
            pub inline fn setDefaultDir(self: *const T, cb_entry_i_d_: u32, lp_entry_i_d_: ?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetDefaultDir(@as(*const IAddrBook, @ptrCast(self)), cb_entry_i_d_, lp_entry_i_d_);
            }
            pub inline fn getSearchPath(self: *const T, ul_flags_: u32, lpp_search_path_: ?*?*SRowSet) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetSearchPath(@as(*const IAddrBook, @ptrCast(self)), ul_flags_, lpp_search_path_);
            }
            pub inline fn setSearchPath(self: *const T, ul_flags_: u32, lp_search_path_: ?*SRowSet) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetSearchPath(@as(*const IAddrBook, @ptrCast(self)), ul_flags_, lp_search_path_);
            }
            pub inline fn prepareRecips(self: *const T, ul_flags_: u32, lp_prop_tag_array_: ?*SPropTagArray, lp_recip_list_: ?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).PrepareRecips(@as(*const IAddrBook, @ptrCast(self)), ul_flags_, lp_prop_tag_array_, lp_recip_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _WABACTIONITEM = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type is limited to platform 'windows5.0'
pub const IWABObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn (
            self: *const IWABObject,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: *const fn (
            self: *const IWABObject,
            cb_size: u32,
            lpp_buffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: *const fn (
            self: *const IWABObject,
            cb_size: u32,
            lp_object: ?*anyopaque,
            lpp_buffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: *const fn (
            self: *const IWABObject,
            lp_buffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: *const fn (
            self: *const IWABObject,
            lp_file_name: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: *const fn (
            self: *const IWABObject,
            lp_w_i_p: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
            lpsz_file_name: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
            ul_flags: u32,
            lpsz_u_r_l: ?PSTR,
            lpp_mail_user: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpsz_v_card: ?PSTR,
            lp_mail_user: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpsz_v_card: ?PSTR,
            lpp_mail_user: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpdw_action: ?*u32,
            lpsb_e_i_d: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: *const fn (
            self: *const IWABObject,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            sb_e_i_d: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IWABObject, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn allocateBuffer(self: *const T, cb_size_: u32, lpp_buffer_: ?*?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IWABObject, @ptrCast(self)), cb_size_, lpp_buffer_);
            }
            pub inline fn allocateMore(self: *const T, cb_size_: u32, lp_object_: ?*anyopaque, lpp_buffer_: ?*?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).AllocateMore(@as(*const IWABObject, @ptrCast(self)), cb_size_, lp_object_, lpp_buffer_);
            }
            pub inline fn freeBuffer(self: *const T, lp_buffer_: ?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IWABObject, @ptrCast(self)), lp_buffer_);
            }
            pub inline fn backup(self: *const T, lp_file_name_: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Backup(@as(*const IWABObject, @ptrCast(self)), lp_file_name_);
            }
            pub inline fn import(self: *const T, lp_w_i_p_: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Import(@as(*const IWABObject, @ptrCast(self)), lp_w_i_p_);
            }
            pub inline fn find(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Find(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, h_wnd_);
            }
            pub inline fn vCardDisplay(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND, lpsz_file_name_: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardDisplay(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, h_wnd_, lpsz_file_name_);
            }
            pub inline fn ldapUrl(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND, ul_flags_: u32, lpsz_u_r_l_: ?PSTR, lpp_mail_user_: ?*?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).LDAPUrl(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, h_wnd_, ul_flags_, lpsz_u_r_l_, lpp_mail_user_);
            }
            pub inline fn vCardCreate(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpsz_v_card_: ?PSTR, lp_mail_user_: ?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardCreate(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpsz_v_card_, lp_mail_user_);
            }
            pub inline fn vCardRetrieve(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpsz_v_card_: ?PSTR, lpp_mail_user_: ?*?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardRetrieve(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpsz_v_card_, lpp_mail_user_);
            }
            pub inline fn getMe(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpdw_action_: ?*u32, lpsb_e_i_d_: ?*SBinary, hwnd_: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).GetMe(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpdw_action_, lpsb_e_i_d_, hwnd_);
            }
            pub inline fn setMe(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, sb_e_i_d_: SBinary, hwnd_: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).SetMe(@as(*const IWABObject, @ptrCast(self)), lp_i_a_b_, ul_flags_, sb_e_i_d_, hwnd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IWABOBJECT_QueryInterface_METHOD = *const fn (
    riid: ?*const Guid,
    ppv_obj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AddRef_METHOD = *const fn () callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_Release_METHOD = *const fn () callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_GetLastError_METHOD = *const fn (
    h_result: HRESULT,
    ul_flags: u32,
    lpp_m_a_p_i_error: ?*?*MAPIERROR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateBuffer_METHOD = *const fn (
    cb_size: u32,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateMore_METHOD = *const fn (
    cb_size: u32,
    lp_object: ?*anyopaque,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_FreeBuffer_METHOD = *const fn (
    lp_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Backup_METHOD = *const fn (
    lp_file_name: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Import_METHOD = *const fn (
    lp_w_i_p: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Find_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    h_wnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardDisplay_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    h_wnd: ?HWND,
    lpsz_file_name: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_LDAPUrl_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    h_wnd: ?HWND,
    ul_flags: u32,
    lpsz_u_r_l: ?PSTR,
    lpp_mail_user: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardCreate_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    ul_flags: u32,
    lpsz_v_card: ?PSTR,
    lp_mail_user: ?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardRetrieve_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    ul_flags: u32,
    lpsz_v_card: ?PSTR,
    lpp_mail_user: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_GetMe_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    ul_flags: u32,
    lpdw_action: ?*u32,
    lpsb_e_i_d: ?*SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_SetMe_METHOD = *const fn (
    lp_i_a_b: ?*IAddrBook,
    ul_flags: u32,
    sb_e_i_d: SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_ = extern struct {
    pub const VTable = extern struct {
        QueryInterface: *const fn (
            self: *const IWABOBJECT_,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: *const fn (
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: *const fn (
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetLastError: *const fn (
            self: *const IWABOBJECT_,
            h_result: HRESULT,
            ul_flags: u32,
            lpp_m_a_p_i_error: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: *const fn (
            self: *const IWABOBJECT_,
            cb_size: u32,
            lpp_buffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: *const fn (
            self: *const IWABOBJECT_,
            cb_size: u32,
            lp_object: ?*anyopaque,
            lpp_buffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: *const fn (
            self: *const IWABOBJECT_,
            lp_buffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: *const fn (
            self: *const IWABOBJECT_,
            lp_file_name: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: *const fn (
            self: *const IWABOBJECT_,
            lp_w_i_p: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
            lpsz_file_name: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            h_wnd: ?HWND,
            ul_flags: u32,
            lpsz_u_r_l: ?PSTR,
            lpp_mail_user: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpsz_v_card: ?PSTR,
            lp_mail_user: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpsz_v_card: ?PSTR,
            lpp_mail_user: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            lpdw_action: ?*u32,
            lpsb_e_i_d: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: *const fn (
            self: *const IWABOBJECT_,
            lp_i_a_b: ?*IAddrBook,
            ul_flags: u32,
            sb_e_i_d: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn queryInterface(self: *const T, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).QueryInterface(@as(*const IWABOBJECT_, @ptrCast(self)), riid_, ppv_obj_);
            }
            pub inline fn addRef(self: *const T) u32 {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AddRef(@as(*const IWABOBJECT_, @ptrCast(self)));
            }
            pub inline fn release(self: *const T) u32 {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Release(@as(*const IWABOBJECT_, @ptrCast(self)));
            }
            pub inline fn getLastError(self: *const T, h_result_: HRESULT, ul_flags_: u32, lpp_m_a_p_i_error_: ?*?*MAPIERROR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IWABOBJECT_, @ptrCast(self)), h_result_, ul_flags_, lpp_m_a_p_i_error_);
            }
            pub inline fn allocateBuffer(self: *const T, cb_size_: u32, lpp_buffer_: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IWABOBJECT_, @ptrCast(self)), cb_size_, lpp_buffer_);
            }
            pub inline fn allocateMore(self: *const T, cb_size_: u32, lp_object_: ?*anyopaque, lpp_buffer_: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AllocateMore(@as(*const IWABOBJECT_, @ptrCast(self)), cb_size_, lp_object_, lpp_buffer_);
            }
            pub inline fn freeBuffer(self: *const T, lp_buffer_: ?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IWABOBJECT_, @ptrCast(self)), lp_buffer_);
            }
            pub inline fn backup(self: *const T, lp_file_name_: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Backup(@as(*const IWABOBJECT_, @ptrCast(self)), lp_file_name_);
            }
            pub inline fn import(self: *const T, lp_w_i_p_: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Import(@as(*const IWABOBJECT_, @ptrCast(self)), lp_w_i_p_);
            }
            pub inline fn find(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Find(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, h_wnd_);
            }
            pub inline fn vCardDisplay(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND, lpsz_file_name_: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardDisplay(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, h_wnd_, lpsz_file_name_);
            }
            pub inline fn ldapUrl(self: *const T, lp_i_a_b_: ?*IAddrBook, h_wnd_: ?HWND, ul_flags_: u32, lpsz_u_r_l_: ?PSTR, lpp_mail_user_: ?*?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).LDAPUrl(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, h_wnd_, ul_flags_, lpsz_u_r_l_, lpp_mail_user_);
            }
            pub inline fn vCardCreate(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpsz_v_card_: ?PSTR, lp_mail_user_: ?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardCreate(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpsz_v_card_, lp_mail_user_);
            }
            pub inline fn vCardRetrieve(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpsz_v_card_: ?PSTR, lpp_mail_user_: ?*?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardRetrieve(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpsz_v_card_, lpp_mail_user_);
            }
            pub inline fn getMe(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, lpdw_action_: ?*u32, lpsb_e_i_d_: ?*SBinary, hwnd_: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).GetMe(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, ul_flags_, lpdw_action_, lpsb_e_i_d_, hwnd_);
            }
            pub inline fn setMe(self: *const T, lp_i_a_b_: ?*IAddrBook, ul_flags_: u32, sb_e_i_d_: SBinary, hwnd_: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).SetMe(@as(*const IWABOBJECT_, @ptrCast(self)), lp_i_a_b_, ul_flags_, sb_e_i_d_, hwnd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WAB_PARAM = extern struct {
    cbSize: u32,
    hwnd: ?HWND,
    szFileName: ?PSTR,
    ulFlags: u32,
    guidPSExt: Guid,
};

pub const LPWABOPEN = *const fn (
    lpp_adr_book: ?*?*IAddrBook,
    lpp_w_a_b_object: ?*?*IWABObject,
    lp_w_p: ?*WAB_PARAM,
    reserved2: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPWABOPENEX = *const fn (
    lpp_adr_book: ?*?*IAddrBook,
    lpp_w_a_b_object: ?*?*IWABObject,
    lp_w_p: ?*WAB_PARAM,
    reserved: u32,
    fn_allocate_buffer: ?LPALLOCATEBUFFER,
    fn_allocate_more: ?LPALLOCATEMORE,
    fn_free_buffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const WABIMPORTPARAM = extern struct {
    cbSize: u32,
    lpAdrBook: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszFileName: ?PSTR,
};

pub const WABEXTDISPLAY = extern struct {
    cbSize: u32,
    lpWABObject: ?*IWABObject,
    lpAdrBook: ?*IAddrBook,
    lpPropObj: ?*IMAPIProp,
    fReadOnly: BOOL,
    fDataChanged: BOOL,
    ulFlags: u32,
    lpv: ?*anyopaque,
    lpsz: ?*i8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWABExtInit_Value = Guid.initString("ea22ebf0-87a4-11d1-9acf-00a0c91f9c8b");
pub const IID_IWABExtInit = &IID_IWABExtInit_Value;
pub const IWABExtInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IWABExtInit,
            lp_w_a_b_ext_display: ?*WABEXTDISPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, lp_w_a_b_ext_display_: ?*WABEXTDISPLAY) HRESULT {
                return @as(*const IWABExtInit.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWABExtInit, @ptrCast(self)), lp_w_a_b_ext_display_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPWABALLOCATEBUFFER = *const fn (
    lp_w_a_b_object: ?*IWABObject,
    cb_size: u32,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABALLOCATEMORE = *const fn (
    lp_w_a_b_object: ?*IWABObject,
    cb_size: u32,
    lp_object: ?*anyopaque,
    lpp_buffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABFREEBUFFER = *const fn (
    lp_w_a_b_object: ?*IWABObject,
    lp_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const NOTIFKEY = extern struct {
    cb: u32,
    ab: [1]u8,
};

//--------------------------------------------------------------------------------
// Section: Functions (57)
//--------------------------------------------------------------------------------
pub extern "rtm" fn CreateTable(
    lp_interface: ?*Guid,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_allocate_more: ?LPALLOCATEMORE,
    lp_free_buffer: ?LPFREEBUFFER,
    lpv_reserved: ?*anyopaque,
    ul_table_type: u32,
    ul_prop_tag_index_column: u32,
    lp_s_prop_tag_array_columns: ?*SPropTagArray,
    lpp_table_data: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn CreateIProp(
    lp_interface: ?*Guid,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_allocate_more: ?LPALLOCATEMORE,
    lp_free_buffer: ?LPFREEBUFFER,
    lpv_reserved: ?*anyopaque,
    lpp_prop_data: ?*?*IPropData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIInitIdle(
    lpv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIDeinitIdle() callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtgRegisterIdleRoutine(
    lpfn_idle: ?PFNIDLE,
    lpv_idle_param: ?*anyopaque,
    pri_idle: i16,
    csec_idle: u32,
    iro_idle: u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "mapi32" fn DeregisterIdleRoutine(
    ftg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn EnableIdleRoutine(
    ftg: ?*anyopaque,
    f_enable: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn ChangeIdleRoutine(
    ftg: ?*anyopaque,
    lpfn_idle: ?PFNIDLE,
    lpv_idle_param: ?*anyopaque,
    pri_idle: i16,
    csec_idle: u32,
    iro_idle: u16,
    irc_idle: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn MAPIGetDefaultMalloc(
    retval: *?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn OpenStreamOnFile(
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_free_buffer: ?LPFREEBUFFER,
    ul_flags: u32,
    lpsz_file_name: ?*i8,
    lpsz_prefix: ?*i8,
    lpp_stream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn PropCopyMore(
    lp_s_prop_value_dest: ?*SPropValue,
    lp_s_prop_value_src: ?*SPropValue,
    lpf_alloc_more: ?LPALLOCATEMORE,
    lpv_object: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlPropSize(
    lp_s_prop_value: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn FEqualNames(
    lp_name1: ?*MAPINAMEID,
    lp_name2: ?*MAPINAMEID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropContainsProp(
    lp_s_prop_value_dst: ?*SPropValue,
    lp_s_prop_value_src: ?*SPropValue,
    ul_fuzzy_level: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropCompareProp(
    lp_s_prop_value1: ?*SPropValue,
    ul_rel_op: u32,
    lp_s_prop_value2: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn LPropCompareProp(
    lp_s_prop_value_a: ?*SPropValue,
    lp_s_prop_value_b: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn HrAddColumns(
    lptbl: ?*IMAPITable,
    lpproptag_columns_new: ?*SPropTagArray,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_free_buffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAddColumnsEx(
    lptbl: ?*IMAPITable,
    lpproptag_columns_new: ?*SPropTagArray,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_free_buffer: ?LPFREEBUFFER,
    lpfn_filter_columns: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAllocAdviseSink(
    lpfn_callback: ?LPNOTIFCALLBACK,
    lpv_context: ?*anyopaque,
    lpp_advise_sink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrThisThreadAdviseSink(
    lp_advise_sink: ?*IMAPIAdviseSink,
    lpp_advise_sink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrDispatchNotifications(
    ul_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn BuildDisplayTable(
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_allocate_more: ?LPALLOCATEMORE,
    lp_free_buffer: ?LPFREEBUFFER,
    lp_malloc: ?*IMalloc,
    h_instance: ?HINSTANCE,
    c_pages: u32,
    lp_page: ?*DTPAGE,
    ul_flags: u32,
    lpp_table: ?*?*IMAPITable,
    lpp_tbl_data: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScCountNotifications(
    c_notifications: i32,
    lp_notifications: ?*NOTIFICATION,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCopyNotifications(
    c_notification: i32,
    lp_notifications: ?*NOTIFICATION,
    lpv_dst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocNotifications(
    c_notification: i32,
    lp_notifications: ?*NOTIFICATION,
    lpv_base_old: ?*anyopaque,
    lpv_base_new: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCountProps(
    c_values: i32,
    lp_prop_array: ?*SPropValue,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn LpValFindProp(
    ul_prop_tag: u32,
    c_values: u32,
    lp_prop_array: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn ScCopyProps(
    c_values: i32,
    lp_prop_array: ?*SPropValue,
    lpv_dst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocProps(
    c_values: i32,
    lp_prop_array: ?*SPropValue,
    lpv_base_old: ?*anyopaque,
    lpv_base_new: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScDupPropset(
    c_values: i32,
    lp_prop_array: ?*SPropValue,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lpp_prop_array: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlAddRef(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn UlRelease(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn HrGetOneProp(
    lp_mapi_prop: ?*IMAPIProp,
    ul_prop_tag: u32,
    lpp_prop: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrSetOneProp(
    lp_mapi_prop: ?*IMAPIProp,
    lp_prop: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn FPropExists(
    lp_mapi_prop: ?*IMAPIProp,
    ul_prop_tag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn PpropFindProp(
    lp_prop_array: ?*SPropValue,
    c_values: u32,
    ul_prop_tag: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn FreePadrlist(
    lp_adrlist: ?*ADRLIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FreeProws(
    lp_rows: ?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn HrQueryAllRows(
    lp_table: ?*IMAPITable,
    lp_prop_tags: ?*SPropTagArray,
    lp_restriction: ?*SRestriction,
    lp_sort_order_set: ?*SSortOrderSet,
    crows_max: i32,
    lpp_rows: ?*?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn SzFindCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindLastCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindSz(
    lpsz: ?*i8,
    lpsz_key: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn UFromSz(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn ScUNCFromLocalPath(
    lpsz_local: ?PSTR,
    lpsz_u_n_c: [*:0]u8,
    cch_u_n_c: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScLocalPathFromUNC(
    lpsz_u_n_c: ?PSTR,
    lpsz_local: [*:0]u8,
    cch_local: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn FtAddFt(
    ft_addend1: FILETIME,
    ft_addend2: FILETIME,
    retval: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtMulDwDw(
    ft_multiplicand: u32,
    ft_multiplier: u32,
    retval: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtMulDw(
    ft_multiplier: u32,
    ft_multiplicand: FILETIME,
    retval: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtSubFt(
    ft_minuend: FILETIME,
    ft_subtrahend: FILETIME,
    retval: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtNegFt(
    ft: FILETIME,
    retval: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn ScCreateConversationIndex(
    cb_parent: u32,
    lpb_parent: ?*u8,
    lpcb_conv_index: ?*u32,
    lppb_conv_index: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn WrapStoreEntryID(
    ul_flags: u32,
    lpsz_d_l_l_name: ?*i8,
    cb_orig_entry: u32,
    // TODO: what to do with BytesParamIndex 2?
    lp_orig_entry: ?*ENTRYID,
    lpcb_wrapped_entry: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    lpp_wrapped_entry: ?*?*ENTRYID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn RTFSync(
    lp_message: ?*IMessage,
    ul_flags: u32,
    lpf_message_updated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn WrapCompressedRTFStream(
    lp_compressed_r_t_f_stream: ?*IStream,
    ul_flags: u32,
    lp_uncompressed_r_t_f_stream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrIStorageFromStream(
    lp_unk_in: ?*IUnknown,
    lp_interface: ?*Guid,
    ul_flags: u32,
    lpp_storage_out: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScInitMapiUtil(
    ul_flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn DeinitMapiUtil() callconv(@import("std").os.windows.WINAPI) void;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CY = @import("../system/com.zig").CY;
const FILETIME = @import("../foundation.zig").FILETIME;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMalloc = @import("../system/com.zig").IMalloc;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPALLOCATEBUFFER")) {
        _ = LPALLOCATEBUFFER;
    }
    if (@hasDecl(@This(), "LPALLOCATEMORE")) {
        _ = LPALLOCATEMORE;
    }
    if (@hasDecl(@This(), "LPFREEBUFFER")) {
        _ = LPFREEBUFFER;
    }
    if (@hasDecl(@This(), "LPNOTIFCALLBACK")) {
        _ = LPNOTIFCALLBACK;
    }
    if (@hasDecl(@This(), "LPFNABSDI")) {
        _ = LPFNABSDI;
    }
    if (@hasDecl(@This(), "LPFNDISMISS")) {
        _ = LPFNDISMISS;
    }
    if (@hasDecl(@This(), "LPFNBUTTON")) {
        _ = LPFNBUTTON;
    }
    if (@hasDecl(@This(), "FNIDLE")) {
        _ = FNIDLE;
    }
    if (@hasDecl(@This(), "PFNIDLE")) {
        _ = PFNIDLE;
    }
    if (@hasDecl(@This(), "LPOPENSTREAMONFILE")) {
        _ = LPOPENSTREAMONFILE;
    }
    if (@hasDecl(@This(), "LPDISPATCHNOTIFICATIONS")) {
        _ = LPDISPATCHNOTIFICATIONS;
    }
    if (@hasDecl(@This(), "LPCREATECONVERSATIONINDEX")) {
        _ = LPCREATECONVERSATIONINDEX;
    }
    if (@hasDecl(@This(), "IWABOBJECT_QueryInterface_METHOD")) {
        _ = IWABOBJECT_QueryInterface_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AddRef_METHOD")) {
        _ = IWABOBJECT_AddRef_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Release_METHOD")) {
        _ = IWABOBJECT_Release_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_GetLastError_METHOD")) {
        _ = IWABOBJECT_GetLastError_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateBuffer_METHOD")) {
        _ = IWABOBJECT_AllocateBuffer_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateMore_METHOD")) {
        _ = IWABOBJECT_AllocateMore_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_FreeBuffer_METHOD")) {
        _ = IWABOBJECT_FreeBuffer_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Backup_METHOD")) {
        _ = IWABOBJECT_Backup_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Import_METHOD")) {
        _ = IWABOBJECT_Import_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Find_METHOD")) {
        _ = IWABOBJECT_Find_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardDisplay_METHOD")) {
        _ = IWABOBJECT_VCardDisplay_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_LDAPUrl_METHOD")) {
        _ = IWABOBJECT_LDAPUrl_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardCreate_METHOD")) {
        _ = IWABOBJECT_VCardCreate_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardRetrieve_METHOD")) {
        _ = IWABOBJECT_VCardRetrieve_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_GetMe_METHOD")) {
        _ = IWABOBJECT_GetMe_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_SetMe_METHOD")) {
        _ = IWABOBJECT_SetMe_METHOD;
    }
    if (@hasDecl(@This(), "LPWABOPEN")) {
        _ = LPWABOPEN;
    }
    if (@hasDecl(@This(), "LPWABOPENEX")) {
        _ = LPWABOPENEX;
    }
    if (@hasDecl(@This(), "LPWABALLOCATEBUFFER")) {
        _ = LPWABALLOCATEBUFFER;
    }
    if (@hasDecl(@This(), "LPWABALLOCATEMORE")) {
        _ = LPWABALLOCATEMORE;
    }
    if (@hasDecl(@This(), "LPWABFREEBUFFER")) {
        _ = LPWABFREEBUFFER;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
