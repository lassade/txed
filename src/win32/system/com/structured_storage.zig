//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (66)
//--------------------------------------------------------------------------------
pub const PROPSETFLAG_DEFAULT = @as(u32, 0);
pub const PROPSETFLAG_NONSIMPLE = @as(u32, 1);
pub const PROPSETFLAG_ANSI = @as(u32, 2);
pub const PROPSETFLAG_UNBUFFERED = @as(u32, 4);
pub const PROPSETFLAG_CASE_SENSITIVE = @as(u32, 8);
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE = @as(u32, 1);
pub const PID_DICTIONARY = @as(u32, 0);
pub const PID_CODEPAGE = @as(u32, 1);
pub const PID_FIRST_USABLE = @as(u32, 2);
pub const PID_FIRST_NAME_DEFAULT = @as(u32, 4095);
pub const PID_LOCALE = @as(u32, 2147483648);
pub const PID_MODIFY_TIME = @as(u32, 2147483649);
pub const PID_SECURITY = @as(u32, 2147483650);
pub const PID_BEHAVIOR = @as(u32, 2147483651);
pub const PID_ILLEGAL = @as(u32, 4294967295);
pub const PID_MIN_READONLY = @as(u32, 2147483648);
pub const PID_MAX_READONLY = @as(u32, 3221225471);
pub const PRSPEC_INVALID = @as(u32, 4294967295);
pub const PROPSETHDR_OSVERSION_UNKNOWN = @as(u32, 4294967295);
pub const PIDDI_THUMBNAIL = @as(i32, 2);
pub const PIDSI_TITLE = @as(i32, 2);
pub const PIDSI_SUBJECT = @as(i32, 3);
pub const PIDSI_AUTHOR = @as(i32, 4);
pub const PIDSI_KEYWORDS = @as(i32, 5);
pub const PIDSI_COMMENTS = @as(i32, 6);
pub const PIDSI_TEMPLATE = @as(i32, 7);
pub const PIDSI_LASTAUTHOR = @as(i32, 8);
pub const PIDSI_REVNUMBER = @as(i32, 9);
pub const PIDSI_EDITTIME = @as(i32, 10);
pub const PIDSI_LASTPRINTED = @as(i32, 11);
pub const PIDSI_CREATE_DTM = @as(i32, 12);
pub const PIDSI_LASTSAVE_DTM = @as(i32, 13);
pub const PIDSI_PAGECOUNT = @as(i32, 14);
pub const PIDSI_WORDCOUNT = @as(i32, 15);
pub const PIDSI_CHARCOUNT = @as(i32, 16);
pub const PIDSI_THUMBNAIL = @as(i32, 17);
pub const PIDSI_APPNAME = @as(i32, 18);
pub const PIDSI_DOC_SECURITY = @as(i32, 19);
pub const PIDDSI_CATEGORY = @as(u32, 2);
pub const PIDDSI_PRESFORMAT = @as(u32, 3);
pub const PIDDSI_BYTECOUNT = @as(u32, 4);
pub const PIDDSI_LINECOUNT = @as(u32, 5);
pub const PIDDSI_PARCOUNT = @as(u32, 6);
pub const PIDDSI_SLIDECOUNT = @as(u32, 7);
pub const PIDDSI_NOTECOUNT = @as(u32, 8);
pub const PIDDSI_HIDDENCOUNT = @as(u32, 9);
pub const PIDDSI_MMCLIPCOUNT = @as(u32, 10);
pub const PIDDSI_SCALE = @as(u32, 11);
pub const PIDDSI_HEADINGPAIR = @as(u32, 12);
pub const PIDDSI_DOCPARTS = @as(u32, 13);
pub const PIDDSI_MANAGER = @as(u32, 14);
pub const PIDDSI_COMPANY = @as(u32, 15);
pub const PIDDSI_LINKSDIRTY = @as(u32, 16);
pub const PIDMSI_EDITOR = @as(i32, 2);
pub const PIDMSI_SUPPLIER = @as(i32, 3);
pub const PIDMSI_SOURCE = @as(i32, 4);
pub const PIDMSI_SEQUENCE_NO = @as(i32, 5);
pub const PIDMSI_PROJECT = @as(i32, 6);
pub const PIDMSI_STATUS = @as(i32, 7);
pub const PIDMSI_OWNER = @as(i32, 8);
pub const PIDMSI_RATING = @as(i32, 9);
pub const PIDMSI_PRODUCTION = @as(i32, 10);
pub const PIDMSI_COPYRIGHT = @as(i32, 11);
pub const CWCSTORAGENAME = @as(u32, 32);
pub const STGOPTIONS_VERSION = @as(u32, 1);
pub const CCH_MAX_PROPSTG_NAME = @as(u32, 31);

//--------------------------------------------------------------------------------
// Section: Types (58)
//--------------------------------------------------------------------------------
pub const PROPSPEC_KIND = enum(u32) {
    LPWSTR = 0,
    PROPID = 1,
};
pub const PRSPEC_LPWSTR = PROPSPEC_KIND.LPWSTR;
pub const PRSPEC_PROPID = PROPSPEC_KIND.PROPID;

pub const STGM = enum(u32) {
    DIRECT = 0,
    TRANSACTED = 65536,
    SIMPLE = 134217728,
    // READ = 0, this enum value conflicts with DIRECT
    WRITE = 1,
    READWRITE = 2,
    SHARE_DENY_NONE = 64,
    SHARE_DENY_READ = 48,
    SHARE_DENY_WRITE = 32,
    SHARE_EXCLUSIVE = 16,
    PRIORITY = 262144,
    DELETEONRELEASE = 67108864,
    NOSCRATCH = 1048576,
    CREATE = 4096,
    CONVERT = 131072,
    // FAILIFTHERE = 0, this enum value conflicts with DIRECT
    NOSNAPSHOT = 2097152,
    DIRECT_SWMR = 4194304,
    _,
    pub fn initFlags(o: struct {
        DIRECT: u1 = 0,
        TRANSACTED: u1 = 0,
        SIMPLE: u1 = 0,
        WRITE: u1 = 0,
        READWRITE: u1 = 0,
        SHARE_DENY_NONE: u1 = 0,
        SHARE_DENY_READ: u1 = 0,
        SHARE_DENY_WRITE: u1 = 0,
        SHARE_EXCLUSIVE: u1 = 0,
        PRIORITY: u1 = 0,
        DELETEONRELEASE: u1 = 0,
        NOSCRATCH: u1 = 0,
        CREATE: u1 = 0,
        CONVERT: u1 = 0,
        NOSNAPSHOT: u1 = 0,
        DIRECT_SWMR: u1 = 0,
    }) STGM {
        return @as(STGM, @enumFromInt((if (o.DIRECT == 1) @intFromEnum(STGM.DIRECT) else 0) | (if (o.TRANSACTED == 1) @intFromEnum(STGM.TRANSACTED) else 0) | (if (o.SIMPLE == 1) @intFromEnum(STGM.SIMPLE) else 0) | (if (o.WRITE == 1) @intFromEnum(STGM.WRITE) else 0) | (if (o.READWRITE == 1) @intFromEnum(STGM.READWRITE) else 0) | (if (o.SHARE_DENY_NONE == 1) @intFromEnum(STGM.SHARE_DENY_NONE) else 0) | (if (o.SHARE_DENY_READ == 1) @intFromEnum(STGM.SHARE_DENY_READ) else 0) | (if (o.SHARE_DENY_WRITE == 1) @intFromEnum(STGM.SHARE_DENY_WRITE) else 0) | (if (o.SHARE_EXCLUSIVE == 1) @intFromEnum(STGM.SHARE_EXCLUSIVE) else 0) | (if (o.PRIORITY == 1) @intFromEnum(STGM.PRIORITY) else 0) | (if (o.DELETEONRELEASE == 1) @intFromEnum(STGM.DELETEONRELEASE) else 0) | (if (o.NOSCRATCH == 1) @intFromEnum(STGM.NOSCRATCH) else 0) | (if (o.CREATE == 1) @intFromEnum(STGM.CREATE) else 0) | (if (o.CONVERT == 1) @intFromEnum(STGM.CONVERT) else 0) | (if (o.NOSNAPSHOT == 1) @intFromEnum(STGM.NOSNAPSHOT) else 0) | (if (o.DIRECT_SWMR == 1) @intFromEnum(STGM.DIRECT_SWMR) else 0)));
    }
};
pub const STGM_DIRECT = STGM.DIRECT;
pub const STGM_TRANSACTED = STGM.TRANSACTED;
pub const STGM_SIMPLE = STGM.SIMPLE;
pub const STGM_READ = STGM.DIRECT;
pub const STGM_WRITE = STGM.WRITE;
pub const STGM_READWRITE = STGM.READWRITE;
pub const STGM_SHARE_DENY_NONE = STGM.SHARE_DENY_NONE;
pub const STGM_SHARE_DENY_READ = STGM.SHARE_DENY_READ;
pub const STGM_SHARE_DENY_WRITE = STGM.SHARE_DENY_WRITE;
pub const STGM_SHARE_EXCLUSIVE = STGM.SHARE_EXCLUSIVE;
pub const STGM_PRIORITY = STGM.PRIORITY;
pub const STGM_DELETEONRELEASE = STGM.DELETEONRELEASE;
pub const STGM_NOSCRATCH = STGM.NOSCRATCH;
pub const STGM_CREATE = STGM.CREATE;
pub const STGM_CONVERT = STGM.CONVERT;
pub const STGM_FAILIFTHERE = STGM.DIRECT;
pub const STGM_NOSNAPSHOT = STGM.NOSNAPSHOT;
pub const STGM_DIRECT_SWMR = STGM.DIRECT_SWMR;

pub const STGFMT = enum(u32) {
    STORAGE = 0,
    NATIVE = 1,
    FILE = 3,
    ANY = 4,
    DOCFILE = 5,
    // DOCUMENT = 0, this enum value conflicts with STORAGE
};
pub const STGFMT_STORAGE = STGFMT.STORAGE;
pub const STGFMT_NATIVE = STGFMT.NATIVE;
pub const STGFMT_FILE = STGFMT.FILE;
pub const STGFMT_ANY = STGFMT.ANY;
pub const STGFMT_DOCFILE = STGFMT.DOCFILE;
pub const STGFMT_DOCUMENT = STGFMT.STORAGE;

pub const STGC = enum(u32) {
    DEFAULT = 0,
    OVERWRITE = 1,
    ONLYIFCURRENT = 2,
    DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    CONSOLIDATE = 8,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        OVERWRITE: u1 = 0,
        ONLYIFCURRENT: u1 = 0,
        DANGEROUSLYCOMMITMERELYTODISKCACHE: u1 = 0,
        CONSOLIDATE: u1 = 0,
    }) STGC {
        return @as(STGC, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(STGC.DEFAULT) else 0) | (if (o.OVERWRITE == 1) @intFromEnum(STGC.OVERWRITE) else 0) | (if (o.ONLYIFCURRENT == 1) @intFromEnum(STGC.ONLYIFCURRENT) else 0) | (if (o.DANGEROUSLYCOMMITMERELYTODISKCACHE == 1) @intFromEnum(STGC.DANGEROUSLYCOMMITMERELYTODISKCACHE) else 0) | (if (o.CONSOLIDATE == 1) @intFromEnum(STGC.CONSOLIDATE) else 0)));
    }
};
pub const STGC_DEFAULT = STGC.DEFAULT;
pub const STGC_OVERWRITE = STGC.OVERWRITE;
pub const STGC_ONLYIFCURRENT = STGC.ONLYIFCURRENT;
pub const STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = STGC.DANGEROUSLYCOMMITMERELYTODISKCACHE;
pub const STGC_CONSOLIDATE = STGC.CONSOLIDATE;

pub const STGMOVE = enum(i32) {
    MOVE = 0,
    COPY = 1,
    SHALLOWCOPY = 2,
};
pub const STGMOVE_MOVE = STGMOVE.MOVE;
pub const STGMOVE_COPY = STGMOVE.COPY;
pub const STGMOVE_SHALLOWCOPY = STGMOVE.SHALLOWCOPY;

pub const STATFLAG = enum(i32) {
    DEFAULT = 0,
    NONAME = 1,
    NOOPEN = 2,
};
pub const STATFLAG_DEFAULT = STATFLAG.DEFAULT;
pub const STATFLAG_NONAME = STATFLAG.NONAME;
pub const STATFLAG_NOOPEN = STATFLAG.NOOPEN;

pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: ?*u8,
};

pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: ?*u8,
};

pub const LOCKTYPE = enum(i32) {
    WRITE = 1,
    EXCLUSIVE = 2,
    ONLYONCE = 4,
};
pub const LOCK_WRITE = LOCKTYPE.WRITE;
pub const LOCK_EXCLUSIVE = LOCKTYPE.EXCLUSIVE;
pub const LOCK_ONLYONCE = LOCKTYPE.ONLYONCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATSTG_Value = Guid.initString("0000000d-0000-0000-c000-000000000046");
pub const IID_IEnumSTATSTG = &IID_IEnumSTATSTG_Value;
pub const IEnumSTATSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSTATSTG,
            celt: u32,
            rgelt: [*]STATSTG,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSTATSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSTATSTG,
            ppenum: ?*?*IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]STATSTG, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATSTG, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATSTG, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATSTG, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSTATSTG) HRESULT {
                return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATSTG, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RemSNB = extern struct {
    ulCntStr: u32,
    ulCntChar: u32,
    rgString: [1]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStorage_Value = Guid.initString("0000000b-0000-0000-c000-000000000046");
pub const IID_IStorage = &IID_IStorage_Value;
pub const IStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            grf_mode: STGM,
            reserved1: u32,
            reserved2: u32,
            ppstm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStream: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            reserved1: ?*anyopaque,
            grf_mode: STGM,
            reserved2: u32,
            ppstm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStorage: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            grf_mode: STGM,
            reserved1: u32,
            reserved2: u32,
            ppstg: ?*?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStorage: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            pstg_priority: ?*IStorage,
            grf_mode: STGM,
            snb_exclude: ?*?*u16,
            reserved: u32,
            ppstg: ?*?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: *const fn (
            self: *const IStorage,
            ciid_exclude: u32,
            rgiid_exclude: ?[*]const Guid,
            snb_exclude: ?*?*u16,
            pstg_dest: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveElementTo: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            pstg_dest: ?*IStorage,
            pwcs_new_name: ?[*:0]const u16,
            grf_flags: STGMOVE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IStorage,
            grf_commit_flags: STGC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: *const fn (
            self: *const IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumElements: *const fn (
            self: *const IStorage,
            reserved1: u32,
            reserved2: ?*anyopaque,
            reserved3: u32,
            ppenum: ?*?*IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyElement: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameElement: *const fn (
            self: *const IStorage,
            pwcs_old_name: ?[*:0]const u16,
            pwcs_new_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetElementTimes: *const fn (
            self: *const IStorage,
            pwcs_name: ?[*:0]const u16,
            pctime: ?*const FILETIME,
            patime: ?*const FILETIME,
            pmtime: ?*const FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClass: *const fn (
            self: *const IStorage,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStateBits: *const fn (
            self: *const IStorage,
            grf_state_bits: u32,
            grf_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: *const fn (
            self: *const IStorage,
            pstatstg: ?*STATSTG,
            grf_stat_flag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createStream(self: *const T, pwcs_name_: ?[*:0]const u16, grf_mode_: STGM, reserved1_: u32, reserved2_: u32, ppstm_: ?*?*IStream) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const IStorage, @ptrCast(self)), pwcs_name_, grf_mode_, reserved1_, reserved2_, ppstm_);
            }
            pub inline fn openStream(self: *const T, pwcs_name_: ?[*:0]const u16, reserved1_: ?*anyopaque, grf_mode_: STGM, reserved2_: u32, ppstm_: ?*?*IStream) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStream(@as(*const IStorage, @ptrCast(self)), pwcs_name_, reserved1_, grf_mode_, reserved2_, ppstm_);
            }
            pub inline fn createStorage(self: *const T, pwcs_name_: ?[*:0]const u16, grf_mode_: STGM, reserved1_: u32, reserved2_: u32, ppstg_: ?*?*IStorage) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStorage(@as(*const IStorage, @ptrCast(self)), pwcs_name_, grf_mode_, reserved1_, reserved2_, ppstg_);
            }
            pub inline fn openStorage(self: *const T, pwcs_name_: ?[*:0]const u16, pstg_priority_: ?*IStorage, grf_mode_: STGM, snb_exclude_: ?*?*u16, reserved_: u32, ppstg_: ?*?*IStorage) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStorage(@as(*const IStorage, @ptrCast(self)), pwcs_name_, pstg_priority_, grf_mode_, snb_exclude_, reserved_, ppstg_);
            }
            pub inline fn copyTo(self: *const T, ciid_exclude_: u32, rgiid_exclude_: ?[*]const Guid, snb_exclude_: ?*?*u16, pstg_dest_: ?*IStorage) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IStorage, @ptrCast(self)), ciid_exclude_, rgiid_exclude_, snb_exclude_, pstg_dest_);
            }
            pub inline fn moveElementTo(self: *const T, pwcs_name_: ?[*:0]const u16, pstg_dest_: ?*IStorage, pwcs_new_name_: ?[*:0]const u16, grf_flags_: STGMOVE) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).MoveElementTo(@as(*const IStorage, @ptrCast(self)), pwcs_name_, pstg_dest_, pwcs_new_name_, grf_flags_);
            }
            pub inline fn commit(self: *const T, grf_commit_flags_: STGC) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IStorage, @ptrCast(self)), grf_commit_flags_);
            }
            pub inline fn revert(self: *const T) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IStorage, @ptrCast(self)));
            }
            pub inline fn enumElements(self: *const T, reserved1_: u32, reserved2_: ?*anyopaque, reserved3_: u32, ppenum_: ?*?*IEnumSTATSTG) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).EnumElements(@as(*const IStorage, @ptrCast(self)), reserved1_, reserved2_, reserved3_, ppenum_);
            }
            pub inline fn destroyElement(self: *const T, pwcs_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).DestroyElement(@as(*const IStorage, @ptrCast(self)), pwcs_name_);
            }
            pub inline fn renameElement(self: *const T, pwcs_old_name_: ?[*:0]const u16, pwcs_new_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).RenameElement(@as(*const IStorage, @ptrCast(self)), pwcs_old_name_, pwcs_new_name_);
            }
            pub inline fn setElementTimes(self: *const T, pwcs_name_: ?[*:0]const u16, pctime_: ?*const FILETIME, patime_: ?*const FILETIME, pmtime_: ?*const FILETIME) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetElementTimes(@as(*const IStorage, @ptrCast(self)), pwcs_name_, pctime_, patime_, pmtime_);
            }
            pub inline fn setClass(self: *const T, clsid_: ?*const Guid) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IStorage, @ptrCast(self)), clsid_);
            }
            pub inline fn setStateBits(self: *const T, grf_state_bits_: u32, grf_mask_: u32) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetStateBits(@as(*const IStorage, @ptrCast(self)), grf_state_bits_, grf_mask_);
            }
            pub inline fn stat(self: *const T, pstatstg_: ?*STATSTG, grf_stat_flag_: u32) HRESULT {
                return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IStorage, @ptrCast(self)), pstatstg_, grf_stat_flag_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStorage_Value = Guid.initString("0000010a-0000-0000-c000-000000000046");
pub const IID_IPersistStorage = &IID_IPersistStorage_Value;
pub const IPersistStorage = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: *const fn (
            self: *const IPersistStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: *const fn (
            self: *const IPersistStorage,
            p_stg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistStorage,
            p_stg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistStorage,
            p_stg_save: ?*IStorage,
            f_same_as_load: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: *const fn (
            self: *const IPersistStorage,
            p_stg_new: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: *const fn (
            self: *const IPersistStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn isDirty(self: *const T) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStorage, @ptrCast(self)));
            }
            pub inline fn initNew(self: *const T, p_stg_: ?*IStorage) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistStorage, @ptrCast(self)), p_stg_);
            }
            pub inline fn load(self: *const T, p_stg_: ?*IStorage) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStorage, @ptrCast(self)), p_stg_);
            }
            pub inline fn save(self: *const T, p_stg_save_: ?*IStorage, f_same_as_load_: BOOL) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStorage, @ptrCast(self)), p_stg_save_, f_same_as_load_);
            }
            pub inline fn saveCompleted(self: *const T, p_stg_new_: ?*IStorage) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IPersistStorage, @ptrCast(self)), p_stg_new_);
            }
            pub inline fn handsOffStorage(self: *const T) HRESULT {
                return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).HandsOffStorage(@as(*const IPersistStorage, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILockBytes_Value = Guid.initString("0000000a-0000-0000-c000-000000000046");
pub const IID_ILockBytes = &IID_ILockBytes_Value;
pub const ILockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadAt: *const fn (
            self: *const ILockBytes,
            ul_offset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: ?*anyopaque,
            cb: u32,
            pcb_read: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAt: *const fn (
            self: *const ILockBytes,
            ul_offset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: ?*const anyopaque,
            cb: u32,
            pcb_written: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: *const fn (
            self: *const ILockBytes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: *const fn (
            self: *const ILockBytes,
            cb: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRegion: *const fn (
            self: *const ILockBytes,
            lib_offset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dw_lock_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRegion: *const fn (
            self: *const ILockBytes,
            lib_offset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dw_lock_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: *const fn (
            self: *const ILockBytes,
            pstatstg: ?*STATSTG,
            grf_stat_flag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn readAt(self: *const T, ul_offset_: ULARGE_INTEGER, pv_: ?*anyopaque, cb_: u32, pcb_read_: ?*u32) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).ReadAt(@as(*const ILockBytes, @ptrCast(self)), ul_offset_, pv_, cb_, pcb_read_);
            }
            pub inline fn writeAt(self: *const T, ul_offset_: ULARGE_INTEGER, pv_: ?*const anyopaque, cb_: u32, pcb_written_: ?*u32) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).WriteAt(@as(*const ILockBytes, @ptrCast(self)), ul_offset_, pv_, cb_, pcb_written_);
            }
            pub inline fn flush(self: *const T) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Flush(@as(*const ILockBytes, @ptrCast(self)));
            }
            pub inline fn setSize(self: *const T, cb_: ULARGE_INTEGER) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).SetSize(@as(*const ILockBytes, @ptrCast(self)), cb_);
            }
            pub inline fn lockRegion(self: *const T, lib_offset_: ULARGE_INTEGER, cb_: ULARGE_INTEGER, dw_lock_type_: u32) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).LockRegion(@as(*const ILockBytes, @ptrCast(self)), lib_offset_, cb_, dw_lock_type_);
            }
            pub inline fn unlockRegion(self: *const T, lib_offset_: ULARGE_INTEGER, cb_: ULARGE_INTEGER, dw_lock_type_: u32) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).UnlockRegion(@as(*const ILockBytes, @ptrCast(self)), lib_offset_, cb_, dw_lock_type_);
            }
            pub inline fn stat(self: *const T, pstatstg_: ?*STATSTG, grf_stat_flag_: u32) HRESULT {
                return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Stat(@as(*const ILockBytes, @ptrCast(self)), pstatstg_, grf_stat_flag_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRootStorage_Value = Guid.initString("00000012-0000-0000-c000-000000000046");
pub const IID_IRootStorage = &IID_IRootStorage_Value;
pub const IRootStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchToFile: *const fn (
            self: *const IRootStorage,
            psz_file: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn switchToFile(self: *const T, psz_file_: ?PWSTR) HRESULT {
                return @as(*const IRootStorage.VTable, @ptrCast(self.vtable)).SwitchToFile(@as(*const IRootStorage, @ptrCast(self)), psz_file_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFillLockBytes_Value = Guid.initString("99caf010-415e-11cf-8814-00aa00b569f5");
pub const IID_IFillLockBytes = &IID_IFillLockBytes_Value;
pub const IFillLockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FillAppend: *const fn (
            self: *const IFillLockBytes,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*const anyopaque,
            cb: u32,
            pcb_written: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillAt: *const fn (
            self: *const IFillLockBytes,
            ul_offset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: ?*const anyopaque,
            cb: u32,
            pcb_written: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFillSize: *const fn (
            self: *const IFillLockBytes,
            ul_size: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: *const fn (
            self: *const IFillLockBytes,
            b_canceled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn fillAppend(self: *const T, pv_: ?*const anyopaque, cb_: u32, pcb_written_: ?*u32) HRESULT {
                return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAppend(@as(*const IFillLockBytes, @ptrCast(self)), pv_, cb_, pcb_written_);
            }
            pub inline fn fillAt(self: *const T, ul_offset_: ULARGE_INTEGER, pv_: ?*const anyopaque, cb_: u32, pcb_written_: ?*u32) HRESULT {
                return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAt(@as(*const IFillLockBytes, @ptrCast(self)), ul_offset_, pv_, cb_, pcb_written_);
            }
            pub inline fn setFillSize(self: *const T, ul_size_: ULARGE_INTEGER) HRESULT {
                return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).SetFillSize(@as(*const IFillLockBytes, @ptrCast(self)), ul_size_);
            }
            pub inline fn terminate(self: *const T, b_canceled_: BOOL) HRESULT {
                return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IFillLockBytes, @ptrCast(self)), b_canceled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILayoutStorage_Value = Guid.initString("0e6d4d90-6738-11cf-9608-00aa00680db4");
pub const IID_ILayoutStorage = &IID_ILayoutStorage_Value;
pub const ILayoutStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LayoutScript: *const fn (
            self: *const ILayoutStorage,
            p_storage_layout: [*]StorageLayout,
            n_entries: u32,
            glf_interleaved_flag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginMonitor: *const fn (
            self: *const ILayoutStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndMonitor: *const fn (
            self: *const ILayoutStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReLayoutDocfile: *const fn (
            self: *const ILayoutStorage,
            pwcs_new_df_name: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReLayoutDocfileOnILockBytes: *const fn (
            self: *const ILayoutStorage,
            p_i_lock_bytes: ?*ILockBytes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn layoutScript(self: *const T, p_storage_layout_: [*]StorageLayout, n_entries_: u32, glf_interleaved_flag_: u32) HRESULT {
                return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).LayoutScript(@as(*const ILayoutStorage, @ptrCast(self)), p_storage_layout_, n_entries_, glf_interleaved_flag_);
            }
            pub inline fn beginMonitor(self: *const T) HRESULT {
                return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).BeginMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
            }
            pub inline fn endMonitor(self: *const T) HRESULT {
                return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).EndMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
            }
            pub inline fn reLayoutDocfile(self: *const T, pwcs_new_df_name_: ?PWSTR) HRESULT {
                return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfile(@as(*const ILayoutStorage, @ptrCast(self)), pwcs_new_df_name_);
            }
            pub inline fn reLayoutDocfileOnILockBytes(self: *const T, p_i_lock_bytes_: ?*ILockBytes) HRESULT {
                return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfileOnILockBytes(@as(*const ILayoutStorage, @ptrCast(self)), p_i_lock_bytes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectWriterLock_Value = Guid.initString("0e6d4d92-6738-11cf-9608-00aa00680db4");
pub const IID_IDirectWriterLock = &IID_IDirectWriterLock_Value;
pub const IDirectWriterLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForWriteAccess: *const fn (
            self: *const IDirectWriterLock,
            dw_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseWriteAccess: *const fn (
            self: *const IDirectWriterLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HaveWriteAccess: *const fn (
            self: *const IDirectWriterLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn waitForWriteAccess(self: *const T, dw_timeout_: u32) HRESULT {
                return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).WaitForWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)), dw_timeout_);
            }
            pub inline fn releaseWriteAccess(self: *const T) HRESULT {
                return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).ReleaseWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
            }
            pub inline fn haveWriteAccess(self: *const T) HRESULT {
                return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).HaveWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VERSIONEDSTREAM = extern struct {
    guidVersion: Guid,
    pStream: ?*IStream,
};

pub const CAC = extern struct {
    cElems: u32,
    pElems: ?PSTR,
};

pub const CAUB = extern struct {
    cElems: u32,
    pElems: ?*u8,
};

pub const CAI = extern struct {
    cElems: u32,
    pElems: ?*i16,
};

pub const CAUI = extern struct {
    cElems: u32,
    pElems: ?*u16,
};

pub const CAL = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAUL = extern struct {
    cElems: u32,
    pElems: ?*u32,
};

pub const CAFLT = extern struct {
    cElems: u32,
    pElems: ?*f32,
};

pub const CADBL = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CACY = extern struct {
    cElems: u32,
    pElems: ?*CY,
};

pub const CADATE = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CABSTR = extern struct {
    cElems: u32,
    pElems: ?*?BSTR,
};

pub const CABSTRBLOB = extern struct {
    cElems: u32,
    pElems: ?*BSTRBLOB,
};

pub const CABOOL = extern struct {
    cElems: u32,
    pElems: ?*i16,
};

pub const CASCODE = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAPROPVARIANT = extern struct {
    cElems: u32,
    pElems: ?*PROPVARIANT,
};

pub const CAH = extern struct {
    cElems: u32,
    pElems: ?*LARGE_INTEGER,
};

pub const CAUH = extern struct {
    cElems: u32,
    pElems: ?*ULARGE_INTEGER,
};

pub const CALPSTR = extern struct {
    cElems: u32,
    pElems: ?*?PSTR,
};

pub const CALPWSTR = extern struct {
    cElems: u32,
    pElems: ?*?PWSTR,
};

pub const CAFILETIME = extern struct {
    cElems: u32,
    pElems: ?*FILETIME,
};

pub const CACLIPDATA = extern struct {
    cElems: u32,
    pElems: ?*CLIPDATA,
};

pub const CACLSID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};

pub const PROPVARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                cVal: CHAR,
                bVal: u8,
                iVal: i16,
                uiVal: u16,
                lVal: i32,
                ulVal: u32,
                intVal: i32,
                uintVal: u32,
                hVal: LARGE_INTEGER,
                uhVal: ULARGE_INTEGER,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                filetime: FILETIME,
                puuid: ?*Guid,
                pclipdata: ?*CLIPDATA,
                bstrVal: ?BSTR,
                bstrblobVal: BSTRBLOB,
                blob: BLOB,
                pszVal: ?PSTR,
                pwszVal: ?PWSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                pStream: ?*IStream,
                pStorage: ?*IStorage,
                pVersionedStream: ?*VERSIONEDSTREAM,
                parray: ?*SAFEARRAY,
                cac: CAC,
                caub: CAUB,
                cai: CAI,
                caui: CAUI,
                cal: CAL,
                caul: CAUL,
                cah: CAH,
                cauh: CAUH,
                caflt: CAFLT,
                cadbl: CADBL,
                cabool: CABOOL,
                cascode: CASCODE,
                cacy: CACY,
                cadate: CADATE,
                cafiletime: CAFILETIME,
                cauuid: CACLSID,
                caclipdata: CACLIPDATA,
                cabstr: CABSTR,
                cabstrblob: CABSTRBLOB,
                calpstr: CALPSTR,
                calpwstr: CALPWSTR,
                capropvar: CAPROPVARIANT,
                pcVal: ?PSTR,
                pbVal: ?*u8,
                piVal: ?*i16,
                puiVal: ?*u16,
                plVal: ?*i32,
                pulVal: ?*u32,
                pintVal: ?*i32,
                puintVal: ?*u32,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                pdecVal: ?*DECIMAL,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*PROPVARIANT,
            },
        },
        decVal: DECIMAL,
    },
};

pub const PROPSPEC = extern struct {
    ulKind: PROPSPEC_KIND,
    Anonymous: extern union {
        propid: u32,
        lpwstr: ?PWSTR,
    },
};

pub const STATPROPSTG = extern struct {
    lpwstrName: ?PWSTR,
    propid: u32,
    vt: u16,
};

pub const STATPROPSETSTG = extern struct {
    fmtid: Guid,
    clsid: Guid,
    grfFlags: u32,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyStorage_Value = Guid.initString("00000138-0000-0000-c000-000000000046");
pub const IID_IPropertyStorage = &IID_IPropertyStorage_Value;
pub const IPropertyStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMultiple: *const fn (
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
            rgpropvar: [*]PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMultiple: *const fn (
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
            rgpropvar: [*]const PROPVARIANT,
            propid_name_first: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMultiple: *const fn (
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPropertyNames: *const fn (
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
            rglpwstr_name: [*]?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePropertyNames: *const fn (
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
            rglpwstr_name: [*]const ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyNames: *const fn (
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IPropertyStorage,
            grf_commit_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: *const fn (
            self: *const IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: *const fn (
            self: *const IPropertyStorage,
            ppenum: ?*?*IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimes: *const fn (
            self: *const IPropertyStorage,
            pctime: ?*const FILETIME,
            patime: ?*const FILETIME,
            pmtime: ?*const FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClass: *const fn (
            self: *const IPropertyStorage,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: *const fn (
            self: *const IPropertyStorage,
            pstatpsstg: ?*STATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn readMultiple(self: *const T, cpspec_: u32, rgpspec_: [*]const PROPSPEC, rgpropvar_: [*]PROPVARIANT) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec_, rgpspec_, rgpropvar_);
            }
            pub inline fn writeMultiple(self: *const T, cpspec_: u32, rgpspec_: [*]const PROPSPEC, rgpropvar_: [*]const PROPVARIANT, propid_name_first_: u32) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WriteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec_, rgpspec_, rgpropvar_, propid_name_first_);
            }
            pub inline fn deleteMultiple(self: *const T, cpspec_: u32, rgpspec_: [*]const PROPSPEC) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeleteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec_, rgpspec_);
            }
            pub inline fn readPropertyNames(self: *const T, cpropid_: u32, rgpropid_: [*]const u32, rglpwstr_name_: [*]?PWSTR) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadPropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid_, rgpropid_, rglpwstr_name_);
            }
            pub inline fn writePropertyNames(self: *const T, cpropid_: u32, rgpropid_: [*]const u32, rglpwstr_name_: [*]const ?[*:0]const u16) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WritePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid_, rgpropid_, rglpwstr_name_);
            }
            pub inline fn deletePropertyNames(self: *const T, cpropid_: u32, rgpropid_: [*]const u32) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeletePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid_, rgpropid_);
            }
            pub inline fn commit(self: *const T, grf_commit_flags_: u32) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IPropertyStorage, @ptrCast(self)), grf_commit_flags_);
            }
            pub inline fn revert(self: *const T) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IPropertyStorage, @ptrCast(self)));
            }
            pub inline fn @"enum"(self: *const T, ppenum_: ?*?*IEnumSTATPROPSTG) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertyStorage, @ptrCast(self)), ppenum_);
            }
            pub inline fn setTimes(self: *const T, pctime_: ?*const FILETIME, patime_: ?*const FILETIME, pmtime_: ?*const FILETIME) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetTimes(@as(*const IPropertyStorage, @ptrCast(self)), pctime_, patime_, pmtime_);
            }
            pub inline fn setClass(self: *const T, clsid_: ?*const Guid) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IPropertyStorage, @ptrCast(self)), clsid_);
            }
            pub inline fn stat(self: *const T, pstatpsstg_: ?*STATPROPSETSTG) HRESULT {
                return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IPropertyStorage, @ptrCast(self)), pstatpsstg_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertySetStorage_Value = Guid.initString("0000013a-0000-0000-c000-000000000046");
pub const IID_IPropertySetStorage = &IID_IPropertySetStorage_Value;
pub const IPropertySetStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: *const fn (
            self: *const IPropertySetStorage,
            rfmtid: ?*const Guid,
            pclsid: ?*const Guid,
            grf_flags: u32,
            grf_mode: u32,
            ppprstg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: *const fn (
            self: *const IPropertySetStorage,
            rfmtid: ?*const Guid,
            grf_mode: u32,
            ppprstg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const IPropertySetStorage,
            rfmtid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: *const fn (
            self: *const IPropertySetStorage,
            ppenum: ?*?*IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn create(self: *const T, rfmtid_: ?*const Guid, pclsid_: ?*const Guid, grf_flags_: u32, grf_mode_: u32, ppprstg_: ?*?*IPropertyStorage) HRESULT {
                return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Create(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid_, pclsid_, grf_flags_, grf_mode_, ppprstg_);
            }
            pub inline fn open(self: *const T, rfmtid_: ?*const Guid, grf_mode_: u32, ppprstg_: ?*?*IPropertyStorage) HRESULT {
                return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Open(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid_, grf_mode_, ppprstg_);
            }
            pub inline fn delete(self: *const T, rfmtid_: ?*const Guid) HRESULT {
                return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Delete(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid_);
            }
            pub inline fn @"enum"(self: *const T, ppenum_: ?*?*IEnumSTATPROPSETSTG) HRESULT {
                return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertySetStorage, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSTG_Value = Guid.initString("00000139-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSTG = &IID_IEnumSTATPROPSTG_Value;
pub const IEnumSTATPROPSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSTATPROPSTG,
            celt: u32,
            rgelt: [*]STATPROPSTG,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSTATPROPSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSTATPROPSTG,
            ppenum: ?*?*IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]STATPROPSTG, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSTG, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSTATPROPSTG) HRESULT {
                return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSETSTG_Value = Guid.initString("0000013b-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSETSTG = &IID_IEnumSTATPROPSETSTG_Value;
pub const IEnumSTATPROPSETSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSTATPROPSETSTG,
            celt: u32,
            rgelt: [*]STATPROPSETSTG,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSTATPROPSETSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSTATPROPSETSTG,
            ppenum: ?*?*IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]STATPROPSETSTG, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSTATPROPSETSTG) HRESULT {
                return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STGOPTIONS = extern struct {
    usVersion: u16,
    reserved: u16,
    ulSectorSize: u32,
    pwcsTemplateFile: ?[*:0]const u16,
};

pub const PIDMSI_STATUS_VALUE = enum(i32) {
    NORMAL = 0,
    NEW = 1,
    PRELIM = 2,
    DRAFT = 3,
    INPROGRESS = 4,
    EDIT = 5,
    REVIEW = 6,
    PROOF = 7,
    FINAL = 8,
    OTHER = 32767,
};
pub const PIDMSI_STATUS_NORMAL = PIDMSI_STATUS_VALUE.NORMAL;
pub const PIDMSI_STATUS_NEW = PIDMSI_STATUS_VALUE.NEW;
pub const PIDMSI_STATUS_PRELIM = PIDMSI_STATUS_VALUE.PRELIM;
pub const PIDMSI_STATUS_DRAFT = PIDMSI_STATUS_VALUE.DRAFT;
pub const PIDMSI_STATUS_INPROGRESS = PIDMSI_STATUS_VALUE.INPROGRESS;
pub const PIDMSI_STATUS_EDIT = PIDMSI_STATUS_VALUE.EDIT;
pub const PIDMSI_STATUS_REVIEW = PIDMSI_STATUS_VALUE.REVIEW;
pub const PIDMSI_STATUS_PROOF = PIDMSI_STATUS_VALUE.PROOF;
pub const PIDMSI_STATUS_FINAL = PIDMSI_STATUS_VALUE.FINAL;
pub const PIDMSI_STATUS_OTHER = PIDMSI_STATUS_VALUE.OTHER;

pub const SERIALIZEDPROPERTYVALUE = extern struct {
    dwType: u32,
    rgb: [1]u8,
};

pub const PMemoryAllocator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IPropertyBag_Value = Guid.initString("55272a00-42cb-11ce-8135-00aa004bb851");
pub const IID_IPropertyBag = &IID_IPropertyBag_Value;
pub const IPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: *const fn (
            self: *const IPropertyBag,
            psz_prop_name: ?[*:0]const u16,
            p_var: ?*VARIANT,
            p_error_log: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: *const fn (
            self: *const IPropertyBag,
            psz_prop_name: ?[*:0]const u16,
            p_var: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn read(self: *const T, psz_prop_name_: ?[*:0]const u16, p_var_: ?*VARIANT, p_error_log_: ?*IErrorLog) HRESULT {
                return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag, @ptrCast(self)), psz_prop_name_, p_var_, p_error_log_);
            }
            pub inline fn write(self: *const T, psz_prop_name_: ?[*:0]const u16, p_var_: ?*VARIANT) HRESULT {
                return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag, @ptrCast(self)), psz_prop_name_, p_var_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OLESTREAMVTBL = extern struct {
    Get: isize,
    Put: isize,
};

pub const OLESTREAM = extern struct {
    lpstbl: ?*OLESTREAMVTBL,
};

pub const PROPBAG2 = extern struct {
    dwType: u32,
    vt: u16,
    cfType: u16,
    dwHint: u32,
    pstrName: ?PWSTR,
    clsid: Guid,
};

const IID_IPropertyBag2_Value = Guid.initString("22f55882-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPropertyBag2 = &IID_IPropertyBag2_Value;
pub const IPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: *const fn (
            self: *const IPropertyBag2,
            c_properties: u32,
            p_prop_bag: [*]PROPBAG2,
            p_err_log: ?*IErrorLog,
            pvar_value: [*]VARIANT,
            phr_error: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: *const fn (
            self: *const IPropertyBag2,
            c_properties: u32,
            p_prop_bag: [*]PROPBAG2,
            pvar_value: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CountProperties: *const fn (
            self: *const IPropertyBag2,
            pc_properties: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: *const fn (
            self: *const IPropertyBag2,
            i_property: u32,
            c_properties: u32,
            p_prop_bag: [*]PROPBAG2,
            pc_properties: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadObject: *const fn (
            self: *const IPropertyBag2,
            pstr_name: ?[*:0]const u16,
            dw_hint: u32,
            p_unk_object: ?*IUnknown,
            p_err_log: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn read(self: *const T, c_properties_: u32, p_prop_bag_: [*]PROPBAG2, p_err_log_: ?*IErrorLog, pvar_value_: [*]VARIANT, phr_error_: [*]HRESULT) HRESULT {
                return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag2, @ptrCast(self)), c_properties_, p_prop_bag_, p_err_log_, pvar_value_, phr_error_);
            }
            pub inline fn write(self: *const T, c_properties_: u32, p_prop_bag_: [*]PROPBAG2, pvar_value_: [*]VARIANT) HRESULT {
                return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag2, @ptrCast(self)), c_properties_, p_prop_bag_, pvar_value_);
            }
            pub inline fn countProperties(self: *const T, pc_properties_: ?*u32) HRESULT {
                return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).CountProperties(@as(*const IPropertyBag2, @ptrCast(self)), pc_properties_);
            }
            pub inline fn getPropertyInfo(self: *const T, i_property_: u32, c_properties_: u32, p_prop_bag_: [*]PROPBAG2, pc_properties_: ?*u32) HRESULT {
                return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IPropertyBag2, @ptrCast(self)), i_property_, c_properties_, p_prop_bag_, pc_properties_);
            }
            pub inline fn loadObject(self: *const T, pstr_name_: ?[*:0]const u16, dw_hint_: u32, p_unk_object_: ?*IUnknown, p_err_log_: ?*IErrorLog) HRESULT {
                return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).LoadObject(@as(*const IPropertyBag2, @ptrCast(self)), pstr_name_, dw_hint_, p_unk_object_, p_err_log_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (45)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromFile(
    p_server_info: ?*COSERVERINFO,
    p_clsid: ?*Guid,
    punk_outer: ?*IUnknown,
    dw_cls_ctx: CLSCTX,
    grf_mode: u32,
    pwsz_name: ?PWSTR,
    dw_count: u32,
    p_results: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromIStorage(
    p_server_info: ?*COSERVERINFO,
    p_clsid: ?*Guid,
    punk_outer: ?*IUnknown,
    dw_cls_ctx: CLSCTX,
    pstg: ?*IStorage,
    dw_count: u32,
    p_results: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(
    pflb: ?*IFillLockBytes,
    grf_mode: u32,
    async_flags: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(
    pilb: ?*ILockBytes,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnFile(
    pwcs_name: ?[*:0]const u16,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dflayout" fn StgOpenLayoutDocfile(
    pwcs_df_name: ?[*:0]const u16,
    grf_mode: u32,
    reserved: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateStreamOnHGlobal(
    h_global: isize,
    f_delete_on_release: BOOL,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromStream(
    pstm: ?*IStream,
    phglobal: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterfaceAndReleaseStream(
    p_stm: ?*IStream,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantCopy(
    pvar_dest: ?*PROPVARIANT,
    pvar_src: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantClear(
    pvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FreePropVariantArray(
    c_variants: u32,
    rgvars: [*]PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfile(
    pwcs_name: ?[*:0]const u16,
    grf_mode: STGM,
    reserved: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfileOnILockBytes(
    plkbyt: ?*ILockBytes,
    grf_mode: STGM,
    reserved: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorage(
    pwcs_name: ?[*:0]const u16,
    pstg_priority: ?*IStorage,
    grf_mode: STGM,
    snb_exclude: ?*?*u16,
    reserved: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageOnILockBytes(
    plkbyt: ?*ILockBytes,
    pstg_priority: ?*IStorage,
    grf_mode: u32,
    snb_exclude: ?*?*u16,
    reserved: u32,
    ppstg_open: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageFile(
    pwcs_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageILockBytes(
    plkbyt: ?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgSetTimes(
    lpsz_name: ?[*:0]const u16,
    pctime: ?*const FILETIME,
    patime: ?*const FILETIME,
    pmtime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateStorageEx(
    pwcs_name: ?[*:0]const u16,
    grf_mode: STGM,
    stgfmt: STGFMT,
    grf_attrs: u32,
    p_stg_options: ?*STGOPTIONS,
    p_security_descriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    pp_object_open: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageEx(
    pwcs_name: ?[*:0]const u16,
    grf_mode: STGM,
    stgfmt: STGFMT,
    grf_attrs: u32,
    p_stg_options: ?*STGOPTIONS,
    p_security_descriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    pp_object_open: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropStg(
    p_unk: ?*IUnknown,
    fmtid: ?*const Guid,
    pclsid: ?*const Guid,
    grf_flags: u32,
    dw_reserved: u32,
    pp_prop_stg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenPropStg(
    p_unk: ?*IUnknown,
    fmtid: ?*const Guid,
    grf_flags: u32,
    dw_reserved: u32,
    pp_prop_stg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropSetStg(
    p_storage: ?*IStorage,
    dw_reserved: u32,
    pp_prop_set_stg: ?*?*IPropertySetStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FmtIdToPropStgName(
    pfmtid: ?*const Guid,
    osz_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropStgNameToFmtId(
    osz_name: ?[*:0]const u16,
    pfmtid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStg(
    p_stg: ?*IStorage,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStg(
    p_stg: ?*IStorage,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStm(
    p_stm: ?*IStream,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStm(
    p_stm: ?*IStream,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromILockBytes(
    plkbyt: ?*ILockBytes,
    phglobal: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateILockBytesOnHGlobal(
    h_global: isize,
    f_delete_on_release: BOOL,
    pplkbyt: ?*?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetConvertStg(
    p_stg: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertVariantToProperty(
    pvar: ?*const PROPVARIANT,
    code_page: u16,
    // TODO: what to do with BytesParamIndex 3?
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
    pid: u32,
    f_reserved: BOOLEAN,
    pc_indirect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*SERIALIZEDPROPERTYVALUE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertPropertyToVariant(
    pprop: ?*const SERIALIZEDPROPERTYVALUE,
    code_page: u16,
    pvar: ?*PROPVARIANT,
    pma: ?*PMemoryAllocator,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgPropertyLengthAsVariant(
    // TODO: what to do with BytesParamIndex 1?
    p_prop: ?*const SERIALIZEDPROPERTYVALUE,
    cb_prop: u32,
    code_page: u16,
    b_reserved: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteFmtUserTypeStg(
    pstg: ?*IStorage,
    cf: u16,
    lpsz_user_type: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadFmtUserTypeStg(
    pstg: ?*IStorage,
    pcf: ?*u16,
    lplpsz_user_type: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(
    lpolestream: ?*OLESTREAM,
    pstg: ?*IStorage,
    ptd: ?*const DVTARGETDEVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(
    pstg: ?*IStorage,
    lpolestream: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn SetConvertStg(
    p_stg: ?*IStorage,
    f_convert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(
    pstg: ?*IStorage,
    cf_format: u16,
    l_width: i32,
    l_height: i32,
    dw_size: u32,
    pmedium: ?*STGMEDIUM,
    polestm: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(
    polestm: ?*OLESTREAM,
    pstg: ?*IStorage,
    pcf_format: ?*u16,
    plw_width: ?*i32,
    pl_height: ?*i32,
    pdw_size: ?*u32,
    pmedium: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgSerializePropVariant(
    ppropvar: ?*const PROPVARIANT,
    pp_prop: ?*?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgDeserializePropVariant(
    pprop: ?*const SERIALIZEDPROPERTYVALUE,
    cb_max: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (29)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BLOB = @import("../../system/com.zig").BLOB;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const CLSCTX = @import("../../system/com.zig").CLSCTX;
const COSERVERINFO = @import("../../system/com.zig").COSERVERINFO;
const CY = @import("../../system/com.zig").CY;
const DECIMAL = @import("../../foundation.zig").DECIMAL;
const DVTARGETDEVICE = @import("../../system/com.zig").DVTARGETDEVICE;
const FILETIME = @import("../../foundation.zig").FILETIME;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IErrorLog = @import("../../system/com.zig").IErrorLog;
const IPersist = @import("../../system/com.zig").IPersist;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../../foundation.zig").LARGE_INTEGER;
const MULTI_QI = @import("../../system/com.zig").MULTI_QI;
const PSECURITY_DESCRIPTOR = @import("../../security.zig").PSECURITY_DESCRIPTOR;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const SAFEARRAY = @import("../../system/com.zig").SAFEARRAY;
const STATSTG = @import("../../system/com.zig").STATSTG;
const STGMEDIUM = @import("../../system/com.zig").STGMEDIUM;
const StorageLayout = @import("../../system/com.zig").StorageLayout;
const ULARGE_INTEGER = @import("../../foundation.zig").ULARGE_INTEGER;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
