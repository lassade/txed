//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
pub const CALLFRAMEINFO = extern struct {
    iMethod: u32,
    fHasInValues: BOOL,
    fHasInOutValues: BOOL,
    fHasOutValues: BOOL,
    fDerivesFromIDispatch: BOOL,
    cInInterfacesMax: i32,
    cInOutInterfacesMax: i32,
    cOutInterfacesMax: i32,
    cTopLevelInInterfaces: i32,
    iid: Guid,
    cMethod: u32,
    cParams: u32,
};

pub const CALLFRAMEPARAMINFO = extern struct {
    fIn: BOOLEAN,
    fOut: BOOLEAN,
    stackOffset: u32,
    cbParam: u32,
};

pub const CALLFRAME_COPY = enum(i32) {
    NESTED = 1,
    INDEPENDENT = 2,
};
pub const CALLFRAME_COPY_NESTED = CALLFRAME_COPY.NESTED;
pub const CALLFRAME_COPY_INDEPENDENT = CALLFRAME_COPY.INDEPENDENT;

pub const CALLFRAME_FREE = enum(i32) {
    NONE = 0,
    IN = 1,
    INOUT = 2,
    OUT = 4,
    TOP_INOUT = 8,
    TOP_OUT = 16,
    ALL = 31,
};
pub const CALLFRAME_FREE_NONE = CALLFRAME_FREE.NONE;
pub const CALLFRAME_FREE_IN = CALLFRAME_FREE.IN;
pub const CALLFRAME_FREE_INOUT = CALLFRAME_FREE.INOUT;
pub const CALLFRAME_FREE_OUT = CALLFRAME_FREE.OUT;
pub const CALLFRAME_FREE_TOP_INOUT = CALLFRAME_FREE.TOP_INOUT;
pub const CALLFRAME_FREE_TOP_OUT = CALLFRAME_FREE.TOP_OUT;
pub const CALLFRAME_FREE_ALL = CALLFRAME_FREE.ALL;

pub const CALLFRAME_NULL = enum(i32) {
    NONE = 0,
    INOUT = 2,
    OUT = 4,
    ALL = 6,
};
pub const CALLFRAME_NULL_NONE = CALLFRAME_NULL.NONE;
pub const CALLFRAME_NULL_INOUT = CALLFRAME_NULL.INOUT;
pub const CALLFRAME_NULL_OUT = CALLFRAME_NULL.OUT;
pub const CALLFRAME_NULL_ALL = CALLFRAME_NULL.ALL;

pub const CALLFRAME_WALK = enum(i32) {
    IN = 1,
    INOUT = 2,
    OUT = 4,
};
pub const CALLFRAME_WALK_IN = CALLFRAME_WALK.IN;
pub const CALLFRAME_WALK_INOUT = CALLFRAME_WALK.INOUT;
pub const CALLFRAME_WALK_OUT = CALLFRAME_WALK.OUT;

pub const CALLFRAME_MARSHALCONTEXT = extern struct {
    fIn: BOOLEAN,
    dwDestContext: u32,
    pvDestContext: ?*anyopaque,
    punkReserved: ?*IUnknown,
    guidTransferSyntax: Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrame_Value = Guid.initString("d573b4b0-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallFrame = &IID_ICallFrame_Value;
pub const ICallFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: *const fn (
            self: *const ICallFrame,
            p_info: ?*CALLFRAMEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDAndMethod: *const fn (
            self: *const ICallFrame,
            p_i_i_d: ?*Guid,
            pi_method: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: *const fn (
            self: *const ICallFrame,
            pwsz_interface: ?*?PWSTR,
            pwsz_method: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackLocation: *const fn (
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        SetStackLocation: *const fn (
            self: *const ICallFrame,
            pv_stack: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetReturnValue: *const fn (
            self: *const ICallFrame,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetReturnValue: *const fn (
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamInfo: *const fn (
            self: *const ICallFrame,
            iparam: u32,
            p_info: ?*CALLFRAMEPARAMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: *const fn (
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParam: *const fn (
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: *const fn (
            self: *const ICallFrame,
            copy_control: CALLFRAME_COPY,
            p_walker: ?*ICallFrameWalker,
            pp_frame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: *const fn (
            self: *const ICallFrame,
            pframe_args_dest: ?*ICallFrame,
            p_walker_dest_free: ?*ICallFrameWalker,
            p_walker_copy: ?*ICallFrameWalker,
            free_flags: u32,
            p_walker_free: ?*ICallFrameWalker,
            null_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeParam: *const fn (
            self: *const ICallFrame,
            iparam: u32,
            free_flags: u32,
            p_walker_free: ?*ICallFrameWalker,
            null_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WalkFrame: *const fn (
            self: *const ICallFrame,
            walk_what: u32,
            p_walker: ?*ICallFrameWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarshalSizeMax: *const fn (
            self: *const ICallFrame,
            pmshl_context: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            pcb_buffer_needed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Marshal: *const fn (
            self: *const ICallFrame,
            pmshl_context: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            p_buffer: [*]u8,
            cb_buffer: u32,
            pcb_buffer_used: ?*u32,
            pdata_rep: ?*u32,
            prpc_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmarshal: *const fn (
            self: *const ICallFrame,
            p_buffer: [*]u8,
            cb_buffer: u32,
            data_rep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcb_unmarshalled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: *const fn (
            self: *const ICallFrame,
            p_buffer: [*]u8,
            cb_buffer: u32,
            ib_first_release: u32,
            data_rep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: *const fn (
            self: *const ICallFrame,
            pv_receiver: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInfo(self: *const T, p_info_: ?*CALLFRAMEINFO) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ICallFrame, @ptrCast(self)), p_info_);
            }
            pub inline fn getIIDAndMethod(self: *const T, p_i_i_d_: ?*Guid, pi_method_: ?*u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetIIDAndMethod(@as(*const ICallFrame, @ptrCast(self)), p_i_i_d_, pi_method_);
            }
            pub inline fn getNames(self: *const T, pwsz_interface_: ?*?PWSTR, pwsz_method_: ?*?PWSTR) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetNames(@as(*const ICallFrame, @ptrCast(self)), pwsz_interface_, pwsz_method_);
            }
            pub inline fn getStackLocation(self: *const T) ?*anyopaque {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetStackLocation(@as(*const ICallFrame, @ptrCast(self)));
            }
            pub inline fn setStackLocation(self: *const T, pv_stack_: ?*anyopaque) void {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).SetStackLocation(@as(*const ICallFrame, @ptrCast(self)), pv_stack_);
            }
            pub inline fn setReturnValue(self: *const T, hr_: HRESULT) void {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).SetReturnValue(@as(*const ICallFrame, @ptrCast(self)), hr_);
            }
            pub inline fn getReturnValue(self: *const T) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetReturnValue(@as(*const ICallFrame, @ptrCast(self)));
            }
            pub inline fn getParamInfo(self: *const T, iparam_: u32, p_info_: ?*CALLFRAMEPARAMINFO) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetParamInfo(@as(*const ICallFrame, @ptrCast(self)), iparam_, p_info_);
            }
            pub inline fn setParam(self: *const T, iparam_: u32, pvar_: ?*VARIANT) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).SetParam(@as(*const ICallFrame, @ptrCast(self)), iparam_, pvar_);
            }
            pub inline fn getParam(self: *const T, iparam_: u32, pvar_: ?*VARIANT) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetParam(@as(*const ICallFrame, @ptrCast(self)), iparam_, pvar_);
            }
            pub inline fn copy(self: *const T, copy_control_: CALLFRAME_COPY, p_walker_: ?*ICallFrameWalker, pp_frame_: ?*?*ICallFrame) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).Copy(@as(*const ICallFrame, @ptrCast(self)), copy_control_, p_walker_, pp_frame_);
            }
            pub inline fn free(self: *const T, pframe_args_dest_: ?*ICallFrame, p_walker_dest_free_: ?*ICallFrameWalker, p_walker_copy_: ?*ICallFrameWalker, free_flags_: u32, p_walker_free_: ?*ICallFrameWalker, null_flags_: u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).Free(@as(*const ICallFrame, @ptrCast(self)), pframe_args_dest_, p_walker_dest_free_, p_walker_copy_, free_flags_, p_walker_free_, null_flags_);
            }
            pub inline fn freeParam(self: *const T, iparam_: u32, free_flags_: u32, p_walker_free_: ?*ICallFrameWalker, null_flags_: u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).FreeParam(@as(*const ICallFrame, @ptrCast(self)), iparam_, free_flags_, p_walker_free_, null_flags_);
            }
            pub inline fn walkFrame(self: *const T, walk_what_: u32, p_walker_: ?*ICallFrameWalker) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).WalkFrame(@as(*const ICallFrame, @ptrCast(self)), walk_what_, p_walker_);
            }
            pub inline fn getMarshalSizeMax(self: *const T, pmshl_context_: ?*CALLFRAME_MARSHALCONTEXT, mshlflags_: MSHLFLAGS, pcb_buffer_needed_: ?*u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).GetMarshalSizeMax(@as(*const ICallFrame, @ptrCast(self)), pmshl_context_, mshlflags_, pcb_buffer_needed_);
            }
            pub inline fn marshal(self: *const T, pmshl_context_: ?*CALLFRAME_MARSHALCONTEXT, mshlflags_: MSHLFLAGS, p_buffer_: [*]u8, cb_buffer_: u32, pcb_buffer_used_: ?*u32, pdata_rep_: ?*u32, prpc_flags_: ?*u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).Marshal(@as(*const ICallFrame, @ptrCast(self)), pmshl_context_, mshlflags_, p_buffer_, cb_buffer_, pcb_buffer_used_, pdata_rep_, prpc_flags_);
            }
            pub inline fn unmarshal(self: *const T, p_buffer_: [*]u8, cb_buffer_: u32, data_rep_: u32, pcontext_: ?*CALLFRAME_MARSHALCONTEXT, pcb_unmarshalled_: ?*u32) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).Unmarshal(@as(*const ICallFrame, @ptrCast(self)), p_buffer_, cb_buffer_, data_rep_, pcontext_, pcb_unmarshalled_);
            }
            pub inline fn releaseMarshalData(self: *const T, p_buffer_: [*]u8, cb_buffer_: u32, ib_first_release_: u32, data_rep_: u32, pcontext_: ?*CALLFRAME_MARSHALCONTEXT) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).ReleaseMarshalData(@as(*const ICallFrame, @ptrCast(self)), p_buffer_, cb_buffer_, ib_first_release_, data_rep_, pcontext_);
            }
            pub inline fn invoke(self: *const T, pv_receiver_: ?*anyopaque) HRESULT {
                return @as(*const ICallFrame.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ICallFrame, @ptrCast(self)), pv_receiver_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallIndirect_Value = Guid.initString("d573b4b1-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallIndirect = &IID_ICallIndirect_Value;
pub const ICallIndirect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallIndirect: *const fn (
            self: *const ICallIndirect,
            phr_return: ?*HRESULT,
            i_method: u32,
            pv_args: ?*anyopaque,
            cb_args: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMethodInfo: *const fn (
            self: *const ICallIndirect,
            i_method: u32,
            p_info: ?*CALLFRAMEINFO,
            pwsz_method: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackSize: *const fn (
            self: *const ICallIndirect,
            i_method: u32,
            cb_args: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: *const fn (
            self: *const ICallIndirect,
            piid: ?*Guid,
            pf_derives_from_i_dispatch: ?*BOOL,
            pc_method: ?*u32,
            pwsz_interface: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn callIndirect(self: *const T, phr_return_: ?*HRESULT, i_method_: u32, pv_args_: ?*anyopaque, cb_args_: ?*u32) HRESULT {
                return @as(*const ICallIndirect.VTable, @ptrCast(self.vtable)).CallIndirect(@as(*const ICallIndirect, @ptrCast(self)), phr_return_, i_method_, pv_args_, cb_args_);
            }
            pub inline fn getMethodInfo(self: *const T, i_method_: u32, p_info_: ?*CALLFRAMEINFO, pwsz_method_: ?*?PWSTR) HRESULT {
                return @as(*const ICallIndirect.VTable, @ptrCast(self.vtable)).GetMethodInfo(@as(*const ICallIndirect, @ptrCast(self)), i_method_, p_info_, pwsz_method_);
            }
            pub inline fn getStackSize(self: *const T, i_method_: u32, cb_args_: ?*u32) HRESULT {
                return @as(*const ICallIndirect.VTable, @ptrCast(self.vtable)).GetStackSize(@as(*const ICallIndirect, @ptrCast(self)), i_method_, cb_args_);
            }
            pub inline fn getIID(self: *const T, piid_: ?*Guid, pf_derives_from_i_dispatch_: ?*BOOL, pc_method_: ?*u32, pwsz_interface_: ?*?PWSTR) HRESULT {
                return @as(*const ICallIndirect.VTable, @ptrCast(self.vtable)).GetIID(@as(*const ICallIndirect, @ptrCast(self)), piid_, pf_derives_from_i_dispatch_, pc_method_, pwsz_interface_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallInterceptor_Value = Guid.initString("60c7ca75-896d-11d2-b8b6-00c04fb9618a");
pub const IID_ICallInterceptor = &IID_ICallInterceptor_Value;
pub const ICallInterceptor = extern struct {
    pub const VTable = extern struct {
        base: ICallIndirect.VTable,
        RegisterSink: *const fn (
            self: *const ICallInterceptor,
            psink: ?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisteredSink: *const fn (
            self: *const ICallInterceptor,
            ppsink: ?*?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICallIndirect.MethodMixin(T);
            pub inline fn registerSink(self: *const T, psink_: ?*ICallFrameEvents) HRESULT {
                return @as(*const ICallInterceptor.VTable, @ptrCast(self.vtable)).RegisterSink(@as(*const ICallInterceptor, @ptrCast(self)), psink_);
            }
            pub inline fn getRegisteredSink(self: *const T, ppsink_: ?*?*ICallFrameEvents) HRESULT {
                return @as(*const ICallInterceptor.VTable, @ptrCast(self.vtable)).GetRegisteredSink(@as(*const ICallInterceptor, @ptrCast(self)), ppsink_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameEvents_Value = Guid.initString("fd5e0843-fc91-11d0-97d7-00c04fb9618a");
pub const IID_ICallFrameEvents = &IID_ICallFrameEvents_Value;
pub const ICallFrameEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCall: *const fn (
            self: *const ICallFrameEvents,
            p_frame: ?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onCall(self: *const T, p_frame_: ?*ICallFrame) HRESULT {
                return @as(*const ICallFrameEvents.VTable, @ptrCast(self.vtable)).OnCall(@as(*const ICallFrameEvents, @ptrCast(self)), p_frame_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallUnmarshal_Value = Guid.initString("5333b003-2e42-11d2-b89d-00c04fb9618a");
pub const IID_ICallUnmarshal = &IID_ICallUnmarshal_Value;
pub const ICallUnmarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unmarshal: *const fn (
            self: *const ICallUnmarshal,
            i_method: u32,
            p_buffer: [*]u8,
            cb_buffer: u32,
            f_force_buffer_copy: BOOL,
            data_rep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcb_unmarshalled: ?*u32,
            pp_frame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: *const fn (
            self: *const ICallUnmarshal,
            i_method: u32,
            p_buffer: [*]u8,
            cb_buffer: u32,
            ib_first_release: u32,
            data_rep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn unmarshal(self: *const T, i_method_: u32, p_buffer_: [*]u8, cb_buffer_: u32, f_force_buffer_copy_: BOOL, data_rep_: u32, pcontext_: ?*CALLFRAME_MARSHALCONTEXT, pcb_unmarshalled_: ?*u32, pp_frame_: ?*?*ICallFrame) HRESULT {
                return @as(*const ICallUnmarshal.VTable, @ptrCast(self.vtable)).Unmarshal(@as(*const ICallUnmarshal, @ptrCast(self)), i_method_, p_buffer_, cb_buffer_, f_force_buffer_copy_, data_rep_, pcontext_, pcb_unmarshalled_, pp_frame_);
            }
            pub inline fn releaseMarshalData(self: *const T, i_method_: u32, p_buffer_: [*]u8, cb_buffer_: u32, ib_first_release_: u32, data_rep_: u32, pcontext_: ?*CALLFRAME_MARSHALCONTEXT) HRESULT {
                return @as(*const ICallUnmarshal.VTable, @ptrCast(self.vtable)).ReleaseMarshalData(@as(*const ICallUnmarshal, @ptrCast(self)), i_method_, p_buffer_, cb_buffer_, ib_first_release_, data_rep_, pcontext_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameWalker_Value = Guid.initString("08b23919-392d-11d2-b8a4-00c04fb9618a");
pub const IID_ICallFrameWalker = &IID_ICallFrameWalker_Value;
pub const ICallFrameWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWalkInterface: *const fn (
            self: *const ICallFrameWalker,
            iid: ?*const Guid,
            ppv_interface: ?*?*anyopaque,
            f_in: BOOL,
            f_out: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onWalkInterface(self: *const T, iid_: ?*const Guid, ppv_interface_: ?*?*anyopaque, f_in_: BOOL, f_out_: BOOL) HRESULT {
                return @as(*const ICallFrameWalker.VTable, @ptrCast(self.vtable)).OnWalkInterface(@as(*const ICallFrameWalker, @ptrCast(self)), iid_, ppv_interface_, f_in_, f_out_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInterfaceRelated_Value = Guid.initString("d1fb5a79-7706-11d1-adba-00c04fc2adc0");
pub const IID_IInterfaceRelated = &IID_IInterfaceRelated_Value;
pub const IInterfaceRelated = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIID: *const fn (
            self: *const IInterfaceRelated,
            iid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: *const fn (
            self: *const IInterfaceRelated,
            piid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setIID(self: *const T, iid_: ?*const Guid) HRESULT {
                return @as(*const IInterfaceRelated.VTable, @ptrCast(self.vtable)).SetIID(@as(*const IInterfaceRelated, @ptrCast(self)), iid_);
            }
            pub inline fn getIID(self: *const T, piid_: ?*Guid) HRESULT {
                return @as(*const IInterfaceRelated.VTable, @ptrCast(self.vtable)).GetIID(@as(*const IInterfaceRelated, @ptrCast(self)), piid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterceptor(
    iid_intercepted: ?*const Guid,
    punk_outer: ?*IUnknown,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoGetInterceptorFromTypeInfo(
    iid_intercepted: ?*const Guid,
    punk_outer: ?*IUnknown,
    type_info: ?*ITypeInfo,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const HRESULT = @import("../../foundation.zig").HRESULT;
const ITypeInfo = @import("../../system/com.zig").ITypeInfo;
const IUnknown = @import("../../system/com.zig").IUnknown;
const MSHLFLAGS = @import("../../system/com.zig").MSHLFLAGS;
const PWSTR = @import("../../foundation.zig").PWSTR;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
