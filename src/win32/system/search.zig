//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3393)
//--------------------------------------------------------------------------------
pub const SI_TEMPORARY = @as(u32, 2147483648);
pub const SUBSINFO_ALLFLAGS = @as(u32, 61311);
pub const RS_READY = @as(u32, 1);
pub const RS_SUSPENDED = @as(u32, 2);
pub const RS_UPDATING = @as(u32, 4);
pub const RS_SUSPENDONIDLE = @as(u32, 65536);
pub const RS_MAYBOTHERUSER = @as(u32, 131072);
pub const RS_COMPLETED = @as(u32, 2147483648);
pub const SUBSMGRUPDATE_MINIMIZE = @as(u32, 1);
pub const SUBSMGRUPDATE_MASK = @as(u32, 1);
pub const SUBSMGRENUM_TEMP = @as(u32, 1);
pub const SUBSMGRENUM_MASK = @as(u32, 1);
pub const INET_E_AGENT_MAX_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693248));
pub const INET_S_AGENT_PART_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790401));
pub const INET_E_AGENT_CACHE_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693246));
pub const INET_E_AGENT_CONNECTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693245));
pub const INET_E_SCHEDULED_UPDATES_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693244));
pub const INET_E_SCHEDULED_UPDATES_RESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693243));
pub const INET_E_SCHEDULED_UPDATE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693242));
pub const INET_E_SCHEDULED_EXCLUDE_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693241));
pub const INET_E_AGENT_EXCEEDING_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146693232));
pub const INET_S_AGENT_INCREASED_CACHE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 790416));
pub const OLEDBVER = @as(u32, 624);
pub const DB_NULL_HACCESSOR = @as(u32, 0);
pub const DB_INVALID_HACCESSOR = @as(u32, 0);
pub const DB_NULL_HROW = @as(u32, 0);
pub const DB_NULL_HCHAPTER = @as(u32, 0);
pub const DB_INVALID_HCHAPTER = @as(u32, 0);
pub const STD_BOOKMARKLENGTH = @as(u32, 1);
pub const DBPROPVAL_BMK_NUMERIC = @as(i32, 1);
pub const DBPROPVAL_BMK_KEY = @as(i32, 2);
pub const DBPROPVAL_CL_START = @as(i32, 1);
pub const DBPROPVAL_CL_END = @as(i32, 2);
pub const DBPROPVAL_CU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_CU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_CU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_CU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_CD_NOTNULL = @as(i32, 1);
pub const DBPROPVAL_CB_NULL = @as(i32, 1);
pub const DBPROPVAL_CB_NON_NULL = @as(i32, 2);
pub const DBPROPVAL_FU_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_FU_COLUMN = @as(i32, 2);
pub const DBPROPVAL_FU_TABLE = @as(i32, 4);
pub const DBPROPVAL_FU_CATALOG = @as(i32, 8);
pub const DBPROPVAL_GB_NOT_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GB_EQUALS_SELECT = @as(i32, 2);
pub const DBPROPVAL_GB_CONTAINS_SELECT = @as(i32, 4);
pub const DBPROPVAL_GB_NO_RELATION = @as(i32, 8);
pub const DBPROPVAL_HT_DIFFERENT_CATALOGS = @as(i32, 1);
pub const DBPROPVAL_HT_DIFFERENT_PROVIDERS = @as(i32, 2);
pub const DBPROPVAL_IC_UPPER = @as(i32, 1);
pub const DBPROPVAL_IC_LOWER = @as(i32, 2);
pub const DBPROPVAL_IC_SENSITIVE = @as(i32, 4);
pub const DBPROPVAL_IC_MIXED = @as(i32, 8);
pub const DBPROPVAL_LM_NONE = @as(i32, 1);
pub const DBPROPVAL_LM_READ = @as(i32, 2);
pub const DBPROPVAL_LM_INTENT = @as(i32, 4);
pub const DBPROPVAL_LM_RITE = @as(i32, 8);
pub const DBPROPVAL_NP_OKTODO = @as(i32, 1);
pub const DBPROPVAL_NP_ABOUTTODO = @as(i32, 2);
pub const DBPROPVAL_NP_SYNCHAFTER = @as(i32, 4);
pub const DBPROPVAL_NP_FAILEDTODO = @as(i32, 8);
pub const DBPROPVAL_NP_DIDEVENT = @as(i32, 16);
pub const DBPROPVAL_NC_END = @as(i32, 1);
pub const DBPROPVAL_NC_HIGH = @as(i32, 2);
pub const DBPROPVAL_NC_LOW = @as(i32, 4);
pub const DBPROPVAL_NC_START = @as(i32, 8);
pub const DBPROPVAL_OO_BLOB = @as(i32, 1);
pub const DBPROPVAL_OO_IPERSIST = @as(i32, 2);
pub const DBPROPVAL_CB_DELETE = @as(i32, 1);
pub const DBPROPVAL_CB_PRESERVE = @as(i32, 2);
pub const DBPROPVAL_SU_DML_STATEMENTS = @as(i32, 1);
pub const DBPROPVAL_SU_TABLE_DEFINITION = @as(i32, 2);
pub const DBPROPVAL_SU_INDEX_DEFINITION = @as(i32, 4);
pub const DBPROPVAL_SU_PRIVILEGE_DEFINITION = @as(i32, 8);
pub const DBPROPVAL_SQ_CORRELATEDSUBQUERIES = @as(i32, 1);
pub const DBPROPVAL_SQ_COMPARISON = @as(i32, 2);
pub const DBPROPVAL_SQ_EXISTS = @as(i32, 4);
pub const DBPROPVAL_SQ_IN = @as(i32, 8);
pub const DBPROPVAL_SQ_QUANTIFIED = @as(i32, 16);
pub const DBPROPVAL_SQ_TABLE = @as(i32, 32);
pub const DBPROPVAL_SS_ISEQUENTIALSTREAM = @as(i32, 1);
pub const DBPROPVAL_SS_ISTREAM = @as(i32, 2);
pub const DBPROPVAL_SS_ISTORAGE = @as(i32, 4);
pub const DBPROPVAL_SS_ILOCKBYTES = @as(i32, 8);
pub const DBPROPVAL_TI_CHAOS = @as(i32, 16);
pub const DBPROPVAL_TI_READUNCOMMITTED = @as(i32, 256);
pub const DBPROPVAL_TI_BROWSE = @as(i32, 256);
pub const DBPROPVAL_TI_CURSORSTABILITY = @as(i32, 4096);
pub const DBPROPVAL_TI_READCOMMITTED = @as(i32, 4096);
pub const DBPROPVAL_TI_REPEATABLEREAD = @as(i32, 65536);
pub const DBPROPVAL_TI_SERIALIZABLE = @as(i32, 1048576);
pub const DBPROPVAL_TI_ISOLATED = @as(i32, 1048576);
pub const DBPROPVAL_TR_COMMIT_DC = @as(i32, 1);
pub const DBPROPVAL_TR_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TR_COMMIT_NO = @as(i32, 4);
pub const DBPROPVAL_TR_ABORT_DC = @as(i32, 8);
pub const DBPROPVAL_TR_ABORT = @as(i32, 16);
pub const DBPROPVAL_TR_ABORT_NO = @as(i32, 32);
pub const DBPROPVAL_TR_DONTCARE = @as(i32, 64);
pub const DBPROPVAL_TR_BOTH = @as(i32, 128);
pub const DBPROPVAL_TR_NONE = @as(i32, 256);
pub const DBPROPVAL_TR_OPTIMISTIC = @as(i32, 512);
pub const DBPROPVAL_RT_FREETHREAD = @as(i32, 1);
pub const DBPROPVAL_RT_APTMTTHREAD = @as(i32, 2);
pub const DBPROPVAL_RT_SINGLETHREAD = @as(i32, 4);
pub const DBPROPVAL_UP_CHANGE = @as(i32, 1);
pub const DBPROPVAL_UP_DELETE = @as(i32, 2);
pub const DBPROPVAL_UP_INSERT = @as(i32, 4);
pub const DBPROPVAL_SQL_NONE = @as(i32, 0);
pub const DBPROPVAL_SQL_ODBC_MINIMUM = @as(i32, 1);
pub const DBPROPVAL_SQL_ODBC_CORE = @as(i32, 2);
pub const DBPROPVAL_SQL_ODBC_EXTENDED = @as(i32, 4);
pub const DBPROPVAL_SQL_ANSI89_IEF = @as(i32, 8);
pub const DBPROPVAL_SQL_ANSI92_ENTRY = @as(i32, 16);
pub const DBPROPVAL_SQL_FIPS_TRANSITIONAL = @as(i32, 32);
pub const DBPROPVAL_SQL_ANSI92_INTERMEDIATE = @as(i32, 64);
pub const DBPROPVAL_SQL_ANSI92_FULL = @as(i32, 128);
pub const DBPROPVAL_SQL_ESCAPECLAUSES = @as(i32, 256);
pub const DBPROPVAL_IT_BTREE = @as(i32, 1);
pub const DBPROPVAL_IT_HASH = @as(i32, 2);
pub const DBPROPVAL_IT_CONTENT = @as(i32, 3);
pub const DBPROPVAL_IT_OTHER = @as(i32, 4);
pub const DBPROPVAL_IN_DISALLOWNULL = @as(i32, 1);
pub const DBPROPVAL_IN_IGNORENULL = @as(i32, 2);
pub const DBPROPVAL_IN_IGNOREANYNULL = @as(i32, 4);
pub const DBPROPVAL_TC_NONE = @as(i32, 0);
pub const DBPROPVAL_TC_DML = @as(i32, 1);
pub const DBPROPVAL_TC_DDL_COMMIT = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_IGNORE = @as(i32, 4);
pub const DBPROPVAL_TC_ALL = @as(i32, 8);
pub const DBPROPVAL_OA_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_OA_ATEXECUTE = @as(i32, 2);
pub const DBPROPVAL_OA_ATROWRELEASE = @as(i32, 4);
pub const DBPROPVAL_MR_NOTSUPPORTED = @as(i32, 0);
pub const DBPROPVAL_MR_SUPPORTED = @as(i32, 1);
pub const DBPROPVAL_MR_CONCURRENT = @as(i32, 2);
pub const DBPROPVAL_PT_GUID_NAME = @as(i32, 1);
pub const DBPROPVAL_PT_GUID_PROPID = @as(i32, 2);
pub const DBPROPVAL_PT_NAME = @as(i32, 4);
pub const DBPROPVAL_PT_GUID = @as(i32, 8);
pub const DBPROPVAL_PT_PROPID = @as(i32, 16);
pub const DBPROPVAL_PT_PGUID_NAME = @as(i32, 32);
pub const DBPROPVAL_PT_PGUID_PROPID = @as(i32, 64);
pub const DBPROPVAL_NT_SINGLEROW = @as(i32, 1);
pub const DBPROPVAL_NT_MULTIPLEROWS = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_INITIALIZE = @as(i32, 1);
pub const DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION = @as(i32, 2);
pub const DBPROPVAL_ASYNCH_RANDOMPOPULATION = @as(i32, 4);
pub const DBPROPVAL_OP_EQUAL = @as(i32, 1);
pub const DBPROPVAL_OP_RELATIVE = @as(i32, 2);
pub const DBPROPVAL_OP_STRING = @as(i32, 4);
pub const DBPROPVAL_CO_EQUALITY = @as(i32, 1);
pub const DBPROPVAL_CO_STRING = @as(i32, 2);
pub const DBPROPVAL_CO_CASESENSITIVE = @as(i32, 4);
pub const DBPROPVAL_CO_CASEINSENSITIVE = @as(i32, 8);
pub const DBPROPVAL_CO_CONTAINS = @as(i32, 16);
pub const DBPROPVAL_CO_BEGINSWITH = @as(i32, 32);
pub const DBPROPVAL_ASYNCH_BACKGROUNDPOPULATION = @as(i32, 8);
pub const DBPROPVAL_ASYNCH_PREPOPULATE = @as(i32, 16);
pub const DBPROPVAL_ASYNCH_POPULATEONDEMAND = @as(i32, 32);
pub const DBPROPVAL_LM_SINGLEROW = @as(i32, 2);
pub const DBPROPVAL_SQL_SUBMINIMUM = @as(i32, 512);
pub const DBPROPVAL_DST_TDP = @as(i32, 1);
pub const DBPROPVAL_DST_MDP = @as(i32, 2);
pub const DBPROPVAL_DST_TDPANDMDP = @as(i32, 3);
pub const MDPROPVAL_AU_UNSUPPORTED = @as(i32, 0);
pub const MDPROPVAL_AU_UNCHANGED = @as(i32, 1);
pub const MDPROPVAL_AU_UNKNOWN = @as(i32, 2);
pub const MDPROPVAL_MF_WITH_CALCMEMBERS = @as(i32, 1);
pub const MDPROPVAL_MF_WITH_NAMEDSETS = @as(i32, 2);
pub const MDPROPVAL_MF_CREATE_CALCMEMBERS = @as(i32, 4);
pub const MDPROPVAL_MF_CREATE_NAMEDSETS = @as(i32, 8);
pub const MDPROPVAL_MF_SCOPE_SESSION = @as(i32, 16);
pub const MDPROPVAL_MF_SCOPE_GLOBAL = @as(i32, 32);
pub const MDPROPVAL_MMF_COUSIN = @as(i32, 1);
pub const MDPROPVAL_MMF_PARALLELPERIOD = @as(i32, 2);
pub const MDPROPVAL_MMF_OPENINGPERIOD = @as(i32, 4);
pub const MDPROPVAL_MMF_CLOSINGPERIOD = @as(i32, 8);
pub const MDPROPVAL_MNF_MEDIAN = @as(i32, 1);
pub const MDPROPVAL_MNF_VAR = @as(i32, 2);
pub const MDPROPVAL_MNF_STDDEV = @as(i32, 4);
pub const MDPROPVAL_MNF_RANK = @as(i32, 8);
pub const MDPROPVAL_MNF_AGGREGATE = @as(i32, 16);
pub const MDPROPVAL_MNF_COVARIANCE = @as(i32, 32);
pub const MDPROPVAL_MNF_CORRELATION = @as(i32, 64);
pub const MDPROPVAL_MNF_LINREGSLOPE = @as(i32, 128);
pub const MDPROPVAL_MNF_LINREGVARIANCE = @as(i32, 256);
pub const MDPROPVAL_MNF_LINREG2 = @as(i32, 512);
pub const MDPROPVAL_MNF_LINREGPOINT = @as(i32, 1024);
pub const MDPROPVAL_MNF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MNF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MNF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MNF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MNF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOPPERCENT = @as(i32, 1);
pub const MDPROPVAL_MSF_BOTTOMPERCENT = @as(i32, 2);
pub const MDPROPVAL_MSF_TOPSUM = @as(i32, 4);
pub const MDPROPVAL_MSF_BOTTOMSUM = @as(i32, 8);
pub const MDPROPVAL_MSF_PERIODSTODATE = @as(i32, 16);
pub const MDPROPVAL_MSF_LASTPERIODS = @as(i32, 32);
pub const MDPROPVAL_MSF_YTD = @as(i32, 64);
pub const MDPROPVAL_MSF_QTD = @as(i32, 128);
pub const MDPROPVAL_MSF_MTD = @as(i32, 256);
pub const MDPROPVAL_MSF_WTD = @as(i32, 512);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBBER = @as(i32, 1024);
pub const MDPROPVAL_MSF_DRILLDOWNLEVEL = @as(i32, 2048);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERTOP = @as(i32, 4096);
pub const MDPROPVAL_MSF_DRILLDOWNMEMBERBOTTOM = @as(i32, 8192);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELTOP = @as(i32, 16384);
pub const MDPROPVAL_MSF_DRILLDOWNLEVELBOTTOM = @as(i32, 32768);
pub const MDPROPVAL_MSF_DRILLUPMEMBER = @as(i32, 65536);
pub const MDPROPVAL_MSF_DRILLUPLEVEL = @as(i32, 131072);
pub const MDPROPVAL_MSF_TOGGLEDRILLSTATE = @as(i32, 262144);
pub const MDPROPVAL_MD_SELF = @as(i32, 1);
pub const MDPROPVAL_MD_BEFORE = @as(i32, 2);
pub const MDPROPVAL_MD_AFTER = @as(i32, 4);
pub const MDPROPVAL_MSC_LESSTHAN = @as(i32, 1);
pub const MDPROPVAL_MSC_GREATERTHAN = @as(i32, 2);
pub const MDPROPVAL_MSC_LESSTHANEQUAL = @as(i32, 4);
pub const MDPROPVAL_MSC_GREATERTHANEQUAL = @as(i32, 8);
pub const MDPROPVAL_MC_SINGLECASE = @as(i32, 1);
pub const MDPROPVAL_MC_SEARCHEDCASE = @as(i32, 2);
pub const MDPROPVAL_MOQ_OUTERREFERENCE = @as(i32, 1);
pub const MDPROPVAL_MOQ_DATASOURCE_CUBE = @as(i32, 1);
pub const MDPROPVAL_MOQ_CATALOG_CUBE = @as(i32, 2);
pub const MDPROPVAL_MOQ_SCHEMA_CUBE = @as(i32, 4);
pub const MDPROPVAL_MOQ_CUBE_DIM = @as(i32, 8);
pub const MDPROPVAL_MOQ_DIM_HIER = @as(i32, 16);
pub const MDPROPVAL_MOQ_DIMHIER_LEVEL = @as(i32, 32);
pub const MDPROPVAL_MOQ_LEVEL_MEMBER = @as(i32, 64);
pub const MDPROPVAL_MOQ_MEMBER_MEMBER = @as(i32, 128);
pub const MDPROPVAL_MOQ_DIMHIER_MEMBER = @as(i32, 256);
pub const MDPROPVAL_FS_FULL_SUPPORT = @as(i32, 1);
pub const MDPROPVAL_FS_GENERATED_COLUMN = @as(i32, 2);
pub const MDPROPVAL_FS_GENERATED_DIMENSION = @as(i32, 3);
pub const MDPROPVAL_FS_NO_SUPPORT = @as(i32, 4);
pub const MDPROPVAL_NL_NAMEDLEVELS = @as(i32, 1);
pub const MDPROPVAL_NL_NUMBEREDLEVELS = @as(i32, 2);
pub const MDPROPVAL_MJC_SINGLECUBE = @as(i32, 1);
pub const MDPROPVAL_MJC_MULTICUBES = @as(i32, 2);
pub const MDPROPVAL_MJC_IMPLICITCUBE = @as(i32, 4);
pub const MDPROPVAL_RR_NORANGEROWSET = @as(i32, 1);
pub const MDPROPVAL_RR_READONLY = @as(i32, 2);
pub const MDPROPVAL_RR_UPDATE = @as(i32, 4);
pub const MDPROPVAL_MS_MULTIPLETUPLES = @as(i32, 1);
pub const MDPROPVAL_MS_SINGLETUPLE = @as(i32, 2);
pub const MDPROPVAL_NME_ALLDIMENSIONS = @as(i32, 0);
pub const MDPROPVAL_NME_MEASURESONLY = @as(i32, 1);
pub const DBPROPVAL_AO_SEQUENTIAL = @as(i32, 0);
pub const DBPROPVAL_AO_SEQUENTIALSTORAGEOBJECTS = @as(i32, 1);
pub const DBPROPVAL_AO_RANDOM = @as(i32, 2);
pub const DBPROPVAL_BD_ROWSET = @as(i32, 0);
pub const DBPROPVAL_BD_INTRANSACTION = @as(i32, 1);
pub const DBPROPVAL_BD_XTRANSACTION = @as(i32, 2);
pub const DBPROPVAL_BD_REORGANIZATION = @as(i32, 3);
pub const BMK_DURABILITY_ROWSET = @as(i32, 0);
pub const BMK_DURABILITY_INTRANSACTION = @as(i32, 1);
pub const BMK_DURABILITY_XTRANSACTION = @as(i32, 2);
pub const BMK_DURABILITY_REORGANIZATION = @as(i32, 3);
pub const DBPROPVAL_BO_NOLOG = @as(i32, 0);
pub const DBPROPVAL_BO_NOINDEXUPDATE = @as(i32, 1);
pub const DBPROPVAL_BO_REFINTEGRITY = @as(i32, 2);
pub const DBPROPVAL_STGM_DIRECT = @as(u32, 65536);
pub const DBPROPVAL_STGM_TRANSACTED = @as(u32, 131072);
pub const DBPROPVAL_STGM_CONVERT = @as(u32, 262144);
pub const DBPROPVAL_STGM_FAILIFTHERE = @as(u32, 524288);
pub const DBPROPVAL_STGM_PRIORITY = @as(u32, 1048576);
pub const DBPROPVAL_STGM_DELETEONRELEASE = @as(u32, 2097152);
pub const DBPROPVAL_GB_COLLATE = @as(i32, 16);
pub const DBPROPVAL_CS_UNINITIALIZED = @as(i32, 0);
pub const DBPROPVAL_CS_INITIALIZED = @as(i32, 1);
pub const DBPROPVAL_CS_COMMUNICATIONFAILURE = @as(i32, 2);
pub const DBPROPVAL_RD_RESETALL = @as(i32, -1);
pub const DBPROPVAL_OS_RESOURCEPOOLING = @as(i32, 1);
pub const DBPROPVAL_OS_TXNENLISTMENT = @as(i32, 2);
pub const DBPROPVAL_OS_CLIENTCURSOR = @as(i32, 4);
pub const DBPROPVAL_OS_ENABLEALL = @as(i32, -1);
pub const DBPROPVAL_BI_CROSSROWSET = @as(i32, 1);
pub const MDPROPVAL_NL_SCHEMAONLY = @as(i32, 4);
pub const DBPROPVAL_OS_DISABLEALL = @as(i32, 0);
pub const DBPROPVAL_OO_ROWOBJECT = @as(i32, 4);
pub const DBPROPVAL_OO_SCOPED = @as(i32, 8);
pub const DBPROPVAL_OO_DIRECTBIND = @as(i32, 16);
pub const DBPROPVAL_DST_DOCSOURCE = @as(i32, 4);
pub const DBPROPVAL_GU_NOTSUPPORTED = @as(i32, 1);
pub const DBPROPVAL_GU_SUFFIX = @as(i32, 2);
pub const DB_BINDFLAGS_DELAYFETCHCOLUMNS = @as(i32, 1);
pub const DB_BINDFLAGS_DELAYFETCHSTREAM = @as(i32, 2);
pub const DB_BINDFLAGS_RECURSIVE = @as(i32, 4);
pub const DB_BINDFLAGS_OUTPUT = @as(i32, 8);
pub const DB_BINDFLAGS_COLLECTION = @as(i32, 16);
pub const DB_BINDFLAGS_OPENIFEXISTS = @as(i32, 32);
pub const DB_BINDFLAGS_OVERWRITE = @as(i32, 64);
pub const DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT = @as(i32, 128);
pub const DBPROPVAL_ORS_TABLE = @as(i32, 0);
pub const DBPROPVAL_ORS_INDEX = @as(i32, 1);
pub const DBPROPVAL_ORS_INTEGRATEDINDEX = @as(i32, 2);
pub const DBPROPVAL_TC_DDL_LOCK = @as(i32, 16);
pub const DBPROPVAL_ORS_STOREDPROC = @as(i32, 4);
pub const DBPROPVAL_IN_ALLOWNULL = @as(i32, 0);
pub const DBPROPVAL_OO_SINGLETON = @as(i32, 32);
pub const DBPROPVAL_OS_AGR_AFTERSESSION = @as(i32, 8);
pub const DBPROPVAL_CM_TRANSACTIONS = @as(i32, 1);
pub const DBPROPVAL_TS_CARDINALITY = @as(i32, 1);
pub const DBPROPVAL_TS_HISTOGRAM = @as(i32, 2);
pub const DBPROPVAL_ORS_HISTOGRAM = @as(i32, 8);
pub const MDPROPVAL_VISUAL_MODE_DEFAULT = @as(i32, 0);
pub const MDPROPVAL_VISUAL_MODE_VISUAL = @as(i32, 1);
pub const MDPROPVAL_VISUAL_MODE_VISUAL_OFF = @as(i32, 2);
pub const DB_IMP_LEVEL_ANONYMOUS = @as(u32, 0);
pub const DB_IMP_LEVEL_IDENTIFY = @as(u32, 1);
pub const DB_IMP_LEVEL_IMPERSONATE = @as(u32, 2);
pub const DB_IMP_LEVEL_DELEGATE = @as(u32, 3);
pub const DBPROMPT_PROMPT = @as(u32, 1);
pub const DBPROMPT_COMPLETE = @as(u32, 2);
pub const DBPROMPT_COMPLETEREQUIRED = @as(u32, 3);
pub const DBPROMPT_NOPROMPT = @as(u32, 4);
pub const DB_PROT_LEVEL_NONE = @as(u32, 0);
pub const DB_PROT_LEVEL_CONNECT = @as(u32, 1);
pub const DB_PROT_LEVEL_CALL = @as(u32, 2);
pub const DB_PROT_LEVEL_PKT = @as(u32, 3);
pub const DB_PROT_LEVEL_PKT_INTEGRITY = @as(u32, 4);
pub const DB_PROT_LEVEL_PKT_PRIVACY = @as(u32, 5);
pub const DB_MODE_READ = @as(u32, 1);
pub const DB_MODE_WRITE = @as(u32, 2);
pub const DB_MODE_READWRITE = @as(u32, 3);
pub const DB_MODE_SHARE_DENY_READ = @as(u32, 4);
pub const DB_MODE_SHARE_DENY_WRITE = @as(u32, 8);
pub const DB_MODE_SHARE_EXCLUSIVE = @as(u32, 12);
pub const DB_MODE_SHARE_DENY_NONE = @as(u32, 16);
pub const DBCOMPUTEMODE_COMPUTED = @as(u32, 1);
pub const DBCOMPUTEMODE_DYNAMIC = @as(u32, 2);
pub const DBCOMPUTEMODE_NOTCOMPUTED = @as(u32, 3);
pub const DBPROPVAL_DF_INITIALLY_DEFERRED = @as(u32, 1);
pub const DBPROPVAL_DF_INITIALLY_IMMEDIATE = @as(u32, 2);
pub const DBPROPVAL_DF_NOT_DEFERRABLE = @as(u32, 3);
pub const DBPARAMTYPE_INPUT = @as(u32, 1);
pub const DBPARAMTYPE_INPUTOUTPUT = @as(u32, 2);
pub const DBPARAMTYPE_OUTPUT = @as(u32, 3);
pub const DBPARAMTYPE_RETURNVALUE = @as(u32, 4);
pub const DB_PT_UNKNOWN = @as(u32, 1);
pub const DB_PT_PROCEDURE = @as(u32, 2);
pub const DB_PT_FUNCTION = @as(u32, 3);
pub const DB_REMOTE = @as(u32, 1);
pub const DB_LOCAL_SHARED = @as(u32, 2);
pub const DB_LOCAL_EXCLUSIVE = @as(u32, 3);
pub const DB_COLLATION_ASC = @as(u32, 1);
pub const DB_COLLATION_DESC = @as(u32, 2);
pub const DB_UNSEARCHABLE = @as(u32, 1);
pub const DB_LIKE_ONLY = @as(u32, 2);
pub const DB_ALL_EXCEPT_LIKE = @as(u32, 3);
pub const DB_SEARCHABLE = @as(u32, 4);
pub const MDTREEOP_CHILDREN = @as(u32, 1);
pub const MDTREEOP_SIBLINGS = @as(u32, 2);
pub const MDTREEOP_PARENT = @as(u32, 4);
pub const MDTREEOP_SELF = @as(u32, 8);
pub const MDTREEOP_DESCENDANTS = @as(u32, 16);
pub const MDTREEOP_ANCESTORS = @as(u32, 32);
pub const MD_DIMTYPE_UNKNOWN = @as(u32, 0);
pub const MD_DIMTYPE_TIME = @as(u32, 1);
pub const MD_DIMTYPE_MEASURE = @as(u32, 2);
pub const MD_DIMTYPE_OTHER = @as(u32, 3);
pub const MDLEVEL_TYPE_UNKNOWN = @as(u32, 0);
pub const MDLEVEL_TYPE_REGULAR = @as(u32, 0);
pub const MDLEVEL_TYPE_ALL = @as(u32, 1);
pub const MDLEVEL_TYPE_CALCULATED = @as(u32, 2);
pub const MDLEVEL_TYPE_TIME = @as(u32, 4);
pub const MDLEVEL_TYPE_RESERVED1 = @as(u32, 8);
pub const MDLEVEL_TYPE_TIME_YEARS = @as(u32, 20);
pub const MDLEVEL_TYPE_TIME_HALF_YEAR = @as(u32, 36);
pub const MDLEVEL_TYPE_TIME_QUARTERS = @as(u32, 68);
pub const MDLEVEL_TYPE_TIME_MONTHS = @as(u32, 132);
pub const MDLEVEL_TYPE_TIME_WEEKS = @as(u32, 260);
pub const MDLEVEL_TYPE_TIME_DAYS = @as(u32, 516);
pub const MDLEVEL_TYPE_TIME_HOURS = @as(u32, 772);
pub const MDLEVEL_TYPE_TIME_MINUTES = @as(u32, 1028);
pub const MDLEVEL_TYPE_TIME_SECONDS = @as(u32, 2052);
pub const MDLEVEL_TYPE_TIME_UNDEFINED = @as(u32, 4100);
pub const MDMEASURE_AGGR_UNKNOWN = @as(u32, 0);
pub const MDMEASURE_AGGR_SUM = @as(u32, 1);
pub const MDMEASURE_AGGR_COUNT = @as(u32, 2);
pub const MDMEASURE_AGGR_MIN = @as(u32, 3);
pub const MDMEASURE_AGGR_MAX = @as(u32, 4);
pub const MDMEASURE_AGGR_AVG = @as(u32, 5);
pub const MDMEASURE_AGGR_VAR = @as(u32, 6);
pub const MDMEASURE_AGGR_STD = @as(u32, 7);
pub const MDMEASURE_AGGR_CALCULATED = @as(u32, 127);
pub const MDPROP_MEMBER = @as(u32, 1);
pub const MDPROP_CELL = @as(u32, 2);
pub const MDMEMBER_TYPE_UNKNOWN = @as(u32, 0);
pub const MDMEMBER_TYPE_REGULAR = @as(u32, 1);
pub const MDMEMBER_TYPE_ALL = @as(u32, 2);
pub const MDMEMBER_TYPE_MEASURE = @as(u32, 3);
pub const MDMEMBER_TYPE_FORMULA = @as(u32, 4);
pub const MDMEMBER_TYPE_RESERVE1 = @as(u32, 5);
pub const MDMEMBER_TYPE_RESERVE2 = @as(u32, 6);
pub const MDMEMBER_TYPE_RESERVE3 = @as(u32, 7);
pub const MDMEMBER_TYPE_RESERVE4 = @as(u32, 8);
pub const MDDISPINFO_DRILLED_DOWN = @as(u32, 65536);
pub const MDDISPINFO_PARENT_SAME_AS_PREV = @as(u32, 131072);
pub const DB_COUNTUNAVAILABLE = @as(i32, -1);
pub const MDFF_BOLD = @as(u32, 1);
pub const MDFF_ITALIC = @as(u32, 2);
pub const MDFF_UNDERLINE = @as(u32, 4);
pub const MDFF_STRIKEOUT = @as(u32, 8);
pub const MDAXIS_COLUMNS = @as(u32, 0);
pub const MDAXIS_ROWS = @as(u32, 1);
pub const MDAXIS_PAGES = @as(u32, 2);
pub const MDAXIS_SECTIONS = @as(u32, 3);
pub const MDAXIS_CHAPTERS = @as(u32, 4);
pub const MDAXIS_SLICERS = @as(u32, 4294967295);
pub const CRESTRICTIONS_DBSCHEMA_ASSERTIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CATALOGS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_CHARACTER_SETS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_COLUMN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_CONSTRAINT_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_KEY_COLUMN_USAGE = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_REFERENTIAL_CONSTRAINTS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_CONSTRAINTS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_DOMAIN_USAGE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_INDEXES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_OBJECT_ACTIONS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_OBJECTS = @as(u32, 1);
pub const CRESTRICTIONS_DBSCHEMA_COLUMN_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_PRIVILEGES = @as(u32, 5);
pub const CRESTRICTIONS_DBSCHEMA_USAGE_PRIVILEGES = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_SCHEMATA = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_SQL_LANGUAGES = @as(u32, 0);
pub const CRESTRICTIONS_DBSCHEMA_STATISTICS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_TABLES = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TRANSLATIONS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROVIDER_TYPES = @as(u32, 2);
pub const CRESTRICTIONS_DBSCHEMA_VIEWS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_COLUMN_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_VIEW_TABLE_USAGE = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_PARAMETERS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_FOREIGN_KEYS = @as(u32, 6);
pub const CRESTRICTIONS_DBSCHEMA_PRIMARY_KEYS = @as(u32, 3);
pub const CRESTRICTIONS_DBSCHEMA_PROCEDURE_COLUMNS = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLES_INFO = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_CUBES = @as(u32, 3);
pub const CRESTRICTIONS_MDSCHEMA_DIMENSIONS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_HIERARCHIES = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_LEVELS = @as(u32, 7);
pub const CRESTRICTIONS_MDSCHEMA_MEASURES = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_PROPERTIES = @as(u32, 9);
pub const CRESTRICTIONS_MDSCHEMA_MEMBERS = @as(u32, 12);
pub const CRESTRICTIONS_DBSCHEMA_TRUSTEE = @as(u32, 4);
pub const CRESTRICTIONS_DBSCHEMA_TABLE_STATISTICS = @as(u32, 7);
pub const CRESTRICTIONS_DBSCHEMA_CHECK_CONSTRAINTS_BY_TABLE = @as(u32, 6);
pub const CRESTRICTIONS_MDSCHEMA_FUNCTIONS = @as(u32, 4);
pub const CRESTRICTIONS_MDSCHEMA_ACTIONS = @as(u32, 8);
pub const CRESTRICTIONS_MDSCHEMA_COMMANDS = @as(u32, 5);
pub const CRESTRICTIONS_MDSCHEMA_SETS = @as(u32, 5);
pub const IDENTIFIER_SDK_MASK = @as(u32, 4026531840);
pub const IDENTIFIER_SDK_ERROR = @as(u32, 268435456);
pub const DBPROP_MSDAORA_DETERMINEKEYCOLUMNS = @as(u32, 1);
pub const DBPROP_MSDAORA8_DETERMINEKEYCOLUMNS = @as(u32, 2);
pub const PWPROP_OSPVALUE = @as(u32, 2);
pub const STGM_COLLECTION = @as(i32, 8192);
pub const STGM_OUTPUT = @as(i32, 32768);
pub const STGM_OPEN = @as(i32, -2147483648);
pub const STGM_RECURSIVE = @as(i32, 16777216);
pub const STGM_STRICTOPEN = @as(i32, 1073741824);
pub const KAGPROP_QUERYBASEDUPDATES = @as(u32, 2);
pub const KAGPROP_MARSHALLABLE = @as(u32, 3);
pub const KAGPROP_POSITIONONNEWROW = @as(u32, 4);
pub const KAGPROP_IRowsetChangeExtInfo = @as(u32, 5);
pub const KAGPROP_CURSOR = @as(u32, 6);
pub const KAGPROP_CONCURRENCY = @as(u32, 7);
pub const KAGPROP_BLOBSONFOCURSOR = @as(u32, 8);
pub const KAGPROP_INCLUDENONEXACT = @as(u32, 9);
pub const KAGPROP_FORCESSFIREHOSEMODE = @as(u32, 10);
pub const KAGPROP_FORCENOPARAMETERREBIND = @as(u32, 11);
pub const KAGPROP_FORCENOPREPARE = @as(u32, 12);
pub const KAGPROP_FORCENOREEXECUTE = @as(u32, 13);
pub const KAGPROP_ACCESSIBLEPROCEDURES = @as(u32, 2);
pub const KAGPROP_ACCESSIBLETABLES = @as(u32, 3);
pub const KAGPROP_ODBCSQLOPTIEF = @as(u32, 4);
pub const KAGPROP_OJCAPABILITY = @as(u32, 5);
pub const KAGPROP_PROCEDURES = @as(u32, 6);
pub const KAGPROP_DRIVERNAME = @as(u32, 7);
pub const KAGPROP_DRIVERVER = @as(u32, 8);
pub const KAGPROP_DRIVERODBCVER = @as(u32, 9);
pub const KAGPROP_LIKEESCAPECLAUSE = @as(u32, 10);
pub const KAGPROP_SPECIALCHARACTERS = @as(u32, 11);
pub const KAGPROP_MAXCOLUMNSINGROUPBY = @as(u32, 12);
pub const KAGPROP_MAXCOLUMNSININDEX = @as(u32, 13);
pub const KAGPROP_MAXCOLUMNSINORDERBY = @as(u32, 14);
pub const KAGPROP_MAXCOLUMNSINSELECT = @as(u32, 15);
pub const KAGPROP_MAXCOLUMNSINTABLE = @as(u32, 16);
pub const KAGPROP_NUMERICFUNCTIONS = @as(u32, 17);
pub const KAGPROP_ODBCSQLCONFORMANCE = @as(u32, 18);
pub const KAGPROP_OUTERJOINS = @as(u32, 19);
pub const KAGPROP_STRINGFUNCTIONS = @as(u32, 20);
pub const KAGPROP_SYSTEMFUNCTIONS = @as(u32, 21);
pub const KAGPROP_TIMEDATEFUNCTIONS = @as(u32, 22);
pub const KAGPROP_FILEUSAGE = @as(u32, 23);
pub const KAGPROP_ACTIVESTATEMENTS = @as(u32, 24);
pub const KAGPROP_AUTH_TRUSTEDCONNECTION = @as(u32, 2);
pub const KAGPROP_AUTH_SERVERINTEGRATED = @as(u32, 3);
pub const KAGPROPVAL_CONCUR_ROWVER = @as(u32, 1);
pub const KAGPROPVAL_CONCUR_VALUES = @as(u32, 2);
pub const KAGPROPVAL_CONCUR_LOCK = @as(u32, 4);
pub const KAGPROPVAL_CONCUR_READ_ONLY = @as(u32, 8);
pub const ODBCVER = @as(u32, 896);
pub const ODBC_ADD_DSN = @as(u32, 1);
pub const ODBC_CONFIG_DSN = @as(u32, 2);
pub const ODBC_REMOVE_DSN = @as(u32, 3);
pub const ODBC_ADD_SYS_DSN = @as(u32, 4);
pub const ODBC_CONFIG_SYS_DSN = @as(u32, 5);
pub const ODBC_REMOVE_SYS_DSN = @as(u32, 6);
pub const ODBC_REMOVE_DEFAULT_DSN = @as(u32, 7);
pub const ODBC_INSTALL_INQUIRY = @as(u32, 1);
pub const ODBC_INSTALL_COMPLETE = @as(u32, 2);
pub const ODBC_INSTALL_DRIVER = @as(u32, 1);
pub const ODBC_REMOVE_DRIVER = @as(u32, 2);
pub const ODBC_CONFIG_DRIVER = @as(u32, 3);
pub const ODBC_CONFIG_DRIVER_MAX = @as(u32, 100);
pub const ODBC_BOTH_DSN = @as(u32, 0);
pub const ODBC_USER_DSN = @as(u32, 1);
pub const ODBC_SYSTEM_DSN = @as(u32, 2);
pub const ODBC_ERROR_GENERAL_ERR = @as(u32, 1);
pub const ODBC_ERROR_INVALID_BUFF_LEN = @as(u32, 2);
pub const ODBC_ERROR_INVALID_HWND = @as(u32, 3);
pub const ODBC_ERROR_INVALID_STR = @as(u32, 4);
pub const ODBC_ERROR_INVALID_REQUEST_TYPE = @as(u32, 5);
pub const ODBC_ERROR_COMPONENT_NOT_FOUND = @as(u32, 6);
pub const ODBC_ERROR_INVALID_NAME = @as(u32, 7);
pub const ODBC_ERROR_INVALID_KEYWORD_VALUE = @as(u32, 8);
pub const ODBC_ERROR_INVALID_DSN = @as(u32, 9);
pub const ODBC_ERROR_INVALID_INF = @as(u32, 10);
pub const ODBC_ERROR_REQUEST_FAILED = @as(u32, 11);
pub const ODBC_ERROR_INVALID_PATH = @as(u32, 12);
pub const ODBC_ERROR_LOAD_LIB_FAILED = @as(u32, 13);
pub const ODBC_ERROR_INVALID_PARAM_SEQUENCE = @as(u32, 14);
pub const ODBC_ERROR_INVALID_LOG_FILE = @as(u32, 15);
pub const ODBC_ERROR_USER_CANCELED = @as(u32, 16);
pub const ODBC_ERROR_USAGE_UPDATE_FAILED = @as(u32, 17);
pub const ODBC_ERROR_CREATE_DSN_FAILED = @as(u32, 18);
pub const ODBC_ERROR_WRITING_SYSINFO_FAILED = @as(u32, 19);
pub const ODBC_ERROR_REMOVE_DSN_FAILED = @as(u32, 20);
pub const ODBC_ERROR_OUT_OF_MEM = @as(u32, 21);
pub const ODBC_ERROR_OUTPUT_STRING_TRUNCATED = @as(u32, 22);
pub const ODBC_ERROR_NOTRANINFO = @as(u32, 23);
pub const ODBC_ERROR_MAX = @as(u32, 23);
pub const SQL_MAX_SQLSERVERNAME = @as(u32, 128);
pub const SQL_COPT_SS_BASE = @as(u32, 1200);
pub const SQL_COPT_SS_REMOTE_PWD = @as(u32, 1201);
pub const SQL_COPT_SS_USE_PROC_FOR_PREP = @as(u32, 1202);
pub const SQL_COPT_SS_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_COPT_SS_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_COPT_SS_USER_DATA = @as(u32, 1205);
pub const SQL_COPT_SS_FALLBACK_CONNECT = @as(u32, 1210);
pub const SQL_COPT_SS_PERF_DATA = @as(u32, 1211);
pub const SQL_COPT_SS_PERF_DATA_LOG = @as(u32, 1212);
pub const SQL_COPT_SS_PERF_QUERY_INTERVAL = @as(u32, 1213);
pub const SQL_COPT_SS_PERF_QUERY_LOG = @as(u32, 1214);
pub const SQL_COPT_SS_PERF_QUERY = @as(u32, 1215);
pub const SQL_COPT_SS_PERF_DATA_LOG_NOW = @as(u32, 1216);
pub const SQL_COPT_SS_QUOTED_IDENT = @as(u32, 1217);
pub const SQL_COPT_SS_ANSI_NPW = @as(u32, 1218);
pub const SQL_COPT_SS_BCP = @as(u32, 1219);
pub const SQL_COPT_SS_TRANSLATE = @as(u32, 1220);
pub const SQL_COPT_SS_ATTACHDBFILENAME = @as(u32, 1221);
pub const SQL_COPT_SS_CONCAT_NULL = @as(u32, 1222);
pub const SQL_COPT_SS_ENCRYPT = @as(u32, 1223);
pub const SQL_COPT_SS_MAX_USED = @as(u32, 1223);
pub const SQL_SOPT_SS_BASE = @as(u32, 1225);
pub const SQL_SOPT_SS_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQL_SOPT_SS_CURRENT_COMMAND = @as(u32, 1226);
pub const SQL_SOPT_SS_HIDDEN_COLUMNS = @as(u32, 1227);
pub const SQL_SOPT_SS_NOBROWSETABLE = @as(u32, 1228);
pub const SQL_SOPT_SS_REGIONALIZE = @as(u32, 1229);
pub const SQL_SOPT_SS_CURSOR_OPTIONS = @as(u32, 1230);
pub const SQL_SOPT_SS_NOCOUNT_STATUS = @as(u32, 1231);
pub const SQL_SOPT_SS_DEFER_PREPARE = @as(u32, 1232);
pub const SQL_SOPT_SS_MAX_USED = @as(u32, 1232);
pub const SQL_COPT_SS_BASE_EX = @as(u32, 1240);
pub const SQL_COPT_SS_BROWSE_CONNECT = @as(u32, 1241);
pub const SQL_COPT_SS_BROWSE_SERVER = @as(u32, 1242);
pub const SQL_COPT_SS_WARN_ON_CP_ERROR = @as(u32, 1243);
pub const SQL_COPT_SS_CONNECTION_DEAD = @as(u32, 1244);
pub const SQL_COPT_SS_BROWSE_CACHE_DATA = @as(u32, 1245);
pub const SQL_COPT_SS_RESET_CONNECTION = @as(u32, 1246);
pub const SQL_COPT_SS_EX_MAX_USED = @as(u32, 1246);
pub const SQL_UP_OFF = @as(i32, 0);
pub const SQL_UP_ON = @as(i32, 1);
pub const SQL_UP_ON_DROP = @as(i32, 2);
pub const SQL_UP_DEFAULT = @as(i32, 1);
pub const SQL_IS_OFF = @as(i32, 0);
pub const SQL_IS_ON = @as(i32, 1);
pub const SQL_IS_DEFAULT = @as(i32, 0);
pub const SQL_PC_OFF = @as(i32, 0);
pub const SQL_PC_ON = @as(i32, 1);
pub const SQL_PC_DEFAULT = @as(i32, 0);
pub const SQL_XL_OFF = @as(i32, 0);
pub const SQL_XL_ON = @as(i32, 1);
pub const SQL_XL_DEFAULT = @as(i32, 1);
pub const SQL_FB_OFF = @as(i32, 0);
pub const SQL_FB_ON = @as(i32, 1);
pub const SQL_FB_DEFAULT = @as(i32, 0);
pub const SQL_BCP_OFF = @as(i32, 0);
pub const SQL_BCP_ON = @as(i32, 1);
pub const SQL_BCP_DEFAULT = @as(i32, 0);
pub const SQL_QI_OFF = @as(i32, 0);
pub const SQL_QI_ON = @as(i32, 1);
pub const SQL_QI_DEFAULT = @as(i32, 1);
pub const SQL_AD_OFF = @as(i32, 0);
pub const SQL_AD_ON = @as(i32, 1);
pub const SQL_AD_DEFAULT = @as(i32, 1);
pub const SQL_CN_OFF = @as(i32, 0);
pub const SQL_CN_ON = @as(i32, 1);
pub const SQL_CN_DEFAULT = @as(i32, 1);
pub const SQL_TL_OFF = @as(i32, 0);
pub const SQL_TL_ON = @as(i32, 1);
pub const SQL_TL_DEFAULT = @as(i32, 1);
pub const SQL_HC_OFF = @as(i32, 0);
pub const SQL_HC_ON = @as(i32, 1);
pub const SQL_HC_DEFAULT = @as(i32, 0);
pub const SQL_NB_OFF = @as(i32, 0);
pub const SQL_NB_ON = @as(i32, 1);
pub const SQL_NB_DEFAULT = @as(i32, 0);
pub const SQL_RE_OFF = @as(i32, 0);
pub const SQL_RE_ON = @as(i32, 1);
pub const SQL_RE_DEFAULT = @as(i32, 0);
pub const SQL_CO_OFF = @as(i32, 0);
pub const SQL_CO_FFO = @as(i32, 1);
pub const SQL_CO_AF = @as(i32, 2);
pub const SQL_CO_FIREHOSE_AF = @as(i32, 4);
pub const SQL_CO_DEFAULT = @as(i32, 0);
pub const SQL_NC_OFF = @as(i32, 0);
pub const SQL_NC_ON = @as(i32, 1);
pub const SQL_DP_OFF = @as(i32, 0);
pub const SQL_DP_ON = @as(i32, 1);
pub const SQL_EN_OFF = @as(i32, 0);
pub const SQL_EN_ON = @as(i32, 1);
pub const SQL_MORE_INFO_NO = @as(i32, 0);
pub const SQL_MORE_INFO_YES = @as(i32, 1);
pub const SQL_CACHE_DATA_NO = @as(i32, 0);
pub const SQL_CACHE_DATA_YES = @as(i32, 1);
pub const SQL_RESET_YES = @as(i32, 1);
pub const SQL_WARN_NO = @as(i32, 0);
pub const SQL_WARN_YES = @as(i32, 1);
pub const SQL_CURSOR_FAST_FORWARD_ONLY = @as(u32, 8);
pub const SQL_CA_SS_BASE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_SSTYPE = @as(u32, 1200);
pub const SQL_CA_SS_COLUMN_UTYPE = @as(u32, 1201);
pub const SQL_CA_SS_NUM_ORDERS = @as(u32, 1202);
pub const SQL_CA_SS_COLUMN_ORDER = @as(u32, 1203);
pub const SQL_CA_SS_COLUMN_VARYLEN = @as(u32, 1204);
pub const SQL_CA_SS_NUM_COMPUTES = @as(u32, 1205);
pub const SQL_CA_SS_COMPUTE_ID = @as(u32, 1206);
pub const SQL_CA_SS_COMPUTE_BYLIST = @as(u32, 1207);
pub const SQL_CA_SS_COLUMN_ID = @as(u32, 1208);
pub const SQL_CA_SS_COLUMN_OP = @as(u32, 1209);
pub const SQL_CA_SS_COLUMN_SIZE = @as(u32, 1210);
pub const SQL_CA_SS_COLUMN_HIDDEN = @as(u32, 1211);
pub const SQL_CA_SS_COLUMN_KEY = @as(u32, 1212);
pub const SQL_CA_SS_COLUMN_COLLATION = @as(u32, 1214);
pub const SQL_CA_SS_VARIANT_TYPE = @as(u32, 1215);
pub const SQL_CA_SS_VARIANT_SQL_TYPE = @as(u32, 1216);
pub const SQL_CA_SS_VARIANT_SERVER_TYPE = @as(u32, 1217);
pub const SQL_CA_SS_MAX_USED = @as(u32, 1218);
pub const SQLTEXT = @as(u32, 35);
pub const SQLVARBINARY = @as(u32, 37);
pub const SQLINTN = @as(u32, 38);
pub const SQLVARCHAR = @as(u32, 39);
pub const SQLBINARY = @as(u32, 45);
pub const SQLIMAGE = @as(u32, 34);
pub const SQLCHARACTER = @as(u32, 47);
pub const SQLINT1 = @as(u32, 48);
pub const SQLBIT = @as(u32, 50);
pub const SQLINT2 = @as(u32, 52);
pub const SQLINT4 = @as(u32, 56);
pub const SQLMONEY = @as(u32, 60);
pub const SQLDATETIME = @as(u32, 61);
pub const SQLFLT8 = @as(u32, 62);
pub const SQLFLTN = @as(u32, 109);
pub const SQLMONEYN = @as(u32, 110);
pub const SQLDATETIMN = @as(u32, 111);
pub const SQLFLT4 = @as(u32, 59);
pub const SQLMONEY4 = @as(u32, 122);
pub const SQLDATETIM4 = @as(u32, 58);
pub const SQLDECIMAL = @as(u32, 106);
pub const SQLNUMERIC = @as(u32, 108);
pub const SQLUNIQUEID = @as(u32, 36);
pub const SQLBIGCHAR = @as(u32, 175);
pub const SQLBIGVARCHAR = @as(u32, 167);
pub const SQLBIGBINARY = @as(u32, 173);
pub const SQLBIGVARBINARY = @as(u32, 165);
pub const SQLBITN = @as(u32, 104);
pub const SQLNCHAR = @as(u32, 239);
pub const SQLNVARCHAR = @as(u32, 231);
pub const SQLNTEXT = @as(u32, 99);
pub const SQLINT8 = @as(u32, 127);
pub const SQLVARIANT = @as(u32, 98);
pub const SQLudtBINARY = @as(u32, 3);
pub const SQLudtBIT = @as(u32, 16);
pub const SQLudtBITN = @as(u32, 0);
pub const SQLudtCHAR = @as(u32, 1);
pub const SQLudtDATETIM4 = @as(u32, 22);
pub const SQLudtDATETIME = @as(u32, 12);
pub const SQLudtDATETIMN = @as(u32, 15);
pub const SQLudtDECML = @as(u32, 24);
pub const SQLudtDECMLN = @as(u32, 26);
pub const SQLudtFLT4 = @as(u32, 23);
pub const SQLudtFLT8 = @as(u32, 8);
pub const SQLudtFLTN = @as(u32, 14);
pub const SQLudtIMAGE = @as(u32, 20);
pub const SQLudtINT1 = @as(u32, 5);
pub const SQLudtINT2 = @as(u32, 6);
pub const SQLudtINT4 = @as(u32, 7);
pub const SQLudtINTN = @as(u32, 13);
pub const SQLudtMONEY = @as(u32, 11);
pub const SQLudtMONEY4 = @as(u32, 21);
pub const SQLudtMONEYN = @as(u32, 17);
pub const SQLudtNUM = @as(u32, 10);
pub const SQLudtNUMN = @as(u32, 25);
pub const SQLudtSYSNAME = @as(u32, 18);
pub const SQLudtTEXT = @as(u32, 19);
pub const SQLudtTIMESTAMP = @as(u32, 80);
pub const SQLudtUNIQUEIDENTIFIER = @as(u32, 0);
pub const SQLudtVARBINARY = @as(u32, 4);
pub const SQLudtVARCHAR = @as(u32, 2);
pub const MIN_USER_DATATYPE = @as(u32, 256);
pub const SQLAOPSTDEV = @as(u32, 48);
pub const SQLAOPSTDEVP = @as(u32, 49);
pub const SQLAOPVAR = @as(u32, 50);
pub const SQLAOPVARP = @as(u32, 51);
pub const SQLAOPCNT = @as(u32, 75);
pub const SQLAOPSUM = @as(u32, 77);
pub const SQLAOPAVG = @as(u32, 79);
pub const SQLAOPMIN = @as(u32, 81);
pub const SQLAOPMAX = @as(u32, 82);
pub const SQLAOPANY = @as(u32, 83);
pub const SQLAOPNOOP = @as(u32, 86);
pub const SQL_INFO_SS_FIRST = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEW = @as(u32, 1199);
pub const SQL_INFO_SS_NETLIB_NAMEA = @as(u32, 1200);
pub const SQL_INFO_SS_MAX_USED = @as(u32, 1200);
pub const SQL_INFO_SS_NETLIB_NAME = @as(u32, 1199);
pub const SQL_SS_VARIANT = @as(i32, -150);
pub const SQL_DIAG_SS_BASE = @as(i32, -1150);
pub const SQL_DIAG_SS_MSGSTATE = @as(i32, -1150);
pub const SQL_DIAG_DFC_SS_BASE = @as(i32, -200);
pub const EX_ANY = @as(u32, 0);
pub const EX_INFO = @as(u32, 10);
pub const EX_MAXISEVERITY = @as(u32, 10);
pub const EX_MISSING = @as(u32, 11);
pub const EX_TYPE = @as(u32, 12);
pub const EX_DEADLOCK = @as(u32, 13);
pub const EX_PERMIT = @as(u32, 14);
pub const EX_SYNTAX = @as(u32, 15);
pub const EX_USER = @as(u32, 16);
pub const EX_RESOURCE = @as(u32, 17);
pub const EX_INTOK = @as(u32, 18);
pub const MAXUSEVERITY = @as(u32, 18);
pub const EX_LIMIT = @as(u32, 19);
pub const EX_CMDFATAL = @as(u32, 20);
pub const MINFATALERR = @as(u32, 20);
pub const EX_DBFATAL = @as(u32, 21);
pub const EX_TABCORRUPT = @as(u32, 22);
pub const EX_DBCORRUPT = @as(u32, 23);
pub const EX_HARDWARE = @as(u32, 24);
pub const EX_CONTROL = @as(u32, 25);
pub const DBMAXCHAR = @as(u32, 8001);
pub const MAXNAME = @as(u32, 129);
pub const MAXNUMERICLEN = @as(u32, 16);
pub const SQL_PERF_START = @as(u32, 1);
pub const SQL_PERF_STOP = @as(u32, 2);
pub const SQL_SS_DL_DEFAULT = "STATS.LOG";
pub const SQL_SS_QL_DEFAULT = "QUERY.LOG";
pub const SQL_SS_QI_DEFAULT = @as(u32, 30000);
pub const SUCCEED = @as(u32, 1);
pub const FAIL = @as(u32, 0);
pub const SUCCEED_ABORT = @as(u32, 2);
pub const SUCCEED_ASYNC = @as(u32, 3);
pub const DB_IN = @as(u32, 1);
pub const DB_OUT = @as(u32, 2);
pub const BCPMAXERRS = @as(u32, 1);
pub const BCPFIRST = @as(u32, 2);
pub const BCPLAST = @as(u32, 3);
pub const BCPBATCH = @as(u32, 4);
pub const BCPKEEPNULLS = @as(u32, 5);
pub const BCPABORT = @as(u32, 6);
pub const BCPODBC = @as(u32, 7);
pub const BCPKEEPIDENTITY = @as(u32, 8);
pub const BCP6xFILEFMT = @as(u32, 9);
pub const BCPHINTSA = @as(u32, 10);
pub const BCPHINTSW = @as(u32, 11);
pub const BCPFILECP = @as(u32, 12);
pub const BCPUNICODEFILE = @as(u32, 13);
pub const BCPTEXTFILE = @as(u32, 14);
pub const BCPFILEFMT = @as(u32, 15);
pub const BCPFILECP_ACP = @as(u32, 0);
pub const BCPFILECP_OEMCP = @as(u32, 1);
pub const BCPFILECP_RAW = @as(i32, -1);
pub const SQL_VARLEN_DATA = @as(i32, -10);
pub const BCPHINTS = @as(u32, 11);
pub const BCP_FMT_TYPE = @as(u32, 1);
pub const BCP_FMT_INDICATOR_LEN = @as(u32, 2);
pub const BCP_FMT_DATA_LEN = @as(u32, 3);
pub const BCP_FMT_TERMINATOR = @as(u32, 4);
pub const BCP_FMT_SERVER_COL = @as(u32, 5);
pub const BCP_FMT_COLLATION = @as(u32, 6);
pub const BCP_FMT_COLLATION_ID = @as(u32, 7);
pub const SQL_FAST_CONNECT = @as(u32, 1200);
pub const SQL_FC_OFF = @as(i32, 0);
pub const SQL_FC_ON = @as(i32, 1);
pub const SQL_FC_DEFAULT = @as(i32, 0);
pub const SQL_COPT_SS_ANSI_OEM = @as(u32, 1206);
pub const SQL_AO_OFF = @as(i32, 0);
pub const SQL_AO_ON = @as(i32, 1);
pub const SQL_AO_DEFAULT = @as(i32, 0);
pub const SQL_REMOTE_PWD = @as(u32, 1201);
pub const SQL_USE_PROCEDURE_FOR_PREPARE = @as(u32, 1202);
pub const SQL_INTEGRATED_SECURITY = @as(u32, 1203);
pub const SQL_PRESERVE_CURSORS = @as(u32, 1204);
pub const SQL_TEXTPTR_LOGGING = @as(u32, 1225);
pub const SQLDECIMALN = @as(u32, 106);
pub const SQLNUMERICN = @as(u32, 108);
pub const DB_E_BOGUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217665));
pub const DB_E_BADACCESSORHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217920));
pub const DB_E_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217919));
pub const DB_E_READONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217918));
pub const DB_E_SCHEMAVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217917));
pub const DB_E_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217916));
pub const DB_E_OBJECTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217915));
pub const DB_E_BADCHAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217914));
pub const DB_E_CANTCONVERTVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217913));
pub const DB_E_BADBINDINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217912));
pub const DB_SEC_E_PERMISSIONDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217911));
pub const DB_E_NOTAREFERENCECOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217910));
pub const DB_E_LIMITREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217909));
pub const DB_E_NOCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217908));
pub const DB_E_COSTLIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217907));
pub const DB_E_BADBOOKMARK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217906));
pub const DB_E_BADLOCKMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217905));
pub const DB_E_PARAMNOTOPTIONAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217904));
pub const DB_E_BADCOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217903));
pub const DB_E_BADRATIO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217902));
pub const DB_E_BADVALUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217901));
pub const DB_E_ERRORSINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217900));
pub const DB_E_CANTCANCEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217899));
pub const DB_E_DIALECTNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217898));
pub const DB_E_DUPLICATEDATASOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217897));
pub const DB_E_CANNOTRESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217896));
pub const DB_E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217895));
pub const DB_E_NEWLYINSERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217893));
pub const DB_E_CANNOTFREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217894));
pub const DB_E_GOALREJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217892));
pub const DB_E_UNSUPPORTEDCONVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217891));
pub const DB_E_BADSTARTPOSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217890));
pub const DB_E_NOQUERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217889));
pub const DB_E_NOTREENTRANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217888));
pub const DB_E_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217887));
pub const DB_E_NOAGGREGATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217886));
pub const DB_E_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217885));
pub const DB_E_CANTFETCHBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217884));
pub const DB_E_ROWSNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217883));
pub const DB_E_BADSTORAGEFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217882));
pub const DB_E_BADCOMPAREOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217881));
pub const DB_E_BADSTATUSVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217880));
pub const DB_E_CANTSCROLLBACKWARDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217879));
pub const DB_E_BADREGIONHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217878));
pub const DB_E_NONCONTIGUOUSRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217877));
pub const DB_E_INVALIDTRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217876));
pub const DB_E_NOTASUBREGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217875));
pub const DB_E_MULTIPLESTATEMENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217874));
pub const DB_E_INTEGRITYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217873));
pub const DB_E_BADTYPENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217872));
pub const DB_E_ABORTLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217871));
pub const DB_E_ROWSETINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217870));
pub const DB_E_CANTTRANSLATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217869));
pub const DB_E_DUPLICATEINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217868));
pub const DB_E_NOINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217867));
pub const DB_E_INDEXINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217866));
pub const DB_E_NOTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217865));
pub const DB_E_CONCURRENCYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217864));
pub const DB_E_BADCOPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217863));
pub const DB_E_BADPRECISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217862));
pub const DB_E_BADSCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217861));
pub const DB_E_BADTABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217860));
pub const DB_E_BADID = @as(i32, -2147217860);
pub const DB_E_BADTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217859));
pub const DB_E_DUPLICATECOLUMNID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217858));
pub const DB_E_DUPLICATETABLEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217857));
pub const DB_E_TABLEINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217856));
pub const DB_E_NOLOCALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217855));
pub const DB_E_BADRECORDNUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217854));
pub const DB_E_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217853));
pub const DB_E_BADPROPERTYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217852));
pub const DB_E_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217851));
pub const DB_E_BADACCESSORFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217850));
pub const DB_E_BADSTORAGEFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217849));
pub const DB_E_BYREFACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217848));
pub const DB_E_NULLACCESSORNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217847));
pub const DB_E_NOTPREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217846));
pub const DB_E_BADACCESSORTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217845));
pub const DB_E_WRITEONLYACCESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217844));
pub const DB_SEC_E_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217843));
pub const DB_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217842));
pub const DB_E_CHAPTERNOTRELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217841));
pub const DB_E_BADSOURCEHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217840));
pub const DB_E_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217839));
pub const DB_E_ALREADYINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217838));
pub const DB_E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217837));
pub const DB_E_MAXPENDCHANGESEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217836));
pub const DB_E_BADORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217835));
pub const DB_E_PENDINGCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217834));
pub const DB_E_DATAOVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217833));
pub const DB_E_BADHRESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217832));
pub const DB_E_BADLOOKUPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217831));
pub const DB_E_BADDYNAMICERRORID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217830));
pub const DB_E_PENDINGINSERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217829));
pub const DB_E_BADCONVERTFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217828));
pub const DB_E_BADPARAMETERNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217827));
pub const DB_E_MULTIPLESTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217826));
pub const DB_E_CANTFILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217825));
pub const DB_E_CANTORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217824));
pub const MD_E_BADTUPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217823));
pub const MD_E_BADCOORDINATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217822));
pub const MD_E_INVALIDAXIS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217821));
pub const MD_E_INVALIDCELLRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217820));
pub const DB_E_NOCOLUMN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217819));
pub const DB_E_COMMANDNOTPERSISTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217817));
pub const DB_E_DUPLICATEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217816));
pub const DB_E_OBJECTCREATIONLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217815));
pub const DB_E_BADINDEXID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217806));
pub const DB_E_BADINITSTRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217805));
pub const DB_E_NOPROVIDERSREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217804));
pub const DB_E_MISMATCHEDPROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217803));
pub const DB_E_BADCOMMANDID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217802));
pub const SEC_E_PERMISSIONDENIED = @as(i32, -2147217911);
pub const SEC_E_BADTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217814));
pub const SEC_E_NOTRUSTEEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217813));
pub const SEC_E_NOMEMBERSHIPSUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217812));
pub const SEC_E_INVALIDOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217811));
pub const SEC_E_NOOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217810));
pub const SEC_E_INVALIDACCESSENTRYLIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217809));
pub const SEC_E_INVALIDOWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217808));
pub const SEC_E_INVALIDACCESSENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217807));
pub const DB_E_BADCONSTRAINTTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217801));
pub const DB_E_BADCONSTRAINTFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217800));
pub const DB_E_BADDEFERRABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217799));
pub const DB_E_BADMATCHTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217792));
pub const DB_E_BADUPDATEDELETERULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217782));
pub const DB_E_BADCONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217781));
pub const DB_E_BADCOMMANDFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217780));
pub const DB_E_OBJECTMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217779));
pub const DB_E_NOSOURCEOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217775));
pub const DB_E_RESOURCELOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217774));
pub const DB_E_NOTCOLLECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217773));
pub const DB_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217772));
pub const DB_E_ASYNCNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217771));
pub const DB_E_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217770));
pub const DB_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217769));
pub const DB_E_RESOURCEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217768));
pub const DB_E_RESOURCEOUTOFSCOPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217778));
pub const DB_E_DROPRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217776));
pub const DB_E_DUPLICATECONSTRAINTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217767));
pub const DB_E_OUTOFSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217766));
pub const DB_SEC_E_SAFEMODE_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217765));
pub const DB_E_NOSTATISTIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217764));
pub const DB_E_ALTERRESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217763));
pub const DB_E_RESOURCENOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217762));
pub const DB_E_NOCONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217761));
pub const DB_E_COLUMNUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217760));
pub const DB_S_ROWLIMITEXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265920));
pub const DB_S_COLUMNTYPEMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265921));
pub const DB_S_TYPEINFOOVERRIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265922));
pub const DB_S_BOOKMARKSKIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265923));
pub const DB_S_NONEXTROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265925));
pub const DB_S_ENDOFROWSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265926));
pub const DB_S_COMMANDREEXECUTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265927));
pub const DB_S_BUFFERFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265928));
pub const DB_S_NORESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265929));
pub const DB_S_CANTRELEASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265930));
pub const DB_S_GOALCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265931));
pub const DB_S_UNWANTEDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265932));
pub const DB_S_DIALECTIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265933));
pub const DB_S_UNWANTEDPHASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265934));
pub const DB_S_UNWANTEDREASON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265935));
pub const DB_S_ASYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265936));
pub const DB_S_COLUMNSCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265937));
pub const DB_S_ERRORSRETURNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265938));
pub const DB_S_BADROWHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265939));
pub const DB_S_DELETEDROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265940));
pub const DB_S_TOOMANYCHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265941));
pub const DB_S_STOPLIMITREACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265942));
pub const DB_S_LOCKUPGRADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265944));
pub const DB_S_PROPERTIESCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265945));
pub const DB_S_ERRORSOCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265946));
pub const DB_S_PARAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265947));
pub const DB_S_MULTIPLECHANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265948));
pub const DB_S_NOTSINGLETON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265943));
pub const DB_S_NOROWSPECIFICCOLUMNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 265949));
pub const DBPROPFLAGS_PERSIST = @as(u32, 8192);
pub const DBPROPVAL_PERSIST_ADTG = @as(u32, 0);
pub const DBPROPVAL_PERSIST_XML = @as(u32, 1);
pub const DBPROP_PersistFormat = @as(u32, 2);
pub const DBPROP_PersistSchema = @as(u32, 3);
pub const DBPROP_HCHAPTER = @as(u32, 4);
pub const DBPROP_MAINTAINPROPS = @as(u32, 5);
pub const DBPROP_Unicode = @as(u32, 6);
pub const DBPROP_INTERLEAVEDROWS = @as(u32, 8);
pub const MS_PERSIST_PROGID = "MSPersist";
pub const DISPID_QUERY_RANKVECTOR = @as(u32, 2);
pub const DISPID_QUERY_RANK = @as(u32, 3);
pub const DISPID_QUERY_HITCOUNT = @as(u32, 4);
pub const DISPID_QUERY_WORKID = @as(u32, 5);
pub const DISPID_QUERY_ALL = @as(u32, 6);
pub const DISPID_QUERY_UNFILTERED = @as(u32, 7);
pub const DISPID_QUERY_REVNAME = @as(u32, 8);
pub const DISPID_QUERY_VIRTUALPATH = @as(u32, 9);
pub const DISPID_QUERY_LASTSEENTIME = @as(u32, 10);
pub const CQUERYDISPIDS = @as(u32, 11);
pub const DISPID_QUERY_METADATA_VROOTUSED = @as(u32, 2);
pub const DISPID_QUERY_METADATA_VROOTAUTOMATIC = @as(u32, 3);
pub const DISPID_QUERY_METADATA_VROOTMANUAL = @as(u32, 4);
pub const DISPID_QUERY_METADATA_PROPGUID = @as(u32, 5);
pub const DISPID_QUERY_METADATA_PROPDISPID = @as(u32, 6);
pub const DISPID_QUERY_METADATA_PROPNAME = @as(u32, 7);
pub const DISPID_QUERY_METADATA_STORELEVEL = @as(u32, 8);
pub const DISPID_QUERY_METADATA_PROPMODIFIABLE = @as(u32, 9);
pub const CQUERYMETADISPIDS = @as(u32, 10);
pub const PROPID_DBBMK_BOOKMARK = @as(u32, 2);
pub const PROPID_DBBMK_CHAPTER = @as(u32, 3);
pub const CDBBMKDISPIDS = @as(u32, 8);
pub const PROPID_DBSELF_SELF = @as(u32, 2);
pub const CDBSELFDISPIDS = @as(u32, 8);
pub const CDBCOLDISPIDS = @as(u32, 28);
pub const CQUERYPROPERTY = @as(u32, 64);
pub const QUERY_VALIDBITS = @as(u32, 3);
pub const RTNone = @as(u32, 0);
pub const RTAnd = @as(u32, 1);
pub const RTOr = @as(u32, 2);
pub const RTNot = @as(u32, 3);
pub const RTContent = @as(u32, 4);
pub const RTProperty = @as(u32, 5);
pub const RTProximity = @as(u32, 6);
pub const RTVector = @as(u32, 7);
pub const RTNatLanguage = @as(u32, 8);
pub const GENERATE_METHOD_PREFIXMATCH = @as(u32, 1);
pub const GENERATE_METHOD_STEMMED = @as(u32, 2);
pub const PRRE = @as(u32, 6);
pub const PRAllBits = @as(u32, 7);
pub const PRSomeBits = @as(u32, 8);
pub const PRAll = @as(u32, 256);
pub const PRAny = @as(u32, 512);
pub const QUERY_SORTXASCEND = @as(u32, 2);
pub const QUERY_SORTXDESCEND = @as(u32, 3);
pub const QUERY_SORTDEFAULT = @as(u32, 4);
pub const CATEGORIZE_UNIQUE = @as(u32, 0);
pub const CATEGORIZE_CLUSTER = @as(u32, 1);
pub const CATEGORIZE_BUCKETS = @as(u32, 2);
pub const BUCKET_LINEAR = @as(u32, 0);
pub const BUCKET_EXPONENTIAL = @as(u32, 1);
pub const CATEGORIZE_RANGE = @as(u32, 3);
pub const OCC_INVALID = @as(u32, 4294967295);
pub const MAX_QUERY_RANK = @as(u32, 1000);
pub const OSP_IndexLabel = @as(u32, 0);
pub const SQL_NULL_DATA = @as(i32, -1);
pub const SQL_DATA_AT_EXEC = @as(i32, -2);
pub const SQL_SUCCESS = @as(u32, 0);
pub const SQL_SUCCESS_WITH_INFO = @as(u32, 1);
pub const SQL_NO_DATA = @as(u32, 100);
pub const SQL_PARAM_DATA_AVAILABLE = @as(u32, 101);
pub const SQL_ERROR = @as(i32, -1);
pub const SQL_INVALID_HANDLE = @as(i32, -2);
pub const SQL_STILL_EXECUTING = @as(u32, 2);
pub const SQL_NEED_DATA = @as(u32, 99);
pub const SQL_NTS = @as(i32, -3);
pub const SQL_NTSL = @as(i32, -3);
pub const SQL_MAX_MESSAGE_LENGTH = @as(u32, 512);
pub const SQL_DATE_LEN = @as(u32, 10);
pub const SQL_TIME_LEN = @as(u32, 8);
pub const SQL_TIMESTAMP_LEN = @as(u32, 19);
pub const SQL_HANDLE_ENV = @as(u32, 1);
pub const SQL_HANDLE_DBC = @as(u32, 2);
pub const SQL_HANDLE_STMT = @as(u32, 3);
pub const SQL_HANDLE_DESC = @as(u32, 4);
pub const SQL_ATTR_OUTPUT_NTS = @as(u32, 10001);
pub const SQL_ATTR_AUTO_IPD = @as(u32, 10001);
pub const SQL_ATTR_METADATA_ID = @as(u32, 10014);
pub const SQL_ATTR_APP_ROW_DESC = @as(u32, 10010);
pub const SQL_ATTR_APP_PARAM_DESC = @as(u32, 10011);
pub const SQL_ATTR_IMP_ROW_DESC = @as(u32, 10012);
pub const SQL_ATTR_IMP_PARAM_DESC = @as(u32, 10013);
pub const SQL_ATTR_CURSOR_SCROLLABLE = @as(i32, -1);
pub const SQL_ATTR_CURSOR_SENSITIVITY = @as(i32, -2);
pub const SQL_NONSCROLLABLE = @as(u32, 0);
pub const SQL_SCROLLABLE = @as(u32, 1);
pub const SQL_DESC_COUNT = @as(u32, 1001);
pub const SQL_DESC_TYPE = @as(u32, 1002);
pub const SQL_DESC_LENGTH = @as(u32, 1003);
pub const SQL_DESC_OCTET_LENGTH_PTR = @as(u32, 1004);
pub const SQL_DESC_PRECISION = @as(u32, 1005);
pub const SQL_DESC_SCALE = @as(u32, 1006);
pub const SQL_DESC_DATETIME_INTERVAL_CODE = @as(u32, 1007);
pub const SQL_DESC_NULLABLE = @as(u32, 1008);
pub const SQL_DESC_INDICATOR_PTR = @as(u32, 1009);
pub const SQL_DESC_DATA_PTR = @as(u32, 1010);
pub const SQL_DESC_NAME = @as(u32, 1011);
pub const SQL_DESC_UNNAMED = @as(u32, 1012);
pub const SQL_DESC_OCTET_LENGTH = @as(u32, 1013);
pub const SQL_DESC_ALLOC_TYPE = @as(u32, 1099);
pub const SQL_DIAG_RETURNCODE = @as(u32, 1);
pub const SQL_DIAG_NUMBER = @as(u32, 2);
pub const SQL_DIAG_ROW_COUNT = @as(u32, 3);
pub const SQL_DIAG_SQLSTATE = @as(u32, 4);
pub const SQL_DIAG_NATIVE = @as(u32, 5);
pub const SQL_DIAG_MESSAGE_TEXT = @as(u32, 6);
pub const SQL_DIAG_DYNAMIC_FUNCTION = @as(u32, 7);
pub const SQL_DIAG_CLASS_ORIGIN = @as(u32, 8);
pub const SQL_DIAG_SUBCLASS_ORIGIN = @as(u32, 9);
pub const SQL_DIAG_CONNECTION_NAME = @as(u32, 10);
pub const SQL_DIAG_SERVER_NAME = @as(u32, 11);
pub const SQL_DIAG_DYNAMIC_FUNCTION_CODE = @as(u32, 12);
pub const SQL_DIAG_ALTER_DOMAIN = @as(u32, 3);
pub const SQL_DIAG_ALTER_TABLE = @as(u32, 4);
pub const SQL_DIAG_CALL = @as(u32, 7);
pub const SQL_DIAG_CREATE_ASSERTION = @as(u32, 6);
pub const SQL_DIAG_CREATE_CHARACTER_SET = @as(u32, 8);
pub const SQL_DIAG_CREATE_COLLATION = @as(u32, 10);
pub const SQL_DIAG_CREATE_DOMAIN = @as(u32, 23);
pub const SQL_DIAG_CREATE_INDEX = @as(i32, -1);
pub const SQL_DIAG_CREATE_SCHEMA = @as(u32, 64);
pub const SQL_DIAG_CREATE_TABLE = @as(u32, 77);
pub const SQL_DIAG_CREATE_TRANSLATION = @as(u32, 79);
pub const SQL_DIAG_CREATE_VIEW = @as(u32, 84);
pub const SQL_DIAG_DELETE_WHERE = @as(u32, 19);
pub const SQL_DIAG_DROP_ASSERTION = @as(u32, 24);
pub const SQL_DIAG_DROP_CHARACTER_SET = @as(u32, 25);
pub const SQL_DIAG_DROP_COLLATION = @as(u32, 26);
pub const SQL_DIAG_DROP_DOMAIN = @as(u32, 27);
pub const SQL_DIAG_DROP_INDEX = @as(i32, -2);
pub const SQL_DIAG_DROP_SCHEMA = @as(u32, 31);
pub const SQL_DIAG_DROP_TABLE = @as(u32, 32);
pub const SQL_DIAG_DROP_TRANSLATION = @as(u32, 33);
pub const SQL_DIAG_DROP_VIEW = @as(u32, 36);
pub const SQL_DIAG_DYNAMIC_DELETE_CURSOR = @as(u32, 38);
pub const SQL_DIAG_DYNAMIC_UPDATE_CURSOR = @as(u32, 81);
pub const SQL_DIAG_GRANT = @as(u32, 48);
pub const SQL_DIAG_INSERT = @as(u32, 50);
pub const SQL_DIAG_REVOKE = @as(u32, 59);
pub const SQL_DIAG_SELECT_CURSOR = @as(u32, 85);
pub const SQL_DIAG_UNKNOWN_STATEMENT = @as(u32, 0);
pub const SQL_DIAG_UPDATE_WHERE = @as(u32, 82);
pub const SQL_UNKNOWN_TYPE = @as(u32, 0);
pub const SQL_CHAR = @as(u32, 1);
pub const SQL_NUMERIC = @as(u32, 2);
pub const SQL_DECIMAL = @as(u32, 3);
pub const SQL_INTEGER = @as(u32, 4);
pub const SQL_SMALLINT = @as(u32, 5);
pub const SQL_FLOAT = @as(u32, 6);
pub const SQL_REAL = @as(u32, 7);
pub const SQL_DOUBLE = @as(u32, 8);
pub const SQL_DATETIME = @as(u32, 9);
pub const SQL_VARCHAR = @as(u32, 12);
pub const SQL_TYPE_DATE = @as(u32, 91);
pub const SQL_TYPE_TIME = @as(u32, 92);
pub const SQL_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_UNSPECIFIED = @as(u32, 0);
pub const SQL_INSENSITIVE = @as(u32, 1);
pub const SQL_SENSITIVE = @as(u32, 2);
pub const SQL_ALL_TYPES = @as(u32, 0);
pub const SQL_DEFAULT = @as(u32, 99);
pub const SQL_ARD_TYPE = @as(i32, -99);
pub const SQL_APD_TYPE = @as(i32, -100);
pub const SQL_CODE_DATE = @as(u32, 1);
pub const SQL_CODE_TIME = @as(u32, 2);
pub const SQL_CODE_TIMESTAMP = @as(u32, 3);
pub const SQL_FALSE = @as(u32, 0);
pub const SQL_TRUE = @as(u32, 1);
pub const SQL_NO_NULLS = @as(u32, 0);
pub const SQL_NULLABLE = @as(u32, 1);
pub const SQL_NULLABLE_UNKNOWN = @as(u32, 2);
pub const SQL_PRED_NONE = @as(u32, 0);
pub const SQL_PRED_CHAR = @as(u32, 1);
pub const SQL_PRED_BASIC = @as(u32, 2);
pub const SQL_NAMED = @as(u32, 0);
pub const SQL_UNNAMED = @as(u32, 1);
pub const SQL_DESC_ALLOC_AUTO = @as(u32, 1);
pub const SQL_DESC_ALLOC_USER = @as(u32, 2);
pub const SQL_CLOSE = @as(u32, 0);
pub const SQL_DROP = @as(u32, 1);
pub const SQL_UNBIND = @as(u32, 2);
pub const SQL_RESET_PARAMS = @as(u32, 3);
pub const SQL_FETCH_NEXT = @as(u32, 1);
pub const SQL_FETCH_FIRST = @as(u32, 2);
pub const SQL_FETCH_LAST = @as(u32, 3);
pub const SQL_FETCH_PRIOR = @as(u32, 4);
pub const SQL_FETCH_ABSOLUTE = @as(u32, 5);
pub const SQL_FETCH_RELATIVE = @as(u32, 6);
pub const SQL_COMMIT = @as(u32, 0);
pub const SQL_ROLLBACK = @as(u32, 1);
pub const SQL_NULL_HENV = @as(u32, 0);
pub const SQL_NULL_HDBC = @as(u32, 0);
pub const SQL_NULL_HSTMT = @as(u32, 0);
pub const SQL_NULL_HDESC = @as(u32, 0);
pub const SQL_NULL_HANDLE = @as(i32, 0);
pub const SQL_SCOPE_CURROW = @as(u32, 0);
pub const SQL_SCOPE_TRANSACTION = @as(u32, 1);
pub const SQL_SCOPE_SESSION = @as(u32, 2);
pub const SQL_PC_UNKNOWN = @as(u32, 0);
pub const SQL_PC_NON_PSEUDO = @as(u32, 1);
pub const SQL_PC_PSEUDO = @as(u32, 2);
pub const SQL_ROW_IDENTIFIER = @as(u32, 1);
pub const SQL_INDEX_UNIQUE = @as(u32, 0);
pub const SQL_INDEX_ALL = @as(u32, 1);
pub const SQL_INDEX_CLUSTERED = @as(u32, 1);
pub const SQL_INDEX_HASHED = @as(u32, 2);
pub const SQL_INDEX_OTHER = @as(u32, 3);
pub const SQL_API_SQLALLOCCONNECT = @as(u32, 1);
pub const SQL_API_SQLALLOCENV = @as(u32, 2);
pub const SQL_API_SQLALLOCHANDLE = @as(u32, 1001);
pub const SQL_API_SQLALLOCSTMT = @as(u32, 3);
pub const SQL_API_SQLBINDCOL = @as(u32, 4);
pub const SQL_API_SQLBINDPARAM = @as(u32, 1002);
pub const SQL_API_SQLCANCEL = @as(u32, 5);
pub const SQL_API_SQLCLOSECURSOR = @as(u32, 1003);
pub const SQL_API_SQLCOLATTRIBUTE = @as(u32, 6);
pub const SQL_API_SQLCOLUMNS = @as(u32, 40);
pub const SQL_API_SQLCONNECT = @as(u32, 7);
pub const SQL_API_SQLCOPYDESC = @as(u32, 1004);
pub const SQL_API_SQLDATASOURCES = @as(u32, 57);
pub const SQL_API_SQLDESCRIBECOL = @as(u32, 8);
pub const SQL_API_SQLDISCONNECT = @as(u32, 9);
pub const SQL_API_SQLENDTRAN = @as(u32, 1005);
pub const SQL_API_SQLERROR = @as(u32, 10);
pub const SQL_API_SQLEXECDIRECT = @as(u32, 11);
pub const SQL_API_SQLEXECUTE = @as(u32, 12);
pub const SQL_API_SQLFETCH = @as(u32, 13);
pub const SQL_API_SQLFETCHSCROLL = @as(u32, 1021);
pub const SQL_API_SQLFREECONNECT = @as(u32, 14);
pub const SQL_API_SQLFREEENV = @as(u32, 15);
pub const SQL_API_SQLFREEHANDLE = @as(u32, 1006);
pub const SQL_API_SQLFREESTMT = @as(u32, 16);
pub const SQL_API_SQLGETCONNECTATTR = @as(u32, 1007);
pub const SQL_API_SQLGETCONNECTOPTION = @as(u32, 42);
pub const SQL_API_SQLGETCURSORNAME = @as(u32, 17);
pub const SQL_API_SQLGETDATA = @as(u32, 43);
pub const SQL_API_SQLGETDESCFIELD = @as(u32, 1008);
pub const SQL_API_SQLGETDESCREC = @as(u32, 1009);
pub const SQL_API_SQLGETDIAGFIELD = @as(u32, 1010);
pub const SQL_API_SQLGETDIAGREC = @as(u32, 1011);
pub const SQL_API_SQLGETENVATTR = @as(u32, 1012);
pub const SQL_API_SQLGETFUNCTIONS = @as(u32, 44);
pub const SQL_API_SQLGETINFO = @as(u32, 45);
pub const SQL_API_SQLGETSTMTATTR = @as(u32, 1014);
pub const SQL_API_SQLGETSTMTOPTION = @as(u32, 46);
pub const SQL_API_SQLGETTYPEINFO = @as(u32, 47);
pub const SQL_API_SQLNUMRESULTCOLS = @as(u32, 18);
pub const SQL_API_SQLPARAMDATA = @as(u32, 48);
pub const SQL_API_SQLPREPARE = @as(u32, 19);
pub const SQL_API_SQLPUTDATA = @as(u32, 49);
pub const SQL_API_SQLROWCOUNT = @as(u32, 20);
pub const SQL_API_SQLSETCONNECTATTR = @as(u32, 1016);
pub const SQL_API_SQLSETCONNECTOPTION = @as(u32, 50);
pub const SQL_API_SQLSETCURSORNAME = @as(u32, 21);
pub const SQL_API_SQLSETDESCFIELD = @as(u32, 1017);
pub const SQL_API_SQLSETDESCREC = @as(u32, 1018);
pub const SQL_API_SQLSETENVATTR = @as(u32, 1019);
pub const SQL_API_SQLSETPARAM = @as(u32, 22);
pub const SQL_API_SQLSETSTMTATTR = @as(u32, 1020);
pub const SQL_API_SQLSETSTMTOPTION = @as(u32, 51);
pub const SQL_API_SQLSPECIALCOLUMNS = @as(u32, 52);
pub const SQL_API_SQLSTATISTICS = @as(u32, 53);
pub const SQL_API_SQLTABLES = @as(u32, 54);
pub const SQL_API_SQLTRANSACT = @as(u32, 23);
pub const SQL_API_SQLCANCELHANDLE = @as(u32, 1550);
pub const SQL_API_SQLCOMPLETEASYNC = @as(u32, 1551);
pub const SQL_MAX_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAXIMUM_DRIVER_CONNECTIONS = @as(u32, 0);
pub const SQL_MAX_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_MAXIMUM_CONCURRENT_ACTIVITIES = @as(u32, 1);
pub const SQL_DATA_SOURCE_NAME = @as(u32, 2);
pub const SQL_FETCH_DIRECTION = @as(u32, 8);
pub const SQL_SERVER_NAME = @as(u32, 13);
pub const SQL_SEARCH_PATTERN_ESCAPE = @as(u32, 14);
pub const SQL_DBMS_NAME = @as(u32, 17);
pub const SQL_DBMS_VER = @as(u32, 18);
pub const SQL_ACCESSIBLE_TABLES = @as(u32, 19);
pub const SQL_ACCESSIBLE_PROCEDURES = @as(u32, 20);
pub const SQL_CURSOR_COMMIT_BEHAVIOR = @as(u32, 23);
pub const SQL_DATA_SOURCE_READ_ONLY = @as(u32, 25);
pub const SQL_DEFAULT_TXN_ISOLATION = @as(u32, 26);
pub const SQL_IDENTIFIER_CASE = @as(u32, 28);
pub const SQL_IDENTIFIER_QUOTE_CHAR = @as(u32, 29);
pub const SQL_MAX_COLUMN_NAME_LEN = @as(u32, 30);
pub const SQL_MAXIMUM_COLUMN_NAME_LENGTH = @as(u32, 30);
pub const SQL_MAX_CURSOR_NAME_LEN = @as(u32, 31);
pub const SQL_MAXIMUM_CURSOR_NAME_LENGTH = @as(u32, 31);
pub const SQL_MAX_SCHEMA_NAME_LEN = @as(u32, 32);
pub const SQL_MAXIMUM_SCHEMA_NAME_LENGTH = @as(u32, 32);
pub const SQL_MAX_CATALOG_NAME_LEN = @as(u32, 34);
pub const SQL_MAXIMUM_CATALOG_NAME_LENGTH = @as(u32, 34);
pub const SQL_MAX_TABLE_NAME_LEN = @as(u32, 35);
pub const SQL_SCROLL_CONCURRENCY = @as(u32, 43);
pub const SQL_TXN_CAPABLE = @as(u32, 46);
pub const SQL_TRANSACTION_CAPABLE = @as(u32, 46);
pub const SQL_USER_NAME = @as(u32, 47);
pub const SQL_TXN_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_TRANSACTION_ISOLATION_OPTION = @as(u32, 72);
pub const SQL_INTEGRITY = @as(u32, 73);
pub const SQL_GETDATA_EXTENSIONS = @as(u32, 81);
pub const SQL_NULL_COLLATION = @as(u32, 85);
pub const SQL_ALTER_TABLE = @as(u32, 86);
pub const SQL_ORDER_BY_COLUMNS_IN_SELECT = @as(u32, 90);
pub const SQL_SPECIAL_CHARACTERS = @as(u32, 94);
pub const SQL_MAX_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAXIMUM_COLUMNS_IN_GROUP_BY = @as(u32, 97);
pub const SQL_MAX_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAXIMUM_COLUMNS_IN_INDEX = @as(u32, 98);
pub const SQL_MAX_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAXIMUM_COLUMNS_IN_ORDER_BY = @as(u32, 99);
pub const SQL_MAX_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAXIMUM_COLUMNS_IN_SELECT = @as(u32, 100);
pub const SQL_MAX_COLUMNS_IN_TABLE = @as(u32, 101);
pub const SQL_MAX_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAXIMUM_INDEX_SIZE = @as(u32, 102);
pub const SQL_MAX_ROW_SIZE = @as(u32, 104);
pub const SQL_MAXIMUM_ROW_SIZE = @as(u32, 104);
pub const SQL_MAX_STATEMENT_LEN = @as(u32, 105);
pub const SQL_MAXIMUM_STATEMENT_LENGTH = @as(u32, 105);
pub const SQL_MAX_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAXIMUM_TABLES_IN_SELECT = @as(u32, 106);
pub const SQL_MAX_USER_NAME_LEN = @as(u32, 107);
pub const SQL_MAXIMUM_USER_NAME_LENGTH = @as(u32, 107);
pub const SQL_OJ_CAPABILITIES = @as(u32, 115);
pub const SQL_OUTER_JOIN_CAPABILITIES = @as(u32, 115);
pub const SQL_XOPEN_CLI_YEAR = @as(u32, 10000);
pub const SQL_CURSOR_SENSITIVITY = @as(u32, 10001);
pub const SQL_DESCRIBE_PARAMETER = @as(u32, 10002);
pub const SQL_CATALOG_NAME = @as(u32, 10003);
pub const SQL_COLLATION_SEQ = @as(u32, 10004);
pub const SQL_MAX_IDENTIFIER_LEN = @as(u32, 10005);
pub const SQL_MAXIMUM_IDENTIFIER_LENGTH = @as(u32, 10005);
pub const SQL_AT_ADD_COLUMN = @as(i32, 1);
pub const SQL_AT_DROP_COLUMN = @as(i32, 2);
pub const SQL_AT_ADD_CONSTRAINT = @as(i32, 8);
pub const SQL_AM_NONE = @as(u32, 0);
pub const SQL_AM_CONNECTION = @as(u32, 1);
pub const SQL_AM_STATEMENT = @as(u32, 2);
pub const SQL_CB_DELETE = @as(u32, 0);
pub const SQL_CB_CLOSE = @as(u32, 1);
pub const SQL_CB_PRESERVE = @as(u32, 2);
pub const SQL_FD_FETCH_NEXT = @as(i32, 1);
pub const SQL_FD_FETCH_FIRST = @as(i32, 2);
pub const SQL_FD_FETCH_LAST = @as(i32, 4);
pub const SQL_FD_FETCH_PRIOR = @as(i32, 8);
pub const SQL_FD_FETCH_ABSOLUTE = @as(i32, 16);
pub const SQL_FD_FETCH_RELATIVE = @as(i32, 32);
pub const SQL_GD_ANY_COLUMN = @as(i32, 1);
pub const SQL_GD_ANY_ORDER = @as(i32, 2);
pub const SQL_IC_UPPER = @as(u32, 1);
pub const SQL_IC_LOWER = @as(u32, 2);
pub const SQL_IC_SENSITIVE = @as(u32, 3);
pub const SQL_IC_MIXED = @as(u32, 4);
pub const SQL_OJ_LEFT = @as(i32, 1);
pub const SQL_OJ_RIGHT = @as(i32, 2);
pub const SQL_OJ_FULL = @as(i32, 4);
pub const SQL_OJ_NESTED = @as(i32, 8);
pub const SQL_OJ_NOT_ORDERED = @as(i32, 16);
pub const SQL_OJ_INNER = @as(i32, 32);
pub const SQL_OJ_ALL_COMPARISON_OPS = @as(i32, 64);
pub const SQL_SCCO_READ_ONLY = @as(i32, 1);
pub const SQL_SCCO_LOCK = @as(i32, 2);
pub const SQL_SCCO_OPT_ROWVER = @as(i32, 4);
pub const SQL_SCCO_OPT_VALUES = @as(i32, 8);
pub const SQL_TC_NONE = @as(u32, 0);
pub const SQL_TC_DML = @as(u32, 1);
pub const SQL_TC_ALL = @as(u32, 2);
pub const SQL_TC_DDL_COMMIT = @as(u32, 3);
pub const SQL_TC_DDL_IGNORE = @as(u32, 4);
pub const SQL_TXN_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TRANSACTION_READ_UNCOMMITTED = @as(i32, 1);
pub const SQL_TXN_READ_COMMITTED = @as(i32, 2);
pub const SQL_TRANSACTION_READ_COMMITTED = @as(i32, 2);
pub const SQL_TXN_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TRANSACTION_REPEATABLE_READ = @as(i32, 4);
pub const SQL_TXN_SERIALIZABLE = @as(i32, 8);
pub const SQL_TRANSACTION_SERIALIZABLE = @as(i32, 8);
pub const SQL_NC_HIGH = @as(u32, 0);
pub const SQL_NC_LOW = @as(u32, 1);
pub const SQL_SPEC_MAJOR = @as(u32, 3);
pub const SQL_SPEC_MINOR = @as(u32, 80);
pub const SQL_SPEC_STRING = "03.80";
pub const SQL_SQLSTATE_SIZE = @as(u32, 5);
pub const SQL_MAX_DSN_LENGTH = @as(u32, 32);
pub const SQL_MAX_OPTION_STRING_LENGTH = @as(u32, 256);
pub const SQL_NO_DATA_FOUND = @as(u32, 100);
pub const SQL_HANDLE_SENV = @as(u32, 5);
pub const SQL_ATTR_ODBC_VERSION = @as(u32, 200);
pub const SQL_ATTR_CONNECTION_POOLING = @as(u32, 201);
pub const SQL_ATTR_CP_MATCH = @as(u32, 202);
pub const SQL_ATTR_APPLICATION_KEY = @as(u32, 203);
pub const SQL_CP_OFF = @as(u32, 0);
pub const SQL_CP_ONE_PER_DRIVER = @as(u32, 1);
pub const SQL_CP_ONE_PER_HENV = @as(u32, 2);
pub const SQL_CP_DRIVER_AWARE = @as(u32, 3);
pub const SQL_CP_DEFAULT = @as(u32, 0);
pub const SQL_CP_STRICT_MATCH = @as(u32, 0);
pub const SQL_CP_RELAXED_MATCH = @as(u32, 1);
pub const SQL_CP_MATCH_DEFAULT = @as(u32, 0);
pub const SQL_OV_ODBC2 = @as(u32, 2);
pub const SQL_OV_ODBC3 = @as(u32, 3);
pub const SQL_OV_ODBC3_80 = @as(u32, 380);
pub const SQL_ACCESS_MODE = @as(u32, 101);
pub const SQL_AUTOCOMMIT = @as(u32, 102);
pub const SQL_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_OPT_TRACE = @as(u32, 104);
pub const SQL_OPT_TRACEFILE = @as(u32, 105);
pub const SQL_TRANSLATE_DLL = @as(u32, 106);
pub const SQL_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_TXN_ISOLATION = @as(u32, 108);
pub const SQL_CURRENT_QUALIFIER = @as(u32, 109);
pub const SQL_ODBC_CURSORS = @as(u32, 110);
pub const SQL_QUIET_MODE = @as(u32, 111);
pub const SQL_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_ACCESS_MODE = @as(u32, 101);
pub const SQL_ATTR_AUTOCOMMIT = @as(u32, 102);
pub const SQL_ATTR_CONNECTION_TIMEOUT = @as(u32, 113);
pub const SQL_ATTR_CURRENT_CATALOG = @as(u32, 109);
pub const SQL_ATTR_DISCONNECT_BEHAVIOR = @as(u32, 114);
pub const SQL_ATTR_ENLIST_IN_DTC = @as(u32, 1207);
pub const SQL_ATTR_ENLIST_IN_XA = @as(u32, 1208);
pub const SQL_ATTR_LOGIN_TIMEOUT = @as(u32, 103);
pub const SQL_ATTR_ODBC_CURSORS = @as(u32, 110);
pub const SQL_ATTR_PACKET_SIZE = @as(u32, 112);
pub const SQL_ATTR_QUIET_MODE = @as(u32, 111);
pub const SQL_ATTR_TRACE = @as(u32, 104);
pub const SQL_ATTR_TRACEFILE = @as(u32, 105);
pub const SQL_ATTR_TRANSLATE_LIB = @as(u32, 106);
pub const SQL_ATTR_TRANSLATE_OPTION = @as(u32, 107);
pub const SQL_ATTR_TXN_ISOLATION = @as(u32, 108);
pub const SQL_ATTR_CONNECTION_DEAD = @as(u32, 1209);
pub const SQL_ATTR_ANSI_APP = @as(u32, 115);
pub const SQL_ATTR_RESET_CONNECTION = @as(u32, 116);
pub const SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE = @as(u32, 117);
pub const SQL_ATTR_ASYNC_DBC_EVENT = @as(u32, 119);
pub const SQL_CONNECT_OPT_DRVR_START = @as(u32, 1000);
pub const SQL_CONN_OPT_MAX = @as(u32, 112);
pub const SQL_CONN_OPT_MIN = @as(u32, 101);
pub const SQL_MODE_READ_WRITE = @as(u32, 0);
pub const SQL_MODE_READ_ONLY = @as(u32, 1);
pub const SQL_MODE_DEFAULT = @as(u32, 0);
pub const SQL_AUTOCOMMIT_OFF = @as(u32, 0);
pub const SQL_AUTOCOMMIT_ON = @as(u32, 1);
pub const SQL_AUTOCOMMIT_DEFAULT = @as(u32, 1);
pub const SQL_LOGIN_TIMEOUT_DEFAULT = @as(u32, 15);
pub const SQL_OPT_TRACE_OFF = @as(u32, 0);
pub const SQL_OPT_TRACE_ON = @as(u32, 1);
pub const SQL_OPT_TRACE_DEFAULT = @as(u32, 0);
pub const SQL_OPT_TRACE_FILE_DEFAULT = "\\SQL.LOG";
pub const SQL_CUR_USE_IF_NEEDED = @as(u32, 0);
pub const SQL_CUR_USE_ODBC = @as(u32, 1);
pub const SQL_CUR_USE_DRIVER = @as(u32, 2);
pub const SQL_CUR_DEFAULT = @as(u32, 2);
pub const SQL_DB_RETURN_TO_POOL = @as(u32, 0);
pub const SQL_DB_DISCONNECT = @as(u32, 1);
pub const SQL_DB_DEFAULT = @as(u32, 0);
pub const SQL_DTC_DONE = @as(i32, 0);
pub const SQL_CD_TRUE = @as(i32, 1);
pub const SQL_CD_FALSE = @as(i32, 0);
pub const SQL_AA_TRUE = @as(i32, 1);
pub const SQL_AA_FALSE = @as(i32, 0);
pub const SQL_RESET_CONNECTION_YES = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_DBC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_DBC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_MAX_ROWS = @as(u32, 1);
pub const SQL_NOSCAN = @as(u32, 2);
pub const SQL_MAX_LENGTH = @as(u32, 3);
pub const SQL_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_BIND_TYPE = @as(u32, 5);
pub const SQL_CURSOR_TYPE = @as(u32, 6);
pub const SQL_CONCURRENCY = @as(u32, 7);
pub const SQL_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ROWSET_SIZE = @as(u32, 9);
pub const SQL_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_GET_BOOKMARK = @as(u32, 13);
pub const SQL_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ASYNC_ENABLE = @as(u32, 4);
pub const SQL_ATTR_CONCURRENCY = @as(u32, 7);
pub const SQL_ATTR_CURSOR_TYPE = @as(u32, 6);
pub const SQL_ATTR_ENABLE_AUTO_IPD = @as(u32, 15);
pub const SQL_ATTR_FETCH_BOOKMARK_PTR = @as(u32, 16);
pub const SQL_ATTR_KEYSET_SIZE = @as(u32, 8);
pub const SQL_ATTR_MAX_LENGTH = @as(u32, 3);
pub const SQL_ATTR_MAX_ROWS = @as(u32, 1);
pub const SQL_ATTR_NOSCAN = @as(u32, 2);
pub const SQL_ATTR_PARAM_BIND_OFFSET_PTR = @as(u32, 17);
pub const SQL_ATTR_PARAM_BIND_TYPE = @as(u32, 18);
pub const SQL_ATTR_PARAM_OPERATION_PTR = @as(u32, 19);
pub const SQL_ATTR_PARAM_STATUS_PTR = @as(u32, 20);
pub const SQL_ATTR_PARAMS_PROCESSED_PTR = @as(u32, 21);
pub const SQL_ATTR_PARAMSET_SIZE = @as(u32, 22);
pub const SQL_ATTR_QUERY_TIMEOUT = @as(u32, 0);
pub const SQL_ATTR_RETRIEVE_DATA = @as(u32, 11);
pub const SQL_ATTR_ROW_BIND_OFFSET_PTR = @as(u32, 23);
pub const SQL_ATTR_ROW_BIND_TYPE = @as(u32, 5);
pub const SQL_ATTR_ROW_NUMBER = @as(u32, 14);
pub const SQL_ATTR_ROW_OPERATION_PTR = @as(u32, 24);
pub const SQL_ATTR_ROW_STATUS_PTR = @as(u32, 25);
pub const SQL_ATTR_ROWS_FETCHED_PTR = @as(u32, 26);
pub const SQL_ATTR_ROW_ARRAY_SIZE = @as(u32, 27);
pub const SQL_ATTR_SIMULATE_CURSOR = @as(u32, 10);
pub const SQL_ATTR_USE_BOOKMARKS = @as(u32, 12);
pub const SQL_ATTR_ASYNC_STMT_EVENT = @as(u32, 29);
pub const SQL_STMT_OPT_MAX = @as(u32, 14);
pub const SQL_STMT_OPT_MIN = @as(u32, 0);
pub const SQL_IS_POINTER = @as(i32, -4);
pub const SQL_IS_UINTEGER = @as(i32, -5);
pub const SQL_IS_INTEGER = @as(i32, -6);
pub const SQL_IS_USMALLINT = @as(i32, -7);
pub const SQL_IS_SMALLINT = @as(i32, -8);
pub const SQL_PARAM_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_PARAM_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_QUERY_TIMEOUT_DEFAULT = @as(u32, 0);
pub const SQL_MAX_ROWS_DEFAULT = @as(u32, 0);
pub const SQL_NOSCAN_OFF = @as(u32, 0);
pub const SQL_NOSCAN_ON = @as(u32, 1);
pub const SQL_NOSCAN_DEFAULT = @as(u32, 0);
pub const SQL_MAX_LENGTH_DEFAULT = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_OFF = @as(u32, 0);
pub const SQL_ASYNC_ENABLE_ON = @as(u32, 1);
pub const SQL_ASYNC_ENABLE_DEFAULT = @as(u32, 0);
pub const SQL_BIND_BY_COLUMN = @as(u32, 0);
pub const SQL_BIND_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_CONCUR_READ_ONLY = @as(u32, 1);
pub const SQL_CONCUR_LOCK = @as(u32, 2);
pub const SQL_CONCUR_ROWVER = @as(u32, 3);
pub const SQL_CONCUR_VALUES = @as(u32, 4);
pub const SQL_CONCUR_DEFAULT = @as(u32, 1);
pub const SQL_CURSOR_FORWARD_ONLY = @as(u32, 0);
pub const SQL_CURSOR_KEYSET_DRIVEN = @as(u32, 1);
pub const SQL_CURSOR_DYNAMIC = @as(u32, 2);
pub const SQL_CURSOR_STATIC = @as(u32, 3);
pub const SQL_CURSOR_TYPE_DEFAULT = @as(u32, 0);
pub const SQL_ROWSET_SIZE_DEFAULT = @as(u32, 1);
pub const SQL_KEYSET_SIZE_DEFAULT = @as(u32, 0);
pub const SQL_SC_NON_UNIQUE = @as(u32, 0);
pub const SQL_SC_TRY_UNIQUE = @as(u32, 1);
pub const SQL_SC_UNIQUE = @as(u32, 2);
pub const SQL_RD_OFF = @as(u32, 0);
pub const SQL_RD_ON = @as(u32, 1);
pub const SQL_RD_DEFAULT = @as(u32, 1);
pub const SQL_UB_OFF = @as(u32, 0);
pub const SQL_UB_ON = @as(u32, 1);
pub const SQL_UB_DEFAULT = @as(u32, 0);
pub const SQL_UB_FIXED = @as(u32, 1);
pub const SQL_UB_VARIABLE = @as(u32, 2);
pub const SQL_DESC_ARRAY_SIZE = @as(u32, 20);
pub const SQL_DESC_ARRAY_STATUS_PTR = @as(u32, 21);
pub const SQL_DESC_BASE_COLUMN_NAME = @as(u32, 22);
pub const SQL_DESC_BASE_TABLE_NAME = @as(u32, 23);
pub const SQL_DESC_BIND_OFFSET_PTR = @as(u32, 24);
pub const SQL_DESC_BIND_TYPE = @as(u32, 25);
pub const SQL_DESC_DATETIME_INTERVAL_PRECISION = @as(u32, 26);
pub const SQL_DESC_LITERAL_PREFIX = @as(u32, 27);
pub const SQL_DESC_LITERAL_SUFFIX = @as(u32, 28);
pub const SQL_DESC_LOCAL_TYPE_NAME = @as(u32, 29);
pub const SQL_DESC_MAXIMUM_SCALE = @as(u32, 30);
pub const SQL_DESC_MINIMUM_SCALE = @as(u32, 31);
pub const SQL_DESC_NUM_PREC_RADIX = @as(u32, 32);
pub const SQL_DESC_PARAMETER_TYPE = @as(u32, 33);
pub const SQL_DESC_ROWS_PROCESSED_PTR = @as(u32, 34);
pub const SQL_DESC_ROWVER = @as(u32, 35);
pub const SQL_DIAG_CURSOR_ROW_COUNT = @as(i32, -1249);
pub const SQL_DIAG_ROW_NUMBER = @as(i32, -1248);
pub const SQL_DIAG_COLUMN_NUMBER = @as(i32, -1247);
pub const SQL_DATE = @as(u32, 9);
pub const SQL_INTERVAL = @as(u32, 10);
pub const SQL_TIME = @as(u32, 10);
pub const SQL_TIMESTAMP = @as(u32, 11);
pub const SQL_LONGVARCHAR = @as(i32, -1);
pub const SQL_BINARY = @as(i32, -2);
pub const SQL_VARBINARY = @as(i32, -3);
pub const SQL_LONGVARBINARY = @as(i32, -4);
pub const SQL_BIGINT = @as(i32, -5);
pub const SQL_TINYINT = @as(i32, -6);
pub const SQL_BIT = @as(i32, -7);
pub const SQL_GUID = @as(i32, -11);
pub const SQL_CODE_YEAR = @as(u32, 1);
pub const SQL_CODE_MONTH = @as(u32, 2);
pub const SQL_CODE_DAY = @as(u32, 3);
pub const SQL_CODE_HOUR = @as(u32, 4);
pub const SQL_CODE_MINUTE = @as(u32, 5);
pub const SQL_CODE_SECOND = @as(u32, 6);
pub const SQL_CODE_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_CODE_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_CODE_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_CODE_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_CODE_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_CODE_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_CODE_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_INTERVAL_DAY = @as(i32, -83);
pub const SQL_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_UNICODE = @as(i32, -95);
pub const SQL_UNICODE_VARCHAR = @as(i32, -96);
pub const SQL_UNICODE_LONGVARCHAR = @as(i32, -97);
pub const SQL_UNICODE_CHAR = @as(i32, -95);
pub const SQL_TYPE_DRIVER_START = @as(i32, -80);
pub const SQL_TYPE_DRIVER_END = @as(i32, -97);
pub const SQL_C_CHAR = @as(u32, 1);
pub const SQL_C_LONG = @as(u32, 4);
pub const SQL_C_SHORT = @as(u32, 5);
pub const SQL_C_FLOAT = @as(u32, 7);
pub const SQL_C_DOUBLE = @as(u32, 8);
pub const SQL_C_NUMERIC = @as(u32, 2);
pub const SQL_C_DEFAULT = @as(u32, 99);
pub const SQL_SIGNED_OFFSET = @as(i32, -20);
pub const SQL_UNSIGNED_OFFSET = @as(i32, -22);
pub const SQL_C_DATE = @as(u32, 9);
pub const SQL_C_TIME = @as(u32, 10);
pub const SQL_C_TIMESTAMP = @as(u32, 11);
pub const SQL_C_TYPE_DATE = @as(u32, 91);
pub const SQL_C_TYPE_TIME = @as(u32, 92);
pub const SQL_C_TYPE_TIMESTAMP = @as(u32, 93);
pub const SQL_C_INTERVAL_YEAR = @as(i32, -80);
pub const SQL_C_INTERVAL_MONTH = @as(i32, -81);
pub const SQL_C_INTERVAL_DAY = @as(i32, -83);
pub const SQL_C_INTERVAL_HOUR = @as(i32, -84);
pub const SQL_C_INTERVAL_MINUTE = @as(i32, -85);
pub const SQL_C_INTERVAL_SECOND = @as(i32, -86);
pub const SQL_C_INTERVAL_YEAR_TO_MONTH = @as(i32, -82);
pub const SQL_C_INTERVAL_DAY_TO_HOUR = @as(i32, -87);
pub const SQL_C_INTERVAL_DAY_TO_MINUTE = @as(i32, -88);
pub const SQL_C_INTERVAL_DAY_TO_SECOND = @as(i32, -89);
pub const SQL_C_INTERVAL_HOUR_TO_MINUTE = @as(i32, -90);
pub const SQL_C_INTERVAL_HOUR_TO_SECOND = @as(i32, -91);
pub const SQL_C_INTERVAL_MINUTE_TO_SECOND = @as(i32, -92);
pub const SQL_C_BINARY = @as(i32, -2);
pub const SQL_C_BIT = @as(i32, -7);
pub const SQL_C_TINYINT = @as(i32, -6);
pub const SQL_C_GUID = @as(i32, -11);
pub const SQL_TYPE_NULL = @as(u32, 0);
pub const SQL_TYPE_MIN = @as(i32, -7);
pub const SQL_TYPE_MAX = @as(u32, 12);
pub const SQL_DRIVER_C_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_SQL_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DESC_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_DIAG_FIELD_BASE = @as(u32, 16384);
pub const SQL_DRIVER_INFO_TYPE_BASE = @as(u32, 16384);
pub const SQL_DRIVER_CONN_ATTR_BASE = @as(u32, 16384);
pub const SQL_DRIVER_STMT_ATTR_BASE = @as(u32, 16384);
pub const SQL_C_VARBOOKMARK = @as(i32, -2);
pub const SQL_NO_ROW_NUMBER = @as(i32, -1);
pub const SQL_NO_COLUMN_NUMBER = @as(i32, -1);
pub const SQL_ROW_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_COLUMN_NUMBER_UNKNOWN = @as(i32, -2);
pub const SQL_DEFAULT_PARAM = @as(i32, -5);
pub const SQL_IGNORE = @as(i32, -6);
pub const SQL_COLUMN_IGNORE = @as(i32, -6);
pub const SQL_LEN_DATA_AT_EXEC_OFFSET = @as(i32, -100);
pub const SQL_LEN_BINARY_ATTR_OFFSET = @as(i32, -100);
pub const SQL_SETPARAM_VALUE_MAX = @as(i32, -1);
pub const SQL_COLUMN_COUNT = @as(u32, 0);
pub const SQL_COLUMN_NAME = @as(u32, 1);
pub const SQL_COLUMN_TYPE = @as(u32, 2);
pub const SQL_COLUMN_LENGTH = @as(u32, 3);
pub const SQL_COLUMN_PRECISION = @as(u32, 4);
pub const SQL_COLUMN_SCALE = @as(u32, 5);
pub const SQL_COLUMN_DISPLAY_SIZE = @as(u32, 6);
pub const SQL_COLUMN_NULLABLE = @as(u32, 7);
pub const SQL_COLUMN_UNSIGNED = @as(u32, 8);
pub const SQL_COLUMN_MONEY = @as(u32, 9);
pub const SQL_COLUMN_UPDATABLE = @as(u32, 10);
pub const SQL_COLUMN_AUTO_INCREMENT = @as(u32, 11);
pub const SQL_COLUMN_CASE_SENSITIVE = @as(u32, 12);
pub const SQL_COLUMN_SEARCHABLE = @as(u32, 13);
pub const SQL_COLUMN_TYPE_NAME = @as(u32, 14);
pub const SQL_COLUMN_TABLE_NAME = @as(u32, 15);
pub const SQL_COLUMN_OWNER_NAME = @as(u32, 16);
pub const SQL_COLUMN_QUALIFIER_NAME = @as(u32, 17);
pub const SQL_COLUMN_LABEL = @as(u32, 18);
pub const SQL_COLATT_OPT_MAX = @as(u32, 18);
pub const SQL_COLUMN_DRIVER_START = @as(u32, 1000);
pub const SQL_COLATT_OPT_MIN = @as(u32, 0);
pub const SQL_ATTR_READONLY = @as(u32, 0);
pub const SQL_ATTR_WRITE = @as(u32, 1);
pub const SQL_ATTR_READWRITE_UNKNOWN = @as(u32, 2);
pub const SQL_UNSEARCHABLE = @as(u32, 0);
pub const SQL_LIKE_ONLY = @as(u32, 1);
pub const SQL_ALL_EXCEPT_LIKE = @as(u32, 2);
pub const SQL_SEARCHABLE = @as(u32, 3);
pub const SQL_PRED_SEARCHABLE = @as(u32, 3);
pub const SQL_NO_TOTAL = @as(i32, -4);
pub const SQL_API_SQLALLOCHANDLESTD = @as(u32, 73);
pub const SQL_API_SQLBULKOPERATIONS = @as(u32, 24);
pub const SQL_API_SQLBINDPARAMETER = @as(u32, 72);
pub const SQL_API_SQLBROWSECONNECT = @as(u32, 55);
pub const SQL_API_SQLCOLATTRIBUTES = @as(u32, 6);
pub const SQL_API_SQLCOLUMNPRIVILEGES = @as(u32, 56);
pub const SQL_API_SQLDESCRIBEPARAM = @as(u32, 58);
pub const SQL_API_SQLDRIVERCONNECT = @as(u32, 41);
pub const SQL_API_SQLDRIVERS = @as(u32, 71);
pub const SQL_API_SQLPRIVATEDRIVERS = @as(u32, 79);
pub const SQL_API_SQLEXTENDEDFETCH = @as(u32, 59);
pub const SQL_API_SQLFOREIGNKEYS = @as(u32, 60);
pub const SQL_API_SQLMORERESULTS = @as(u32, 61);
pub const SQL_API_SQLNATIVESQL = @as(u32, 62);
pub const SQL_API_SQLNUMPARAMS = @as(u32, 63);
pub const SQL_API_SQLPARAMOPTIONS = @as(u32, 64);
pub const SQL_API_SQLPRIMARYKEYS = @as(u32, 65);
pub const SQL_API_SQLPROCEDURECOLUMNS = @as(u32, 66);
pub const SQL_API_SQLPROCEDURES = @as(u32, 67);
pub const SQL_API_SQLSETPOS = @as(u32, 68);
pub const SQL_API_SQLSETSCROLLOPTIONS = @as(u32, 69);
pub const SQL_API_SQLTABLEPRIVILEGES = @as(u32, 70);
pub const SQL_EXT_API_LAST = @as(u32, 72);
pub const SQL_NUM_FUNCTIONS = @as(u32, 23);
pub const SQL_EXT_API_START = @as(u32, 40);
pub const SQL_API_ALL_FUNCTIONS = @as(u32, 0);
pub const SQL_API_LOADBYORDINAL = @as(u32, 199);
pub const SQL_API_ODBC3_ALL_FUNCTIONS = @as(u32, 999);
pub const SQL_API_ODBC3_ALL_FUNCTIONS_SIZE = @as(u32, 250);
pub const SQL_INFO_FIRST = @as(u32, 0);
pub const SQL_ACTIVE_CONNECTIONS = @as(u32, 0);
pub const SQL_ACTIVE_STATEMENTS = @as(u32, 1);
pub const SQL_DRIVER_HDBC = @as(u32, 3);
pub const SQL_DRIVER_HENV = @as(u32, 4);
pub const SQL_DRIVER_HSTMT = @as(u32, 5);
pub const SQL_DRIVER_NAME = @as(u32, 6);
pub const SQL_DRIVER_VER = @as(u32, 7);
pub const SQL_ODBC_API_CONFORMANCE = @as(u32, 9);
pub const SQL_ODBC_VER = @as(u32, 10);
pub const SQL_ROW_UPDATES = @as(u32, 11);
pub const SQL_ODBC_SAG_CLI_CONFORMANCE = @as(u32, 12);
pub const SQL_ODBC_SQL_CONFORMANCE = @as(u32, 15);
pub const SQL_PROCEDURES = @as(u32, 21);
pub const SQL_CONCAT_NULL_BEHAVIOR = @as(u32, 22);
pub const SQL_CURSOR_ROLLBACK_BEHAVIOR = @as(u32, 24);
pub const SQL_EXPRESSIONS_IN_ORDERBY = @as(u32, 27);
pub const SQL_MAX_OWNER_NAME_LEN = @as(u32, 32);
pub const SQL_MAX_PROCEDURE_NAME_LEN = @as(u32, 33);
pub const SQL_MAX_QUALIFIER_NAME_LEN = @as(u32, 34);
pub const SQL_MULT_RESULT_SETS = @as(u32, 36);
pub const SQL_MULTIPLE_ACTIVE_TXN = @as(u32, 37);
pub const SQL_OUTER_JOINS = @as(u32, 38);
pub const SQL_OWNER_TERM = @as(u32, 39);
pub const SQL_PROCEDURE_TERM = @as(u32, 40);
pub const SQL_QUALIFIER_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_QUALIFIER_TERM = @as(u32, 42);
pub const SQL_SCROLL_OPTIONS = @as(u32, 44);
pub const SQL_TABLE_TERM = @as(u32, 45);
pub const SQL_CONVERT_FUNCTIONS = @as(u32, 48);
pub const SQL_NUMERIC_FUNCTIONS = @as(u32, 49);
pub const SQL_STRING_FUNCTIONS = @as(u32, 50);
pub const SQL_SYSTEM_FUNCTIONS = @as(u32, 51);
pub const SQL_TIMEDATE_FUNCTIONS = @as(u32, 52);
pub const SQL_CONVERT_BIGINT = @as(u32, 53);
pub const SQL_CONVERT_BINARY = @as(u32, 54);
pub const SQL_CONVERT_BIT = @as(u32, 55);
pub const SQL_CONVERT_CHAR = @as(u32, 56);
pub const SQL_CONVERT_DATE = @as(u32, 57);
pub const SQL_CONVERT_DECIMAL = @as(u32, 58);
pub const SQL_CONVERT_DOUBLE = @as(u32, 59);
pub const SQL_CONVERT_FLOAT = @as(u32, 60);
pub const SQL_CONVERT_INTEGER = @as(u32, 61);
pub const SQL_CONVERT_LONGVARCHAR = @as(u32, 62);
pub const SQL_CONVERT_NUMERIC = @as(u32, 63);
pub const SQL_CONVERT_REAL = @as(u32, 64);
pub const SQL_CONVERT_SMALLINT = @as(u32, 65);
pub const SQL_CONVERT_TIME = @as(u32, 66);
pub const SQL_CONVERT_TIMESTAMP = @as(u32, 67);
pub const SQL_CONVERT_TINYINT = @as(u32, 68);
pub const SQL_CONVERT_VARBINARY = @as(u32, 69);
pub const SQL_CONVERT_VARCHAR = @as(u32, 70);
pub const SQL_CONVERT_LONGVARBINARY = @as(u32, 71);
pub const SQL_ODBC_SQL_OPT_IEF = @as(u32, 73);
pub const SQL_CORRELATION_NAME = @as(u32, 74);
pub const SQL_NON_NULLABLE_COLUMNS = @as(u32, 75);
pub const SQL_DRIVER_HLIB = @as(u32, 76);
pub const SQL_DRIVER_ODBC_VER = @as(u32, 77);
pub const SQL_LOCK_TYPES = @as(u32, 78);
pub const SQL_POS_OPERATIONS = @as(u32, 79);
pub const SQL_POSITIONED_STATEMENTS = @as(u32, 80);
pub const SQL_BOOKMARK_PERSISTENCE = @as(u32, 82);
pub const SQL_STATIC_SENSITIVITY = @as(u32, 83);
pub const SQL_FILE_USAGE = @as(u32, 84);
pub const SQL_COLUMN_ALIAS = @as(u32, 87);
pub const SQL_GROUP_BY = @as(u32, 88);
pub const SQL_KEYWORDS = @as(u32, 89);
pub const SQL_OWNER_USAGE = @as(u32, 91);
pub const SQL_QUALIFIER_USAGE = @as(u32, 92);
pub const SQL_QUOTED_IDENTIFIER_CASE = @as(u32, 93);
pub const SQL_SUBQUERIES = @as(u32, 95);
pub const SQL_UNION = @as(u32, 96);
pub const SQL_MAX_ROW_SIZE_INCLUDES_LONG = @as(u32, 103);
pub const SQL_MAX_CHAR_LITERAL_LEN = @as(u32, 108);
pub const SQL_TIMEDATE_ADD_INTERVALS = @as(u32, 109);
pub const SQL_TIMEDATE_DIFF_INTERVALS = @as(u32, 110);
pub const SQL_NEED_LONG_DATA_LEN = @as(u32, 111);
pub const SQL_MAX_BINARY_LITERAL_LEN = @as(u32, 112);
pub const SQL_LIKE_ESCAPE_CLAUSE = @as(u32, 113);
pub const SQL_QUALIFIER_LOCATION = @as(u32, 114);
pub const SQL_INFO_LAST = @as(u32, 114);
pub const SQL_INFO_DRIVER_START = @as(u32, 1000);
pub const SQL_ACTIVE_ENVIRONMENTS = @as(u32, 116);
pub const SQL_ALTER_DOMAIN = @as(u32, 117);
pub const SQL_SQL_CONFORMANCE = @as(u32, 118);
pub const SQL_DATETIME_LITERALS = @as(u32, 119);
pub const SQL_ASYNC_MODE = @as(u32, 10021);
pub const SQL_BATCH_ROW_COUNT = @as(u32, 120);
pub const SQL_BATCH_SUPPORT = @as(u32, 121);
pub const SQL_CATALOG_LOCATION = @as(u32, 114);
pub const SQL_CATALOG_NAME_SEPARATOR = @as(u32, 41);
pub const SQL_CATALOG_TERM = @as(u32, 42);
pub const SQL_CATALOG_USAGE = @as(u32, 92);
pub const SQL_CONVERT_WCHAR = @as(u32, 122);
pub const SQL_CONVERT_INTERVAL_DAY_TIME = @as(u32, 123);
pub const SQL_CONVERT_INTERVAL_YEAR_MONTH = @as(u32, 124);
pub const SQL_CONVERT_WLONGVARCHAR = @as(u32, 125);
pub const SQL_CONVERT_WVARCHAR = @as(u32, 126);
pub const SQL_CREATE_ASSERTION = @as(u32, 127);
pub const SQL_CREATE_CHARACTER_SET = @as(u32, 128);
pub const SQL_CREATE_COLLATION = @as(u32, 129);
pub const SQL_CREATE_DOMAIN = @as(u32, 130);
pub const SQL_CREATE_SCHEMA = @as(u32, 131);
pub const SQL_CREATE_TABLE = @as(u32, 132);
pub const SQL_CREATE_TRANSLATION = @as(u32, 133);
pub const SQL_CREATE_VIEW = @as(u32, 134);
pub const SQL_DRIVER_HDESC = @as(u32, 135);
pub const SQL_DROP_ASSERTION = @as(u32, 136);
pub const SQL_DROP_CHARACTER_SET = @as(u32, 137);
pub const SQL_DROP_COLLATION = @as(u32, 138);
pub const SQL_DROP_DOMAIN = @as(u32, 139);
pub const SQL_DROP_SCHEMA = @as(u32, 140);
pub const SQL_DROP_TABLE = @as(u32, 141);
pub const SQL_DROP_TRANSLATION = @as(u32, 142);
pub const SQL_DROP_VIEW = @as(u32, 143);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES1 = @as(u32, 144);
pub const SQL_DYNAMIC_CURSOR_ATTRIBUTES2 = @as(u32, 145);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1 = @as(u32, 146);
pub const SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2 = @as(u32, 147);
pub const SQL_INDEX_KEYWORDS = @as(u32, 148);
pub const SQL_INFO_SCHEMA_VIEWS = @as(u32, 149);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES1 = @as(u32, 150);
pub const SQL_KEYSET_CURSOR_ATTRIBUTES2 = @as(u32, 151);
pub const SQL_MAX_ASYNC_CONCURRENT_STATEMENTS = @as(u32, 10022);
pub const SQL_ODBC_INTERFACE_CONFORMANCE = @as(u32, 152);
pub const SQL_PARAM_ARRAY_ROW_COUNTS = @as(u32, 153);
pub const SQL_PARAM_ARRAY_SELECTS = @as(u32, 154);
pub const SQL_SCHEMA_TERM = @as(u32, 39);
pub const SQL_SCHEMA_USAGE = @as(u32, 91);
pub const SQL_SQL92_DATETIME_FUNCTIONS = @as(u32, 155);
pub const SQL_SQL92_FOREIGN_KEY_DELETE_RULE = @as(u32, 156);
pub const SQL_SQL92_FOREIGN_KEY_UPDATE_RULE = @as(u32, 157);
pub const SQL_SQL92_GRANT = @as(u32, 158);
pub const SQL_SQL92_NUMERIC_VALUE_FUNCTIONS = @as(u32, 159);
pub const SQL_SQL92_PREDICATES = @as(u32, 160);
pub const SQL_SQL92_RELATIONAL_JOIN_OPERATORS = @as(u32, 161);
pub const SQL_SQL92_REVOKE = @as(u32, 162);
pub const SQL_SQL92_ROW_VALUE_CONSTRUCTOR = @as(u32, 163);
pub const SQL_SQL92_STRING_FUNCTIONS = @as(u32, 164);
pub const SQL_SQL92_VALUE_EXPRESSIONS = @as(u32, 165);
pub const SQL_STANDARD_CLI_CONFORMANCE = @as(u32, 166);
pub const SQL_STATIC_CURSOR_ATTRIBUTES1 = @as(u32, 167);
pub const SQL_STATIC_CURSOR_ATTRIBUTES2 = @as(u32, 168);
pub const SQL_AGGREGATE_FUNCTIONS = @as(u32, 169);
pub const SQL_DDL_INDEX = @as(u32, 170);
pub const SQL_DM_VER = @as(u32, 171);
pub const SQL_INSERT_STATEMENT = @as(u32, 172);
pub const SQL_CONVERT_GUID = @as(u32, 173);
pub const SQL_UNION_STATEMENT = @as(u32, 96);
pub const SQL_ASYNC_DBC_FUNCTIONS = @as(u32, 10023);
pub const SQL_DRIVER_AWARE_POOLING_SUPPORTED = @as(u32, 10024);
pub const SQL_ASYNC_NOTIFICATION = @as(u32, 10025);
pub const SQL_ASYNC_NOTIFICATION_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_NOTIFICATION_CAPABLE = @as(i32, 1);
pub const SQL_DTC_TRANSITION_COST = @as(u32, 1750);
pub const SQL_AT_ADD_COLUMN_SINGLE = @as(i32, 32);
pub const SQL_AT_ADD_COLUMN_DEFAULT = @as(i32, 64);
pub const SQL_AT_ADD_COLUMN_COLLATION = @as(i32, 128);
pub const SQL_AT_SET_COLUMN_DEFAULT = @as(i32, 256);
pub const SQL_AT_DROP_COLUMN_DEFAULT = @as(i32, 512);
pub const SQL_AT_DROP_COLUMN_CASCADE = @as(i32, 1024);
pub const SQL_AT_DROP_COLUMN_RESTRICT = @as(i32, 2048);
pub const SQL_AT_ADD_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE = @as(i32, 8192);
pub const SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT = @as(i32, 16384);
pub const SQL_AT_CONSTRAINT_NAME_DEFINITION = @as(i32, 32768);
pub const SQL_AT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 65536);
pub const SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 131072);
pub const SQL_AT_CONSTRAINT_DEFERRABLE = @as(i32, 262144);
pub const SQL_AT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 524288);
pub const SQL_CVT_CHAR = @as(i32, 1);
pub const SQL_CVT_NUMERIC = @as(i32, 2);
pub const SQL_CVT_DECIMAL = @as(i32, 4);
pub const SQL_CVT_INTEGER = @as(i32, 8);
pub const SQL_CVT_SMALLINT = @as(i32, 16);
pub const SQL_CVT_FLOAT = @as(i32, 32);
pub const SQL_CVT_REAL = @as(i32, 64);
pub const SQL_CVT_DOUBLE = @as(i32, 128);
pub const SQL_CVT_VARCHAR = @as(i32, 256);
pub const SQL_CVT_LONGVARCHAR = @as(i32, 512);
pub const SQL_CVT_BINARY = @as(i32, 1024);
pub const SQL_CVT_VARBINARY = @as(i32, 2048);
pub const SQL_CVT_BIT = @as(i32, 4096);
pub const SQL_CVT_TINYINT = @as(i32, 8192);
pub const SQL_CVT_BIGINT = @as(i32, 16384);
pub const SQL_CVT_DATE = @as(i32, 32768);
pub const SQL_CVT_TIME = @as(i32, 65536);
pub const SQL_CVT_TIMESTAMP = @as(i32, 131072);
pub const SQL_CVT_LONGVARBINARY = @as(i32, 262144);
pub const SQL_CVT_INTERVAL_YEAR_MONTH = @as(i32, 524288);
pub const SQL_CVT_INTERVAL_DAY_TIME = @as(i32, 1048576);
pub const SQL_CVT_WCHAR = @as(i32, 2097152);
pub const SQL_CVT_WLONGVARCHAR = @as(i32, 4194304);
pub const SQL_CVT_WVARCHAR = @as(i32, 8388608);
pub const SQL_CVT_GUID = @as(i32, 16777216);
pub const SQL_FN_CVT_CONVERT = @as(i32, 1);
pub const SQL_FN_CVT_CAST = @as(i32, 2);
pub const SQL_FN_STR_CONCAT = @as(i32, 1);
pub const SQL_FN_STR_INSERT = @as(i32, 2);
pub const SQL_FN_STR_LEFT = @as(i32, 4);
pub const SQL_FN_STR_LTRIM = @as(i32, 8);
pub const SQL_FN_STR_LENGTH = @as(i32, 16);
pub const SQL_FN_STR_LOCATE = @as(i32, 32);
pub const SQL_FN_STR_LCASE = @as(i32, 64);
pub const SQL_FN_STR_REPEAT = @as(i32, 128);
pub const SQL_FN_STR_REPLACE = @as(i32, 256);
pub const SQL_FN_STR_RIGHT = @as(i32, 512);
pub const SQL_FN_STR_RTRIM = @as(i32, 1024);
pub const SQL_FN_STR_SUBSTRING = @as(i32, 2048);
pub const SQL_FN_STR_UCASE = @as(i32, 4096);
pub const SQL_FN_STR_ASCII = @as(i32, 8192);
pub const SQL_FN_STR_CHAR = @as(i32, 16384);
pub const SQL_FN_STR_DIFFERENCE = @as(i32, 32768);
pub const SQL_FN_STR_LOCATE_2 = @as(i32, 65536);
pub const SQL_FN_STR_SOUNDEX = @as(i32, 131072);
pub const SQL_FN_STR_SPACE = @as(i32, 262144);
pub const SQL_FN_STR_BIT_LENGTH = @as(i32, 524288);
pub const SQL_FN_STR_CHAR_LENGTH = @as(i32, 1048576);
pub const SQL_FN_STR_CHARACTER_LENGTH = @as(i32, 2097152);
pub const SQL_FN_STR_OCTET_LENGTH = @as(i32, 4194304);
pub const SQL_FN_STR_POSITION = @as(i32, 8388608);
pub const SQL_SSF_CONVERT = @as(i32, 1);
pub const SQL_SSF_LOWER = @as(i32, 2);
pub const SQL_SSF_UPPER = @as(i32, 4);
pub const SQL_SSF_SUBSTRING = @as(i32, 8);
pub const SQL_SSF_TRANSLATE = @as(i32, 16);
pub const SQL_SSF_TRIM_BOTH = @as(i32, 32);
pub const SQL_SSF_TRIM_LEADING = @as(i32, 64);
pub const SQL_SSF_TRIM_TRAILING = @as(i32, 128);
pub const SQL_FN_NUM_ABS = @as(i32, 1);
pub const SQL_FN_NUM_ACOS = @as(i32, 2);
pub const SQL_FN_NUM_ASIN = @as(i32, 4);
pub const SQL_FN_NUM_ATAN = @as(i32, 8);
pub const SQL_FN_NUM_ATAN2 = @as(i32, 16);
pub const SQL_FN_NUM_CEILING = @as(i32, 32);
pub const SQL_FN_NUM_COS = @as(i32, 64);
pub const SQL_FN_NUM_COT = @as(i32, 128);
pub const SQL_FN_NUM_EXP = @as(i32, 256);
pub const SQL_FN_NUM_FLOOR = @as(i32, 512);
pub const SQL_FN_NUM_LOG = @as(i32, 1024);
pub const SQL_FN_NUM_MOD = @as(i32, 2048);
pub const SQL_FN_NUM_SIGN = @as(i32, 4096);
pub const SQL_FN_NUM_SIN = @as(i32, 8192);
pub const SQL_FN_NUM_SQRT = @as(i32, 16384);
pub const SQL_FN_NUM_TAN = @as(i32, 32768);
pub const SQL_FN_NUM_PI = @as(i32, 65536);
pub const SQL_FN_NUM_RAND = @as(i32, 131072);
pub const SQL_FN_NUM_DEGREES = @as(i32, 262144);
pub const SQL_FN_NUM_LOG10 = @as(i32, 524288);
pub const SQL_FN_NUM_POWER = @as(i32, 1048576);
pub const SQL_FN_NUM_RADIANS = @as(i32, 2097152);
pub const SQL_FN_NUM_ROUND = @as(i32, 4194304);
pub const SQL_FN_NUM_TRUNCATE = @as(i32, 8388608);
pub const SQL_SNVF_BIT_LENGTH = @as(i32, 1);
pub const SQL_SNVF_CHAR_LENGTH = @as(i32, 2);
pub const SQL_SNVF_CHARACTER_LENGTH = @as(i32, 4);
pub const SQL_SNVF_EXTRACT = @as(i32, 8);
pub const SQL_SNVF_OCTET_LENGTH = @as(i32, 16);
pub const SQL_SNVF_POSITION = @as(i32, 32);
pub const SQL_FN_TD_NOW = @as(i32, 1);
pub const SQL_FN_TD_CURDATE = @as(i32, 2);
pub const SQL_FN_TD_DAYOFMONTH = @as(i32, 4);
pub const SQL_FN_TD_DAYOFWEEK = @as(i32, 8);
pub const SQL_FN_TD_DAYOFYEAR = @as(i32, 16);
pub const SQL_FN_TD_MONTH = @as(i32, 32);
pub const SQL_FN_TD_QUARTER = @as(i32, 64);
pub const SQL_FN_TD_WEEK = @as(i32, 128);
pub const SQL_FN_TD_YEAR = @as(i32, 256);
pub const SQL_FN_TD_CURTIME = @as(i32, 512);
pub const SQL_FN_TD_HOUR = @as(i32, 1024);
pub const SQL_FN_TD_MINUTE = @as(i32, 2048);
pub const SQL_FN_TD_SECOND = @as(i32, 4096);
pub const SQL_FN_TD_TIMESTAMPADD = @as(i32, 8192);
pub const SQL_FN_TD_TIMESTAMPDIFF = @as(i32, 16384);
pub const SQL_FN_TD_DAYNAME = @as(i32, 32768);
pub const SQL_FN_TD_MONTHNAME = @as(i32, 65536);
pub const SQL_FN_TD_CURRENT_DATE = @as(i32, 131072);
pub const SQL_FN_TD_CURRENT_TIME = @as(i32, 262144);
pub const SQL_FN_TD_CURRENT_TIMESTAMP = @as(i32, 524288);
pub const SQL_FN_TD_EXTRACT = @as(i32, 1048576);
pub const SQL_SDF_CURRENT_DATE = @as(i32, 1);
pub const SQL_SDF_CURRENT_TIME = @as(i32, 2);
pub const SQL_SDF_CURRENT_TIMESTAMP = @as(i32, 4);
pub const SQL_FN_SYS_USERNAME = @as(i32, 1);
pub const SQL_FN_SYS_DBNAME = @as(i32, 2);
pub const SQL_FN_SYS_IFNULL = @as(i32, 4);
pub const SQL_FN_TSI_FRAC_SECOND = @as(i32, 1);
pub const SQL_FN_TSI_SECOND = @as(i32, 2);
pub const SQL_FN_TSI_MINUTE = @as(i32, 4);
pub const SQL_FN_TSI_HOUR = @as(i32, 8);
pub const SQL_FN_TSI_DAY = @as(i32, 16);
pub const SQL_FN_TSI_WEEK = @as(i32, 32);
pub const SQL_FN_TSI_MONTH = @as(i32, 64);
pub const SQL_FN_TSI_QUARTER = @as(i32, 128);
pub const SQL_FN_TSI_YEAR = @as(i32, 256);
pub const SQL_CA1_NEXT = @as(i32, 1);
pub const SQL_CA1_ABSOLUTE = @as(i32, 2);
pub const SQL_CA1_RELATIVE = @as(i32, 4);
pub const SQL_CA1_BOOKMARK = @as(i32, 8);
pub const SQL_CA1_LOCK_NO_CHANGE = @as(i32, 64);
pub const SQL_CA1_LOCK_EXCLUSIVE = @as(i32, 128);
pub const SQL_CA1_LOCK_UNLOCK = @as(i32, 256);
pub const SQL_CA1_POS_POSITION = @as(i32, 512);
pub const SQL_CA1_POS_UPDATE = @as(i32, 1024);
pub const SQL_CA1_POS_DELETE = @as(i32, 2048);
pub const SQL_CA1_POS_REFRESH = @as(i32, 4096);
pub const SQL_CA1_POSITIONED_UPDATE = @as(i32, 8192);
pub const SQL_CA1_POSITIONED_DELETE = @as(i32, 16384);
pub const SQL_CA1_SELECT_FOR_UPDATE = @as(i32, 32768);
pub const SQL_CA1_BULK_ADD = @as(i32, 65536);
pub const SQL_CA1_BULK_UPDATE_BY_BOOKMARK = @as(i32, 131072);
pub const SQL_CA1_BULK_DELETE_BY_BOOKMARK = @as(i32, 262144);
pub const SQL_CA1_BULK_FETCH_BY_BOOKMARK = @as(i32, 524288);
pub const SQL_CA2_READ_ONLY_CONCURRENCY = @as(i32, 1);
pub const SQL_CA2_LOCK_CONCURRENCY = @as(i32, 2);
pub const SQL_CA2_OPT_ROWVER_CONCURRENCY = @as(i32, 4);
pub const SQL_CA2_OPT_VALUES_CONCURRENCY = @as(i32, 8);
pub const SQL_CA2_SENSITIVITY_ADDITIONS = @as(i32, 16);
pub const SQL_CA2_SENSITIVITY_DELETIONS = @as(i32, 32);
pub const SQL_CA2_SENSITIVITY_UPDATES = @as(i32, 64);
pub const SQL_CA2_MAX_ROWS_SELECT = @as(i32, 128);
pub const SQL_CA2_MAX_ROWS_INSERT = @as(i32, 256);
pub const SQL_CA2_MAX_ROWS_DELETE = @as(i32, 512);
pub const SQL_CA2_MAX_ROWS_UPDATE = @as(i32, 1024);
pub const SQL_CA2_MAX_ROWS_CATALOG = @as(i32, 2048);
pub const SQL_CA2_CRC_EXACT = @as(i32, 4096);
pub const SQL_CA2_CRC_APPROXIMATE = @as(i32, 8192);
pub const SQL_CA2_SIMULATE_NON_UNIQUE = @as(i32, 16384);
pub const SQL_CA2_SIMULATE_TRY_UNIQUE = @as(i32, 32768);
pub const SQL_CA2_SIMULATE_UNIQUE = @as(i32, 65536);
pub const SQL_OAC_NONE = @as(u32, 0);
pub const SQL_OAC_LEVEL1 = @as(u32, 1);
pub const SQL_OAC_LEVEL2 = @as(u32, 2);
pub const SQL_OSCC_NOT_COMPLIANT = @as(u32, 0);
pub const SQL_OSCC_COMPLIANT = @as(u32, 1);
pub const SQL_OSC_MINIMUM = @as(u32, 0);
pub const SQL_OSC_CORE = @as(u32, 1);
pub const SQL_OSC_EXTENDED = @as(u32, 2);
pub const SQL_CB_NULL = @as(u32, 0);
pub const SQL_CB_NON_NULL = @as(u32, 1);
pub const SQL_SO_FORWARD_ONLY = @as(i32, 1);
pub const SQL_SO_KEYSET_DRIVEN = @as(i32, 2);
pub const SQL_SO_DYNAMIC = @as(i32, 4);
pub const SQL_SO_MIXED = @as(i32, 8);
pub const SQL_SO_STATIC = @as(i32, 16);
pub const SQL_FD_FETCH_RESUME = @as(i32, 64);
pub const SQL_FD_FETCH_BOOKMARK = @as(i32, 128);
pub const SQL_TXN_VERSIONING = @as(i32, 16);
pub const SQL_CN_NONE = @as(u32, 0);
pub const SQL_CN_DIFFERENT = @as(u32, 1);
pub const SQL_CN_ANY = @as(u32, 2);
pub const SQL_NNC_NULL = @as(u32, 0);
pub const SQL_NNC_NON_NULL = @as(u32, 1);
pub const SQL_NC_START = @as(u32, 2);
pub const SQL_NC_END = @as(u32, 4);
pub const SQL_FILE_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_FILE_TABLE = @as(u32, 1);
pub const SQL_FILE_QUALIFIER = @as(u32, 2);
pub const SQL_FILE_CATALOG = @as(u32, 2);
pub const SQL_GD_BLOCK = @as(i32, 4);
pub const SQL_GD_BOUND = @as(i32, 8);
pub const SQL_GD_OUTPUT_PARAMS = @as(i32, 16);
pub const SQL_PS_POSITIONED_DELETE = @as(i32, 1);
pub const SQL_PS_POSITIONED_UPDATE = @as(i32, 2);
pub const SQL_PS_SELECT_FOR_UPDATE = @as(i32, 4);
pub const SQL_GB_NOT_SUPPORTED = @as(u32, 0);
pub const SQL_GB_GROUP_BY_EQUALS_SELECT = @as(u32, 1);
pub const SQL_GB_GROUP_BY_CONTAINS_SELECT = @as(u32, 2);
pub const SQL_GB_NO_RELATION = @as(u32, 3);
pub const SQL_GB_COLLATE = @as(u32, 4);
pub const SQL_OU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_OU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_OU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_OU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_OU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_SU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_SU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_SU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_SU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_QU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_QU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_QU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_QU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_QU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_CU_DML_STATEMENTS = @as(i32, 1);
pub const SQL_CU_PROCEDURE_INVOCATION = @as(i32, 2);
pub const SQL_CU_TABLE_DEFINITION = @as(i32, 4);
pub const SQL_CU_INDEX_DEFINITION = @as(i32, 8);
pub const SQL_CU_PRIVILEGE_DEFINITION = @as(i32, 16);
pub const SQL_SQ_COMPARISON = @as(i32, 1);
pub const SQL_SQ_EXISTS = @as(i32, 2);
pub const SQL_SQ_IN = @as(i32, 4);
pub const SQL_SQ_QUANTIFIED = @as(i32, 8);
pub const SQL_SQ_CORRELATED_SUBQUERIES = @as(i32, 16);
pub const SQL_U_UNION = @as(i32, 1);
pub const SQL_U_UNION_ALL = @as(i32, 2);
pub const SQL_BP_CLOSE = @as(i32, 1);
pub const SQL_BP_DELETE = @as(i32, 2);
pub const SQL_BP_DROP = @as(i32, 4);
pub const SQL_BP_TRANSACTION = @as(i32, 8);
pub const SQL_BP_UPDATE = @as(i32, 16);
pub const SQL_BP_OTHER_HSTMT = @as(i32, 32);
pub const SQL_BP_SCROLL = @as(i32, 64);
pub const SQL_SS_ADDITIONS = @as(i32, 1);
pub const SQL_SS_DELETIONS = @as(i32, 2);
pub const SQL_SS_UPDATES = @as(i32, 4);
pub const SQL_CV_CREATE_VIEW = @as(i32, 1);
pub const SQL_CV_CHECK_OPTION = @as(i32, 2);
pub const SQL_CV_CASCADED = @as(i32, 4);
pub const SQL_CV_LOCAL = @as(i32, 8);
pub const SQL_LCK_NO_CHANGE = @as(i32, 1);
pub const SQL_LCK_EXCLUSIVE = @as(i32, 2);
pub const SQL_LCK_UNLOCK = @as(i32, 4);
pub const SQL_POS_POSITION = @as(i32, 1);
pub const SQL_POS_REFRESH = @as(i32, 2);
pub const SQL_POS_UPDATE = @as(i32, 4);
pub const SQL_POS_DELETE = @as(i32, 8);
pub const SQL_POS_ADD = @as(i32, 16);
pub const SQL_QL_START = @as(u32, 1);
pub const SQL_QL_END = @as(u32, 2);
pub const SQL_AF_AVG = @as(i32, 1);
pub const SQL_AF_COUNT = @as(i32, 2);
pub const SQL_AF_MAX = @as(i32, 4);
pub const SQL_AF_MIN = @as(i32, 8);
pub const SQL_AF_SUM = @as(i32, 16);
pub const SQL_AF_DISTINCT = @as(i32, 32);
pub const SQL_AF_ALL = @as(i32, 64);
pub const SQL_SC_SQL92_ENTRY = @as(i32, 1);
pub const SQL_SC_FIPS127_2_TRANSITIONAL = @as(i32, 2);
pub const SQL_SC_SQL92_INTERMEDIATE = @as(i32, 4);
pub const SQL_SC_SQL92_FULL = @as(i32, 8);
pub const SQL_DL_SQL92_DATE = @as(i32, 1);
pub const SQL_DL_SQL92_TIME = @as(i32, 2);
pub const SQL_DL_SQL92_TIMESTAMP = @as(i32, 4);
pub const SQL_DL_SQL92_INTERVAL_YEAR = @as(i32, 8);
pub const SQL_DL_SQL92_INTERVAL_MONTH = @as(i32, 16);
pub const SQL_DL_SQL92_INTERVAL_DAY = @as(i32, 32);
pub const SQL_DL_SQL92_INTERVAL_HOUR = @as(i32, 64);
pub const SQL_DL_SQL92_INTERVAL_MINUTE = @as(i32, 128);
pub const SQL_DL_SQL92_INTERVAL_SECOND = @as(i32, 256);
pub const SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH = @as(i32, 512);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR = @as(i32, 1024);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE = @as(i32, 2048);
pub const SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND = @as(i32, 4096);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE = @as(i32, 8192);
pub const SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND = @as(i32, 16384);
pub const SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND = @as(i32, 32768);
pub const SQL_CL_START = @as(u32, 1);
pub const SQL_CL_END = @as(u32, 2);
pub const SQL_BRC_PROCEDURES = @as(u32, 1);
pub const SQL_BRC_EXPLICIT = @as(u32, 2);
pub const SQL_BRC_ROLLED_UP = @as(u32, 4);
pub const SQL_BS_SELECT_EXPLICIT = @as(i32, 1);
pub const SQL_BS_ROW_COUNT_EXPLICIT = @as(i32, 2);
pub const SQL_BS_SELECT_PROC = @as(i32, 4);
pub const SQL_BS_ROW_COUNT_PROC = @as(i32, 8);
pub const SQL_PARC_BATCH = @as(u32, 1);
pub const SQL_PARC_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_BATCH = @as(u32, 1);
pub const SQL_PAS_NO_BATCH = @as(u32, 2);
pub const SQL_PAS_NO_SELECT = @as(u32, 3);
pub const SQL_IK_NONE = @as(i32, 0);
pub const SQL_IK_ASC = @as(i32, 1);
pub const SQL_IK_DESC = @as(i32, 2);
pub const SQL_ISV_ASSERTIONS = @as(i32, 1);
pub const SQL_ISV_CHARACTER_SETS = @as(i32, 2);
pub const SQL_ISV_CHECK_CONSTRAINTS = @as(i32, 4);
pub const SQL_ISV_COLLATIONS = @as(i32, 8);
pub const SQL_ISV_COLUMN_DOMAIN_USAGE = @as(i32, 16);
pub const SQL_ISV_COLUMN_PRIVILEGES = @as(i32, 32);
pub const SQL_ISV_COLUMNS = @as(i32, 64);
pub const SQL_ISV_CONSTRAINT_COLUMN_USAGE = @as(i32, 128);
pub const SQL_ISV_CONSTRAINT_TABLE_USAGE = @as(i32, 256);
pub const SQL_ISV_DOMAIN_CONSTRAINTS = @as(i32, 512);
pub const SQL_ISV_DOMAINS = @as(i32, 1024);
pub const SQL_ISV_KEY_COLUMN_USAGE = @as(i32, 2048);
pub const SQL_ISV_REFERENTIAL_CONSTRAINTS = @as(i32, 4096);
pub const SQL_ISV_SCHEMATA = @as(i32, 8192);
pub const SQL_ISV_SQL_LANGUAGES = @as(i32, 16384);
pub const SQL_ISV_TABLE_CONSTRAINTS = @as(i32, 32768);
pub const SQL_ISV_TABLE_PRIVILEGES = @as(i32, 65536);
pub const SQL_ISV_TABLES = @as(i32, 131072);
pub const SQL_ISV_TRANSLATIONS = @as(i32, 262144);
pub const SQL_ISV_USAGE_PRIVILEGES = @as(i32, 524288);
pub const SQL_ISV_VIEW_COLUMN_USAGE = @as(i32, 1048576);
pub const SQL_ISV_VIEW_TABLE_USAGE = @as(i32, 2097152);
pub const SQL_ISV_VIEWS = @as(i32, 4194304);
pub const SQL_AD_CONSTRAINT_NAME_DEFINITION = @as(i32, 1);
pub const SQL_AD_ADD_DOMAIN_CONSTRAINT = @as(i32, 2);
pub const SQL_AD_DROP_DOMAIN_CONSTRAINT = @as(i32, 4);
pub const SQL_AD_ADD_DOMAIN_DEFAULT = @as(i32, 8);
pub const SQL_AD_DROP_DOMAIN_DEFAULT = @as(i32, 16);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_AD_ADD_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CS_CREATE_SCHEMA = @as(i32, 1);
pub const SQL_CS_AUTHORIZATION = @as(i32, 2);
pub const SQL_CS_DEFAULT_CHARACTER_SET = @as(i32, 4);
pub const SQL_CTR_CREATE_TRANSLATION = @as(i32, 1);
pub const SQL_CA_CREATE_ASSERTION = @as(i32, 1);
pub const SQL_CA_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 16);
pub const SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 32);
pub const SQL_CA_CONSTRAINT_DEFERRABLE = @as(i32, 64);
pub const SQL_CA_CONSTRAINT_NON_DEFERRABLE = @as(i32, 128);
pub const SQL_CCS_CREATE_CHARACTER_SET = @as(i32, 1);
pub const SQL_CCS_COLLATE_CLAUSE = @as(i32, 2);
pub const SQL_CCS_LIMITED_COLLATION = @as(i32, 4);
pub const SQL_CCOL_CREATE_COLLATION = @as(i32, 1);
pub const SQL_CDO_CREATE_DOMAIN = @as(i32, 1);
pub const SQL_CDO_DEFAULT = @as(i32, 2);
pub const SQL_CDO_CONSTRAINT = @as(i32, 4);
pub const SQL_CDO_COLLATION = @as(i32, 8);
pub const SQL_CDO_CONSTRAINT_NAME_DEFINITION = @as(i32, 16);
pub const SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CDO_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CDO_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_CREATE_TABLE = @as(i32, 1);
pub const SQL_CT_COMMIT_PRESERVE = @as(i32, 2);
pub const SQL_CT_COMMIT_DELETE = @as(i32, 4);
pub const SQL_CT_GLOBAL_TEMPORARY = @as(i32, 8);
pub const SQL_CT_LOCAL_TEMPORARY = @as(i32, 16);
pub const SQL_CT_CONSTRAINT_INITIALLY_DEFERRED = @as(i32, 32);
pub const SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE = @as(i32, 64);
pub const SQL_CT_CONSTRAINT_DEFERRABLE = @as(i32, 128);
pub const SQL_CT_CONSTRAINT_NON_DEFERRABLE = @as(i32, 256);
pub const SQL_CT_COLUMN_CONSTRAINT = @as(i32, 512);
pub const SQL_CT_COLUMN_DEFAULT = @as(i32, 1024);
pub const SQL_CT_COLUMN_COLLATION = @as(i32, 2048);
pub const SQL_CT_TABLE_CONSTRAINT = @as(i32, 4096);
pub const SQL_CT_CONSTRAINT_NAME_DEFINITION = @as(i32, 8192);
pub const SQL_DI_CREATE_INDEX = @as(i32, 1);
pub const SQL_DI_DROP_INDEX = @as(i32, 2);
pub const SQL_DC_DROP_COLLATION = @as(i32, 1);
pub const SQL_DD_DROP_DOMAIN = @as(i32, 1);
pub const SQL_DD_RESTRICT = @as(i32, 2);
pub const SQL_DD_CASCADE = @as(i32, 4);
pub const SQL_DS_DROP_SCHEMA = @as(i32, 1);
pub const SQL_DS_RESTRICT = @as(i32, 2);
pub const SQL_DS_CASCADE = @as(i32, 4);
pub const SQL_DCS_DROP_CHARACTER_SET = @as(i32, 1);
pub const SQL_DA_DROP_ASSERTION = @as(i32, 1);
pub const SQL_DT_DROP_TABLE = @as(i32, 1);
pub const SQL_DT_RESTRICT = @as(i32, 2);
pub const SQL_DT_CASCADE = @as(i32, 4);
pub const SQL_DTR_DROP_TRANSLATION = @as(i32, 1);
pub const SQL_DV_DROP_VIEW = @as(i32, 1);
pub const SQL_DV_RESTRICT = @as(i32, 2);
pub const SQL_DV_CASCADE = @as(i32, 4);
pub const SQL_IS_INSERT_LITERALS = @as(i32, 1);
pub const SQL_IS_INSERT_SEARCHED = @as(i32, 2);
pub const SQL_IS_SELECT_INTO = @as(i32, 4);
pub const SQL_OIC_CORE = @as(u32, 1);
pub const SQL_OIC_LEVEL1 = @as(u32, 2);
pub const SQL_OIC_LEVEL2 = @as(u32, 3);
pub const SQL_SFKD_CASCADE = @as(i32, 1);
pub const SQL_SFKD_NO_ACTION = @as(i32, 2);
pub const SQL_SFKD_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKD_SET_NULL = @as(i32, 8);
pub const SQL_SFKU_CASCADE = @as(i32, 1);
pub const SQL_SFKU_NO_ACTION = @as(i32, 2);
pub const SQL_SFKU_SET_DEFAULT = @as(i32, 4);
pub const SQL_SFKU_SET_NULL = @as(i32, 8);
pub const SQL_SG_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SG_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SG_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SG_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SG_WITH_GRANT_OPTION = @as(i32, 16);
pub const SQL_SG_DELETE_TABLE = @as(i32, 32);
pub const SQL_SG_INSERT_TABLE = @as(i32, 64);
pub const SQL_SG_INSERT_COLUMN = @as(i32, 128);
pub const SQL_SG_REFERENCES_TABLE = @as(i32, 256);
pub const SQL_SG_REFERENCES_COLUMN = @as(i32, 512);
pub const SQL_SG_SELECT_TABLE = @as(i32, 1024);
pub const SQL_SG_UPDATE_TABLE = @as(i32, 2048);
pub const SQL_SG_UPDATE_COLUMN = @as(i32, 4096);
pub const SQL_SP_EXISTS = @as(i32, 1);
pub const SQL_SP_ISNOTNULL = @as(i32, 2);
pub const SQL_SP_ISNULL = @as(i32, 4);
pub const SQL_SP_MATCH_FULL = @as(i32, 8);
pub const SQL_SP_MATCH_PARTIAL = @as(i32, 16);
pub const SQL_SP_MATCH_UNIQUE_FULL = @as(i32, 32);
pub const SQL_SP_MATCH_UNIQUE_PARTIAL = @as(i32, 64);
pub const SQL_SP_OVERLAPS = @as(i32, 128);
pub const SQL_SP_UNIQUE = @as(i32, 256);
pub const SQL_SP_LIKE = @as(i32, 512);
pub const SQL_SP_IN = @as(i32, 1024);
pub const SQL_SP_BETWEEN = @as(i32, 2048);
pub const SQL_SP_COMPARISON = @as(i32, 4096);
pub const SQL_SP_QUANTIFIED_COMPARISON = @as(i32, 8192);
pub const SQL_SRJO_CORRESPONDING_CLAUSE = @as(i32, 1);
pub const SQL_SRJO_CROSS_JOIN = @as(i32, 2);
pub const SQL_SRJO_EXCEPT_JOIN = @as(i32, 4);
pub const SQL_SRJO_FULL_OUTER_JOIN = @as(i32, 8);
pub const SQL_SRJO_INNER_JOIN = @as(i32, 16);
pub const SQL_SRJO_INTERSECT_JOIN = @as(i32, 32);
pub const SQL_SRJO_LEFT_OUTER_JOIN = @as(i32, 64);
pub const SQL_SRJO_NATURAL_JOIN = @as(i32, 128);
pub const SQL_SRJO_RIGHT_OUTER_JOIN = @as(i32, 256);
pub const SQL_SRJO_UNION_JOIN = @as(i32, 512);
pub const SQL_SR_USAGE_ON_DOMAIN = @as(i32, 1);
pub const SQL_SR_USAGE_ON_CHARACTER_SET = @as(i32, 2);
pub const SQL_SR_USAGE_ON_COLLATION = @as(i32, 4);
pub const SQL_SR_USAGE_ON_TRANSLATION = @as(i32, 8);
pub const SQL_SR_GRANT_OPTION_FOR = @as(i32, 16);
pub const SQL_SR_CASCADE = @as(i32, 32);
pub const SQL_SR_RESTRICT = @as(i32, 64);
pub const SQL_SR_DELETE_TABLE = @as(i32, 128);
pub const SQL_SR_INSERT_TABLE = @as(i32, 256);
pub const SQL_SR_INSERT_COLUMN = @as(i32, 512);
pub const SQL_SR_REFERENCES_TABLE = @as(i32, 1024);
pub const SQL_SR_REFERENCES_COLUMN = @as(i32, 2048);
pub const SQL_SR_SELECT_TABLE = @as(i32, 4096);
pub const SQL_SR_UPDATE_TABLE = @as(i32, 8192);
pub const SQL_SR_UPDATE_COLUMN = @as(i32, 16384);
pub const SQL_SRVC_VALUE_EXPRESSION = @as(i32, 1);
pub const SQL_SRVC_NULL = @as(i32, 2);
pub const SQL_SRVC_DEFAULT = @as(i32, 4);
pub const SQL_SRVC_ROW_SUBQUERY = @as(i32, 8);
pub const SQL_SVE_CASE = @as(i32, 1);
pub const SQL_SVE_CAST = @as(i32, 2);
pub const SQL_SVE_COALESCE = @as(i32, 4);
pub const SQL_SVE_NULLIF = @as(i32, 8);
pub const SQL_SCC_XOPEN_CLI_VERSION1 = @as(i32, 1);
pub const SQL_SCC_ISO92_CLI = @as(i32, 2);
pub const SQL_US_UNION = @as(i32, 1);
pub const SQL_US_UNION_ALL = @as(i32, 2);
pub const SQL_DRIVER_AWARE_POOLING_NOT_CAPABLE = @as(i32, 0);
pub const SQL_DRIVER_AWARE_POOLING_CAPABLE = @as(i32, 1);
pub const SQL_DTC_ENLIST_EXPENSIVE = @as(i32, 1);
pub const SQL_DTC_UNENLIST_EXPENSIVE = @as(i32, 2);
pub const SQL_ASYNC_DBC_NOT_CAPABLE = @as(i32, 0);
pub const SQL_ASYNC_DBC_CAPABLE = @as(i32, 1);
pub const SQL_FETCH_FIRST_USER = @as(u32, 31);
pub const SQL_FETCH_FIRST_SYSTEM = @as(u32, 32);
pub const SQL_ENTIRE_ROWSET = @as(u32, 0);
pub const SQL_POSITION = @as(u32, 0);
pub const SQL_REFRESH = @as(u32, 1);
pub const SQL_UPDATE = @as(u32, 2);
pub const SQL_DELETE = @as(u32, 3);
pub const SQL_ADD = @as(u32, 4);
pub const SQL_SETPOS_MAX_OPTION_VALUE = @as(u32, 4);
pub const SQL_UPDATE_BY_BOOKMARK = @as(u32, 5);
pub const SQL_DELETE_BY_BOOKMARK = @as(u32, 6);
pub const SQL_FETCH_BY_BOOKMARK = @as(u32, 7);
pub const SQL_LOCK_NO_CHANGE = @as(u32, 0);
pub const SQL_LOCK_EXCLUSIVE = @as(u32, 1);
pub const SQL_LOCK_UNLOCK = @as(u32, 2);
pub const SQL_SETPOS_MAX_LOCK_VALUE = @as(u32, 2);
pub const SQL_BEST_ROWID = @as(u32, 1);
pub const SQL_ROWVER = @as(u32, 2);
pub const SQL_PC_NOT_PSEUDO = @as(u32, 1);
pub const SQL_QUICK = @as(u32, 0);
pub const SQL_ENSURE = @as(u32, 1);
pub const SQL_TABLE_STAT = @as(u32, 0);
pub const SQL_ALL_CATALOGS = "%";
pub const SQL_ALL_SCHEMAS = "%";
pub const SQL_ALL_TABLE_TYPES = "%";
pub const SQL_DRIVER_NOPROMPT = @as(u32, 0);
pub const SQL_DRIVER_COMPLETE = @as(u32, 1);
pub const SQL_DRIVER_PROMPT = @as(u32, 2);
pub const SQL_DRIVER_COMPLETE_REQUIRED = @as(u32, 3);
pub const SQL_FETCH_BOOKMARK = @as(u32, 8);
pub const SQL_ROW_SUCCESS = @as(u32, 0);
pub const SQL_ROW_DELETED = @as(u32, 1);
pub const SQL_ROW_UPDATED = @as(u32, 2);
pub const SQL_ROW_NOROW = @as(u32, 3);
pub const SQL_ROW_ADDED = @as(u32, 4);
pub const SQL_ROW_ERROR = @as(u32, 5);
pub const SQL_ROW_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_ROW_PROCEED = @as(u32, 0);
pub const SQL_ROW_IGNORE = @as(u32, 1);
pub const SQL_PARAM_SUCCESS = @as(u32, 0);
pub const SQL_PARAM_SUCCESS_WITH_INFO = @as(u32, 6);
pub const SQL_PARAM_ERROR = @as(u32, 5);
pub const SQL_PARAM_UNUSED = @as(u32, 7);
pub const SQL_PARAM_DIAG_UNAVAILABLE = @as(u32, 1);
pub const SQL_PARAM_PROCEED = @as(u32, 0);
pub const SQL_PARAM_IGNORE = @as(u32, 1);
pub const SQL_CASCADE = @as(u32, 0);
pub const SQL_RESTRICT = @as(u32, 1);
pub const SQL_SET_NULL = @as(u32, 2);
pub const SQL_NO_ACTION = @as(u32, 3);
pub const SQL_SET_DEFAULT = @as(u32, 4);
pub const SQL_INITIALLY_DEFERRED = @as(u32, 5);
pub const SQL_INITIALLY_IMMEDIATE = @as(u32, 6);
pub const SQL_NOT_DEFERRABLE = @as(u32, 7);
pub const SQL_PARAM_TYPE_UNKNOWN = @as(u32, 0);
pub const SQL_PARAM_INPUT = @as(u32, 1);
pub const SQL_PARAM_INPUT_OUTPUT = @as(u32, 2);
pub const SQL_RESULT_COL = @as(u32, 3);
pub const SQL_PARAM_OUTPUT = @as(u32, 4);
pub const SQL_RETURN_VALUE = @as(u32, 5);
pub const SQL_PARAM_INPUT_OUTPUT_STREAM = @as(u32, 8);
pub const SQL_PARAM_OUTPUT_STREAM = @as(u32, 16);
pub const SQL_PT_UNKNOWN = @as(u32, 0);
pub const SQL_PT_PROCEDURE = @as(u32, 1);
pub const SQL_PT_FUNCTION = @as(u32, 2);
pub const SQL_ODBC_KEYWORDS = "ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,ASC,ASSERTION,AT,AUTHORIZATION,AVG,BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,DISTINCT,DOMAIN,DOUBLE,DROP,ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,EXISTS,EXTERNAL,EXTRACT,FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,MATCH,MAX,MIN,MINUTE,MODULE,MONTH,NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWSSCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,SUBSTRING,SUM,SYSTEM_USER,TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,YEAR,ZONE";
pub const SQL_YEAR = @as(u32, 1);
pub const SQL_MONTH = @as(u32, 2);
pub const SQL_DAY = @as(u32, 3);
pub const SQL_HOUR = @as(u32, 4);
pub const SQL_MINUTE = @as(u32, 5);
pub const SQL_SECOND = @as(u32, 6);
pub const SQL_YEAR_TO_MONTH = @as(u32, 7);
pub const SQL_DAY_TO_HOUR = @as(u32, 8);
pub const SQL_DAY_TO_MINUTE = @as(u32, 9);
pub const SQL_DAY_TO_SECOND = @as(u32, 10);
pub const SQL_HOUR_TO_MINUTE = @as(u32, 11);
pub const SQL_HOUR_TO_SECOND = @as(u32, 12);
pub const SQL_MINUTE_TO_SECOND = @as(u32, 13);
pub const SQL_DATABASE_NAME = @as(u32, 16);
pub const SQL_FD_FETCH_PREV = @as(i32, 8);
pub const SQL_FETCH_PREV = @as(u32, 4);
pub const SQL_CONCUR_TIMESTAMP = @as(u32, 3);
pub const SQL_SCCO_OPT_TIMESTAMP = @as(i32, 4);
pub const SQL_CC_DELETE = @as(u32, 0);
pub const SQL_CR_DELETE = @as(u32, 0);
pub const SQL_CC_CLOSE = @as(u32, 1);
pub const SQL_CR_CLOSE = @as(u32, 1);
pub const SQL_CC_PRESERVE = @as(u32, 2);
pub const SQL_CR_PRESERVE = @as(u32, 2);
pub const SQL_FETCH_RESUME = @as(u32, 7);
pub const SQL_SCROLL_FORWARD_ONLY = @as(i32, 0);
pub const SQL_SCROLL_KEYSET_DRIVEN = @as(i32, -1);
pub const SQL_SCROLL_DYNAMIC = @as(i32, -2);
pub const SQL_SCROLL_STATIC = @as(i32, -3);
pub const TRACE_VERSION = @as(u32, 1000);
pub const TRACE_ON = @as(i32, 1);
pub const TRACE_VS_EVENT_ON = @as(i32, 2);
pub const ODBC_VS_FLAG_UNICODE_ARG = @as(i32, 1);
pub const ODBC_VS_FLAG_UNICODE_COR = @as(i32, 2);
pub const ODBC_VS_FLAG_RETCODE = @as(i32, 4);
pub const ODBC_VS_FLAG_STOP = @as(i32, 8);
pub const CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS = @as(u32, 1);
pub const SSPROP_ENABLEFASTLOAD = @as(u32, 2);
pub const SSPROP_UNICODELCID = @as(u32, 2);
pub const SSPROP_UNICODECOMPARISONSTYLE = @as(u32, 3);
pub const SSPROP_COLUMNLEVELCOLLATION = @as(u32, 4);
pub const SSPROP_CHARACTERSET = @as(u32, 5);
pub const SSPROP_SORTORDER = @as(u32, 6);
pub const SSPROP_CURRENTCOLLATION = @as(u32, 7);
pub const SSPROP_INIT_CURRENTLANGUAGE = @as(u32, 4);
pub const SSPROP_INIT_NETWORKADDRESS = @as(u32, 5);
pub const SSPROP_INIT_NETWORKLIBRARY = @as(u32, 6);
pub const SSPROP_INIT_USEPROCFORPREP = @as(u32, 7);
pub const SSPROP_INIT_AUTOTRANSLATE = @as(u32, 8);
pub const SSPROP_INIT_PACKETSIZE = @as(u32, 9);
pub const SSPROP_INIT_APPNAME = @as(u32, 10);
pub const SSPROP_INIT_WSID = @as(u32, 11);
pub const SSPROP_INIT_FILENAME = @as(u32, 12);
pub const SSPROP_INIT_ENCRYPT = @as(u32, 13);
pub const SSPROP_AUTH_REPL_SERVER_NAME = @as(u32, 14);
pub const SSPROP_INIT_TAGCOLUMNCOLLATION = @as(u32, 15);
pub const SSPROPVAL_USEPROCFORPREP_OFF = @as(u32, 0);
pub const SSPROPVAL_USEPROCFORPREP_ON = @as(u32, 1);
pub const SSPROPVAL_USEPROCFORPREP_ON_DROP = @as(u32, 2);
pub const SSPROP_QUOTEDCATALOGNAMES = @as(u32, 2);
pub const SSPROP_ALLOWNATIVEVARIANT = @as(u32, 3);
pub const SSPROP_SQLXMLXPROGID = @as(u32, 4);
pub const SSPROP_MAXBLOBLENGTH = @as(u32, 8);
pub const SSPROP_FASTLOADOPTIONS = @as(u32, 9);
pub const SSPROP_FASTLOADKEEPNULLS = @as(u32, 10);
pub const SSPROP_FASTLOADKEEPIDENTITY = @as(u32, 11);
pub const SSPROP_CURSORAUTOFETCH = @as(u32, 12);
pub const SSPROP_DEFERPREPARE = @as(u32, 13);
pub const SSPROP_IRowsetFastLoad = @as(u32, 14);
pub const SSPROP_COL_COLLATIONNAME = @as(u32, 14);
pub const SSPROP_STREAM_MAPPINGSCHEMA = @as(u32, 15);
pub const SSPROP_STREAM_XSL = @as(u32, 16);
pub const SSPROP_STREAM_BASEPATH = @as(u32, 17);
pub const SSPROP_STREAM_COMMANDTYPE = @as(u32, 18);
pub const SSPROP_STREAM_XMLROOT = @as(u32, 19);
pub const SSPROP_STREAM_FLAGS = @as(u32, 20);
pub const SSPROP_STREAM_CONTENTTYPE = @as(u32, 23);
pub const STREAM_FLAGS_DISALLOW_URL = @as(u32, 1);
pub const STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH = @as(u32, 2);
pub const STREAM_FLAGS_DISALLOW_QUERY = @as(u32, 4);
pub const STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA = @as(u32, 8);
pub const STREAM_FLAGS_DONTCACHETEMPLATE = @as(u32, 16);
pub const STREAM_FLAGS_DONTCACHEXSL = @as(u32, 32);
pub const STREAM_FLAGS_DISALLOW_UPDATEGRAMS = @as(u32, 64);
pub const STREAM_FLAGS_RESERVED = @as(u32, 4294901760);
pub const SSPROPVAL_COMMANDTYPE_REGULAR = @as(u32, 21);
pub const SSPROPVAL_COMMANDTYPE_BULKLOAD = @as(u32, 22);
pub const DBTYPE_SQLVARIANT = @as(u32, 144);
pub const SQL_HANDLE_DBC_INFO_TOKEN = @as(u32, 6);
pub const SQL_CONN_POOL_RATING_BEST = @as(u32, 100);
pub const SQL_CONN_POOL_RATING_GOOD_ENOUGH = @as(u32, 99);
pub const SQL_CONN_POOL_RATING_USELESS = @as(u32, 0);
pub const SQL_ATTR_DBC_INFO_TOKEN = @as(u32, 118);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CALLBACK = @as(u32, 120);
pub const SQL_ATTR_ASYNC_DBC_NOTIFICATION_CONTEXT = @as(u32, 121);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CALLBACK = @as(u32, 30);
pub const SQL_ATTR_ASYNC_STMT_NOTIFICATION_CONTEXT = @as(u32, 31);
pub const SQL_MAX_NUMERIC_LEN = @as(u32, 16);
pub const SQL_WCHAR = @as(i32, -8);
pub const SQL_WVARCHAR = @as(i32, -9);
pub const SQL_WLONGVARCHAR = @as(i32, -10);
pub const SQL_C_WCHAR = @as(i32, -8);
pub const SQL_C_TCHAR = @as(i32, -8);
pub const SQL_SQLSTATE_SIZEW = @as(u32, 10);
pub const CSTORAGEPROPERTY = @as(u32, 23);
pub const CATEGORY_SEARCH = @as(i32, 1);
pub const CATEGORY_COLLATOR = @as(i32, 2);
pub const CATEGORY_GATHERER = @as(i32, 3);
pub const CATEGORY_INDEXER = @as(i32, 4);
pub const EVENT_SSSEARCH_STARTED = @as(i32, 1073742827);
pub const EVENT_SSSEARCH_STARTING_SETUP = @as(i32, 1073742828);
pub const EVENT_SSSEARCH_SETUP_SUCCEEDED = @as(i32, 1073742829);
pub const EVENT_SSSEARCH_SETUP_FAILED = @as(i32, -1073740818);
pub const EVENT_OUTOFMEMORY = @as(i32, -1073740817);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_STARTED = @as(i32, -2147482640);
pub const EVENT_EXCEPTION = @as(i32, -1073740815);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_SUCCEEDED = @as(i32, 1073742834);
pub const EVENT_SSSEARCH_SETUP_CLEANUP_FAILED = @as(i32, -1073740813);
pub const EVENT_SSSEARCH_STOPPED = @as(i32, 1073742837);
pub const EVENT_SSSEARCH_CREATE_PATH_RULES_FAILED = @as(i32, -2147482634);
pub const EVENT_SSSEARCH_DROPPED_EVENTS = @as(i32, -2147482633);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_FAILED = @as(i32, -1073740808);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_SUCCEEDED = @as(i32, 1073742841);
pub const EVENT_SSSEARCH_DATAFILES_MOVE_ROLLBACK_ERRORS = @as(i32, -2147482630);
pub const EVENT_SSSEARCH_CSM_SAVE_FAILED = @as(i32, -1073740805);
pub const EVENT_CONFIG_SYNTAX = @as(i32, -2147482604);
pub const EVENT_UNPRIVILEGED_SERVICE_ACCOUNT = @as(i32, -2147482596);
pub const EVENT_SYSTEM_EXCEPTION = @as(i32, -2147482595);
pub const EVENT_CONFIG_ERROR = @as(i32, -1073738821);
pub const EVENT_GATHERSVC_PERFMON = @as(i32, -1073738818);
pub const EVENT_GATHERER_PERFMON = @as(i32, -1073738817);
pub const EVENT_HASHMAP_INSERT = @as(i32, -1073738816);
pub const EVENT_TRANSLOG_CREATE_TRX = @as(i32, -1073738815);
pub const EVENT_TRANSLOG_APPEND = @as(i32, -1073738814);
pub const EVENT_TRANSLOG_UPDATE = @as(i32, -1073738813);
pub const EVENT_HASHMAP_UPDATE = @as(i32, -1073738811);
pub const EVENT_GATHER_EXCEPTION = @as(i32, -1073738810);
pub const EVENT_TRANSACTION_READ = @as(i32, -1073738809);
pub const EVENT_GATHER_END_CRAWL = @as(i32, 1073744842);
pub const EVENT_GATHER_START_CRAWL = @as(i32, 1073744843);
pub const EVENT_GATHER_INTERNAL = @as(i32, -1073738804);
pub const EVENT_GATHER_CRAWL_NOT_STARTED = @as(i32, -2147480625);
pub const EVENT_GATHER_CRAWL_SEED_ERROR = @as(i32, -2147480624);
pub const EVENT_GATHER_CRITICAL_ERROR = @as(i32, -1073738799);
pub const EVENT_GATHER_ADVISE_FAILED = @as(i32, -1073738798);
pub const EVENT_GATHER_TRANSACTION_FAIL = @as(i32, -1073738797);
pub const EVENT_GATHER_OBJ_INIT_FAILED = @as(i32, -1073738796);
pub const EVENT_GATHER_PLUGIN_INIT_FAILED = @as(i32, -1073738795);
pub const EVENT_GATHER_SERVICE_INIT = @as(i32, -1073738794);
pub const EVENT_GATHER_CANT_CREATE_DOCID = @as(i32, -1073738793);
pub const EVENT_GATHER_CANT_DELETE_DOCID = @as(i32, -1073738792);
pub const EVENT_TRANSLOG_CREATE = @as(i32, -1073738791);
pub const EVENT_REG_VERSION = @as(i32, -1073738790);
pub const EVENT_GATHER_CRAWL_SEED_FAILED = @as(i32, -2147480612);
pub const EVENT_GATHER_CRAWL_SEED_FAILED_INIT = @as(i32, -2147480611);
pub const EVENT_GATHER_REG_MISSING = @as(i32, -2147480610);
pub const EVENT_GATHER_CRAWL_IN_PROGRESS = @as(i32, -2147480609);
pub const EVENT_GATHER_LOCK_FAILED = @as(i32, -1073738784);
pub const EVENT_GATHER_RESET_START = @as(i32, 1073744865);
pub const EVENT_GATHER_START_PAUSE = @as(i32, -2147480606);
pub const EVENT_GATHER_THROTTLE = @as(i32, 1073744867);
pub const EVENT_GATHER_RESUME = @as(i32, 1073744868);
pub const EVENT_GATHER_AUTODESCLEN_ADJUSTED = @as(i32, -2147480603);
pub const EVENT_GATHER_NO_CRAWL_SEEDS = @as(i32, -2147480602);
pub const EVENT_GATHER_END_INCREMENTAL = @as(i32, 1073744871);
pub const EVENT_GATHER_FROM_NOT_SET = @as(i32, -1073738776);
pub const EVENT_GATHER_DELETING_HISTORY_ITEMS = @as(i32, -1073738774);
pub const EVENT_GATHER_STOP_START = @as(i32, 1073744876);
pub const EVENT_GATHER_START_CRAWL_IF_RESET = @as(i32, -2147480595);
pub const EVENT_GATHER_DISK_FULL = @as(i32, -2147480594);
pub const EVENT_GATHER_NO_SCHEMA = @as(i32, -2147480593);
pub const EVENT_GATHER_AUTODESCENCODE_INVALID = @as(i32, -2147480592);
pub const EVENT_GATHER_PLUGINMGR_INIT_FAILED = @as(i32, -1073738767);
pub const EVENT_GATHER_APP_INIT_FAILED = @as(i32, -1073738766);
pub const EVENT_FAILED_INITIALIZE_CRAWL = @as(i32, -1073738765);
pub const EVENT_CRAWL_SCHEDULED = @as(i32, 1073744884);
pub const EVENT_FAILED_CREATE_GATHERER_LOG = @as(i32, -2147480587);
pub const EVENT_WBREAKER_NOT_LOADED = @as(i32, -2147480586);
pub const EVENT_LEARN_PROPAGATION_COPY_FAILED = @as(i32, -2147480585);
pub const EVENT_LEARN_CREATE_DB_FAILED = @as(i32, -2147480584);
pub const EVENT_LEARN_COMPILE_FAILED = @as(i32, -2147480583);
pub const EVENT_LEARN_PROPAGATION_FAILED = @as(i32, -2147480582);
pub const EVENT_GATHER_END_ADAPTIVE = @as(i32, 1073744891);
pub const EVENT_USING_DIFFERENT_WORD_BREAKER = @as(i32, -2147480580);
pub const EVENT_GATHER_RESTORE_COMPLETE = @as(i32, 3069);
pub const EVENT_GATHER_RESTORE_ERROR = @as(i32, -1073738754);
pub const EVENT_AUTOCAT_PERFMON = @as(i32, -1073738753);
pub const EVENT_GATHER_DIRTY_STARTUP = @as(i32, -2147480576);
pub const EVENT_GATHER_HISTORY_CORRUPTION_DETECTED = @as(i32, -2147480575);
pub const EVENT_GATHER_RESTOREAPP_ERROR = @as(i32, -1073738750);
pub const EVENT_GATHER_RESTOREAPP_COMPLETE = @as(i32, 3075);
pub const EVENT_GATHER_BACKUPAPP_ERROR = @as(i32, -1073738748);
pub const EVENT_GATHER_BACKUPAPP_COMPLETE = @as(i32, 3077);
pub const EVENT_GATHER_DAEMON_TERMINATED = @as(i32, -2147480570);
pub const EVENT_NOTIFICATION_FAILURE = @as(i32, -1073738745);
pub const EVENT_NOTIFICATION_FAILURE_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480568);
pub const EVENT_NOTIFICATION_RESTORED = @as(i32, 1073744905);
pub const EVENT_NOTIFICATION_RESTORED_SCOPE_EXCEEDED_LOGGING = @as(i32, -2147480566);
pub const EVENT_GATHER_PROTOCOLHANDLER_LOAD_FAILED = @as(i32, -1073738741);
pub const EVENT_GATHER_PROTOCOLHANDLER_INIT_FAILED = @as(i32, -1073738740);
pub const EVENT_GATHER_INVALID_NETWORK_ACCESS_ACCOUNT = @as(i32, -1073738739);
pub const EVENT_GATHER_SYSTEM_LCID_CHANGED = @as(i32, -2147480562);
pub const EVENT_GATHER_FLUSH_FAILED = @as(i32, -1073738737);
pub const EVENT_GATHER_CHECKPOINT_FAILED = @as(i32, -1073738736);
pub const EVENT_GATHER_SAVE_FAILED = @as(i32, -1073738735);
pub const EVENT_GATHER_RESTORE_CHECKPOINT_FAILED = @as(i32, -1073738734);
pub const EVENT_GATHER_READ_CHECKPOINT_FAILED = @as(i32, -1073738733);
pub const EVENT_GATHER_CHECKPOINT_CORRUPT = @as(i32, -1073738732);
pub const EVENT_GATHER_CHECKPOINT_FILE_MISSING = @as(i32, -1073738731);
pub const EVENT_STS_INIT_SECURITY_FAILED = @as(i32, -2147480554);
pub const EVENT_LOCAL_GROUP_NOT_EXPANDED = @as(i32, 1073744919);
pub const EVENT_LOCAL_GROUPS_CACHE_FLUSHED = @as(i32, 1073744920);
pub const EVENT_GATHERER_DATASOURCE = @as(i32, -1073738727);
pub const EVENT_AUTOCAT_CANT_CREATE_FILE_SHARE = @as(i32, -1073738726);
pub const EVENT_NOTIFICATION_THREAD_EXIT_FAILED = @as(i32, -1073738725);
pub const EVENT_FILTER_HOST_NOT_INITIALIZED = @as(i32, -1073738724);
pub const EVENT_FILTER_HOST_NOT_TERMINATED = @as(i32, -1073738723);
pub const EVENT_FILTERPOOL_ADD_FAILED = @as(i32, -1073738722);
pub const EVENT_FILTERPOOL_DELETE_FAILED = @as(i32, -1073738721);
pub const EVENT_ENUMERATE_SESSIONS_FAILED = @as(i32, -1073738720);
pub const EVENT_DETAILED_FILTERPOOL_ADD_FAILED = @as(i32, -1073738719);
pub const EVENT_AUDIENCECOMPUTATION_CANNOTSTART = @as(i32, -1073738223);
pub const EVENT_GATHER_RECOVERY_FAILURE = @as(i32, -1073738222);
pub const EVENT_INDEXER_STARTED = @as(i32, 1073748824);
pub const EVENT_INDEXER_SCHEMA_COPY_ERROR = @as(i32, -1073734823);
pub const EVENT_INDEXER_INIT_ERROR = @as(i32, -1073734814);
pub const EVENT_INDEXER_INVALID_DIRECTORY = @as(i32, -1073734813);
pub const EVENT_INDEXER_PROP_ERROR = @as(i32, -1073734812);
pub const EVENT_INDEXER_PAUSED_FOR_DISKFULL = @as(i32, -1073734811);
pub const EVENT_INDEXER_PROP_STOPPED = @as(i32, -2147476633);
pub const EVENT_INDEXER_PROP_SUCCEEDED = @as(i32, 7016);
pub const EVENT_INDEXER_PROP_STARTED = @as(i32, 1073748841);
pub const EVENT_INDEXER_NO_SEARCH_SERVERS = @as(i32, -2147476630);
pub const EVENT_INDEXER_ADD_DSS_SUCCEEDED = @as(i32, 7019);
pub const EVENT_INDEXER_REMOVE_DSS_SUCCEEDED = @as(i32, 7020);
pub const EVENT_INDEXER_ADD_DSS_FAILED = @as(i32, -2147476627);
pub const EVENT_INDEXER_REMOVE_DSS_FAILED = @as(i32, -1073734801);
pub const EVENT_INDEXER_DSS_CONTACT_FAILED = @as(i32, -1073734800);
pub const EVENT_INDEXER_BUILD_FAILED = @as(i32, -1073734797);
pub const EVENT_INDEXER_REG_MISSING = @as(i32, -1073734796);
pub const EVENT_INDEXER_PROPSTORE_INIT_FAILED = @as(i32, -1073734787);
pub const EVENT_INDEXER_CI_LOAD_ERROR = @as(i32, -1073734785);
pub const EVENT_INDEXER_RESET_FOR_CORRUPTION = @as(i32, -1073734784);
pub const EVENT_INDEXER_SHUTDOWN = @as(i32, 1073748866);
pub const EVENT_INDEXER_LOAD_FAIL = @as(i32, -1073734781);
pub const EVENT_INDEXER_PROP_STATE_CORRUPT = @as(i32, -1073734780);
pub const EVENT_INDEXER_DSS_ALREADY_ADDED = @as(i32, 1073748870);
pub const EVENT_INDEXER_BUILD_START = @as(i32, 1073748872);
pub const EVENT_INDEXER_BUILD_ENDED = @as(i32, 1073748873);
pub const EVENT_INDEXER_VERIFY_PROP_ACCOUNT = @as(i32, -1073734768);
pub const EVENT_INDEXER_ADD_DSS_DISCONNECT = @as(i32, -2147476585);
pub const EVENT_INDEXER_PERFMON = @as(i32, -1073734760);
pub const EVENT_INDEXER_MISSING_APP_DIRECTORY = @as(i32, -1073734758);
pub const EVENT_INDEXER_REG_ERROR = @as(i32, -1073734756);
pub const EVENT_INDEXER_DSS_UNABLE_TO_REMOVE = @as(i32, -1073734755);
pub const EVENT_INDEXER_NEW_PROJECT = @as(i32, -1073734754);
pub const EVENT_INDEXER_REMOVED_PROJECT = @as(i32, -1073734753);
pub const EVENT_INDEXER_PROP_COMMITTED = @as(i32, 1073748898);
pub const EVENT_INDEXER_PROP_ABORTED = @as(i32, 1073748899);
pub const EVENT_DSS_NOT_ENABLED = @as(i32, -2147476572);
pub const EVENT_INDEXER_PROP_COMMIT_FAILED = @as(i32, -1073734747);
pub const JET_INIT_ERROR = @as(i32, -1073732824);
pub const JET_NEW_PROP_STORE_ERROR = @as(i32, -1073732823);
pub const JET_GET_PROP_STORE_ERROR = @as(i32, -1073732822);
pub const JET_MULTIINSTANCE_DISABLED = @as(i32, -2147474645);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILES = @as(i32, -2147473635);
pub const EVENT_WARNING_CANNOT_UPGRADE_NOISE_FILE = @as(i32, -2147473634);
pub const EVENT_WIN32_ERROR = @as(i32, -2147473633);
pub const EVENT_PERF_COUNTERS_NOT_LOADED = @as(i32, -2147473628);
pub const EVENT_PERF_COUNTERS_REGISTRY_TROUBLE = @as(i32, -2147473627);
pub const EVENT_PERF_COUNTERS_ALREADY_EXISTS = @as(i32, -2147473626);
pub const EVENT_PROTOCOL_HOST_FORCE_TERMINATE = @as(i32, -2147473625);
pub const EVENT_FILTER_HOST_FORCE_TERMINATE = @as(i32, -2147473624);
pub const EVENT_INDEXER_OUT_OF_DATABASE_INSTANCE = @as(i32, -1073731799);
pub const EVENT_INDEXER_FAIL_TO_SET_MAX_JETINSTANCE = @as(i32, -1073731798);
pub const EVENT_INDEXER_FAIL_TO_CREATE_PER_USER_CATALOG = @as(i32, -1073731797);
pub const EVENT_INDEXER_FAIL_TO_UNLOAD_PER_USER_CATALOG = @as(i32, -1073731796);
pub const ERROR_SOURCE_NETWORKING = @as(u32, 768);
pub const ERROR_SOURCE_DATASOURCE = @as(u32, 1024);
pub const ERROR_SOURCE_COLLATOR = @as(u32, 1280);
pub const ERROR_SOURCE_CONNMGR = @as(u32, 1536);
pub const ERROR_SOURCE_QUERY = @as(u32, 1792);
pub const ERROR_SOURCE_SCHEMA = @as(u32, 3072);
pub const ERROR_SOURCE_GATHERER = @as(u32, 3328);
pub const ERROR_SOURCE_INDEXER = @as(u32, 4352);
pub const ERROR_SOURCE_SETUP = @as(u32, 4864);
pub const ERROR_SOURCE_SECURITY = @as(u32, 5120);
pub const ERROR_SOURCE_CMDLINE = @as(u32, 5376);
pub const ERROR_SOURCE_NLADMIN = @as(u32, 6400);
pub const ERROR_SOURCE_SCRIPTPI = @as(u32, 8192);
pub const ERROR_SOURCE_MSS = @as(u32, 8448);
pub const ERROR_SOURCE_XML = @as(u32, 8704);
pub const ERROR_SOURCE_DAV = @as(u32, 8960);
pub const ERROR_SOURCE_FLTRDMN = @as(u32, 9216);
pub const ERROR_SOURCE_OLEDB_BINDER = @as(u32, 9472);
pub const ERROR_SOURCE_NOTESPH = @as(u32, 9728);
pub const ERROR_SOURCE_EXSTOREPH = @as(u32, 9984);
pub const ERROR_SOURCE_SRCH_SCHEMA_CACHE = @as(u32, 13056);
pub const ERROR_SOURCE_CONTENT_SOURCE = @as(u32, 13312);
pub const ERROR_SOURCE_REMOTE_EXSTOREPH = @as(u32, 13568);
pub const ERROR_SOURCE_PEOPLE_IMPORT = @as(u32, 16384);
pub const ERROR_FTE = @as(u32, 13824);
pub const ERROR_FTE_CB = @as(u32, 51968);
pub const ERROR_FTE_FD = @as(u32, 64768);
pub const XML_E_NODEFAULTNS = @as(i32, -2147212800);
pub const XML_E_BADSXQL = @as(i32, -2147212799);
pub const MSS_E_INVALIDAPPNAME = @as(i32, -2147213056);
pub const MSS_E_APPNOTFOUND = @as(i32, -2147213055);
pub const MSS_E_APPALREADYEXISTS = @as(i32, -2147213054);
pub const MSS_E_CATALOGNOTFOUND = @as(i32, -2147213053);
pub const MSS_E_CATALOGSTOPPING = @as(i32, -2147213052);
pub const MSS_E_UNICODEFILEHEADERMISSING = @as(i32, -2147213051);
pub const MSS_E_CATALOGALREADYEXISTS = @as(i32, -2147213050);
pub const NET_E_GENERAL = @as(i32, -2147220736);
pub const NET_E_DISCONNECTED = @as(i32, -2147220733);
pub const NET_E_INVALIDPARAMS = @as(i32, -2147220728);
pub const NET_E_OPERATIONINPROGRESS = @as(i32, -2147220727);
pub const SEC_E_INVALIDCONTEXT = @as(i32, -2147216381);
pub const SEC_E_INITFAILED = @as(i32, -2147216383);
pub const SEC_E_NOTINITIALIZED = @as(i32, -2147216382);
pub const SEC_E_ACCESSDENIED = @as(i32, -2147216129);
pub const DS_E_NOMOREDATA = @as(i32, -2147220480);
pub const DS_E_INVALIDDATASOURCE = @as(i32, -2147220479);
pub const DS_E_DATASOURCENOTAVAILABLE = @as(i32, -2147220478);
pub const DS_E_QUERYCANCELED = @as(i32, -2147220477);
pub const DS_E_UNKNOWNREQUEST = @as(i32, -2147220476);
pub const DS_E_BADREQUEST = @as(i32, -2147220475);
pub const DS_E_SERVERCAPACITY = @as(i32, -2147220474);
pub const DS_E_BADSEQUENCE = @as(i32, -2147220473);
pub const DS_E_MESSAGETOOLONG = @as(i32, -2147220472);
pub const DS_E_SERVERERROR = @as(i32, -2147220471);
pub const DS_E_CONFIGBAD = @as(i32, -2147220470);
pub const DS_E_DATANOTPRESENT = @as(i32, -2147220464);
pub const DS_E_SETSTATUSINPROGRESS = @as(i32, -2147220463);
pub const DS_E_DUPLICATEID = @as(i32, -2147220462);
pub const DS_E_TOOMANYDATASOURCES = @as(i32, -2147220461);
pub const DS_E_REGISTRY = @as(i32, -2147220460);
pub const DS_E_DATASOURCENOTDISABLED = @as(i32, -2147220459);
pub const DS_E_INVALIDTAGDB = @as(i32, -2147220458);
pub const DS_E_INVALIDCATALOGNAME = @as(i32, -2147220457);
pub const DS_E_CONFIGNOTRIGHTTYPE = @as(i32, -2147220456);
pub const DS_E_PROTOCOLVERSION = @as(i32, -2147220455);
pub const DS_E_ALREADYENABLED = @as(i32, -2147220454);
pub const DS_E_INDEXDIRECTORY = @as(i32, -2147220452);
pub const DS_E_VALUETOOLARGE = @as(i32, -2147220451);
pub const DS_E_UNKNOWNPARAM = @as(i32, -2147220450);
pub const DS_E_BUFFERTOOSMALL = @as(i32, -2147220449);
pub const DS_E_PARAMOUTOFRANGE = @as(i32, -2147220448);
pub const DS_E_ALREADYDISABLED = @as(i32, -2147220447);
pub const DS_E_QUERYHUNG = @as(i32, -2147220446);
pub const DS_E_BADRESULT = @as(i32, -2147220445);
pub const DS_E_CANNOTWRITEREGISTRY = @as(i32, -2147220444);
pub const DS_E_CANNOTREMOVECONCURRENT = @as(i32, -2147220443);
pub const DS_E_SEARCHCATNAMECOLLISION = @as(i32, -2147220442);
pub const DS_E_PROPVERSIONMISMATCH = @as(i32, -2147220441);
pub const DS_E_MISSINGCATALOG = @as(i32, -2147220440);
pub const COLL_E_BADSEQUENCE = @as(i32, -2147220223);
pub const COLL_E_NOMOREDATA = @as(i32, -2147220222);
pub const COLL_E_INCOMPATIBLECOLUMNS = @as(i32, -2147220221);
pub const COLL_E_BUFFERTOOSMALL = @as(i32, -2147220220);
pub const COLL_E_BADRESULT = @as(i32, -2147220218);
pub const COLL_E_NOSORTCOLUMN = @as(i32, -2147220217);
pub const COLL_E_DUPLICATEDBID = @as(i32, -2147220216);
pub const COLL_E_TOOMANYMERGECOLUMNS = @as(i32, -2147220215);
pub const COLL_E_NODEFAULTCATALOG = @as(i32, -2147220214);
pub const COLL_E_MAXCONNEXCEEDED = @as(i32, -2147220213);
pub const CM_E_TOOMANYDATASERVERS = @as(i32, -2147219967);
pub const CM_E_TOOMANYDATASOURCES = @as(i32, -2147219966);
pub const CM_E_NOQUERYCONNECTIONS = @as(i32, -2147219965);
pub const CM_E_DATASOURCENOTAVAILABLE = @as(i32, -2147219964);
pub const CM_E_CONNECTIONTIMEOUT = @as(i32, -2147219963);
pub const CM_E_SERVERNOTFOUND = @as(i32, -2147219962);
pub const CM_S_NODATASERVERS = @as(i32, 263687);
pub const CM_E_REGISTRY = @as(i32, -2147219960);
pub const CM_E_INVALIDDATASOURCE = @as(i32, -2147219959);
pub const CM_E_TIMEOUT = @as(i32, -2147219958);
pub const CM_E_INSUFFICIENTBUFFER = @as(i32, -2147219957);
pub const QRY_E_QUERYSYNTAX = @as(i32, -2147219711);
pub const QRY_E_TYPEMISMATCH = @as(i32, -2147219710);
pub const QRY_E_UNHANDLEDTYPE = @as(i32, -2147219709);
pub const QRY_S_NOROWSFOUND = @as(i32, 263940);
pub const QRY_E_TOOMANYCOLUMNS = @as(i32, -2147219707);
pub const QRY_E_TOOMANYDATABASES = @as(i32, -2147219706);
pub const QRY_E_STARTHITTOBIG = @as(i32, -2147219705);
pub const QRY_E_TOOMANYQUERYTERMS = @as(i32, -2147219704);
pub const QRY_E_NODATASOURCES = @as(i32, -2147219703);
pub const QRY_E_TIMEOUT = @as(i32, -2147219702);
pub const QRY_E_COLUMNNOTSORTABLE = @as(i32, -2147219701);
pub const QRY_E_COLUMNNOTSEARCHABLE = @as(i32, -2147219700);
pub const QRY_E_INVALIDCOLUMN = @as(i32, -2147219699);
pub const QRY_E_QUERYCORRUPT = @as(i32, -2147219698);
pub const QRY_E_PREFIXWILDCARD = @as(i32, -2147219697);
pub const QRY_E_INFIXWILDCARD = @as(i32, -2147219696);
pub const QRY_E_WILDCARDPREFIXLENGTH = @as(i32, -2147219695);
pub const QRY_S_TERMIGNORED = @as(i32, 263954);
pub const QRY_E_ENGINEFAILED = @as(i32, -2147219693);
pub const QRY_E_SEARCHTOOBIG = @as(i32, -2147219692);
pub const QRY_E_NULLQUERY = @as(i32, -2147219691);
pub const QRY_S_INEXACTRESULTS = @as(i32, 263958);
pub const QRY_E_NOCOLUMNS = @as(i32, -2147219689);
pub const QRY_E_INVALIDSCOPES = @as(i32, -2147219688);
pub const QRY_E_INVALIDCATALOG = @as(i32, -2147219687);
pub const QRY_E_SCOPECARDINALIDY = @as(i32, -2147219686);
pub const QRY_E_UNEXPECTED = @as(i32, -2147219685);
pub const QRY_E_INVALIDPATH = @as(i32, -2147219684);
pub const QRY_E_LMNOTINITIALIZED = @as(i32, -2147219683);
pub const QRY_E_INVALIDINTERVAL = @as(i32, -2147219682);
pub const QRY_E_NOLOGMANAGER = @as(i32, -2147219681);
pub const SCHEMA_E_LOAD_SPECIAL = @as(i32, -2147218431);
pub const SCHEMA_E_FILENOTFOUND = @as(i32, -2147218430);
pub const SCHEMA_E_NESTEDTAG = @as(i32, -2147218429);
pub const SCHEMA_E_UNEXPECTEDTAG = @as(i32, -2147218428);
pub const SCHEMA_E_VERSIONMISMATCH = @as(i32, -2147218427);
pub const SCHEMA_E_CANNOTCREATEFILE = @as(i32, -2147218426);
pub const SCHEMA_E_CANNOTWRITEFILE = @as(i32, -2147218425);
pub const SCHEMA_E_EMPTYFILE = @as(i32, -2147218424);
pub const SCHEMA_E_INVALIDFILETYPE = @as(i32, -2147218423);
pub const SCHEMA_E_INVALIDDATATYPE = @as(i32, -2147218422);
pub const SCHEMA_E_CANNOTCREATENOISEWORDFILE = @as(i32, -2147218421);
pub const SCHEMA_E_ADDSTOPWORDS = @as(i32, -2147218420);
pub const SCHEMA_E_NAMEEXISTS = @as(i32, -2147218419);
pub const SCHEMA_E_INVALIDVALUE = @as(i32, -2147218418);
pub const SCHEMA_E_BADPROPSPEC = @as(i32, -2147218417);
pub const SCHEMA_E_NOMORECOLUMNS = @as(i32, -2147218416);
pub const SCHEMA_E_FILECHANGED = @as(i32, -2147218415);
pub const SCHEMA_E_BADCOLUMNNAME = @as(i32, -2147218414);
pub const SCHEMA_E_BADPROPPID = @as(i32, -2147218413);
pub const SCHEMA_E_BADATTRIBUTE = @as(i32, -2147218412);
pub const SCHEMA_E_BADFILENAME = @as(i32, -2147218411);
pub const SCHEMA_E_PROPEXISTS = @as(i32, -2147218410);
pub const SCHEMA_E_DUPLICATENOISE = @as(i32, -2147218409);
pub const GTHR_E_DUPLICATE_OBJECT = @as(i32, -2147218174);
pub const GTHR_E_UNABLE_TO_READ_REGISTRY = @as(i32, -2147218173);
pub const GTHR_E_ERROR_WRITING_REGISTRY = @as(i32, -2147218172);
pub const GTHR_E_ERROR_INITIALIZING_PERFMON = @as(i32, -2147218171);
pub const GTHR_E_ERROR_OBJECT_NOT_FOUND = @as(i32, -2147218170);
pub const GTHR_E_URL_EXCLUDED = @as(i32, -2147218169);
pub const GTHR_E_CONFIG_DUP_PROJECT = @as(i32, -2147218166);
pub const GTHR_E_CONFIG_DUP_EXTENSION = @as(i32, -2147218165);
pub const GTHR_E_DUPLICATE_URL = @as(i32, -2147218163);
pub const GTHR_E_TOO_MANY_PLUGINS = @as(i32, -2147218162);
pub const GTHR_E_INVALIDFUNCTION = @as(i32, -2147218161);
pub const GTHR_E_NOFILTERSINK = @as(i32, -2147218160);
pub const GTHR_E_FILTER_PROCESS_TERMINATED = @as(i32, -2147218159);
pub const GTHR_E_FILTER_INVALID_MESSAGE = @as(i32, -2147218158);
pub const GTHR_E_UNSUPPORTED_PROPERTY_TYPE = @as(i32, -2147218157);
pub const GTHR_E_NAME_TOO_LONG = @as(i32, -2147218156);
pub const GTHR_E_NO_IDENTITY = @as(i32, -2147218155);
pub const GTHR_E_FILTER_NOT_FOUND = @as(i32, -2147218154);
pub const GTHR_E_FILTER_NO_MORE_THREADS = @as(i32, -2147218153);
pub const GTHR_E_PRT_HNDLR_PROGID_MISSING = @as(i32, -2147218152);
pub const GTHR_E_FILTER_PROCESS_TERMINATED_QUOTA = @as(i32, -2147218151);
pub const GTHR_E_UNKNOWN_PROTOCOL = @as(i32, -2147218150);
pub const GTHR_E_PROJECT_NOT_INITIALIZED = @as(i32, -2147218149);
pub const GTHR_S_STATUS_CHANGE_IGNORED = @as(i32, 265500);
pub const GTHR_S_STATUS_END_CRAWL = @as(i32, 265501);
pub const GTHR_S_STATUS_RESET = @as(i32, 265502);
pub const GTHR_S_STATUS_THROTTLE = @as(i32, 265503);
pub const GTHR_S_STATUS_RESUME = @as(i32, 265504);
pub const GTHR_S_STATUS_PAUSE = @as(i32, 265505);
pub const GTHR_E_INVALID_PROJECT_NAME = @as(i32, -2147218142);
pub const GTHR_E_SHUTTING_DOWN = @as(i32, -2147218141);
pub const GTHR_S_END_STD_CHUNKS = @as(i32, 265508);
pub const GTHR_E_VALUE_NOT_AVAILABLE = @as(i32, -2147218139);
pub const GTHR_E_OUT_OF_DOC_ID = @as(i32, -2147218138);
pub const GTHR_E_NOTIFICATION_START_PAGE = @as(i32, -2147218137);
pub const GTHR_E_DUP_PROPERTY_MAPPING = @as(i32, -2147218134);
pub const GTHR_S_NO_CRAWL_SEEDS = @as(i32, 265515);
pub const GTHR_E_INVALID_ACCOUNT = @as(i32, -2147218132);
pub const GTHR_E_FILTER_INIT = @as(i32, -2147218130);
pub const GTHR_E_INVALID_ACCOUNT_SYNTAX = @as(i32, -2147218129);
pub const GTHR_S_CANNOT_FILTER = @as(i32, 265520);
pub const GTHR_E_PROXY_NAME = @as(i32, -2147218127);
pub const GTHR_E_SERVER_UNAVAILABLE = @as(i32, -2147218126);
pub const GTHR_S_STATUS_STOP = @as(i32, 265523);
pub const GTHR_E_INVALID_PATH = @as(i32, -2147218124);
pub const GTHR_E_FILTER_NO_CODEPAGE = @as(i32, -2147218123);
pub const GTHR_S_STATUS_START = @as(i32, 265526);
pub const GTHR_E_NO_PRTCLHNLR = @as(i32, -2147218121);
pub const GTHR_E_IE_OFFLINE = @as(i32, -2147218120);
pub const GTHR_E_BAD_FILTER_DAEMON = @as(i32, -2147218119);
pub const GTHR_E_INVALID_MAPPING = @as(i32, -2147218112);
pub const GTHR_E_USER_AGENT_NOT_SPECIFIED = @as(i32, -2147218111);
pub const GTHR_E_FROM_NOT_SPECIFIED = @as(i32, -2147218109);
pub const GTHR_E_INVALID_STREAM_LOGS_COUNT = @as(i32, -2147218108);
pub const GTHR_E_INVALID_EXTENSION = @as(i32, -2147218107);
pub const GTHR_E_INVALID_GROW_FACTOR = @as(i32, -2147218106);
pub const GTHR_E_INVALID_TIME_OUT = @as(i32, -2147218105);
pub const GTHR_E_INVALID_RETRIES = @as(i32, -2147218104);
pub const GTHR_E_INVALID_LOG_FILE_NAME = @as(i32, -2147218103);
pub const GTHR_E_INVALID_HOST_NAME = @as(i32, -2147218096);
pub const GTHR_E_INVALID_START_PAGE = @as(i32, -2147218095);
pub const GTHR_E_DUPLICATE_PROJECT = @as(i32, -2147218094);
pub const GTHR_E_INVALID_DIRECTORY = @as(i32, -2147218093);
pub const GTHR_E_FILTER_INTERRUPTED = @as(i32, -2147218092);
pub const GTHR_E_INVALID_PROXY_PORT = @as(i32, -2147218091);
pub const GTHR_S_CONFIG_HAS_ACCOUNTS = @as(i32, 265558);
pub const GTHR_E_SECRET_NOT_FOUND = @as(i32, -2147218089);
pub const GTHR_E_INVALID_PATH_EXPRESSION = @as(i32, -2147218088);
pub const GTHR_E_INVALID_START_PAGE_HOST = @as(i32, -2147218087);
pub const GTHR_E_INVALID_START_PAGE_PATH = @as(i32, -2147218080);
pub const GTHR_E_APPLICATION_NOT_FOUND = @as(i32, -2147218079);
pub const GTHR_E_CANNOT_REMOVE_PLUGINMGR = @as(i32, -2147218078);
pub const GTHR_E_INVALID_APPLICATION_NAME = @as(i32, -2147218077);
pub const GTHR_E_FILTER_FAULT = @as(i32, -2147218075);
pub const GTHR_E_NON_FIXED_DRIVE = @as(i32, -2147218074);
pub const GTHR_S_PROB_NOT_MODIFIED = @as(i32, 265575);
pub const GTHR_S_CRAWL_SCHEDULED = @as(i32, 265576);
pub const GTHR_S_TRANSACTION_IGNORED = @as(i32, 265577);
pub const GTHR_S_START_FILTER_FROM_PROTOCOL = @as(i32, 265578);
pub const GTHR_E_FILTER_SINGLE_THREADED = @as(i32, -2147218069);
pub const GTHR_S_BAD_FILE_LINK = @as(i32, 265580);
pub const GTHR_E_URL_UNIDENTIFIED = @as(i32, -2147218067);
pub const GTHR_S_NOT_ALL_PARTS = @as(i32, 265582);
pub const GTHR_E_FORCE_NOTIFICATION_RESET = @as(i32, -2147218065);
pub const GTHR_S_END_PROCESS_LOOP_NOTIFY_QUEUE = @as(i32, 265584);
pub const GTHR_S_START_FILTER_FROM_BODY = @as(i32, 265585);
pub const GTHR_E_CONTENT_ID_CONFLICT = @as(i32, -2147218062);
pub const GTHR_E_UNABLE_TO_READ_EXCHANGE_STORE = @as(i32, -2147218061);
pub const GTHR_E_RECOVERABLE_EXOLEDB_ERROR = @as(i32, -2147218060);
pub const GTHR_E_INVALID_CALL_FROM_WBREAKER = @as(i32, -2147218058);
pub const GTHR_E_PROPERTY_LIST_NOT_INITIALIZED = @as(i32, -2147218057);
pub const GTHR_S_MODIFIED_PARTS = @as(i32, 265592);
pub const GHTR_E_LOCAL_SERVER_UNAVAILABLE = @as(i32, -2147218055);
pub const GTHR_E_SCHEMA_ERRORS_OCCURRED = @as(i32, -2147218054);
pub const GTHR_E_TIMEOUT = @as(i32, -2147218053);
pub const GTHR_S_CRAWL_FULL = @as(i32, 265603);
pub const GTHR_S_CRAWL_INCREMENTAL = @as(i32, 265604);
pub const GTHR_S_CRAWL_ADAPTIVE = @as(i32, 265605);
pub const GTHR_E_NOTIFICATION_START_ADDRESS_INVALID = @as(i32, -2147218042);
pub const GTHR_E_NOTIFICATION_TYPE_NOT_SUPPORTED = @as(i32, -2147218041);
pub const GTHR_E_NOTIFICATION_FILE_SHARE_INFO_NOT_AVAILABLE = @as(i32, -2147218040);
pub const GTHR_E_NOTIFICATION_LOCAL_PATH_MUST_USE_FIXED_DRIVE = @as(i32, -2147218039);
pub const GHTR_E_INSUFFICIENT_DISK_SPACE = @as(i32, -2147218037);
pub const GTHR_E_INVALID_RESOURCE_ID = @as(i32, -2147218035);
pub const GTHR_E_NESTED_HIERARCHICAL_START_ADDRESSES = @as(i32, -2147218034);
pub const GTHR_S_NO_INDEX = @as(i32, 265616);
pub const GTHR_S_PAUSE_REASON_EXTERNAL = @as(i32, 265618);
pub const GTHR_S_PAUSE_REASON_UPGRADING = @as(i32, 265619);
pub const GTHR_S_PAUSE_REASON_BACKOFF = @as(i32, 265620);
pub const GTHR_E_RETRY = @as(i32, -2147218027);
pub const GTHR_E_JET_BACKUP_ERROR = @as(i32, -2147218026);
pub const GTHR_E_JET_RESTORE_ERROR = @as(i32, -2147218025);
pub const GTHR_S_OFFICE_CHILD = @as(i32, 265626);
pub const GTHR_E_PLUGIN_NOT_REGISTERED = @as(i32, -2147218021);
pub const GTHR_E_NOTIF_ACCESS_TOKEN_UPDATED = @as(i32, -2147218020);
pub const GTHR_E_DIRMON_NOT_INITIALZED = @as(i32, -2147218019);
pub const GTHR_E_NOTIF_BEING_REMOVED = @as(i32, -2147218018);
pub const GTHR_E_NOTIF_EXCESSIVE_THROUGHPUT = @as(i32, -2147218017);
pub const GTHR_E_INVALID_PATH_SPEC = @as(i32, -2147218016);
pub const GTHR_E_INSUFFICIENT_FEATURE_TERMS = @as(i32, -2147218015);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_CATEGORIES = @as(i32, -2147218014);
pub const GTHR_E_INSUFFICIENT_EXAMPLE_DOCUMENTS = @as(i32, -2147218013);
pub const GTHR_E_AUTOCAT_UNEXPECTED = @as(i32, -2147218012);
pub const GTHR_E_SINGLE_THREADED_EMBEDDING = @as(i32, -2147218011);
pub const GTHR_S_CANNOT_WORDBREAK = @as(i32, 265638);
pub const GTHR_S_USE_MIME_FILTER = @as(i32, 265639);
pub const GTHR_E_FOLDER_CRAWLED_BY_ANOTHER_WORKSPACE = @as(i32, -2147218007);
pub const GTHR_E_EMPTY_DACL = @as(i32, -2147218006);
pub const GTHR_E_OBJECT_NOT_VALID = @as(i32, -2147218005);
pub const GTHR_E_CANNOT_ENABLE_CHECKPOINT = @as(i32, -2147218002);
pub const GTHR_E_SCOPES_EXCEEDED = @as(i32, -2147218001);
pub const GTHR_E_PROPERTIES_EXCEEDED = @as(i32, -2147218000);
pub const GTHR_E_INVALID_START_ADDRESS = @as(i32, -2147217998);
pub const GTHR_S_PAUSE_REASON_PROFILE_IMPORT = @as(i32, 265651);
pub const GTHR_E_PIPE_NOT_CONNECTTED = @as(i32, -2147217996);
pub const GTHR_E_BACKUP_VALIDATION_FAIL = @as(i32, -2147217994);
pub const GTHR_E_BAD_FILTER_HOST = @as(i32, -2147217993);
pub const GTHR_E_NTF_CLIENT_NOT_SUBSCRIBED = @as(i32, -1073476167);
pub const GTHR_E_FILTERPOOL_NOTFOUND = @as(i32, -2147217990);
pub const GTHR_E_ADDLINKS_FAILED_WILL_RETRY_PARENT = @as(i32, -2147217989);
pub const IDX_E_INVALIDTAG = @as(i32, -2147217151);
pub const IDX_E_METAFILE_CORRUPT = @as(i32, -2147217150);
pub const IDX_E_TOO_MANY_SEARCH_SERVERS = @as(i32, -2147217149);
pub const IDX_E_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, -2147217148);
pub const IDX_E_BUILD_IN_PROGRESS = @as(i32, -2147217147);
pub const IDX_E_IDXLSTFILE_CORRUPT = @as(i32, -2147217146);
pub const IDX_E_REGISTRY_ENTRY = @as(i32, -2147217145);
pub const IDX_E_OBJECT_NOT_FOUND = @as(i32, -2147217144);
pub const IDX_E_SEARCH_SERVER_NOT_FOUND = @as(i32, -2147217143);
pub const IDX_E_WB_NOTFOUND = @as(i32, -2147217142);
pub const IDX_E_NOISELIST_NOTFOUND = @as(i32, -2147217141);
pub const IDX_E_STEMMER_NOTFOUND = @as(i32, -2147217140);
pub const IDX_E_PROP_STOPPED = @as(i32, -2147217139);
pub const IDX_E_DISKFULL = @as(i32, -2147217138);
pub const IDX_E_INVALID_INDEX = @as(i32, -2147217137);
pub const IDX_E_CORRUPT_INDEX = @as(i32, -2147217136);
pub const IDX_E_PROPSTORE_INIT_FAILED = @as(i32, -2147217134);
pub const IDX_E_PROP_STATE_CORRUPT = @as(i32, -2147217133);
pub const IDX_S_NO_BUILD_IN_PROGRESS = @as(i32, 266516);
pub const IDX_S_SEARCH_SERVER_ALREADY_EXISTS = @as(i32, 266517);
pub const IDX_S_SEARCH_SERVER_DOES_NOT_EXIST = @as(i32, 266518);
pub const IDX_E_NOT_LOADED = @as(i32, -2147217129);
pub const IDX_E_PROP_MAJOR_VERSION_MISMATCH = @as(i32, -2147217128);
pub const IDX_E_PROP_MINOR_VERSION_MISMATCH = @as(i32, -2147217127);
pub const IDX_E_DSS_NOT_CONNECTED = @as(i32, -2147217126);
pub const IDX_E_DOCUMENT_ABORTED = @as(i32, -2147217125);
pub const IDX_E_CATALOG_DISMOUNTED = @as(i32, -2147217124);
pub const IDX_S_DSS_NOT_AVAILABLE = @as(i32, 266525);
pub const IDX_E_USE_DEFAULT_CONTENTCLASS = @as(i32, -2147217121);
pub const IDX_E_USE_APPGLOBAL_PROPTABLE = @as(i32, -2147217120);
pub const JPS_E_JET_ERR = @as(i32, -2147217025);
pub const JPS_S_DUPLICATE_DOC_DETECTED = @as(i32, 266624);
pub const JPS_E_CATALOG_DECSRIPTION_MISSING = @as(i32, -2147217023);
pub const JPS_E_MISSING_INFORMATION = @as(i32, -2147217022);
pub const JPS_E_INSUFFICIENT_VERSION_STORAGE = @as(i32, -2147217021);
pub const JPS_E_INSUFFICIENT_DATABASE_SESSIONS = @as(i32, -2147217020);
pub const JPS_E_INSUFFICIENT_DATABASE_RESOURCES = @as(i32, -2147217019);
pub const JPS_E_SCHEMA_ERROR = @as(i32, -2147217018);
pub const JPS_E_PROPAGATION_FILE = @as(i32, -2147217017);
pub const JPS_E_PROPAGATION_CORRUPTION = @as(i32, -2147217016);
pub const JPS_E_PROPAGATION_VERSION_MISMATCH = @as(i32, -2147217015);
pub const JPS_E_SHARING_VIOLATION = @as(i32, -2147217014);
pub const EXCI_E_NO_CONFIG = @as(i32, -2147216992);
pub const EXCI_E_INVALID_SERVER_CONFIG = @as(i32, -2147216991);
pub const EXCI_E_ACCESS_DENIED = @as(i32, -2147216990);
pub const EXCI_E_INVALID_EXCHANGE_SERVER = @as(i32, -2147216989);
pub const EXCI_E_BADCONFIG_OR_ACCESSDENIED = @as(i32, -2147216988);
pub const EXCI_E_WRONG_SERVER_OR_ACCT = @as(i32, -2147216987);
pub const EXCI_E_NOT_ADMIN_OR_WRONG_SITE = @as(i32, -2147216986);
pub const EXCI_E_NO_MAPI = @as(i32, -2147216985);
pub const EXCI_E_INVALID_ACCOUNT_INFO = @as(i32, -2147216984);
pub const PRTH_E_INTERNAL_ERROR = @as(i32, -2147216892);
pub const PRTH_S_MAX_GROWTH = @as(i32, 266761);
pub const PRTH_E_WININET = @as(i32, -2147216886);
pub const PRTH_E_RETRY = @as(i32, -2147216885);
pub const PRTH_S_MAX_DOWNLOAD = @as(i32, 266764);
pub const PRTH_E_MIME_EXCLUDED = @as(i32, -2147216883);
pub const PRTH_E_CANT_TRANSFORM_EXTERNAL_ACL = @as(i32, -2147216882);
pub const PRTH_E_CANT_TRANSFORM_DENIED_ACE = @as(i32, -2147216881);
pub const PRTH_E_NO_PROPERTY = @as(i32, -2147216877);
pub const PRTH_S_USE_ROSEBUD = @as(i32, 266772);
pub const PRTH_E_DATABASE_OPEN_ERROR = @as(i32, -2147216875);
pub const PRTH_E_OPLOCK_BROKEN = @as(i32, -2147216874);
pub const PRTH_E_LOAD_FAILED = @as(i32, -2147216873);
pub const PRTH_E_INIT_FAILED = @as(i32, -2147216872);
pub const PRTH_E_VOLUME_MOUNT_POINT = @as(i32, -2147216871);
pub const PRTH_E_TRUNCATED = @as(i32, -2147216870);
pub const GTHR_E_LOCAL_GROUPS_EXPANSION_INTERNAL_ERROR = @as(i32, -2147216867);
pub const PRTH_E_HTTPS_CERTIFICATE_ERROR = @as(i32, -2147216861);
pub const PRTH_E_HTTPS_REQUIRE_CERTIFICATE = @as(i32, -2147216860);
pub const PRTH_S_TRY_IMPERSONATING = @as(i32, 266789);
pub const CMDLINE_E_UNEXPECTED = @as(i32, -2147216127);
pub const CMDLINE_E_PAREN = @as(i32, -2147216126);
pub const CMDLINE_E_PARAM_SIZE = @as(i32, -2147216125);
pub const CMDLINE_E_NOT_INIT = @as(i32, -2147216124);
pub const CMDLINE_E_ALREADY_INIT = @as(i32, -2147216123);
pub const CMDLINE_E_NUM_PARAMS = @as(i32, -2147216122);
pub const NLADMIN_E_DUPLICATE_CATALOG = @as(i32, -2147215103);
pub const NLADMIN_S_NOT_ALL_BUILD_CATALOGS_INITIALIZED = @as(i32, 268546);
pub const NLADMIN_E_FAILED_TO_GIVE_ACCOUNT_PRIVILEGE = @as(i32, -2147215101);
pub const NLADMIN_E_BUILD_CATALOG_NOT_INITIALIZED = @as(i32, -2147215100);
pub const SCRIPTPI_E_CHUNK_NOT_TEXT = @as(i32, -2147213312);
pub const SCRIPTPI_E_PID_NOT_NAME = @as(i32, -2147213311);
pub const SCRIPTPI_E_PID_NOT_NUMERIC = @as(i32, -2147213310);
pub const SCRIPTPI_E_CHUNK_NOT_VALUE = @as(i32, -2147213309);
pub const SCRIPTPI_E_CANNOT_ALTER_CHUNK = @as(i32, -2147213308);
pub const SCRIPTPI_E_ALREADY_COMPLETED = @as(i32, -2147213307);
pub const _MAPI_E_NO_SUPPORT = @as(i32, -2147221246);
pub const _MAPI_E_BAD_CHARWIDTH = @as(i32, -2147221245);
pub const _MAPI_E_STRING_TOO_LONG = @as(i32, -2147221243);
pub const _MAPI_E_UNKNOWN_FLAGS = @as(i32, -2147221242);
pub const _MAPI_E_INVALID_ENTRYID = @as(i32, -2147221241);
pub const _MAPI_E_INVALID_OBJECT = @as(i32, -2147221240);
pub const _MAPI_E_OBJECT_CHANGED = @as(i32, -2147221239);
pub const _MAPI_E_OBJECT_DELETED = @as(i32, -2147221238);
pub const _MAPI_E_BUSY = @as(i32, -2147221237);
pub const _MAPI_E_NOT_ENOUGH_DISK = @as(i32, -2147221235);
pub const _MAPI_E_NOT_ENOUGH_RESOURCES = @as(i32, -2147221234);
pub const _MAPI_E_NOT_FOUND = @as(i32, -2147221233);
pub const _MAPI_E_VERSION = @as(i32, -2147221232);
pub const _MAPI_E_LOGON_FAILED = @as(i32, -2147221231);
pub const _MAPI_E_SESSION_LIMIT = @as(i32, -2147221230);
pub const _MAPI_E_USER_CANCEL = @as(i32, -2147221229);
pub const _MAPI_E_UNABLE_TO_ABORT = @as(i32, -2147221228);
pub const _MAPI_E_NETWORK_ERROR = @as(i32, -2147221227);
pub const _MAPI_E_DISK_ERROR = @as(i32, -2147221226);
pub const _MAPI_E_TOO_COMPLEX = @as(i32, -2147221225);
pub const _MAPI_E_BAD_COLUMN = @as(i32, -2147221224);
pub const _MAPI_E_EXTENDED_ERROR = @as(i32, -2147221223);
pub const _MAPI_E_COMPUTED = @as(i32, -2147221222);
pub const _MAPI_E_CORRUPT_DATA = @as(i32, -2147221221);
pub const _MAPI_E_UNCONFIGURED = @as(i32, -2147221220);
pub const _MAPI_E_FAILONEPROVIDER = @as(i32, -2147221219);
pub const _MAPI_E_UNKNOWN_CPID = @as(i32, -2147221218);
pub const _MAPI_E_UNKNOWN_LCID = @as(i32, -2147221217);
pub const _MAPI_E_PASSWORD_CHANGE_REQUIRED = @as(i32, -2147221216);
pub const _MAPI_E_PASSWORD_EXPIRED = @as(i32, -2147221215);
pub const _MAPI_E_INVALID_WORKSTATION_ACCOUNT = @as(i32, -2147221214);
pub const _MAPI_E_INVALID_ACCESS_TIME = @as(i32, -2147221213);
pub const _MAPI_E_ACCOUNT_DISABLED = @as(i32, -2147221212);
pub const _MAPI_E_END_OF_SESSION = @as(i32, -2147220992);
pub const _MAPI_E_UNKNOWN_ENTRYID = @as(i32, -2147220991);
pub const _MAPI_E_MISSING_REQUIRED_COLUMN = @as(i32, -2147220990);
pub const _MAPI_W_NO_SERVICE = @as(i32, 262659);
pub const MSG_TEST_MESSAGE = @as(i32, 1074008064);
pub const FLTRDMN_E_UNEXPECTED = @as(i32, -2147212287);
pub const FLTRDMN_E_QI_FILTER_FAILED = @as(i32, -2147212286);
pub const FLTRDMN_E_FILTER_INIT_FAILED = @as(i32, -2147212284);
pub const FLTRDMN_E_ENCRYPTED_DOCUMENT = @as(i32, -2147212283);
pub const FLTRDMN_E_CANNOT_DECRYPT_PASSWORD = @as(i32, -2147212282);
pub const OLEDB_BINDER_CUSTOM_ERROR = @as(i32, -2147212032);
pub const NOTESPH_E_UNEXPECTED_STATE = @as(i32, -2147211775);
pub const NOTESPH_S_IGNORE_ID = @as(i32, 271874);
pub const NOTESPH_E_UNSUPPORTED_CONTENT_FIELD_TYPE = @as(i32, -2147211773);
pub const NOTESPH_E_ITEM_NOT_FOUND = @as(i32, -2147211772);
pub const NOTESPH_E_SERVER_CONFIG = @as(i32, -2147211771);
pub const NOTESPH_E_ATTACHMENTS = @as(i32, -2147211770);
pub const NOTESPH_E_NO_NTID = @as(i32, -2147211769);
pub const NOTESPH_E_DB_ACCESS_DENIED = @as(i32, -2147211768);
pub const NOTESPH_E_NOTESSETUP_ID_MAPPING_ERROR = @as(i32, -2147211767);
pub const NOTESPH_S_LISTKNOWNFIELDS = @as(i32, 271888);
pub const NOTESPH_E_FAIL = @as(i32, -2147211759);
pub const STS_ABORTXMLPARSE = @as(i32, -2147211756);
pub const STS_WS_ERROR = @as(i32, -2147211754);
pub const SPS_WS_ERROR = @as(i32, -2147211753);
pub const EXSTOREPH_E_UNEXPECTED = @as(i32, -2147211519);
pub const CERT_E_NOT_FOUND_OR_NO_PERMISSSION = @as(i32, -2147211263);
pub const SRCH_SCHEMA_CACHE_E_UNEXPECTED = @as(i32, -2147208447);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_READ = @as(i32, -2147208191);
pub const CONTENT_SOURCE_E_UNEXPECTED_NULL_POINTER = @as(i32, -2147208190);
pub const CONTENT_SOURCE_E_PROPERTY_MAPPING_BAD_VECTOR_SIZE = @as(i32, -2147208189);
pub const CONTENT_SOURCE_E_CONTENT_CLASS_READ = @as(i32, -2147208188);
pub const CONTENT_SOURCE_E_UNEXPECTED_EXCEPTION = @as(i32, -2147208187);
pub const CONTENT_SOURCE_E_NULL_CONTENT_CLASS_BSTR = @as(i32, -2147208186);
pub const CONTENT_SOURCE_E_CONTENT_SOURCE_COLUMN_TYPE = @as(i32, -2147208185);
pub const CONTENT_SOURCE_E_OUT_OF_RANGE = @as(i32, -2147208184);
pub const CONTENT_SOURCE_E_NULL_URI = @as(i32, -2147208183);
pub const REXSPH_E_INVALID_CALL = @as(i32, -2147207936);
pub const REXSPH_S_REDIRECTED = @as(i32, 275713);
pub const REXSPH_E_REDIRECT_ON_SECURITY_UPDATE = @as(i32, -2147207934);
pub const REXSPH_E_MULTIPLE_REDIRECT = @as(i32, -2147207933);
pub const REXSPH_E_NO_PROPERTY_ON_ROW = @as(i32, -2147207932);
pub const REXSPH_E_TYPE_MISMATCH_ON_READ = @as(i32, -2147207931);
pub const REXSPH_E_UNEXPECTED_DATA_STATUS = @as(i32, -2147207930);
pub const REXSPH_E_UNKNOWN_DATA_TYPE = @as(i32, -2147207929);
pub const REXSPH_E_UNEXPECTED_FILTER_STATE = @as(i32, -2147207928);
pub const REXSPH_E_DUPLICATE_PROPERTY = @as(i32, -2147207927);
pub const PEOPLE_IMPORT_E_DBCONNFAIL = @as(i32, -2147205120);
pub const PEOPLE_IMPORT_NODSDEFINED = @as(i32, -2147205119);
pub const PEOPLE_IMPORT_E_FAILTOGETDSDEF = @as(i32, -2147205118);
pub const PEOPLE_IMPORT_NOMAPPINGDEFINED = @as(i32, -2147205117);
pub const PEOPLE_IMPORT_E_FAILTOGETDSMAPPING = @as(i32, -2147205116);
pub const PEOPLE_IMPORT_E_DATATYPENOTSUPPORTED = @as(i32, -2147205115);
pub const PEOPLE_IMPORT_E_NOCASTINGSUPPORTED = @as(i32, -2147205114);
pub const PEOPLE_IMPORT_E_UPDATE_DIRSYNC_COOKIE = @as(i32, -2147205113);
pub const PEOPLE_IMPORT_E_DIRSYNC_ZERO_COOKIE = @as(i32, -2147205112);
pub const PEOPLE_IMPORT_E_LDAPPATH_TOOLONG = @as(i32, -2147205111);
pub const PEOPLE_IMPORT_E_CANONICALURL_TOOLONG = @as(i32, -2147205110);
pub const PEOPLE_IMPORT_E_USERNAME_NOTRESOLVED = @as(i32, -2147205109);
pub const PEOPLE_IMPORT_E_DC_NOT_AVAILABLE = @as(i32, -2147205108);
pub const PEOPLE_IMPORT_E_DOMAIN_DISCOVER_FAILED = @as(i32, -2147205107);
pub const PEOPLE_IMPORT_E_FAILTOGETLCID = @as(i32, -2147205106);
pub const PEOPLE_IMPORT_E_DOMAIN_REMOVED = @as(i32, -2147205105);
pub const PEOPLE_IMPORT_E_ENUM_ACCESSDENIED = @as(i32, -2147205104);
pub const PEOPLE_IMPORT_E_DIRSYNC_NOTREFRESHED = @as(i32, -2147205103);
pub const FTE_E_SECRET_NOT_FOUND = @as(i32, -2147207678);
pub const FTE_E_PIPE_NOT_CONNECTED = @as(i32, -2147207677);
pub const FTE_E_ADMIN_BLOB_CORRUPT = @as(i32, -2147207676);
pub const FTE_E_FILTER_SINGLE_THREADED = @as(i32, -2147207675);
pub const FTE_E_ERROR_WRITING_REGISTRY = @as(i32, -2147207674);
pub const FTE_E_PROJECT_SHUTDOWN = @as(i32, -2147207673);
pub const FTE_E_PROJECT_NOT_INITALIZED = @as(i32, -2147207672);
pub const FTE_E_PIPE_DATA_CORRUPTED = @as(i32, -2147207671);
pub const FTE_E_URB_TOO_BIG = @as(i32, -2147207664);
pub const FTE_E_INVALID_DOCID = @as(i32, -2147207663);
pub const FTE_E_PAUSE_EXTERNAL = @as(i32, -2147207662);
pub const FTE_E_REJECTED_DUE_TO_PROJECT_STATUS = @as(i32, -2147207661);
pub const FTE_E_FD_DID_NOT_CONNECT = @as(i32, -2147207660);
pub const FTE_E_PROGID_REQUIRED = @as(i32, -2147207658);
pub const FTE_E_STATIC_THREAD_INVALID_ARGUMENTS = @as(i32, -2147207657);
pub const FTE_E_CATALOG_ALREADY_EXISTS = @as(i32, -2147207656);
pub const FTE_S_RESOURCES_STARTING_TO_GET_LOW = @as(i32, 275993);
pub const FTE_E_PATH_TOO_LONG = @as(i32, -2147207654);
pub const FTE_INVALID_ADMIN_CLIENT = @as(i32, -2147207653);
pub const FTE_E_COM_SIGNATURE_VALIDATION = @as(i32, -2147207652);
pub const FTE_E_AFFINITY_MASK = @as(i32, -2147207651);
pub const FTE_E_FD_OWNERSHIP_OBSOLETE = @as(i32, -2147207650);
pub const FTE_E_EXCEEDED_MAX_PLUGINS = @as(i32, -2147207647);
pub const FTE_S_BEYOND_QUOTA = @as(i32, 276002);
pub const FTE_E_DUPLICATE_OBJECT = @as(i32, -2147207644);
pub const FTE_S_REDUNDANT = @as(i32, 276005);
pub const FTE_E_REDUNDANT_TRAN_FAILURE = @as(i32, -2147207642);
pub const FTE_E_DEPENDENT_TRAN_FAILED_TO_PERSIST = @as(i32, -2147207641);
pub const FTE_E_FD_SHUTDOWN = @as(i32, -2147207640);
pub const FTE_E_CATALOG_DOES_NOT_EXIST = @as(i32, -2147207639);
pub const FTE_E_NO_PLUGINS = @as(i32, -2147207638);
pub const FTE_S_STATUS_CHANGE_REQUEST = @as(i32, 276011);
pub const FTE_E_BATCH_ABORTED = @as(i32, -2147207636);
pub const FTE_E_ANOTHER_STATUS_CHANGE_IS_ALREADY_ACTIVE = @as(i32, -2147207635);
pub const FTE_S_RESUME = @as(i32, 276014);
pub const FTE_E_NOT_PROCESSED_DUE_TO_PREVIOUS_ERRORS = @as(i32, -2147207633);
pub const FTE_E_FD_TIMEOUT = @as(i32, -2147207632);
pub const FTE_E_RESOURCE_SHUTDOWN = @as(i32, -2147207631);
pub const FTE_E_INVALID_PROPERTY = @as(i32, -2147207630);
pub const FTE_E_NO_MORE_PROPERTIES = @as(i32, -2147207629);
pub const FTE_E_UNKNOWN_PLUGIN = @as(i32, -2147207628);
pub const FTE_E_LIBRARY_NOT_LOADED = @as(i32, -2147207627);
pub const FTE_E_PERFMON_FULL = @as(i32, -2147207626);
pub const FTE_E_FAILED_TO_CREATE_ACCESSOR = @as(i32, -2147207625);
pub const FTE_E_INVALID_TYPE = @as(i32, -2147207624);
pub const FTE_E_OUT_OF_RANGE = @as(i32, -2147207623);
pub const FTE_E_CORRUPT_PROPERTY_STORE = @as(i32, -2147207622);
pub const FTE_E_PROPERTY_STORE_WORKID_NOTVALID = @as(i32, -2147207621);
pub const FTE_S_PROPERTY_STORE_END_OF_ENUMERATION = @as(i32, 276028);
pub const FTE_E_CORRUPT_GATHERER_HASH_MAP = @as(i32, -2147207619);
pub const FTE_E_KEY_NOT_CACHED = @as(i32, -2147207618);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_SHUTDOWN = @as(i32, -2147207617);
pub const FTE_E_UPGRADE_INTERFACE_ALREADY_INSTANTIATED = @as(i32, -2147207616);
pub const FTE_E_STACK_CORRUPTED = @as(i32, -2147207615);
pub const FTE_E_INVALID_PROG_ID = @as(i32, -2147207614);
pub const FTE_E_SERIAL_STREAM_CORRUPT = @as(i32, -2147207613);
pub const FTE_E_READONLY_CATALOG = @as(i32, -2147207612);
pub const FTE_E_PERF_NOT_LOADED = @as(i32, -2147207611);
pub const FTE_S_READONLY_CATALOG = @as(i32, 276038);
pub const FTE_E_RETRY_HUGE_DOC = @as(i32, -2147207608);
pub const FTE_E_UNKNOWN_FD_TYPE = @as(i32, -2147207607);
pub const FTE_E_DOC_TOO_HUGE = @as(i32, -2147207606);
pub const FTE_E_DATATYPE_MISALIGNMENT = @as(i32, -2147207605);
pub const FTE_E_ALREADY_INITIALIZED = @as(i32, -2147207604);
pub const FTE_E_FD_USED_TOO_MUCH_MEMORY = @as(i32, -2147207603);
pub const FTE_E_UNEXPECTED_EXIT = @as(i32, -2147207602);
pub const FTE_E_HIGH_MEMORY_PRESSURE = @as(i32, -2147207601);
pub const FTE_E_INVALID_ISOLATE_ERROR_BATCH = @as(i32, -2147207600);
pub const FTE_E_RETRY_SINGLE_DOC_PER_BATCH = @as(i32, -2147207599);
pub const FTE_E_INVALID_PROJECT_ID = @as(i32, -2147207598);
pub const FTE_E_FAILURE_TO_POST_SETCOMPLETION_STATUS = @as(i32, -2147207597);
pub const FTE_E_INVALID_CODEPAGE = @as(i32, -2147207596);
pub const FTE_E_FD_IDLE = @as(i32, -2147207595);
pub const FTE_E_FD_UNRESPONSIVE = @as(i32, -2147207594);
pub const FTE_S_TRY_TO_FLUSH = @as(i32, 276055);
pub const FTE_S_CATALOG_BLOB_MISMATCHED = @as(i32, 276056);
pub const FTE_S_PROPERTY_RESET = @as(i32, 276057);
pub const FTE_E_NO_PROPERTY_STORE = @as(i32, -1073465766);
pub const FTE_E_CB_OUT_OF_MEMORY = @as(i32, -2147169536);
pub const FTE_E_CB_CBID_OUT_OF_BOUND = @as(i32, -2147169535);
pub const FTE_E_CB_NOT_ENOUGH_AVAIL_PHY_MEM = @as(i32, -2147169534);
pub const FTE_E_CB_NOT_ENOUGH_OCC_BUFFER = @as(i32, -2147169533);
pub const FTE_E_CORRUPT_WORDLIST = @as(i32, -2147169532);
pub const FTE_E_FD_NO_IPERSIST_INTERFACE = @as(i32, -2147156736);
pub const FTE_E_FD_IFILTER_INIT_FAILED = @as(i32, -2147156735);
pub const FTE_E_FD_FAILED_TO_LOAD_IFILTER = @as(i32, -2147156734);
pub const FTE_E_FD_DOC_TIMEOUT = @as(i32, -2147156733);
pub const FTE_E_FD_UNEXPECTED_EXIT = @as(i32, -2147156732);
pub const FTE_E_FD_DOC_UNEXPECTED_EXIT = @as(i32, -2147156731);
pub const FTE_E_FD_NOISE_NO_TEXT_FILTER = @as(i32, -2147156730);
pub const FTE_E_FD_NOISE_NO_IPERSISTSTREAM_ON_TEXT_FILTER = @as(i32, -2147156729);
pub const FTE_E_FD_NOISE_TEXT_FILTER_LOAD_FAILED = @as(i32, -2147156728);
pub const FTE_E_FD_NOISE_TEXT_FILTER_INIT_FAILED = @as(i32, -2147156727);
pub const FTE_E_FD_OCCURRENCE_OVERFLOW = @as(i32, -2147156726);
pub const FTE_E_FD_FILTER_CAUSED_SHARING_VIOLATION = @as(i32, -2147156725);
pub const ERROR_SOURCE_PROTHNDLR = @as(u32, 4608);
pub const QUERY_E_ALLNOISE_AND_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215859));
pub const QUERY_E_NO_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215858));
pub const QUERY_E_ALLNOISE_AND_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215857));
pub const QUERY_E_NO_RELPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215856));
pub const QUERY_E_REPEATED_RELDOC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215855));
pub const QUERY_E_RELDOC_SYNTAX_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215854));
pub const QUERY_E_INVALID_DOCUMENT_IDENTIFIER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215853));
pub const QUERY_E_INCORRECT_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215852));
pub const QUERY_E_INVALIDSCOPE_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215851));
pub const QUERY_E_INVALIDSORT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215850));
pub const QUERY_E_INVALIDCOALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215849));
pub const QUERY_E_UPGRADEINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215848));
pub const QUERY_E_AGGREGATE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215847));
pub const QUERY_E_TOP_LEVEL_IN_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215846));
pub const QUERY_E_DUPLICATE_RANGE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215845));
pub const CI_S_NEW_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268329));
pub const CI_E_NO_AUXMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215318));
pub const CI_S_CLIENT_REQUESTED_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268331));
pub const CI_S_RETRY_DOCUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268332));
pub const CI_E_CORRUPT_FWIDX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473491));
pub const CI_E_DIACRITIC_SETTINGS_DIFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473490));
pub const CI_E_INVALID_CATALOG_LIST_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147215313));
pub const CI_S_CATALOG_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 268336));
pub const CI_E_NO_CATALOG_MANAGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473487));
pub const CI_E_INCONSISTENT_TRANSACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473486));
pub const CI_E_PROTECTED_CATALOG_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473485));
pub const CI_E_NO_PROTECTED_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473484));
pub const CI_E_MULTIPLE_PROTECTED_USERS_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473483));
pub const CI_E_PROTECTED_CATALOG_SID_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473482));
pub const CI_E_PROTECTED_CATALOG_NON_INTERACTIVE_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073473481));
pub const MSG_CI_MASTER_MERGE_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745926));
pub const MSG_CI_MASTER_MERGE_COMPLETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745927));
pub const MSG_CI_MASTER_MERGE_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745928));
pub const MSG_CI_MASTER_MERGE_CANT_START = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737719));
pub const MSG_CI_MASTER_MERGE_CANT_RESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073737718));
pub const MSG_CI_MASTER_MERGE_RESTARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745945));
pub const MSG_CI_CORRUPT_INDEX_COMPONENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745962));
pub const MSG_CI_MASTER_MERGE_ABORTED_LOW_DISK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745987));
pub const MSG_CI_MASTER_MERGE_REASON_EXTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745988));
pub const MSG_CI_MASTER_MERGE_REASON_INDEX_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745989));
pub const MSG_CI_MASTER_MERGE_REASON_EXPECTED_DOCS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745990));
pub const MSG_CI_MASTER_MERGE_REASON_NUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1073745991));
pub const MSG_CI_CREATE_SEVER_ITEM_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479480));
pub const NOT_N_PARSE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 526638));
pub const IDS_MON_DEFAULT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264495));
pub const IDS_MON_ILLEGAL_PASSTHROUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264496));
pub const IDS_MON_PARSE_ERR_1_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264497));
pub const IDS_MON_PARSE_ERR_2_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264498));
pub const IDS_MON_SEMI_COLON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264499));
pub const IDS_MON_ORDINAL_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264500));
pub const IDS_MON_VIEW_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264501));
pub const IDS_MON_COLUMN_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264502));
pub const IDS_MON_BUILTIN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264503));
pub const IDS_MON_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264504));
pub const IDS_MON_SELECT_STAR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264505));
pub const IDS_MON_OR_NOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264506));
pub const IDS_MON_CANNOT_CONVERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264507));
pub const IDS_MON_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264508));
pub const IDS_MON_RELATIVE_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264509));
pub const IDS_MON_NOT_COLUMN_OF_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264510));
pub const IDS_MON_BUILTIN_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264511));
pub const IDS_MON_WEIGHT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264512));
pub const IDS_MON_MATCH_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264513));
pub const IDS_MON_PROPERTY_NAME_IN_VIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264514));
pub const IDS_MON_VIEW_ALREADY_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264515));
pub const IDS_MON_INVALID_CATALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264516));
pub const IDS_MON_INVALIDSELECT_COALESCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264517));
pub const IDS_MON_CANNOT_CAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264518));
pub const IDS_MON_DATE_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264519));
pub const IDS_MON_INVALID_IN_GROUP_CLAUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 264520));
pub const DBPROPSET_MSDAORA_ROWSET = Guid.initString("e8cc4cbd-fdff-11d0-b865-00a0c9081c1d");
pub const DBPROPSET_MSDAORA8_ROWSET = Guid.initString("7f06a375-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDASQL = Guid.initString("c8b522cb-5cf3-11ce-ade5-00aa0044773d");
pub const CLSID_MSDASQL_ENUMERATOR = Guid.initString("c8b522cd-5cf3-11ce-ade5-00aa0044773d");
pub const DBPROPSET_PROVIDERDATASOURCEINFO = Guid.initString("497c60e0-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERROWSET = Guid.initString("497c60e1-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERDBINIT = Guid.initString("497c60e2-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERSTMTATTR = Guid.initString("497c60e3-7123-11cf-b171-00aa0057599e");
pub const DBPROPSET_PROVIDERCONNATTR = Guid.initString("497c60e4-7123-11cf-b171-00aa0057599e");
pub const CLSID_DataShapeProvider = Guid.initString("3449a1c8-c56c-11d0-ad72-00c04fc29863");
pub const DBPROPSET_MSDSDBINIT = Guid.initString("55cb91a8-5c7a-11d1-adad-00c04fc29863");
pub const DBPROPSET_MSDSSESSION = Guid.initString("edf17536-afbf-11d1-8847-0000f879f98c");
pub const CLSID_MSPersist = Guid.initString("7c07e0d0-4418-11d2-9212-00c04fbbbfb3");
pub const DBPROPSET_PERSIST = Guid.initString("4d7839a0-5b8e-11d1-a6b3-00a0c9138c66");
pub const PROGID_MSPersist_W = "MSPersist";
pub const PROGID_MSPersist_Version_W = "MSPersist.1";
pub const CLSID_SQLOLEDB = Guid.initString("0c7ff16c-38e3-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ERROR = Guid.initString("c0932c62-38e5-11d0-97ab-00c04fc2ad98");
pub const CLSID_SQLOLEDB_ENUMERATOR = Guid.initString("dfa22b8e-e68d-11d0-97e4-00c04fc2ad98");
pub const DBGUID_MSSQLXML = Guid.initString("5d531cb2-e6ed-11d2-b252-00c04f681b71");
pub const DBGUID_XPATH = Guid.initString("ec2a4293-e898-11d2-b1b7-00c04f680c56");
pub const DBSCHEMA_LINKEDSERVERS = Guid.initString("9093caf4-2eac-11d1-9809-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCE = Guid.initString("28efaee4-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERDATASOURCEINFO = Guid.initString("df10cb94-35f6-11d2-9c54-00c04f7971d3");
pub const DBPROPSET_SQLSERVERDBINIT = Guid.initString("5cf4ca10-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERROWSET = Guid.initString("5cf4ca11-ef21-11d0-97e7-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERSESSION = Guid.initString("28efaee5-2d2c-11d1-9807-00c04fc2ad98");
pub const DBPROPSET_SQLSERVERCOLUMN = Guid.initString("3b63fb5e-3fbb-11d3-9f29-00c04f8ee9dc");
pub const DBPROPSET_SQLSERVERSTREAM = Guid.initString("9f79c073-8a6d-4bca-a8a8-c9b79a9b962d");

//--------------------------------------------------------------------------------
// Section: Types (437)
//--------------------------------------------------------------------------------
pub const IRowsetExactScroll = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IWordSink_Value = Guid.initString("cc907054-c058-101a-b554-08002b33b0e6");
pub const IID_IWordSink = &IID_IWordSink_Value;
pub const IWordSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutWord: *const fn (
            self: *const IWordSink,
            cwc: u32,
            pwc_in_buf: ?[*:0]const u16,
            cwc_src_len: u32,
            cwc_src_pos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutAltWord: *const fn (
            self: *const IWordSink,
            cwc: u32,
            pwc_in_buf: ?[*:0]const u16,
            cwc_src_len: u32,
            cwc_src_pos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartAltPhrase: *const fn (
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndAltPhrase: *const fn (
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutBreak: *const fn (
            self: *const IWordSink,
            break_type: WORDREP_BREAK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putWord(self: *const T, cwc_: u32, pwc_in_buf_: ?[*:0]const u16, cwc_src_len_: u32, cwc_src_pos_: u32) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IWordSink, @ptrCast(self)), cwc_, pwc_in_buf_, cwc_src_len_, cwc_src_pos_);
            }
            pub inline fn putAltWord(self: *const T, cwc_: u32, pwc_in_buf_: ?[*:0]const u16, cwc_src_len_: u32, cwc_src_pos_: u32) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IWordSink, @ptrCast(self)), cwc_, pwc_in_buf_, cwc_src_len_, cwc_src_pos_);
            }
            pub inline fn startAltPhrase(self: *const T) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).StartAltPhrase(@as(*const IWordSink, @ptrCast(self)));
            }
            pub inline fn endAltPhrase(self: *const T) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).EndAltPhrase(@as(*const IWordSink, @ptrCast(self)));
            }
            pub inline fn putBreak(self: *const T, break_type_: WORDREP_BREAK_TYPE) HRESULT {
                return @as(*const IWordSink.VTable, @ptrCast(self.vtable)).PutBreak(@as(*const IWordSink, @ptrCast(self)), break_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PFNFILLTEXTBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const TEXT_SOURCE = extern struct {
    pfnFillTextBuffer: ?PFNFILLTEXTBUFFER,
    awcBuffer: ?[*:0]const u16,
    iEnd: u32,
    iCur: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordBreaker_Value = Guid.initString("d53552c8-77e3-101a-b552-08002b33b0e6");
pub const IID_IWordBreaker = &IID_IWordBreaker_Value;
pub const IWordBreaker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const IWordBreaker,
            f_query: BOOL,
            ul_max_token_size: u32,
            pf_license: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BreakText: *const fn (
            self: *const IWordBreaker,
            p_text_source: ?*TEXT_SOURCE,
            p_word_sink: ?*IWordSink,
            p_phrase_sink: ?*IPhraseSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposePhrase: *const fn (
            self: *const IWordBreaker,
            pwc_noun: ?[*:0]const u16,
            cwc_noun: u32,
            pwc_modifier: ?[*:0]const u16,
            cwc_modifier: u32,
            ul_attachment_type: u32,
            pwc_phrase: ?PWSTR,
            pcwc_phrase: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: *const fn (
            self: *const IWordBreaker,
            ppwcs_license: ?*const ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, f_query_: BOOL, ul_max_token_size_: u32, pf_license_: ?*BOOL) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).Init(@as(*const IWordBreaker, @ptrCast(self)), f_query_, ul_max_token_size_, pf_license_);
            }
            pub inline fn breakText(self: *const T, p_text_source_: ?*TEXT_SOURCE, p_word_sink_: ?*IWordSink, p_phrase_sink_: ?*IPhraseSink) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).BreakText(@as(*const IWordBreaker, @ptrCast(self)), p_text_source_, p_word_sink_, p_phrase_sink_);
            }
            pub inline fn composePhrase(self: *const T, pwc_noun_: ?[*:0]const u16, cwc_noun_: u32, pwc_modifier_: ?[*:0]const u16, cwc_modifier_: u32, ul_attachment_type_: u32, pwc_phrase_: ?PWSTR, pcwc_phrase_: ?*u32) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).ComposePhrase(@as(*const IWordBreaker, @ptrCast(self)), pwc_noun_, cwc_noun_, pwc_modifier_, cwc_modifier_, ul_attachment_type_, pwc_phrase_, pcwc_phrase_);
            }
            pub inline fn getLicenseToUse(self: *const T, ppwcs_license_: ?*const ?*u16) HRESULT {
                return @as(*const IWordBreaker.VTable, @ptrCast(self.vtable)).GetLicenseToUse(@as(*const IWordBreaker, @ptrCast(self)), ppwcs_license_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWordFormSink_Value = Guid.initString("fe77c330-7f42-11ce-be57-00aa0051fe20");
pub const IID_IWordFormSink = &IID_IWordFormSink_Value;
pub const IWordFormSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: *const fn (
            self: *const IWordFormSink,
            pwc_in_buf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutWord: *const fn (
            self: *const IWordFormSink,
            pwc_in_buf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putAltWord(self: *const T, pwc_in_buf_: ?[*:0]const u16, cwc_: u32) HRESULT {
                return @as(*const IWordFormSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IWordFormSink, @ptrCast(self)), pwc_in_buf_, cwc_);
            }
            pub inline fn putWord(self: *const T, pwc_in_buf_: ?[*:0]const u16, cwc_: u32) HRESULT {
                return @as(*const IWordFormSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IWordFormSink, @ptrCast(self)), pwc_in_buf_, cwc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStemmer_Value = Guid.initString("efbaf140-7f42-11ce-be57-00aa0051fe20");
pub const IID_IStemmer = &IID_IStemmer_Value;
pub const IStemmer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const IStemmer,
            ul_max_token_size: u32,
            pf_license: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateWordForms: *const fn (
            self: *const IStemmer,
            pwc_in_buf: ?[*:0]const u16,
            cwc: u32,
            p_stem_sink: ?*IWordFormSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: *const fn (
            self: *const IStemmer,
            ppwcs_license: ?*const ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, ul_max_token_size_: u32, pf_license_: ?*BOOL) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).Init(@as(*const IStemmer, @ptrCast(self)), ul_max_token_size_, pf_license_);
            }
            pub inline fn generateWordForms(self: *const T, pwc_in_buf_: ?[*:0]const u16, cwc_: u32, p_stem_sink_: ?*IWordFormSink) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).GenerateWordForms(@as(*const IStemmer, @ptrCast(self)), pwc_in_buf_, cwc_, p_stem_sink_);
            }
            pub inline fn getLicenseToUse(self: *const T, ppwcs_license_: ?*const ?*u16) HRESULT {
                return @as(*const IStemmer.VTable, @ptrCast(self.vtable)).GetLicenseToUse(@as(*const IStemmer, @ptrCast(self)), ppwcs_license_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleCommandCreator_Value = Guid.initString("5e341ab7-02d0-11d1-900c-00a0c9063796");
pub const IID_ISimpleCommandCreator = &IID_ISimpleCommandCreator_Value;
pub const ISimpleCommandCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateICommand: *const fn (
            self: *const ISimpleCommandCreator,
            pp_i_unknown: ?*?*IUnknown,
            p_outer_unk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VerifyCatalog: *const fn (
            self: *const ISimpleCommandCreator,
            pwsz_machine: ?[*:0]const u16,
            pwsz_catalog_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultCatalog: *const fn (
            self: *const ISimpleCommandCreator,
            pwsz_catalog_name: ?PWSTR,
            cwc_in: u32,
            pcwc_out: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createICommand(self: *const T, pp_i_unknown_: ?*?*IUnknown, p_outer_unk_: ?*IUnknown) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).CreateICommand(@as(*const ISimpleCommandCreator, @ptrCast(self)), pp_i_unknown_, p_outer_unk_);
            }
            pub inline fn verifyCatalog(self: *const T, pwsz_machine_: ?[*:0]const u16, pwsz_catalog_name_: ?[*:0]const u16) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).VerifyCatalog(@as(*const ISimpleCommandCreator, @ptrCast(self)), pwsz_machine_, pwsz_catalog_name_);
            }
            pub inline fn getDefaultCatalog(self: *const T, pwsz_catalog_name_: ?PWSTR, cwc_in_: u32, pcwc_out_: ?*u32) HRESULT {
                return @as(*const ISimpleCommandCreator.VTable, @ptrCast(self.vtable)).GetDefaultCatalog(@as(*const ISimpleCommandCreator, @ptrCast(self)), pwsz_catalog_name_, cwc_in_, pcwc_out_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapper_Value = Guid.initString("0b63e37a-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapper = &IID_IColumnMapper_Value;
pub const IColumnMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropInfoFromName: *const fn (
            self: *const IColumnMapper,
            wcs_prop_name: ?[*:0]const u16,
            pp_prop_id: ?*?*DBID,
            p_prop_type: ?*u16,
            pui_width: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropInfoFromId: *const fn (
            self: *const IColumnMapper,
            p_prop_id: ?*const DBID,
            pwcs_name: ?*?*u16,
            p_prop_type: ?*u16,
            pui_width: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPropInfo: *const fn (
            self: *const IColumnMapper,
            i_entry: u32,
            pwcs_name: ?*const ?*u16,
            pp_prop_id: ?*?*DBID,
            p_prop_type: ?*u16,
            pui_width: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMapUpToDate: *const fn (
            self: *const IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPropInfoFromName(self: *const T, wcs_prop_name_: ?[*:0]const u16, pp_prop_id_: ?*?*DBID, p_prop_type_: ?*u16, pui_width_: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).GetPropInfoFromName(@as(*const IColumnMapper, @ptrCast(self)), wcs_prop_name_, pp_prop_id_, p_prop_type_, pui_width_);
            }
            pub inline fn getPropInfoFromId(self: *const T, p_prop_id_: ?*const DBID, pwcs_name_: ?*?*u16, p_prop_type_: ?*u16, pui_width_: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).GetPropInfoFromId(@as(*const IColumnMapper, @ptrCast(self)), p_prop_id_, pwcs_name_, p_prop_type_, pui_width_);
            }
            pub inline fn enumPropInfo(self: *const T, i_entry_: u32, pwcs_name_: ?*const ?*u16, pp_prop_id_: ?*?*DBID, p_prop_type_: ?*u16, pui_width_: ?*u32) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).EnumPropInfo(@as(*const IColumnMapper, @ptrCast(self)), i_entry_, pwcs_name_, pp_prop_id_, p_prop_type_, pui_width_);
            }
            pub inline fn isMapUpToDate(self: *const T) HRESULT {
                return @as(*const IColumnMapper.VTable, @ptrCast(self.vtable)).IsMapUpToDate(@as(*const IColumnMapper, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapperCreator_Value = Guid.initString("0b63e37b-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IColumnMapperCreator = &IID_IColumnMapperCreator_Value;
pub const IColumnMapperCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnMapper: *const fn (
            self: *const IColumnMapperCreator,
            wcs_machine_name: ?[*:0]const u16,
            wcs_catalog_name: ?[*:0]const u16,
            pp_column_mapper: ?*?*IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getColumnMapper(self: *const T, wcs_machine_name_: ?[*:0]const u16, wcs_catalog_name_: ?[*:0]const u16, pp_column_mapper_: ?*?*IColumnMapper) HRESULT {
                return @as(*const IColumnMapperCreator.VTable, @ptrCast(self.vtable)).GetColumnMapper(@as(*const IColumnMapperCreator, @ptrCast(self)), wcs_machine_name_, wcs_catalog_name_, pp_column_mapper_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchManager_Value = Guid.initString("7d096c5f-ac08-4f1f-beb7-5c22c517ce39");
pub const CLSID_CSearchManager = &CLSID_CSearchManager_Value;

const CLSID_CSearchRoot_Value = Guid.initString("30766bd2-ea1c-4f28-bf27-0b44e2f68db7");
pub const CLSID_CSearchRoot = &CLSID_CSearchRoot_Value;

const CLSID_CSearchScopeRule_Value = Guid.initString("e63de750-3bd7-4be5-9c84-6b4281988c44");
pub const CLSID_CSearchScopeRule = &CLSID_CSearchScopeRule_Value;

const CLSID_FilterRegistration_Value = Guid.initString("9e175b8d-f52a-11d8-b9a5-505054503030");
pub const CLSID_FilterRegistration = &CLSID_FilterRegistration_Value;

pub const FILTERED_DATA_SOURCES = extern struct {
    pwcsExtension: ?[*:0]const u16,
    pwcsMime: ?[*:0]const u16,
    pClsid: ?*const Guid,
    pwcsOverride: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ILoadFilter_Value = Guid.initString("c7310722-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ILoadFilter = &IID_ILoadFilter_Value;
pub const ILoadFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadIFilter: *const fn (
            self: *const ILoadFilter,
            pwcs_path: ?[*:0]const u16,
            p_filtered_sources: ?*FILTERED_DATA_SOURCES,
            p_unk_outer: ?*IUnknown,
            f_use_default: BOOL,
            p_filter_clsid: ?*Guid,
            search_dec_size: ?*i32,
            pwcs_search_desc: ?*?*u16,
            pp_i_filt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStorage: *const fn (
            self: *const ILoadFilter,
            p_stg: ?*IStorage,
            p_unk_outer: ?*IUnknown,
            pwcs_override: ?[*:0]const u16,
            f_use_default: BOOL,
            p_filter_clsid: ?*Guid,
            search_dec_size: ?*i32,
            pwcs_search_desc: ?*?*u16,
            pp_i_filt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStream: *const fn (
            self: *const ILoadFilter,
            p_stm: ?*IStream,
            p_filtered_sources: ?*FILTERED_DATA_SOURCES,
            p_unk_outer: ?*IUnknown,
            f_use_default: BOOL,
            p_filter_clsid: ?*Guid,
            search_dec_size: ?*i32,
            pwcs_search_desc: ?*?*u16,
            pp_i_filt: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn loadIFilter(self: *const T, pwcs_path_: ?[*:0]const u16, p_filtered_sources_: ?*FILTERED_DATA_SOURCES, p_unk_outer_: ?*IUnknown, f_use_default_: BOOL, p_filter_clsid_: ?*Guid, search_dec_size_: ?*i32, pwcs_search_desc_: ?*?*u16, pp_i_filt_: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilter(@as(*const ILoadFilter, @ptrCast(self)), pwcs_path_, p_filtered_sources_, p_unk_outer_, f_use_default_, p_filter_clsid_, search_dec_size_, pwcs_search_desc_, pp_i_filt_);
            }
            pub inline fn loadIFilterFromStorage(self: *const T, p_stg_: ?*IStorage, p_unk_outer_: ?*IUnknown, pwcs_override_: ?[*:0]const u16, f_use_default_: BOOL, p_filter_clsid_: ?*Guid, search_dec_size_: ?*i32, pwcs_search_desc_: ?*?*u16, pp_i_filt_: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilterFromStorage(@as(*const ILoadFilter, @ptrCast(self)), p_stg_, p_unk_outer_, pwcs_override_, f_use_default_, p_filter_clsid_, search_dec_size_, pwcs_search_desc_, pp_i_filt_);
            }
            pub inline fn loadIFilterFromStream(self: *const T, p_stm_: ?*IStream, p_filtered_sources_: ?*FILTERED_DATA_SOURCES, p_unk_outer_: ?*IUnknown, f_use_default_: BOOL, p_filter_clsid_: ?*Guid, search_dec_size_: ?*i32, pwcs_search_desc_: ?*?*u16, pp_i_filt_: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilter.VTable, @ptrCast(self.vtable)).LoadIFilterFromStream(@as(*const ILoadFilter, @ptrCast(self)), p_stm_, p_filtered_sources_, p_unk_outer_, f_use_default_, p_filter_clsid_, search_dec_size_, pwcs_search_desc_, pp_i_filt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ILoadFilterWithPrivateComActivation_Value = Guid.initString("40bdbd34-780b-48d3-9bb6-12ebd4ad2e75");
pub const IID_ILoadFilterWithPrivateComActivation = &IID_ILoadFilterWithPrivateComActivation_Value;
pub const ILoadFilterWithPrivateComActivation = extern struct {
    pub const VTable = extern struct {
        base: ILoadFilter.VTable,
        LoadIFilterWithPrivateComActivation: *const fn (
            self: *const ILoadFilterWithPrivateComActivation,
            filtered_sources: ?*FILTERED_DATA_SOURCES,
            use_default: BOOL,
            filter_clsid: ?*Guid,
            is_filter_private_com_activated: ?*BOOL,
            filter_obj: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ILoadFilter.MethodMixin(T);
            pub inline fn loadIFilterWithPrivateComActivation(self: *const T, filtered_sources_: ?*FILTERED_DATA_SOURCES, use_default_: BOOL, filter_clsid_: ?*Guid, is_filter_private_com_activated_: ?*BOOL, filter_obj_: ?*?*IFilter) HRESULT {
                return @as(*const ILoadFilterWithPrivateComActivation.VTable, @ptrCast(self.vtable)).LoadIFilterWithPrivateComActivation(@as(*const ILoadFilterWithPrivateComActivation, @ptrCast(self)), filtered_sources_, use_default_, filter_clsid_, is_filter_private_com_activated_, filter_obj_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRichChunk_Value = Guid.initString("4fdef69c-dbc9-454e-9910-b34f3c64b510");
pub const IID_IRichChunk = &IID_IRichChunk_Value;
pub const IRichChunk = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn (
            self: *const IRichChunk,
            p_first_pos: ?*u32,
            p_length: ?*u32,
            ppsz: ?*?PWSTR,
            p_value: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getData(self: *const T, p_first_pos_: ?*u32, p_length_: ?*u32, ppsz_: ?*?PWSTR, p_value_: ?*PROPVARIANT) HRESULT {
                return @as(*const IRichChunk.VTable, @ptrCast(self.vtable)).GetData(@as(*const IRichChunk, @ptrCast(self)), p_first_pos_, p_length_, ppsz_, p_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICondition_Value = Guid.initString("0fc988d4-c935-4b97-a973-46282ea175c8");
pub const IID_ICondition = &IID_ICondition_Value;
pub const ICondition = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        GetConditionType: *const fn (
            self: *const ICondition,
            p_node_type: ?*CONDITION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubConditions: *const fn (
            self: *const ICondition,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComparisonInfo: *const fn (
            self: *const ICondition,
            ppsz_property_name: ?*?PWSTR,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueType: *const fn (
            self: *const ICondition,
            ppsz_value_type_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueNormalization: *const fn (
            self: *const ICondition,
            ppsz_normalization: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputTerms: *const fn (
            self: *const ICondition,
            pp_property_term: ?*?*IRichChunk,
            pp_operation_term: ?*?*IRichChunk,
            pp_value_term: ?*?*IRichChunk,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ICondition,
            ppc: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistStream.MethodMixin(T);
            pub inline fn getConditionType(self: *const T, p_node_type_: ?*CONDITION_TYPE) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetConditionType(@as(*const ICondition, @ptrCast(self)), p_node_type_);
            }
            pub inline fn getSubConditions(self: *const T, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetSubConditions(@as(*const ICondition, @ptrCast(self)), riid_, ppv_);
            }
            pub inline fn getComparisonInfo(self: *const T, ppsz_property_name_: ?*?PWSTR, pcop_: ?*CONDITION_OPERATION, ppropvar_: ?*PROPVARIANT) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetComparisonInfo(@as(*const ICondition, @ptrCast(self)), ppsz_property_name_, pcop_, ppropvar_);
            }
            pub inline fn getValueType(self: *const T, ppsz_value_type_name_: ?*?PWSTR) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetValueType(@as(*const ICondition, @ptrCast(self)), ppsz_value_type_name_);
            }
            pub inline fn getValueNormalization(self: *const T, ppsz_normalization_: ?*?PWSTR) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetValueNormalization(@as(*const ICondition, @ptrCast(self)), ppsz_normalization_);
            }
            pub inline fn getInputTerms(self: *const T, pp_property_term_: ?*?*IRichChunk, pp_operation_term_: ?*?*IRichChunk, pp_value_term_: ?*?*IRichChunk) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).GetInputTerms(@as(*const ICondition, @ptrCast(self)), pp_property_term_, pp_operation_term_, pp_value_term_);
            }
            pub inline fn clone(self: *const T, ppc_: ?*?*ICondition) HRESULT {
                return @as(*const ICondition.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICondition, @ptrCast(self)), ppc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICondition2_Value = Guid.initString("0db8851d-2e5b-47eb-9208-d28c325a01d7");
pub const IID_ICondition2 = &IID_ICondition2_Value;
pub const ICondition2 = extern struct {
    pub const VTable = extern struct {
        base: ICondition.VTable,
        GetLocale: *const fn (
            self: *const ICondition2,
            ppsz_locale_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeafConditionInfo: *const fn (
            self: *const ICondition2,
            ppropkey: ?*PROPERTYKEY,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICondition.MethodMixin(T);
            pub inline fn getLocale(self: *const T, ppsz_locale_name_: ?*?PWSTR) HRESULT {
                return @as(*const ICondition2.VTable, @ptrCast(self.vtable)).GetLocale(@as(*const ICondition2, @ptrCast(self)), ppsz_locale_name_);
            }
            pub inline fn getLeafConditionInfo(self: *const T, ppropkey_: ?*PROPERTYKEY, pcop_: ?*CONDITION_OPERATION, ppropvar_: ?*PROPVARIANT) HRESULT {
                return @as(*const ICondition2.VTable, @ptrCast(self.vtable)).GetLeafConditionInfo(@as(*const ICondition2, @ptrCast(self)), ppropkey_, pcop_, ppropvar_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DB_NUMERIC = extern struct {
    precision: u8,
    scale: u8,
    sign: u8,
    val: [16]u8,
};

pub const DBDATE = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const DBTIME = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const DB_VARNUMERIC = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [1]u8,
};

pub const DBTYPEENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    I2 = 2,
    I4 = 3,
    R4 = 4,
    R8 = 5,
    CY = 6,
    DATE = 7,
    BSTR = 8,
    IDISPATCH = 9,
    ERROR = 10,
    BOOL = 11,
    VARIANT = 12,
    IUNKNOWN = 13,
    DECIMAL = 14,
    UI1 = 17,
    ARRAY = 8192,
    BYREF = 16384,
    I1 = 16,
    UI2 = 18,
    UI4 = 19,
    I8 = 20,
    UI8 = 21,
    GUID = 72,
    VECTOR = 4096,
    RESERVED = 32768,
    BYTES = 128,
    STR = 129,
    WSTR = 130,
    NUMERIC = 131,
    UDT = 132,
    DBDATE = 133,
    DBTIME = 134,
    DBTIMESTAMP = 135,
};
pub const DBTYPE_EMPTY = DBTYPEENUM.EMPTY;
pub const DBTYPE_NULL = DBTYPEENUM.NULL;
pub const DBTYPE_I2 = DBTYPEENUM.I2;
pub const DBTYPE_I4 = DBTYPEENUM.I4;
pub const DBTYPE_R4 = DBTYPEENUM.R4;
pub const DBTYPE_R8 = DBTYPEENUM.R8;
pub const DBTYPE_CY = DBTYPEENUM.CY;
pub const DBTYPE_DATE = DBTYPEENUM.DATE;
pub const DBTYPE_BSTR = DBTYPEENUM.BSTR;
pub const DBTYPE_IDISPATCH = DBTYPEENUM.IDISPATCH;
pub const DBTYPE_ERROR = DBTYPEENUM.ERROR;
pub const DBTYPE_BOOL = DBTYPEENUM.BOOL;
pub const DBTYPE_VARIANT = DBTYPEENUM.VARIANT;
pub const DBTYPE_IUNKNOWN = DBTYPEENUM.IUNKNOWN;
pub const DBTYPE_DECIMAL = DBTYPEENUM.DECIMAL;
pub const DBTYPE_UI1 = DBTYPEENUM.UI1;
pub const DBTYPE_ARRAY = DBTYPEENUM.ARRAY;
pub const DBTYPE_BYREF = DBTYPEENUM.BYREF;
pub const DBTYPE_I1 = DBTYPEENUM.I1;
pub const DBTYPE_UI2 = DBTYPEENUM.UI2;
pub const DBTYPE_UI4 = DBTYPEENUM.UI4;
pub const DBTYPE_I8 = DBTYPEENUM.I8;
pub const DBTYPE_UI8 = DBTYPEENUM.UI8;
pub const DBTYPE_GUID = DBTYPEENUM.GUID;
pub const DBTYPE_VECTOR = DBTYPEENUM.VECTOR;
pub const DBTYPE_RESERVED = DBTYPEENUM.RESERVED;
pub const DBTYPE_BYTES = DBTYPEENUM.BYTES;
pub const DBTYPE_STR = DBTYPEENUM.STR;
pub const DBTYPE_WSTR = DBTYPEENUM.WSTR;
pub const DBTYPE_NUMERIC = DBTYPEENUM.NUMERIC;
pub const DBTYPE_UDT = DBTYPEENUM.UDT;
pub const DBTYPE_DBDATE = DBTYPEENUM.DBDATE;
pub const DBTYPE_DBTIME = DBTYPEENUM.DBTIME;
pub const DBTYPE_DBTIMESTAMP = DBTYPEENUM.DBTIMESTAMP;

pub const DBTYPEENUM15 = enum(i32) {
    R = 136,
};
pub const DBTYPE_HCHAPTER = DBTYPEENUM15.R;

pub const DBTYPEENUM20 = enum(i32) {
    FILETIME = 64,
    PROPVARIANT = 138,
    VARNUMERIC = 139,
};
pub const DBTYPE_FILETIME = DBTYPEENUM20.FILETIME;
pub const DBTYPE_PROPVARIANT = DBTYPEENUM20.PROPVARIANT;
pub const DBTYPE_VARNUMERIC = DBTYPEENUM20.VARNUMERIC;

pub const DBPARTENUM = enum(i32) {
    INVALID = 0,
    VALUE = 1,
    LENGTH = 2,
    STATUS = 4,
};
pub const DBPART_INVALID = DBPARTENUM.INVALID;
pub const DBPART_VALUE = DBPARTENUM.VALUE;
pub const DBPART_LENGTH = DBPARTENUM.LENGTH;
pub const DBPART_STATUS = DBPARTENUM.STATUS;

pub const DBPARAMIOENUM = enum(i32) {
    NOTPARAM = 0,
    INPUT = 1,
    OUTPUT = 2,
};
pub const DBPARAMIO_NOTPARAM = DBPARAMIOENUM.NOTPARAM;
pub const DBPARAMIO_INPUT = DBPARAMIOENUM.INPUT;
pub const DBPARAMIO_OUTPUT = DBPARAMIOENUM.OUTPUT;

pub const DBBINDFLAGENUM = enum(i32) {
    L = 1,
};
pub const DBBINDFLAG_HTML = DBBINDFLAGENUM.L;

pub const DBMEMOWNERENUM = enum(i32) {
    CLIENTOWNED = 0,
    PROVIDEROWNED = 1,
};
pub const DBMEMOWNER_CLIENTOWNED = DBMEMOWNERENUM.CLIENTOWNED;
pub const DBMEMOWNER_PROVIDEROWNED = DBMEMOWNERENUM.PROVIDEROWNED;

pub const DBSTATUSENUM = enum(i32) {
    S_OK = 0,
    E_BADACCESSOR = 1,
    E_CANTCONVERTVALUE = 2,
    S_ISNULL = 3,
    S_TRUNCATED = 4,
    E_SIGNMISMATCH = 5,
    E_DATAOVERFLOW = 6,
    E_CANTCREATE = 7,
    E_UNAVAILABLE = 8,
    E_PERMISSIONDENIED = 9,
    E_INTEGRITYVIOLATION = 10,
    E_SCHEMAVIOLATION = 11,
    E_BADSTATUS = 12,
    S_DEFAULT = 13,
};
pub const DBSTATUS_S_OK = DBSTATUSENUM.S_OK;
pub const DBSTATUS_E_BADACCESSOR = DBSTATUSENUM.E_BADACCESSOR;
pub const DBSTATUS_E_CANTCONVERTVALUE = DBSTATUSENUM.E_CANTCONVERTVALUE;
pub const DBSTATUS_S_ISNULL = DBSTATUSENUM.S_ISNULL;
pub const DBSTATUS_S_TRUNCATED = DBSTATUSENUM.S_TRUNCATED;
pub const DBSTATUS_E_SIGNMISMATCH = DBSTATUSENUM.E_SIGNMISMATCH;
pub const DBSTATUS_E_DATAOVERFLOW = DBSTATUSENUM.E_DATAOVERFLOW;
pub const DBSTATUS_E_CANTCREATE = DBSTATUSENUM.E_CANTCREATE;
pub const DBSTATUS_E_UNAVAILABLE = DBSTATUSENUM.E_UNAVAILABLE;
pub const DBSTATUS_E_PERMISSIONDENIED = DBSTATUSENUM.E_PERMISSIONDENIED;
pub const DBSTATUS_E_INTEGRITYVIOLATION = DBSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBSTATUS_E_SCHEMAVIOLATION = DBSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBSTATUS_E_BADSTATUS = DBSTATUSENUM.E_BADSTATUS;
pub const DBSTATUS_S_DEFAULT = DBSTATUSENUM.S_DEFAULT;

pub const DBSTATUSENUM20 = enum(i32) {
    MDSTATUS_S_CELLEMPTY = 14,
    DBSTATUS_S_IGNORE = 15,
};
pub const MDSTATUS_S_CELLEMPTY = DBSTATUSENUM20.MDSTATUS_S_CELLEMPTY;
pub const DBSTATUS_S_IGNORE = DBSTATUSENUM20.DBSTATUS_S_IGNORE;

pub const DBSTATUSENUM21 = enum(i32) {
    E_DOESNOTEXIST = 16,
    E_INVALIDURL = 17,
    E_RESOURCELOCKED = 18,
    E_RESOURCEEXISTS = 19,
    E_CANNOTCOMPLETE = 20,
    E_VOLUMENOTFOUND = 21,
    E_OUTOFSPACE = 22,
    S_CANNOTDELETESOURCE = 23,
    E_READONLY = 24,
    E_RESOURCEOUTOFSCOPE = 25,
    S_ALREADYEXISTS = 26,
};
pub const DBSTATUS_E_DOESNOTEXIST = DBSTATUSENUM21.E_DOESNOTEXIST;
pub const DBSTATUS_E_INVALIDURL = DBSTATUSENUM21.E_INVALIDURL;
pub const DBSTATUS_E_RESOURCELOCKED = DBSTATUSENUM21.E_RESOURCELOCKED;
pub const DBSTATUS_E_RESOURCEEXISTS = DBSTATUSENUM21.E_RESOURCEEXISTS;
pub const DBSTATUS_E_CANNOTCOMPLETE = DBSTATUSENUM21.E_CANNOTCOMPLETE;
pub const DBSTATUS_E_VOLUMENOTFOUND = DBSTATUSENUM21.E_VOLUMENOTFOUND;
pub const DBSTATUS_E_OUTOFSPACE = DBSTATUSENUM21.E_OUTOFSPACE;
pub const DBSTATUS_S_CANNOTDELETESOURCE = DBSTATUSENUM21.S_CANNOTDELETESOURCE;
pub const DBSTATUS_E_READONLY = DBSTATUSENUM21.E_READONLY;
pub const DBSTATUS_E_RESOURCEOUTOFSCOPE = DBSTATUSENUM21.E_RESOURCEOUTOFSCOPE;
pub const DBSTATUS_S_ALREADYEXISTS = DBSTATUSENUM21.S_ALREADYEXISTS;

pub const DBBINDURLFLAGENUM = enum(i32) {
    READ = 1,
    WRITE = 2,
    READWRITE = 3,
    SHARE_DENY_READ = 4,
    SHARE_DENY_WRITE = 8,
    SHARE_EXCLUSIVE = 12,
    SHARE_DENY_NONE = 16,
    ASYNCHRONOUS = 4096,
    COLLECTION = 8192,
    DELAYFETCHSTREAM = 16384,
    DELAYFETCHCOLUMNS = 32768,
    RECURSIVE = 4194304,
    OUTPUT = 8388608,
    WAITFORINIT = 16777216,
    OPENIFEXISTS = 33554432,
    OVERWRITE = 67108864,
    ISSTRUCTUREDDOCUMENT = 134217728,
};
pub const DBBINDURLFLAG_READ = DBBINDURLFLAGENUM.READ;
pub const DBBINDURLFLAG_WRITE = DBBINDURLFLAGENUM.WRITE;
pub const DBBINDURLFLAG_READWRITE = DBBINDURLFLAGENUM.READWRITE;
pub const DBBINDURLFLAG_SHARE_DENY_READ = DBBINDURLFLAGENUM.SHARE_DENY_READ;
pub const DBBINDURLFLAG_SHARE_DENY_WRITE = DBBINDURLFLAGENUM.SHARE_DENY_WRITE;
pub const DBBINDURLFLAG_SHARE_EXCLUSIVE = DBBINDURLFLAGENUM.SHARE_EXCLUSIVE;
pub const DBBINDURLFLAG_SHARE_DENY_NONE = DBBINDURLFLAGENUM.SHARE_DENY_NONE;
pub const DBBINDURLFLAG_ASYNCHRONOUS = DBBINDURLFLAGENUM.ASYNCHRONOUS;
pub const DBBINDURLFLAG_COLLECTION = DBBINDURLFLAGENUM.COLLECTION;
pub const DBBINDURLFLAG_DELAYFETCHSTREAM = DBBINDURLFLAGENUM.DELAYFETCHSTREAM;
pub const DBBINDURLFLAG_DELAYFETCHCOLUMNS = DBBINDURLFLAGENUM.DELAYFETCHCOLUMNS;
pub const DBBINDURLFLAG_RECURSIVE = DBBINDURLFLAGENUM.RECURSIVE;
pub const DBBINDURLFLAG_OUTPUT = DBBINDURLFLAGENUM.OUTPUT;
pub const DBBINDURLFLAG_WAITFORINIT = DBBINDURLFLAGENUM.WAITFORINIT;
pub const DBBINDURLFLAG_OPENIFEXISTS = DBBINDURLFLAGENUM.OPENIFEXISTS;
pub const DBBINDURLFLAG_OVERWRITE = DBBINDURLFLAGENUM.OVERWRITE;
pub const DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT = DBBINDURLFLAGENUM.ISSTRUCTUREDDOCUMENT;

pub const DBBINDURLSTATUSENUM = enum(i32) {
    OK = 0,
    DENYNOTSUPPORTED = 1,
    DENYTYPENOTSUPPORTED = 4,
    REDIRECTED = 8,
};
pub const DBBINDURLSTATUS_S_OK = DBBINDURLSTATUSENUM.OK;
pub const DBBINDURLSTATUS_S_DENYNOTSUPPORTED = DBBINDURLSTATUSENUM.DENYNOTSUPPORTED;
pub const DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED = DBBINDURLSTATUSENUM.DENYTYPENOTSUPPORTED;
pub const DBBINDURLSTATUS_S_REDIRECTED = DBBINDURLSTATUSENUM.REDIRECTED;

pub const DBSTATUSENUM25 = enum(i32) {
    CANCELED = 27,
    NOTCOLLECTION = 28,
};
pub const DBSTATUS_E_CANCELED = DBSTATUSENUM25.CANCELED;
pub const DBSTATUS_E_NOTCOLLECTION = DBSTATUSENUM25.NOTCOLLECTION;

pub const DBROWSTATUSENUM = enum(i32) {
    S_OK = 0,
    S_MULTIPLECHANGES = 2,
    S_PENDINGCHANGES = 3,
    E_CANCELED = 4,
    E_CANTRELEASE = 6,
    E_CONCURRENCYVIOLATION = 7,
    E_DELETED = 8,
    E_PENDINGINSERT = 9,
    E_NEWLYINSERTED = 10,
    E_INTEGRITYVIOLATION = 11,
    E_INVALID = 12,
    E_MAXPENDCHANGESEXCEEDED = 13,
    E_OBJECTOPEN = 14,
    E_OUTOFMEMORY = 15,
    E_PERMISSIONDENIED = 16,
    E_LIMITREACHED = 17,
    E_SCHEMAVIOLATION = 18,
    E_FAIL = 19,
};
pub const DBROWSTATUS_S_OK = DBROWSTATUSENUM.S_OK;
pub const DBROWSTATUS_S_MULTIPLECHANGES = DBROWSTATUSENUM.S_MULTIPLECHANGES;
pub const DBROWSTATUS_S_PENDINGCHANGES = DBROWSTATUSENUM.S_PENDINGCHANGES;
pub const DBROWSTATUS_E_CANCELED = DBROWSTATUSENUM.E_CANCELED;
pub const DBROWSTATUS_E_CANTRELEASE = DBROWSTATUSENUM.E_CANTRELEASE;
pub const DBROWSTATUS_E_CONCURRENCYVIOLATION = DBROWSTATUSENUM.E_CONCURRENCYVIOLATION;
pub const DBROWSTATUS_E_DELETED = DBROWSTATUSENUM.E_DELETED;
pub const DBROWSTATUS_E_PENDINGINSERT = DBROWSTATUSENUM.E_PENDINGINSERT;
pub const DBROWSTATUS_E_NEWLYINSERTED = DBROWSTATUSENUM.E_NEWLYINSERTED;
pub const DBROWSTATUS_E_INTEGRITYVIOLATION = DBROWSTATUSENUM.E_INTEGRITYVIOLATION;
pub const DBROWSTATUS_E_INVALID = DBROWSTATUSENUM.E_INVALID;
pub const DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED = DBROWSTATUSENUM.E_MAXPENDCHANGESEXCEEDED;
pub const DBROWSTATUS_E_OBJECTOPEN = DBROWSTATUSENUM.E_OBJECTOPEN;
pub const DBROWSTATUS_E_OUTOFMEMORY = DBROWSTATUSENUM.E_OUTOFMEMORY;
pub const DBROWSTATUS_E_PERMISSIONDENIED = DBROWSTATUSENUM.E_PERMISSIONDENIED;
pub const DBROWSTATUS_E_LIMITREACHED = DBROWSTATUSENUM.E_LIMITREACHED;
pub const DBROWSTATUS_E_SCHEMAVIOLATION = DBROWSTATUSENUM.E_SCHEMAVIOLATION;
pub const DBROWSTATUS_E_FAIL = DBROWSTATUSENUM.E_FAIL;

pub const DBROWSTATUSENUM20 = enum(i32) {
    E = 20,
};
pub const DBROWSTATUS_S_NOCHANGE = DBROWSTATUSENUM20.E;

pub const DBSTATUSENUM26 = enum(i32) {
    N = 29,
};
pub const DBSTATUS_S_ROWSETCOLUMN = DBSTATUSENUM26.N;

pub const DBCOLUMNFLAGSENUM = enum(i32) {
    ISBOOKMARK = 1,
    MAYDEFER = 2,
    WRITE = 4,
    WRITEUNKNOWN = 8,
    ISFIXEDLENGTH = 16,
    ISNULLABLE = 32,
    MAYBENULL = 64,
    ISLONG = 128,
    ISROWID = 256,
    ISROWVER = 512,
    CACHEDEFERRED = 4096,
};
pub const DBCOLUMNFLAGS_ISBOOKMARK = DBCOLUMNFLAGSENUM.ISBOOKMARK;
pub const DBCOLUMNFLAGS_MAYDEFER = DBCOLUMNFLAGSENUM.MAYDEFER;
pub const DBCOLUMNFLAGS_WRITE = DBCOLUMNFLAGSENUM.WRITE;
pub const DBCOLUMNFLAGS_WRITEUNKNOWN = DBCOLUMNFLAGSENUM.WRITEUNKNOWN;
pub const DBCOLUMNFLAGS_ISFIXEDLENGTH = DBCOLUMNFLAGSENUM.ISFIXEDLENGTH;
pub const DBCOLUMNFLAGS_ISNULLABLE = DBCOLUMNFLAGSENUM.ISNULLABLE;
pub const DBCOLUMNFLAGS_MAYBENULL = DBCOLUMNFLAGSENUM.MAYBENULL;
pub const DBCOLUMNFLAGS_ISLONG = DBCOLUMNFLAGSENUM.ISLONG;
pub const DBCOLUMNFLAGS_ISROWID = DBCOLUMNFLAGSENUM.ISROWID;
pub const DBCOLUMNFLAGS_ISROWVER = DBCOLUMNFLAGSENUM.ISROWVER;
pub const DBCOLUMNFLAGS_CACHEDEFERRED = DBCOLUMNFLAGSENUM.CACHEDEFERRED;

pub const DBCOLUMNFLAGSENUM20 = enum(i32) {
    SCALEISNEGATIVE = 16384,
    RESERVED = 32768,
};
pub const DBCOLUMNFLAGS_SCALEISNEGATIVE = DBCOLUMNFLAGSENUM20.SCALEISNEGATIVE;
pub const DBCOLUMNFLAGS_RESERVED = DBCOLUMNFLAGSENUM20.RESERVED;

pub const DBCOLUMNFLAGS15ENUM = enum(i32) {
    R = 8192,
};
pub const DBCOLUMNFLAGS_ISCHAPTER = DBCOLUMNFLAGS15ENUM.R;

pub const DBCOLUMNFLAGSENUM21 = enum(i32) {
    ROWURL = 65536,
    DEFAULTSTREAM = 131072,
    COLLECTION = 262144,
};
pub const DBCOLUMNFLAGS_ISROWURL = DBCOLUMNFLAGSENUM21.ROWURL;
pub const DBCOLUMNFLAGS_ISDEFAULTSTREAM = DBCOLUMNFLAGSENUM21.DEFAULTSTREAM;
pub const DBCOLUMNFLAGS_ISCOLLECTION = DBCOLUMNFLAGSENUM21.COLLECTION;

pub const DBCOLUMNFLAGSENUM26 = enum(i32) {
    ISSTREAM = 524288,
    ISROWSET = 1048576,
    ISROW = 2097152,
    ROWSPECIFICCOLUMN = 4194304,
};
pub const DBCOLUMNFLAGS_ISSTREAM = DBCOLUMNFLAGSENUM26.ISSTREAM;
pub const DBCOLUMNFLAGS_ISROWSET = DBCOLUMNFLAGSENUM26.ISROWSET;
pub const DBCOLUMNFLAGS_ISROW = DBCOLUMNFLAGSENUM26.ISROW;
pub const DBCOLUMNFLAGS_ROWSPECIFICCOLUMN = DBCOLUMNFLAGSENUM26.ROWSPECIFICCOLUMN;

pub const DBTABLESTATISTICSTYPE26 = enum(i32) {
    HISTOGRAM = 1,
    COLUMN_CARDINALITY = 2,
    TUPLE_CARDINALITY = 4,
};
pub const DBSTAT_HISTOGRAM = DBTABLESTATISTICSTYPE26.HISTOGRAM;
pub const DBSTAT_COLUMN_CARDINALITY = DBTABLESTATISTICSTYPE26.COLUMN_CARDINALITY;
pub const DBSTAT_TUPLE_CARDINALITY = DBTABLESTATISTICSTYPE26.TUPLE_CARDINALITY;

pub const DBBOOKMARK = enum(i32) {
    INVALID = 0,
    FIRST = 1,
    LAST = 2,
};
pub const DBBMK_INVALID = DBBOOKMARK.INVALID;
pub const DBBMK_FIRST = DBBOOKMARK.FIRST;
pub const DBBMK_LAST = DBBOOKMARK.LAST;

pub const DBPROPENUM = enum(i32) {
    ABORTPRESERVE = 2,
    ACTIVESESSIONS = 3,
    APPENDONLY = 187,
    ASYNCTXNABORT = 168,
    ASYNCTXNCOMMIT = 4,
    AUTH_CACHE_AUTHINFO = 5,
    AUTH_ENCRYPT_PASSWORD = 6,
    AUTH_INTEGRATED = 7,
    AUTH_MASK_PASSWORD = 8,
    AUTH_PASSWORD = 9,
    AUTH_PERSIST_ENCRYPTED = 10,
    AUTH_PERSIST_SENSITIVE_AUTHINFO = 11,
    AUTH_USERID = 12,
    BLOCKINGSTORAGEOBJECTS = 13,
    BOOKMARKS = 14,
    BOOKMARKSKIPPED = 15,
    BOOKMARKTYPE = 16,
    BYREFACCESSORS = 120,
    CACHEDEFERRED = 17,
    CANFETCHBACKWARDS = 18,
    CANHOLDROWS = 19,
    CANSCROLLBACKWARDS = 21,
    CATALOGLOCATION = 22,
    CATALOGTERM = 23,
    CATALOGUSAGE = 24,
    CHANGEINSERTEDROWS = 188,
    COL_AUTOINCREMENT = 26,
    COL_DEFAULT = 27,
    COL_DESCRIPTION = 28,
    COL_FIXEDLENGTH = 167,
    COL_NULLABLE = 29,
    COL_PRIMARYKEY = 30,
    COL_UNIQUE = 31,
    COLUMNDEFINITION = 32,
    COLUMNRESTRICT = 33,
    COMMANDTIMEOUT = 34,
    COMMITPRESERVE = 35,
    CONCATNULLBEHAVIOR = 36,
    CURRENTCATALOG = 37,
    DATASOURCENAME = 38,
    DATASOURCEREADONLY = 39,
    DBMSNAME = 40,
    DBMSVER = 41,
    DEFERRED = 42,
    DELAYSTORAGEOBJECTS = 43,
    DSOTHREADMODEL = 169,
    GROUPBY = 44,
    HETEROGENEOUSTABLES = 45,
    IAccessor = 121,
    IColumnsInfo = 122,
    IColumnsRowset = 123,
    IConnectionPointContainer = 124,
    IConvertType = 194,
    IRowset = 126,
    IRowsetChange = 127,
    IRowsetIdentity = 128,
    IRowsetIndex = 159,
    IRowsetInfo = 129,
    IRowsetLocate = 130,
    IRowsetResynch = 132,
    IRowsetScroll = 133,
    IRowsetUpdate = 134,
    ISupportErrorInfo = 135,
    ILockBytes = 136,
    ISequentialStream = 137,
    IStorage = 138,
    IStream = 139,
    IDENTIFIERCASE = 46,
    IMMOBILEROWS = 47,
    INDEX_AUTOUPDATE = 48,
    INDEX_CLUSTERED = 49,
    INDEX_FILLFACTOR = 50,
    INDEX_INITIALSIZE = 51,
    INDEX_NULLCOLLATION = 52,
    INDEX_NULLS = 53,
    INDEX_PRIMARYKEY = 54,
    INDEX_SORTBOOKMARKS = 55,
    INDEX_TEMPINDEX = 163,
    INDEX_TYPE = 56,
    INDEX_UNIQUE = 57,
    INIT_DATASOURCE = 59,
    INIT_HWND = 60,
    INIT_IMPERSONATION_LEVEL = 61,
    INIT_LCID = 186,
    INIT_LOCATION = 62,
    INIT_MODE = 63,
    INIT_PROMPT = 64,
    INIT_PROTECTION_LEVEL = 65,
    INIT_PROVIDERSTRING = 160,
    INIT_TIMEOUT = 66,
    LITERALBOOKMARKS = 67,
    LITERALIDENTITY = 68,
    MAXINDEXSIZE = 70,
    MAXOPENROWS = 71,
    MAXPENDINGROWS = 72,
    MAXROWS = 73,
    MAXROWSIZE = 74,
    MAXROWSIZEINCLUDESBLOB = 75,
    MAXTABLESINSELECT = 76,
    MAYWRITECOLUMN = 77,
    MEMORYUSAGE = 78,
    MULTIPLEPARAMSETS = 191,
    MULTIPLERESULTS = 196,
    MULTIPLESTORAGEOBJECTS = 80,
    MULTITABLEUPDATE = 81,
    NOTIFICATIONGRANULARITY = 198,
    NOTIFICATIONPHASES = 82,
    NOTIFYCOLUMNSET = 171,
    NOTIFYROWDELETE = 173,
    NOTIFYROWFIRSTCHANGE = 174,
    NOTIFYROWINSERT = 175,
    NOTIFYROWRESYNCH = 177,
    NOTIFYROWSETCHANGED = 211,
    NOTIFYROWSETRELEASE = 178,
    NOTIFYROWSETFETCHPOSITIONCHANGE = 179,
    NOTIFYROWUNDOCHANGE = 180,
    NOTIFYROWUNDODELETE = 181,
    NOTIFYROWUNDOINSERT = 182,
    NOTIFYROWUPDATE = 183,
    NULLCOLLATION = 83,
    OLEOBJECTS = 84,
    ORDERBYCOLUMNSINSELECT = 85,
    ORDEREDBOOKMARKS = 86,
    OTHERINSERT = 87,
    OTHERUPDATEDELETE = 88,
    OUTPUTPARAMETERAVAILABILITY = 184,
    OWNINSERT = 89,
    OWNUPDATEDELETE = 90,
    PERSISTENTIDTYPE = 185,
    PREPAREABORTBEHAVIOR = 91,
    PREPARECOMMITBEHAVIOR = 92,
    PROCEDURETERM = 93,
    PROVIDERNAME = 96,
    PROVIDEROLEDBVER = 97,
    PROVIDERVER = 98,
    QUICKRESTART = 99,
    QUOTEDIDENTIFIERCASE = 100,
    REENTRANTEVENTS = 101,
    REMOVEDELETED = 102,
    REPORTMULTIPLECHANGES = 103,
    RETURNPENDINGINSERTS = 189,
    ROWRESTRICT = 104,
    ROWSETCONVERSIONSONCOMMAND = 192,
    ROWTHREADMODEL = 105,
    SCHEMATERM = 106,
    SCHEMAUSAGE = 107,
    SERVERCURSOR = 108,
    SESS_AUTOCOMMITISOLEVELS = 190,
    SQLSUPPORT = 109,
    STRONGIDENTITY = 119,
    STRUCTUREDSTORAGE = 111,
    SUBQUERIES = 112,
    SUPPORTEDTXNDDL = 161,
    SUPPORTEDTXNISOLEVELS = 113,
    SUPPORTEDTXNISORETAIN = 114,
    TABLETERM = 115,
    TBL_TEMPTABLE = 140,
    TRANSACTEDOBJECT = 116,
    UPDATABILITY = 117,
    USERNAME = 118,
};
pub const DBPROP_ABORTPRESERVE = DBPROPENUM.ABORTPRESERVE;
pub const DBPROP_ACTIVESESSIONS = DBPROPENUM.ACTIVESESSIONS;
pub const DBPROP_APPENDONLY = DBPROPENUM.APPENDONLY;
pub const DBPROP_ASYNCTXNABORT = DBPROPENUM.ASYNCTXNABORT;
pub const DBPROP_ASYNCTXNCOMMIT = DBPROPENUM.ASYNCTXNCOMMIT;
pub const DBPROP_AUTH_CACHE_AUTHINFO = DBPROPENUM.AUTH_CACHE_AUTHINFO;
pub const DBPROP_AUTH_ENCRYPT_PASSWORD = DBPROPENUM.AUTH_ENCRYPT_PASSWORD;
pub const DBPROP_AUTH_INTEGRATED = DBPROPENUM.AUTH_INTEGRATED;
pub const DBPROP_AUTH_MASK_PASSWORD = DBPROPENUM.AUTH_MASK_PASSWORD;
pub const DBPROP_AUTH_PASSWORD = DBPROPENUM.AUTH_PASSWORD;
pub const DBPROP_AUTH_PERSIST_ENCRYPTED = DBPROPENUM.AUTH_PERSIST_ENCRYPTED;
pub const DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO = DBPROPENUM.AUTH_PERSIST_SENSITIVE_AUTHINFO;
pub const DBPROP_AUTH_USERID = DBPROPENUM.AUTH_USERID;
pub const DBPROP_BLOCKINGSTORAGEOBJECTS = DBPROPENUM.BLOCKINGSTORAGEOBJECTS;
pub const DBPROP_BOOKMARKS = DBPROPENUM.BOOKMARKS;
pub const DBPROP_BOOKMARKSKIPPED = DBPROPENUM.BOOKMARKSKIPPED;
pub const DBPROP_BOOKMARKTYPE = DBPROPENUM.BOOKMARKTYPE;
pub const DBPROP_BYREFACCESSORS = DBPROPENUM.BYREFACCESSORS;
pub const DBPROP_CACHEDEFERRED = DBPROPENUM.CACHEDEFERRED;
pub const DBPROP_CANFETCHBACKWARDS = DBPROPENUM.CANFETCHBACKWARDS;
pub const DBPROP_CANHOLDROWS = DBPROPENUM.CANHOLDROWS;
pub const DBPROP_CANSCROLLBACKWARDS = DBPROPENUM.CANSCROLLBACKWARDS;
pub const DBPROP_CATALOGLOCATION = DBPROPENUM.CATALOGLOCATION;
pub const DBPROP_CATALOGTERM = DBPROPENUM.CATALOGTERM;
pub const DBPROP_CATALOGUSAGE = DBPROPENUM.CATALOGUSAGE;
pub const DBPROP_CHANGEINSERTEDROWS = DBPROPENUM.CHANGEINSERTEDROWS;
pub const DBPROP_COL_AUTOINCREMENT = DBPROPENUM.COL_AUTOINCREMENT;
pub const DBPROP_COL_DEFAULT = DBPROPENUM.COL_DEFAULT;
pub const DBPROP_COL_DESCRIPTION = DBPROPENUM.COL_DESCRIPTION;
pub const DBPROP_COL_FIXEDLENGTH = DBPROPENUM.COL_FIXEDLENGTH;
pub const DBPROP_COL_NULLABLE = DBPROPENUM.COL_NULLABLE;
pub const DBPROP_COL_PRIMARYKEY = DBPROPENUM.COL_PRIMARYKEY;
pub const DBPROP_COL_UNIQUE = DBPROPENUM.COL_UNIQUE;
pub const DBPROP_COLUMNDEFINITION = DBPROPENUM.COLUMNDEFINITION;
pub const DBPROP_COLUMNRESTRICT = DBPROPENUM.COLUMNRESTRICT;
pub const DBPROP_COMMANDTIMEOUT = DBPROPENUM.COMMANDTIMEOUT;
pub const DBPROP_COMMITPRESERVE = DBPROPENUM.COMMITPRESERVE;
pub const DBPROP_CONCATNULLBEHAVIOR = DBPROPENUM.CONCATNULLBEHAVIOR;
pub const DBPROP_CURRENTCATALOG = DBPROPENUM.CURRENTCATALOG;
pub const DBPROP_DATASOURCENAME = DBPROPENUM.DATASOURCENAME;
pub const DBPROP_DATASOURCEREADONLY = DBPROPENUM.DATASOURCEREADONLY;
pub const DBPROP_DBMSNAME = DBPROPENUM.DBMSNAME;
pub const DBPROP_DBMSVER = DBPROPENUM.DBMSVER;
pub const DBPROP_DEFERRED = DBPROPENUM.DEFERRED;
pub const DBPROP_DELAYSTORAGEOBJECTS = DBPROPENUM.DELAYSTORAGEOBJECTS;
pub const DBPROP_DSOTHREADMODEL = DBPROPENUM.DSOTHREADMODEL;
pub const DBPROP_GROUPBY = DBPROPENUM.GROUPBY;
pub const DBPROP_HETEROGENEOUSTABLES = DBPROPENUM.HETEROGENEOUSTABLES;
pub const DBPROP_IAccessor = DBPROPENUM.IAccessor;
pub const DBPROP_IColumnsInfo = DBPROPENUM.IColumnsInfo;
pub const DBPROP_IColumnsRowset = DBPROPENUM.IColumnsRowset;
pub const DBPROP_IConnectionPointContainer = DBPROPENUM.IConnectionPointContainer;
pub const DBPROP_IConvertType = DBPROPENUM.IConvertType;
pub const DBPROP_IRowset = DBPROPENUM.IRowset;
pub const DBPROP_IRowsetChange = DBPROPENUM.IRowsetChange;
pub const DBPROP_IRowsetIdentity = DBPROPENUM.IRowsetIdentity;
pub const DBPROP_IRowsetIndex = DBPROPENUM.IRowsetIndex;
pub const DBPROP_IRowsetInfo = DBPROPENUM.IRowsetInfo;
pub const DBPROP_IRowsetLocate = DBPROPENUM.IRowsetLocate;
pub const DBPROP_IRowsetResynch = DBPROPENUM.IRowsetResynch;
pub const DBPROP_IRowsetScroll = DBPROPENUM.IRowsetScroll;
pub const DBPROP_IRowsetUpdate = DBPROPENUM.IRowsetUpdate;
pub const DBPROP_ISupportErrorInfo = DBPROPENUM.ISupportErrorInfo;
pub const DBPROP_ILockBytes = DBPROPENUM.ILockBytes;
pub const DBPROP_ISequentialStream = DBPROPENUM.ISequentialStream;
pub const DBPROP_IStorage = DBPROPENUM.IStorage;
pub const DBPROP_IStream = DBPROPENUM.IStream;
pub const DBPROP_IDENTIFIERCASE = DBPROPENUM.IDENTIFIERCASE;
pub const DBPROP_IMMOBILEROWS = DBPROPENUM.IMMOBILEROWS;
pub const DBPROP_INDEX_AUTOUPDATE = DBPROPENUM.INDEX_AUTOUPDATE;
pub const DBPROP_INDEX_CLUSTERED = DBPROPENUM.INDEX_CLUSTERED;
pub const DBPROP_INDEX_FILLFACTOR = DBPROPENUM.INDEX_FILLFACTOR;
pub const DBPROP_INDEX_INITIALSIZE = DBPROPENUM.INDEX_INITIALSIZE;
pub const DBPROP_INDEX_NULLCOLLATION = DBPROPENUM.INDEX_NULLCOLLATION;
pub const DBPROP_INDEX_NULLS = DBPROPENUM.INDEX_NULLS;
pub const DBPROP_INDEX_PRIMARYKEY = DBPROPENUM.INDEX_PRIMARYKEY;
pub const DBPROP_INDEX_SORTBOOKMARKS = DBPROPENUM.INDEX_SORTBOOKMARKS;
pub const DBPROP_INDEX_TEMPINDEX = DBPROPENUM.INDEX_TEMPINDEX;
pub const DBPROP_INDEX_TYPE = DBPROPENUM.INDEX_TYPE;
pub const DBPROP_INDEX_UNIQUE = DBPROPENUM.INDEX_UNIQUE;
pub const DBPROP_INIT_DATASOURCE = DBPROPENUM.INIT_DATASOURCE;
pub const DBPROP_INIT_HWND = DBPROPENUM.INIT_HWND;
pub const DBPROP_INIT_IMPERSONATION_LEVEL = DBPROPENUM.INIT_IMPERSONATION_LEVEL;
pub const DBPROP_INIT_LCID = DBPROPENUM.INIT_LCID;
pub const DBPROP_INIT_LOCATION = DBPROPENUM.INIT_LOCATION;
pub const DBPROP_INIT_MODE = DBPROPENUM.INIT_MODE;
pub const DBPROP_INIT_PROMPT = DBPROPENUM.INIT_PROMPT;
pub const DBPROP_INIT_PROTECTION_LEVEL = DBPROPENUM.INIT_PROTECTION_LEVEL;
pub const DBPROP_INIT_PROVIDERSTRING = DBPROPENUM.INIT_PROVIDERSTRING;
pub const DBPROP_INIT_TIMEOUT = DBPROPENUM.INIT_TIMEOUT;
pub const DBPROP_LITERALBOOKMARKS = DBPROPENUM.LITERALBOOKMARKS;
pub const DBPROP_LITERALIDENTITY = DBPROPENUM.LITERALIDENTITY;
pub const DBPROP_MAXINDEXSIZE = DBPROPENUM.MAXINDEXSIZE;
pub const DBPROP_MAXOPENROWS = DBPROPENUM.MAXOPENROWS;
pub const DBPROP_MAXPENDINGROWS = DBPROPENUM.MAXPENDINGROWS;
pub const DBPROP_MAXROWS = DBPROPENUM.MAXROWS;
pub const DBPROP_MAXROWSIZE = DBPROPENUM.MAXROWSIZE;
pub const DBPROP_MAXROWSIZEINCLUDESBLOB = DBPROPENUM.MAXROWSIZEINCLUDESBLOB;
pub const DBPROP_MAXTABLESINSELECT = DBPROPENUM.MAXTABLESINSELECT;
pub const DBPROP_MAYWRITECOLUMN = DBPROPENUM.MAYWRITECOLUMN;
pub const DBPROP_MEMORYUSAGE = DBPROPENUM.MEMORYUSAGE;
pub const DBPROP_MULTIPLEPARAMSETS = DBPROPENUM.MULTIPLEPARAMSETS;
pub const DBPROP_MULTIPLERESULTS = DBPROPENUM.MULTIPLERESULTS;
pub const DBPROP_MULTIPLESTORAGEOBJECTS = DBPROPENUM.MULTIPLESTORAGEOBJECTS;
pub const DBPROP_MULTITABLEUPDATE = DBPROPENUM.MULTITABLEUPDATE;
pub const DBPROP_NOTIFICATIONGRANULARITY = DBPROPENUM.NOTIFICATIONGRANULARITY;
pub const DBPROP_NOTIFICATIONPHASES = DBPROPENUM.NOTIFICATIONPHASES;
pub const DBPROP_NOTIFYCOLUMNSET = DBPROPENUM.NOTIFYCOLUMNSET;
pub const DBPROP_NOTIFYROWDELETE = DBPROPENUM.NOTIFYROWDELETE;
pub const DBPROP_NOTIFYROWFIRSTCHANGE = DBPROPENUM.NOTIFYROWFIRSTCHANGE;
pub const DBPROP_NOTIFYROWINSERT = DBPROPENUM.NOTIFYROWINSERT;
pub const DBPROP_NOTIFYROWRESYNCH = DBPROPENUM.NOTIFYROWRESYNCH;
pub const DBPROP_NOTIFYROWSETCHANGED = DBPROPENUM.NOTIFYROWSETCHANGED;
pub const DBPROP_NOTIFYROWSETRELEASE = DBPROPENUM.NOTIFYROWSETRELEASE;
pub const DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE = DBPROPENUM.NOTIFYROWSETFETCHPOSITIONCHANGE;
pub const DBPROP_NOTIFYROWUNDOCHANGE = DBPROPENUM.NOTIFYROWUNDOCHANGE;
pub const DBPROP_NOTIFYROWUNDODELETE = DBPROPENUM.NOTIFYROWUNDODELETE;
pub const DBPROP_NOTIFYROWUNDOINSERT = DBPROPENUM.NOTIFYROWUNDOINSERT;
pub const DBPROP_NOTIFYROWUPDATE = DBPROPENUM.NOTIFYROWUPDATE;
pub const DBPROP_NULLCOLLATION = DBPROPENUM.NULLCOLLATION;
pub const DBPROP_OLEOBJECTS = DBPROPENUM.OLEOBJECTS;
pub const DBPROP_ORDERBYCOLUMNSINSELECT = DBPROPENUM.ORDERBYCOLUMNSINSELECT;
pub const DBPROP_ORDEREDBOOKMARKS = DBPROPENUM.ORDEREDBOOKMARKS;
pub const DBPROP_OTHERINSERT = DBPROPENUM.OTHERINSERT;
pub const DBPROP_OTHERUPDATEDELETE = DBPROPENUM.OTHERUPDATEDELETE;
pub const DBPROP_OUTPUTPARAMETERAVAILABILITY = DBPROPENUM.OUTPUTPARAMETERAVAILABILITY;
pub const DBPROP_OWNINSERT = DBPROPENUM.OWNINSERT;
pub const DBPROP_OWNUPDATEDELETE = DBPROPENUM.OWNUPDATEDELETE;
pub const DBPROP_PERSISTENTIDTYPE = DBPROPENUM.PERSISTENTIDTYPE;
pub const DBPROP_PREPAREABORTBEHAVIOR = DBPROPENUM.PREPAREABORTBEHAVIOR;
pub const DBPROP_PREPARECOMMITBEHAVIOR = DBPROPENUM.PREPARECOMMITBEHAVIOR;
pub const DBPROP_PROCEDURETERM = DBPROPENUM.PROCEDURETERM;
pub const DBPROP_PROVIDERNAME = DBPROPENUM.PROVIDERNAME;
pub const DBPROP_PROVIDEROLEDBVER = DBPROPENUM.PROVIDEROLEDBVER;
pub const DBPROP_PROVIDERVER = DBPROPENUM.PROVIDERVER;
pub const DBPROP_QUICKRESTART = DBPROPENUM.QUICKRESTART;
pub const DBPROP_QUOTEDIDENTIFIERCASE = DBPROPENUM.QUOTEDIDENTIFIERCASE;
pub const DBPROP_REENTRANTEVENTS = DBPROPENUM.REENTRANTEVENTS;
pub const DBPROP_REMOVEDELETED = DBPROPENUM.REMOVEDELETED;
pub const DBPROP_REPORTMULTIPLECHANGES = DBPROPENUM.REPORTMULTIPLECHANGES;
pub const DBPROP_RETURNPENDINGINSERTS = DBPROPENUM.RETURNPENDINGINSERTS;
pub const DBPROP_ROWRESTRICT = DBPROPENUM.ROWRESTRICT;
pub const DBPROP_ROWSETCONVERSIONSONCOMMAND = DBPROPENUM.ROWSETCONVERSIONSONCOMMAND;
pub const DBPROP_ROWTHREADMODEL = DBPROPENUM.ROWTHREADMODEL;
pub const DBPROP_SCHEMATERM = DBPROPENUM.SCHEMATERM;
pub const DBPROP_SCHEMAUSAGE = DBPROPENUM.SCHEMAUSAGE;
pub const DBPROP_SERVERCURSOR = DBPROPENUM.SERVERCURSOR;
pub const DBPROP_SESS_AUTOCOMMITISOLEVELS = DBPROPENUM.SESS_AUTOCOMMITISOLEVELS;
pub const DBPROP_SQLSUPPORT = DBPROPENUM.SQLSUPPORT;
pub const DBPROP_STRONGIDENTITY = DBPROPENUM.STRONGIDENTITY;
pub const DBPROP_STRUCTUREDSTORAGE = DBPROPENUM.STRUCTUREDSTORAGE;
pub const DBPROP_SUBQUERIES = DBPROPENUM.SUBQUERIES;
pub const DBPROP_SUPPORTEDTXNDDL = DBPROPENUM.SUPPORTEDTXNDDL;
pub const DBPROP_SUPPORTEDTXNISOLEVELS = DBPROPENUM.SUPPORTEDTXNISOLEVELS;
pub const DBPROP_SUPPORTEDTXNISORETAIN = DBPROPENUM.SUPPORTEDTXNISORETAIN;
pub const DBPROP_TABLETERM = DBPROPENUM.TABLETERM;
pub const DBPROP_TBL_TEMPTABLE = DBPROPENUM.TBL_TEMPTABLE;
pub const DBPROP_TRANSACTEDOBJECT = DBPROPENUM.TRANSACTEDOBJECT;
pub const DBPROP_UPDATABILITY = DBPROPENUM.UPDATABILITY;
pub const DBPROP_USERNAME = DBPROPENUM.USERNAME;

pub const DBPROPENUM15 = enum(i32) {
    FILTERCOMPAREOPS = 209,
    FINDCOMPAREOPS = 210,
    IChapteredRowset = 202,
    IDBAsynchStatus = 203,
    IRowsetFind = 204,
    IRowsetView = 212,
    IViewChapter = 213,
    IViewFilter = 214,
    IViewRowset = 215,
    IViewSort = 216,
    INIT_ASYNCH = 200,
    MAXOPENCHAPTERS = 199,
    MAXORSINFILTER = 205,
    MAXSORTCOLUMNS = 206,
    ROWSET_ASYNCH = 201,
    SORTONINDEX = 207,
};
pub const DBPROP_FILTERCOMPAREOPS = DBPROPENUM15.FILTERCOMPAREOPS;
pub const DBPROP_FINDCOMPAREOPS = DBPROPENUM15.FINDCOMPAREOPS;
pub const DBPROP_IChapteredRowset = DBPROPENUM15.IChapteredRowset;
pub const DBPROP_IDBAsynchStatus = DBPROPENUM15.IDBAsynchStatus;
pub const DBPROP_IRowsetFind = DBPROPENUM15.IRowsetFind;
pub const DBPROP_IRowsetView = DBPROPENUM15.IRowsetView;
pub const DBPROP_IViewChapter = DBPROPENUM15.IViewChapter;
pub const DBPROP_IViewFilter = DBPROPENUM15.IViewFilter;
pub const DBPROP_IViewRowset = DBPROPENUM15.IViewRowset;
pub const DBPROP_IViewSort = DBPROPENUM15.IViewSort;
pub const DBPROP_INIT_ASYNCH = DBPROPENUM15.INIT_ASYNCH;
pub const DBPROP_MAXOPENCHAPTERS = DBPROPENUM15.MAXOPENCHAPTERS;
pub const DBPROP_MAXORSINFILTER = DBPROPENUM15.MAXORSINFILTER;
pub const DBPROP_MAXSORTCOLUMNS = DBPROPENUM15.MAXSORTCOLUMNS;
pub const DBPROP_ROWSET_ASYNCH = DBPROPENUM15.ROWSET_ASYNCH;
pub const DBPROP_SORTONINDEX = DBPROPENUM15.SORTONINDEX;

pub const DBPROPENUM20 = enum(i32) {
    DBPROP_IMultipleResults = 217,
    DBPROP_DATASOURCE_TYPE = 251,
    MDPROP_AXES = 252,
    MDPROP_FLATTENING_SUPPORT = 253,
    MDPROP_MDX_JOINCUBES = 254,
    MDPROP_NAMED_LEVELS = 255,
    MDPROP_RANGEROWSET = 256,
    MDPROP_MDX_SLICER = 218,
    MDPROP_MDX_CUBEQUALIFICATION = 219,
    MDPROP_MDX_OUTERREFERENCE = 220,
    MDPROP_MDX_QUERYBYPROPERTY = 221,
    MDPROP_MDX_CASESUPPORT = 222,
    MDPROP_MDX_STRING_COMPOP = 224,
    MDPROP_MDX_DESCFLAGS = 225,
    MDPROP_MDX_SET_FUNCTIONS = 226,
    MDPROP_MDX_MEMBER_FUNCTIONS = 227,
    MDPROP_MDX_NUMERIC_FUNCTIONS = 228,
    MDPROP_MDX_FORMULAS = 229,
    MDPROP_AGGREGATECELL_UPDATE = 230,
    // MDPROP_MDX_AGGREGATECELL_UPDATE = 230, this enum value conflicts with MDPROP_AGGREGATECELL_UPDATE
    MDPROP_MDX_OBJQUALIFICATION = 261,
    MDPROP_MDX_NONMEASURE_EXPRESSIONS = 262,
    DBPROP_ACCESSORDER = 231,
    DBPROP_BOOKMARKINFO = 232,
    DBPROP_INIT_CATALOG = 233,
    DBPROP_ROW_BULKOPS = 234,
    DBPROP_PROVIDERFRIENDLYNAME = 235,
    DBPROP_LOCKMODE = 236,
    DBPROP_MULTIPLECONNECTIONS = 237,
    DBPROP_UNIQUEROWS = 238,
    DBPROP_SERVERDATAONINSERT = 239,
    DBPROP_STORAGEFLAGS = 240,
    DBPROP_CONNECTIONSTATUS = 244,
    DBPROP_ALTERCOLUMN = 245,
    DBPROP_COLUMNLCID = 246,
    DBPROP_RESETDATASOURCE = 247,
    DBPROP_INIT_OLEDBSERVICES = 248,
    DBPROP_IRowsetRefresh = 249,
    DBPROP_SERVERNAME = 250,
    DBPROP_IParentRowset = 257,
    DBPROP_HIDDENCOLUMNS = 258,
    DBPROP_PROVIDERMEMORY = 259,
    DBPROP_CLIENTCURSOR = 260,
};
pub const DBPROP_IMultipleResults = DBPROPENUM20.DBPROP_IMultipleResults;
pub const DBPROP_DATASOURCE_TYPE = DBPROPENUM20.DBPROP_DATASOURCE_TYPE;
pub const MDPROP_AXES = DBPROPENUM20.MDPROP_AXES;
pub const MDPROP_FLATTENING_SUPPORT = DBPROPENUM20.MDPROP_FLATTENING_SUPPORT;
pub const MDPROP_MDX_JOINCUBES = DBPROPENUM20.MDPROP_MDX_JOINCUBES;
pub const MDPROP_NAMED_LEVELS = DBPROPENUM20.MDPROP_NAMED_LEVELS;
pub const MDPROP_RANGEROWSET = DBPROPENUM20.MDPROP_RANGEROWSET;
pub const MDPROP_MDX_SLICER = DBPROPENUM20.MDPROP_MDX_SLICER;
pub const MDPROP_MDX_CUBEQUALIFICATION = DBPROPENUM20.MDPROP_MDX_CUBEQUALIFICATION;
pub const MDPROP_MDX_OUTERREFERENCE = DBPROPENUM20.MDPROP_MDX_OUTERREFERENCE;
pub const MDPROP_MDX_QUERYBYPROPERTY = DBPROPENUM20.MDPROP_MDX_QUERYBYPROPERTY;
pub const MDPROP_MDX_CASESUPPORT = DBPROPENUM20.MDPROP_MDX_CASESUPPORT;
pub const MDPROP_MDX_STRING_COMPOP = DBPROPENUM20.MDPROP_MDX_STRING_COMPOP;
pub const MDPROP_MDX_DESCFLAGS = DBPROPENUM20.MDPROP_MDX_DESCFLAGS;
pub const MDPROP_MDX_SET_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_SET_FUNCTIONS;
pub const MDPROP_MDX_MEMBER_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_MEMBER_FUNCTIONS;
pub const MDPROP_MDX_NUMERIC_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_NUMERIC_FUNCTIONS;
pub const MDPROP_MDX_FORMULAS = DBPROPENUM20.MDPROP_MDX_FORMULAS;
pub const MDPROP_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_OBJQUALIFICATION = DBPROPENUM20.MDPROP_MDX_OBJQUALIFICATION;
pub const MDPROP_MDX_NONMEASURE_EXPRESSIONS = DBPROPENUM20.MDPROP_MDX_NONMEASURE_EXPRESSIONS;
pub const DBPROP_ACCESSORDER = DBPROPENUM20.DBPROP_ACCESSORDER;
pub const DBPROP_BOOKMARKINFO = DBPROPENUM20.DBPROP_BOOKMARKINFO;
pub const DBPROP_INIT_CATALOG = DBPROPENUM20.DBPROP_INIT_CATALOG;
pub const DBPROP_ROW_BULKOPS = DBPROPENUM20.DBPROP_ROW_BULKOPS;
pub const DBPROP_PROVIDERFRIENDLYNAME = DBPROPENUM20.DBPROP_PROVIDERFRIENDLYNAME;
pub const DBPROP_LOCKMODE = DBPROPENUM20.DBPROP_LOCKMODE;
pub const DBPROP_MULTIPLECONNECTIONS = DBPROPENUM20.DBPROP_MULTIPLECONNECTIONS;
pub const DBPROP_UNIQUEROWS = DBPROPENUM20.DBPROP_UNIQUEROWS;
pub const DBPROP_SERVERDATAONINSERT = DBPROPENUM20.DBPROP_SERVERDATAONINSERT;
pub const DBPROP_STORAGEFLAGS = DBPROPENUM20.DBPROP_STORAGEFLAGS;
pub const DBPROP_CONNECTIONSTATUS = DBPROPENUM20.DBPROP_CONNECTIONSTATUS;
pub const DBPROP_ALTERCOLUMN = DBPROPENUM20.DBPROP_ALTERCOLUMN;
pub const DBPROP_COLUMNLCID = DBPROPENUM20.DBPROP_COLUMNLCID;
pub const DBPROP_RESETDATASOURCE = DBPROPENUM20.DBPROP_RESETDATASOURCE;
pub const DBPROP_INIT_OLEDBSERVICES = DBPROPENUM20.DBPROP_INIT_OLEDBSERVICES;
pub const DBPROP_IRowsetRefresh = DBPROPENUM20.DBPROP_IRowsetRefresh;
pub const DBPROP_SERVERNAME = DBPROPENUM20.DBPROP_SERVERNAME;
pub const DBPROP_IParentRowset = DBPROPENUM20.DBPROP_IParentRowset;
pub const DBPROP_HIDDENCOLUMNS = DBPROPENUM20.DBPROP_HIDDENCOLUMNS;
pub const DBPROP_PROVIDERMEMORY = DBPROPENUM20.DBPROP_PROVIDERMEMORY;
pub const DBPROP_CLIENTCURSOR = DBPROPENUM20.DBPROP_CLIENTCURSOR;

pub const DBPROPENUM21 = enum(i32) {
    TRUSTEE_USERNAME = 241,
    TRUSTEE_AUTHENTICATION = 242,
    TRUSTEE_NEWAUTHENTICATION = 243,
    IRow = 263,
    IRowChange = 264,
    IRowSchemaChange = 265,
    IGetRow = 266,
    IScopedOperations = 267,
    IBindResource = 268,
    ICreateRow = 269,
    INIT_BINDFLAGS = 270,
    INIT_LOCKOWNER = 271,
    GENERATEURL = 273,
    IDBBinderProperties = 274,
    IColumnsInfo2 = 275,
    IRegisterProvider = 276,
    IGetSession = 277,
    IGetSourceRow = 278,
    IRowsetCurrentIndex = 279,
    OPENROWSETSUPPORT = 280,
    COL_ISLONG = 281,
};
pub const DBPROP_TRUSTEE_USERNAME = DBPROPENUM21.TRUSTEE_USERNAME;
pub const DBPROP_TRUSTEE_AUTHENTICATION = DBPROPENUM21.TRUSTEE_AUTHENTICATION;
pub const DBPROP_TRUSTEE_NEWAUTHENTICATION = DBPROPENUM21.TRUSTEE_NEWAUTHENTICATION;
pub const DBPROP_IRow = DBPROPENUM21.IRow;
pub const DBPROP_IRowChange = DBPROPENUM21.IRowChange;
pub const DBPROP_IRowSchemaChange = DBPROPENUM21.IRowSchemaChange;
pub const DBPROP_IGetRow = DBPROPENUM21.IGetRow;
pub const DBPROP_IScopedOperations = DBPROPENUM21.IScopedOperations;
pub const DBPROP_IBindResource = DBPROPENUM21.IBindResource;
pub const DBPROP_ICreateRow = DBPROPENUM21.ICreateRow;
pub const DBPROP_INIT_BINDFLAGS = DBPROPENUM21.INIT_BINDFLAGS;
pub const DBPROP_INIT_LOCKOWNER = DBPROPENUM21.INIT_LOCKOWNER;
pub const DBPROP_GENERATEURL = DBPROPENUM21.GENERATEURL;
pub const DBPROP_IDBBinderProperties = DBPROPENUM21.IDBBinderProperties;
pub const DBPROP_IColumnsInfo2 = DBPROPENUM21.IColumnsInfo2;
pub const DBPROP_IRegisterProvider = DBPROPENUM21.IRegisterProvider;
pub const DBPROP_IGetSession = DBPROPENUM21.IGetSession;
pub const DBPROP_IGetSourceRow = DBPROPENUM21.IGetSourceRow;
pub const DBPROP_IRowsetCurrentIndex = DBPROPENUM21.IRowsetCurrentIndex;
pub const DBPROP_OPENROWSETSUPPORT = DBPROPENUM21.OPENROWSETSUPPORT;
pub const DBPROP_COL_ISLONG = DBPROPENUM21.COL_ISLONG;

pub const DBPROPENUM25 = enum(i32) {
    COL_SEED = 282,
    COL_INCREMENT = 283,
    INIT_GENERALTIMEOUT = 284,
    COMSERVICES = 285,
};
pub const DBPROP_COL_SEED = DBPROPENUM25.COL_SEED;
pub const DBPROP_COL_INCREMENT = DBPROPENUM25.COL_INCREMENT;
pub const DBPROP_INIT_GENERALTIMEOUT = DBPROPENUM25.INIT_GENERALTIMEOUT;
pub const DBPROP_COMSERVICES = DBPROPENUM25.COMSERVICES;

pub const DBPROPENUM26 = enum(i32) {
    DBPROP_OUTPUTSTREAM = 286,
    DBPROP_OUTPUTENCODING = 287,
    DBPROP_TABLESTATISTICS = 288,
    DBPROP_SKIPROWCOUNTRESULTS = 291,
    DBPROP_IRowsetBookmark = 292,
    MDPROP_VISUALMODE = 293,
};
pub const DBPROP_OUTPUTSTREAM = DBPROPENUM26.DBPROP_OUTPUTSTREAM;
pub const DBPROP_OUTPUTENCODING = DBPROPENUM26.DBPROP_OUTPUTENCODING;
pub const DBPROP_TABLESTATISTICS = DBPROPENUM26.DBPROP_TABLESTATISTICS;
pub const DBPROP_SKIPROWCOUNTRESULTS = DBPROPENUM26.DBPROP_SKIPROWCOUNTRESULTS;
pub const DBPROP_IRowsetBookmark = DBPROPENUM26.DBPROP_IRowsetBookmark;
pub const MDPROP_VISUALMODE = DBPROPENUM26.MDPROP_VISUALMODE;

pub const DBPARAMFLAGSENUM = enum(i32) {
    INPUT = 1,
    OUTPUT = 2,
    SIGNED = 16,
    NULLABLE = 64,
    LONG = 128,
};
pub const DBPARAMFLAGS_ISINPUT = DBPARAMFLAGSENUM.INPUT;
pub const DBPARAMFLAGS_ISOUTPUT = DBPARAMFLAGSENUM.OUTPUT;
pub const DBPARAMFLAGS_ISSIGNED = DBPARAMFLAGSENUM.SIGNED;
pub const DBPARAMFLAGS_ISNULLABLE = DBPARAMFLAGSENUM.NULLABLE;
pub const DBPARAMFLAGS_ISLONG = DBPARAMFLAGSENUM.LONG;

pub const DBPARAMFLAGSENUM20 = enum(i32) {
    E = 256,
};
pub const DBPARAMFLAGS_SCALEISNEGATIVE = DBPARAMFLAGSENUM20.E;

pub const DBPROPFLAGSENUM = enum(i32) {
    NOTSUPPORTED = 0,
    COLUMN = 1,
    DATASOURCE = 2,
    DATASOURCECREATE = 4,
    DATASOURCEINFO = 8,
    DBINIT = 16,
    INDEX = 32,
    ROWSET = 64,
    TABLE = 128,
    COLUMNOK = 256,
    READ = 512,
    WRITE = 1024,
    REQUIRED = 2048,
    SESSION = 4096,
};
pub const DBPROPFLAGS_NOTSUPPORTED = DBPROPFLAGSENUM.NOTSUPPORTED;
pub const DBPROPFLAGS_COLUMN = DBPROPFLAGSENUM.COLUMN;
pub const DBPROPFLAGS_DATASOURCE = DBPROPFLAGSENUM.DATASOURCE;
pub const DBPROPFLAGS_DATASOURCECREATE = DBPROPFLAGSENUM.DATASOURCECREATE;
pub const DBPROPFLAGS_DATASOURCEINFO = DBPROPFLAGSENUM.DATASOURCEINFO;
pub const DBPROPFLAGS_DBINIT = DBPROPFLAGSENUM.DBINIT;
pub const DBPROPFLAGS_INDEX = DBPROPFLAGSENUM.INDEX;
pub const DBPROPFLAGS_ROWSET = DBPROPFLAGSENUM.ROWSET;
pub const DBPROPFLAGS_TABLE = DBPROPFLAGSENUM.TABLE;
pub const DBPROPFLAGS_COLUMNOK = DBPROPFLAGSENUM.COLUMNOK;
pub const DBPROPFLAGS_READ = DBPROPFLAGSENUM.READ;
pub const DBPROPFLAGS_WRITE = DBPROPFLAGSENUM.WRITE;
pub const DBPROPFLAGS_REQUIRED = DBPROPFLAGSENUM.REQUIRED;
pub const DBPROPFLAGS_SESSION = DBPROPFLAGSENUM.SESSION;

pub const DBPROPFLAGSENUM21 = enum(i32) {
    E = 8192,
};
pub const DBPROPFLAGS_TRUSTEE = DBPROPFLAGSENUM21.E;

pub const DBPROPFLAGSENUM25 = enum(i32) {
    W = 16384,
};
pub const DBPROPFLAGS_VIEW = DBPROPFLAGSENUM25.W;

pub const DBPROPFLAGSENUM26 = enum(i32) {
    M = 32768,
};
pub const DBPROPFLAGS_STREAM = DBPROPFLAGSENUM26.M;

pub const DBPROPOPTIONSENUM = enum(i32) {
    REQUIRED = 0,
    SETIFCHEAP = 1,
    // OPTIONAL = 1, this enum value conflicts with SETIFCHEAP
};
pub const DBPROPOPTIONS_REQUIRED = DBPROPOPTIONSENUM.REQUIRED;
pub const DBPROPOPTIONS_SETIFCHEAP = DBPROPOPTIONSENUM.SETIFCHEAP;
pub const DBPROPOPTIONS_OPTIONAL = DBPROPOPTIONSENUM.SETIFCHEAP;

pub const DBPROPSTATUSENUM = enum(i32) {
    OK = 0,
    NOTSUPPORTED = 1,
    BADVALUE = 2,
    BADOPTION = 3,
    BADCOLUMN = 4,
    NOTALLSETTABLE = 5,
    NOTSETTABLE = 6,
    NOTSET = 7,
    CONFLICTING = 8,
};
pub const DBPROPSTATUS_OK = DBPROPSTATUSENUM.OK;
pub const DBPROPSTATUS_NOTSUPPORTED = DBPROPSTATUSENUM.NOTSUPPORTED;
pub const DBPROPSTATUS_BADVALUE = DBPROPSTATUSENUM.BADVALUE;
pub const DBPROPSTATUS_BADOPTION = DBPROPSTATUSENUM.BADOPTION;
pub const DBPROPSTATUS_BADCOLUMN = DBPROPSTATUSENUM.BADCOLUMN;
pub const DBPROPSTATUS_NOTALLSETTABLE = DBPROPSTATUSENUM.NOTALLSETTABLE;
pub const DBPROPSTATUS_NOTSETTABLE = DBPROPSTATUSENUM.NOTSETTABLE;
pub const DBPROPSTATUS_NOTSET = DBPROPSTATUSENUM.NOTSET;
pub const DBPROPSTATUS_CONFLICTING = DBPROPSTATUSENUM.CONFLICTING;

pub const DBPROPSTATUSENUM21 = enum(i32) {
    E = 9,
};
pub const DBPROPSTATUS_NOTAVAILABLE = DBPROPSTATUSENUM21.E;

pub const DBINDEX_COL_ORDERENUM = enum(i32) {
    ASC = 0,
    DESC = 1,
};
pub const DBINDEX_COL_ORDER_ASC = DBINDEX_COL_ORDERENUM.ASC;
pub const DBINDEX_COL_ORDER_DESC = DBINDEX_COL_ORDERENUM.DESC;

pub const DBCOLUMNDESCFLAGSENUM = enum(i32) {
    TYPENAME = 1,
    ITYPEINFO = 2,
    PROPERTIES = 4,
    CLSID = 8,
    COLSIZE = 16,
    DBCID = 32,
    WTYPE = 64,
    PRECISION = 128,
    SCALE = 256,
};
pub const DBCOLUMNDESCFLAGS_TYPENAME = DBCOLUMNDESCFLAGSENUM.TYPENAME;
pub const DBCOLUMNDESCFLAGS_ITYPEINFO = DBCOLUMNDESCFLAGSENUM.ITYPEINFO;
pub const DBCOLUMNDESCFLAGS_PROPERTIES = DBCOLUMNDESCFLAGSENUM.PROPERTIES;
pub const DBCOLUMNDESCFLAGS_CLSID = DBCOLUMNDESCFLAGSENUM.CLSID;
pub const DBCOLUMNDESCFLAGS_COLSIZE = DBCOLUMNDESCFLAGSENUM.COLSIZE;
pub const DBCOLUMNDESCFLAGS_DBCID = DBCOLUMNDESCFLAGSENUM.DBCID;
pub const DBCOLUMNDESCFLAGS_WTYPE = DBCOLUMNDESCFLAGSENUM.WTYPE;
pub const DBCOLUMNDESCFLAGS_PRECISION = DBCOLUMNDESCFLAGSENUM.PRECISION;
pub const DBCOLUMNDESCFLAGS_SCALE = DBCOLUMNDESCFLAGSENUM.SCALE;

pub const DBEVENTPHASEENUM = enum(i32) {
    OKTODO = 0,
    ABOUTTODO = 1,
    SYNCHAFTER = 2,
    FAILEDTODO = 3,
    DIDEVENT = 4,
};
pub const DBEVENTPHASE_OKTODO = DBEVENTPHASEENUM.OKTODO;
pub const DBEVENTPHASE_ABOUTTODO = DBEVENTPHASEENUM.ABOUTTODO;
pub const DBEVENTPHASE_SYNCHAFTER = DBEVENTPHASEENUM.SYNCHAFTER;
pub const DBEVENTPHASE_FAILEDTODO = DBEVENTPHASEENUM.FAILEDTODO;
pub const DBEVENTPHASE_DIDEVENT = DBEVENTPHASEENUM.DIDEVENT;

pub const DBREASONENUM = enum(i32) {
    ROWSET_FETCHPOSITIONCHANGE = 0,
    ROWSET_RELEASE = 1,
    COLUMN_SET = 2,
    COLUMN_RECALCULATED = 3,
    ROW_ACTIVATE = 4,
    ROW_RELEASE = 5,
    ROW_DELETE = 6,
    ROW_FIRSTCHANGE = 7,
    ROW_INSERT = 8,
    ROW_RESYNCH = 9,
    ROW_UNDOCHANGE = 10,
    ROW_UNDOINSERT = 11,
    ROW_UNDODELETE = 12,
    ROW_UPDATE = 13,
    ROWSET_CHANGED = 14,
};
pub const DBREASON_ROWSET_FETCHPOSITIONCHANGE = DBREASONENUM.ROWSET_FETCHPOSITIONCHANGE;
pub const DBREASON_ROWSET_RELEASE = DBREASONENUM.ROWSET_RELEASE;
pub const DBREASON_COLUMN_SET = DBREASONENUM.COLUMN_SET;
pub const DBREASON_COLUMN_RECALCULATED = DBREASONENUM.COLUMN_RECALCULATED;
pub const DBREASON_ROW_ACTIVATE = DBREASONENUM.ROW_ACTIVATE;
pub const DBREASON_ROW_RELEASE = DBREASONENUM.ROW_RELEASE;
pub const DBREASON_ROW_DELETE = DBREASONENUM.ROW_DELETE;
pub const DBREASON_ROW_FIRSTCHANGE = DBREASONENUM.ROW_FIRSTCHANGE;
pub const DBREASON_ROW_INSERT = DBREASONENUM.ROW_INSERT;
pub const DBREASON_ROW_RESYNCH = DBREASONENUM.ROW_RESYNCH;
pub const DBREASON_ROW_UNDOCHANGE = DBREASONENUM.ROW_UNDOCHANGE;
pub const DBREASON_ROW_UNDOINSERT = DBREASONENUM.ROW_UNDOINSERT;
pub const DBREASON_ROW_UNDODELETE = DBREASONENUM.ROW_UNDODELETE;
pub const DBREASON_ROW_UPDATE = DBREASONENUM.ROW_UPDATE;
pub const DBREASON_ROWSET_CHANGED = DBREASONENUM.ROWSET_CHANGED;

pub const DBREASONENUM15 = enum(i32) {
    POSITION_CHANGED = 15,
    POSITION_CHAPTERCHANGED = 16,
    POSITION_CLEARED = 17,
    _ASYNCHINSERT = 18,
};
pub const DBREASON_ROWPOSITION_CHANGED = DBREASONENUM15.POSITION_CHANGED;
pub const DBREASON_ROWPOSITION_CHAPTERCHANGED = DBREASONENUM15.POSITION_CHAPTERCHANGED;
pub const DBREASON_ROWPOSITION_CLEARED = DBREASONENUM15.POSITION_CLEARED;
pub const DBREASON_ROW_ASYNCHINSERT = DBREASONENUM15._ASYNCHINSERT;

pub const DBCOMPAREOPSENUM = enum(i32) {
    LT = 0,
    LE = 1,
    EQ = 2,
    GE = 3,
    GT = 4,
    BEGINSWITH = 5,
    CONTAINS = 6,
    NE = 7,
    IGNORE = 8,
    CASESENSITIVE = 4096,
    CASEINSENSITIVE = 8192,
};
pub const DBCOMPAREOPS_LT = DBCOMPAREOPSENUM.LT;
pub const DBCOMPAREOPS_LE = DBCOMPAREOPSENUM.LE;
pub const DBCOMPAREOPS_EQ = DBCOMPAREOPSENUM.EQ;
pub const DBCOMPAREOPS_GE = DBCOMPAREOPSENUM.GE;
pub const DBCOMPAREOPS_GT = DBCOMPAREOPSENUM.GT;
pub const DBCOMPAREOPS_BEGINSWITH = DBCOMPAREOPSENUM.BEGINSWITH;
pub const DBCOMPAREOPS_CONTAINS = DBCOMPAREOPSENUM.CONTAINS;
pub const DBCOMPAREOPS_NE = DBCOMPAREOPSENUM.NE;
pub const DBCOMPAREOPS_IGNORE = DBCOMPAREOPSENUM.IGNORE;
pub const DBCOMPAREOPS_CASESENSITIVE = DBCOMPAREOPSENUM.CASESENSITIVE;
pub const DBCOMPAREOPS_CASEINSENSITIVE = DBCOMPAREOPSENUM.CASEINSENSITIVE;

pub const DBCOMPAREOPSENUM20 = enum(i32) {
    BEGINSWITH = 9,
    CONTAINS = 10,
};
pub const DBCOMPAREOPS_NOTBEGINSWITH = DBCOMPAREOPSENUM20.BEGINSWITH;
pub const DBCOMPAREOPS_NOTCONTAINS = DBCOMPAREOPSENUM20.CONTAINS;

pub const DBASYNCHOPENUM = enum(i32) {
    N = 0,
};
pub const DBASYNCHOP_OPEN = DBASYNCHOPENUM.N;

pub const DBASYNCHPHASEENUM = enum(i32) {
    INITIALIZATION = 0,
    POPULATION = 1,
    COMPLETE = 2,
    CANCELED = 3,
};
pub const DBASYNCHPHASE_INITIALIZATION = DBASYNCHPHASEENUM.INITIALIZATION;
pub const DBASYNCHPHASE_POPULATION = DBASYNCHPHASEENUM.POPULATION;
pub const DBASYNCHPHASE_COMPLETE = DBASYNCHPHASEENUM.COMPLETE;
pub const DBASYNCHPHASE_CANCELED = DBASYNCHPHASEENUM.CANCELED;

pub const DBSORTENUM = enum(i32) {
    ASCENDING = 0,
    DESCENDING = 1,
};
pub const DBSORT_ASCENDING = DBSORTENUM.ASCENDING;
pub const DBSORT_DESCENDING = DBSORTENUM.DESCENDING;

pub const DBCOMMANDPERSISTFLAGENUM = enum(i32) {
    E = 1,
};
pub const DBCOMMANDPERSISTFLAG_NOSAVE = DBCOMMANDPERSISTFLAGENUM.E;

pub const DBCOMMANDPERSISTFLAGENUM21 = enum(i32) {
    DEFAULT = 0,
    PERSISTVIEW = 2,
    PERSISTPROCEDURE = 4,
};
pub const DBCOMMANDPERSISTFLAG_DEFAULT = DBCOMMANDPERSISTFLAGENUM21.DEFAULT;
pub const DBCOMMANDPERSISTFLAG_PERSISTVIEW = DBCOMMANDPERSISTFLAGENUM21.PERSISTVIEW;
pub const DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE = DBCOMMANDPERSISTFLAGENUM21.PERSISTPROCEDURE;

pub const DBCONSTRAINTTYPEENUM = enum(i32) {
    UNIQUE = 0,
    FOREIGNKEY = 1,
    PRIMARYKEY = 2,
    CHECK = 3,
};
pub const DBCONSTRAINTTYPE_UNIQUE = DBCONSTRAINTTYPEENUM.UNIQUE;
pub const DBCONSTRAINTTYPE_FOREIGNKEY = DBCONSTRAINTTYPEENUM.FOREIGNKEY;
pub const DBCONSTRAINTTYPE_PRIMARYKEY = DBCONSTRAINTTYPEENUM.PRIMARYKEY;
pub const DBCONSTRAINTTYPE_CHECK = DBCONSTRAINTTYPEENUM.CHECK;

pub const DBUPDELRULEENUM = enum(i32) {
    NOACTION = 0,
    CASCADE = 1,
    SETNULL = 2,
    SETDEFAULT = 3,
};
pub const DBUPDELRULE_NOACTION = DBUPDELRULEENUM.NOACTION;
pub const DBUPDELRULE_CASCADE = DBUPDELRULEENUM.CASCADE;
pub const DBUPDELRULE_SETNULL = DBUPDELRULEENUM.SETNULL;
pub const DBUPDELRULE_SETDEFAULT = DBUPDELRULEENUM.SETDEFAULT;

pub const DBMATCHTYPEENUM = enum(i32) {
    FULL = 0,
    NONE = 1,
    PARTIAL = 2,
};
pub const DBMATCHTYPE_FULL = DBMATCHTYPEENUM.FULL;
pub const DBMATCHTYPE_NONE = DBMATCHTYPEENUM.NONE;
pub const DBMATCHTYPE_PARTIAL = DBMATCHTYPEENUM.PARTIAL;

pub const DBDEFERRABILITYENUM = enum(i32) {
    ED = 1,
    ABLE = 2,
};
pub const DBDEFERRABILITY_DEFERRED = DBDEFERRABILITYENUM.ED;
pub const DBDEFERRABILITY_DEFERRABLE = DBDEFERRABILITYENUM.ABLE;

pub const DBACCESSORFLAGSENUM = enum(i32) {
    INVALID = 0,
    PASSBYREF = 1,
    ROWDATA = 2,
    PARAMETERDATA = 4,
    OPTIMIZED = 8,
    INHERITED = 16,
};
pub const DBACCESSOR_INVALID = DBACCESSORFLAGSENUM.INVALID;
pub const DBACCESSOR_PASSBYREF = DBACCESSORFLAGSENUM.PASSBYREF;
pub const DBACCESSOR_ROWDATA = DBACCESSORFLAGSENUM.ROWDATA;
pub const DBACCESSOR_PARAMETERDATA = DBACCESSORFLAGSENUM.PARAMETERDATA;
pub const DBACCESSOR_OPTIMIZED = DBACCESSORFLAGSENUM.OPTIMIZED;
pub const DBACCESSOR_INHERITED = DBACCESSORFLAGSENUM.INHERITED;

pub const DBBINDSTATUSENUM = enum(i32) {
    OK = 0,
    BADORDINAL = 1,
    UNSUPPORTEDCONVERSION = 2,
    BADBINDINFO = 3,
    BADSTORAGEFLAGS = 4,
    NOINTERFACE = 5,
    MULTIPLESTORAGE = 6,
};
pub const DBBINDSTATUS_OK = DBBINDSTATUSENUM.OK;
pub const DBBINDSTATUS_BADORDINAL = DBBINDSTATUSENUM.BADORDINAL;
pub const DBBINDSTATUS_UNSUPPORTEDCONVERSION = DBBINDSTATUSENUM.UNSUPPORTEDCONVERSION;
pub const DBBINDSTATUS_BADBINDINFO = DBBINDSTATUSENUM.BADBINDINFO;
pub const DBBINDSTATUS_BADSTORAGEFLAGS = DBBINDSTATUSENUM.BADSTORAGEFLAGS;
pub const DBBINDSTATUS_NOINTERFACE = DBBINDSTATUSENUM.NOINTERFACE;
pub const DBBINDSTATUS_MULTIPLESTORAGE = DBBINDSTATUSENUM.MULTIPLESTORAGE;

const IID_IAccessor_Value = Guid.initString("0c733a8c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAccessor = &IID_IAccessor_Value;
pub const IAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefAccessor: *const fn (
            self: *const IAccessor,
            h_accessor: usize,
            pc_ref_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: *const fn (
            self: *const IAccessor,
            dw_accessor_flags: u32,
            c_bindings: usize,
            rg_bindings: [*]const DBBINDING,
            cb_row_size: usize,
            ph_accessor: ?*usize,
            rg_status: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindings: *const fn (
            self: *const IAccessor,
            h_accessor: usize,
            pdw_accessor_flags: ?*u32,
            pc_bindings: ?*usize,
            prg_bindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseAccessor: *const fn (
            self: *const IAccessor,
            h_accessor: usize,
            pc_ref_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addRefAccessor(self: *const T, h_accessor_: usize, pc_ref_count_: ?*u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).AddRefAccessor(@as(*const IAccessor, @ptrCast(self)), h_accessor_, pc_ref_count_);
            }
            pub inline fn createAccessor(self: *const T, dw_accessor_flags_: u32, c_bindings_: usize, rg_bindings_: [*]const DBBINDING, cb_row_size_: usize, ph_accessor_: ?*usize, rg_status_: ?[*]u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).CreateAccessor(@as(*const IAccessor, @ptrCast(self)), dw_accessor_flags_, c_bindings_, rg_bindings_, cb_row_size_, ph_accessor_, rg_status_);
            }
            pub inline fn getBindings(self: *const T, h_accessor_: usize, pdw_accessor_flags_: ?*u32, pc_bindings_: ?*usize, prg_bindings_: ?*?*DBBINDING) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).GetBindings(@as(*const IAccessor, @ptrCast(self)), h_accessor_, pdw_accessor_flags_, pc_bindings_, prg_bindings_);
            }
            pub inline fn releaseAccessor(self: *const T, h_accessor_: usize, pc_ref_count_: ?*u32) HRESULT {
                return @as(*const IAccessor.VTable, @ptrCast(self.vtable)).ReleaseAccessor(@as(*const IAccessor, @ptrCast(self)), h_accessor_, pc_ref_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowset_Value = Guid.initString("0c733a7c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowset = &IID_IRowset_Value;
pub const IRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefRows: *const fn (
            self: *const IRowset,
            c_rows: usize,
            rgh_rows: ?*const usize,
            rg_ref_counts: ?*u32,
            rg_row_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const IRowset,
            h_row: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextRows: *const fn (
            self: *const IRowset,
            h_reserved: usize,
            l_rows_offset: isize,
            c_rows: isize,
            pc_rows_obtained: ?*usize,
            prgh_rows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseRows: *const fn (
            self: *const IRowset,
            c_rows: usize,
            rgh_rows: ?*const usize,
            rg_row_options: ?*u32,
            rg_ref_counts: ?*u32,
            rg_row_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestartPosition: *const fn (
            self: *const IRowset,
            h_reserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addRefRows(self: *const T, c_rows_: usize, rgh_rows_: ?*const usize, rg_ref_counts_: ?*u32, rg_row_status_: ?*u32) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).AddRefRows(@as(*const IRowset, @ptrCast(self)), c_rows_, rgh_rows_, rg_ref_counts_, rg_row_status_);
            }
            pub inline fn getData(self: *const T, h_row_: usize, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).GetData(@as(*const IRowset, @ptrCast(self)), h_row_, h_accessor_, p_data_);
            }
            pub inline fn getNextRows(self: *const T, h_reserved_: usize, l_rows_offset_: isize, c_rows_: isize, pc_rows_obtained_: ?*usize, prgh_rows_: ?*?*usize) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).GetNextRows(@as(*const IRowset, @ptrCast(self)), h_reserved_, l_rows_offset_, c_rows_, pc_rows_obtained_, prgh_rows_);
            }
            pub inline fn releaseRows(self: *const T, c_rows_: usize, rgh_rows_: ?*const usize, rg_row_options_: ?*u32, rg_ref_counts_: ?*u32, rg_row_status_: ?*u32) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).ReleaseRows(@as(*const IRowset, @ptrCast(self)), c_rows_, rgh_rows_, rg_row_options_, rg_ref_counts_, rg_row_status_);
            }
            pub inline fn restartPosition(self: *const T, h_reserved_: usize) HRESULT {
                return @as(*const IRowset.VTable, @ptrCast(self.vtable)).RestartPosition(@as(*const IRowset, @ptrCast(self)), h_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetInfo_Value = Guid.initString("0c733a55-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetInfo = &IID_IRowsetInfo_Value;
pub const IRowsetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn (
            self: *const IRowsetInfo,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_sets: ?*u32,
            prg_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferencedRowset: *const fn (
            self: *const IRowsetInfo,
            i_ordinal: usize,
            riid: ?*const Guid,
            pp_referenced_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: *const fn (
            self: *const IRowsetInfo,
            riid: ?*const Guid,
            pp_specification: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProperties(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_sets_: ?*u32, prg_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IRowsetInfo, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_sets_, prg_property_sets_);
            }
            pub inline fn getReferencedRowset(self: *const T, i_ordinal_: usize, riid_: ?*const Guid, pp_referenced_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetReferencedRowset(@as(*const IRowsetInfo, @ptrCast(self)), i_ordinal_, riid_, pp_referenced_rowset_);
            }
            pub inline fn getSpecification(self: *const T, riid_: ?*const Guid, pp_specification_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetInfo.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IRowsetInfo, @ptrCast(self)), riid_, pp_specification_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOMPAREENUM = enum(i32) {
    LT = 0,
    EQ = 1,
    GT = 2,
    NE = 3,
    NOTCOMPARABLE = 4,
};
pub const DBCOMPARE_LT = DBCOMPAREENUM.LT;
pub const DBCOMPARE_EQ = DBCOMPAREENUM.EQ;
pub const DBCOMPARE_GT = DBCOMPAREENUM.GT;
pub const DBCOMPARE_NE = DBCOMPAREENUM.NE;
pub const DBCOMPARE_NOTCOMPARABLE = DBCOMPAREENUM.NOTCOMPARABLE;

const IID_IRowsetLocate_Value = Guid.initString("0c733a7d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetLocate = &IID_IRowsetLocate_Value;
pub const IRowsetLocate = extern struct {
    pub const VTable = extern struct {
        base: IRowset.VTable,
        Compare: *const fn (
            self: *const IRowsetLocate,
            h_reserved: usize,
            cb_bookmark1: usize,
            p_bookmark1: ?*const u8,
            cb_bookmark2: usize,
            p_bookmark2: ?*const u8,
            p_comparison: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAt: *const fn (
            self: *const IRowsetLocate,
            h_reserved1: usize,
            h_reserved2: usize,
            cb_bookmark: usize,
            p_bookmark: ?*const u8,
            l_rows_offset: isize,
            c_rows: isize,
            pc_rows_obtained: ?*usize,
            prgh_rows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsByBookmark: *const fn (
            self: *const IRowsetLocate,
            h_reserved: usize,
            c_rows: usize,
            rgcb_bookmarks: ?*const usize,
            rgp_bookmarks: ?*const ?*u8,
            rgh_rows: ?*usize,
            rg_row_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: *const fn (
            self: *const IRowsetLocate,
            h_reserved: usize,
            c_bookmarks: usize,
            rgcb_bookmarks: ?*const usize,
            rgp_bookmarks: ?*const ?*u8,
            rg_hashed_values: ?*usize,
            rg_bookmark_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowset.MethodMixin(T);
            pub inline fn compare(self: *const T, h_reserved_: usize, cb_bookmark1_: usize, p_bookmark1_: ?*const u8, cb_bookmark2_: usize, p_bookmark2_: ?*const u8, p_comparison_: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).Compare(@as(*const IRowsetLocate, @ptrCast(self)), h_reserved_, cb_bookmark1_, p_bookmark1_, cb_bookmark2_, p_bookmark2_, p_comparison_);
            }
            pub inline fn getRowsAt(self: *const T, h_reserved1_: usize, h_reserved2_: usize, cb_bookmark_: usize, p_bookmark_: ?*const u8, l_rows_offset_: isize, c_rows_: isize, pc_rows_obtained_: ?*usize, prgh_rows_: ?*?*usize) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).GetRowsAt(@as(*const IRowsetLocate, @ptrCast(self)), h_reserved1_, h_reserved2_, cb_bookmark_, p_bookmark_, l_rows_offset_, c_rows_, pc_rows_obtained_, prgh_rows_);
            }
            pub inline fn getRowsByBookmark(self: *const T, h_reserved_: usize, c_rows_: usize, rgcb_bookmarks_: ?*const usize, rgp_bookmarks_: ?*const ?*u8, rgh_rows_: ?*usize, rg_row_status_: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).GetRowsByBookmark(@as(*const IRowsetLocate, @ptrCast(self)), h_reserved_, c_rows_, rgcb_bookmarks_, rgp_bookmarks_, rgh_rows_, rg_row_status_);
            }
            pub inline fn hash(self: *const T, h_reserved_: usize, c_bookmarks_: usize, rgcb_bookmarks_: ?*const usize, rgp_bookmarks_: ?*const ?*u8, rg_hashed_values_: ?*usize, rg_bookmark_status_: ?*u32) HRESULT {
                return @as(*const IRowsetLocate.VTable, @ptrCast(self.vtable)).Hash(@as(*const IRowsetLocate, @ptrCast(self)), h_reserved_, c_bookmarks_, rgcb_bookmarks_, rgp_bookmarks_, rg_hashed_values_, rg_bookmark_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetResynch_Value = Guid.initString("0c733a84-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetResynch = &IID_IRowsetResynch_Value;
pub const IRowsetResynch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVisibleData: *const fn (
            self: *const IRowsetResynch,
            h_row: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResynchRows: *const fn (
            self: *const IRowsetResynch,
            c_rows: usize,
            rgh_rows: ?*const usize,
            pc_rows_resynched: ?*usize,
            prgh_rows_resynched: ?*?*usize,
            prg_row_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getVisibleData(self: *const T, h_row_: usize, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowsetResynch.VTable, @ptrCast(self.vtable)).GetVisibleData(@as(*const IRowsetResynch, @ptrCast(self)), h_row_, h_accessor_, p_data_);
            }
            pub inline fn resynchRows(self: *const T, c_rows_: usize, rgh_rows_: ?*const usize, pc_rows_resynched_: ?*usize, prgh_rows_resynched_: ?*?*usize, prg_row_status_: ?*?*u32) HRESULT {
                return @as(*const IRowsetResynch.VTable, @ptrCast(self.vtable)).ResynchRows(@as(*const IRowsetResynch, @ptrCast(self)), c_rows_, rgh_rows_, pc_rows_resynched_, prgh_rows_resynched_, prg_row_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetScroll_Value = Guid.initString("0c733a7e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetScroll = &IID_IRowsetScroll_Value;
pub const IRowsetScroll = extern struct {
    pub const VTable = extern struct {
        base: IRowsetLocate.VTable,
        GetApproximatePosition: *const fn (
            self: *const IRowsetScroll,
            h_reserved: usize,
            cb_bookmark: usize,
            p_bookmark: ?*const u8,
            pul_position: ?*usize,
            pc_rows: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAtRatio: *const fn (
            self: *const IRowsetScroll,
            h_reserved1: usize,
            h_reserved2: usize,
            ul_numerator: usize,
            ul_denominator: usize,
            c_rows: isize,
            pc_rows_obtained: ?*usize,
            prgh_rows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetLocate.MethodMixin(T);
            pub inline fn getApproximatePosition(self: *const T, h_reserved_: usize, cb_bookmark_: usize, p_bookmark_: ?*const u8, pul_position_: ?*usize, pc_rows_: ?*usize) HRESULT {
                return @as(*const IRowsetScroll.VTable, @ptrCast(self.vtable)).GetApproximatePosition(@as(*const IRowsetScroll, @ptrCast(self)), h_reserved_, cb_bookmark_, p_bookmark_, pul_position_, pc_rows_);
            }
            pub inline fn getRowsAtRatio(self: *const T, h_reserved1_: usize, h_reserved2_: usize, ul_numerator_: usize, ul_denominator_: usize, c_rows_: isize, pc_rows_obtained_: ?*usize, prgh_rows_: ?*?*usize) HRESULT {
                return @as(*const IRowsetScroll.VTable, @ptrCast(self.vtable)).GetRowsAtRatio(@as(*const IRowsetScroll, @ptrCast(self)), h_reserved1_, h_reserved2_, ul_numerator_, ul_denominator_, c_rows_, pc_rows_obtained_, prgh_rows_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IChapteredRowset_Value = Guid.initString("0c733a93-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IChapteredRowset = &IID_IChapteredRowset_Value;
pub const IChapteredRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefChapter: *const fn (
            self: *const IChapteredRowset,
            h_chapter: usize,
            pc_ref_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseChapter: *const fn (
            self: *const IChapteredRowset,
            h_chapter: usize,
            pc_ref_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addRefChapter(self: *const T, h_chapter_: usize, pc_ref_count_: ?*u32) HRESULT {
                return @as(*const IChapteredRowset.VTable, @ptrCast(self.vtable)).AddRefChapter(@as(*const IChapteredRowset, @ptrCast(self)), h_chapter_, pc_ref_count_);
            }
            pub inline fn releaseChapter(self: *const T, h_chapter_: usize, pc_ref_count_: ?*u32) HRESULT {
                return @as(*const IChapteredRowset.VTable, @ptrCast(self.vtable)).ReleaseChapter(@as(*const IChapteredRowset, @ptrCast(self)), h_chapter_, pc_ref_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetFind_Value = Guid.initString("0c733a9d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetFind = &IID_IRowsetFind_Value;
pub const IRowsetFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindNextRow: *const fn (
            self: *const IRowsetFind,
            h_chapter: usize,
            h_accessor: usize,
            p_find_value: ?*anyopaque,
            compare_op: u32,
            cb_bookmark: usize,
            p_bookmark: ?*const u8,
            l_rows_offset: isize,
            c_rows: isize,
            pc_rows_obtained: ?*usize,
            prgh_rows: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn findNextRow(self: *const T, h_chapter_: usize, h_accessor_: usize, p_find_value_: ?*anyopaque, compare_op_: u32, cb_bookmark_: usize, p_bookmark_: ?*const u8, l_rows_offset_: isize, c_rows_: isize, pc_rows_obtained_: ?*usize, prgh_rows_: ?*?*usize) HRESULT {
                return @as(*const IRowsetFind.VTable, @ptrCast(self.vtable)).FindNextRow(@as(*const IRowsetFind, @ptrCast(self)), h_chapter_, h_accessor_, p_find_value_, compare_op_, cb_bookmark_, p_bookmark_, l_rows_offset_, c_rows_, pc_rows_obtained_, prgh_rows_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPOSITIONFLAGSENUM = enum(i32) {
    OK = 0,
    NOROW = 1,
    BOF = 2,
    EOF = 3,
};
pub const DBPOSITION_OK = DBPOSITIONFLAGSENUM.OK;
pub const DBPOSITION_NOROW = DBPOSITIONFLAGSENUM.NOROW;
pub const DBPOSITION_BOF = DBPOSITIONFLAGSENUM.BOF;
pub const DBPOSITION_EOF = DBPOSITIONFLAGSENUM.EOF;

const IID_IRowPosition_Value = Guid.initString("0c733a94-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowPosition = &IID_IRowPosition_Value;
pub const IRowPosition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClearRowPosition: *const fn (
            self: *const IRowPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowPosition: *const fn (
            self: *const IRowPosition,
            ph_chapter: ?*usize,
            ph_row: ?*usize,
            pdw_position_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowset: *const fn (
            self: *const IRowPosition,
            riid: ?*const Guid,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: *const fn (
            self: *const IRowPosition,
            p_rowset: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRowPosition: *const fn (
            self: *const IRowPosition,
            h_chapter: usize,
            h_row: usize,
            dw_position_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clearRowPosition(self: *const T) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).ClearRowPosition(@as(*const IRowPosition, @ptrCast(self)));
            }
            pub inline fn getRowPosition(self: *const T, ph_chapter_: ?*usize, ph_row_: ?*usize, pdw_position_flags_: ?*u32) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).GetRowPosition(@as(*const IRowPosition, @ptrCast(self)), ph_chapter_, ph_row_, pdw_position_flags_);
            }
            pub inline fn getRowset(self: *const T, riid_: ?*const Guid, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).GetRowset(@as(*const IRowPosition, @ptrCast(self)), riid_, pp_rowset_);
            }
            pub inline fn initialize(self: *const T, p_rowset_: ?*IUnknown) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IRowPosition, @ptrCast(self)), p_rowset_);
            }
            pub inline fn setRowPosition(self: *const T, h_chapter_: usize, h_row_: usize, dw_position_flags_: u32) HRESULT {
                return @as(*const IRowPosition.VTable, @ptrCast(self.vtable)).SetRowPosition(@as(*const IRowPosition, @ptrCast(self)), h_chapter_, h_row_, dw_position_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowPositionChange_Value = Guid.initString("0997a571-126e-11d0-9f8a-00a0c9a0631e");
pub const IID_IRowPositionChange = &IID_IRowPositionChange_Value;
pub const IRowPositionChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRowPositionChange: *const fn (
            self: *const IRowPositionChange,
            e_reason: u32,
            e_phase: u32,
            f_cant_deny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onRowPositionChange(self: *const T, e_reason_: u32, e_phase_: u32, f_cant_deny_: BOOL) HRESULT {
                return @as(*const IRowPositionChange.VTable, @ptrCast(self.vtable)).OnRowPositionChange(@as(*const IRowPositionChange, @ptrCast(self)), e_reason_, e_phase_, f_cant_deny_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewRowset_Value = Guid.initString("0c733a97-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewRowset = &IID_IViewRowset_Value;
pub const IViewRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: *const fn (
            self: *const IViewRowset,
            riid: ?*const Guid,
            pp_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewRowset: *const fn (
            self: *const IViewRowset,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSpecification(self: *const T, riid_: ?*const Guid, pp_object_: ?*?*IUnknown) HRESULT {
                return @as(*const IViewRowset.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IViewRowset, @ptrCast(self)), riid_, pp_object_);
            }
            pub inline fn openViewRowset(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IViewRowset.VTable, @ptrCast(self.vtable)).OpenViewRowset(@as(*const IViewRowset, @ptrCast(self)), p_unk_outer_, riid_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewChapter_Value = Guid.initString("0c733a98-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewChapter = &IID_IViewChapter_Value;
pub const IViewChapter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: *const fn (
            self: *const IViewChapter,
            riid: ?*const Guid,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewChapter: *const fn (
            self: *const IViewChapter,
            h_source: usize,
            ph_view_chapter: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSpecification(self: *const T, riid_: ?*const Guid, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IViewChapter.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IViewChapter, @ptrCast(self)), riid_, pp_rowset_);
            }
            pub inline fn openViewChapter(self: *const T, h_source_: usize, ph_view_chapter_: ?*usize) HRESULT {
                return @as(*const IViewChapter.VTable, @ptrCast(self.vtable)).OpenViewChapter(@as(*const IViewChapter, @ptrCast(self)), h_source_, ph_view_chapter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewSort_Value = Guid.initString("0c733a9a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewSort = &IID_IViewSort_Value;
pub const IViewSort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSortOrder: *const fn (
            self: *const IViewSort,
            pc_values: ?*usize,
            prg_columns: ?*?*usize,
            prg_orders: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSortOrder: *const fn (
            self: *const IViewSort,
            c_values: usize,
            rg_columns: [*]const usize,
            rg_orders: [*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSortOrder(self: *const T, pc_values_: ?*usize, prg_columns_: ?*?*usize, prg_orders_: ?*?*u32) HRESULT {
                return @as(*const IViewSort.VTable, @ptrCast(self.vtable)).GetSortOrder(@as(*const IViewSort, @ptrCast(self)), pc_values_, prg_columns_, prg_orders_);
            }
            pub inline fn setSortOrder(self: *const T, c_values_: usize, rg_columns_: [*]const usize, rg_orders_: [*]const u32) HRESULT {
                return @as(*const IViewSort.VTable, @ptrCast(self.vtable)).SetSortOrder(@as(*const IViewSort, @ptrCast(self)), c_values_, rg_columns_, rg_orders_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewFilter_Value = Guid.initString("0c733a9b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IViewFilter = &IID_IViewFilter_Value;
pub const IViewFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: *const fn (
            self: *const IViewFilter,
            h_accessor: usize,
            pc_rows: ?*usize,
            p_compare_ops: [*]?*u32,
            p_criteria_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterBindings: *const fn (
            self: *const IViewFilter,
            pc_bindings: ?*usize,
            prg_bindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilter: *const fn (
            self: *const IViewFilter,
            h_accessor: usize,
            c_rows: usize,
            compare_ops: [*]u32,
            p_criteria_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFilter(self: *const T, h_accessor_: usize, pc_rows_: ?*usize, p_compare_ops_: [*]?*u32, p_criteria_data_: ?*anyopaque) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IViewFilter, @ptrCast(self)), h_accessor_, pc_rows_, p_compare_ops_, p_criteria_data_);
            }
            pub inline fn getFilterBindings(self: *const T, pc_bindings_: ?*usize, prg_bindings_: ?*?*DBBINDING) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).GetFilterBindings(@as(*const IViewFilter, @ptrCast(self)), pc_bindings_, prg_bindings_);
            }
            pub inline fn setFilter(self: *const T, h_accessor_: usize, c_rows_: usize, compare_ops_: [*]u32, p_criteria_data_: ?*anyopaque) HRESULT {
                return @as(*const IViewFilter.VTable, @ptrCast(self.vtable)).SetFilter(@as(*const IViewFilter, @ptrCast(self)), h_accessor_, c_rows_, compare_ops_, p_criteria_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetView_Value = Guid.initString("0c733a99-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetView = &IID_IRowsetView_Value;
pub const IRowsetView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: *const fn (
            self: *const IRowsetView,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_view: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetView: *const fn (
            self: *const IRowsetView,
            h_chapter: usize,
            riid: ?*const Guid,
            ph_chapter_source: ?*usize,
            pp_view: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createView(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_view_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetView.VTable, @ptrCast(self.vtable)).CreateView(@as(*const IRowsetView, @ptrCast(self)), p_unk_outer_, riid_, pp_view_);
            }
            pub inline fn getView(self: *const T, h_chapter_: usize, riid_: ?*const Guid, ph_chapter_source_: ?*usize, pp_view_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetView.VTable, @ptrCast(self.vtable)).GetView(@as(*const IRowsetView, @ptrCast(self)), h_chapter_, riid_, ph_chapter_source_, pp_view_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChange_Value = Guid.initString("0c733a05-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChange = &IID_IRowsetChange_Value;
pub const IRowsetChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteRows: *const fn (
            self: *const IRowsetChange,
            h_reserved: usize,
            c_rows: usize,
            rgh_rows: ?*const usize,
            rg_row_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: *const fn (
            self: *const IRowsetChange,
            h_row: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertRow: *const fn (
            self: *const IRowsetChange,
            h_reserved: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
            ph_row: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn deleteRows(self: *const T, h_reserved_: usize, c_rows_: usize, rgh_rows_: ?*const usize, rg_row_status_: ?*u32) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).DeleteRows(@as(*const IRowsetChange, @ptrCast(self)), h_reserved_, c_rows_, rgh_rows_, rg_row_status_);
            }
            pub inline fn setData(self: *const T, h_row_: usize, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).SetData(@as(*const IRowsetChange, @ptrCast(self)), h_row_, h_accessor_, p_data_);
            }
            pub inline fn insertRow(self: *const T, h_reserved_: usize, h_accessor_: usize, p_data_: ?*anyopaque, ph_row_: ?*usize) HRESULT {
                return @as(*const IRowsetChange.VTable, @ptrCast(self.vtable)).InsertRow(@as(*const IRowsetChange, @ptrCast(self)), h_reserved_, h_accessor_, p_data_, ph_row_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPENDINGSTATUSENUM = enum(i32) {
    NEW = 1,
    CHANGED = 2,
    DELETED = 4,
    UNCHANGED = 8,
    INVALIDROW = 16,
};
pub const DBPENDINGSTATUS_NEW = DBPENDINGSTATUSENUM.NEW;
pub const DBPENDINGSTATUS_CHANGED = DBPENDINGSTATUSENUM.CHANGED;
pub const DBPENDINGSTATUS_DELETED = DBPENDINGSTATUSENUM.DELETED;
pub const DBPENDINGSTATUS_UNCHANGED = DBPENDINGSTATUSENUM.UNCHANGED;
pub const DBPENDINGSTATUS_INVALIDROW = DBPENDINGSTATUSENUM.INVALIDROW;

const IID_IRowsetUpdate_Value = Guid.initString("0c733a6d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetUpdate = &IID_IRowsetUpdate_Value;
pub const IRowsetUpdate = extern struct {
    pub const VTable = extern struct {
        base: IRowsetChange.VTable,
        GetOriginalData: *const fn (
            self: *const IRowsetUpdate,
            h_row: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPendingRows: *const fn (
            self: *const IRowsetUpdate,
            h_reserved: usize,
            dw_row_status: u32,
            pc_pending_rows: ?*usize,
            prg_pending_rows: ?*?*usize,
            prg_pending_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowStatus: *const fn (
            self: *const IRowsetUpdate,
            h_reserved: usize,
            c_rows: usize,
            rgh_rows: ?*const usize,
            rg_pending_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: *const fn (
            self: *const IRowsetUpdate,
            h_reserved: usize,
            c_rows: usize,
            rgh_rows: ?*const usize,
            pc_rows_undone: ?*usize,
            prg_rows_undone: ?*?*usize,
            prg_row_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: *const fn (
            self: *const IRowsetUpdate,
            h_reserved: usize,
            c_rows: usize,
            rgh_rows: ?*const usize,
            pc_rows: ?*usize,
            prg_rows: ?*?*usize,
            prg_row_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetChange.MethodMixin(T);
            pub inline fn getOriginalData(self: *const T, h_row_: usize, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetOriginalData(@as(*const IRowsetUpdate, @ptrCast(self)), h_row_, h_accessor_, p_data_);
            }
            pub inline fn getPendingRows(self: *const T, h_reserved_: usize, dw_row_status_: u32, pc_pending_rows_: ?*usize, prg_pending_rows_: ?*?*usize, prg_pending_status_: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetPendingRows(@as(*const IRowsetUpdate, @ptrCast(self)), h_reserved_, dw_row_status_, pc_pending_rows_, prg_pending_rows_, prg_pending_status_);
            }
            pub inline fn getRowStatus(self: *const T, h_reserved_: usize, c_rows_: usize, rgh_rows_: ?*const usize, rg_pending_status_: ?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).GetRowStatus(@as(*const IRowsetUpdate, @ptrCast(self)), h_reserved_, c_rows_, rgh_rows_, rg_pending_status_);
            }
            pub inline fn undo(self: *const T, h_reserved_: usize, c_rows_: usize, rgh_rows_: ?*const usize, pc_rows_undone_: ?*usize, prg_rows_undone_: ?*?*usize, prg_row_status_: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).Undo(@as(*const IRowsetUpdate, @ptrCast(self)), h_reserved_, c_rows_, rgh_rows_, pc_rows_undone_, prg_rows_undone_, prg_row_status_);
            }
            pub inline fn update(self: *const T, h_reserved_: usize, c_rows_: usize, rgh_rows_: ?*const usize, pc_rows_: ?*usize, prg_rows_: ?*?*usize, prg_row_status_: ?*?*u32) HRESULT {
                return @as(*const IRowsetUpdate.VTable, @ptrCast(self.vtable)).Update(@as(*const IRowsetUpdate, @ptrCast(self)), h_reserved_, c_rows_, rgh_rows_, pc_rows_, prg_rows_, prg_row_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetIdentity_Value = Guid.initString("0c733a09-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIdentity = &IID_IRowsetIdentity_Value;
pub const IRowsetIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSameRow: *const fn (
            self: *const IRowsetIdentity,
            h_this_row: usize,
            h_that_row: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isSameRow(self: *const T, h_this_row_: usize, h_that_row_: usize) HRESULT {
                return @as(*const IRowsetIdentity.VTable, @ptrCast(self.vtable)).IsSameRow(@as(*const IRowsetIdentity, @ptrCast(self)), h_this_row_, h_that_row_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetNotify_Value = Guid.initString("0c733a83-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNotify = &IID_IRowsetNotify_Value;
pub const IRowsetNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFieldChange: *const fn (
            self: *const IRowsetNotify,
            p_rowset: ?*IRowset,
            h_row: usize,
            c_columns: usize,
            rg_columns: [*]usize,
            e_reason: u32,
            e_phase: u32,
            f_cant_deny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowChange: *const fn (
            self: *const IRowsetNotify,
            p_rowset: ?*IRowset,
            c_rows: usize,
            rgh_rows: [*]const usize,
            e_reason: u32,
            e_phase: u32,
            f_cant_deny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetChange: *const fn (
            self: *const IRowsetNotify,
            p_rowset: ?*IRowset,
            e_reason: u32,
            e_phase: u32,
            f_cant_deny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onFieldChange(self: *const T, p_rowset_: ?*IRowset, h_row_: usize, c_columns_: usize, rg_columns_: [*]usize, e_reason_: u32, e_phase_: u32, f_cant_deny_: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnFieldChange(@as(*const IRowsetNotify, @ptrCast(self)), p_rowset_, h_row_, c_columns_, rg_columns_, e_reason_, e_phase_, f_cant_deny_);
            }
            pub inline fn onRowChange(self: *const T, p_rowset_: ?*IRowset, c_rows_: usize, rgh_rows_: [*]const usize, e_reason_: u32, e_phase_: u32, f_cant_deny_: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnRowChange(@as(*const IRowsetNotify, @ptrCast(self)), p_rowset_, c_rows_, rgh_rows_, e_reason_, e_phase_, f_cant_deny_);
            }
            pub inline fn onRowsetChange(self: *const T, p_rowset_: ?*IRowset, e_reason_: u32, e_phase_: u32, f_cant_deny_: BOOL) HRESULT {
                return @as(*const IRowsetNotify.VTable, @ptrCast(self.vtable)).OnRowsetChange(@as(*const IRowsetNotify, @ptrCast(self)), p_rowset_, e_reason_, e_phase_, f_cant_deny_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBSEEKENUM = enum(i32) {
    INVALID = 0,
    FIRSTEQ = 1,
    LASTEQ = 2,
    AFTEREQ = 4,
    AFTER = 8,
    BEFOREEQ = 16,
    BEFORE = 32,
};
pub const DBSEEK_INVALID = DBSEEKENUM.INVALID;
pub const DBSEEK_FIRSTEQ = DBSEEKENUM.FIRSTEQ;
pub const DBSEEK_LASTEQ = DBSEEKENUM.LASTEQ;
pub const DBSEEK_AFTEREQ = DBSEEKENUM.AFTEREQ;
pub const DBSEEK_AFTER = DBSEEKENUM.AFTER;
pub const DBSEEK_BEFOREEQ = DBSEEKENUM.BEFOREEQ;
pub const DBSEEK_BEFORE = DBSEEKENUM.BEFORE;

pub const DBRANGEENUM = enum(i32) {
    INCLUSIVESTART = 0,
    // INCLUSIVEEND = 0, this enum value conflicts with INCLUSIVESTART
    EXCLUSIVESTART = 1,
    EXCLUSIVEEND = 2,
    EXCLUDENULLS = 4,
    PREFIX = 8,
    MATCH = 16,
};
pub const DBRANGE_INCLUSIVESTART = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_INCLUSIVEEND = DBRANGEENUM.INCLUSIVESTART;
pub const DBRANGE_EXCLUSIVESTART = DBRANGEENUM.EXCLUSIVESTART;
pub const DBRANGE_EXCLUSIVEEND = DBRANGEENUM.EXCLUSIVEEND;
pub const DBRANGE_EXCLUDENULLS = DBRANGEENUM.EXCLUDENULLS;
pub const DBRANGE_PREFIX = DBRANGEENUM.PREFIX;
pub const DBRANGE_MATCH = DBRANGEENUM.MATCH;

pub const DBRANGEENUM20 = enum(i32) {
    SHIFT = 24,
    MASK = 255,
};
pub const DBRANGE_MATCH_N_SHIFT = DBRANGEENUM20.SHIFT;
pub const DBRANGE_MATCH_N_MASK = DBRANGEENUM20.MASK;

const IID_IRowsetIndex_Value = Guid.initString("0c733a82-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetIndex = &IID_IRowsetIndex_Value;
pub const IRowsetIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexInfo: *const fn (
            self: *const IRowsetIndex,
            pc_key_columns: ?*usize,
            prg_index_column_desc: ?*?*DBINDEXCOLUMNDESC,
            pc_index_property_sets: ?*u32,
            prg_index_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: *const fn (
            self: *const IRowsetIndex,
            h_accessor: usize,
            c_key_values: usize,
            p_data: ?*anyopaque,
            dw_seek_options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: *const fn (
            self: *const IRowsetIndex,
            h_accessor: usize,
            c_start_key_columns: usize,
            p_start_data: ?*anyopaque,
            c_end_key_columns: usize,
            p_end_data: ?*anyopaque,
            dw_range_options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIndexInfo(self: *const T, pc_key_columns_: ?*usize, prg_index_column_desc_: ?*?*DBINDEXCOLUMNDESC, pc_index_property_sets_: ?*u32, prg_index_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).GetIndexInfo(@as(*const IRowsetIndex, @ptrCast(self)), pc_key_columns_, prg_index_column_desc_, pc_index_property_sets_, prg_index_property_sets_);
            }
            pub inline fn seek(self: *const T, h_accessor_: usize, c_key_values_: usize, p_data_: ?*anyopaque, dw_seek_options_: u32) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).Seek(@as(*const IRowsetIndex, @ptrCast(self)), h_accessor_, c_key_values_, p_data_, dw_seek_options_);
            }
            pub inline fn setRange(self: *const T, h_accessor_: usize, c_start_key_columns_: usize, p_start_data_: ?*anyopaque, c_end_key_columns_: usize, p_end_data_: ?*anyopaque, dw_range_options_: u32) HRESULT {
                return @as(*const IRowsetIndex.VTable, @ptrCast(self.vtable)).SetRange(@as(*const IRowsetIndex, @ptrCast(self)), h_accessor_, c_start_key_columns_, p_start_data_, c_end_key_columns_, p_end_data_, dw_range_options_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommand_Value = Guid.initString("0c733a63-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommand = &IID_ICommand_Value;
pub const ICommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: *const fn (
            self: *const ICommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: *const fn (
            self: *const ICommand,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            p_params: ?*DBPARAMS,
            pc_rows_affected: ?*isize,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDBSession: *const fn (
            self: *const ICommand,
            riid: ?*const Guid,
            pp_session: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn cancel(self: *const T) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).Cancel(@as(*const ICommand, @ptrCast(self)));
            }
            pub inline fn execute(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, p_params_: ?*DBPARAMS, pc_rows_affected_: ?*isize, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).Execute(@as(*const ICommand, @ptrCast(self)), p_unk_outer_, riid_, p_params_, pc_rows_affected_, pp_rowset_);
            }
            pub inline fn getDBSession(self: *const T, riid_: ?*const Guid, pp_session_: ?*?*IUnknown) HRESULT {
                return @as(*const ICommand.VTable, @ptrCast(self.vtable)).GetDBSession(@as(*const ICommand, @ptrCast(self)), riid_, pp_session_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBRESULTFLAGENUM = enum(i32) {
    DEFAULT = 0,
    ROWSET = 1,
    ROW = 2,
};
pub const DBRESULTFLAG_DEFAULT = DBRESULTFLAGENUM.DEFAULT;
pub const DBRESULTFLAG_ROWSET = DBRESULTFLAGENUM.ROWSET;
pub const DBRESULTFLAG_ROW = DBRESULTFLAGENUM.ROW;

const IID_IMultipleResults_Value = Guid.initString("0c733a90-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMultipleResults = &IID_IMultipleResults_Value;
pub const IMultipleResults = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResult: *const fn (
            self: *const IMultipleResults,
            p_unk_outer: ?*IUnknown,
            l_result_flag: isize,
            riid: ?*const Guid,
            pc_rows_affected: ?*isize,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getResult(self: *const T, p_unk_outer_: ?*IUnknown, l_result_flag_: isize, riid_: ?*const Guid, pc_rows_affected_: ?*isize, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IMultipleResults.VTable, @ptrCast(self.vtable)).GetResult(@as(*const IMultipleResults, @ptrCast(self)), p_unk_outer_, l_result_flag_, riid_, pc_rows_affected_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCONVERTFLAGSENUM = enum(i32) {
    COLUMN = 0,
    PARAMETER = 1,
};
pub const DBCONVERTFLAGS_COLUMN = DBCONVERTFLAGSENUM.COLUMN;
pub const DBCONVERTFLAGS_PARAMETER = DBCONVERTFLAGSENUM.PARAMETER;

pub const DBCONVERTFLAGSENUM20 = enum(i32) {
    ISLONG = 2,
    ISFIXEDLENGTH = 4,
    FROMVARIANT = 8,
};
pub const DBCONVERTFLAGS_ISLONG = DBCONVERTFLAGSENUM20.ISLONG;
pub const DBCONVERTFLAGS_ISFIXEDLENGTH = DBCONVERTFLAGSENUM20.ISFIXEDLENGTH;
pub const DBCONVERTFLAGS_FROMVARIANT = DBCONVERTFLAGSENUM20.FROMVARIANT;

const IID_IConvertType_Value = Guid.initString("0c733a88-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IConvertType = &IID_IConvertType_Value;
pub const IConvertType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanConvert: *const fn (
            self: *const IConvertType,
            w_from_type: u16,
            w_to_type: u16,
            dw_convert_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn canConvert(self: *const T, w_from_type_: u16, w_to_type_: u16, dw_convert_flags_: u32) HRESULT {
                return @as(*const IConvertType.VTable, @ptrCast(self.vtable)).CanConvert(@as(*const IConvertType, @ptrCast(self)), w_from_type_, w_to_type_, dw_convert_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPrepare_Value = Guid.initString("0c733a26-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPrepare = &IID_ICommandPrepare_Value;
pub const ICommandPrepare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: *const fn (
            self: *const ICommandPrepare,
            c_expected_runs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unprepare: *const fn (
            self: *const ICommandPrepare,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn prepare(self: *const T, c_expected_runs_: u32) HRESULT {
                return @as(*const ICommandPrepare.VTable, @ptrCast(self.vtable)).Prepare(@as(*const ICommandPrepare, @ptrCast(self)), c_expected_runs_);
            }
            pub inline fn unprepare(self: *const T) HRESULT {
                return @as(*const ICommandPrepare.VTable, @ptrCast(self.vtable)).Unprepare(@as(*const ICommandPrepare, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandProperties_Value = Guid.initString("0c733a79-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandProperties = &IID_ICommandProperties_Value;
pub const ICommandProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn (
            self: *const ICommandProperties,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_sets: ?*u32,
            prg_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn (
            self: *const ICommandProperties,
            c_property_sets: u32,
            rg_property_sets: [*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProperties(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_sets_: ?*u32, prg_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const ICommandProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const ICommandProperties, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_sets_, prg_property_sets_);
            }
            pub inline fn setProperties(self: *const T, c_property_sets_: u32, rg_property_sets_: [*]DBPROPSET) HRESULT {
                return @as(*const ICommandProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const ICommandProperties, @ptrCast(self)), c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandText_Value = Guid.initString("0c733a27-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandText = &IID_ICommandText_Value;
pub const ICommandText = extern struct {
    pub const VTable = extern struct {
        base: ICommand.VTable,
        GetCommandText: *const fn (
            self: *const ICommandText,
            pguid_dialect: ?*Guid,
            ppwsz_command: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandText: *const fn (
            self: *const ICommandText,
            rguid_dialect: ?*const Guid,
            pwsz_command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICommand.MethodMixin(T);
            pub inline fn getCommandText(self: *const T, pguid_dialect_: ?*Guid, ppwsz_command_: ?*?PWSTR) HRESULT {
                return @as(*const ICommandText.VTable, @ptrCast(self.vtable)).GetCommandText(@as(*const ICommandText, @ptrCast(self)), pguid_dialect_, ppwsz_command_);
            }
            pub inline fn setCommandText(self: *const T, rguid_dialect_: ?*const Guid, pwsz_command_: ?[*:0]const u16) HRESULT {
                return @as(*const ICommandText.VTable, @ptrCast(self.vtable)).SetCommandText(@as(*const ICommandText, @ptrCast(self)), rguid_dialect_, pwsz_command_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandWithParameters_Value = Guid.initString("0c733a64-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandWithParameters = &IID_ICommandWithParameters_Value;
pub const ICommandWithParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: *const fn (
            self: *const ICommandWithParameters,
            pc_params: ?*usize,
            prg_param_info: ?*?*DBPARAMINFO,
            pp_names_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapParameterNames: *const fn (
            self: *const ICommandWithParameters,
            c_param_names: usize,
            rg_param_names: [*]?PWSTR,
            rg_param_ordinals: [*]isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameterInfo: *const fn (
            self: *const ICommandWithParameters,
            c_params: usize,
            rg_param_ordinals: ?[*]const usize,
            rg_param_bind_info: ?[*]const DBPARAMBINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getParameterInfo(self: *const T, pc_params_: ?*usize, prg_param_info_: ?*?*DBPARAMINFO, pp_names_buffer_: ?*?*u16) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).GetParameterInfo(@as(*const ICommandWithParameters, @ptrCast(self)), pc_params_, prg_param_info_, pp_names_buffer_);
            }
            pub inline fn mapParameterNames(self: *const T, c_param_names_: usize, rg_param_names_: [*]?PWSTR, rg_param_ordinals_: [*]isize) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).MapParameterNames(@as(*const ICommandWithParameters, @ptrCast(self)), c_param_names_, rg_param_names_, rg_param_ordinals_);
            }
            pub inline fn setParameterInfo(self: *const T, c_params_: usize, rg_param_ordinals_: ?[*]const usize, rg_param_bind_info_: ?[*]const DBPARAMBINDINFO) HRESULT {
                return @as(*const ICommandWithParameters.VTable, @ptrCast(self.vtable)).SetParameterInfo(@as(*const ICommandWithParameters, @ptrCast(self)), c_params_, rg_param_ordinals_, rg_param_bind_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsRowset_Value = Guid.initString("0c733a10-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsRowset = &IID_IColumnsRowset_Value;
pub const IColumnsRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableColumns: *const fn (
            self: *const IColumnsRowset,
            pc_opt_columns: ?*usize,
            prg_opt_columns: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnsRowset: *const fn (
            self: *const IColumnsRowset,
            p_unk_outer: ?*IUnknown,
            c_opt_columns: usize,
            rg_opt_columns: [*]const DBID,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
            pp_col_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAvailableColumns(self: *const T, pc_opt_columns_: ?*usize, prg_opt_columns_: ?*?*DBID) HRESULT {
                return @as(*const IColumnsRowset.VTable, @ptrCast(self.vtable)).GetAvailableColumns(@as(*const IColumnsRowset, @ptrCast(self)), pc_opt_columns_, prg_opt_columns_);
            }
            pub inline fn getColumnsRowset(self: *const T, p_unk_outer_: ?*IUnknown, c_opt_columns_: usize, rg_opt_columns_: [*]const DBID, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET, pp_col_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IColumnsRowset.VTable, @ptrCast(self.vtable)).GetColumnsRowset(@as(*const IColumnsRowset, @ptrCast(self)), p_unk_outer_, c_opt_columns_, rg_opt_columns_, riid_, c_property_sets_, rg_property_sets_, pp_col_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo_Value = Guid.initString("0c733a11-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo = &IID_IColumnsInfo_Value;
pub const IColumnsInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnInfo: *const fn (
            self: *const IColumnsInfo,
            pc_columns: ?*usize,
            prg_info: ?*?*DBCOLUMNINFO,
            pp_strings_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapColumnIDs: *const fn (
            self: *const IColumnsInfo,
            c_column_i_ds: usize,
            rg_column_i_ds: ?[*]const DBID,
            rg_columns: ?[*]usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getColumnInfo(self: *const T, pc_columns_: ?*usize, prg_info_: ?*?*DBCOLUMNINFO, pp_strings_buffer_: ?*?*u16) HRESULT {
                return @as(*const IColumnsInfo.VTable, @ptrCast(self.vtable)).GetColumnInfo(@as(*const IColumnsInfo, @ptrCast(self)), pc_columns_, prg_info_, pp_strings_buffer_);
            }
            pub inline fn mapColumnIDs(self: *const T, c_column_i_ds_: usize, rg_column_i_ds_: ?[*]const DBID, rg_columns_: ?[*]usize) HRESULT {
                return @as(*const IColumnsInfo.VTable, @ptrCast(self.vtable)).MapColumnIDs(@as(*const IColumnsInfo, @ptrCast(self)), c_column_i_ds_, rg_column_i_ds_, rg_columns_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateCommand_Value = Guid.initString("0c733a1d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateCommand = &IID_IDBCreateCommand_Value;
pub const IDBCreateCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCommand: *const fn (
            self: *const IDBCreateCommand,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_command: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createCommand(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_command_: ?*?*IUnknown) HRESULT {
                return @as(*const IDBCreateCommand.VTable, @ptrCast(self.vtable)).CreateCommand(@as(*const IDBCreateCommand, @ptrCast(self)), p_unk_outer_, riid_, pp_command_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateSession_Value = Guid.initString("0c733a5d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBCreateSession = &IID_IDBCreateSession_Value;
pub const IDBCreateSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: *const fn (
            self: *const IDBCreateSession,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_d_b_session: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createSession(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_d_b_session_: ?*?*IUnknown) HRESULT {
                return @as(*const IDBCreateSession.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IDBCreateSession, @ptrCast(self)), p_unk_outer_, riid_, pp_d_b_session_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBSOURCETYPEENUM = enum(i32) {
    DATASOURCE = 1,
    ENUMERATOR = 2,
};
pub const DBSOURCETYPE_DATASOURCE = DBSOURCETYPEENUM.DATASOURCE;
pub const DBSOURCETYPE_ENUMERATOR = DBSOURCETYPEENUM.ENUMERATOR;

pub const DBSOURCETYPEENUM20 = enum(i32) {
    TDP = 1,
    MDP = 3,
};
pub const DBSOURCETYPE_DATASOURCE_TDP = DBSOURCETYPEENUM20.TDP;
pub const DBSOURCETYPE_DATASOURCE_MDP = DBSOURCETYPEENUM20.MDP;

pub const DBSOURCETYPEENUM25 = enum(i32) {
    R = 4,
};
pub const DBSOURCETYPE_BINDER = DBSOURCETYPEENUM25.R;

const IID_ISourcesRowset_Value = Guid.initString("0c733a1e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISourcesRowset = &IID_ISourcesRowset_Value;
pub const ISourcesRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourcesRowset: *const fn (
            self: *const ISourcesRowset,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_properties: ?[*]DBPROPSET,
            pp_sources_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSourcesRowset(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, c_property_sets_: u32, rg_properties_: ?[*]DBPROPSET, pp_sources_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const ISourcesRowset.VTable, @ptrCast(self.vtable)).GetSourcesRowset(@as(*const ISourcesRowset, @ptrCast(self)), p_unk_outer_, riid_, c_property_sets_, rg_properties_, pp_sources_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBProperties_Value = Guid.initString("0c733a8a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBProperties = &IID_IDBProperties_Value;
pub const IDBProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn (
            self: *const IDBProperties,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_sets: ?*u32,
            prg_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: *const fn (
            self: *const IDBProperties,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_info_sets: ?*u32,
            prg_property_info_sets: ?*?*DBPROPINFOSET,
            pp_desc_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn (
            self: *const IDBProperties,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProperties(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_sets_: ?*u32, prg_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IDBProperties, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_sets_, prg_property_sets_);
            }
            pub inline fn getPropertyInfo(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_info_sets_: ?*u32, prg_property_info_sets_: ?*?*DBPROPINFOSET, pp_desc_buffer_: ?*?*u16) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IDBProperties, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_info_sets_, prg_property_info_sets_, pp_desc_buffer_);
            }
            pub inline fn setProperties(self: *const T, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET) HRESULT {
                return @as(*const IDBProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IDBProperties, @ptrCast(self)), c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBInitialize_Value = Guid.initString("0c733a8b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInitialize = &IID_IDBInitialize_Value;
pub const IDBInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: *const fn (
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T) HRESULT {
                return @as(*const IDBInitialize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDBInitialize, @ptrCast(self)));
            }
            pub inline fn uninitialize(self: *const T) HRESULT {
                return @as(*const IDBInitialize.VTable, @ptrCast(self.vtable)).Uninitialize(@as(*const IDBInitialize, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBLITERALENUM = enum(i32) {
    INVALID = 0,
    BINARY_LITERAL = 1,
    CATALOG_NAME = 2,
    CATALOG_SEPARATOR = 3,
    CHAR_LITERAL = 4,
    COLUMN_ALIAS = 5,
    COLUMN_NAME = 6,
    CORRELATION_NAME = 7,
    CURSOR_NAME = 8,
    ESCAPE_PERCENT = 9,
    ESCAPE_UNDERSCORE = 10,
    INDEX_NAME = 11,
    LIKE_PERCENT = 12,
    LIKE_UNDERSCORE = 13,
    PROCEDURE_NAME = 14,
    QUOTE = 15,
    SCHEMA_NAME = 16,
    TABLE_NAME = 17,
    TEXT_COMMAND = 18,
    USER_NAME = 19,
    VIEW_NAME = 20,
};
pub const DBLITERAL_INVALID = DBLITERALENUM.INVALID;
pub const DBLITERAL_BINARY_LITERAL = DBLITERALENUM.BINARY_LITERAL;
pub const DBLITERAL_CATALOG_NAME = DBLITERALENUM.CATALOG_NAME;
pub const DBLITERAL_CATALOG_SEPARATOR = DBLITERALENUM.CATALOG_SEPARATOR;
pub const DBLITERAL_CHAR_LITERAL = DBLITERALENUM.CHAR_LITERAL;
pub const DBLITERAL_COLUMN_ALIAS = DBLITERALENUM.COLUMN_ALIAS;
pub const DBLITERAL_COLUMN_NAME = DBLITERALENUM.COLUMN_NAME;
pub const DBLITERAL_CORRELATION_NAME = DBLITERALENUM.CORRELATION_NAME;
pub const DBLITERAL_CURSOR_NAME = DBLITERALENUM.CURSOR_NAME;
pub const DBLITERAL_ESCAPE_PERCENT = DBLITERALENUM.ESCAPE_PERCENT;
pub const DBLITERAL_ESCAPE_UNDERSCORE = DBLITERALENUM.ESCAPE_UNDERSCORE;
pub const DBLITERAL_INDEX_NAME = DBLITERALENUM.INDEX_NAME;
pub const DBLITERAL_LIKE_PERCENT = DBLITERALENUM.LIKE_PERCENT;
pub const DBLITERAL_LIKE_UNDERSCORE = DBLITERALENUM.LIKE_UNDERSCORE;
pub const DBLITERAL_PROCEDURE_NAME = DBLITERALENUM.PROCEDURE_NAME;
pub const DBLITERAL_QUOTE = DBLITERALENUM.QUOTE;
pub const DBLITERAL_SCHEMA_NAME = DBLITERALENUM.SCHEMA_NAME;
pub const DBLITERAL_TABLE_NAME = DBLITERALENUM.TABLE_NAME;
pub const DBLITERAL_TEXT_COMMAND = DBLITERALENUM.TEXT_COMMAND;
pub const DBLITERAL_USER_NAME = DBLITERALENUM.USER_NAME;
pub const DBLITERAL_VIEW_NAME = DBLITERALENUM.VIEW_NAME;

pub const DBLITERALENUM20 = enum(i32) {
    CUBE_NAME = 21,
    DIMENSION_NAME = 22,
    HIERARCHY_NAME = 23,
    LEVEL_NAME = 24,
    MEMBER_NAME = 25,
    PROPERTY_NAME = 26,
    SCHEMA_SEPARATOR = 27,
    QUOTE_SUFFIX = 28,
};
pub const DBLITERAL_CUBE_NAME = DBLITERALENUM20.CUBE_NAME;
pub const DBLITERAL_DIMENSION_NAME = DBLITERALENUM20.DIMENSION_NAME;
pub const DBLITERAL_HIERARCHY_NAME = DBLITERALENUM20.HIERARCHY_NAME;
pub const DBLITERAL_LEVEL_NAME = DBLITERALENUM20.LEVEL_NAME;
pub const DBLITERAL_MEMBER_NAME = DBLITERALENUM20.MEMBER_NAME;
pub const DBLITERAL_PROPERTY_NAME = DBLITERALENUM20.PROPERTY_NAME;
pub const DBLITERAL_SCHEMA_SEPARATOR = DBLITERALENUM20.SCHEMA_SEPARATOR;
pub const DBLITERAL_QUOTE_SUFFIX = DBLITERALENUM20.QUOTE_SUFFIX;

pub const DBLITERALENUM21 = enum(i32) {
    PERCENT_SUFFIX = 29,
    UNDERSCORE_SUFFIX = 30,
};
pub const DBLITERAL_ESCAPE_PERCENT_SUFFIX = DBLITERALENUM21.PERCENT_SUFFIX;
pub const DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX = DBLITERALENUM21.UNDERSCORE_SUFFIX;

const IID_IDBInfo_Value = Guid.initString("0c733a89-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBInfo = &IID_IDBInfo_Value;
pub const IDBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeywords: *const fn (
            self: *const IDBInfo,
            ppwsz_keywords: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLiteralInfo: *const fn (
            self: *const IDBInfo,
            c_literals: u32,
            rg_literals: ?[*]const u32,
            pc_literal_info: ?*u32,
            prg_literal_info: ?*?*DBLITERALINFO,
            pp_char_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getKeywords(self: *const T, ppwsz_keywords_: ?*?PWSTR) HRESULT {
                return @as(*const IDBInfo.VTable, @ptrCast(self.vtable)).GetKeywords(@as(*const IDBInfo, @ptrCast(self)), ppwsz_keywords_);
            }
            pub inline fn getLiteralInfo(self: *const T, c_literals_: u32, rg_literals_: ?[*]const u32, pc_literal_info_: ?*u32, prg_literal_info_: ?*?*DBLITERALINFO, pp_char_buffer_: ?*?*u16) HRESULT {
                return @as(*const IDBInfo.VTable, @ptrCast(self.vtable)).GetLiteralInfo(@as(*const IDBInfo, @ptrCast(self)), c_literals_, rg_literals_, pc_literal_info_, prg_literal_info_, pp_char_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBDataSourceAdmin_Value = Guid.initString("0c733a7a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBDataSourceAdmin = &IID_IDBDataSourceAdmin_Value;
pub const IDBDataSourceAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDataSource: *const fn (
            self: *const IDBDataSourceAdmin,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_d_b_session: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyDataSource: *const fn (
            self: *const IDBDataSourceAdmin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreationProperties: *const fn (
            self: *const IDBDataSourceAdmin,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_info_sets: ?*u32,
            prg_property_info_sets: ?*?*DBPROPINFOSET,
            pp_desc_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyDataSource: *const fn (
            self: *const IDBDataSourceAdmin,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createDataSource(self: *const T, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_d_b_session_: ?*?*IUnknown) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).CreateDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)), c_property_sets_, rg_property_sets_, p_unk_outer_, riid_, pp_d_b_session_);
            }
            pub inline fn destroyDataSource(self: *const T) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).DestroyDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)));
            }
            pub inline fn getCreationProperties(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_info_sets_: ?*u32, prg_property_info_sets_: ?*?*DBPROPINFOSET, pp_desc_buffer_: ?*?*u16) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).GetCreationProperties(@as(*const IDBDataSourceAdmin, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_info_sets_, prg_property_info_sets_, pp_desc_buffer_);
            }
            pub inline fn modifyDataSource(self: *const T, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET) HRESULT {
                return @as(*const IDBDataSourceAdmin.VTable, @ptrCast(self.vtable)).ModifyDataSource(@as(*const IDBDataSourceAdmin, @ptrCast(self)), c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchNotify_Value = Guid.initString("0c733a96-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchNotify = &IID_IDBAsynchNotify_Value;
pub const IDBAsynchNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLowResource: *const fn (
            self: *const IDBAsynchNotify,
            dw_reserved: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: *const fn (
            self: *const IDBAsynchNotify,
            h_chapter: usize,
            e_operation: u32,
            ul_progress: usize,
            ul_progress_max: usize,
            e_asynch_phase: u32,
            pwsz_status_text: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStop: *const fn (
            self: *const IDBAsynchNotify,
            h_chapter: usize,
            e_operation: u32,
            hr_status: HRESULT,
            pwsz_status_text: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onLowResource(self: *const T, dw_reserved_: usize) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnLowResource(@as(*const IDBAsynchNotify, @ptrCast(self)), dw_reserved_);
            }
            pub inline fn onProgress(self: *const T, h_chapter_: usize, e_operation_: u32, ul_progress_: usize, ul_progress_max_: usize, e_asynch_phase_: u32, pwsz_status_text_: ?PWSTR) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IDBAsynchNotify, @ptrCast(self)), h_chapter_, e_operation_, ul_progress_, ul_progress_max_, e_asynch_phase_, pwsz_status_text_);
            }
            pub inline fn onStop(self: *const T, h_chapter_: usize, e_operation_: u32, hr_status_: HRESULT, pwsz_status_text_: ?PWSTR) HRESULT {
                return @as(*const IDBAsynchNotify.VTable, @ptrCast(self.vtable)).OnStop(@as(*const IDBAsynchNotify, @ptrCast(self)), h_chapter_, e_operation_, hr_status_, pwsz_status_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchStatus_Value = Guid.initString("0c733a95-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBAsynchStatus = &IID_IDBAsynchStatus_Value;
pub const IDBAsynchStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: *const fn (
            self: *const IDBAsynchStatus,
            h_chapter: usize,
            e_operation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IDBAsynchStatus,
            h_chapter: usize,
            e_operation: u32,
            pul_progress: ?*usize,
            pul_progress_max: ?*usize,
            pe_asynch_phase: ?*u32,
            ppwsz_status_text: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn abort(self: *const T, h_chapter_: usize, e_operation_: u32) HRESULT {
                return @as(*const IDBAsynchStatus.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDBAsynchStatus, @ptrCast(self)), h_chapter_, e_operation_);
            }
            pub inline fn getStatus(self: *const T, h_chapter_: usize, e_operation_: u32, pul_progress_: ?*usize, pul_progress_max_: ?*usize, pe_asynch_phase_: ?*u32, ppwsz_status_text_: ?*?PWSTR) HRESULT {
                return @as(*const IDBAsynchStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IDBAsynchStatus, @ptrCast(self)), h_chapter_, e_operation_, pul_progress_, pul_progress_max_, pe_asynch_phase_, ppwsz_status_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISessionProperties_Value = Guid.initString("0c733a85-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISessionProperties = &IID_ISessionProperties_Value;
pub const ISessionProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: *const fn (
            self: *const ISessionProperties,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?[*]const DBPROPIDSET,
            pc_property_sets: ?*u32,
            prg_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn (
            self: *const ISessionProperties,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProperties(self: *const T, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?[*]const DBPROPIDSET, pc_property_sets_: ?*u32, prg_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const ISessionProperties.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const ISessionProperties, @ptrCast(self)), c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_sets_, prg_property_sets_);
            }
            pub inline fn setProperties(self: *const T, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET) HRESULT {
                return @as(*const ISessionProperties.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const ISessionProperties, @ptrCast(self)), c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexDefinition_Value = Guid.initString("0c733a68-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IIndexDefinition = &IID_IIndexDefinition_Value;
pub const IIndexDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIndex: *const fn (
            self: *const IIndexDefinition,
            p_table_i_d: ?*DBID,
            p_index_i_d: ?*DBID,
            c_index_column_descs: usize,
            rg_index_column_descs: [*]const DBINDEXCOLUMNDESC,
            c_property_sets: u32,
            rg_property_sets: [*]DBPROPSET,
            pp_index_i_d: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropIndex: *const fn (
            self: *const IIndexDefinition,
            p_table_i_d: ?*DBID,
            p_index_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createIndex(self: *const T, p_table_i_d_: ?*DBID, p_index_i_d_: ?*DBID, c_index_column_descs_: usize, rg_index_column_descs_: [*]const DBINDEXCOLUMNDESC, c_property_sets_: u32, rg_property_sets_: [*]DBPROPSET, pp_index_i_d_: ?*?*DBID) HRESULT {
                return @as(*const IIndexDefinition.VTable, @ptrCast(self.vtable)).CreateIndex(@as(*const IIndexDefinition, @ptrCast(self)), p_table_i_d_, p_index_i_d_, c_index_column_descs_, rg_index_column_descs_, c_property_sets_, rg_property_sets_, pp_index_i_d_);
            }
            pub inline fn dropIndex(self: *const T, p_table_i_d_: ?*DBID, p_index_i_d_: ?*DBID) HRESULT {
                return @as(*const IIndexDefinition.VTable, @ptrCast(self.vtable)).DropIndex(@as(*const IIndexDefinition, @ptrCast(self)), p_table_i_d_, p_index_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinition_Value = Guid.initString("0c733a86-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinition = &IID_ITableDefinition_Value;
pub const ITableDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTable: *const fn (
            self: *const ITableDefinition,
            p_unk_outer: ?*IUnknown,
            p_table_i_d: ?*DBID,
            c_column_descs: usize,
            rg_column_descs: ?[*]const DBCOLUMNDESC,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
            pp_table_i_d: ?*?*DBID,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropTable: *const fn (
            self: *const ITableDefinition,
            p_table_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumn: *const fn (
            self: *const ITableDefinition,
            p_table_i_d: ?*DBID,
            p_column_desc: ?*DBCOLUMNDESC,
            pp_column_i_d: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropColumn: *const fn (
            self: *const ITableDefinition,
            p_table_i_d: ?*DBID,
            p_column_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createTable(self: *const T, p_unk_outer_: ?*IUnknown, p_table_i_d_: ?*DBID, c_column_descs_: usize, rg_column_descs_: ?[*]const DBCOLUMNDESC, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET, pp_table_i_d_: ?*?*DBID, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).CreateTable(@as(*const ITableDefinition, @ptrCast(self)), p_unk_outer_, p_table_i_d_, c_column_descs_, rg_column_descs_, riid_, c_property_sets_, rg_property_sets_, pp_table_i_d_, pp_rowset_);
            }
            pub inline fn dropTable(self: *const T, p_table_i_d_: ?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).DropTable(@as(*const ITableDefinition, @ptrCast(self)), p_table_i_d_);
            }
            pub inline fn addColumn(self: *const T, p_table_i_d_: ?*DBID, p_column_desc_: ?*DBCOLUMNDESC, pp_column_i_d_: ?*?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).AddColumn(@as(*const ITableDefinition, @ptrCast(self)), p_table_i_d_, p_column_desc_, pp_column_i_d_);
            }
            pub inline fn dropColumn(self: *const T, p_table_i_d_: ?*DBID, p_column_i_d_: ?*DBID) HRESULT {
                return @as(*const ITableDefinition.VTable, @ptrCast(self.vtable)).DropColumn(@as(*const ITableDefinition, @ptrCast(self)), p_table_i_d_, p_column_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenRowset_Value = Guid.initString("0c733a69-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IOpenRowset = &IID_IOpenRowset_Value;
pub const IOpenRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenRowset: *const fn (
            self: *const IOpenRowset,
            p_unk_outer: ?*IUnknown,
            p_table_i_d: ?*DBID,
            p_index_i_d: ?*DBID,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn openRowset(self: *const T, p_unk_outer_: ?*IUnknown, p_table_i_d_: ?*DBID, p_index_i_d_: ?*DBID, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IOpenRowset.VTable, @ptrCast(self.vtable)).OpenRowset(@as(*const IOpenRowset, @ptrCast(self)), p_unk_outer_, p_table_i_d_, p_index_i_d_, riid_, c_property_sets_, rg_property_sets_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBSchemaRowset_Value = Guid.initString("0c733a7b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaRowset = &IID_IDBSchemaRowset_Value;
pub const IDBSchemaRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowset: *const fn (
            self: *const IDBSchemaRowset,
            p_unk_outer: ?*IUnknown,
            rguid_schema: ?*const Guid,
            c_restrictions: u32,
            rg_restrictions: ?[*]const VARIANT,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?[*]DBPROPSET,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemas: *const fn (
            self: *const IDBSchemaRowset,
            pc_schemas: ?*u32,
            prg_schemas: ?*?*Guid,
            prg_restriction_support: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRowset(self: *const T, p_unk_outer_: ?*IUnknown, rguid_schema_: ?*const Guid, c_restrictions_: u32, rg_restrictions_: ?[*]const VARIANT, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?[*]DBPROPSET, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IDBSchemaRowset.VTable, @ptrCast(self.vtable)).GetRowset(@as(*const IDBSchemaRowset, @ptrCast(self)), p_unk_outer_, rguid_schema_, c_restrictions_, rg_restrictions_, riid_, c_property_sets_, rg_property_sets_, pp_rowset_);
            }
            pub inline fn getSchemas(self: *const T, pc_schemas_: ?*u32, prg_schemas_: ?*?*Guid, prg_restriction_support_: ?*?*u32) HRESULT {
                return @as(*const IDBSchemaRowset.VTable, @ptrCast(self.vtable)).GetSchemas(@as(*const IDBSchemaRowset, @ptrCast(self)), pc_schemas_, prg_schemas_, prg_restriction_support_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDDataset_Value = Guid.initString("a07cccd1-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDDataset = &IID_IMDDataset_Value;
pub const IMDDataset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FreeAxisInfo: *const fn (
            self: *const IMDDataset,
            c_axes: usize,
            rg_axis_info: ?*MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisInfo: *const fn (
            self: *const IMDDataset,
            pc_axes: ?*usize,
            prg_axis_info: ?*?*MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisRowset: *const fn (
            self: *const IMDDataset,
            p_unk_outer: ?*IUnknown,
            i_axis: usize,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellData: *const fn (
            self: *const IMDDataset,
            h_accessor: usize,
            ul_start_cell: usize,
            ul_end_cell: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: *const fn (
            self: *const IMDDataset,
            riid: ?*const Guid,
            pp_specification: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn freeAxisInfo(self: *const T, c_axes_: usize, rg_axis_info_: ?*MDAXISINFO) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).FreeAxisInfo(@as(*const IMDDataset, @ptrCast(self)), c_axes_, rg_axis_info_);
            }
            pub inline fn getAxisInfo(self: *const T, pc_axes_: ?*usize, prg_axis_info_: ?*?*MDAXISINFO) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetAxisInfo(@as(*const IMDDataset, @ptrCast(self)), pc_axes_, prg_axis_info_);
            }
            pub inline fn getAxisRowset(self: *const T, p_unk_outer_: ?*IUnknown, i_axis_: usize, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetAxisRowset(@as(*const IMDDataset, @ptrCast(self)), p_unk_outer_, i_axis_, riid_, c_property_sets_, rg_property_sets_, pp_rowset_);
            }
            pub inline fn getCellData(self: *const T, h_accessor_: usize, ul_start_cell_: usize, ul_end_cell_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetCellData(@as(*const IMDDataset, @ptrCast(self)), h_accessor_, ul_start_cell_, ul_end_cell_, p_data_);
            }
            pub inline fn getSpecification(self: *const T, riid_: ?*const Guid, pp_specification_: ?*?*IUnknown) HRESULT {
                return @as(*const IMDDataset.VTable, @ptrCast(self.vtable)).GetSpecification(@as(*const IMDDataset, @ptrCast(self)), riid_, pp_specification_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDFind_Value = Guid.initString("a07cccd2-8148-11d0-87bb-00c04fc33942");
pub const IID_IMDFind = &IID_IMDFind_Value;
pub const IMDFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCell: *const fn (
            self: *const IMDFind,
            ul_starting_ordinal: usize,
            c_members: usize,
            rgpwsz_member: ?*?PWSTR,
            pul_cell_ordinal: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTuple: *const fn (
            self: *const IMDFind,
            ul_axis_identifier: u32,
            ul_starting_ordinal: usize,
            c_members: usize,
            rgpwsz_member: ?*?PWSTR,
            pul_tuple_ordinal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn findCell(self: *const T, ul_starting_ordinal_: usize, c_members_: usize, rgpwsz_member_: ?*?PWSTR, pul_cell_ordinal_: ?*usize) HRESULT {
                return @as(*const IMDFind.VTable, @ptrCast(self.vtable)).FindCell(@as(*const IMDFind, @ptrCast(self)), ul_starting_ordinal_, c_members_, rgpwsz_member_, pul_cell_ordinal_);
            }
            pub inline fn findTuple(self: *const T, ul_axis_identifier_: u32, ul_starting_ordinal_: usize, c_members_: usize, rgpwsz_member_: ?*?PWSTR, pul_tuple_ordinal_: ?*u32) HRESULT {
                return @as(*const IMDFind.VTable, @ptrCast(self.vtable)).FindTuple(@as(*const IMDFind, @ptrCast(self)), ul_axis_identifier_, ul_starting_ordinal_, c_members_, rgpwsz_member_, pul_tuple_ordinal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDRangeRowset_Value = Guid.initString("0c733aa0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IMDRangeRowset = &IID_IMDRangeRowset_Value;
pub const IMDRangeRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeRowset: *const fn (
            self: *const IMDRangeRowset,
            p_unk_outer: ?*IUnknown,
            ul_start_cell: usize,
            ul_end_cell: usize,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRangeRowset(self: *const T, p_unk_outer_: ?*IUnknown, ul_start_cell_: usize, ul_end_cell_: usize, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IMDRangeRowset.VTable, @ptrCast(self.vtable)).GetRangeRowset(@as(*const IMDRangeRowset, @ptrCast(self)), p_unk_outer_, ul_start_cell_, ul_end_cell_, riid_, c_property_sets_, rg_property_sets_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterTable_Value = Guid.initString("0c733aa5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterTable = &IID_IAlterTable_Value;
pub const IAlterTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterColumn: *const fn (
            self: *const IAlterTable,
            p_table_id: ?*DBID,
            p_column_id: ?*DBID,
            dw_column_desc_flags: u32,
            p_column_desc: ?*DBCOLUMNDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AlterTable: *const fn (
            self: *const IAlterTable,
            p_table_id: ?*DBID,
            p_new_table_id: ?*DBID,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn alterColumn(self: *const T, p_table_id_: ?*DBID, p_column_id_: ?*DBID, dw_column_desc_flags_: u32, p_column_desc_: ?*DBCOLUMNDESC) HRESULT {
                return @as(*const IAlterTable.VTable, @ptrCast(self.vtable)).AlterColumn(@as(*const IAlterTable, @ptrCast(self)), p_table_id_, p_column_id_, dw_column_desc_flags_, p_column_desc_);
            }
            pub inline fn alterTable(self: *const T, p_table_id_: ?*DBID, p_new_table_id_: ?*DBID, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET) HRESULT {
                return @as(*const IAlterTable.VTable, @ptrCast(self.vtable)).AlterTable(@as(*const IAlterTable, @ptrCast(self)), p_table_id_, p_new_table_id_, c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterIndex_Value = Guid.initString("0c733aa6-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IAlterIndex = &IID_IAlterIndex_Value;
pub const IAlterIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterIndex: *const fn (
            self: *const IAlterIndex,
            p_table_id: ?*DBID,
            p_index_id: ?*DBID,
            p_new_index_id: ?*DBID,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn alterIndex(self: *const T, p_table_id_: ?*DBID, p_index_id_: ?*DBID, p_new_index_id_: ?*DBID, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET) HRESULT {
                return @as(*const IAlterIndex.VTable, @ptrCast(self.vtable)).AlterIndex(@as(*const IAlterIndex, @ptrCast(self)), p_table_id_, p_index_id_, p_new_index_id_, c_property_sets_, rg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChapterMember_Value = Guid.initString("0c733aa8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChapterMember = &IID_IRowsetChapterMember_Value;
pub const IRowsetChapterMember = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsRowInChapter: *const fn (
            self: *const IRowsetChapterMember,
            h_chapter: usize,
            h_row: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isRowInChapter(self: *const T, h_chapter_: usize, h_row_: usize) HRESULT {
                return @as(*const IRowsetChapterMember.VTable, @ptrCast(self.vtable)).IsRowInChapter(@as(*const IRowsetChapterMember, @ptrCast(self)), h_chapter_, h_row_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPersist_Value = Guid.initString("0c733aa7-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandPersist = &IID_ICommandPersist_Value;
pub const ICommandPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteCommand: *const fn (
            self: *const ICommandPersist,
            p_command_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentCommand: *const fn (
            self: *const ICommandPersist,
            pp_command_i_d: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCommand: *const fn (
            self: *const ICommandPersist,
            p_command_i_d: ?*DBID,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCommand: *const fn (
            self: *const ICommandPersist,
            p_command_i_d: ?*DBID,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn deleteCommand(self: *const T, p_command_i_d_: ?*DBID) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).DeleteCommand(@as(*const ICommandPersist, @ptrCast(self)), p_command_i_d_);
            }
            pub inline fn getCurrentCommand(self: *const T, pp_command_i_d_: ?*?*DBID) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).GetCurrentCommand(@as(*const ICommandPersist, @ptrCast(self)), pp_command_i_d_);
            }
            pub inline fn loadCommand(self: *const T, p_command_i_d_: ?*DBID, dw_flags_: u32) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).LoadCommand(@as(*const ICommandPersist, @ptrCast(self)), p_command_i_d_, dw_flags_);
            }
            pub inline fn saveCommand(self: *const T, p_command_i_d_: ?*DBID, dw_flags_: u32) HRESULT {
                return @as(*const ICommandPersist.VTable, @ptrCast(self.vtable)).SaveCommand(@as(*const ICommandPersist, @ptrCast(self)), p_command_i_d_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetRefresh_Value = Guid.initString("0c733aa9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetRefresh = &IID_IRowsetRefresh_Value;
pub const IRowsetRefresh = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RefreshVisibleData: *const fn (
            self: *const IRowsetRefresh,
            h_chapter: usize,
            c_rows: usize,
            rgh_rows: ?*const usize,
            f_over_write: BOOL,
            pc_rows_refreshed: ?*usize,
            prgh_rows_refreshed: ?*?*usize,
            prg_row_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastVisibleData: *const fn (
            self: *const IRowsetRefresh,
            h_row: usize,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn refreshVisibleData(self: *const T, h_chapter_: usize, c_rows_: usize, rgh_rows_: ?*const usize, f_over_write_: BOOL, pc_rows_refreshed_: ?*usize, prgh_rows_refreshed_: ?*?*usize, prg_row_status_: ?*?*u32) HRESULT {
                return @as(*const IRowsetRefresh.VTable, @ptrCast(self.vtable)).RefreshVisibleData(@as(*const IRowsetRefresh, @ptrCast(self)), h_chapter_, c_rows_, rgh_rows_, f_over_write_, pc_rows_refreshed_, prgh_rows_refreshed_, prg_row_status_);
            }
            pub inline fn getLastVisibleData(self: *const T, h_row_: usize, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowsetRefresh.VTable, @ptrCast(self.vtable)).GetLastVisibleData(@as(*const IRowsetRefresh, @ptrCast(self)), h_row_, h_accessor_, p_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IParentRowset_Value = Guid.initString("0c733aaa-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IParentRowset = &IID_IParentRowset_Value;
pub const IParentRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChildRowset: *const fn (
            self: *const IParentRowset,
            p_unk_outer: ?*IUnknown,
            i_ordinal: usize,
            riid: ?*const Guid,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getChildRowset(self: *const T, p_unk_outer_: ?*IUnknown, i_ordinal_: usize, riid_: ?*const Guid, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IParentRowset.VTable, @ptrCast(self.vtable)).GetChildRowset(@as(*const IParentRowset, @ptrCast(self)), p_unk_outer_, i_ordinal_, riid_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorRecords_Value = Guid.initString("0c733a67-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorRecords = &IID_IErrorRecords_Value;
pub const IErrorRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddErrorRecord: *const fn (
            self: *const IErrorRecords,
            p_error_info: ?*ERRORINFO,
            dw_lookup_i_d: u32,
            pdispparams: ?*DISPPARAMS,
            punk_custom_error: ?*IUnknown,
            dw_dynamic_error_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBasicErrorInfo: *const fn (
            self: *const IErrorRecords,
            ul_record_num: u32,
            p_error_info: ?*ERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomErrorObject: *const fn (
            self: *const IErrorRecords,
            ul_record_num: u32,
            riid: ?*const Guid,
            pp_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorInfo: *const fn (
            self: *const IErrorRecords,
            ul_record_num: u32,
            lcid: u32,
            pp_error_info: ?*?*IErrorInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorParameters: *const fn (
            self: *const IErrorRecords,
            ul_record_num: u32,
            pdispparams: ?*DISPPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCount: *const fn (
            self: *const IErrorRecords,
            pc_records: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addErrorRecord(self: *const T, p_error_info_: ?*ERRORINFO, dw_lookup_i_d_: u32, pdispparams_: ?*DISPPARAMS, punk_custom_error_: ?*IUnknown, dw_dynamic_error_i_d_: u32) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).AddErrorRecord(@as(*const IErrorRecords, @ptrCast(self)), p_error_info_, dw_lookup_i_d_, pdispparams_, punk_custom_error_, dw_dynamic_error_i_d_);
            }
            pub inline fn getBasicErrorInfo(self: *const T, ul_record_num_: u32, p_error_info_: ?*ERRORINFO) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetBasicErrorInfo(@as(*const IErrorRecords, @ptrCast(self)), ul_record_num_, p_error_info_);
            }
            pub inline fn getCustomErrorObject(self: *const T, ul_record_num_: u32, riid_: ?*const Guid, pp_object_: ?*?*IUnknown) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetCustomErrorObject(@as(*const IErrorRecords, @ptrCast(self)), ul_record_num_, riid_, pp_object_);
            }
            pub inline fn getErrorInfo(self: *const T, ul_record_num_: u32, lcid_: u32, pp_error_info_: ?*?*IErrorInfo) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const IErrorRecords, @ptrCast(self)), ul_record_num_, lcid_, pp_error_info_);
            }
            pub inline fn getErrorParameters(self: *const T, ul_record_num_: u32, pdispparams_: ?*DISPPARAMS) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetErrorParameters(@as(*const IErrorRecords, @ptrCast(self)), ul_record_num_, pdispparams_);
            }
            pub inline fn getRecordCount(self: *const T, pc_records_: ?*u32) HRESULT {
                return @as(*const IErrorRecords.VTable, @ptrCast(self.vtable)).GetRecordCount(@as(*const IErrorRecords, @ptrCast(self)), pc_records_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLookup_Value = Guid.initString("0c733a66-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IErrorLookup = &IID_IErrorLookup_Value;
pub const IErrorLookup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDescription: *const fn (
            self: *const IErrorLookup,
            hr_error: HRESULT,
            dw_lookup_i_d: u32,
            pdispparams: ?*DISPPARAMS,
            lcid: u32,
            pbstr_source: ?*?BSTR,
            pbstr_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpInfo: *const fn (
            self: *const IErrorLookup,
            hr_error: HRESULT,
            dw_lookup_i_d: u32,
            lcid: u32,
            pbstr_help_file: ?*?BSTR,
            pdw_help_context: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseErrors: *const fn (
            self: *const IErrorLookup,
            dw_dynamic_error_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getErrorDescription(self: *const T, hr_error_: HRESULT, dw_lookup_i_d_: u32, pdispparams_: ?*DISPPARAMS, lcid_: u32, pbstr_source_: ?*?BSTR, pbstr_description_: ?*?BSTR) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).GetErrorDescription(@as(*const IErrorLookup, @ptrCast(self)), hr_error_, dw_lookup_i_d_, pdispparams_, lcid_, pbstr_source_, pbstr_description_);
            }
            pub inline fn getHelpInfo(self: *const T, hr_error_: HRESULT, dw_lookup_i_d_: u32, lcid_: u32, pbstr_help_file_: ?*?BSTR, pdw_help_context_: ?*u32) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).GetHelpInfo(@as(*const IErrorLookup, @ptrCast(self)), hr_error_, dw_lookup_i_d_, lcid_, pbstr_help_file_, pdw_help_context_);
            }
            pub inline fn releaseErrors(self: *const T, dw_dynamic_error_i_d_: u32) HRESULT {
                return @as(*const IErrorLookup.VTable, @ptrCast(self.vtable)).ReleaseErrors(@as(*const IErrorLookup, @ptrCast(self)), dw_dynamic_error_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISQLErrorInfo_Value = Guid.initString("0c733a74-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISQLErrorInfo = &IID_ISQLErrorInfo_Value;
pub const ISQLErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSQLInfo: *const fn (
            self: *const ISQLErrorInfo,
            pbstr_s_q_l_state: ?*?BSTR,
            pl_native_error: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSQLInfo(self: *const T, pbstr_s_q_l_state_: ?*?BSTR, pl_native_error_: ?*i32) HRESULT {
                return @as(*const ISQLErrorInfo.VTable, @ptrCast(self.vtable)).GetSQLInfo(@as(*const ISQLErrorInfo, @ptrCast(self)), pbstr_s_q_l_state_, pl_native_error_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetDataSource_Value = Guid.initString("0c733a75-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetDataSource = &IID_IGetDataSource_Value;
pub const IGetDataSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: *const fn (
            self: *const IGetDataSource,
            riid: ?*const Guid,
            pp_data_source: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDataSource(self: *const T, riid_: ?*const Guid, pp_data_source_: ?*?*IUnknown) HRESULT {
                return @as(*const IGetDataSource.VTable, @ptrCast(self.vtable)).GetDataSource(@as(*const IGetDataSource, @ptrCast(self)), riid_, pp_data_source_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionLocal_Value = Guid.initString("0c733a5f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionLocal = &IID_ITransactionLocal_Value;
pub const ITransactionLocal = extern struct {
    pub const VTable = extern struct {
        base: ITransaction.VTable,
        GetOptionsObject: *const fn (
            self: *const ITransactionLocal,
            pp_options: ?*?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartTransaction: *const fn (
            self: *const ITransactionLocal,
            iso_level: i32,
            iso_flags: u32,
            p_other_options: ?*ITransactionOptions,
            pul_transaction_level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITransaction.MethodMixin(T);
            pub inline fn getOptionsObject(self: *const T, pp_options_: ?*?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionLocal.VTable, @ptrCast(self.vtable)).GetOptionsObject(@as(*const ITransactionLocal, @ptrCast(self)), pp_options_);
            }
            pub inline fn startTransaction(self: *const T, iso_level_: i32, iso_flags_: u32, p_other_options_: ?*ITransactionOptions, pul_transaction_level_: ?*u32) HRESULT {
                return @as(*const ITransactionLocal.VTable, @ptrCast(self.vtable)).StartTransaction(@as(*const ITransactionLocal, @ptrCast(self)), iso_level_, iso_flags_, p_other_options_, pul_transaction_level_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionJoin_Value = Guid.initString("0c733a5e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionJoin = &IID_ITransactionJoin_Value;
pub const ITransactionJoin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionsObject: *const fn (
            self: *const ITransactionJoin,
            pp_options: ?*?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinTransaction: *const fn (
            self: *const ITransactionJoin,
            punk_transaction_coord: ?*IUnknown,
            iso_level: i32,
            iso_flags: u32,
            p_other_options: ?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getOptionsObject(self: *const T, pp_options_: ?*?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionJoin.VTable, @ptrCast(self.vtable)).GetOptionsObject(@as(*const ITransactionJoin, @ptrCast(self)), pp_options_);
            }
            pub inline fn joinTransaction(self: *const T, punk_transaction_coord_: ?*IUnknown, iso_level_: i32, iso_flags_: u32, p_other_options_: ?*ITransactionOptions) HRESULT {
                return @as(*const ITransactionJoin.VTable, @ptrCast(self.vtable)).JoinTransaction(@as(*const ITransactionJoin, @ptrCast(self)), punk_transaction_coord_, iso_level_, iso_flags_, p_other_options_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionObject_Value = Guid.initString("0c733a60-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITransactionObject = &IID_ITransactionObject_Value;
pub const ITransactionObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransactionObject: *const fn (
            self: *const ITransactionObject,
            ul_transaction_level: u32,
            pp_transaction_object: ?*?*ITransaction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTransactionObject(self: *const T, ul_transaction_level_: u32, pp_transaction_object_: ?*?*ITransaction) HRESULT {
                return @as(*const ITransactionObject.VTable, @ptrCast(self.vtable)).GetTransactionObject(@as(*const ITransactionObject, @ptrCast(self)), ul_transaction_level_, pp_transaction_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeAdmin_Value = Guid.initString("0c733aa1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeAdmin = &IID_ITrusteeAdmin_Value;
pub const ITrusteeAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareTrustees: *const fn (
            self: *const ITrusteeAdmin,
            p_trustee1: ?*TRUSTEE_W,
            p_trustee2: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTrustee: *const fn (
            self: *const ITrusteeAdmin,
            p_trustee: ?*TRUSTEE_W,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTrustee: *const fn (
            self: *const ITrusteeAdmin,
            p_trustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrusteeProperties: *const fn (
            self: *const ITrusteeAdmin,
            p_trustee: ?*TRUSTEE_W,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrusteeProperties: *const fn (
            self: *const ITrusteeAdmin,
            p_trustee: ?*TRUSTEE_W,
            c_property_i_d_sets: u32,
            rg_property_i_d_sets: ?*const DBPROPIDSET,
            pc_property_sets: ?*u32,
            prg_property_sets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn compareTrustees(self: *const T, p_trustee1_: ?*TRUSTEE_W, p_trustee2_: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).CompareTrustees(@as(*const ITrusteeAdmin, @ptrCast(self)), p_trustee1_, p_trustee2_);
            }
            pub inline fn createTrustee(self: *const T, p_trustee_: ?*TRUSTEE_W, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).CreateTrustee(@as(*const ITrusteeAdmin, @ptrCast(self)), p_trustee_, c_property_sets_, rg_property_sets_);
            }
            pub inline fn deleteTrustee(self: *const T, p_trustee_: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).DeleteTrustee(@as(*const ITrusteeAdmin, @ptrCast(self)), p_trustee_);
            }
            pub inline fn setTrusteeProperties(self: *const T, p_trustee_: ?*TRUSTEE_W, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).SetTrusteeProperties(@as(*const ITrusteeAdmin, @ptrCast(self)), p_trustee_, c_property_sets_, rg_property_sets_);
            }
            pub inline fn getTrusteeProperties(self: *const T, p_trustee_: ?*TRUSTEE_W, c_property_i_d_sets_: u32, rg_property_i_d_sets_: ?*const DBPROPIDSET, pc_property_sets_: ?*u32, prg_property_sets_: ?*?*DBPROPSET) HRESULT {
                return @as(*const ITrusteeAdmin.VTable, @ptrCast(self.vtable)).GetTrusteeProperties(@as(*const ITrusteeAdmin, @ptrCast(self)), p_trustee_, c_property_i_d_sets_, rg_property_i_d_sets_, pc_property_sets_, prg_property_sets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeGroupAdmin_Value = Guid.initString("0c733aa2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITrusteeGroupAdmin = &IID_ITrusteeGroupAdmin_Value;
pub const ITrusteeGroupAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMember: *const fn (
            self: *const ITrusteeGroupAdmin,
            p_membership_trustee: ?*TRUSTEE_W,
            p_member_trustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMember: *const fn (
            self: *const ITrusteeGroupAdmin,
            p_membership_trustee: ?*TRUSTEE_W,
            p_member_trustee: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMember: *const fn (
            self: *const ITrusteeGroupAdmin,
            p_membership_trustee: ?*TRUSTEE_W,
            p_member_trustee: ?*TRUSTEE_W,
            pf_status: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMembers: *const fn (
            self: *const ITrusteeGroupAdmin,
            p_membership_trustee: ?*TRUSTEE_W,
            pc_members: ?*u32,
            prg_members: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberships: *const fn (
            self: *const ITrusteeGroupAdmin,
            p_trustee: ?*TRUSTEE_W,
            pc_memberships: ?*u32,
            prg_memberships: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addMember(self: *const T, p_membership_trustee_: ?*TRUSTEE_W, p_member_trustee_: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).AddMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), p_membership_trustee_, p_member_trustee_);
            }
            pub inline fn deleteMember(self: *const T, p_membership_trustee_: ?*TRUSTEE_W, p_member_trustee_: ?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).DeleteMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), p_membership_trustee_, p_member_trustee_);
            }
            pub inline fn isMember(self: *const T, p_membership_trustee_: ?*TRUSTEE_W, p_member_trustee_: ?*TRUSTEE_W, pf_status_: ?*BOOL) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).IsMember(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), p_membership_trustee_, p_member_trustee_, pf_status_);
            }
            pub inline fn getMembers(self: *const T, p_membership_trustee_: ?*TRUSTEE_W, pc_members_: ?*u32, prg_members_: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).GetMembers(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), p_membership_trustee_, pc_members_, prg_members_);
            }
            pub inline fn getMemberships(self: *const T, p_trustee_: ?*TRUSTEE_W, pc_memberships_: ?*u32, prg_memberships_: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ITrusteeGroupAdmin.VTable, @ptrCast(self.vtable)).GetMemberships(@as(*const ITrusteeGroupAdmin, @ptrCast(self)), p_trustee_, pc_memberships_, prg_memberships_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectAccessControl_Value = Guid.initString("0c733aa3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IObjectAccessControl = &IID_IObjectAccessControl_Value;
pub const IObjectAccessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectAccessRights: *const fn (
            self: *const IObjectAccessControl,
            p_object: ?*SEC_OBJECT,
            pc_access_entries: ?*u32,
            prg_access_entries: ?*?*EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectOwner: *const fn (
            self: *const IObjectAccessControl,
            p_object: ?*SEC_OBJECT,
            pp_owner: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsObjectAccessAllowed: *const fn (
            self: *const IObjectAccessControl,
            p_object: ?*SEC_OBJECT,
            p_access_entry: ?*EXPLICIT_ACCESS_W,
            pf_result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectAccessRights: *const fn (
            self: *const IObjectAccessControl,
            p_object: ?*SEC_OBJECT,
            c_access_entries: u32,
            prg_access_entries: ?*EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectOwner: *const fn (
            self: *const IObjectAccessControl,
            p_object: ?*SEC_OBJECT,
            p_owner: ?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getObjectAccessRights(self: *const T, p_object_: ?*SEC_OBJECT, pc_access_entries_: ?*u32, prg_access_entries_: ?*?*EXPLICIT_ACCESS_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).GetObjectAccessRights(@as(*const IObjectAccessControl, @ptrCast(self)), p_object_, pc_access_entries_, prg_access_entries_);
            }
            pub inline fn getObjectOwner(self: *const T, p_object_: ?*SEC_OBJECT, pp_owner_: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).GetObjectOwner(@as(*const IObjectAccessControl, @ptrCast(self)), p_object_, pp_owner_);
            }
            pub inline fn isObjectAccessAllowed(self: *const T, p_object_: ?*SEC_OBJECT, p_access_entry_: ?*EXPLICIT_ACCESS_W, pf_result_: ?*BOOL) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).IsObjectAccessAllowed(@as(*const IObjectAccessControl, @ptrCast(self)), p_object_, p_access_entry_, pf_result_);
            }
            pub inline fn setObjectAccessRights(self: *const T, p_object_: ?*SEC_OBJECT, c_access_entries_: u32, prg_access_entries_: ?*EXPLICIT_ACCESS_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).SetObjectAccessRights(@as(*const IObjectAccessControl, @ptrCast(self)), p_object_, c_access_entries_, prg_access_entries_);
            }
            pub inline fn setObjectOwner(self: *const T, p_object_: ?*SEC_OBJECT, p_owner_: ?*TRUSTEE_W) HRESULT {
                return @as(*const IObjectAccessControl.VTable, @ptrCast(self.vtable)).SetObjectOwner(@as(*const IObjectAccessControl, @ptrCast(self)), p_object_, p_owner_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACCESS_MASKENUM = enum(i32) {
    EXCLUSIVE = 512,
    READDESIGN = 1024,
    WRITEDESIGN = 2048,
    WITHGRANT = 4096,
    REFERENCE = 8192,
    CREATE = 16384,
    INSERT = 32768,
    DELETE = 65536,
    READCONTROL = 131072,
    WRITEPERMISSIONS = 262144,
    WRITEOWNER = 524288,
    MAXIMUM_ALLOWED = 33554432,
    ALL = 268435456,
    EXECUTE = 536870912,
    READ = -2147483648,
    UPDATE = 1073741824,
    DROP = 256,
};
pub const PERM_EXCLUSIVE = ACCESS_MASKENUM.EXCLUSIVE;
pub const PERM_READDESIGN = ACCESS_MASKENUM.READDESIGN;
pub const PERM_WRITEDESIGN = ACCESS_MASKENUM.WRITEDESIGN;
pub const PERM_WITHGRANT = ACCESS_MASKENUM.WITHGRANT;
pub const PERM_REFERENCE = ACCESS_MASKENUM.REFERENCE;
pub const PERM_CREATE = ACCESS_MASKENUM.CREATE;
pub const PERM_INSERT = ACCESS_MASKENUM.INSERT;
pub const PERM_DELETE = ACCESS_MASKENUM.DELETE;
pub const PERM_READCONTROL = ACCESS_MASKENUM.READCONTROL;
pub const PERM_WRITEPERMISSIONS = ACCESS_MASKENUM.WRITEPERMISSIONS;
pub const PERM_WRITEOWNER = ACCESS_MASKENUM.WRITEOWNER;
pub const PERM_MAXIMUM_ALLOWED = ACCESS_MASKENUM.MAXIMUM_ALLOWED;
pub const PERM_ALL = ACCESS_MASKENUM.ALL;
pub const PERM_EXECUTE = ACCESS_MASKENUM.EXECUTE;
pub const PERM_READ = ACCESS_MASKENUM.READ;
pub const PERM_UPDATE = ACCESS_MASKENUM.UPDATE;
pub const PERM_DROP = ACCESS_MASKENUM.DROP;

const IID_ISecurityInfo_Value = Guid.initString("0c733aa4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISecurityInfo = &IID_ISecurityInfo_Value;
pub const ISecurityInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTrustee: *const fn (
            self: *const ISecurityInfo,
            pp_trustee: ?*?*TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectTypes: *const fn (
            self: *const ISecurityInfo,
            c_object_types: ?*u32,
            rg_object_types: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPermissions: *const fn (
            self: *const ISecurityInfo,
            object_type: Guid,
            p_permissions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrentTrustee(self: *const T, pp_trustee_: ?*?*TRUSTEE_W) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetCurrentTrustee(@as(*const ISecurityInfo, @ptrCast(self)), pp_trustee_);
            }
            pub inline fn getObjectTypes(self: *const T, c_object_types_: ?*u32, rg_object_types_: ?*?*Guid) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetObjectTypes(@as(*const ISecurityInfo, @ptrCast(self)), c_object_types_, rg_object_types_);
            }
            pub inline fn getPermissions(self: *const T, object_type_: Guid, p_permissions_: ?*u32) HRESULT {
                return @as(*const ISecurityInfo.VTable, @ptrCast(self.vtable)).GetPermissions(@as(*const ISecurityInfo, @ptrCast(self)), object_type_, p_permissions_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableCreation_Value = Guid.initString("0c733abc-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableCreation = &IID_ITableCreation_Value;
pub const ITableCreation = extern struct {
    pub const VTable = extern struct {
        base: ITableDefinition.VTable,
        GetTableDefinition: *const fn (
            self: *const ITableCreation,
            p_table_i_d: ?*DBID,
            pc_column_descs: ?*usize,
            prg_column_descs: ?[*]?*DBCOLUMNDESC,
            pc_property_sets: ?*u32,
            prg_property_sets: ?[*]?*DBPROPSET,
            pc_constraint_descs: ?*u32,
            prg_constraint_descs: ?[*]?*DBCONSTRAINTDESC,
            ppwsz_string_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITableDefinition.MethodMixin(T);
            pub inline fn getTableDefinition(self: *const T, p_table_i_d_: ?*DBID, pc_column_descs_: ?*usize, prg_column_descs_: ?[*]?*DBCOLUMNDESC, pc_property_sets_: ?*u32, prg_property_sets_: ?[*]?*DBPROPSET, pc_constraint_descs_: ?*u32, prg_constraint_descs_: ?[*]?*DBCONSTRAINTDESC, ppwsz_string_buffer_: ?*?*u16) HRESULT {
                return @as(*const ITableCreation.VTable, @ptrCast(self.vtable)).GetTableDefinition(@as(*const ITableCreation, @ptrCast(self)), p_table_i_d_, pc_column_descs_, prg_column_descs_, pc_property_sets_, prg_property_sets_, pc_constraint_descs_, prg_constraint_descs_, ppwsz_string_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinitionWithConstraints_Value = Guid.initString("0c733aab-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableDefinitionWithConstraints = &IID_ITableDefinitionWithConstraints_Value;
pub const ITableDefinitionWithConstraints = extern struct {
    pub const VTable = extern struct {
        base: ITableCreation.VTable,
        AddConstraint: *const fn (
            self: *const ITableDefinitionWithConstraints,
            p_table_i_d: ?*DBID,
            p_constraint_desc: ?*DBCONSTRAINTDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTableWithConstraints: *const fn (
            self: *const ITableDefinitionWithConstraints,
            p_unk_outer: ?*IUnknown,
            p_table_i_d: ?*DBID,
            c_column_descs: usize,
            rg_column_descs: ?*DBCOLUMNDESC,
            c_constraint_descs: u32,
            rg_constraint_descs: ?*DBCONSTRAINTDESC,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: ?*DBPROPSET,
            pp_table_i_d: ?*?*DBID,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropConstraint: *const fn (
            self: *const ITableDefinitionWithConstraints,
            p_table_i_d: ?*DBID,
            p_constraint_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITableCreation.MethodMixin(T);
            pub inline fn addConstraint(self: *const T, p_table_i_d_: ?*DBID, p_constraint_desc_: ?*DBCONSTRAINTDESC) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).AddConstraint(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), p_table_i_d_, p_constraint_desc_);
            }
            pub inline fn createTableWithConstraints(self: *const T, p_unk_outer_: ?*IUnknown, p_table_i_d_: ?*DBID, c_column_descs_: usize, rg_column_descs_: ?*DBCOLUMNDESC, c_constraint_descs_: u32, rg_constraint_descs_: ?*DBCONSTRAINTDESC, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: ?*DBPROPSET, pp_table_i_d_: ?*?*DBID, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).CreateTableWithConstraints(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), p_unk_outer_, p_table_i_d_, c_column_descs_, rg_column_descs_, c_constraint_descs_, rg_constraint_descs_, riid_, c_property_sets_, rg_property_sets_, pp_table_i_d_, pp_rowset_);
            }
            pub inline fn dropConstraint(self: *const T, p_table_i_d_: ?*DBID, p_constraint_i_d_: ?*DBID) HRESULT {
                return @as(*const ITableDefinitionWithConstraints.VTable, @ptrCast(self.vtable)).DropConstraint(@as(*const ITableDefinitionWithConstraints, @ptrCast(self)), p_table_i_d_, p_constraint_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRow_Value = Guid.initString("0c733ab4-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRow = &IID_IRow_Value;
pub const IRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumns: *const fn (
            self: *const IRow,
            c_columns: usize,
            rg_columns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceRowset: *const fn (
            self: *const IRow,
            riid: ?*const Guid,
            pp_rowset: ?*?*IUnknown,
            ph_row: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: *const fn (
            self: *const IRow,
            p_unk_outer: ?*IUnknown,
            p_column_i_d: ?*DBID,
            rguid_column_type: ?*const Guid,
            dw_bind_flags: u32,
            riid: ?*const Guid,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getColumns(self: *const T, c_columns_: usize, rg_columns_: [*]DBCOLUMNACCESS) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).GetColumns(@as(*const IRow, @ptrCast(self)), c_columns_, rg_columns_);
            }
            pub inline fn getSourceRowset(self: *const T, riid_: ?*const Guid, pp_rowset_: ?*?*IUnknown, ph_row_: ?*usize) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).GetSourceRowset(@as(*const IRow, @ptrCast(self)), riid_, pp_rowset_, ph_row_);
            }
            pub inline fn open(self: *const T, p_unk_outer_: ?*IUnknown, p_column_i_d_: ?*DBID, rguid_column_type_: ?*const Guid, dw_bind_flags_: u32, riid_: ?*const Guid, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IRow.VTable, @ptrCast(self.vtable)).Open(@as(*const IRow, @ptrCast(self)), p_unk_outer_, p_column_i_d_, rguid_column_type_, dw_bind_flags_, riid_, pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowChange_Value = Guid.initString("0c733ab5-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowChange = &IID_IRowChange_Value;
pub const IRowChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumns: *const fn (
            self: *const IRowChange,
            c_columns: usize,
            rg_columns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setColumns(self: *const T, c_columns_: usize, rg_columns_: [*]DBCOLUMNACCESS) HRESULT {
                return @as(*const IRowChange.VTable, @ptrCast(self.vtable)).SetColumns(@as(*const IRowChange, @ptrCast(self)), c_columns_, rg_columns_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowSchemaChange_Value = Guid.initString("0c733aae-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowSchemaChange = &IID_IRowSchemaChange_Value;
pub const IRowSchemaChange = extern struct {
    pub const VTable = extern struct {
        base: IRowChange.VTable,
        DeleteColumns: *const fn (
            self: *const IRowSchemaChange,
            c_columns: usize,
            rg_column_i_ds: ?*const DBID,
            rgdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumns: *const fn (
            self: *const IRowSchemaChange,
            c_columns: usize,
            rg_new_column_info: ?*const DBCOLUMNINFO,
            rg_columns: ?*DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowChange.MethodMixin(T);
            pub inline fn deleteColumns(self: *const T, c_columns_: usize, rg_column_i_ds_: ?*const DBID, rgdw_status_: ?*u32) HRESULT {
                return @as(*const IRowSchemaChange.VTable, @ptrCast(self.vtable)).DeleteColumns(@as(*const IRowSchemaChange, @ptrCast(self)), c_columns_, rg_column_i_ds_, rgdw_status_);
            }
            pub inline fn addColumns(self: *const T, c_columns_: usize, rg_new_column_info_: ?*const DBCOLUMNINFO, rg_columns_: ?*DBCOLUMNACCESS) HRESULT {
                return @as(*const IRowSchemaChange.VTable, @ptrCast(self.vtable)).AddColumns(@as(*const IRowSchemaChange, @ptrCast(self)), c_columns_, rg_new_column_info_, rg_columns_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetRow_Value = Guid.initString("0c733aaf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetRow = &IID_IGetRow_Value;
pub const IGetRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowFromHROW: *const fn (
            self: *const IGetRow,
            p_unk_outer: ?*IUnknown,
            h_row: usize,
            riid: ?*const Guid,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLFromHROW: *const fn (
            self: *const IGetRow,
            h_row: usize,
            ppwsz_u_r_l: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRowFromHROW(self: *const T, p_unk_outer_: ?*IUnknown, h_row_: usize, riid_: ?*const Guid, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IGetRow.VTable, @ptrCast(self.vtable)).GetRowFromHROW(@as(*const IGetRow, @ptrCast(self)), p_unk_outer_, h_row_, riid_, pp_unk_);
            }
            pub inline fn getURLFromHROW(self: *const T, h_row_: usize, ppwsz_u_r_l_: ?*?PWSTR) HRESULT {
                return @as(*const IGetRow.VTable, @ptrCast(self.vtable)).GetURLFromHROW(@as(*const IGetRow, @ptrCast(self)), h_row_, ppwsz_u_r_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindResource_Value = Guid.initString("0c733ab1-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IBindResource = &IID_IBindResource_Value;
pub const IBindResource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: *const fn (
            self: *const IBindResource,
            p_unk_outer: ?*IUnknown,
            pwsz_u_r_l: ?[*:0]const u16,
            dw_bind_u_r_l_flags: u32,
            rguid: ?*const Guid,
            riid: ?*const Guid,
            p_authenticate: ?*IAuthenticate,
            p_impl_session: ?*DBIMPLICITSESSION,
            pdw_bind_status: ?*u32,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn bind(self: *const T, p_unk_outer_: ?*IUnknown, pwsz_u_r_l_: ?[*:0]const u16, dw_bind_u_r_l_flags_: u32, rguid_: ?*const Guid, riid_: ?*const Guid, p_authenticate_: ?*IAuthenticate, p_impl_session_: ?*DBIMPLICITSESSION, pdw_bind_status_: ?*u32, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IBindResource.VTable, @ptrCast(self.vtable)).Bind(@as(*const IBindResource, @ptrCast(self)), p_unk_outer_, pwsz_u_r_l_, dw_bind_u_r_l_flags_, rguid_, riid_, p_authenticate_, p_impl_session_, pdw_bind_status_, pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOPYFLAGSENUM = enum(i32) {
    ASYNC = 256,
    REPLACE_EXISTING = 512,
    ALLOW_EMULATION = 1024,
    NON_RECURSIVE = 2048,
    ATOMIC = 4096,
};
pub const DBCOPY_ASYNC = DBCOPYFLAGSENUM.ASYNC;
pub const DBCOPY_REPLACE_EXISTING = DBCOPYFLAGSENUM.REPLACE_EXISTING;
pub const DBCOPY_ALLOW_EMULATION = DBCOPYFLAGSENUM.ALLOW_EMULATION;
pub const DBCOPY_NON_RECURSIVE = DBCOPYFLAGSENUM.NON_RECURSIVE;
pub const DBCOPY_ATOMIC = DBCOPYFLAGSENUM.ATOMIC;

pub const DBMOVEFLAGSENUM = enum(i32) {
    REPLACE_EXISTING = 1,
    ASYNC = 256,
    DONT_UPDATE_LINKS = 512,
    ALLOW_EMULATION = 1024,
    ATOMIC = 4096,
};
pub const DBMOVE_REPLACE_EXISTING = DBMOVEFLAGSENUM.REPLACE_EXISTING;
pub const DBMOVE_ASYNC = DBMOVEFLAGSENUM.ASYNC;
pub const DBMOVE_DONT_UPDATE_LINKS = DBMOVEFLAGSENUM.DONT_UPDATE_LINKS;
pub const DBMOVE_ALLOW_EMULATION = DBMOVEFLAGSENUM.ALLOW_EMULATION;
pub const DBMOVE_ATOMIC = DBMOVEFLAGSENUM.ATOMIC;

pub const DBDELETEFLAGSENUM = enum(i32) {
    SYNC = 256,
    TOMIC = 4096,
};
pub const DBDELETE_ASYNC = DBDELETEFLAGSENUM.SYNC;
pub const DBDELETE_ATOMIC = DBDELETEFLAGSENUM.TOMIC;

const IID_IScopedOperations_Value = Guid.initString("0c733ab0-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IScopedOperations = &IID_IScopedOperations_Value;
pub const IScopedOperations = extern struct {
    pub const VTable = extern struct {
        base: IBindResource.VTable,
        Copy: *const fn (
            self: *const IScopedOperations,
            c_rows: usize,
            rgpwsz_source_u_r_ls: ?[*]?PWSTR,
            rgpwsz_dest_u_r_ls: [*]?PWSTR,
            dw_copy_flags: u32,
            p_authenticate: ?*IAuthenticate,
            rgdw_status: [*]u32,
            rgpwsz_new_u_r_ls: ?[*]?PWSTR,
            pp_strings_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: *const fn (
            self: *const IScopedOperations,
            c_rows: usize,
            rgpwsz_source_u_r_ls: ?[*]?PWSTR,
            rgpwsz_dest_u_r_ls: [*]?PWSTR,
            dw_move_flags: u32,
            p_authenticate: ?*IAuthenticate,
            rgdw_status: [*]u32,
            rgpwsz_new_u_r_ls: ?[*]?PWSTR,
            pp_strings_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const IScopedOperations,
            c_rows: usize,
            rgpwsz_u_r_ls: [*]?PWSTR,
            dw_delete_flags: u32,
            rgdw_status: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRowset: *const fn (
            self: *const IScopedOperations,
            p_unk_outer: ?*IUnknown,
            p_table_i_d: ?*DBID,
            p_index_i_d: ?*DBID,
            riid: ?*const Guid,
            c_property_sets: u32,
            rg_property_sets: [*]DBPROPSET,
            pp_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBindResource.MethodMixin(T);
            pub inline fn copy(self: *const T, c_rows_: usize, rgpwsz_source_u_r_ls_: ?[*]?PWSTR, rgpwsz_dest_u_r_ls_: [*]?PWSTR, dw_copy_flags_: u32, p_authenticate_: ?*IAuthenticate, rgdw_status_: [*]u32, rgpwsz_new_u_r_ls_: ?[*]?PWSTR, pp_strings_buffer_: ?*?*u16) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Copy(@as(*const IScopedOperations, @ptrCast(self)), c_rows_, rgpwsz_source_u_r_ls_, rgpwsz_dest_u_r_ls_, dw_copy_flags_, p_authenticate_, rgdw_status_, rgpwsz_new_u_r_ls_, pp_strings_buffer_);
            }
            pub inline fn move(self: *const T, c_rows_: usize, rgpwsz_source_u_r_ls_: ?[*]?PWSTR, rgpwsz_dest_u_r_ls_: [*]?PWSTR, dw_move_flags_: u32, p_authenticate_: ?*IAuthenticate, rgdw_status_: [*]u32, rgpwsz_new_u_r_ls_: ?[*]?PWSTR, pp_strings_buffer_: ?*?*u16) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Move(@as(*const IScopedOperations, @ptrCast(self)), c_rows_, rgpwsz_source_u_r_ls_, rgpwsz_dest_u_r_ls_, dw_move_flags_, p_authenticate_, rgdw_status_, rgpwsz_new_u_r_ls_, pp_strings_buffer_);
            }
            pub inline fn delete(self: *const T, c_rows_: usize, rgpwsz_u_r_ls_: [*]?PWSTR, dw_delete_flags_: u32, rgdw_status_: [*]u32) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).Delete(@as(*const IScopedOperations, @ptrCast(self)), c_rows_, rgpwsz_u_r_ls_, dw_delete_flags_, rgdw_status_);
            }
            pub inline fn openRowset(self: *const T, p_unk_outer_: ?*IUnknown, p_table_i_d_: ?*DBID, p_index_i_d_: ?*DBID, riid_: ?*const Guid, c_property_sets_: u32, rg_property_sets_: [*]DBPROPSET, pp_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IScopedOperations.VTable, @ptrCast(self.vtable)).OpenRowset(@as(*const IScopedOperations, @ptrCast(self)), p_unk_outer_, p_table_i_d_, p_index_i_d_, riid_, c_property_sets_, rg_property_sets_, pp_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateRow_Value = Guid.initString("0c733ab2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICreateRow = &IID_ICreateRow_Value;
pub const ICreateRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateRow: *const fn (
            self: *const ICreateRow,
            p_unk_outer: ?*IUnknown,
            pwsz_u_r_l: ?[*:0]const u16,
            dw_bind_u_r_l_flags: u32,
            rguid: ?*const Guid,
            riid: ?*const Guid,
            p_authenticate: ?*IAuthenticate,
            p_impl_session: ?*DBIMPLICITSESSION,
            pdw_bind_status: ?*u32,
            ppwsz_new_u_r_l: ?*?PWSTR,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createRow(self: *const T, p_unk_outer_: ?*IUnknown, pwsz_u_r_l_: ?[*:0]const u16, dw_bind_u_r_l_flags_: u32, rguid_: ?*const Guid, riid_: ?*const Guid, p_authenticate_: ?*IAuthenticate, p_impl_session_: ?*DBIMPLICITSESSION, pdw_bind_status_: ?*u32, ppwsz_new_u_r_l_: ?*?PWSTR, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const ICreateRow.VTable, @ptrCast(self.vtable)).CreateRow(@as(*const ICreateRow, @ptrCast(self)), p_unk_outer_, pwsz_u_r_l_, dw_bind_u_r_l_flags_, rguid_, riid_, p_authenticate_, p_impl_session_, pdw_bind_status_, ppwsz_new_u_r_l_, pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBBinderProperties_Value = Guid.initString("0c733ab3-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBBinderProperties = &IID_IDBBinderProperties_Value;
pub const IDBBinderProperties = extern struct {
    pub const VTable = extern struct {
        base: IDBProperties.VTable,
        Reset: *const fn (
            self: *const IDBBinderProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDBProperties.MethodMixin(T);
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IDBBinderProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDBBinderProperties, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo2_Value = Guid.initString("0c733ab8-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IColumnsInfo2 = &IID_IColumnsInfo2_Value;
pub const IColumnsInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IColumnsInfo.VTable,
        GetRestrictedColumnInfo: *const fn (
            self: *const IColumnsInfo2,
            c_column_i_d_masks: usize,
            rg_column_i_d_masks: [*]const DBID,
            dw_flags: u32,
            pc_columns: ?*usize,
            prg_column_i_ds: ?*?*DBID,
            prg_column_info: ?*?*DBCOLUMNINFO,
            pp_strings_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IColumnsInfo.MethodMixin(T);
            pub inline fn getRestrictedColumnInfo(self: *const T, c_column_i_d_masks_: usize, rg_column_i_d_masks_: [*]const DBID, dw_flags_: u32, pc_columns_: ?*usize, prg_column_i_ds_: ?*?*DBID, prg_column_info_: ?*?*DBCOLUMNINFO, pp_strings_buffer_: ?*?*u16) HRESULT {
                return @as(*const IColumnsInfo2.VTable, @ptrCast(self.vtable)).GetRestrictedColumnInfo(@as(*const IColumnsInfo2, @ptrCast(self)), c_column_i_d_masks_, rg_column_i_d_masks_, dw_flags_, pc_columns_, prg_column_i_ds_, prg_column_info_, pp_strings_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterProvider_Value = Guid.initString("0c733ab9-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRegisterProvider = &IID_IRegisterProvider_Value;
pub const IRegisterProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetURLMapping: *const fn (
            self: *const IRegisterProvider,
            pwsz_u_r_l: ?[*:0]const u16,
            dw_reserved: usize,
            pclsid_provider: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURLMapping: *const fn (
            self: *const IRegisterProvider,
            pwsz_u_r_l: ?[*:0]const u16,
            dw_reserved: usize,
            rclsid_provider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: *const fn (
            self: *const IRegisterProvider,
            pwsz_u_r_l: ?[*:0]const u16,
            dw_reserved: usize,
            rclsid_provider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getURLMapping(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, dw_reserved_: usize, pclsid_provider_: ?*Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).GetURLMapping(@as(*const IRegisterProvider, @ptrCast(self)), pwsz_u_r_l_, dw_reserved_, pclsid_provider_);
            }
            pub inline fn setURLMapping(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, dw_reserved_: usize, rclsid_provider_: ?*const Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).SetURLMapping(@as(*const IRegisterProvider, @ptrCast(self)), pwsz_u_r_l_, dw_reserved_, rclsid_provider_);
            }
            pub inline fn unregisterProvider(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, dw_reserved_: usize, rclsid_provider_: ?*const Guid) HRESULT {
                return @as(*const IRegisterProvider.VTable, @ptrCast(self.vtable)).UnregisterProvider(@as(*const IRegisterProvider, @ptrCast(self)), pwsz_u_r_l_, dw_reserved_, rclsid_provider_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSession_Value = Guid.initString("0c733aba-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSession = &IID_IGetSession_Value;
pub const IGetSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSession: *const fn (
            self: *const IGetSession,
            riid: ?*const Guid,
            pp_session: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSession(self: *const T, riid_: ?*const Guid, pp_session_: ?*?*IUnknown) HRESULT {
                return @as(*const IGetSession.VTable, @ptrCast(self.vtable)).GetSession(@as(*const IGetSession, @ptrCast(self)), riid_, pp_session_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSourceRow_Value = Guid.initString("0c733abb-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IGetSourceRow = &IID_IGetSourceRow_Value;
pub const IGetSourceRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceRow: *const fn (
            self: *const IGetSourceRow,
            riid: ?*const Guid,
            pp_row: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSourceRow(self: *const T, riid_: ?*const Guid, pp_row_: ?*?*IUnknown) HRESULT {
                return @as(*const IGetSourceRow.VTable, @ptrCast(self.vtable)).GetSourceRow(@as(*const IGetSourceRow, @ptrCast(self)), riid_, pp_row_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetCurrentIndex_Value = Guid.initString("0c733abd-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCurrentIndex = &IID_IRowsetCurrentIndex_Value;
pub const IRowsetCurrentIndex = extern struct {
    pub const VTable = extern struct {
        base: IRowsetIndex.VTable,
        GetIndex: *const fn (
            self: *const IRowsetCurrentIndex,
            pp_index_i_d: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: *const fn (
            self: *const IRowsetCurrentIndex,
            p_index_i_d: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetIndex.MethodMixin(T);
            pub inline fn getIndex(self: *const T, pp_index_i_d_: ?*?*DBID) HRESULT {
                return @as(*const IRowsetCurrentIndex.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const IRowsetCurrentIndex, @ptrCast(self)), pp_index_i_d_);
            }
            pub inline fn setIndex(self: *const T, p_index_i_d_: ?*DBID) HRESULT {
                return @as(*const IRowsetCurrentIndex.VTable, @ptrCast(self.vtable)).SetIndex(@as(*const IRowsetCurrentIndex, @ptrCast(self)), p_index_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandStream_Value = Guid.initString("0c733abf-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandStream = &IID_ICommandStream_Value;
pub const ICommandStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommandStream: *const fn (
            self: *const ICommandStream,
            piid: ?*Guid,
            pguid_dialect: ?*Guid,
            pp_command_stream: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandStream: *const fn (
            self: *const ICommandStream,
            riid: ?*const Guid,
            rguid_dialect: ?*const Guid,
            p_command_stream: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCommandStream(self: *const T, piid_: ?*Guid, pguid_dialect_: ?*Guid, pp_command_stream_: ?*?*IUnknown) HRESULT {
                return @as(*const ICommandStream.VTable, @ptrCast(self.vtable)).GetCommandStream(@as(*const ICommandStream, @ptrCast(self)), piid_, pguid_dialect_, pp_command_stream_);
            }
            pub inline fn setCommandStream(self: *const T, riid_: ?*const Guid, rguid_dialect_: ?*const Guid, p_command_stream_: ?*IUnknown) HRESULT {
                return @as(*const ICommandStream.VTable, @ptrCast(self.vtable)).SetCommandStream(@as(*const ICommandStream, @ptrCast(self)), riid_, rguid_dialect_, p_command_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetBookmark_Value = Guid.initString("0c733ac2-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetBookmark = &IID_IRowsetBookmark_Value;
pub const IRowsetBookmark = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PositionOnBookmark: *const fn (
            self: *const IRowsetBookmark,
            h_chapter: usize,
            cb_bookmark: usize,
            // TODO: what to do with BytesParamIndex 1?
            p_bookmark: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn positionOnBookmark(self: *const T, h_chapter_: usize, cb_bookmark_: usize, p_bookmark_: ?*const u8) HRESULT {
                return @as(*const IRowsetBookmark.VTable, @ptrCast(self.vtable)).PositionOnBookmark(@as(*const IRowsetBookmark, @ptrCast(self)), h_chapter_, cb_bookmark_, p_bookmark_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_QueryParser_Value = Guid.initString("b72f8fd8-0fab-4dd9-bdbf-245a6ce1485b");
pub const CLSID_QueryParser = &CLSID_QueryParser_Value;

const CLSID_NegationCondition_Value = Guid.initString("8de9c74c-605a-4acd-bee3-2b222aa2d23d");
pub const CLSID_NegationCondition = &CLSID_NegationCondition_Value;

const CLSID_CompoundCondition_Value = Guid.initString("116f8d13-101e-4fa5-84d4-ff8279381935");
pub const CLSID_CompoundCondition = &CLSID_CompoundCondition_Value;

const CLSID_LeafCondition_Value = Guid.initString("52f15c89-5a17-48e1-bbcd-46a3f89c7cc2");
pub const CLSID_LeafCondition = &CLSID_LeafCondition_Value;

const CLSID_ConditionFactory_Value = Guid.initString("e03e85b0-7be3-4000-ba98-6c13de9fa486");
pub const CLSID_ConditionFactory = &CLSID_ConditionFactory_Value;

const CLSID_Interval_Value = Guid.initString("d957171f-4bf9-4de2-bcd5-c70a7ca55836");
pub const CLSID_Interval = &CLSID_Interval_Value;

const CLSID_QueryParserManager_Value = Guid.initString("5088b39a-29b4-4d9d-8245-4ee289222f66");
pub const CLSID_QueryParserManager = &CLSID_QueryParserManager_Value;

pub const STRUCTURED_QUERY_SYNTAX = enum(i32) {
    NO_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SQS_NO_SYNTAX = STRUCTURED_QUERY_SYNTAX.NO_SYNTAX;
pub const SQS_ADVANCED_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SQS_NATURAL_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const STRUCTURED_QUERY_SINGLE_OPTION = enum(i32) {
    SCHEMA = 0,
    LOCALE_WORD_BREAKING = 1,
    WORD_BREAKER = 2,
    NATURAL_SYNTAX = 3,
    AUTOMATIC_WILDCARD = 4,
    TRACE_LEVEL = 5,
    LANGUAGE_KEYWORDS = 6,
    SYNTAX = 7,
    TIME_ZONE = 8,
    IMPLICIT_CONNECTOR = 9,
    CONNECTOR_CASE = 10,
};
pub const SQSO_SCHEMA = STRUCTURED_QUERY_SINGLE_OPTION.SCHEMA;
pub const SQSO_LOCALE_WORD_BREAKING = STRUCTURED_QUERY_SINGLE_OPTION.LOCALE_WORD_BREAKING;
pub const SQSO_WORD_BREAKER = STRUCTURED_QUERY_SINGLE_OPTION.WORD_BREAKER;
pub const SQSO_NATURAL_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.NATURAL_SYNTAX;
pub const SQSO_AUTOMATIC_WILDCARD = STRUCTURED_QUERY_SINGLE_OPTION.AUTOMATIC_WILDCARD;
pub const SQSO_TRACE_LEVEL = STRUCTURED_QUERY_SINGLE_OPTION.TRACE_LEVEL;
pub const SQSO_LANGUAGE_KEYWORDS = STRUCTURED_QUERY_SINGLE_OPTION.LANGUAGE_KEYWORDS;
pub const SQSO_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.SYNTAX;
pub const SQSO_TIME_ZONE = STRUCTURED_QUERY_SINGLE_OPTION.TIME_ZONE;
pub const SQSO_IMPLICIT_CONNECTOR = STRUCTURED_QUERY_SINGLE_OPTION.IMPLICIT_CONNECTOR;
pub const SQSO_CONNECTOR_CASE = STRUCTURED_QUERY_SINGLE_OPTION.CONNECTOR_CASE;

pub const STRUCTURED_QUERY_MULTIOPTION = enum(i32) {
    VIRTUAL_PROPERTY = 0,
    DEFAULT_PROPERTY = 1,
    GENERATOR_FOR_TYPE = 2,
    MAP_PROPERTY = 3,
};
pub const SQMO_VIRTUAL_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.VIRTUAL_PROPERTY;
pub const SQMO_DEFAULT_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.DEFAULT_PROPERTY;
pub const SQMO_GENERATOR_FOR_TYPE = STRUCTURED_QUERY_MULTIOPTION.GENERATOR_FOR_TYPE;
pub const SQMO_MAP_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.MAP_PROPERTY;

pub const STRUCTURED_QUERY_PARSE_ERROR = enum(i32) {
    NONE = 0,
    EXTRA_OPENING_PARENTHESIS = 1,
    EXTRA_CLOSING_PARENTHESIS = 2,
    IGNORED_MODIFIER = 3,
    IGNORED_CONNECTOR = 4,
    IGNORED_KEYWORD = 5,
    UNHANDLED = 6,
};
pub const SQPE_NONE = STRUCTURED_QUERY_PARSE_ERROR.NONE;
pub const SQPE_EXTRA_OPENING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_OPENING_PARENTHESIS;
pub const SQPE_EXTRA_CLOSING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.EXTRA_CLOSING_PARENTHESIS;
pub const SQPE_IGNORED_MODIFIER = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_MODIFIER;
pub const SQPE_IGNORED_CONNECTOR = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_CONNECTOR;
pub const SQPE_IGNORED_KEYWORD = STRUCTURED_QUERY_PARSE_ERROR.IGNORED_KEYWORD;
pub const SQPE_UNHANDLED = STRUCTURED_QUERY_PARSE_ERROR.UNHANDLED;

pub const STRUCTURED_QUERY_RESOLVE_OPTION = enum(u32) {
    DEFAULT = 0,
    DONT_RESOLVE_DATETIME = 1,
    ALWAYS_ONE_INTERVAL = 2,
    DONT_SIMPLIFY_CONDITION_TREES = 4,
    DONT_MAP_RELATIONS = 8,
    DONT_RESOLVE_RANGES = 16,
    DONT_REMOVE_UNRESTRICTED_KEYWORDS = 32,
    DONT_SPLIT_WORDS = 64,
    IGNORE_PHRASE_ORDER = 128,
    ADD_VALUE_TYPE_FOR_PLAIN_VALUES = 256,
    ADD_ROBUST_ITEM_NAME = 512,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        DONT_RESOLVE_DATETIME: u1 = 0,
        ALWAYS_ONE_INTERVAL: u1 = 0,
        DONT_SIMPLIFY_CONDITION_TREES: u1 = 0,
        DONT_MAP_RELATIONS: u1 = 0,
        DONT_RESOLVE_RANGES: u1 = 0,
        DONT_REMOVE_UNRESTRICTED_KEYWORDS: u1 = 0,
        DONT_SPLIT_WORDS: u1 = 0,
        IGNORE_PHRASE_ORDER: u1 = 0,
        ADD_VALUE_TYPE_FOR_PLAIN_VALUES: u1 = 0,
        ADD_ROBUST_ITEM_NAME: u1 = 0,
    }) STRUCTURED_QUERY_RESOLVE_OPTION {
        return @as(STRUCTURED_QUERY_RESOLVE_OPTION, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DEFAULT) else 0) | (if (o.DONT_RESOLVE_DATETIME == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_DATETIME) else 0) | (if (o.ALWAYS_ONE_INTERVAL == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ALWAYS_ONE_INTERVAL) else 0) | (if (o.DONT_SIMPLIFY_CONDITION_TREES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SIMPLIFY_CONDITION_TREES) else 0) | (if (o.DONT_MAP_RELATIONS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_MAP_RELATIONS) else 0) | (if (o.DONT_RESOLVE_RANGES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_RANGES) else 0) | (if (o.DONT_REMOVE_UNRESTRICTED_KEYWORDS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_REMOVE_UNRESTRICTED_KEYWORDS) else 0) | (if (o.DONT_SPLIT_WORDS == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SPLIT_WORDS) else 0) | (if (o.IGNORE_PHRASE_ORDER == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.IGNORE_PHRASE_ORDER) else 0) | (if (o.ADD_VALUE_TYPE_FOR_PLAIN_VALUES == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ADD_VALUE_TYPE_FOR_PLAIN_VALUES) else 0) | (if (o.ADD_ROBUST_ITEM_NAME == 1) @intFromEnum(STRUCTURED_QUERY_RESOLVE_OPTION.ADD_ROBUST_ITEM_NAME) else 0)));
    }
};
pub const SQRO_DEFAULT = STRUCTURED_QUERY_RESOLVE_OPTION.DEFAULT;
pub const SQRO_DONT_RESOLVE_DATETIME = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_DATETIME;
pub const SQRO_ALWAYS_ONE_INTERVAL = STRUCTURED_QUERY_RESOLVE_OPTION.ALWAYS_ONE_INTERVAL;
pub const SQRO_DONT_SIMPLIFY_CONDITION_TREES = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SIMPLIFY_CONDITION_TREES;
pub const SQRO_DONT_MAP_RELATIONS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_MAP_RELATIONS;
pub const SQRO_DONT_RESOLVE_RANGES = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_RESOLVE_RANGES;
pub const SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_REMOVE_UNRESTRICTED_KEYWORDS;
pub const SQRO_DONT_SPLIT_WORDS = STRUCTURED_QUERY_RESOLVE_OPTION.DONT_SPLIT_WORDS;
pub const SQRO_IGNORE_PHRASE_ORDER = STRUCTURED_QUERY_RESOLVE_OPTION.IGNORE_PHRASE_ORDER;
pub const SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = STRUCTURED_QUERY_RESOLVE_OPTION.ADD_VALUE_TYPE_FOR_PLAIN_VALUES;
pub const SQRO_ADD_ROBUST_ITEM_NAME = STRUCTURED_QUERY_RESOLVE_OPTION.ADD_ROBUST_ITEM_NAME;

pub const CASE_REQUIREMENT = enum(i32) {
    ANY = 0,
    UPPER_IF_AQS = 1,
};
pub const CASE_REQUIREMENT_ANY = CASE_REQUIREMENT.ANY;
pub const CASE_REQUIREMENT_UPPER_IF_AQS = CASE_REQUIREMENT.UPPER_IF_AQS;

pub const INTERVAL_LIMIT_KIND = enum(i32) {
    EXPLICIT_INCLUDED = 0,
    EXPLICIT_EXCLUDED = 1,
    NEGATIVE_INFINITY = 2,
    POSITIVE_INFINITY = 3,
};
pub const ILK_EXPLICIT_INCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_INCLUDED;
pub const ILK_EXPLICIT_EXCLUDED = INTERVAL_LIMIT_KIND.EXPLICIT_EXCLUDED;
pub const ILK_NEGATIVE_INFINITY = INTERVAL_LIMIT_KIND.NEGATIVE_INFINITY;
pub const ILK_POSITIVE_INFINITY = INTERVAL_LIMIT_KIND.POSITIVE_INFINITY;

pub const QUERY_PARSER_MANAGER_OPTION = enum(i32) {
    SCHEMA_BINARY_NAME = 0,
    PRELOCALIZED_SCHEMA_BINARY_PATH = 1,
    UNLOCALIZED_SCHEMA_BINARY_PATH = 2,
    LOCALIZED_SCHEMA_BINARY_PATH = 3,
    APPEND_LCID_TO_LOCALIZED_PATH = 4,
    LOCALIZER_SUPPORT = 5,
};
pub const QPMO_SCHEMA_BINARY_NAME = QUERY_PARSER_MANAGER_OPTION.SCHEMA_BINARY_NAME;
pub const QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.PRELOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.UNLOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_LOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.LOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_APPEND_LCID_TO_LOCALIZED_PATH = QUERY_PARSER_MANAGER_OPTION.APPEND_LCID_TO_LOCALIZED_PATH;
pub const QPMO_LOCALIZER_SUPPORT = QUERY_PARSER_MANAGER_OPTION.LOCALIZER_SUPPORT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParser_Value = Guid.initString("2ebdee67-3505-43f8-9946-ea44abc8e5b0");
pub const IID_IQueryParser = &IID_IQueryParser_Value;
pub const IQueryParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Parse: *const fn (
            self: *const IQueryParser,
            psz_input_string: ?[*:0]const u16,
            p_custom_properties: ?*IEnumUnknown,
            pp_solution: ?*?*IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: *const fn (
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            p_option_value: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOption: *const fn (
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            p_option_value: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMultiOption: *const fn (
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_MULTIOPTION,
            psz_option_key: ?[*:0]const u16,
            p_option_value: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemaProvider: *const fn (
            self: *const IQueryParser,
            pp_schema_provider: ?*?*ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestateToString: *const fn (
            self: *const IQueryParser,
            p_condition: ?*ICondition,
            f_use_english: BOOL,
            ppsz_query_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParsePropertyValue: *const fn (
            self: *const IQueryParser,
            psz_property_name: ?[*:0]const u16,
            psz_input_string: ?[*:0]const u16,
            pp_solution: ?*?*IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestatePropertyValueToString: *const fn (
            self: *const IQueryParser,
            p_condition: ?*ICondition,
            f_use_english: BOOL,
            ppsz_property_name: ?*?PWSTR,
            ppsz_query_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn parse(self: *const T, psz_input_string_: ?[*:0]const u16, p_custom_properties_: ?*IEnumUnknown, pp_solution_: ?*?*IQuerySolution) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).Parse(@as(*const IQueryParser, @ptrCast(self)), psz_input_string_, p_custom_properties_, pp_solution_);
            }
            pub inline fn setOption(self: *const T, option_: STRUCTURED_QUERY_SINGLE_OPTION, p_option_value_: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IQueryParser, @ptrCast(self)), option_, p_option_value_);
            }
            pub inline fn getOption(self: *const T, option_: STRUCTURED_QUERY_SINGLE_OPTION, p_option_value_: ?*PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).GetOption(@as(*const IQueryParser, @ptrCast(self)), option_, p_option_value_);
            }
            pub inline fn setMultiOption(self: *const T, option_: STRUCTURED_QUERY_MULTIOPTION, psz_option_key_: ?[*:0]const u16, p_option_value_: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).SetMultiOption(@as(*const IQueryParser, @ptrCast(self)), option_, psz_option_key_, p_option_value_);
            }
            pub inline fn getSchemaProvider(self: *const T, pp_schema_provider_: ?*?*ISchemaProvider) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).GetSchemaProvider(@as(*const IQueryParser, @ptrCast(self)), pp_schema_provider_);
            }
            pub inline fn restateToString(self: *const T, p_condition_: ?*ICondition, f_use_english_: BOOL, ppsz_query_string_: ?*?PWSTR) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).RestateToString(@as(*const IQueryParser, @ptrCast(self)), p_condition_, f_use_english_, ppsz_query_string_);
            }
            pub inline fn parsePropertyValue(self: *const T, psz_property_name_: ?[*:0]const u16, psz_input_string_: ?[*:0]const u16, pp_solution_: ?*?*IQuerySolution) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).ParsePropertyValue(@as(*const IQueryParser, @ptrCast(self)), psz_property_name_, psz_input_string_, pp_solution_);
            }
            pub inline fn restatePropertyValueToString(self: *const T, p_condition_: ?*ICondition, f_use_english_: BOOL, ppsz_property_name_: ?*?PWSTR, ppsz_query_string_: ?*?PWSTR) HRESULT {
                return @as(*const IQueryParser.VTable, @ptrCast(self.vtable)).RestatePropertyValueToString(@as(*const IQueryParser, @ptrCast(self)), p_condition_, f_use_english_, ppsz_property_name_, ppsz_query_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionFactory_Value = Guid.initString("a5efe073-b16f-474f-9f3e-9f8b497a3e08");
pub const IID_IConditionFactory = &IID_IConditionFactory_Value;
pub const IConditionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MakeNot: *const fn (
            self: *const IConditionFactory,
            pc_sub: ?*ICondition,
            f_simplify: BOOL,
            ppc_result: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeAndOr: *const fn (
            self: *const IConditionFactory,
            ct: CONDITION_TYPE,
            peu_subs: ?*IEnumUnknown,
            f_simplify: BOOL,
            ppc_result: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeLeaf: *const fn (
            self: *const IConditionFactory,
            psz_property_name: ?[*:0]const u16,
            cop: CONDITION_OPERATION,
            psz_value_type: ?[*:0]const u16,
            ppropvar: ?*const PROPVARIANT,
            p_property_name_term: ?*IRichChunk,
            p_operation_term: ?*IRichChunk,
            p_value_term: ?*IRichChunk,
            f_expand: BOOL,
            ppc_result: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: *const fn (
            self: *const IConditionFactory,
            pc: ?*ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pst_reference_time: ?*const SYSTEMTIME,
            ppc_resolved: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn makeNot(self: *const T, pc_sub_: ?*ICondition, f_simplify_: BOOL, ppc_result_: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeNot(@as(*const IConditionFactory, @ptrCast(self)), pc_sub_, f_simplify_, ppc_result_);
            }
            pub inline fn makeAndOr(self: *const T, ct_: CONDITION_TYPE, peu_subs_: ?*IEnumUnknown, f_simplify_: BOOL, ppc_result_: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeAndOr(@as(*const IConditionFactory, @ptrCast(self)), ct_, peu_subs_, f_simplify_, ppc_result_);
            }
            pub inline fn makeLeaf(self: *const T, psz_property_name_: ?[*:0]const u16, cop_: CONDITION_OPERATION, psz_value_type_: ?[*:0]const u16, ppropvar_: ?*const PROPVARIANT, p_property_name_term_: ?*IRichChunk, p_operation_term_: ?*IRichChunk, p_value_term_: ?*IRichChunk, f_expand_: BOOL, ppc_result_: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).MakeLeaf(@as(*const IConditionFactory, @ptrCast(self)), psz_property_name_, cop_, psz_value_type_, ppropvar_, p_property_name_term_, p_operation_term_, p_value_term_, f_expand_, ppc_result_);
            }
            pub inline fn resolve(self: *const T, pc_: ?*ICondition, sqro_: STRUCTURED_QUERY_RESOLVE_OPTION, pst_reference_time_: ?*const SYSTEMTIME, ppc_resolved_: ?*?*ICondition) HRESULT {
                return @as(*const IConditionFactory.VTable, @ptrCast(self.vtable)).Resolve(@as(*const IConditionFactory, @ptrCast(self)), pc_, sqro_, pst_reference_time_, ppc_resolved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQuerySolution_Value = Guid.initString("d6ebc66b-8921-4193-afdd-a1789fb7ff57");
pub const IID_IQuerySolution = &IID_IQuerySolution_Value;
pub const IQuerySolution = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        GetQuery: *const fn (
            self: *const IQuerySolution,
            pp_query_node: ?*?*ICondition,
            pp_main_type: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrors: *const fn (
            self: *const IQuerySolution,
            riid: ?*const Guid,
            pp_parse_errors: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLexicalData: *const fn (
            self: *const IQuerySolution,
            ppsz_input_string: ?*?PWSTR,
            pp_tokens: ?*?*ITokenCollection,
            plcid: ?*u32,
            pp_word_breaker: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConditionFactory.MethodMixin(T);
            pub inline fn getQuery(self: *const T, pp_query_node_: ?*?*ICondition, pp_main_type_: ?*?*IEntity) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IQuerySolution, @ptrCast(self)), pp_query_node_, pp_main_type_);
            }
            pub inline fn getErrors(self: *const T, riid_: ?*const Guid, pp_parse_errors_: ?*?*anyopaque) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetErrors(@as(*const IQuerySolution, @ptrCast(self)), riid_, pp_parse_errors_);
            }
            pub inline fn getLexicalData(self: *const T, ppsz_input_string_: ?*?PWSTR, pp_tokens_: ?*?*ITokenCollection, plcid_: ?*u32, pp_word_breaker_: ?*?*IUnknown) HRESULT {
                return @as(*const IQuerySolution.VTable, @ptrCast(self.vtable)).GetLexicalData(@as(*const IQuerySolution, @ptrCast(self)), ppsz_input_string_, pp_tokens_, plcid_, pp_word_breaker_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONDITION_CREATION_OPTIONS = enum(u32) {
    DEFAULT = 0,
    // NONE = 0, this enum value conflicts with DEFAULT
    SIMPLIFY = 1,
    VECTOR_AND = 2,
    VECTOR_OR = 4,
    VECTOR_LEAF = 8,
    USE_CONTENT_LOCALE = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        SIMPLIFY: u1 = 0,
        VECTOR_AND: u1 = 0,
        VECTOR_OR: u1 = 0,
        VECTOR_LEAF: u1 = 0,
        USE_CONTENT_LOCALE: u1 = 0,
    }) CONDITION_CREATION_OPTIONS {
        return @as(CONDITION_CREATION_OPTIONS, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.DEFAULT) else 0) | (if (o.SIMPLIFY == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.SIMPLIFY) else 0) | (if (o.VECTOR_AND == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_AND) else 0) | (if (o.VECTOR_OR == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_OR) else 0) | (if (o.VECTOR_LEAF == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.VECTOR_LEAF) else 0) | (if (o.USE_CONTENT_LOCALE == 1) @intFromEnum(CONDITION_CREATION_OPTIONS.USE_CONTENT_LOCALE) else 0)));
    }
};
pub const CONDITION_CREATION_DEFAULT = CONDITION_CREATION_OPTIONS.DEFAULT;
pub const CONDITION_CREATION_NONE = CONDITION_CREATION_OPTIONS.DEFAULT;
pub const CONDITION_CREATION_SIMPLIFY = CONDITION_CREATION_OPTIONS.SIMPLIFY;
pub const CONDITION_CREATION_VECTOR_AND = CONDITION_CREATION_OPTIONS.VECTOR_AND;
pub const CONDITION_CREATION_VECTOR_OR = CONDITION_CREATION_OPTIONS.VECTOR_OR;
pub const CONDITION_CREATION_VECTOR_LEAF = CONDITION_CREATION_OPTIONS.VECTOR_LEAF;
pub const CONDITION_CREATION_USE_CONTENT_LOCALE = CONDITION_CREATION_OPTIONS.USE_CONTENT_LOCALE;

// TODO: this type is limited to platform 'windows6.1'
const IID_IConditionFactory2_Value = Guid.initString("71d222e1-432f-429e-8c13-b6dafde5077a");
pub const IID_IConditionFactory2 = &IID_IConditionFactory2_Value;
pub const IConditionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        CreateTrueFalse: *const fn (
            self: *const IConditionFactory2,
            f_val: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNegation: *const fn (
            self: *const IConditionFactory2,
            pc_sub: ?*ICondition,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromObjectArray: *const fn (
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            poa_subs: ?*IObjectArray,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromArray: *const fn (
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            ppcond_subs: [*]?*ICondition,
            c_subs: u32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStringLeaf: *const fn (
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            psz_value: ?[*:0]const u16,
            psz_locale_name: ?[*:0]const u16,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIntegerLeaf: *const fn (
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            l_value: i32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBooleanLeaf: *const fn (
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            f_value: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLeaf: *const fn (
            self: *const IConditionFactory2,
            propkey: ?*const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            propvar: ?*const PROPVARIANT,
            psz_semantic_type: ?[*:0]const u16,
            psz_locale_name: ?[*:0]const u16,
            p_property_name_term: ?*IRichChunk,
            p_operation_term: ?*IRichChunk,
            p_value_term: ?*IRichChunk,
            cco: CONDITION_CREATION_OPTIONS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveCondition: *const fn (
            self: *const IConditionFactory2,
            pc: ?*ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pst_reference_time: ?*const SYSTEMTIME,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConditionFactory.MethodMixin(T);
            pub inline fn createTrueFalse(self: *const T, f_val_: BOOL, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateTrueFalse(@as(*const IConditionFactory2, @ptrCast(self)), f_val_, cco_, riid_, ppv_);
            }
            pub inline fn createNegation(self: *const T, pc_sub_: ?*ICondition, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateNegation(@as(*const IConditionFactory2, @ptrCast(self)), pc_sub_, cco_, riid_, ppv_);
            }
            pub inline fn createCompoundFromObjectArray(self: *const T, ct_: CONDITION_TYPE, poa_subs_: ?*IObjectArray, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateCompoundFromObjectArray(@as(*const IConditionFactory2, @ptrCast(self)), ct_, poa_subs_, cco_, riid_, ppv_);
            }
            pub inline fn createCompoundFromArray(self: *const T, ct_: CONDITION_TYPE, ppcond_subs_: [*]?*ICondition, c_subs_: u32, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateCompoundFromArray(@as(*const IConditionFactory2, @ptrCast(self)), ct_, ppcond_subs_, c_subs_, cco_, riid_, ppv_);
            }
            pub inline fn createStringLeaf(self: *const T, propkey_: ?*const PROPERTYKEY, cop_: CONDITION_OPERATION, psz_value_: ?[*:0]const u16, psz_locale_name_: ?[*:0]const u16, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateStringLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey_, cop_, psz_value_, psz_locale_name_, cco_, riid_, ppv_);
            }
            pub inline fn createIntegerLeaf(self: *const T, propkey_: ?*const PROPERTYKEY, cop_: CONDITION_OPERATION, l_value_: i32, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateIntegerLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey_, cop_, l_value_, cco_, riid_, ppv_);
            }
            pub inline fn createBooleanLeaf(self: *const T, propkey_: ?*const PROPERTYKEY, cop_: CONDITION_OPERATION, f_value_: BOOL, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateBooleanLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey_, cop_, f_value_, cco_, riid_, ppv_);
            }
            pub inline fn createLeaf(self: *const T, propkey_: ?*const PROPERTYKEY, cop_: CONDITION_OPERATION, propvar_: ?*const PROPVARIANT, psz_semantic_type_: ?[*:0]const u16, psz_locale_name_: ?[*:0]const u16, p_property_name_term_: ?*IRichChunk, p_operation_term_: ?*IRichChunk, p_value_term_: ?*IRichChunk, cco_: CONDITION_CREATION_OPTIONS, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).CreateLeaf(@as(*const IConditionFactory2, @ptrCast(self)), propkey_, cop_, propvar_, psz_semantic_type_, psz_locale_name_, p_property_name_term_, p_operation_term_, p_value_term_, cco_, riid_, ppv_);
            }
            pub inline fn resolveCondition(self: *const T, pc_: ?*ICondition, sqro_: STRUCTURED_QUERY_RESOLVE_OPTION, pst_reference_time_: ?*const SYSTEMTIME, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IConditionFactory2.VTable, @ptrCast(self.vtable)).ResolveCondition(@as(*const IConditionFactory2, @ptrCast(self)), pc_, sqro_, pst_reference_time_, riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConditionGenerator_Value = Guid.initString("92d2cc58-4386-45a3-b98c-7e0ce64a4117");
pub const IID_IConditionGenerator = &IID_IConditionGenerator_Value;
pub const IConditionGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IConditionGenerator,
            p_schema_provider: ?*ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecognizeNamedEntities: *const fn (
            self: *const IConditionGenerator,
            psz_input_string: ?[*:0]const u16,
            lcid_user_locale: u32,
            p_token_collection: ?*ITokenCollection,
            p_named_entities: ?*INamedEntityCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateForLeaf: *const fn (
            self: *const IConditionGenerator,
            p_condition_factory: ?*IConditionFactory,
            psz_property_name: ?[*:0]const u16,
            cop: CONDITION_OPERATION,
            psz_value_type: ?[*:0]const u16,
            psz_value: ?[*:0]const u16,
            psz_value2: ?[*:0]const u16,
            p_property_name_term: ?*IRichChunk,
            p_operation_term: ?*IRichChunk,
            p_value_term: ?*IRichChunk,
            automatic_wildcard: BOOL,
            p_no_string_query: ?*BOOL,
            pp_query_expression: ?*?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn (
            self: *const IConditionGenerator,
            psz_value_type: ?[*:0]const u16,
            ppropvar: ?*const PROPVARIANT,
            f_use_english: BOOL,
            ppsz_phrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_schema_provider_: ?*ISchemaProvider) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IConditionGenerator, @ptrCast(self)), p_schema_provider_);
            }
            pub inline fn recognizeNamedEntities(self: *const T, psz_input_string_: ?[*:0]const u16, lcid_user_locale_: u32, p_token_collection_: ?*ITokenCollection, p_named_entities_: ?*INamedEntityCollector) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).RecognizeNamedEntities(@as(*const IConditionGenerator, @ptrCast(self)), psz_input_string_, lcid_user_locale_, p_token_collection_, p_named_entities_);
            }
            pub inline fn generateForLeaf(self: *const T, p_condition_factory_: ?*IConditionFactory, psz_property_name_: ?[*:0]const u16, cop_: CONDITION_OPERATION, psz_value_type_: ?[*:0]const u16, psz_value_: ?[*:0]const u16, psz_value2_: ?[*:0]const u16, p_property_name_term_: ?*IRichChunk, p_operation_term_: ?*IRichChunk, p_value_term_: ?*IRichChunk, automatic_wildcard_: BOOL, p_no_string_query_: ?*BOOL, pp_query_expression_: ?*?*ICondition) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).GenerateForLeaf(@as(*const IConditionGenerator, @ptrCast(self)), p_condition_factory_, psz_property_name_, cop_, psz_value_type_, psz_value_, psz_value2_, p_property_name_term_, p_operation_term_, p_value_term_, automatic_wildcard_, p_no_string_query_, pp_query_expression_);
            }
            pub inline fn defaultPhrase(self: *const T, psz_value_type_: ?[*:0]const u16, ppropvar_: ?*const PROPVARIANT, f_use_english_: BOOL, ppsz_phrase_: ?*?PWSTR) HRESULT {
                return @as(*const IConditionGenerator.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IConditionGenerator, @ptrCast(self)), psz_value_type_, ppropvar_, f_use_english_, ppsz_phrase_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInterval_Value = Guid.initString("6bf0a714-3c18-430b-8b5d-83b1c234d3db");
pub const IID_IInterval = &IID_IInterval_Value;
pub const IInterval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLimits: *const fn (
            self: *const IInterval,
            pilk_lower: ?*INTERVAL_LIMIT_KIND,
            ppropvar_lower: ?*PROPVARIANT,
            pilk_upper: ?*INTERVAL_LIMIT_KIND,
            ppropvar_upper: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLimits(self: *const T, pilk_lower_: ?*INTERVAL_LIMIT_KIND, ppropvar_lower_: ?*PROPVARIANT, pilk_upper_: ?*INTERVAL_LIMIT_KIND, ppropvar_upper_: ?*PROPVARIANT) HRESULT {
                return @as(*const IInterval.VTable, @ptrCast(self.vtable)).GetLimits(@as(*const IInterval, @ptrCast(self)), pilk_lower_, ppropvar_lower_, pilk_upper_, ppropvar_upper_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMetaData_Value = Guid.initString("780102b0-c43b-4876-bc7b-5e9ba5c88794");
pub const IID_IMetaData = &IID_IMetaData_Value;
pub const IMetaData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn (
            self: *const IMetaData,
            ppsz_key: ?*?PWSTR,
            ppsz_value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getData(self: *const T, ppsz_key_: ?*?PWSTR, ppsz_value_: ?*?PWSTR) HRESULT {
                return @as(*const IMetaData.VTable, @ptrCast(self.vtable)).GetData(@as(*const IMetaData, @ptrCast(self)), ppsz_key_, ppsz_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEntity_Value = Guid.initString("24264891-e80b-4fd3-b7ce-4ff2fae8931f");
pub const IID_IEntity = &IID_IEntity_Value;
pub const IEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: *const fn (
            self: *const IEntity,
            ppsz_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Base: *const fn (
            self: *const IEntity,
            p_base_entity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Relationships: *const fn (
            self: *const IEntity,
            riid: ?*const Guid,
            p_relationships: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationship: *const fn (
            self: *const IEntity,
            psz_relation_name: ?[*:0]const u16,
            p_relationship: ?*?*IRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn (
            self: *const IEntity,
            riid: ?*const Guid,
            p_meta_data: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NamedEntities: *const fn (
            self: *const IEntity,
            riid: ?*const Guid,
            p_named_entities: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedEntity: *const fn (
            self: *const IEntity,
            psz_value: ?[*:0]const u16,
            pp_named_entity: ?*?*INamedEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn (
            self: *const IEntity,
            ppsz_phrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn name(self: *const T, ppsz_name_: ?*?PWSTR) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Name(@as(*const IEntity, @ptrCast(self)), ppsz_name_);
            }
            pub inline fn base(self: *const T, p_base_entity_: ?*?*IEntity) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Base(@as(*const IEntity, @ptrCast(self)), p_base_entity_);
            }
            pub inline fn relationships(self: *const T, riid_: ?*const Guid, p_relationships_: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).Relationships(@as(*const IEntity, @ptrCast(self)), riid_, p_relationships_);
            }
            pub inline fn getRelationship(self: *const T, psz_relation_name_: ?[*:0]const u16, p_relationship_: ?*?*IRelationship) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).GetRelationship(@as(*const IEntity, @ptrCast(self)), psz_relation_name_, p_relationship_);
            }
            pub inline fn metaData(self: *const T, riid_: ?*const Guid, p_meta_data_: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).MetaData(@as(*const IEntity, @ptrCast(self)), riid_, p_meta_data_);
            }
            pub inline fn namedEntities(self: *const T, riid_: ?*const Guid, p_named_entities_: ?*?*anyopaque) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).NamedEntities(@as(*const IEntity, @ptrCast(self)), riid_, p_named_entities_);
            }
            pub inline fn getNamedEntity(self: *const T, psz_value_: ?[*:0]const u16, pp_named_entity_: ?*?*INamedEntity) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).GetNamedEntity(@as(*const IEntity, @ptrCast(self)), psz_value_, pp_named_entity_);
            }
            pub inline fn defaultPhrase(self: *const T, ppsz_phrase_: ?*?PWSTR) HRESULT {
                return @as(*const IEntity.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IEntity, @ptrCast(self)), ppsz_phrase_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRelationship_Value = Guid.initString("2769280b-5108-498c-9c7f-a51239b63147");
pub const IID_IRelationship = &IID_IRelationship_Value;
pub const IRelationship = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: *const fn (
            self: *const IRelationship,
            ppsz_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsReal: *const fn (
            self: *const IRelationship,
            p_is_real: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destination: *const fn (
            self: *const IRelationship,
            p_destination_entity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn (
            self: *const IRelationship,
            riid: ?*const Guid,
            p_meta_data: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn (
            self: *const IRelationship,
            ppsz_phrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn name(self: *const T, ppsz_name_: ?*?PWSTR) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).Name(@as(*const IRelationship, @ptrCast(self)), ppsz_name_);
            }
            pub inline fn isReal(self: *const T, p_is_real_: ?*BOOL) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).IsReal(@as(*const IRelationship, @ptrCast(self)), p_is_real_);
            }
            pub inline fn destination(self: *const T, p_destination_entity_: ?*?*IEntity) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).Destination(@as(*const IRelationship, @ptrCast(self)), p_destination_entity_);
            }
            pub inline fn metaData(self: *const T, riid_: ?*const Guid, p_meta_data_: ?*?*anyopaque) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).MetaData(@as(*const IRelationship, @ptrCast(self)), riid_, p_meta_data_);
            }
            pub inline fn defaultPhrase(self: *const T, ppsz_phrase_: ?*?PWSTR) HRESULT {
                return @as(*const IRelationship.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const IRelationship, @ptrCast(self)), ppsz_phrase_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntity_Value = Guid.initString("abdbd0b1-7d54-49fb-ab5c-bff4130004cd");
pub const IID_INamedEntity = &IID_INamedEntity_Value;
pub const INamedEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: *const fn (
            self: *const INamedEntity,
            ppsz_value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: *const fn (
            self: *const INamedEntity,
            ppsz_phrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getValue(self: *const T, ppsz_value_: ?*?PWSTR) HRESULT {
                return @as(*const INamedEntity.VTable, @ptrCast(self.vtable)).GetValue(@as(*const INamedEntity, @ptrCast(self)), ppsz_value_);
            }
            pub inline fn defaultPhrase(self: *const T, ppsz_phrase_: ?*?PWSTR) HRESULT {
                return @as(*const INamedEntity.VTable, @ptrCast(self.vtable)).DefaultPhrase(@as(*const INamedEntity, @ptrCast(self)), ppsz_phrase_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaProvider_Value = Guid.initString("8cf89bcb-394c-49b2-ae28-a59dd4ed7f68");
pub const IID_ISchemaProvider = &IID_ISchemaProvider_Value;
pub const ISchemaProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Entities: *const fn (
            self: *const ISchemaProvider,
            riid: ?*const Guid,
            p_entities: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RootEntity: *const fn (
            self: *const ISchemaProvider,
            p_root_entity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntity: *const fn (
            self: *const ISchemaProvider,
            psz_entity_name: ?[*:0]const u16,
            p_entity: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: *const fn (
            self: *const ISchemaProvider,
            riid: ?*const Guid,
            p_meta_data: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Localize: *const fn (
            self: *const ISchemaProvider,
            lcid: u32,
            p_schema_localizer_support: ?*ISchemaLocalizerSupport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveBinary: *const fn (
            self: *const ISchemaProvider,
            psz_schema_binary_path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupAuthoredNamedEntity: *const fn (
            self: *const ISchemaProvider,
            p_entity: ?*IEntity,
            psz_input_string: ?[*:0]const u16,
            p_token_collection: ?*ITokenCollection,
            c_tokens_begin: u32,
            pc_tokens_length: ?*u32,
            ppsz_value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn entities(self: *const T, riid_: ?*const Guid, p_entities_: ?*?*anyopaque) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).Entities(@as(*const ISchemaProvider, @ptrCast(self)), riid_, p_entities_);
            }
            pub inline fn rootEntity(self: *const T, p_root_entity_: ?*?*IEntity) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).RootEntity(@as(*const ISchemaProvider, @ptrCast(self)), p_root_entity_);
            }
            pub inline fn getEntity(self: *const T, psz_entity_name_: ?[*:0]const u16, p_entity_: ?*?*IEntity) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).GetEntity(@as(*const ISchemaProvider, @ptrCast(self)), psz_entity_name_, p_entity_);
            }
            pub inline fn metaData(self: *const T, riid_: ?*const Guid, p_meta_data_: ?*?*anyopaque) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).MetaData(@as(*const ISchemaProvider, @ptrCast(self)), riid_, p_meta_data_);
            }
            pub inline fn localize(self: *const T, lcid_: u32, p_schema_localizer_support_: ?*ISchemaLocalizerSupport) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).Localize(@as(*const ISchemaProvider, @ptrCast(self)), lcid_, p_schema_localizer_support_);
            }
            pub inline fn saveBinary(self: *const T, psz_schema_binary_path_: ?[*:0]const u16) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).SaveBinary(@as(*const ISchemaProvider, @ptrCast(self)), psz_schema_binary_path_);
            }
            pub inline fn lookupAuthoredNamedEntity(self: *const T, p_entity_: ?*IEntity, psz_input_string_: ?[*:0]const u16, p_token_collection_: ?*ITokenCollection, c_tokens_begin_: u32, pc_tokens_length_: ?*u32, ppsz_value_: ?*?PWSTR) HRESULT {
                return @as(*const ISchemaProvider.VTable, @ptrCast(self.vtable)).LookupAuthoredNamedEntity(@as(*const ISchemaProvider, @ptrCast(self)), p_entity_, psz_input_string_, p_token_collection_, c_tokens_begin_, pc_tokens_length_, ppsz_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITokenCollection_Value = Guid.initString("22d8b4f2-f577-4adb-a335-c2ae88416fab");
pub const IID_ITokenCollection = &IID_ITokenCollection_Value;
pub const ITokenCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NumberOfTokens: *const fn (
            self: *const ITokenCollection,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToken: *const fn (
            self: *const ITokenCollection,
            i: u32,
            p_begin: ?*u32,
            p_length: ?*u32,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn numberOfTokens(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const ITokenCollection.VTable, @ptrCast(self.vtable)).NumberOfTokens(@as(*const ITokenCollection, @ptrCast(self)), p_count_);
            }
            pub inline fn getToken(self: *const T, i_: u32, p_begin_: ?*u32, p_length_: ?*u32, ppsz_: ?*?PWSTR) HRESULT {
                return @as(*const ITokenCollection.VTable, @ptrCast(self.vtable)).GetToken(@as(*const ITokenCollection, @ptrCast(self)), i_, p_begin_, p_length_, ppsz_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NAMED_ENTITY_CERTAINTY = enum(i32) {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
};
pub const NEC_LOW = NAMED_ENTITY_CERTAINTY.LOW;
pub const NEC_MEDIUM = NAMED_ENTITY_CERTAINTY.MEDIUM;
pub const NEC_HIGH = NAMED_ENTITY_CERTAINTY.HIGH;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedEntityCollector_Value = Guid.initString("af2440f6-8afc-47d0-9a7f-396a0acfb43d");
pub const IID_INamedEntityCollector = &IID_INamedEntityCollector_Value;
pub const INamedEntityCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: *const fn (
            self: *const INamedEntityCollector,
            begin_span: u32,
            end_span: u32,
            begin_actual: u32,
            end_actual: u32,
            p_type: ?*IEntity,
            psz_value: ?[*:0]const u16,
            certainty: NAMED_ENTITY_CERTAINTY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn add(self: *const T, begin_span_: u32, end_span_: u32, begin_actual_: u32, end_actual_: u32, p_type_: ?*IEntity, psz_value_: ?[*:0]const u16, certainty_: NAMED_ENTITY_CERTAINTY) HRESULT {
                return @as(*const INamedEntityCollector.VTable, @ptrCast(self.vtable)).Add(@as(*const INamedEntityCollector, @ptrCast(self)), begin_span_, end_span_, begin_actual_, end_actual_, p_type_, psz_value_, certainty_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISchemaLocalizerSupport_Value = Guid.initString("ca3fdca2-bfbe-4eed-90d7-0caef0a1bda1");
pub const IID_ISchemaLocalizerSupport = &IID_ISchemaLocalizerSupport_Value;
pub const ISchemaLocalizerSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Localize: *const fn (
            self: *const ISchemaLocalizerSupport,
            psz_global_string: ?[*:0]const u16,
            ppsz_local_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn localize(self: *const T, psz_global_string_: ?[*:0]const u16, ppsz_local_string_: ?*?PWSTR) HRESULT {
                return @as(*const ISchemaLocalizerSupport.VTable, @ptrCast(self.vtable)).Localize(@as(*const ISchemaLocalizerSupport, @ptrCast(self)), psz_global_string_, ppsz_local_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryParserManager_Value = Guid.initString("a879e3c4-af77-44fb-8f37-ebd1487cf920");
pub const IID_IQueryParserManager = &IID_IQueryParserManager_Value;
pub const IQueryParserManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateLoadedParser: *const fn (
            self: *const IQueryParserManager,
            psz_catalog: ?[*:0]const u16,
            langid_for_keywords: u16,
            riid: ?*const Guid,
            pp_query_parser: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeOptions: *const fn (
            self: *const IQueryParserManager,
            f_understand_n_q_s: BOOL,
            f_auto_wild_card: BOOL,
            p_query_parser: ?*IQueryParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: *const fn (
            self: *const IQueryParserManager,
            option: QUERY_PARSER_MANAGER_OPTION,
            p_option_value: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createLoadedParser(self: *const T, psz_catalog_: ?[*:0]const u16, langid_for_keywords_: u16, riid_: ?*const Guid, pp_query_parser_: ?*?*anyopaque) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).CreateLoadedParser(@as(*const IQueryParserManager, @ptrCast(self)), psz_catalog_, langid_for_keywords_, riid_, pp_query_parser_);
            }
            pub inline fn initializeOptions(self: *const T, f_understand_n_q_s_: BOOL, f_auto_wild_card_: BOOL, p_query_parser_: ?*IQueryParser) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).InitializeOptions(@as(*const IQueryParserManager, @ptrCast(self)), f_understand_n_q_s_, f_auto_wild_card_, p_query_parser_);
            }
            pub inline fn setOption(self: *const T, option_: QUERY_PARSER_MANAGER_OPTION, p_option_value_: ?*const PROPVARIANT) HRESULT {
                return @as(*const IQueryParserManager.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IQueryParserManager, @ptrCast(self)), option_, p_option_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HITRANGE = extern struct {
    iPosition: u32,
    cLength: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor_Value = Guid.initString("0b63e318-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IUrlAccessor = &IID_IUrlAccessor_Value;
pub const IUrlAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRequestParameter: *const fn (
            self: *const IUrlAccessor,
            p_spec: ?*PROPSPEC,
            p_var: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocFormat: *const fn (
            self: *const IUrlAccessor,
            wsz_doc_format: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCLSID: *const fn (
            self: *const IUrlAccessor,
            p_clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: *const fn (
            self: *const IUrlAccessor,
            wsz_host: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirectory: *const fn (
            self: *const IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const IUrlAccessor,
            pll_size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastModified: *const fn (
            self: *const IUrlAccessor,
            pft_last_modified: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: *const fn (
            self: *const IUrlAccessor,
            wsz_file_name: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityDescriptor: *const fn (
            self: *const IUrlAccessor,
            p_s_d: [*:0]u8,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedirectedURL: *const fn (
            self: *const IUrlAccessor,
            wsz_redirected_u_r_l: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityProvider: *const fn (
            self: *const IUrlAccessor,
            p_s_p_clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStream: *const fn (
            self: *const IUrlAccessor,
            pp_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToFilter: *const fn (
            self: *const IUrlAccessor,
            pp_filter: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addRequestParameter(self: *const T, p_spec_: ?*PROPSPEC, p_var_: ?*PROPVARIANT) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).AddRequestParameter(@as(*const IUrlAccessor, @ptrCast(self)), p_spec_, p_var_);
            }
            pub inline fn getDocFormat(self: *const T, wsz_doc_format_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetDocFormat(@as(*const IUrlAccessor, @ptrCast(self)), wsz_doc_format_, dw_size_, pdw_length_);
            }
            pub inline fn getCLSID(self: *const T, p_clsid_: ?*Guid) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetCLSID(@as(*const IUrlAccessor, @ptrCast(self)), p_clsid_);
            }
            pub inline fn getHost(self: *const T, wsz_host_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUrlAccessor, @ptrCast(self)), wsz_host_, dw_size_, pdw_length_);
            }
            pub inline fn isDirectory(self: *const T) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).IsDirectory(@as(*const IUrlAccessor, @ptrCast(self)));
            }
            pub inline fn getSize(self: *const T, pll_size_: ?*u64) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IUrlAccessor, @ptrCast(self)), pll_size_);
            }
            pub inline fn getLastModified(self: *const T, pft_last_modified_: ?*FILETIME) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetLastModified(@as(*const IUrlAccessor, @ptrCast(self)), pft_last_modified_);
            }
            pub inline fn getFileName(self: *const T, wsz_file_name_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IUrlAccessor, @ptrCast(self)), wsz_file_name_, dw_size_, pdw_length_);
            }
            pub inline fn getSecurityDescriptor(self: *const T, p_s_d_: [*:0]u8, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSecurityDescriptor(@as(*const IUrlAccessor, @ptrCast(self)), p_s_d_, dw_size_, pdw_length_);
            }
            pub inline fn getRedirectedURL(self: *const T, wsz_redirected_u_r_l_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetRedirectedURL(@as(*const IUrlAccessor, @ptrCast(self)), wsz_redirected_u_r_l_, dw_size_, pdw_length_);
            }
            pub inline fn getSecurityProvider(self: *const T, p_s_p_clsid_: ?*Guid) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).GetSecurityProvider(@as(*const IUrlAccessor, @ptrCast(self)), p_s_p_clsid_);
            }
            pub inline fn bindToStream(self: *const T, pp_stream_: ?*?*IStream) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).BindToStream(@as(*const IUrlAccessor, @ptrCast(self)), pp_stream_);
            }
            pub inline fn bindToFilter(self: *const T, pp_filter_: ?*?*IFilter) HRESULT {
                return @as(*const IUrlAccessor.VTable, @ptrCast(self.vtable)).BindToFilter(@as(*const IUrlAccessor, @ptrCast(self)), pp_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor2_Value = Guid.initString("c7310734-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IUrlAccessor2 = &IID_IUrlAccessor2_Value;
pub const IUrlAccessor2 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor.VTable,
        GetDisplayUrl: *const fn (
            self: *const IUrlAccessor2,
            wsz_doc_url: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDocument: *const fn (
            self: *const IUrlAccessor2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePage: *const fn (
            self: *const IUrlAccessor2,
            wsz_code_page: [*:0]u16,
            dw_size: u32,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor.MethodMixin(T);
            pub inline fn getDisplayUrl(self: *const T, wsz_doc_url_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).GetDisplayUrl(@as(*const IUrlAccessor2, @ptrCast(self)), wsz_doc_url_, dw_size_, pdw_length_);
            }
            pub inline fn isDocument(self: *const T) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).IsDocument(@as(*const IUrlAccessor2, @ptrCast(self)));
            }
            pub inline fn getCodePage(self: *const T, wsz_code_page_: [*:0]u16, dw_size_: u32, pdw_length_: ?*u32) HRESULT {
                return @as(*const IUrlAccessor2.VTable, @ptrCast(self.vtable)).GetCodePage(@as(*const IUrlAccessor2, @ptrCast(self)), wsz_code_page_, dw_size_, pdw_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUrlAccessor3_Value = Guid.initString("6fbc7005-0455-4874-b8ff-7439450241a3");
pub const IID_IUrlAccessor3 = &IID_IUrlAccessor3_Value;
pub const IUrlAccessor3 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor2.VTable,
        GetImpersonationSidBlobs: *const fn (
            self: *const IUrlAccessor3,
            pcwsz_u_r_l: ?[*:0]const u16,
            pc_sid_count: ?*u32,
            pp_sid_blobs: ?*?*BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor2.MethodMixin(T);
            pub inline fn getImpersonationSidBlobs(self: *const T, pcwsz_u_r_l_: ?[*:0]const u16, pc_sid_count_: ?*u32, pp_sid_blobs_: ?*?*BLOB) HRESULT {
                return @as(*const IUrlAccessor3.VTable, @ptrCast(self.vtable)).GetImpersonationSidBlobs(@as(*const IUrlAccessor3, @ptrCast(self)), pcwsz_u_r_l_, pc_sid_count_, pp_sid_blobs_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUrlAccessor4_Value = Guid.initString("5cc51041-c8d2-41d7-bca3-9e9e286297dc");
pub const IID_IUrlAccessor4 = &IID_IUrlAccessor4_Value;
pub const IUrlAccessor4 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor3.VTable,
        ShouldIndexItemContent: *const fn (
            self: *const IUrlAccessor4,
            pf_index_content: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShouldIndexProperty: *const fn (
            self: *const IUrlAccessor4,
            key: ?*const PROPERTYKEY,
            pf_index_property: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUrlAccessor3.MethodMixin(T);
            pub inline fn shouldIndexItemContent(self: *const T, pf_index_content_: ?*BOOL) HRESULT {
                return @as(*const IUrlAccessor4.VTable, @ptrCast(self.vtable)).ShouldIndexItemContent(@as(*const IUrlAccessor4, @ptrCast(self)), pf_index_content_);
            }
            pub inline fn shouldIndexProperty(self: *const T, key_: ?*const PROPERTYKEY, pf_index_property_: ?*BOOL) HRESULT {
                return @as(*const IUrlAccessor4.VTable, @ptrCast(self.vtable)).ShouldIndexProperty(@as(*const IUrlAccessor4, @ptrCast(self)), key_, pf_index_property_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IOpLockStatus_Value = Guid.initString("c731065d-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_IOpLockStatus = &IID_IOpLockStatus_Value;
pub const IOpLockStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsOplockValid: *const fn (
            self: *const IOpLockStatus,
            pf_is_oplock_valid: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOplockBroken: *const fn (
            self: *const IOpLockStatus,
            pf_is_oplock_broken: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOplockEventHandle: *const fn (
            self: *const IOpLockStatus,
            ph_oplock_ev: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isOplockValid(self: *const T, pf_is_oplock_valid_: ?*BOOL) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).IsOplockValid(@as(*const IOpLockStatus, @ptrCast(self)), pf_is_oplock_valid_);
            }
            pub inline fn isOplockBroken(self: *const T, pf_is_oplock_broken_: ?*BOOL) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).IsOplockBroken(@as(*const IOpLockStatus, @ptrCast(self)), pf_is_oplock_broken_);
            }
            pub inline fn getOplockEventHandle(self: *const T, ph_oplock_ev_: ?*?HANDLE) HRESULT {
                return @as(*const IOpLockStatus.VTable, @ptrCast(self.vtable)).GetOplockEventHandle(@as(*const IOpLockStatus, @ptrCast(self)), ph_oplock_ev_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocolThreadContext_Value = Guid.initString("c73106e1-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocolThreadContext = &IID_ISearchProtocolThreadContext_Value;
pub const ISearchProtocolThreadContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadInit: *const fn (
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadShutdown: *const fn (
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadIdle: *const fn (
            self: *const ISearchProtocolThreadContext,
            dw_time_elasped_since_last_call_in_m_s: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn threadInit(self: *const T) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadInit(@as(*const ISearchProtocolThreadContext, @ptrCast(self)));
            }
            pub inline fn threadShutdown(self: *const T) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadShutdown(@as(*const ISearchProtocolThreadContext, @ptrCast(self)));
            }
            pub inline fn threadIdle(self: *const T, dw_time_elasped_since_last_call_in_m_s_: u32) HRESULT {
                return @as(*const ISearchProtocolThreadContext.VTable, @ptrCast(self.vtable)).ThreadIdle(@as(*const ISearchProtocolThreadContext, @ptrCast(self)), dw_time_elasped_since_last_call_in_m_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TIMEOUT_INFO = extern struct {
    dwSize: u32,
    dwConnectTimeout: u32,
    dwDataTimeout: u32,
};

pub const PROXY_ACCESS = enum(i32) {
    PRECONFIG = 0,
    DIRECT = 1,
    PROXY = 2,
};
pub const PROXY_ACCESS_PRECONFIG = PROXY_ACCESS.PRECONFIG;
pub const PROXY_ACCESS_DIRECT = PROXY_ACCESS.DIRECT;
pub const PROXY_ACCESS_PROXY = PROXY_ACCESS.PROXY;

pub const PROXY_INFO = extern struct {
    dwSize: u32,
    pcwszUserAgent: ?[*:0]const u16,
    paUseProxy: PROXY_ACCESS,
    fLocalBypass: BOOL,
    dwPortNumber: u32,
    pcwszProxyName: ?[*:0]const u16,
    pcwszBypassList: ?[*:0]const u16,
};

pub const AUTH_TYPE = enum(i32) {
    ANONYMOUS = 0,
    NTLM = 1,
    BASIC = 2,
};
pub const eAUTH_TYPE_ANONYMOUS = AUTH_TYPE.ANONYMOUS;
pub const eAUTH_TYPE_NTLM = AUTH_TYPE.NTLM;
pub const eAUTH_TYPE_BASIC = AUTH_TYPE.BASIC;

pub const AUTHENTICATION_INFO = extern struct {
    dwSize: u32,
    atAuthenticationType: AUTH_TYPE,
    pcwszUser: ?[*:0]const u16,
    pcwszPassword: ?[*:0]const u16,
};

pub const INCREMENTAL_ACCESS_INFO = extern struct {
    dwSize: u32,
    ftLastModifiedTime: FILETIME,
};

pub const ITEM_INFO = extern struct {
    dwSize: u32,
    pcwszFromEMail: ?[*:0]const u16,
    pcwszApplicationName: ?[*:0]const u16,
    pcwszCatalogName: ?[*:0]const u16,
    pcwszContentClass: ?[*:0]const u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol_Value = Guid.initString("c73106ba-ac80-11d1-8df3-00c04fb6ef4f");
pub const IID_ISearchProtocol = &IID_ISearchProtocol_Value;
pub const ISearchProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const ISearchProtocol,
            p_timeout_info: ?*TIMEOUT_INFO,
            p_protocol_handler_site: ?*IProtocolHandlerSite,
            p_proxy_info: ?*PROXY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: *const fn (
            self: *const ISearchProtocol,
            pcwsz_u_r_l: ?[*:0]const u16,
            p_authentication_info: ?*AUTHENTICATION_INFO,
            p_incremental_access_info: ?*INCREMENTAL_ACCESS_INFO,
            p_item_info: ?*ITEM_INFO,
            pp_accessor: ?*?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseAccessor: *const fn (
            self: *const ISearchProtocol,
            p_accessor: ?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutDown: *const fn (
            self: *const ISearchProtocol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, p_timeout_info_: ?*TIMEOUT_INFO, p_protocol_handler_site_: ?*IProtocolHandlerSite, p_proxy_info_: ?*PROXY_INFO) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).Init(@as(*const ISearchProtocol, @ptrCast(self)), p_timeout_info_, p_protocol_handler_site_, p_proxy_info_);
            }
            pub inline fn createAccessor(self: *const T, pcwsz_u_r_l_: ?[*:0]const u16, p_authentication_info_: ?*AUTHENTICATION_INFO, p_incremental_access_info_: ?*INCREMENTAL_ACCESS_INFO, p_item_info_: ?*ITEM_INFO, pp_accessor_: ?*?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).CreateAccessor(@as(*const ISearchProtocol, @ptrCast(self)), pcwsz_u_r_l_, p_authentication_info_, p_incremental_access_info_, p_item_info_, pp_accessor_);
            }
            pub inline fn closeAccessor(self: *const T, p_accessor_: ?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).CloseAccessor(@as(*const ISearchProtocol, @ptrCast(self)), p_accessor_);
            }
            pub inline fn shutDown(self: *const T) HRESULT {
                return @as(*const ISearchProtocol.VTable, @ptrCast(self.vtable)).ShutDown(@as(*const ISearchProtocol, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchProtocol2_Value = Guid.initString("7789f0b2-b5b2-4722-8b65-5dbd150697a9");
pub const IID_ISearchProtocol2 = &IID_ISearchProtocol2_Value;
pub const ISearchProtocol2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchProtocol.VTable,
        CreateAccessorEx: *const fn (
            self: *const ISearchProtocol2,
            pcwsz_u_r_l: ?[*:0]const u16,
            p_authentication_info: ?*AUTHENTICATION_INFO,
            p_incremental_access_info: ?*INCREMENTAL_ACCESS_INFO,
            p_item_info: ?*ITEM_INFO,
            p_user_data: ?*const BLOB,
            pp_accessor: ?*?*IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchProtocol.MethodMixin(T);
            pub inline fn createAccessorEx(self: *const T, pcwsz_u_r_l_: ?[*:0]const u16, p_authentication_info_: ?*AUTHENTICATION_INFO, p_incremental_access_info_: ?*INCREMENTAL_ACCESS_INFO, p_item_info_: ?*ITEM_INFO, p_user_data_: ?*const BLOB, pp_accessor_: ?*?*IUrlAccessor) HRESULT {
                return @as(*const ISearchProtocol2.VTable, @ptrCast(self.vtable)).CreateAccessorEx(@as(*const ISearchProtocol2, @ptrCast(self)), pcwsz_u_r_l_, p_authentication_info_, p_incremental_access_info_, p_item_info_, p_user_data_, pp_accessor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IProtocolHandlerSite_Value = Guid.initString("0b63e385-9ccc-11d0-bcdb-00805fccce04");
pub const IID_IProtocolHandlerSite = &IID_IProtocolHandlerSite_Value;
pub const IProtocolHandlerSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: *const fn (
            self: *const IProtocolHandlerSite,
            pclsid_obj: ?*Guid,
            pcwsz_content_type: ?[*:0]const u16,
            pcwsz_extension: ?[*:0]const u16,
            pp_filter: ?*?*IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFilter(self: *const T, pclsid_obj_: ?*Guid, pcwsz_content_type_: ?[*:0]const u16, pcwsz_extension_: ?[*:0]const u16, pp_filter_: ?*?*IFilter) HRESULT {
                return @as(*const IProtocolHandlerSite.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IProtocolHandlerSite, @ptrCast(self)), pclsid_obj_, pcwsz_content_type_, pcwsz_extension_, pp_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchRoot_Value = Guid.initString("04c18ccf-1f57-4cbd-88cc-3900f5195ce3");
pub const IID_ISearchRoot = &IID_ISearchRoot_Value;
pub const ISearchRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Schedule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            psz_task_arg: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Schedule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            ppsz_task_arg: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            ppsz_u_r_l: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHierarchical: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            f_is_hierarchical: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHierarchical: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pf_is_hierarchical: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProvidesNotifications: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            f_provides_notifications: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProvidesNotifications: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pf_provides_notifications: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseNotificationsOnly: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            f_use_notifications_only: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseNotificationsOnly: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pf_use_notifications_only: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumerationDepth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            dw_depth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumerationDepth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pdw_depth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HostDepth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            dw_depth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostDepth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pdw_depth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FollowDirectories: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            f_follow_directories: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowDirectories: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            pf_follow_directories: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AuthenticationType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            auth_type: AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthenticationType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            p_auth_type: ?*AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_User: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            psz_user: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_User: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            ppsz_user: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            psz_password: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Password: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchRoot,
            ppsz_password: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putSchedule(self: *const T, psz_task_arg_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_Schedule(@as(*const ISearchRoot, @ptrCast(self)), psz_task_arg_);
            }
            pub inline fn getSchedule(self: *const T, ppsz_task_arg_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_Schedule(@as(*const ISearchRoot, @ptrCast(self)), ppsz_task_arg_);
            }
            pub inline fn putRootURL(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_RootURL(@as(*const ISearchRoot, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn getRootURL(self: *const T, ppsz_u_r_l_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_RootURL(@as(*const ISearchRoot, @ptrCast(self)), ppsz_u_r_l_);
            }
            pub inline fn putIsHierarchical(self: *const T, f_is_hierarchical_: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_IsHierarchical(@as(*const ISearchRoot, @ptrCast(self)), f_is_hierarchical_);
            }
            pub inline fn getIsHierarchical(self: *const T, pf_is_hierarchical_: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_IsHierarchical(@as(*const ISearchRoot, @ptrCast(self)), pf_is_hierarchical_);
            }
            pub inline fn putProvidesNotifications(self: *const T, f_provides_notifications_: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_ProvidesNotifications(@as(*const ISearchRoot, @ptrCast(self)), f_provides_notifications_);
            }
            pub inline fn getProvidesNotifications(self: *const T, pf_provides_notifications_: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_ProvidesNotifications(@as(*const ISearchRoot, @ptrCast(self)), pf_provides_notifications_);
            }
            pub inline fn putUseNotificationsOnly(self: *const T, f_use_notifications_only_: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_UseNotificationsOnly(@as(*const ISearchRoot, @ptrCast(self)), f_use_notifications_only_);
            }
            pub inline fn getUseNotificationsOnly(self: *const T, pf_use_notifications_only_: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_UseNotificationsOnly(@as(*const ISearchRoot, @ptrCast(self)), pf_use_notifications_only_);
            }
            pub inline fn putEnumerationDepth(self: *const T, dw_depth_: u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_EnumerationDepth(@as(*const ISearchRoot, @ptrCast(self)), dw_depth_);
            }
            pub inline fn getEnumerationDepth(self: *const T, pdw_depth_: ?*u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_EnumerationDepth(@as(*const ISearchRoot, @ptrCast(self)), pdw_depth_);
            }
            pub inline fn putHostDepth(self: *const T, dw_depth_: u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_HostDepth(@as(*const ISearchRoot, @ptrCast(self)), dw_depth_);
            }
            pub inline fn getHostDepth(self: *const T, pdw_depth_: ?*u32) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_HostDepth(@as(*const ISearchRoot, @ptrCast(self)), pdw_depth_);
            }
            pub inline fn putFollowDirectories(self: *const T, f_follow_directories_: BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_FollowDirectories(@as(*const ISearchRoot, @ptrCast(self)), f_follow_directories_);
            }
            pub inline fn getFollowDirectories(self: *const T, pf_follow_directories_: ?*BOOL) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_FollowDirectories(@as(*const ISearchRoot, @ptrCast(self)), pf_follow_directories_);
            }
            pub inline fn putAuthenticationType(self: *const T, auth_type_: AUTH_TYPE) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_AuthenticationType(@as(*const ISearchRoot, @ptrCast(self)), auth_type_);
            }
            pub inline fn getAuthenticationType(self: *const T, p_auth_type_: ?*AUTH_TYPE) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_AuthenticationType(@as(*const ISearchRoot, @ptrCast(self)), p_auth_type_);
            }
            pub inline fn putUser(self: *const T, psz_user_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_User(@as(*const ISearchRoot, @ptrCast(self)), psz_user_);
            }
            pub inline fn getUser(self: *const T, ppsz_user_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_User(@as(*const ISearchRoot, @ptrCast(self)), ppsz_user_);
            }
            pub inline fn putPassword(self: *const T, psz_password_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).put_Password(@as(*const ISearchRoot, @ptrCast(self)), psz_password_);
            }
            pub inline fn getPassword(self: *const T, ppsz_password_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchRoot.VTable, @ptrCast(self.vtable)).get_Password(@as(*const ISearchRoot, @ptrCast(self)), ppsz_password_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchRoots_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef52");
pub const IID_IEnumSearchRoots = &IID_IEnumSearchRoots_Value;
pub const IEnumSearchRoots = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSearchRoots,
            celt: u32,
            rgelt: [*]?*ISearchRoot,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSearchRoots,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSearchRoots,
            ppenum: ?*?*IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*ISearchRoot, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSearchRoots, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSearchRoots, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSearchRoots, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSearchRoots) HRESULT {
                return @as(*const IEnumSearchRoots.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSearchRoots, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FOLLOW_FLAGS = enum(i32) {
    INDEXCOMPLEXURLS = 1,
    SUPPRESSINDEXING = 2,
};
pub const FF_INDEXCOMPLEXURLS = FOLLOW_FLAGS.INDEXCOMPLEXURLS;
pub const FF_SUPPRESSINDEXING = FOLLOW_FLAGS.SUPPRESSINDEXING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchScopeRule_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef53");
pub const IID_ISearchScopeRule = &IID_ISearchScopeRule_Value;
pub const ISearchScopeRule = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatternOrURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchScopeRule,
            ppsz_pattern_or_u_r_l: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsIncluded: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchScopeRule,
            pf_is_included: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchScopeRule,
            pf_is_default: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FollowFlags: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchScopeRule,
            p_follow_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPatternOrURL(self: *const T, ppsz_pattern_or_u_r_l_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_PatternOrURL(@as(*const ISearchScopeRule, @ptrCast(self)), ppsz_pattern_or_u_r_l_);
            }
            pub inline fn getIsIncluded(self: *const T, pf_is_included_: ?*BOOL) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_IsIncluded(@as(*const ISearchScopeRule, @ptrCast(self)), pf_is_included_);
            }
            pub inline fn getIsDefault(self: *const T, pf_is_default_: ?*BOOL) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_IsDefault(@as(*const ISearchScopeRule, @ptrCast(self)), pf_is_default_);
            }
            pub inline fn getFollowFlags(self: *const T, p_follow_flags_: ?*u32) HRESULT {
                return @as(*const ISearchScopeRule.VTable, @ptrCast(self.vtable)).get_FollowFlags(@as(*const ISearchScopeRule, @ptrCast(self)), p_follow_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumSearchScopeRules_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef54");
pub const IID_IEnumSearchScopeRules = &IID_IEnumSearchScopeRules_Value;
pub const IEnumSearchScopeRules = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSearchScopeRules,
            celt: u32,
            pprgelt: [*]?*ISearchScopeRule,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSearchScopeRules,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSearchScopeRules,
            ppenum: ?*?*IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, pprgelt_: [*]?*ISearchScopeRule, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSearchScopeRules, @ptrCast(self)), celt_, pprgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSearchScopeRules, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSearchScopeRules, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSearchScopeRules) HRESULT {
                return @as(*const IEnumSearchScopeRules.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSearchScopeRules, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CLUSION_REASON = enum(i32) {
    UNKNOWNSCOPE = 0,
    DEFAULT = 1,
    USER = 2,
    GROUPPOLICY = 3,
};
pub const CLUSIONREASON_UNKNOWNSCOPE = CLUSION_REASON.UNKNOWNSCOPE;
pub const CLUSIONREASON_DEFAULT = CLUSION_REASON.DEFAULT;
pub const CLUSIONREASON_USER = CLUSION_REASON.USER;
pub const CLUSIONREASON_GROUPPOLICY = CLUSION_REASON.GROUPPOLICY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCrawlScopeManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef55");
pub const IID_ISearchCrawlScopeManager = &IID_ISearchCrawlScopeManager_Value;
pub const ISearchCrawlScopeManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDefaultScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            f_include: BOOL,
            f_follow_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRoot: *const fn (
            self: *const ISearchCrawlScopeManager,
            p_search_root: ?*ISearchRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveRoot: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateRoots: *const fn (
            self: *const ISearchCrawlScopeManager,
            pp_search_roots: ?*?*IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddHierarchicalScope: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            f_include: BOOL,
            f_default: BOOL,
            f_override_children: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            f_include: BOOL,
            f_override_children: BOOL,
            f_follow_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_rule: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateScopeRules: *const fn (
            self: *const ISearchCrawlScopeManager,
            pp_search_scope_rules: ?*?*IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasParentScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            pf_has_parent_rule: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasChildScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            pf_has_child_rule: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScope: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            pf_is_included: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScopeEx: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            pf_is_included: ?*BOOL,
            p_reason: ?*CLUSION_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToDefaultScopes: *const fn (
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAll: *const fn (
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentScopeVersionId: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
            pl_scope_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDefaultScopeRule: *const fn (
            self: *const ISearchCrawlScopeManager,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addDefaultScopeRule(self: *const T, psz_u_r_l_: ?[*:0]const u16, f_include_: BOOL, f_follow_flags_: u32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddDefaultScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, f_include_, f_follow_flags_);
            }
            pub inline fn addRoot(self: *const T, p_search_root_: ?*ISearchRoot) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddRoot(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), p_search_root_);
            }
            pub inline fn removeRoot(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveRoot(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn enumerateRoots(self: *const T, pp_search_roots_: ?*?*IEnumSearchRoots) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).EnumerateRoots(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pp_search_roots_);
            }
            pub inline fn addHierarchicalScope(self: *const T, psz_u_r_l_: ?[*:0]const u16, f_include_: BOOL, f_default_: BOOL, f_override_children_: BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddHierarchicalScope(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, f_include_, f_default_, f_override_children_);
            }
            pub inline fn addUserScopeRule(self: *const T, psz_u_r_l_: ?[*:0]const u16, f_include_: BOOL, f_override_children_: BOOL, f_follow_flags_: u32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).AddUserScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, f_include_, f_override_children_, f_follow_flags_);
            }
            pub inline fn removeScopeRule(self: *const T, psz_rule_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_rule_);
            }
            pub inline fn enumerateScopeRules(self: *const T, pp_search_scope_rules_: ?*?*IEnumSearchScopeRules) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).EnumerateScopeRules(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), pp_search_scope_rules_);
            }
            pub inline fn hasParentScopeRule(self: *const T, psz_u_r_l_: ?[*:0]const u16, pf_has_parent_rule_: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).HasParentScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, pf_has_parent_rule_);
            }
            pub inline fn hasChildScopeRule(self: *const T, psz_u_r_l_: ?[*:0]const u16, pf_has_child_rule_: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).HasChildScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, pf_has_child_rule_);
            }
            pub inline fn includedInCrawlScope(self: *const T, psz_u_r_l_: ?[*:0]const u16, pf_is_included_: ?*BOOL) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).IncludedInCrawlScope(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, pf_is_included_);
            }
            pub inline fn includedInCrawlScopeEx(self: *const T, psz_u_r_l_: ?[*:0]const u16, pf_is_included_: ?*BOOL, p_reason_: ?*CLUSION_REASON) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).IncludedInCrawlScopeEx(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, pf_is_included_, p_reason_);
            }
            pub inline fn revertToDefaultScopes(self: *const T) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RevertToDefaultScopes(@as(*const ISearchCrawlScopeManager, @ptrCast(self)));
            }
            pub inline fn saveAll(self: *const T) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).SaveAll(@as(*const ISearchCrawlScopeManager, @ptrCast(self)));
            }
            pub inline fn getParentScopeVersionId(self: *const T, psz_u_r_l_: ?[*:0]const u16, pl_scope_id_: ?*i32) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).GetParentScopeVersionId(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_, pl_scope_id_);
            }
            pub inline fn removeDefaultScopeRule(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCrawlScopeManager.VTable, @ptrCast(self.vtable)).RemoveDefaultScopeRule(@as(*const ISearchCrawlScopeManager, @ptrCast(self)), psz_u_r_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISearchCrawlScopeManager2_Value = Guid.initString("6292f7ad-4e19-4717-a534-8fc22bcd5ccd");
pub const IID_ISearchCrawlScopeManager2 = &IID_ISearchCrawlScopeManager2_Value;
pub const ISearchCrawlScopeManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCrawlScopeManager.VTable,
        GetVersion: *const fn (
            self: *const ISearchCrawlScopeManager2,
            pl_version: ?*?*i32,
            ph_file_mapping: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchCrawlScopeManager.MethodMixin(T);
            pub inline fn getVersion(self: *const T, pl_version_: ?*?*i32, ph_file_mapping_: ?*?HANDLE) HRESULT {
                return @as(*const ISearchCrawlScopeManager2.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ISearchCrawlScopeManager2, @ptrCast(self)), pl_version_, ph_file_mapping_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_KIND_OF_CHANGE = enum(i32) {
    ADD = 0,
    DELETE = 1,
    MODIFY = 2,
    MOVE_RENAME = 3,
    SEMANTICS_DIRECTORY = 262144,
    SEMANTICS_SHALLOW = 524288,
    SEMANTICS_UPDATE_SECURITY = 4194304,
};
pub const SEARCH_CHANGE_ADD = SEARCH_KIND_OF_CHANGE.ADD;
pub const SEARCH_CHANGE_DELETE = SEARCH_KIND_OF_CHANGE.DELETE;
pub const SEARCH_CHANGE_MODIFY = SEARCH_KIND_OF_CHANGE.MODIFY;
pub const SEARCH_CHANGE_MOVE_RENAME = SEARCH_KIND_OF_CHANGE.MOVE_RENAME;
pub const SEARCH_CHANGE_SEMANTICS_DIRECTORY = SEARCH_KIND_OF_CHANGE.SEMANTICS_DIRECTORY;
pub const SEARCH_CHANGE_SEMANTICS_SHALLOW = SEARCH_KIND_OF_CHANGE.SEMANTICS_SHALLOW;
pub const SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = SEARCH_KIND_OF_CHANGE.SEMANTICS_UPDATE_SECURITY;

pub const SEARCH_NOTIFICATION_PRIORITY = enum(i32) {
    NORMAL_PRIORITY = 0,
    HIGH_PRIORITY = 1,
};
pub const SEARCH_NORMAL_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.NORMAL_PRIORITY;
pub const SEARCH_HIGH_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.HIGH_PRIORITY;

pub const SEARCH_ITEM_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
    pUserData: ?*BLOB,
    lpwszURL: ?PWSTR,
    lpwszOldURL: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchItemsChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef58");
pub const IID_ISearchItemsChangedSink = &IID_ISearchItemsChangedSink_Value;
pub const ISearchItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: *const fn (
            self: *const ISearchItemsChangedSink,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: *const fn (
            self: *const ISearchItemsChangedSink,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: *const fn (
            self: *const ISearchItemsChangedSink,
            dw_number_of_changes: u32,
            rg_data_change_entries: [*]SEARCH_ITEM_CHANGE,
            rgdw_doc_ids: [*]u32,
            rghr_completion_codes: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startedMonitoringScope(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).StartedMonitoringScope(@as(*const ISearchItemsChangedSink, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn stoppedMonitoringScope(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).StoppedMonitoringScope(@as(*const ISearchItemsChangedSink, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn onItemsChanged(self: *const T, dw_number_of_changes_: u32, rg_data_change_entries_: [*]SEARCH_ITEM_CHANGE, rgdw_doc_ids_: [*]u32, rghr_completion_codes_: [*]HRESULT) HRESULT {
                return @as(*const ISearchItemsChangedSink.VTable, @ptrCast(self.vtable)).OnItemsChanged(@as(*const ISearchItemsChangedSink, @ptrCast(self)), dw_number_of_changes_, rg_data_change_entries_, rgdw_doc_ids_, rghr_completion_codes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_ITEM_PERSISTENT_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    URL: ?PWSTR,
    OldURL: ?PWSTR,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchPersistentItemsChangedSink_Value = Guid.initString("a2ffdf9b-4758-4f84-b729-df81a1a0612f");
pub const IID_ISearchPersistentItemsChangedSink = &IID_ISearchPersistentItemsChangedSink_Value;
pub const ISearchPersistentItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: *const fn (
            self: *const ISearchPersistentItemsChangedSink,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: *const fn (
            self: *const ISearchPersistentItemsChangedSink,
            psz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: *const fn (
            self: *const ISearchPersistentItemsChangedSink,
            dw_number_of_changes: u32,
            data_change_entries: [*]SEARCH_ITEM_PERSISTENT_CHANGE,
            hr_completion_codes: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startedMonitoringScope(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).StartedMonitoringScope(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn stoppedMonitoringScope(self: *const T, psz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).StoppedMonitoringScope(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), psz_u_r_l_);
            }
            pub inline fn onItemsChanged(self: *const T, dw_number_of_changes_: u32, data_change_entries_: [*]SEARCH_ITEM_PERSISTENT_CHANGE, hr_completion_codes_: [*]HRESULT) HRESULT {
                return @as(*const ISearchPersistentItemsChangedSink.VTable, @ptrCast(self.vtable)).OnItemsChanged(@as(*const ISearchPersistentItemsChangedSink, @ptrCast(self)), dw_number_of_changes_, data_change_entries_, hr_completion_codes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchViewChangedSink_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef65");
pub const IID_ISearchViewChangedSink = &IID_ISearchViewChangedSink_Value;
pub const ISearchViewChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: *const fn (
            self: *const ISearchViewChangedSink,
            pdw_doc_i_d: ?*i32,
            p_change: ?*SEARCH_ITEM_CHANGE,
            pf_in_view: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onChange(self: *const T, pdw_doc_i_d_: ?*i32, p_change_: ?*SEARCH_ITEM_CHANGE, pf_in_view_: ?*BOOL) HRESULT {
                return @as(*const ISearchViewChangedSink.VTable, @ptrCast(self.vtable)).OnChange(@as(*const ISearchViewChangedSink, @ptrCast(self)), pdw_doc_i_d_, p_change_, pf_in_view_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_INDEXING_PHASE = enum(i32) {
    GATHERER = 0,
    QUERYABLE = 1,
    PERSISTED = 2,
};
pub const SEARCH_INDEXING_PHASE_GATHERER = SEARCH_INDEXING_PHASE.GATHERER;
pub const SEARCH_INDEXING_PHASE_QUERYABLE = SEARCH_INDEXING_PHASE.QUERYABLE;
pub const SEARCH_INDEXING_PHASE_PERSISTED = SEARCH_INDEXING_PHASE.PERSISTED;

pub const SEARCH_ITEM_INDEXING_STATUS = extern struct {
    dwDocID: u32,
    hrIndexingStatus: HRESULT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchNotifyInlineSite_Value = Guid.initString("b5702e61-e75c-4b64-82a1-6cb4f832fccf");
pub const IID_ISearchNotifyInlineSite = &IID_ISearchNotifyInlineSite_Value;
pub const ISearchNotifyInlineSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemIndexedStatusChange: *const fn (
            self: *const ISearchNotifyInlineSite,
            sip_status: SEARCH_INDEXING_PHASE,
            dw_num_entries: u32,
            rg_item_status_entries: [*]SEARCH_ITEM_INDEXING_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCatalogStatusChange: *const fn (
            self: *const ISearchNotifyInlineSite,
            guid_catalog_reset_signature: ?*const Guid,
            guid_check_point_signature: ?*const Guid,
            dw_last_check_point_number: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onItemIndexedStatusChange(self: *const T, sip_status_: SEARCH_INDEXING_PHASE, dw_num_entries_: u32, rg_item_status_entries_: [*]SEARCH_ITEM_INDEXING_STATUS) HRESULT {
                return @as(*const ISearchNotifyInlineSite.VTable, @ptrCast(self.vtable)).OnItemIndexedStatusChange(@as(*const ISearchNotifyInlineSite, @ptrCast(self)), sip_status_, dw_num_entries_, rg_item_status_entries_);
            }
            pub inline fn onCatalogStatusChange(self: *const T, guid_catalog_reset_signature_: ?*const Guid, guid_check_point_signature_: ?*const Guid, dw_last_check_point_number_: u32) HRESULT {
                return @as(*const ISearchNotifyInlineSite.VTable, @ptrCast(self.vtable)).OnCatalogStatusChange(@as(*const ISearchNotifyInlineSite, @ptrCast(self)), guid_catalog_reset_signature_, guid_check_point_signature_, dw_last_check_point_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CatalogStatus = enum(i32) {
    IDLE = 0,
    PAUSED = 1,
    RECOVERING = 2,
    FULL_CRAWL = 3,
    INCREMENTAL_CRAWL = 4,
    PROCESSING_NOTIFICATIONS = 5,
    SHUTTING_DOWN = 6,
};
pub const CATALOG_STATUS_IDLE = CatalogStatus.IDLE;
pub const CATALOG_STATUS_PAUSED = CatalogStatus.PAUSED;
pub const CATALOG_STATUS_RECOVERING = CatalogStatus.RECOVERING;
pub const CATALOG_STATUS_FULL_CRAWL = CatalogStatus.FULL_CRAWL;
pub const CATALOG_STATUS_INCREMENTAL_CRAWL = CatalogStatus.INCREMENTAL_CRAWL;
pub const CATALOG_STATUS_PROCESSING_NOTIFICATIONS = CatalogStatus.PROCESSING_NOTIFICATIONS;
pub const CATALOG_STATUS_SHUTTING_DOWN = CatalogStatus.SHUTTING_DOWN;

pub const CatalogPausedReason = enum(i32) {
    NONE = 0,
    HIGH_IO = 1,
    HIGH_CPU = 2,
    HIGH_NTF_RATE = 3,
    LOW_BATTERY = 4,
    LOW_MEMORY = 5,
    LOW_DISK = 6,
    DELAYED_RECOVERY = 7,
    USER_ACTIVE = 8,
    EXTERNAL = 9,
    UPGRADING = 10,
};
pub const CATALOG_PAUSED_REASON_NONE = CatalogPausedReason.NONE;
pub const CATALOG_PAUSED_REASON_HIGH_IO = CatalogPausedReason.HIGH_IO;
pub const CATALOG_PAUSED_REASON_HIGH_CPU = CatalogPausedReason.HIGH_CPU;
pub const CATALOG_PAUSED_REASON_HIGH_NTF_RATE = CatalogPausedReason.HIGH_NTF_RATE;
pub const CATALOG_PAUSED_REASON_LOW_BATTERY = CatalogPausedReason.LOW_BATTERY;
pub const CATALOG_PAUSED_REASON_LOW_MEMORY = CatalogPausedReason.LOW_MEMORY;
pub const CATALOG_PAUSED_REASON_LOW_DISK = CatalogPausedReason.LOW_DISK;
pub const CATALOG_PAUSED_REASON_DELAYED_RECOVERY = CatalogPausedReason.DELAYED_RECOVERY;
pub const CATALOG_PAUSED_REASON_USER_ACTIVE = CatalogPausedReason.USER_ACTIVE;
pub const CATALOG_PAUSED_REASON_EXTERNAL = CatalogPausedReason.EXTERNAL;
pub const CATALOG_PAUSED_REASON_UPGRADING = CatalogPausedReason.UPGRADING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef50");
pub const IID_ISearchCatalogManager = &IID_ISearchCatalogManager_Value;
pub const ISearchCatalogManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            psz_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: *const fn (
            self: *const ISearchCatalogManager,
            psz_name: ?[*:0]const u16,
            pp_value: ?*?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: *const fn (
            self: *const ISearchCatalogManager,
            psz_name: ?[*:0]const u16,
            p_value: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalogStatus: *const fn (
            self: *const ISearchCatalogManager,
            p_status: ?*CatalogStatus,
            p_paused_reason: ?*CatalogPausedReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reindex: *const fn (
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexMatchingURLs: *const fn (
            self: *const ISearchCatalogManager,
            psz_pattern: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSearchRoot: *const fn (
            self: *const ISearchCatalogManager,
            psz_root_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            dw_connect_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            pdw_connect_timeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            dw_data_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            pdw_data_timeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItems: *const fn (
            self: *const ISearchCatalogManager,
            pl_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItemsToIndex: *const fn (
            self: *const ISearchCatalogManager,
            pl_incremental_count: ?*i32,
            pl_notification_queue: ?*i32,
            pl_high_priority_queue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        URLBeingIndexed: *const fn (
            self: *const ISearchCatalogManager,
            psz_url: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLIndexingState: *const fn (
            self: *const ISearchCatalogManager,
            psz_u_r_l: ?[*:0]const u16,
            pdw_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPersistentItemsChangedSink: *const fn (
            self: *const ISearchCatalogManager,
            pp_i_search_persistent_items_changed_sink: ?*?*ISearchPersistentItemsChangedSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterViewForNotification: *const fn (
            self: *const ISearchCatalogManager,
            psz_view: ?[*:0]const u16,
            p_view_changed_sink: ?*ISearchViewChangedSink,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsChangedSink: *const fn (
            self: *const ISearchCatalogManager,
            p_i_search_notify_inline_site: ?*ISearchNotifyInlineSite,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
            p_g_u_i_d_catalog_reset_signature: ?*Guid,
            p_g_u_i_d_check_point_signature: ?*Guid,
            pdw_last_check_point_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterViewForNotification: *const fn (
            self: *const ISearchCatalogManager,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtensionClusion: *const fn (
            self: *const ISearchCatalogManager,
            psz_extension: ?[*:0]const u16,
            f_exclude: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExcludedExtensions: *const fn (
            self: *const ISearchCatalogManager,
            pp_extensions: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQueryHelper: *const fn (
            self: *const ISearchCatalogManager,
            pp_search_query_helper: ?*?*ISearchQueryHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiacriticSensitivity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            f_diacritic_sensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiacriticSensitivity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchCatalogManager,
            pf_diacritic_sensitive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCrawlScopeManager: *const fn (
            self: *const ISearchCatalogManager,
            pp_crawl_scope_manager: ?*?*ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, psz_name_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_name_);
            }
            pub inline fn getParameter(self: *const T, psz_name_: ?[*:0]const u16, pp_value_: ?*?*PROPVARIANT) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetParameter(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_name_, pp_value_);
            }
            pub inline fn setParameter(self: *const T, psz_name_: ?[*:0]const u16, p_value_: ?*PROPVARIANT) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).SetParameter(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_name_, p_value_);
            }
            pub inline fn getCatalogStatus(self: *const T, p_status_: ?*CatalogStatus, p_paused_reason_: ?*CatalogPausedReason) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetCatalogStatus(@as(*const ISearchCatalogManager, @ptrCast(self)), p_status_, p_paused_reason_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISearchCatalogManager, @ptrCast(self)));
            }
            pub inline fn reindex(self: *const T) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).Reindex(@as(*const ISearchCatalogManager, @ptrCast(self)));
            }
            pub inline fn reindexMatchingURLs(self: *const T, psz_pattern_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).ReindexMatchingURLs(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_pattern_);
            }
            pub inline fn reindexSearchRoot(self: *const T, psz_root_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).ReindexSearchRoot(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_root_u_r_l_);
            }
            pub inline fn putConnectTimeout(self: *const T, dw_connect_timeout_: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_ConnectTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), dw_connect_timeout_);
            }
            pub inline fn getConnectTimeout(self: *const T, pdw_connect_timeout_: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_ConnectTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), pdw_connect_timeout_);
            }
            pub inline fn putDataTimeout(self: *const T, dw_data_timeout_: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_DataTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), dw_data_timeout_);
            }
            pub inline fn getDataTimeout(self: *const T, pdw_data_timeout_: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_DataTimeout(@as(*const ISearchCatalogManager, @ptrCast(self)), pdw_data_timeout_);
            }
            pub inline fn numberOfItems(self: *const T, pl_count_: ?*i32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).NumberOfItems(@as(*const ISearchCatalogManager, @ptrCast(self)), pl_count_);
            }
            pub inline fn numberOfItemsToIndex(self: *const T, pl_incremental_count_: ?*i32, pl_notification_queue_: ?*i32, pl_high_priority_queue_: ?*i32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).NumberOfItemsToIndex(@as(*const ISearchCatalogManager, @ptrCast(self)), pl_incremental_count_, pl_notification_queue_, pl_high_priority_queue_);
            }
            pub inline fn urlBeingIndexed(self: *const T, psz_url_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).URLBeingIndexed(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_url_);
            }
            pub inline fn getURLIndexingState(self: *const T, psz_u_r_l_: ?[*:0]const u16, pdw_state_: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetURLIndexingState(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_u_r_l_, pdw_state_);
            }
            pub inline fn getPersistentItemsChangedSink(self: *const T, pp_i_search_persistent_items_changed_sink_: ?*?*ISearchPersistentItemsChangedSink) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetPersistentItemsChangedSink(@as(*const ISearchCatalogManager, @ptrCast(self)), pp_i_search_persistent_items_changed_sink_);
            }
            pub inline fn registerViewForNotification(self: *const T, psz_view_: ?[*:0]const u16, p_view_changed_sink_: ?*ISearchViewChangedSink, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).RegisterViewForNotification(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_view_, p_view_changed_sink_, pdw_cookie_);
            }
            pub inline fn getItemsChangedSink(self: *const T, p_i_search_notify_inline_site_: ?*ISearchNotifyInlineSite, riid_: ?*const Guid, ppv_: ?*?*anyopaque, p_g_u_i_d_catalog_reset_signature_: ?*Guid, p_g_u_i_d_check_point_signature_: ?*Guid, pdw_last_check_point_number_: ?*u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetItemsChangedSink(@as(*const ISearchCatalogManager, @ptrCast(self)), p_i_search_notify_inline_site_, riid_, ppv_, p_g_u_i_d_catalog_reset_signature_, p_g_u_i_d_check_point_signature_, pdw_last_check_point_number_);
            }
            pub inline fn unregisterViewForNotification(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).UnregisterViewForNotification(@as(*const ISearchCatalogManager, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn setExtensionClusion(self: *const T, psz_extension_: ?[*:0]const u16, f_exclude_: BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).SetExtensionClusion(@as(*const ISearchCatalogManager, @ptrCast(self)), psz_extension_, f_exclude_);
            }
            pub inline fn enumerateExcludedExtensions(self: *const T, pp_extensions_: ?*?*IEnumString) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).EnumerateExcludedExtensions(@as(*const ISearchCatalogManager, @ptrCast(self)), pp_extensions_);
            }
            pub inline fn getQueryHelper(self: *const T, pp_search_query_helper_: ?*?*ISearchQueryHelper) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetQueryHelper(@as(*const ISearchCatalogManager, @ptrCast(self)), pp_search_query_helper_);
            }
            pub inline fn putDiacriticSensitivity(self: *const T, f_diacritic_sensitive_: BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).put_DiacriticSensitivity(@as(*const ISearchCatalogManager, @ptrCast(self)), f_diacritic_sensitive_);
            }
            pub inline fn getDiacriticSensitivity(self: *const T, pf_diacritic_sensitive_: ?*BOOL) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).get_DiacriticSensitivity(@as(*const ISearchCatalogManager, @ptrCast(self)), pf_diacritic_sensitive_);
            }
            pub inline fn getCrawlScopeManager(self: *const T, pp_crawl_scope_manager_: ?*?*ISearchCrawlScopeManager) HRESULT {
                return @as(*const ISearchCatalogManager.VTable, @ptrCast(self.vtable)).GetCrawlScopeManager(@as(*const ISearchCatalogManager, @ptrCast(self)), pp_crawl_scope_manager_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITIZE_FLAGS = enum(i32) {
    RETRYFAILEDITEMS = 1,
    IGNOREFAILURECOUNT = 2,
};
pub const PRIORITIZE_FLAG_RETRYFAILEDITEMS = PRIORITIZE_FLAGS.RETRYFAILEDITEMS;
pub const PRIORITIZE_FLAG_IGNOREFAILURECOUNT = PRIORITIZE_FLAGS.IGNOREFAILURECOUNT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCatalogManager2_Value = Guid.initString("7ac3286d-4d1d-4817-84fc-c1c85e3af0d9");
pub const IID_ISearchCatalogManager2 = &IID_ISearchCatalogManager2_Value;
pub const ISearchCatalogManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCatalogManager.VTable,
        PrioritizeMatchingURLs: *const fn (
            self: *const ISearchCatalogManager2,
            psz_pattern: ?[*:0]const u16,
            dw_prioritize_flags: PRIORITIZE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchCatalogManager.MethodMixin(T);
            pub inline fn prioritizeMatchingURLs(self: *const T, psz_pattern_: ?[*:0]const u16, dw_prioritize_flags_: PRIORITIZE_FLAGS) HRESULT {
                return @as(*const ISearchCatalogManager2.VTable, @ptrCast(self.vtable)).PrioritizeMatchingURLs(@as(*const ISearchCatalogManager2, @ptrCast(self)), psz_pattern_, dw_prioritize_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_TERM_EXPANSION = enum(i32) {
    NO_EXPANSION = 0,
    PREFIX_ALL = 1,
    STEM_ALL = 2,
};
pub const SEARCH_TERM_NO_EXPANSION = SEARCH_TERM_EXPANSION.NO_EXPANSION;
pub const SEARCH_TERM_PREFIX_ALL = SEARCH_TERM_EXPANSION.PREFIX_ALL;
pub const SEARCH_TERM_STEM_ALL = SEARCH_TERM_EXPANSION.STEM_ALL;

pub const SEARCH_QUERY_SYNTAX = enum(i32) {
    NO_QUERY_SYNTAX = 0,
    ADVANCED_QUERY_SYNTAX = 1,
    NATURAL_QUERY_SYNTAX = 2,
};
pub const SEARCH_NO_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NO_QUERY_SYNTAX;
pub const SEARCH_ADVANCED_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.ADVANCED_QUERY_SYNTAX;
pub const SEARCH_NATURAL_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.NATURAL_QUERY_SYNTAX;

pub const SEARCH_COLUMN_PROPERTIES = extern struct {
    Value: PROPVARIANT,
    lcid: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchQueryHelper_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef63");
pub const IID_ISearchQueryHelper = &IID_ISearchQueryHelper_Value;
pub const ISearchQueryHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            psz_connection_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentLocale: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentLocale: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryKeywordLocale: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryKeywordLocale: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryTermExpansion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            expand_terms: SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryTermExpansion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            p_expand_terms: ?*SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySyntax: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            query_syntax: SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySyntax: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            p_query_syntax: ?*SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryContentProperties: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            psz_content_properties: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryContentProperties: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            ppsz_content_properties: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySelectColumns: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            psz_select_columns: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySelectColumns: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            ppsz_select_columns: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryWhereRestrictions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            psz_restrictions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryWhereRestrictions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            ppsz_restrictions: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuerySorting: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            psz_sorting: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuerySorting: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            ppsz_sorting: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateSQLFromUserQuery: *const fn (
            self: *const ISearchQueryHelper,
            psz_query: ?[*:0]const u16,
            ppsz_s_q_l: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: *const fn (
            self: *const ISearchQueryHelper,
            item_i_d: i32,
            dw_number_of_columns: u32,
            p_columns: [*]PROPERTYKEY,
            p_values: [*]SEARCH_COLUMN_PROPERTIES,
            pft_gather_modified_time: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryMaxResults: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            c_max_results: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryMaxResults: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchQueryHelper,
            pc_max_results: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getConnectionString(self: *const T, psz_connection_string_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_ConnectionString(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_connection_string_);
            }
            pub inline fn putQueryContentLocale(self: *const T, lcid_: u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryContentLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), lcid_);
            }
            pub inline fn getQueryContentLocale(self: *const T, plcid_: ?*u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryContentLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), plcid_);
            }
            pub inline fn putQueryKeywordLocale(self: *const T, lcid_: u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryKeywordLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), lcid_);
            }
            pub inline fn getQueryKeywordLocale(self: *const T, plcid_: ?*u32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryKeywordLocale(@as(*const ISearchQueryHelper, @ptrCast(self)), plcid_);
            }
            pub inline fn putQueryTermExpansion(self: *const T, expand_terms_: SEARCH_TERM_EXPANSION) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryTermExpansion(@as(*const ISearchQueryHelper, @ptrCast(self)), expand_terms_);
            }
            pub inline fn getQueryTermExpansion(self: *const T, p_expand_terms_: ?*SEARCH_TERM_EXPANSION) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryTermExpansion(@as(*const ISearchQueryHelper, @ptrCast(self)), p_expand_terms_);
            }
            pub inline fn putQuerySyntax(self: *const T, query_syntax_: SEARCH_QUERY_SYNTAX) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySyntax(@as(*const ISearchQueryHelper, @ptrCast(self)), query_syntax_);
            }
            pub inline fn getQuerySyntax(self: *const T, p_query_syntax_: ?*SEARCH_QUERY_SYNTAX) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySyntax(@as(*const ISearchQueryHelper, @ptrCast(self)), p_query_syntax_);
            }
            pub inline fn putQueryContentProperties(self: *const T, psz_content_properties_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryContentProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_content_properties_);
            }
            pub inline fn getQueryContentProperties(self: *const T, ppsz_content_properties_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryContentProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), ppsz_content_properties_);
            }
            pub inline fn putQuerySelectColumns(self: *const T, psz_select_columns_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySelectColumns(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_select_columns_);
            }
            pub inline fn getQuerySelectColumns(self: *const T, ppsz_select_columns_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySelectColumns(@as(*const ISearchQueryHelper, @ptrCast(self)), ppsz_select_columns_);
            }
            pub inline fn putQueryWhereRestrictions(self: *const T, psz_restrictions_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryWhereRestrictions(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_restrictions_);
            }
            pub inline fn getQueryWhereRestrictions(self: *const T, ppsz_restrictions_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryWhereRestrictions(@as(*const ISearchQueryHelper, @ptrCast(self)), ppsz_restrictions_);
            }
            pub inline fn putQuerySorting(self: *const T, psz_sorting_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QuerySorting(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_sorting_);
            }
            pub inline fn getQuerySorting(self: *const T, ppsz_sorting_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QuerySorting(@as(*const ISearchQueryHelper, @ptrCast(self)), ppsz_sorting_);
            }
            pub inline fn generateSQLFromUserQuery(self: *const T, psz_query_: ?[*:0]const u16, ppsz_s_q_l_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).GenerateSQLFromUserQuery(@as(*const ISearchQueryHelper, @ptrCast(self)), psz_query_, ppsz_s_q_l_);
            }
            pub inline fn writeProperties(self: *const T, item_i_d_: i32, dw_number_of_columns_: u32, p_columns_: [*]PROPERTYKEY, p_values_: [*]SEARCH_COLUMN_PROPERTIES, pft_gather_modified_time_: ?*FILETIME) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).WriteProperties(@as(*const ISearchQueryHelper, @ptrCast(self)), item_i_d_, dw_number_of_columns_, p_columns_, p_values_, pft_gather_modified_time_);
            }
            pub inline fn putQueryMaxResults(self: *const T, c_max_results_: i32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).put_QueryMaxResults(@as(*const ISearchQueryHelper, @ptrCast(self)), c_max_results_);
            }
            pub inline fn getQueryMaxResults(self: *const T, pc_max_results_: ?*i32) HRESULT {
                return @as(*const ISearchQueryHelper.VTable, @ptrCast(self.vtable)).get_QueryMaxResults(@as(*const ISearchQueryHelper, @ptrCast(self)), pc_max_results_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY_LEVEL = enum(i32) {
    FOREGROUND = 0,
    HIGH = 1,
    LOW = 2,
    DEFAULT = 3,
};
pub const PRIORITY_LEVEL_FOREGROUND = PRIORITY_LEVEL.FOREGROUND;
pub const PRIORITY_LEVEL_HIGH = PRIORITY_LEVEL.HIGH;
pub const PRIORITY_LEVEL_LOW = PRIORITY_LEVEL.LOW;
pub const PRIORITY_LEVEL_DEFAULT = PRIORITY_LEVEL.DEFAULT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetPrioritization_Value = Guid.initString("42811652-079d-481b-87a2-09a69ecc5f44");
pub const IID_IRowsetPrioritization = &IID_IRowsetPrioritization_Value;
pub const IRowsetPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScopePriority: *const fn (
            self: *const IRowsetPrioritization,
            priority: PRIORITY_LEVEL,
            scope_statistics_event_frequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopePriority: *const fn (
            self: *const IRowsetPrioritization,
            priority: ?*PRIORITY_LEVEL,
            scope_statistics_event_frequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeStatistics: *const fn (
            self: *const IRowsetPrioritization,
            indexed_document_count: ?*u32,
            oustanding_add_count: ?*u32,
            oustanding_modify_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setScopePriority(self: *const T, priority_: PRIORITY_LEVEL, scope_statistics_event_frequency_: u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).SetScopePriority(@as(*const IRowsetPrioritization, @ptrCast(self)), priority_, scope_statistics_event_frequency_);
            }
            pub inline fn getScopePriority(self: *const T, priority_: ?*PRIORITY_LEVEL, scope_statistics_event_frequency_: ?*u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).GetScopePriority(@as(*const IRowsetPrioritization, @ptrCast(self)), priority_, scope_statistics_event_frequency_);
            }
            pub inline fn getScopeStatistics(self: *const T, indexed_document_count_: ?*u32, oustanding_add_count_: ?*u32, oustanding_modify_count_: ?*u32) HRESULT {
                return @as(*const IRowsetPrioritization.VTable, @ptrCast(self.vtable)).GetScopeStatistics(@as(*const IRowsetPrioritization, @ptrCast(self)), indexed_document_count_, oustanding_add_count_, oustanding_modify_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ROWSETEVENT_ITEMSTATE = enum(i32) {
    NOTINROWSET = 0,
    INROWSET = 1,
    UNKNOWN = 2,
};
pub const ROWSETEVENT_ITEMSTATE_NOTINROWSET = ROWSETEVENT_ITEMSTATE.NOTINROWSET;
pub const ROWSETEVENT_ITEMSTATE_INROWSET = ROWSETEVENT_ITEMSTATE.INROWSET;
pub const ROWSETEVENT_ITEMSTATE_UNKNOWN = ROWSETEVENT_ITEMSTATE.UNKNOWN;

pub const ROWSETEVENT_TYPE = enum(i32) {
    DATAEXPIRED = 0,
    FOREGROUNDLOST = 1,
    SCOPESTATISTICS = 2,
};
pub const ROWSETEVENT_TYPE_DATAEXPIRED = ROWSETEVENT_TYPE.DATAEXPIRED;
pub const ROWSETEVENT_TYPE_FOREGROUNDLOST = ROWSETEVENT_TYPE.FOREGROUNDLOST;
pub const ROWSETEVENT_TYPE_SCOPESTATISTICS = ROWSETEVENT_TYPE.SCOPESTATISTICS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IRowsetEvents_Value = Guid.initString("1551aea5-5d66-4b11-86f5-d5634cb211b9");
pub const IID_IRowsetEvents = &IID_IRowsetEvents_Value;
pub const IRowsetEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNewItem: *const fn (
            self: *const IRowsetEvents,
            item_i_d: ?*const PROPVARIANT,
            new_item_state: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChangedItem: *const fn (
            self: *const IRowsetEvents,
            item_i_d: ?*const PROPVARIANT,
            rowset_item_state: ROWSETEVENT_ITEMSTATE,
            changed_item_state: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeletedItem: *const fn (
            self: *const IRowsetEvents,
            item_i_d: ?*const PROPVARIANT,
            deleted_item_state: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetEvent: *const fn (
            self: *const IRowsetEvents,
            event_type: ROWSETEVENT_TYPE,
            event_data: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onNewItem(self: *const T, item_i_d_: ?*const PROPVARIANT, new_item_state_: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnNewItem(@as(*const IRowsetEvents, @ptrCast(self)), item_i_d_, new_item_state_);
            }
            pub inline fn onChangedItem(self: *const T, item_i_d_: ?*const PROPVARIANT, rowset_item_state_: ROWSETEVENT_ITEMSTATE, changed_item_state_: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnChangedItem(@as(*const IRowsetEvents, @ptrCast(self)), item_i_d_, rowset_item_state_, changed_item_state_);
            }
            pub inline fn onDeletedItem(self: *const T, item_i_d_: ?*const PROPVARIANT, deleted_item_state_: ROWSETEVENT_ITEMSTATE) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnDeletedItem(@as(*const IRowsetEvents, @ptrCast(self)), item_i_d_, deleted_item_state_);
            }
            pub inline fn onRowsetEvent(self: *const T, event_type_: ROWSETEVENT_TYPE, event_data_: ?*const PROPVARIANT) HRESULT {
                return @as(*const IRowsetEvents.VTable, @ptrCast(self.vtable)).OnRowsetEvent(@as(*const IRowsetEvents, @ptrCast(self)), event_type_, event_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchManager_Value = Guid.initString("ab310581-ac80-11d1-8df3-00c04fb6ef69");
pub const IID_ISearchManager = &IID_ISearchManager_Value;
pub const ISearchManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexerVersionStr: *const fn (
            self: *const ISearchManager,
            ppsz_version_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexerVersion: *const fn (
            self: *const ISearchManager,
            pdw_major: ?*u32,
            pdw_minor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: *const fn (
            self: *const ISearchManager,
            psz_name: ?[*:0]const u16,
            pp_value: ?*?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: *const fn (
            self: *const ISearchManager,
            psz_name: ?[*:0]const u16,
            p_value: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            ppsz_proxy_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BypassList: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            ppsz_bypass_list: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProxy: *const fn (
            self: *const ISearchManager,
            s_use_proxy: PROXY_ACCESS,
            f_local_by_pass_proxy: BOOL,
            dw_port_number: u32,
            psz_proxy_name: ?[*:0]const u16,
            psz_by_pass_list: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalog: *const fn (
            self: *const ISearchManager,
            psz_catalog: ?[*:0]const u16,
            pp_catalog_manager: ?*?*ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            ppsz_user_agent: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserAgent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            psz_user_agent: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseProxy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            p_use_proxy: ?*PROXY_ACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalBypass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            pf_local_bypass: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PortNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISearchManager,
            pdw_port_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIndexerVersionStr(self: *const T, ppsz_version_string_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetIndexerVersionStr(@as(*const ISearchManager, @ptrCast(self)), ppsz_version_string_);
            }
            pub inline fn getIndexerVersion(self: *const T, pdw_major_: ?*u32, pdw_minor_: ?*u32) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetIndexerVersion(@as(*const ISearchManager, @ptrCast(self)), pdw_major_, pdw_minor_);
            }
            pub inline fn getParameter(self: *const T, psz_name_: ?[*:0]const u16, pp_value_: ?*?*PROPVARIANT) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetParameter(@as(*const ISearchManager, @ptrCast(self)), psz_name_, pp_value_);
            }
            pub inline fn setParameter(self: *const T, psz_name_: ?[*:0]const u16, p_value_: ?*const PROPVARIANT) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).SetParameter(@as(*const ISearchManager, @ptrCast(self)), psz_name_, p_value_);
            }
            pub inline fn getProxyName(self: *const T, ppsz_proxy_name_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_ProxyName(@as(*const ISearchManager, @ptrCast(self)), ppsz_proxy_name_);
            }
            pub inline fn getBypassList(self: *const T, ppsz_bypass_list_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_BypassList(@as(*const ISearchManager, @ptrCast(self)), ppsz_bypass_list_);
            }
            pub inline fn setProxy(self: *const T, s_use_proxy_: PROXY_ACCESS, f_local_by_pass_proxy_: BOOL, dw_port_number_: u32, psz_proxy_name_: ?[*:0]const u16, psz_by_pass_list_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).SetProxy(@as(*const ISearchManager, @ptrCast(self)), s_use_proxy_, f_local_by_pass_proxy_, dw_port_number_, psz_proxy_name_, psz_by_pass_list_);
            }
            pub inline fn getCatalog(self: *const T, psz_catalog_: ?[*:0]const u16, pp_catalog_manager_: ?*?*ISearchCatalogManager) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).GetCatalog(@as(*const ISearchManager, @ptrCast(self)), psz_catalog_, pp_catalog_manager_);
            }
            pub inline fn getUserAgent(self: *const T, ppsz_user_agent_: ?*?PWSTR) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_UserAgent(@as(*const ISearchManager, @ptrCast(self)), ppsz_user_agent_);
            }
            pub inline fn putUserAgent(self: *const T, psz_user_agent_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).put_UserAgent(@as(*const ISearchManager, @ptrCast(self)), psz_user_agent_);
            }
            pub inline fn getUseProxy(self: *const T, p_use_proxy_: ?*PROXY_ACCESS) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_UseProxy(@as(*const ISearchManager, @ptrCast(self)), p_use_proxy_);
            }
            pub inline fn getLocalBypass(self: *const T, pf_local_bypass_: ?*BOOL) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_LocalBypass(@as(*const ISearchManager, @ptrCast(self)), pf_local_bypass_);
            }
            pub inline fn getPortNumber(self: *const T, pdw_port_number_: ?*u32) HRESULT {
                return @as(*const ISearchManager.VTable, @ptrCast(self.vtable)).get_PortNumber(@as(*const ISearchManager, @ptrCast(self)), pdw_port_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISearchManager2_Value = Guid.initString("dbab3f73-db19-4a79-bfc0-a61a93886ddf");
pub const IID_ISearchManager2 = &IID_ISearchManager2_Value;
pub const ISearchManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchManager.VTable,
        CreateCatalog: *const fn (
            self: *const ISearchManager2,
            psz_catalog: ?[*:0]const u16,
            pp_catalog_manager: ?*?*ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteCatalog: *const fn (
            self: *const ISearchManager2,
            psz_catalog: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISearchManager.MethodMixin(T);
            pub inline fn createCatalog(self: *const T, psz_catalog_: ?[*:0]const u16, pp_catalog_manager_: ?*?*ISearchCatalogManager) HRESULT {
                return @as(*const ISearchManager2.VTable, @ptrCast(self.vtable)).CreateCatalog(@as(*const ISearchManager2, @ptrCast(self)), psz_catalog_, pp_catalog_manager_);
            }
            pub inline fn deleteCatalog(self: *const T, psz_catalog_: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchManager2.VTable, @ptrCast(self.vtable)).DeleteCatalog(@as(*const ISearchManager2, @ptrCast(self)), psz_catalog_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchLanguageSupport_Value = Guid.initString("6a68cc80-4337-4dbc-bd27-fbfb1053820b");
pub const CLSID_CSearchLanguageSupport = &CLSID_CSearchLanguageSupport_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchLanguageSupport_Value = Guid.initString("24c3cbaa-ebc1-491a-9ef1-9f6d8deb1b8f");
pub const IID_ISearchLanguageSupport = &IID_ISearchLanguageSupport_Value;
pub const ISearchLanguageSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDiacriticSensitivity: *const fn (
            self: *const ISearchLanguageSupport,
            f_diacritic_sensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiacriticSensitivity: *const fn (
            self: *const ISearchLanguageSupport,
            pf_diacritic_sensitive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadWordBreaker: *const fn (
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: ?*const Guid,
            pp_word_breaker: ?*?*anyopaque,
            p_lcid_used: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadStemmer: *const fn (
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: ?*const Guid,
            pp_stemmer: ?*?*anyopaque,
            p_lcid_used: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrefixNormalized: *const fn (
            self: *const ISearchLanguageSupport,
            pwcs_query_token: [*:0]const u16,
            cwc_query_token: u32,
            pwcs_document_token: [*:0]const u16,
            cwc_document_token: u32,
            pul_prefix_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDiacriticSensitivity(self: *const T, f_diacritic_sensitive_: BOOL) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).SetDiacriticSensitivity(@as(*const ISearchLanguageSupport, @ptrCast(self)), f_diacritic_sensitive_);
            }
            pub inline fn getDiacriticSensitivity(self: *const T, pf_diacritic_sensitive_: ?*BOOL) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).GetDiacriticSensitivity(@as(*const ISearchLanguageSupport, @ptrCast(self)), pf_diacritic_sensitive_);
            }
            pub inline fn loadWordBreaker(self: *const T, lcid_: u32, riid_: ?*const Guid, pp_word_breaker_: ?*?*anyopaque, p_lcid_used_: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).LoadWordBreaker(@as(*const ISearchLanguageSupport, @ptrCast(self)), lcid_, riid_, pp_word_breaker_, p_lcid_used_);
            }
            pub inline fn loadStemmer(self: *const T, lcid_: u32, riid_: ?*const Guid, pp_stemmer_: ?*?*anyopaque, p_lcid_used_: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).LoadStemmer(@as(*const ISearchLanguageSupport, @ptrCast(self)), lcid_, riid_, pp_stemmer_, p_lcid_used_);
            }
            pub inline fn isPrefixNormalized(self: *const T, pwcs_query_token_: [*:0]const u16, cwc_query_token_: u32, pwcs_document_token_: [*:0]const u16, cwc_document_token_: u32, pul_prefix_length_: ?*u32) HRESULT {
                return @as(*const ISearchLanguageSupport.VTable, @ptrCast(self.vtable)).IsPrefixNormalized(@as(*const ISearchLanguageSupport, @ptrCast(self)), pwcs_query_token_, cwc_query_token_, pwcs_document_token_, cwc_document_token_, pul_prefix_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SubscriptionMgr_Value = Guid.initString("abbe31d0-6dae-11d0-beca-00c04fd940be");
pub const CLSID_SubscriptionMgr = &CLSID_SubscriptionMgr_Value;

pub const ITEMPROP = extern struct {
    variantValue: VARIANT,
    pwszName: ?PWSTR,
};

const IID_IEnumItemProperties_Value = Guid.initString("f72c8d96-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumItemProperties = &IID_IEnumItemProperties_Value;
pub const IEnumItemProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumItemProperties,
            celt: u32,
            rgelt: [*]ITEMPROP,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumItemProperties,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumItemProperties,
            ppenum: ?*?*IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const IEnumItemProperties,
            pn_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]ITEMPROP, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumItemProperties, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumItemProperties, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumItemProperties, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumItemProperties) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumItemProperties, @ptrCast(self)), ppenum_);
            }
            pub inline fn getCount(self: *const T, pn_count_: ?*u32) HRESULT {
                return @as(*const IEnumItemProperties.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumItemProperties, @ptrCast(self)), pn_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONITEMINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwPriority: u32,
    ScheduleGroup: Guid,
    clsidAgent: Guid,
};

const IID_ISubscriptionItem_Value = Guid.initString("a97559f8-6c4a-11d1-a1e8-00c04fc2fbe1");
pub const IID_ISubscriptionItem = &IID_ISubscriptionItem_Value;
pub const ISubscriptionItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookie: *const fn (
            self: *const ISubscriptionItem,
            p_cookie: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionItemInfo: *const fn (
            self: *const ISubscriptionItem,
            p_subscription_item_info: ?*SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscriptionItemInfo: *const fn (
            self: *const ISubscriptionItem,
            p_subscription_item_info: ?*const SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProperties: *const fn (
            self: *const ISubscriptionItem,
            n_count: u32,
            rgwsz_name: [*]const ?[*:0]const u16,
            rg_value: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: *const fn (
            self: *const ISubscriptionItem,
            n_count: u32,
            rgwsz_name: [*]const ?[*:0]const u16,
            rg_value: [*]const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProperties: *const fn (
            self: *const ISubscriptionItem,
            pp_enum_item_properties: ?*?*IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: *const fn (
            self: *const ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCookie(self: *const T, p_cookie_: ?*Guid) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const ISubscriptionItem, @ptrCast(self)), p_cookie_);
            }
            pub inline fn getSubscriptionItemInfo(self: *const T, p_subscription_item_info_: ?*SUBSCRIPTIONITEMINFO) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).GetSubscriptionItemInfo(@as(*const ISubscriptionItem, @ptrCast(self)), p_subscription_item_info_);
            }
            pub inline fn setSubscriptionItemInfo(self: *const T, p_subscription_item_info_: ?*const SUBSCRIPTIONITEMINFO) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).SetSubscriptionItemInfo(@as(*const ISubscriptionItem, @ptrCast(self)), p_subscription_item_info_);
            }
            pub inline fn readProperties(self: *const T, n_count_: u32, rgwsz_name_: [*]const ?[*:0]const u16, rg_value_: [*]VARIANT) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).ReadProperties(@as(*const ISubscriptionItem, @ptrCast(self)), n_count_, rgwsz_name_, rg_value_);
            }
            pub inline fn writeProperties(self: *const T, n_count_: u32, rgwsz_name_: [*]const ?[*:0]const u16, rg_value_: [*]const VARIANT) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).WriteProperties(@as(*const ISubscriptionItem, @ptrCast(self)), n_count_, rgwsz_name_, rg_value_);
            }
            pub inline fn enumProperties(self: *const T, pp_enum_item_properties_: ?*?*IEnumItemProperties) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).EnumProperties(@as(*const ISubscriptionItem, @ptrCast(self)), pp_enum_item_properties_);
            }
            pub inline fn notifyChanged(self: *const T) HRESULT {
                return @as(*const ISubscriptionItem.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const ISubscriptionItem, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSubscription_Value = Guid.initString("f72c8d97-6dbd-11d1-a1e8-00c04fc2fbe1");
pub const IID_IEnumSubscription = &IID_IEnumSubscription_Value;
pub const IEnumSubscription = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSubscription,
            celt: u32,
            rgelt: [*]Guid,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSubscription,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSubscription,
            ppenum: ?*?*IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const IEnumSubscription,
            pn_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]Guid, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSubscription, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSubscription, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSubscription, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumSubscription) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSubscription, @ptrCast(self)), ppenum_);
            }
            pub inline fn getCount(self: *const T, pn_count_: ?*u32) HRESULT {
                return @as(*const IEnumSubscription.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumSubscription, @ptrCast(self)), pn_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONTYPE = enum(i32) {
    URL = 0,
    CHANNEL = 1,
    DESKTOPURL = 2,
    EXTERNAL = 3,
    DESKTOPCHANNEL = 4,
};
pub const SUBSTYPE_URL = SUBSCRIPTIONTYPE.URL;
pub const SUBSTYPE_CHANNEL = SUBSCRIPTIONTYPE.CHANNEL;
pub const SUBSTYPE_DESKTOPURL = SUBSCRIPTIONTYPE.DESKTOPURL;
pub const SUBSTYPE_EXTERNAL = SUBSCRIPTIONTYPE.EXTERNAL;
pub const SUBSTYPE_DESKTOPCHANNEL = SUBSCRIPTIONTYPE.DESKTOPCHANNEL;

pub const SUBSCRIPTIONINFOFLAGS = enum(i32) {
    SCHEDULE = 1,
    RECURSE = 2,
    WEBCRAWL = 4,
    MAILNOT = 8,
    MAXSIZEKB = 16,
    USER = 32,
    PASSWORD = 64,
    TASKFLAGS = 256,
    GLEAM = 512,
    CHANGESONLY = 1024,
    CHANNELFLAGS = 2048,
    FRIENDLYNAME = 8192,
    NEEDPASSWORD = 16384,
    TYPE = 32768,
};
pub const SUBSINFO_SCHEDULE = SUBSCRIPTIONINFOFLAGS.SCHEDULE;
pub const SUBSINFO_RECURSE = SUBSCRIPTIONINFOFLAGS.RECURSE;
pub const SUBSINFO_WEBCRAWL = SUBSCRIPTIONINFOFLAGS.WEBCRAWL;
pub const SUBSINFO_MAILNOT = SUBSCRIPTIONINFOFLAGS.MAILNOT;
pub const SUBSINFO_MAXSIZEKB = SUBSCRIPTIONINFOFLAGS.MAXSIZEKB;
pub const SUBSINFO_USER = SUBSCRIPTIONINFOFLAGS.USER;
pub const SUBSINFO_PASSWORD = SUBSCRIPTIONINFOFLAGS.PASSWORD;
pub const SUBSINFO_TASKFLAGS = SUBSCRIPTIONINFOFLAGS.TASKFLAGS;
pub const SUBSINFO_GLEAM = SUBSCRIPTIONINFOFLAGS.GLEAM;
pub const SUBSINFO_CHANGESONLY = SUBSCRIPTIONINFOFLAGS.CHANGESONLY;
pub const SUBSINFO_CHANNELFLAGS = SUBSCRIPTIONINFOFLAGS.CHANNELFLAGS;
pub const SUBSINFO_FRIENDLYNAME = SUBSCRIPTIONINFOFLAGS.FRIENDLYNAME;
pub const SUBSINFO_NEEDPASSWORD = SUBSCRIPTIONINFOFLAGS.NEEDPASSWORD;
pub const SUBSINFO_TYPE = SUBSCRIPTIONINFOFLAGS.TYPE;

pub const CREATESUBSCRIPTIONFLAGS = enum(i32) {
    ADDTOFAVORITES = 1,
    FROMFAVORITES = 2,
    NOUI = 4,
    NOSAVE = 8,
    SOFTWAREUPDATE = 16,
};
pub const CREATESUBS_ADDTOFAVORITES = CREATESUBSCRIPTIONFLAGS.ADDTOFAVORITES;
pub const CREATESUBS_FROMFAVORITES = CREATESUBSCRIPTIONFLAGS.FROMFAVORITES;
pub const CREATESUBS_NOUI = CREATESUBSCRIPTIONFLAGS.NOUI;
pub const CREATESUBS_NOSAVE = CREATESUBSCRIPTIONFLAGS.NOSAVE;
pub const CREATESUBS_SOFTWAREUPDATE = CREATESUBSCRIPTIONFLAGS.SOFTWAREUPDATE;

pub const SUBSCRIPTIONSCHEDULE = enum(i32) {
    AUTO = 0,
    DAILY = 1,
    WEEKLY = 2,
    CUSTOM = 3,
    MANUAL = 4,
};
pub const SUBSSCHED_AUTO = SUBSCRIPTIONSCHEDULE.AUTO;
pub const SUBSSCHED_DAILY = SUBSCRIPTIONSCHEDULE.DAILY;
pub const SUBSSCHED_WEEKLY = SUBSCRIPTIONSCHEDULE.WEEKLY;
pub const SUBSSCHED_CUSTOM = SUBSCRIPTIONSCHEDULE.CUSTOM;
pub const SUBSSCHED_MANUAL = SUBSCRIPTIONSCHEDULE.MANUAL;

pub const SUBSCRIPTIONINFO = extern struct {
    cbSize: u32,
    fUpdateFlags: u32,
    schedule: SUBSCRIPTIONSCHEDULE,
    customGroupCookie: Guid,
    pTrigger: ?*anyopaque,
    dwRecurseLevels: u32,
    fWebcrawlerFlags: u32,
    bMailNotification: BOOL,
    bGleam: BOOL,
    bChangesOnly: BOOL,
    bNeedPassword: BOOL,
    fChannelFlags: u32,
    bstrUserName: ?BSTR,
    bstrPassword: ?BSTR,
    bstrFriendlyName: ?BSTR,
    dwMaxSizeKB: u32,
    subType: SUBSCRIPTIONTYPE,
    fTaskFlags: u32,
    dwReserved: u32,
};

const IID_ISubscriptionMgr_Value = Guid.initString("085fb2c0-0df8-11d1-8f4b-00a0c905413f");
pub const IID_ISubscriptionMgr = &IID_ISubscriptionMgr_Value;
pub const ISubscriptionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteSubscription: *const fn (
            self: *const ISubscriptionMgr,
            pwsz_u_r_l: ?[*:0]const u16,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateSubscription: *const fn (
            self: *const ISubscriptionMgr,
            pwsz_u_r_l: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAll: *const fn (
            self: *const ISubscriptionMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: *const fn (
            self: *const ISubscriptionMgr,
            pwsz_u_r_l: ?[*:0]const u16,
            pf_subscribed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionInfo: *const fn (
            self: *const ISubscriptionMgr,
            pwsz_u_r_l: ?[*:0]const u16,
            p_info: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultInfo: *const fn (
            self: *const ISubscriptionMgr,
            sub_type: SUBSCRIPTIONTYPE,
            p_info: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSubscriptionProperties: *const fn (
            self: *const ISubscriptionMgr,
            pwsz_u_r_l: ?[*:0]const u16,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscription: *const fn (
            self: *const ISubscriptionMgr,
            hwnd: ?HWND,
            pwsz_u_r_l: ?[*:0]const u16,
            pwsz_friendly_name: ?[*:0]const u16,
            dw_flags: u32,
            subs_type: SUBSCRIPTIONTYPE,
            p_info: ?*SUBSCRIPTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn deleteSubscription(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, hwnd_: ?HWND) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).DeleteSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), pwsz_u_r_l_, hwnd_);
            }
            pub inline fn updateSubscription(self: *const T, pwsz_u_r_l_: ?[*:0]const u16) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).UpdateSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), pwsz_u_r_l_);
            }
            pub inline fn updateAll(self: *const T) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).UpdateAll(@as(*const ISubscriptionMgr, @ptrCast(self)));
            }
            pub inline fn isSubscribed(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, pf_subscribed_: ?*BOOL) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).IsSubscribed(@as(*const ISubscriptionMgr, @ptrCast(self)), pwsz_u_r_l_, pf_subscribed_);
            }
            pub inline fn getSubscriptionInfo(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, p_info_: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).GetSubscriptionInfo(@as(*const ISubscriptionMgr, @ptrCast(self)), pwsz_u_r_l_, p_info_);
            }
            pub inline fn getDefaultInfo(self: *const T, sub_type_: SUBSCRIPTIONTYPE, p_info_: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).GetDefaultInfo(@as(*const ISubscriptionMgr, @ptrCast(self)), sub_type_, p_info_);
            }
            pub inline fn showSubscriptionProperties(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, hwnd_: ?HWND) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).ShowSubscriptionProperties(@as(*const ISubscriptionMgr, @ptrCast(self)), pwsz_u_r_l_, hwnd_);
            }
            pub inline fn createSubscription(self: *const T, hwnd_: ?HWND, pwsz_u_r_l_: ?[*:0]const u16, pwsz_friendly_name_: ?[*:0]const u16, dw_flags_: u32, subs_type_: SUBSCRIPTIONTYPE, p_info_: ?*SUBSCRIPTIONINFO) HRESULT {
                return @as(*const ISubscriptionMgr.VTable, @ptrCast(self.vtable)).CreateSubscription(@as(*const ISubscriptionMgr, @ptrCast(self)), hwnd_, pwsz_u_r_l_, pwsz_friendly_name_, dw_flags_, subs_type_, p_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISubscriptionMgr2_Value = Guid.initString("614bc270-aedf-11d1-a1f9-00c04fc2fbe1");
pub const IID_ISubscriptionMgr2 = &IID_ISubscriptionMgr2_Value;
pub const ISubscriptionMgr2 = extern struct {
    pub const VTable = extern struct {
        base: ISubscriptionMgr.VTable,
        GetItemFromURL: *const fn (
            self: *const ISubscriptionMgr2,
            pwsz_u_r_l: ?[*:0]const u16,
            pp_subscription_item: ?*?*ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFromCookie: *const fn (
            self: *const ISubscriptionMgr2,
            p_subscription_cookie: ?*const Guid,
            pp_subscription_item: ?*?*ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionRunState: *const fn (
            self: *const ISubscriptionMgr2,
            dw_num_cookies: u32,
            p_cookies: [*]const Guid,
            pdw_run_state: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSubscriptions: *const fn (
            self: *const ISubscriptionMgr2,
            dw_flags: u32,
            pp_enum_subscriptions: ?*?*IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateItems: *const fn (
            self: *const ISubscriptionMgr2,
            dw_flags: u32,
            dw_num_cookies: u32,
            p_cookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItems: *const fn (
            self: *const ISubscriptionMgr2,
            dw_num_cookies: u32,
            p_cookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortAll: *const fn (
            self: *const ISubscriptionMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISubscriptionMgr.MethodMixin(T);
            pub inline fn getItemFromURL(self: *const T, pwsz_u_r_l_: ?[*:0]const u16, pp_subscription_item_: ?*?*ISubscriptionItem) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetItemFromURL(@as(*const ISubscriptionMgr2, @ptrCast(self)), pwsz_u_r_l_, pp_subscription_item_);
            }
            pub inline fn getItemFromCookie(self: *const T, p_subscription_cookie_: ?*const Guid, pp_subscription_item_: ?*?*ISubscriptionItem) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetItemFromCookie(@as(*const ISubscriptionMgr2, @ptrCast(self)), p_subscription_cookie_, pp_subscription_item_);
            }
            pub inline fn getSubscriptionRunState(self: *const T, dw_num_cookies_: u32, p_cookies_: [*]const Guid, pdw_run_state_: [*]u32) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).GetSubscriptionRunState(@as(*const ISubscriptionMgr2, @ptrCast(self)), dw_num_cookies_, p_cookies_, pdw_run_state_);
            }
            pub inline fn enumSubscriptions(self: *const T, dw_flags_: u32, pp_enum_subscriptions_: ?*?*IEnumSubscription) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).EnumSubscriptions(@as(*const ISubscriptionMgr2, @ptrCast(self)), dw_flags_, pp_enum_subscriptions_);
            }
            pub inline fn updateItems(self: *const T, dw_flags_: u32, dw_num_cookies_: u32, p_cookies_: [*]const Guid) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).UpdateItems(@as(*const ISubscriptionMgr2, @ptrCast(self)), dw_flags_, dw_num_cookies_, p_cookies_);
            }
            pub inline fn abortItems(self: *const T, dw_num_cookies_: u32, p_cookies_: [*]const Guid) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).AbortItems(@as(*const ISubscriptionMgr2, @ptrCast(self)), dw_num_cookies_, p_cookies_);
            }
            pub inline fn abortAll(self: *const T) HRESULT {
                return @as(*const ISubscriptionMgr2.VTable, @ptrCast(self.vtable)).AbortAll(@as(*const ISubscriptionMgr2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DELIVERY_AGENT_FLAGS = enum(i32) {
    NO_BROADCAST = 4,
    NO_RESTRICTIONS = 8,
    SILENT_DIAL = 16,
};
pub const DELIVERY_AGENT_FLAG_NO_BROADCAST = DELIVERY_AGENT_FLAGS.NO_BROADCAST;
pub const DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = DELIVERY_AGENT_FLAGS.NO_RESTRICTIONS;
pub const DELIVERY_AGENT_FLAG_SILENT_DIAL = DELIVERY_AGENT_FLAGS.SILENT_DIAL;

pub const WEBCRAWL_RECURSEFLAGS = enum(i32) {
    DONT_MAKE_STICKY = 1,
    GET_IMAGES = 2,
    GET_VIDEOS = 4,
    GET_BGSOUNDS = 8,
    GET_CONTROLS = 16,
    LINKS_ELSEWHERE = 32,
    IGNORE_ROBOTSTXT = 128,
    ONLY_LINKS_TO_HTML = 256,
};
pub const WEBCRAWL_DONT_MAKE_STICKY = WEBCRAWL_RECURSEFLAGS.DONT_MAKE_STICKY;
pub const WEBCRAWL_GET_IMAGES = WEBCRAWL_RECURSEFLAGS.GET_IMAGES;
pub const WEBCRAWL_GET_VIDEOS = WEBCRAWL_RECURSEFLAGS.GET_VIDEOS;
pub const WEBCRAWL_GET_BGSOUNDS = WEBCRAWL_RECURSEFLAGS.GET_BGSOUNDS;
pub const WEBCRAWL_GET_CONTROLS = WEBCRAWL_RECURSEFLAGS.GET_CONTROLS;
pub const WEBCRAWL_LINKS_ELSEWHERE = WEBCRAWL_RECURSEFLAGS.LINKS_ELSEWHERE;
pub const WEBCRAWL_IGNORE_ROBOTSTXT = WEBCRAWL_RECURSEFLAGS.IGNORE_ROBOTSTXT;
pub const WEBCRAWL_ONLY_LINKS_TO_HTML = WEBCRAWL_RECURSEFLAGS.ONLY_LINKS_TO_HTML;

pub const CHANNEL_AGENT_FLAGS = enum(i32) {
    DYNAMIC_SCHEDULE = 1,
    PRECACHE_SOME = 2,
    PRECACHE_ALL = 4,
    PRECACHE_SCRNSAVER = 8,
};
pub const CHANNEL_AGENT_DYNAMIC_SCHEDULE = CHANNEL_AGENT_FLAGS.DYNAMIC_SCHEDULE;
pub const CHANNEL_AGENT_PRECACHE_SOME = CHANNEL_AGENT_FLAGS.PRECACHE_SOME;
pub const CHANNEL_AGENT_PRECACHE_ALL = CHANNEL_AGENT_FLAGS.PRECACHE_ALL;
pub const CHANNEL_AGENT_PRECACHE_SCRNSAVER = CHANNEL_AGENT_FLAGS.PRECACHE_SCRNSAVER;

pub const DBDATACONVERTENUM = enum(i32) {
    DEFAULT = 0,
    SETDATABEHAVIOR = 1,
    LENGTHFROMNTS = 2,
    DSTISFIXEDLENGTH = 4,
    DECIMALSCALE = 8,
};
pub const DBDATACONVERT_DEFAULT = DBDATACONVERTENUM.DEFAULT;
pub const DBDATACONVERT_SETDATABEHAVIOR = DBDATACONVERTENUM.SETDATABEHAVIOR;
pub const DBDATACONVERT_LENGTHFROMNTS = DBDATACONVERTENUM.LENGTHFROMNTS;
pub const DBDATACONVERT_DSTISFIXEDLENGTH = DBDATACONVERTENUM.DSTISFIXEDLENGTH;
pub const DBDATACONVERT_DECIMALSCALE = DBDATACONVERTENUM.DECIMALSCALE;

const IID_IDataConvert_Value = Guid.initString("0c733a8d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDataConvert = &IID_IDataConvert_Value;
pub const IDataConvert = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DataConvert: *const fn (
            self: *const IDataConvert,
            w_src_type: u16,
            w_dst_type: u16,
            cb_src_length: usize,
            pcb_dst_length: ?*usize,
            // TODO: what to do with BytesParamIndex 2?
            p_src: ?*anyopaque,
            p_dst: ?*anyopaque,
            cb_dst_max_length: usize,
            dbs_src_status: u32,
            pdbs_status: ?*u32,
            b_precision: u8,
            b_scale: u8,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanConvert: *const fn (
            self: *const IDataConvert,
            w_src_type: u16,
            w_dst_type: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionSize: *const fn (
            self: *const IDataConvert,
            w_src_type: u16,
            w_dst_type: u16,
            pcb_src_length: ?*usize,
            pcb_dst_length: ?*usize,
            // TODO: what to do with BytesParamIndex 2?
            p_src: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn dataConvert(self: *const T, w_src_type_: u16, w_dst_type_: u16, cb_src_length_: usize, pcb_dst_length_: ?*usize, p_src_: ?*anyopaque, p_dst_: ?*anyopaque, cb_dst_max_length_: usize, dbs_src_status_: u32, pdbs_status_: ?*u32, b_precision_: u8, b_scale_: u8, dw_flags_: u32) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).DataConvert(@as(*const IDataConvert, @ptrCast(self)), w_src_type_, w_dst_type_, cb_src_length_, pcb_dst_length_, p_src_, p_dst_, cb_dst_max_length_, dbs_src_status_, pdbs_status_, b_precision_, b_scale_, dw_flags_);
            }
            pub inline fn canConvert(self: *const T, w_src_type_: u16, w_dst_type_: u16) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).CanConvert(@as(*const IDataConvert, @ptrCast(self)), w_src_type_, w_dst_type_);
            }
            pub inline fn getConversionSize(self: *const T, w_src_type_: u16, w_dst_type_: u16, pcb_src_length_: ?*usize, pcb_dst_length_: ?*usize, p_src_: ?*anyopaque) HRESULT {
                return @as(*const IDataConvert.VTable, @ptrCast(self.vtable)).GetConversionSize(@as(*const IDataConvert, @ptrCast(self)), w_src_type_, w_dst_type_, pcb_src_length_, pcb_dst_length_, p_src_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DCINFOTYPEENUM = enum(i32) {
    N = 1,
};
pub const DCINFOTYPE_VERSION = DCINFOTYPEENUM.N;

pub const DCINFO = extern struct {
    eInfoType: u32,
    vData: VARIANT,
};

const IID_IDCInfo_Value = Guid.initString("0c733a9c-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDCInfo = &IID_IDCInfo_Value;
pub const IDCInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: *const fn (
            self: *const IDCInfo,
            c_info: u32,
            rge_info_type: [*]u32,
            prg_info: [*]?*DCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: *const fn (
            self: *const IDCInfo,
            c_info: u32,
            rg_info: [*]DCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInfo(self: *const T, c_info_: u32, rge_info_type_: [*]u32, prg_info_: [*]?*DCINFO) HRESULT {
                return @as(*const IDCInfo.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IDCInfo, @ptrCast(self)), c_info_, rge_info_type_, prg_info_);
            }
            pub inline fn setInfo(self: *const T, c_info_: u32, rg_info_: [*]DCINFO) HRESULT {
                return @as(*const IDCInfo.VTable, @ptrCast(self.vtable)).SetInfo(@as(*const IDCInfo, @ptrCast(self)), c_info_, rg_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSDAORA_Value = Guid.initString("e8cc4cbe-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA = &CLSID_MSDAORA_Value;

const CLSID_MSDAORA_ERROR_Value = Guid.initString("e8cc4cbf-fdff-11d0-b865-00a0c9081c1d");
pub const CLSID_MSDAORA_ERROR = &CLSID_MSDAORA_ERROR_Value;

const CLSID_MSDAORA8_Value = Guid.initString("7f06a373-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8 = &CLSID_MSDAORA8_Value;

const CLSID_MSDAORA8_ERROR_Value = Guid.initString("7f06a374-dd6a-43db-b4e0-1fc121e5e62b");
pub const CLSID_MSDAORA8_ERROR = &CLSID_MSDAORA8_ERROR_Value;

const IID_DataSourceListener_Value = Guid.initString("7c0ffab2-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSourceListener = &IID_DataSourceListener_Value;
pub const DataSourceListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        dataMemberChanged: *const fn (
            self: *const DataSourceListener,
            bstr_d_m: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dataMemberAdded: *const fn (
            self: *const DataSourceListener,
            bstr_d_m: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dataMemberRemoved: *const fn (
            self: *const DataSourceListener,
            bstr_d_m: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn dataMemberChanged(self: *const T, bstr_d_m_: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberChanged(@as(*const DataSourceListener, @ptrCast(self)), bstr_d_m_);
            }
            pub inline fn dataMemberAdded(self: *const T, bstr_d_m_: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberAdded(@as(*const DataSourceListener, @ptrCast(self)), bstr_d_m_);
            }
            pub inline fn dataMemberRemoved(self: *const T, bstr_d_m_: ?*u16) HRESULT {
                return @as(*const DataSourceListener.VTable, @ptrCast(self.vtable)).dataMemberRemoved(@as(*const DataSourceListener, @ptrCast(self)), bstr_d_m_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DataSource_Value = Guid.initString("7c0ffab3-cd84-11d0-949a-00a0c91110ed");
pub const IID_DataSource = &IID_DataSource_Value;
pub const DataSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getDataMember: *const fn (
            self: *const DataSource,
            bstr_d_m: ?*u16,
            riid: ?*const Guid,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDataMemberName: *const fn (
            self: *const DataSource,
            l_index: i32,
            pbstr_d_m: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDataMemberCount: *const fn (
            self: *const DataSource,
            pl_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addDataSourceListener: *const fn (
            self: *const DataSource,
            p_d_s_l: ?*DataSourceListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeDataSourceListener: *const fn (
            self: *const DataSource,
            p_d_s_l: ?*DataSourceListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDataMember(self: *const T, bstr_d_m_: ?*u16, riid_: ?*const Guid, ppunk_: ?*?*IUnknown) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMember(@as(*const DataSource, @ptrCast(self)), bstr_d_m_, riid_, ppunk_);
            }
            pub inline fn getDataMemberName(self: *const T, l_index_: i32, pbstr_d_m_: ?*?*u16) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMemberName(@as(*const DataSource, @ptrCast(self)), l_index_, pbstr_d_m_);
            }
            pub inline fn getDataMemberCount(self: *const T, pl_count_: ?*i32) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).getDataMemberCount(@as(*const DataSource, @ptrCast(self)), pl_count_);
            }
            pub inline fn addDataSourceListener(self: *const T, p_d_s_l_: ?*DataSourceListener) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).addDataSourceListener(@as(*const DataSource, @ptrCast(self)), p_d_s_l_);
            }
            pub inline fn removeDataSourceListener(self: *const T, p_d_s_l_: ?*DataSourceListener) HRESULT {
                return @as(*const DataSource.VTable, @ptrCast(self.vtable)).removeDataSourceListener(@as(*const DataSource, @ptrCast(self)), p_d_s_l_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OSPFORMAT = enum(i32) {
    RAW = 0,
    // DEFAULT = 0, this enum value conflicts with RAW
    FORMATTED = 1,
    HTML = 2,
};
pub const OSPFORMAT_RAW = OSPFORMAT.RAW;
pub const OSPFORMAT_DEFAULT = OSPFORMAT.RAW;
pub const OSPFORMAT_FORMATTED = OSPFORMAT.FORMATTED;
pub const OSPFORMAT_HTML = OSPFORMAT.HTML;

pub const OSPRW = enum(i32) {
    DEFAULT = 1,
    READONLY = 0,
    // READWRITE = 1, this enum value conflicts with DEFAULT
    MIXED = 2,
};
pub const OSPRW_DEFAULT = OSPRW.DEFAULT;
pub const OSPRW_READONLY = OSPRW.READONLY;
pub const OSPRW_READWRITE = OSPRW.DEFAULT;
pub const OSPRW_MIXED = OSPRW.MIXED;

pub const OSPFIND = enum(i32) {
    DEFAULT = 0,
    UP = 1,
    CASESENSITIVE = 2,
    UPCASESENSITIVE = 3,
};
pub const OSPFIND_DEFAULT = OSPFIND.DEFAULT;
pub const OSPFIND_UP = OSPFIND.UP;
pub const OSPFIND_CASESENSITIVE = OSPFIND.CASESENSITIVE;
pub const OSPFIND_UPCASESENSITIVE = OSPFIND.UPCASESENSITIVE;

pub const OSPCOMP = enum(i32) {
    EQ = 1,
    // DEFAULT = 1, this enum value conflicts with EQ
    LT = 2,
    LE = 3,
    GE = 4,
    GT = 5,
    NE = 6,
};
pub const OSPCOMP_EQ = OSPCOMP.EQ;
pub const OSPCOMP_DEFAULT = OSPCOMP.EQ;
pub const OSPCOMP_LT = OSPCOMP.LT;
pub const OSPCOMP_LE = OSPCOMP.LE;
pub const OSPCOMP_GE = OSPCOMP.GE;
pub const OSPCOMP_GT = OSPCOMP.GT;
pub const OSPCOMP_NE = OSPCOMP.NE;

pub const OSPXFER = enum(i32) {
    COMPLETE = 0,
    ABORT = 1,
    ERROR = 2,
};
pub const OSPXFER_COMPLETE = OSPXFER.COMPLETE;
pub const OSPXFER_ABORT = OSPXFER.ABORT;
pub const OSPXFER_ERROR = OSPXFER.ERROR;

const IID_OLEDBSimpleProviderListener_Value = Guid.initString("e0e270c1-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProviderListener = &IID_OLEDBSimpleProviderListener_Value;
pub const OLEDBSimpleProviderListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        aboutToChangeCell: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            i_column: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cellChanged: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            i_column: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        aboutToDeleteRows: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deletedRows: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        aboutToInsertRows: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertedRows: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rowsAvailable: *const fn (
            self: *const OLEDBSimpleProviderListener,
            i_row: isize,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transferComplete: *const fn (
            self: *const OLEDBSimpleProviderListener,
            xfer: OSPXFER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn aboutToChangeCell(self: *const T, i_row_: isize, i_column_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToChangeCell(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, i_column_);
            }
            pub inline fn cellChanged(self: *const T, i_row_: isize, i_column_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).cellChanged(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, i_column_);
            }
            pub inline fn aboutToDeleteRows(self: *const T, i_row_: isize, c_rows_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToDeleteRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, c_rows_);
            }
            pub inline fn deletedRows(self: *const T, i_row_: isize, c_rows_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).deletedRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, c_rows_);
            }
            pub inline fn aboutToInsertRows(self: *const T, i_row_: isize, c_rows_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).aboutToInsertRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, c_rows_);
            }
            pub inline fn insertedRows(self: *const T, i_row_: isize, c_rows_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).insertedRows(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, c_rows_);
            }
            pub inline fn rowsAvailable(self: *const T, i_row_: isize, c_rows_: isize) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).rowsAvailable(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), i_row_, c_rows_);
            }
            pub inline fn transferComplete(self: *const T, xfer_: OSPXFER) HRESULT {
                return @as(*const OLEDBSimpleProviderListener.VTable, @ptrCast(self.vtable)).transferComplete(@as(*const OLEDBSimpleProviderListener, @ptrCast(self)), xfer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_OLEDBSimpleProvider_Value = Guid.initString("e0e270c0-c0be-11d0-8fe4-00a0c90a6341");
pub const IID_OLEDBSimpleProvider = &IID_OLEDBSimpleProvider_Value;
pub const OLEDBSimpleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getRowCount: *const fn (
            self: *const OLEDBSimpleProvider,
            pc_rows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getColumnCount: *const fn (
            self: *const OLEDBSimpleProvider,
            pc_columns: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRWStatus: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row: isize,
            i_column: isize,
            prw_status: ?*OSPRW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getVariant: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row: isize,
            i_column: isize,
            format: OSPFORMAT,
            p_var: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setVariant: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row: isize,
            i_column: isize,
            format: OSPFORMAT,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getLocale: *const fn (
            self: *const OLEDBSimpleProvider,
            pbstr_locale: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRows: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row: isize,
            c_rows: isize,
            pc_rows_deleted: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRows: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row: isize,
            c_rows: isize,
            pc_rows_inserted: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        find: *const fn (
            self: *const OLEDBSimpleProvider,
            i_row_start: isize,
            i_column: isize,
            val: VARIANT,
            find_flags: OSPFIND,
            comp_type: OSPCOMP,
            pi_row_found: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addOLEDBSimpleProviderListener: *const fn (
            self: *const OLEDBSimpleProvider,
            posp_i_listener: ?*OLEDBSimpleProviderListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeOLEDBSimpleProviderListener: *const fn (
            self: *const OLEDBSimpleProvider,
            posp_i_listener: ?*OLEDBSimpleProviderListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isAsync: *const fn (
            self: *const OLEDBSimpleProvider,
            pb_asynch: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEstimatedRows: *const fn (
            self: *const OLEDBSimpleProvider,
            pi_rows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopTransfer: *const fn (
            self: *const OLEDBSimpleProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRowCount(self: *const T, pc_rows_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getRowCount(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pc_rows_);
            }
            pub inline fn getColumnCount(self: *const T, pc_columns_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getColumnCount(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pc_columns_);
            }
            pub inline fn getRWStatus(self: *const T, i_row_: isize, i_column_: isize, prw_status_: ?*OSPRW) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getRWStatus(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_, i_column_, prw_status_);
            }
            pub inline fn getVariant(self: *const T, i_row_: isize, i_column_: isize, format_: OSPFORMAT, p_var_: ?*VARIANT) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getVariant(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_, i_column_, format_, p_var_);
            }
            pub inline fn setVariant(self: *const T, i_row_: isize, i_column_: isize, format_: OSPFORMAT, var_: VARIANT) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).setVariant(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_, i_column_, format_, var_);
            }
            pub inline fn getLocale(self: *const T, pbstr_locale_: ?*?BSTR) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getLocale(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pbstr_locale_);
            }
            pub inline fn deleteRows(self: *const T, i_row_: isize, c_rows_: isize, pc_rows_deleted_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).deleteRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_, c_rows_, pc_rows_deleted_);
            }
            pub inline fn insertRows(self: *const T, i_row_: isize, c_rows_: isize, pc_rows_inserted_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).insertRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_, c_rows_, pc_rows_inserted_);
            }
            pub inline fn find(self: *const T, i_row_start_: isize, i_column_: isize, val_: VARIANT, find_flags_: OSPFIND, comp_type_: OSPCOMP, pi_row_found_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).find(@as(*const OLEDBSimpleProvider, @ptrCast(self)), i_row_start_, i_column_, val_, find_flags_, comp_type_, pi_row_found_);
            }
            pub inline fn addOLEDBSimpleProviderListener(self: *const T, posp_i_listener_: ?*OLEDBSimpleProviderListener) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).addOLEDBSimpleProviderListener(@as(*const OLEDBSimpleProvider, @ptrCast(self)), posp_i_listener_);
            }
            pub inline fn removeOLEDBSimpleProviderListener(self: *const T, posp_i_listener_: ?*OLEDBSimpleProviderListener) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).removeOLEDBSimpleProviderListener(@as(*const OLEDBSimpleProvider, @ptrCast(self)), posp_i_listener_);
            }
            pub inline fn isAsync(self: *const T, pb_asynch_: ?*BOOL) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).isAsync(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pb_asynch_);
            }
            pub inline fn getEstimatedRows(self: *const T, pi_rows_: ?*isize) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).getEstimatedRows(@as(*const OLEDBSimpleProvider, @ptrCast(self)), pi_rows_);
            }
            pub inline fn stopTransfer(self: *const T) HRESULT {
                return @as(*const OLEDBSimpleProvider.VTable, @ptrCast(self.vtable)).stopTransfer(@as(*const OLEDBSimpleProvider, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DataSourceObject_Value = Guid.initString("0ae9a4e4-18d4-11d1-b3b3-00aa00c1a924");
pub const IID_DataSourceObject = &IID_DataSourceObject_Value;
pub const DataSourceObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DataLinks_Value = Guid.initString("2206cdb2-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_DataLinks = &CLSID_DataLinks_Value;

const CLSID_MSDAINITIALIZE_Value = Guid.initString("2206cdb0-19c1-11d1-89e0-00c04fd7a829");
pub const CLSID_MSDAINITIALIZE = &CLSID_MSDAINITIALIZE_Value;

const CLSID_PDPO_Value = Guid.initString("ccb4ec60-b9dc-11d1-ac80-00a0c9034873");
pub const CLSID_PDPO = &CLSID_PDPO_Value;

const CLSID_RootBinder_Value = Guid.initString("ff151822-b0bf-11d1-a80d-000000000000");
pub const CLSID_RootBinder = &CLSID_RootBinder_Value;

pub const EBindInfoOptions = enum(i32) {
    R = 1,
};
pub const BIO_BINDER = EBindInfoOptions.R;

const IID_IService_Value = Guid.initString("06210e88-01f5-11d1-b512-0080c781c384");
pub const IID_IService = &IID_IService_Value;
pub const IService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeService: *const fn (
            self: *const IService,
            p_unk_inner: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn invokeService(self: *const T, p_unk_inner_: ?*IUnknown) HRESULT {
                return @as(*const IService.VTable, @ptrCast(self.vtable)).InvokeService(@as(*const IService, @ptrCast(self)), p_unk_inner_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBPROMPTOPTIONSENUM = enum(i32) {
    NONE = 0,
    WIZARDSHEET = 1,
    PROPERTYSHEET = 2,
    BROWSEONLY = 8,
    DISABLE_PROVIDER_SELECTION = 16,
    DISABLESAVEPASSWORD = 32,
};
pub const DBPROMPTOPTIONS_NONE = DBPROMPTOPTIONSENUM.NONE;
pub const DBPROMPTOPTIONS_WIZARDSHEET = DBPROMPTOPTIONSENUM.WIZARDSHEET;
pub const DBPROMPTOPTIONS_PROPERTYSHEET = DBPROMPTOPTIONSENUM.PROPERTYSHEET;
pub const DBPROMPTOPTIONS_BROWSEONLY = DBPROMPTOPTIONSENUM.BROWSEONLY;
pub const DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION = DBPROMPTOPTIONSENUM.DISABLE_PROVIDER_SELECTION;
pub const DBPROMPTOPTIONS_DISABLESAVEPASSWORD = DBPROMPTOPTIONSENUM.DISABLESAVEPASSWORD;

const IID_IDBPromptInitialize_Value = Guid.initString("2206ccb0-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDBPromptInitialize = &IID_IDBPromptInitialize_Value;
pub const IDBPromptInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PromptDataSource: *const fn (
            self: *const IDBPromptInitialize,
            p_unk_outer: ?*IUnknown,
            h_wnd_parent: ?HWND,
            dw_prompt_options: u32,
            c_source_type_filter: u32,
            rg_source_type_filter: ?[*]u32,
            pwszszz_provider_filter: ?[*:0]const u16,
            riid: ?*const Guid,
            pp_data_source: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptFileName: *const fn (
            self: *const IDBPromptInitialize,
            h_wnd_parent: ?HWND,
            dw_prompt_options: u32,
            pwsz_initial_directory: ?[*:0]const u16,
            pwsz_initial_file: ?[*:0]const u16,
            ppwsz_selected_file: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn promptDataSource(self: *const T, p_unk_outer_: ?*IUnknown, h_wnd_parent_: ?HWND, dw_prompt_options_: u32, c_source_type_filter_: u32, rg_source_type_filter_: ?[*]u32, pwszszz_provider_filter_: ?[*:0]const u16, riid_: ?*const Guid, pp_data_source_: ?*?*IUnknown) HRESULT {
                return @as(*const IDBPromptInitialize.VTable, @ptrCast(self.vtable)).PromptDataSource(@as(*const IDBPromptInitialize, @ptrCast(self)), p_unk_outer_, h_wnd_parent_, dw_prompt_options_, c_source_type_filter_, rg_source_type_filter_, pwszszz_provider_filter_, riid_, pp_data_source_);
            }
            pub inline fn promptFileName(self: *const T, h_wnd_parent_: ?HWND, dw_prompt_options_: u32, pwsz_initial_directory_: ?[*:0]const u16, pwsz_initial_file_: ?[*:0]const u16, ppwsz_selected_file_: ?*?PWSTR) HRESULT {
                return @as(*const IDBPromptInitialize.VTable, @ptrCast(self.vtable)).PromptFileName(@as(*const IDBPromptInitialize, @ptrCast(self)), h_wnd_parent_, dw_prompt_options_, pwsz_initial_directory_, pwsz_initial_file_, ppwsz_selected_file_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataInitialize_Value = Guid.initString("2206ccb1-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataInitialize = &IID_IDataInitialize_Value;
pub const IDataInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: *const fn (
            self: *const IDataInitialize,
            p_unk_outer: ?*IUnknown,
            dw_cls_ctx: u32,
            pwsz_initialization_string: ?[*:0]const u16,
            riid: ?*const Guid,
            pp_data_source: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInitializationString: *const fn (
            self: *const IDataInitialize,
            p_data_source: ?*IUnknown,
            f_include_password: u8,
            ppwsz_init_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDBInstance: *const fn (
            self: *const IDataInitialize,
            clsid_provider: ?*const Guid,
            p_unk_outer: ?*IUnknown,
            dw_cls_ctx: u32,
            pwsz_reserved: ?PWSTR,
            riid: ?*const Guid,
            pp_data_source: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDBInstanceEx: *const fn (
            self: *const IDataInitialize,
            clsid_provider: ?*const Guid,
            p_unk_outer: ?*IUnknown,
            dw_cls_ctx: u32,
            pwsz_reserved: ?PWSTR,
            p_server_info: ?*COSERVERINFO,
            cmq: u32,
            rgmq_results: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadStringFromStorage: *const fn (
            self: *const IDataInitialize,
            pwsz_file_name: ?[*:0]const u16,
            ppwsz_initialization_string: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStringToStorage: *const fn (
            self: *const IDataInitialize,
            pwsz_file_name: ?[*:0]const u16,
            pwsz_initialization_string: ?[*:0]const u16,
            dw_creation_disposition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDataSource(self: *const T, p_unk_outer_: ?*IUnknown, dw_cls_ctx_: u32, pwsz_initialization_string_: ?[*:0]const u16, riid_: ?*const Guid, pp_data_source_: ?*?*IUnknown) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).GetDataSource(@as(*const IDataInitialize, @ptrCast(self)), p_unk_outer_, dw_cls_ctx_, pwsz_initialization_string_, riid_, pp_data_source_);
            }
            pub inline fn getInitializationString(self: *const T, p_data_source_: ?*IUnknown, f_include_password_: u8, ppwsz_init_string_: ?*?PWSTR) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).GetInitializationString(@as(*const IDataInitialize, @ptrCast(self)), p_data_source_, f_include_password_, ppwsz_init_string_);
            }
            pub inline fn createDBInstance(self: *const T, clsid_provider_: ?*const Guid, p_unk_outer_: ?*IUnknown, dw_cls_ctx_: u32, pwsz_reserved_: ?PWSTR, riid_: ?*const Guid, pp_data_source_: ?*?*IUnknown) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).CreateDBInstance(@as(*const IDataInitialize, @ptrCast(self)), clsid_provider_, p_unk_outer_, dw_cls_ctx_, pwsz_reserved_, riid_, pp_data_source_);
            }
            pub inline fn createDBInstanceEx(self: *const T, clsid_provider_: ?*const Guid, p_unk_outer_: ?*IUnknown, dw_cls_ctx_: u32, pwsz_reserved_: ?PWSTR, p_server_info_: ?*COSERVERINFO, cmq_: u32, rgmq_results_: [*]MULTI_QI) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).CreateDBInstanceEx(@as(*const IDataInitialize, @ptrCast(self)), clsid_provider_, p_unk_outer_, dw_cls_ctx_, pwsz_reserved_, p_server_info_, cmq_, rgmq_results_);
            }
            pub inline fn loadStringFromStorage(self: *const T, pwsz_file_name_: ?[*:0]const u16, ppwsz_initialization_string_: ?*?PWSTR) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).LoadStringFromStorage(@as(*const IDataInitialize, @ptrCast(self)), pwsz_file_name_, ppwsz_initialization_string_);
            }
            pub inline fn writeStringToStorage(self: *const T, pwsz_file_name_: ?[*:0]const u16, pwsz_initialization_string_: ?[*:0]const u16, dw_creation_disposition_: u32) HRESULT {
                return @as(*const IDataInitialize.VTable, @ptrCast(self.vtable)).WriteStringToStorage(@as(*const IDataInitialize, @ptrCast(self)), pwsz_file_name_, pwsz_initialization_string_, dw_creation_disposition_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataSourceLocator_Value = Guid.initString("2206ccb2-19c1-11d1-89e0-00c04fd7a829");
pub const IID_IDataSourceLocator = &IID_IDataSourceLocator_Value;
pub const IDataSourceLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDataSourceLocator,
            phwnd_parent: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hWnd: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDataSourceLocator,
            hwnd_parent: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptNew: *const fn (
            self: *const IDataSourceLocator,
            pp_a_d_o_connection: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PromptEdit: *const fn (
            self: *const IDataSourceLocator,
            pp_a_d_o_connection: ?*?*IDispatch,
            pb_success: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getHWnd(self: *const T, phwnd_parent_: ?*i64) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).get_hWnd(@as(*const IDataSourceLocator, @ptrCast(self)), phwnd_parent_);
            }
            pub inline fn putHWnd(self: *const T, hwnd_parent_: i64) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).put_hWnd(@as(*const IDataSourceLocator, @ptrCast(self)), hwnd_parent_);
            }
            pub inline fn promptNew(self: *const T, pp_a_d_o_connection_: ?*?*IDispatch) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).PromptNew(@as(*const IDataSourceLocator, @ptrCast(self)), pp_a_d_o_connection_);
            }
            pub inline fn promptEdit(self: *const T, pp_a_d_o_connection_: ?*?*IDispatch, pb_success_: ?*i16) HRESULT {
                return @as(*const IDataSourceLocator.VTable, @ptrCast(self.vtable)).PromptEdit(@as(*const IDataSourceLocator, @ptrCast(self)), pp_a_d_o_connection_, pb_success_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KAGREQDIAGFLAGSENUM = enum(i32) {
    HEADER = 1,
    RECORD = 2,
};
pub const KAGREQDIAGFLAGS_HEADER = KAGREQDIAGFLAGSENUM.HEADER;
pub const KAGREQDIAGFLAGS_RECORD = KAGREQDIAGFLAGSENUM.RECORD;

const IID_IRowsetChangeExtInfo_Value = Guid.initString("0c733a8f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetChangeExtInfo = &IID_IRowsetChangeExtInfo_Value;
pub const IRowsetChangeExtInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOriginalRow: *const fn (
            self: *const IRowsetChangeExtInfo,
            h_reserved: usize,
            h_row: usize,
            ph_row_original: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPendingColumns: *const fn (
            self: *const IRowsetChangeExtInfo,
            h_reserved: usize,
            h_row: usize,
            c_column_ordinals: u32,
            rgi_ordinals: ?*const u32,
            rg_column_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getOriginalRow(self: *const T, h_reserved_: usize, h_row_: usize, ph_row_original_: ?*usize) HRESULT {
                return @as(*const IRowsetChangeExtInfo.VTable, @ptrCast(self.vtable)).GetOriginalRow(@as(*const IRowsetChangeExtInfo, @ptrCast(self)), h_reserved_, h_row_, ph_row_original_);
            }
            pub inline fn getPendingColumns(self: *const T, h_reserved_: usize, h_row_: usize, c_column_ordinals_: u32, rgi_ordinals_: ?*const u32, rg_column_status_: ?*u32) HRESULT {
                return @as(*const IRowsetChangeExtInfo.VTable, @ptrCast(self.vtable)).GetPendingColumns(@as(*const IRowsetChangeExtInfo, @ptrCast(self)), h_reserved_, h_row_, c_column_ordinals_, rgi_ordinals_, rg_column_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KAGREQDIAG = extern struct {
    ulDiagFlags: u32,
    vt: u16,
    sDiagField: i16,
};

pub const KAGGETDIAG = extern struct {
    ulSize: u32,
    vDiagInfo: VARIANT,
    sDiagField: i16,
};

const IID_ISQLRequestDiagFields_Value = Guid.initString("228972f0-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLRequestDiagFields = &IID_ISQLRequestDiagFields_Value;
pub const ISQLRequestDiagFields = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestDiagFields: *const fn (
            self: *const ISQLRequestDiagFields,
            c_diag_fields: u32,
            rg_diag_fields: [*]KAGREQDIAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn requestDiagFields(self: *const T, c_diag_fields_: u32, rg_diag_fields_: [*]KAGREQDIAG) HRESULT {
                return @as(*const ISQLRequestDiagFields.VTable, @ptrCast(self.vtable)).RequestDiagFields(@as(*const ISQLRequestDiagFields, @ptrCast(self)), c_diag_fields_, rg_diag_fields_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISQLGetDiagField_Value = Guid.initString("228972f1-b5ff-11d0-8a80-00c04fd611cd");
pub const IID_ISQLGetDiagField = &IID_ISQLGetDiagField_Value;
pub const ISQLGetDiagField = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiagField: *const fn (
            self: *const ISQLGetDiagField,
            p_diag_info: ?*KAGGETDIAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDiagField(self: *const T, p_diag_info_: ?*KAGGETDIAG) HRESULT {
                return @as(*const ISQLGetDiagField.VTable, @ptrCast(self.vtable)).GetDiagField(@as(*const ISQLGetDiagField, @ptrCast(self)), p_diag_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSDSDBINITPROPENUM = enum(i32) {
    R = 2,
};
pub const DBPROP_MSDS_DBINIT_DATAPROVIDER = MSDSDBINITPROPENUM.R;

pub const MSDSSESSIONPROPENUM = enum(i32) {
    S = 2,
};
pub const DBPROP_MSDS_SESS_UNIQUENAMES = MSDSSESSIONPROPENUM.S;

pub const DATE_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const TIME_STRUCT = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const TIMESTAMP_STRUCT = extern struct {
    year: i16,
    month: u16,
    day: u16,
    hour: u16,
    minute: u16,
    second: u16,
    fraction: u32,
};

pub const SQLINTERVAL = enum(i32) {
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
    HOUR = 4,
    MINUTE = 5,
    SECOND = 6,
    YEAR_TO_MONTH = 7,
    DAY_TO_HOUR = 8,
    DAY_TO_MINUTE = 9,
    DAY_TO_SECOND = 10,
    HOUR_TO_MINUTE = 11,
    HOUR_TO_SECOND = 12,
    MINUTE_TO_SECOND = 13,
};
pub const SQL_IS_YEAR = SQLINTERVAL.YEAR;
pub const SQL_IS_MONTH = SQLINTERVAL.MONTH;
pub const SQL_IS_DAY = SQLINTERVAL.DAY;
pub const SQL_IS_HOUR = SQLINTERVAL.HOUR;
pub const SQL_IS_MINUTE = SQLINTERVAL.MINUTE;
pub const SQL_IS_SECOND = SQLINTERVAL.SECOND;
pub const SQL_IS_YEAR_TO_MONTH = SQLINTERVAL.YEAR_TO_MONTH;
pub const SQL_IS_DAY_TO_HOUR = SQLINTERVAL.DAY_TO_HOUR;
pub const SQL_IS_DAY_TO_MINUTE = SQLINTERVAL.DAY_TO_MINUTE;
pub const SQL_IS_DAY_TO_SECOND = SQLINTERVAL.DAY_TO_SECOND;
pub const SQL_IS_HOUR_TO_MINUTE = SQLINTERVAL.HOUR_TO_MINUTE;
pub const SQL_IS_HOUR_TO_SECOND = SQLINTERVAL.HOUR_TO_SECOND;
pub const SQL_IS_MINUTE_TO_SECOND = SQLINTERVAL.MINUTE_TO_SECOND;

pub const tagSQL_YEAR_MONTH = extern struct {
    year: u32,
    month: u32,
};

pub const tagSQL_DAY_SECOND = extern struct {
    day: u32,
    hour: u32,
    minute: u32,
    second: u32,
    fraction: u32,
};

pub const SQL_INTERVAL_STRUCT = extern struct {
    interval_type: SQLINTERVAL,
    interval_sign: i16,
    intval: extern union {
        year_month: tagSQL_YEAR_MONTH,
        day_second: tagSQL_DAY_SECOND,
    },
};

pub const SQL_NUMERIC_STRUCT = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [16]u8,
};

pub const dbvarychar = extern struct {
    len: i16,
    str: [8001]i8,
};

pub const dbvarybin = extern struct {
    len: i16,
    array: [8001]u8,
};

pub const dbmoney = extern struct {
    mnyhigh: i32,
    mnylow: u32,
};

pub const dbdatetime = extern struct {
    dtdays: i32,
    dttime: u32,
};

pub const dbdatetime4 = extern struct {
    numdays: u16,
    nummins: u16,
};

pub const sqlperf = extern struct {
    TimerResolution: u32,
    SQLidu: u32,
    SQLiduRows: u32,
    SQLSelects: u32,
    SQLSelectRows: u32,
    Transactions: u32,
    SQLPrepares: u32,
    ExecDirects: u32,
    SQLExecutes: u32,
    CursorOpens: u32,
    CursorSize: u32,
    CursorUsed: u32,
    PercentCursorUsed: f64,
    AvgFetchTime: f64,
    AvgCursorSize: f64,
    AvgCursorUsed: f64,
    SQLFetchTime: u32,
    SQLFetchCount: u32,
    CurrentStmtCount: u32,
    MaxOpenStmt: u32,
    SumOpenStmt: u32,
    CurrentConnectionCount: u32,
    MaxConnectionsOpened: u32,
    SumConnectionsOpened: u32,
    SumConnectiontime: u32,
    AvgTimeOpened: f64,
    ServerRndTrips: u32,
    BuffersSent: u32,
    BuffersRec: u32,
    BytesSent: u32,
    BytesRec: u32,
    msExecutionTime: u32,
    msNetWorkServerTime: u32,
};

pub const DBPROPENUM25_DEPRECATED = enum(i32) {
    CommandCost = 141,
    CommandTree = 142,
    CommandValidate = 143,
    DBSchemaCommand = 144,
    ProvideMoniker = 125,
    Query = 146,
    ReadData = 147,
    RowsetAsynch = 148,
    RowsetCopyRows = 149,
    RowsetKeys = 151,
    RowsetNewRowAfter = 152,
    RowsetNextRowset = 153,
    RowsetWatchAll = 155,
    RowsetWatchNotify = 156,
    RowsetWatchRegion = 157,
    RowsetWithParameters = 158,
};
pub const DBPROP_ICommandCost = DBPROPENUM25_DEPRECATED.CommandCost;
pub const DBPROP_ICommandTree = DBPROPENUM25_DEPRECATED.CommandTree;
pub const DBPROP_ICommandValidate = DBPROPENUM25_DEPRECATED.CommandValidate;
pub const DBPROP_IDBSchemaCommand = DBPROPENUM25_DEPRECATED.DBSchemaCommand;
pub const DBPROP_IProvideMoniker = DBPROPENUM25_DEPRECATED.ProvideMoniker;
pub const DBPROP_IQuery = DBPROPENUM25_DEPRECATED.Query;
pub const DBPROP_IReadData = DBPROPENUM25_DEPRECATED.ReadData;
pub const DBPROP_IRowsetAsynch = DBPROPENUM25_DEPRECATED.RowsetAsynch;
pub const DBPROP_IRowsetCopyRows = DBPROPENUM25_DEPRECATED.RowsetCopyRows;
pub const DBPROP_IRowsetKeys = DBPROPENUM25_DEPRECATED.RowsetKeys;
pub const DBPROP_IRowsetNewRowAfter = DBPROPENUM25_DEPRECATED.RowsetNewRowAfter;
pub const DBPROP_IRowsetNextRowset = DBPROPENUM25_DEPRECATED.RowsetNextRowset;
pub const DBPROP_IRowsetWatchAll = DBPROPENUM25_DEPRECATED.RowsetWatchAll;
pub const DBPROP_IRowsetWatchNotify = DBPROPENUM25_DEPRECATED.RowsetWatchNotify;
pub const DBPROP_IRowsetWatchRegion = DBPROPENUM25_DEPRECATED.RowsetWatchRegion;
pub const DBPROP_IRowsetWithParameters = DBPROPENUM25_DEPRECATED.RowsetWithParameters;

pub const DBREASONENUM25 = enum(i32) {
    ROWSADDED = 19,
    POPULATIONCOMPLETE = 20,
    POPULATIONSTOPPED = 21,
};
pub const DBREASON_ROWSET_ROWSADDED = DBREASONENUM25.ROWSADDED;
pub const DBREASON_ROWSET_POPULATIONCOMPLETE = DBREASONENUM25.POPULATIONCOMPLETE;
pub const DBREASON_ROWSET_POPULATIONSTOPPED = DBREASONENUM25.POPULATIONSTOPPED;

const IID_IRowsetNextRowset_Value = Guid.initString("0c733a72-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNextRowset = &IID_IRowsetNextRowset_Value;
pub const IRowsetNextRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextRowset: *const fn (
            self: *const IRowsetNextRowset,
            p_unk_outer: ?*IUnknown,
            riid: ?*const Guid,
            pp_next_rowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNextRowset(self: *const T, p_unk_outer_: ?*IUnknown, riid_: ?*const Guid, pp_next_rowset_: ?*?*IUnknown) HRESULT {
                return @as(*const IRowsetNextRowset.VTable, @ptrCast(self.vtable)).GetNextRowset(@as(*const IRowsetNextRowset, @ptrCast(self)), p_unk_outer_, riid_, pp_next_rowset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetNewRowAfter_Value = Guid.initString("0c733a71-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetNewRowAfter = &IID_IRowsetNewRowAfter_Value;
pub const IRowsetNewRowAfter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNewDataAfter: *const fn (
            self: *const IRowsetNewRowAfter,
            h_chapter: usize,
            cbbm_previous: u32,
            pbm_previous: ?*const u8,
            h_accessor: usize,
            p_data: ?*u8,
            ph_row: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setNewDataAfter(self: *const T, h_chapter_: usize, cbbm_previous_: u32, pbm_previous_: ?*const u8, h_accessor_: usize, p_data_: ?*u8, ph_row_: ?*usize) HRESULT {
                return @as(*const IRowsetNewRowAfter.VTable, @ptrCast(self.vtable)).SetNewDataAfter(@as(*const IRowsetNewRowAfter, @ptrCast(self)), h_chapter_, cbbm_previous_, pbm_previous_, h_accessor_, p_data_, ph_row_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetWithParameters_Value = Guid.initString("0c733a6e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWithParameters = &IID_IRowsetWithParameters_Value;
pub const IRowsetWithParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: *const fn (
            self: *const IRowsetWithParameters,
            pc_params: ?*usize,
            prg_param_info: ?*?*DBPARAMINFO,
            pp_names_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Requery: *const fn (
            self: *const IRowsetWithParameters,
            p_params: ?*DBPARAMS,
            pul_error_param: ?*u32,
            ph_reserved: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getParameterInfo(self: *const T, pc_params_: ?*usize, prg_param_info_: ?*?*DBPARAMINFO, pp_names_buffer_: ?*?*u16) HRESULT {
                return @as(*const IRowsetWithParameters.VTable, @ptrCast(self.vtable)).GetParameterInfo(@as(*const IRowsetWithParameters, @ptrCast(self)), pc_params_, prg_param_info_, pp_names_buffer_);
            }
            pub inline fn requery(self: *const T, p_params_: ?*DBPARAMS, pul_error_param_: ?*u32, ph_reserved_: ?*usize) HRESULT {
                return @as(*const IRowsetWithParameters.VTable, @ptrCast(self.vtable)).Requery(@as(*const IRowsetWithParameters, @ptrCast(self)), p_params_, pul_error_param_, ph_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetAsynch_Value = Guid.initString("0c733a0f-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetAsynch = &IID_IRowsetAsynch_Value;
pub const IRowsetAsynch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RatioFinished: *const fn (
            self: *const IRowsetAsynch,
            pul_denominator: ?*usize,
            pul_numerator: ?*usize,
            pc_rows: ?*usize,
            pf_new_rows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IRowsetAsynch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn ratioFinished(self: *const T, pul_denominator_: ?*usize, pul_numerator_: ?*usize, pc_rows_: ?*usize, pf_new_rows_: ?*BOOL) HRESULT {
                return @as(*const IRowsetAsynch.VTable, @ptrCast(self.vtable)).RatioFinished(@as(*const IRowsetAsynch, @ptrCast(self)), pul_denominator_, pul_numerator_, pc_rows_, pf_new_rows_);
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IRowsetAsynch.VTable, @ptrCast(self.vtable)).Stop(@as(*const IRowsetAsynch, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetKeys_Value = Guid.initString("0c733a12-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetKeys = &IID_IRowsetKeys_Value;
pub const IRowsetKeys = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ListKeys: *const fn (
            self: *const IRowsetKeys,
            pc_columns: ?*usize,
            prg_columns: ?*?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn listKeys(self: *const T, pc_columns_: ?*usize, prg_columns_: ?*?*usize) HRESULT {
                return @as(*const IRowsetKeys.VTable, @ptrCast(self.vtable)).ListKeys(@as(*const IRowsetKeys, @ptrCast(self)), pc_columns_, prg_columns_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetWatchAll_Value = Guid.initString("0c733a73-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchAll = &IID_IRowsetWatchAll_Value;
pub const IRowsetWatchAll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Acknowledge: *const fn (
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: *const fn (
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopWatching: *const fn (
            self: *const IRowsetWatchAll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn acknowledge(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).Acknowledge(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).Start(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
            pub inline fn stopWatching(self: *const T) HRESULT {
                return @as(*const IRowsetWatchAll.VTable, @ptrCast(self.vtable)).StopWatching(@as(*const IRowsetWatchAll, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBWATCHNOTIFYENUM = enum(i32) {
    ROWSCHANGED = 1,
    QUERYDONE = 2,
    QUERYREEXECUTED = 3,
};
pub const DBWATCHNOTIFY_ROWSCHANGED = DBWATCHNOTIFYENUM.ROWSCHANGED;
pub const DBWATCHNOTIFY_QUERYDONE = DBWATCHNOTIFYENUM.QUERYDONE;
pub const DBWATCHNOTIFY_QUERYREEXECUTED = DBWATCHNOTIFYENUM.QUERYREEXECUTED;

const IID_IRowsetWatchNotify_Value = Guid.initString("0c733a44-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchNotify = &IID_IRowsetWatchNotify_Value;
pub const IRowsetWatchNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: *const fn (
            self: *const IRowsetWatchNotify,
            p_rowset: ?*IRowset,
            e_change_reason: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onChange(self: *const T, p_rowset_: ?*IRowset, e_change_reason_: u32) HRESULT {
                return @as(*const IRowsetWatchNotify.VTable, @ptrCast(self.vtable)).OnChange(@as(*const IRowsetWatchNotify, @ptrCast(self)), p_rowset_, e_change_reason_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBWATCHMODEENUM = enum(i32) {
    ALL = 1,
    EXTEND = 2,
    MOVE = 4,
    COUNT = 8,
};
pub const DBWATCHMODE_ALL = DBWATCHMODEENUM.ALL;
pub const DBWATCHMODE_EXTEND = DBWATCHMODEENUM.EXTEND;
pub const DBWATCHMODE_MOVE = DBWATCHMODEENUM.MOVE;
pub const DBWATCHMODE_COUNT = DBWATCHMODEENUM.COUNT;

pub const DBROWCHANGEKINDENUM = enum(i32) {
    INSERT = 0,
    DELETE = 1,
    UPDATE = 2,
    COUNT = 3,
};
pub const DBROWCHANGEKIND_INSERT = DBROWCHANGEKINDENUM.INSERT;
pub const DBROWCHANGEKIND_DELETE = DBROWCHANGEKINDENUM.DELETE;
pub const DBROWCHANGEKIND_UPDATE = DBROWCHANGEKINDENUM.UPDATE;
pub const DBROWCHANGEKIND_COUNT = DBROWCHANGEKINDENUM.COUNT;

const IID_IRowsetWatchRegion_Value = Guid.initString("0c733a45-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetWatchRegion = &IID_IRowsetWatchRegion_Value;
pub const IRowsetWatchRegion = extern struct {
    pub const VTable = extern struct {
        base: IRowsetWatchAll.VTable,
        CreateWatchRegion: *const fn (
            self: *const IRowsetWatchRegion,
            dw_watch_mode: u32,
            ph_region: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeWatchMode: *const fn (
            self: *const IRowsetWatchRegion,
            h_region: usize,
            dw_watch_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteWatchRegion: *const fn (
            self: *const IRowsetWatchRegion,
            h_region: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWatchRegionInfo: *const fn (
            self: *const IRowsetWatchRegion,
            h_region: usize,
            pdw_watch_mode: ?*u32,
            ph_chapter: ?*usize,
            pcb_bookmark: ?*usize,
            pp_bookmark: ?*?*u8,
            pc_rows: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: *const fn (
            self: *const IRowsetWatchRegion,
            pc_changes_obtained: ?*usize,
            prg_changes: ?*?*tagDBROWWATCHRANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShrinkWatchRegion: *const fn (
            self: *const IRowsetWatchRegion,
            h_region: usize,
            h_chapter: usize,
            cb_bookmark: usize,
            p_bookmark: ?*u8,
            c_rows: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRowsetWatchAll.MethodMixin(T);
            pub inline fn createWatchRegion(self: *const T, dw_watch_mode_: u32, ph_region_: ?*usize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).CreateWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), dw_watch_mode_, ph_region_);
            }
            pub inline fn changeWatchMode(self: *const T, h_region_: usize, dw_watch_mode_: u32) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).ChangeWatchMode(@as(*const IRowsetWatchRegion, @ptrCast(self)), h_region_, dw_watch_mode_);
            }
            pub inline fn deleteWatchRegion(self: *const T, h_region_: usize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).DeleteWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), h_region_);
            }
            pub inline fn getWatchRegionInfo(self: *const T, h_region_: usize, pdw_watch_mode_: ?*u32, ph_chapter_: ?*usize, pcb_bookmark_: ?*usize, pp_bookmark_: ?*?*u8, pc_rows_: ?*isize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).GetWatchRegionInfo(@as(*const IRowsetWatchRegion, @ptrCast(self)), h_region_, pdw_watch_mode_, ph_chapter_, pcb_bookmark_, pp_bookmark_, pc_rows_);
            }
            pub inline fn refresh(self: *const T, pc_changes_obtained_: ?*usize, prg_changes_: ?*?*tagDBROWWATCHRANGE) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IRowsetWatchRegion, @ptrCast(self)), pc_changes_obtained_, prg_changes_);
            }
            pub inline fn shrinkWatchRegion(self: *const T, h_region_: usize, h_chapter_: usize, cb_bookmark_: usize, p_bookmark_: ?*u8, c_rows_: isize) HRESULT {
                return @as(*const IRowsetWatchRegion.VTable, @ptrCast(self.vtable)).ShrinkWatchRegion(@as(*const IRowsetWatchRegion, @ptrCast(self)), h_region_, h_chapter_, cb_bookmark_, p_bookmark_, c_rows_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetCopyRows_Value = Guid.initString("0c733a6b-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IRowsetCopyRows = &IID_IRowsetCopyRows_Value;
pub const IRowsetCopyRows = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseSource: *const fn (
            self: *const IRowsetCopyRows,
            h_source_i_d: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyByHROWS: *const fn (
            self: *const IRowsetCopyRows,
            h_source_i_d: u16,
            h_reserved: usize,
            c_rows: isize,
            rgh_rows: ?*const usize,
            b_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyRows: *const fn (
            self: *const IRowsetCopyRows,
            h_source_i_d: u16,
            h_reserved: usize,
            c_rows: isize,
            b_flags: u32,
            pc_rows_copied: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineSource: *const fn (
            self: *const IRowsetCopyRows,
            p_rowset_source: ?*IRowset,
            c_col_ids: usize,
            rg_source_columns: ?*const isize,
            rg_target_columns: ?*const isize,
            ph_source_i_d: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn closeSource(self: *const T, h_source_i_d_: u16) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CloseSource(@as(*const IRowsetCopyRows, @ptrCast(self)), h_source_i_d_);
            }
            pub inline fn copyByHROWS(self: *const T, h_source_i_d_: u16, h_reserved_: usize, c_rows_: isize, rgh_rows_: ?*const usize, b_flags_: u32) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CopyByHROWS(@as(*const IRowsetCopyRows, @ptrCast(self)), h_source_i_d_, h_reserved_, c_rows_, rgh_rows_, b_flags_);
            }
            pub inline fn copyRows(self: *const T, h_source_i_d_: u16, h_reserved_: usize, c_rows_: isize, b_flags_: u32, pc_rows_copied_: ?*usize) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).CopyRows(@as(*const IRowsetCopyRows, @ptrCast(self)), h_source_i_d_, h_reserved_, c_rows_, b_flags_, pc_rows_copied_);
            }
            pub inline fn defineSource(self: *const T, p_rowset_source_: ?*IRowset, c_col_ids_: usize, rg_source_columns_: ?*const isize, rg_target_columns_: ?*const isize, ph_source_i_d_: ?*u16) HRESULT {
                return @as(*const IRowsetCopyRows.VTable, @ptrCast(self.vtable)).DefineSource(@as(*const IRowsetCopyRows, @ptrCast(self)), p_rowset_source_, c_col_ids_, rg_source_columns_, rg_target_columns_, ph_source_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IReadData_Value = Guid.initString("0c733a6a-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IReadData = &IID_IReadData_Value;
pub const IReadData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadData: *const fn (
            self: *const IReadData,
            h_chapter: usize,
            cb_bookmark: usize,
            p_bookmark: ?*const u8,
            l_rows_offset: isize,
            h_accessor: usize,
            c_rows: isize,
            pc_rows_obtained: ?*usize,
            pp_fixed_data: ?*?*u8,
            pcb_variable_total: ?*usize,
            pp_variable_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseChapter: *const fn (
            self: *const IReadData,
            h_chapter: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn readData(self: *const T, h_chapter_: usize, cb_bookmark_: usize, p_bookmark_: ?*const u8, l_rows_offset_: isize, h_accessor_: usize, c_rows_: isize, pc_rows_obtained_: ?*usize, pp_fixed_data_: ?*?*u8, pcb_variable_total_: ?*usize, pp_variable_data_: ?*?*u8) HRESULT {
                return @as(*const IReadData.VTable, @ptrCast(self.vtable)).ReadData(@as(*const IReadData, @ptrCast(self)), h_chapter_, cb_bookmark_, p_bookmark_, l_rows_offset_, h_accessor_, c_rows_, pc_rows_obtained_, pp_fixed_data_, pcb_variable_total_, pp_variable_data_);
            }
            pub inline fn releaseChapter(self: *const T, h_chapter_: usize) HRESULT {
                return @as(*const IReadData.VTable, @ptrCast(self.vtable)).ReleaseChapter(@as(*const IReadData, @ptrCast(self)), h_chapter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBRESOURCEKINDENUM = enum(i32) {
    INVALID = 0,
    TOTAL = 1,
    CPU = 2,
    MEMORY = 3,
    DISK = 4,
    NETWORK = 5,
    RESPONSE = 6,
    ROWS = 7,
    OTHER = 8,
};
pub const DBRESOURCE_INVALID = DBRESOURCEKINDENUM.INVALID;
pub const DBRESOURCE_TOTAL = DBRESOURCEKINDENUM.TOTAL;
pub const DBRESOURCE_CPU = DBRESOURCEKINDENUM.CPU;
pub const DBRESOURCE_MEMORY = DBRESOURCEKINDENUM.MEMORY;
pub const DBRESOURCE_DISK = DBRESOURCEKINDENUM.DISK;
pub const DBRESOURCE_NETWORK = DBRESOURCEKINDENUM.NETWORK;
pub const DBRESOURCE_RESPONSE = DBRESOURCEKINDENUM.RESPONSE;
pub const DBRESOURCE_ROWS = DBRESOURCEKINDENUM.ROWS;
pub const DBRESOURCE_OTHER = DBRESOURCEKINDENUM.OTHER;

pub const DBCOSTUNITENUM = enum(i32) {
    INVALID = 0,
    WEIGHT = 1,
    PERCENT = 2,
    MAXIMUM = 4,
    MINIMUM = 8,
    MICRO_SECOND = 16,
    MILLI_SECOND = 32,
    SECOND = 64,
    MINUTE = 128,
    HOUR = 256,
    BYTE = 512,
    KILO_BYTE = 1024,
    MEGA_BYTE = 2048,
    GIGA_BYTE = 4096,
    NUM_MSGS = 8192,
    NUM_LOCKS = 16384,
    NUM_ROWS = 32768,
    OTHER = 65536,
};
pub const DBUNIT_INVALID = DBCOSTUNITENUM.INVALID;
pub const DBUNIT_WEIGHT = DBCOSTUNITENUM.WEIGHT;
pub const DBUNIT_PERCENT = DBCOSTUNITENUM.PERCENT;
pub const DBUNIT_MAXIMUM = DBCOSTUNITENUM.MAXIMUM;
pub const DBUNIT_MINIMUM = DBCOSTUNITENUM.MINIMUM;
pub const DBUNIT_MICRO_SECOND = DBCOSTUNITENUM.MICRO_SECOND;
pub const DBUNIT_MILLI_SECOND = DBCOSTUNITENUM.MILLI_SECOND;
pub const DBUNIT_SECOND = DBCOSTUNITENUM.SECOND;
pub const DBUNIT_MINUTE = DBCOSTUNITENUM.MINUTE;
pub const DBUNIT_HOUR = DBCOSTUNITENUM.HOUR;
pub const DBUNIT_BYTE = DBCOSTUNITENUM.BYTE;
pub const DBUNIT_KILO_BYTE = DBCOSTUNITENUM.KILO_BYTE;
pub const DBUNIT_MEGA_BYTE = DBCOSTUNITENUM.MEGA_BYTE;
pub const DBUNIT_GIGA_BYTE = DBCOSTUNITENUM.GIGA_BYTE;
pub const DBUNIT_NUM_MSGS = DBCOSTUNITENUM.NUM_MSGS;
pub const DBUNIT_NUM_LOCKS = DBCOSTUNITENUM.NUM_LOCKS;
pub const DBUNIT_NUM_ROWS = DBCOSTUNITENUM.NUM_ROWS;
pub const DBUNIT_OTHER = DBCOSTUNITENUM.OTHER;

pub const DBEXECLIMITSENUM = enum(i32) {
    ABORT = 1,
    STOP = 2,
    SUSPEND = 3,
};
pub const DBEXECLIMITS_ABORT = DBEXECLIMITSENUM.ABORT;
pub const DBEXECLIMITS_STOP = DBEXECLIMITSENUM.STOP;
pub const DBEXECLIMITS_SUSPEND = DBEXECLIMITSENUM.SUSPEND;

const IID_ICommandCost_Value = Guid.initString("0c733a4e-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandCost = &IID_ICommandCost_Value;
pub const ICommandCost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAccumulatedCost: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            pc_cost_limits: ?*u32,
            prg_cost_limits: ?*?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostEstimate: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            pc_cost_estimates: ?*u32,
            prg_cost_estimates: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostGoals: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            pc_cost_goals: ?*u32,
            prg_cost_goals: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCostLimits: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            pc_cost_limits: ?*u32,
            prg_cost_limits: ?*DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCostGoals: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            c_cost_goals: u32,
            rg_cost_goals: ?*const DBCOST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCostLimits: *const fn (
            self: *const ICommandCost,
            pwsz_rowset_name: ?[*:0]const u16,
            c_cost_limits: u32,
            prg_cost_limits: ?*DBCOST,
            dw_execution_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAccumulatedCost(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, pc_cost_limits_: ?*u32, prg_cost_limits_: ?*?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetAccumulatedCost(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, pc_cost_limits_, prg_cost_limits_);
            }
            pub inline fn getCostEstimate(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, pc_cost_estimates_: ?*u32, prg_cost_estimates_: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostEstimate(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, pc_cost_estimates_, prg_cost_estimates_);
            }
            pub inline fn getCostGoals(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, pc_cost_goals_: ?*u32, prg_cost_goals_: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostGoals(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, pc_cost_goals_, prg_cost_goals_);
            }
            pub inline fn getCostLimits(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, pc_cost_limits_: ?*u32, prg_cost_limits_: ?*DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).GetCostLimits(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, pc_cost_limits_, prg_cost_limits_);
            }
            pub inline fn setCostGoals(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, c_cost_goals_: u32, rg_cost_goals_: ?*const DBCOST) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).SetCostGoals(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, c_cost_goals_, rg_cost_goals_);
            }
            pub inline fn setCostLimits(self: *const T, pwsz_rowset_name_: ?[*:0]const u16, c_cost_limits_: u32, prg_cost_limits_: ?*DBCOST, dw_execution_flags_: u32) HRESULT {
                return @as(*const ICommandCost.VTable, @ptrCast(self.vtable)).SetCostLimits(@as(*const ICommandCost, @ptrCast(self)), pwsz_rowset_name_, c_cost_limits_, prg_cost_limits_, dw_execution_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandValidate_Value = Guid.initString("0c733a18-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICommandValidate = &IID_ICommandValidate_Value;
pub const ICommandValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateCompletely: *const fn (
            self: *const ICommandValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateSyntax: *const fn (
            self: *const ICommandValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn validateCompletely(self: *const T) HRESULT {
                return @as(*const ICommandValidate.VTable, @ptrCast(self.vtable)).ValidateCompletely(@as(*const ICommandValidate, @ptrCast(self)));
            }
            pub inline fn validateSyntax(self: *const T) HRESULT {
                return @as(*const ICommandValidate.VTable, @ptrCast(self.vtable)).ValidateSyntax(@as(*const ICommandValidate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableRename_Value = Guid.initString("0c733a77-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ITableRename = &IID_ITableRename_Value;
pub const ITableRename = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenameColumn: *const fn (
            self: *const ITableRename,
            p_table_id: ?*DBID,
            p_old_column_id: ?*DBID,
            p_new_column_id: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameTable: *const fn (
            self: *const ITableRename,
            p_old_table_id: ?*DBID,
            p_old_index_id: ?*DBID,
            p_new_table_id: ?*DBID,
            p_new_index_id: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn renameColumn(self: *const T, p_table_id_: ?*DBID, p_old_column_id_: ?*DBID, p_new_column_id_: ?*DBID) HRESULT {
                return @as(*const ITableRename.VTable, @ptrCast(self.vtable)).RenameColumn(@as(*const ITableRename, @ptrCast(self)), p_table_id_, p_old_column_id_, p_new_column_id_);
            }
            pub inline fn renameTable(self: *const T, p_old_table_id_: ?*DBID, p_old_index_id_: ?*DBID, p_new_table_id_: ?*DBID, p_new_index_id_: ?*DBID) HRESULT {
                return @as(*const ITableRename.VTable, @ptrCast(self.vtable)).RenameTable(@as(*const ITableRename, @ptrCast(self)), p_old_table_id_, p_old_index_id_, p_new_table_id_, p_new_index_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBSchemaCommand_Value = Guid.initString("0c733a50-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IDBSchemaCommand = &IID_IDBSchemaCommand_Value;
pub const IDBSchemaCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommand: *const fn (
            self: *const IDBSchemaCommand,
            p_unk_outer: ?*IUnknown,
            rguid_schema: ?*const Guid,
            pp_command: ?*?*ICommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemas: *const fn (
            self: *const IDBSchemaCommand,
            pc_schemas: ?*u32,
            prg_schemas: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCommand(self: *const T, p_unk_outer_: ?*IUnknown, rguid_schema_: ?*const Guid, pp_command_: ?*?*ICommand) HRESULT {
                return @as(*const IDBSchemaCommand.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDBSchemaCommand, @ptrCast(self)), p_unk_outer_, rguid_schema_, pp_command_);
            }
            pub inline fn getSchemas(self: *const T, pc_schemas_: ?*u32, prg_schemas_: ?*?*Guid) HRESULT {
                return @as(*const IDBSchemaCommand.VTable, @ptrCast(self.vtable)).GetSchemas(@as(*const IDBSchemaCommand, @ptrCast(self)), pc_schemas_, prg_schemas_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideMoniker_Value = Guid.initString("0c733a4d-2a1c-11ce-ade5-00aa0044773d");
pub const IID_IProvideMoniker = &IID_IProvideMoniker_Value;
pub const IProvideMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMoniker: *const fn (
            self: *const IProvideMoniker,
            pp_i_moniker: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMoniker(self: *const T, pp_i_moniker_: ?*?*IMoniker) HRESULT {
                return @as(*const IProvideMoniker.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IProvideMoniker, @ptrCast(self)), pp_i_moniker_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NOTRESTRICTION = extern struct {
    pRes: ?*RESTRICTION,
};

pub const NODERESTRICTION = extern struct {
    cRes: u32,
    paRes: ?*?*RESTRICTION,
    reserved: u32,
};

pub const VECTORRESTRICTION = extern struct {
    Node: NODERESTRICTION,
    RankMethod: u32,
};

pub const CONTENTRESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
    ulGenerateMethod: u32,
};

pub const NATLANGUAGERESTRICTION = extern struct {
    prop: FULLPROPSPEC,
    pwcsPhrase: ?PWSTR,
    lcid: u32,
};

pub const PROPERTYRESTRICTION = extern struct {
    rel: u32,
    prop: FULLPROPSPEC,
    prval: PROPVARIANT,
};

pub const RESTRICTION = extern struct {
    pub const _URes = extern union {
        ar: NODERESTRICTION,
        orRestriction: NODERESTRICTION,
        pxr: NODERESTRICTION,
        vr: VECTORRESTRICTION,
        nr: NOTRESTRICTION,
        cr: CONTENTRESTRICTION,
        nlr: NATLANGUAGERESTRICTION,
        pr: PROPERTYRESTRICTION,
    };
    rt: u32,
    weight: u32,
    res: _URes,
};

pub const COLUMNSET = extern struct {
    cCol: u32,
    aCol: ?*FULLPROPSPEC,
};

pub const SORTKEY = extern struct {
    propColumn: FULLPROPSPEC,
    dwOrder: u32,
    locale: u32,
};

pub const SORTSET = extern struct {
    cCol: u32,
    aCol: ?*SORTKEY,
};

pub const BUCKETCATEGORIZE = extern struct {
    cBuckets: u32,
    Distribution: u32,
};

pub const RANGECATEGORIZE = extern struct {
    cRange: u32,
    aRangeBegin: ?*PROPVARIANT,
};

pub const CATEGORIZATION = extern struct {
    ulCatType: u32,
    Anonymous: extern union {
        cClusters: u32,
        bucket: BUCKETCATEGORIZE,
        range: RANGECATEGORIZE,
    },
    csColumns: COLUMNSET,
};

pub const CATEGORIZATIONSET = extern struct {
    cCat: u32,
    aCat: ?*CATEGORIZATION,
};

const IID_ISearchQueryHits_Value = Guid.initString("ed8ce7e0-106c-11ce-84e2-00aa004b9986");
pub const IID_ISearchQueryHits = &IID_ISearchQueryHits_Value;
pub const ISearchQueryHits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const ISearchQueryHits,
            pflt: ?*IFilter,
            ul_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        NextHitMoniker: *const fn (
            self: *const ISearchQueryHits,
            pc_mnk: ?*u32,
            pap_mnk: ?*?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        NextHitOffset: *const fn (
            self: *const ISearchQueryHits,
            pc_region: ?*u32,
            pa_region: ?*?*FILTERREGION,
        ) callconv(@import("std").os.windows.WINAPI) i32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, pflt_: ?*IFilter, ul_flags_: u32) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).Init(@as(*const ISearchQueryHits, @ptrCast(self)), pflt_, ul_flags_);
            }
            pub inline fn nextHitMoniker(self: *const T, pc_mnk_: ?*u32, pap_mnk_: ?*?*?*IMoniker) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).NextHitMoniker(@as(*const ISearchQueryHits, @ptrCast(self)), pc_mnk_, pap_mnk_);
            }
            pub inline fn nextHitOffset(self: *const T, pc_region_: ?*u32, pa_region_: ?*?*FILTERREGION) i32 {
                return @as(*const ISearchQueryHits.VTable, @ptrCast(self.vtable)).NextHitOffset(@as(*const ISearchQueryHits, @ptrCast(self)), pc_region_, pa_region_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetQueryStatus_Value = Guid.initString("a7ac77ed-f8d7-11ce-a798-0020f8008024");
pub const IID_IRowsetQueryStatus = &IID_IRowsetQueryStatus_Value;
pub const IRowsetQueryStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IRowsetQueryStatus,
            pdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusEx: *const fn (
            self: *const IRowsetQueryStatus,
            pdw_status: ?*u32,
            pc_filtered_documents: ?*u32,
            pc_documents_to_filter: ?*u32,
            pdw_ratio_finished_denominator: ?*usize,
            pdw_ratio_finished_numerator: ?*usize,
            cb_bmk: usize,
            p_bmk: ?*const u8,
            pi_row_bmk: ?*usize,
            pc_rows_total: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, pdw_status_: ?*u32) HRESULT {
                return @as(*const IRowsetQueryStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IRowsetQueryStatus, @ptrCast(self)), pdw_status_);
            }
            pub inline fn getStatusEx(self: *const T, pdw_status_: ?*u32, pc_filtered_documents_: ?*u32, pc_documents_to_filter_: ?*u32, pdw_ratio_finished_denominator_: ?*usize, pdw_ratio_finished_numerator_: ?*usize, cb_bmk_: usize, p_bmk_: ?*const u8, pi_row_bmk_: ?*usize, pc_rows_total_: ?*usize) HRESULT {
                return @as(*const IRowsetQueryStatus.VTable, @ptrCast(self.vtable)).GetStatusEx(@as(*const IRowsetQueryStatus, @ptrCast(self)), pdw_status_, pc_filtered_documents_, pc_documents_to_filter_, pdw_ratio_finished_denominator_, pdw_ratio_finished_numerator_, cb_bmk_, p_bmk_, pi_row_bmk_, pc_rows_total_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ODBC_VS_ARGS = extern struct {
    pguidEvent: ?*const Guid,
    dwFlags: u32,
    Anonymous1: extern union {
        wszArg: ?PWSTR,
        szArg: ?PSTR,
    },
    Anonymous2: extern union {
        wszCorrelation: ?PWSTR,
        szCorrelation: ?PSTR,
    },
    RetCode: i16,
};

pub const SQLVARENUM = enum(i32) {
    EMPTY = 0,
    NULL = 1,
    UI1 = 17,
    I2 = 2,
    I4 = 3,
    I8 = 20,
    R4 = 4,
    R8 = 5,
    MONEY = 6,
    SMALLMONEY = 200,
    WSTRING = 201,
    WVARSTRING = 202,
    STRING = 203,
    VARSTRING = 204,
    BIT = 11,
    GUID = 72,
    NUMERIC = 131,
    DECIMAL = 205,
    DATETIME = 135,
    SMALLDATETIME = 206,
    BINARY = 207,
    VARBINARY = 208,
    UNKNOWN = 209,
};
pub const VT_SS_EMPTY = SQLVARENUM.EMPTY;
pub const VT_SS_NULL = SQLVARENUM.NULL;
pub const VT_SS_UI1 = SQLVARENUM.UI1;
pub const VT_SS_I2 = SQLVARENUM.I2;
pub const VT_SS_I4 = SQLVARENUM.I4;
pub const VT_SS_I8 = SQLVARENUM.I8;
pub const VT_SS_R4 = SQLVARENUM.R4;
pub const VT_SS_R8 = SQLVARENUM.R8;
pub const VT_SS_MONEY = SQLVARENUM.MONEY;
pub const VT_SS_SMALLMONEY = SQLVARENUM.SMALLMONEY;
pub const VT_SS_WSTRING = SQLVARENUM.WSTRING;
pub const VT_SS_WVARSTRING = SQLVARENUM.WVARSTRING;
pub const VT_SS_STRING = SQLVARENUM.STRING;
pub const VT_SS_VARSTRING = SQLVARENUM.VARSTRING;
pub const VT_SS_BIT = SQLVARENUM.BIT;
pub const VT_SS_GUID = SQLVARENUM.GUID;
pub const VT_SS_NUMERIC = SQLVARENUM.NUMERIC;
pub const VT_SS_DECIMAL = SQLVARENUM.DECIMAL;
pub const VT_SS_DATETIME = SQLVARENUM.DATETIME;
pub const VT_SS_SMALLDATETIME = SQLVARENUM.SMALLDATETIME;
pub const VT_SS_BINARY = SQLVARENUM.BINARY;
pub const VT_SS_VARBINARY = SQLVARENUM.VARBINARY;
pub const VT_SS_UNKNOWN = SQLVARENUM.UNKNOWN;

pub const SSVARIANT = extern struct {
    vt: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    Anonymous: extern union {
        pub const _UnknownType = extern struct {
            dwActualLength: u32,
            rgMetadata: [16]u8,
            pUnknownData: ?*u8,
        };
        pub const _CharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pchCharVal: ?PSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        pub const _BLOBType = extern struct {
            dbobj: DBOBJECT,
            pUnk: ?*IUnknown,
        };
        pub const _NCharVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            pwchNCharVal: ?PWSTR,
            rgbReserved: [5]u8,
            dwReserved: u32,
            pwchReserved: ?PWSTR,
        };
        pub const _BinaryVal = extern struct {
            sActualLength: i16,
            sMaxLength: i16,
            prgbBinaryVal: ?*u8,
            dwReserved: u32,
        };
        bTinyIntVal: u8,
        sShortIntVal: i16,
        lIntVal: i32,
        llBigIntVal: i64,
        fltRealVal: f32,
        dblFloatVal: f64,
        cyMoneyVal: CY,
        NCharVal: _NCharVal,
        CharVal: _CharVal,
        fBitVal: i16,
        rgbGuidVal: [16]u8,
        numNumericVal: DB_NUMERIC,
        BinaryVal: _BinaryVal,
        tsDateTimeVal: DBTIMESTAMP,
        UnknownType: _UnknownType,
        BLOBType: _BLOBType,
    },
};

const IID_IUMSInitialize_Value = Guid.initString("5cf4ca14-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IUMSInitialize = &IID_IUMSInitialize_Value;
pub const IUMSInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IUMSInitialize,
            p_u_m_s: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_u_m_s_: ?*anyopaque) HRESULT {
                return @as(*const IUMSInitialize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IUMSInitialize, @ptrCast(self)), p_u_m_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IUMS = extern struct {
    pub const VTable = extern struct {
        SqlUmsSuspend: *const fn (
            self: *const IUMS,
            ticks: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsYield: *const fn (
            self: *const IUMS,
            ticks: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsSwitchPremptive: *const fn (
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsSwitchNonPremptive: *const fn (
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SqlUmsFIsPremptive: *const fn (
            self: *const IUMS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn sqlUmsSuspend(self: *const T, ticks_: u32) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSuspend(@as(*const IUMS, @ptrCast(self)), ticks_);
            }
            pub inline fn sqlUmsYield(self: *const T, ticks_: u32) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsYield(@as(*const IUMS, @ptrCast(self)), ticks_);
            }
            pub inline fn sqlUmsSwitchPremptive(self: *const T) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSwitchPremptive(@as(*const IUMS, @ptrCast(self)));
            }
            pub inline fn sqlUmsSwitchNonPremptive(self: *const T) void {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsSwitchNonPremptive(@as(*const IUMS, @ptrCast(self)));
            }
            pub inline fn sqlUmsFIsPremptive(self: *const T) BOOL {
                return @as(*const IUMS.VTable, @ptrCast(self.vtable)).SqlUmsFIsPremptive(@as(*const IUMS, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const tagSSErrorInfo = extern struct {
    pwszMessage: ?PWSTR,
    pwszServer: ?PWSTR,
    pwszProcedure: ?PWSTR,
    lNative: i32,
    bState: u8,
    bClass: u8,
    wLineNumber: u16,
};

const IID_ISQLServerErrorInfo_Value = Guid.initString("5cf4ca12-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_ISQLServerErrorInfo = &IID_ISQLServerErrorInfo_Value;
pub const ISQLServerErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: *const fn (
            self: *const ISQLServerErrorInfo,
            pp_error_info: ?*?*tagSSErrorInfo,
            pp_strings_buffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getErrorInfo(self: *const T, pp_error_info_: ?*?*tagSSErrorInfo, pp_strings_buffer_: ?*?*u16) HRESULT {
                return @as(*const ISQLServerErrorInfo.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const ISQLServerErrorInfo, @ptrCast(self)), pp_error_info_, pp_strings_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetFastLoad_Value = Guid.initString("5cf4ca13-ef21-11d0-97e7-00c04fc2ad98");
pub const IID_IRowsetFastLoad = &IID_IRowsetFastLoad_Value;
pub const IRowsetFastLoad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertRow: *const fn (
            self: *const IRowsetFastLoad,
            h_accessor: usize,
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IRowsetFastLoad,
            f_done: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn insertRow(self: *const T, h_accessor_: usize, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IRowsetFastLoad.VTable, @ptrCast(self.vtable)).InsertRow(@as(*const IRowsetFastLoad, @ptrCast(self)), h_accessor_, p_data_);
            }
            pub inline fn commit(self: *const T, f_done_: BOOL) HRESULT {
                return @as(*const IRowsetFastLoad.VTable, @ptrCast(self.vtable)).Commit(@as(*const IRowsetFastLoad, @ptrCast(self)), f_done_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LOCKMODEENUM = enum(i32) {
    INVALID = 0,
    EXCLUSIVE = 1,
    SHARED = 2,
};
pub const LOCKMODE_INVALID = LOCKMODEENUM.INVALID;
pub const LOCKMODE_EXCLUSIVE = LOCKMODEENUM.EXCLUSIVE;
pub const LOCKMODE_SHARED = LOCKMODEENUM.SHARED;

const IID_ISchemaLock_Value = Guid.initString("4c2389fb-2511-11d4-b258-00c04f7971ce");
pub const IID_ISchemaLock = &IID_ISchemaLock_Value;
pub const ISchemaLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSchemaLock: *const fn (
            self: *const ISchemaLock,
            p_table_i_d: ?*DBID,
            lm_mode: u32,
            ph_lock_handle: ?*?HANDLE,
            p_table_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSchemaLock: *const fn (
            self: *const ISchemaLock,
            h_lock_handle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSchemaLock(self: *const T, p_table_i_d_: ?*DBID, lm_mode_: u32, ph_lock_handle_: ?*?HANDLE, p_table_version_: ?*u64) HRESULT {
                return @as(*const ISchemaLock.VTable, @ptrCast(self.vtable)).GetSchemaLock(@as(*const ISchemaLock, @ptrCast(self)), p_table_i_d_, lm_mode_, ph_lock_handle_, p_table_version_);
            }
            pub inline fn releaseSchemaLock(self: *const T, h_lock_handle_: ?HANDLE) HRESULT {
                return @as(*const ISchemaLock.VTable, @ptrCast(self.vtable)).ReleaseSchemaLock(@as(*const ISchemaLock, @ptrCast(self)), h_lock_handle_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SQL_ASYNC_NOTIFICATION_CALLBACK = *const fn (
    p_context: ?*anyopaque,
    f_last: BOOL,
) callconv(@import("std").os.windows.WINAPI) i16;

pub const DBVECTOR = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        size: usize,
        ptr: ?*anyopaque,
    },
    .X86 => extern struct {
        size: usize align(2),
        ptr: ?*anyopaque align(2),
    },
};
pub const DBTIMESTAMP = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        year: i16,
        month: u16,
        day: u16,
        hour: u16,
        minute: u16,
        second: u16,
        fraction: u32,
    },
    .X86 => extern struct {
        year: i16 align(2),
        month: u16 align(2),
        day: u16 align(2),
        hour: u16 align(2),
        minute: u16 align(2),
        second: u16 align(2),
        fraction: u32 align(2),
    },
};
pub const SEC_OBJECT_ELEMENT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        guidObjectType: Guid,
        ObjectID: DBID,
    },
    .X86 => extern struct {
        guidObjectType: Guid align(2),
        ObjectID: DBID align(2),
    },
};
pub const SEC_OBJECT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cObjects: u32,
        prgObjects: ?*SEC_OBJECT_ELEMENT,
    },
    .X86 => extern struct {
        cObjects: u32 align(2),
        prgObjects: ?*SEC_OBJECT_ELEMENT align(2),
    },
};
pub const DBIMPLICITSESSION = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pUnkOuter: ?*IUnknown,
        piid: ?*Guid,
        pSession: ?*IUnknown,
    },
    .X86 => extern struct {
        pUnkOuter: ?*IUnknown align(2),
        piid: ?*Guid align(2),
        pSession: ?*IUnknown align(2),
    },
};
pub const DBOBJECT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iid: Guid,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iid: Guid align(2),
    },
};
pub const DBBINDEXT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pExtension: ?*u8,
        ulExtension: usize,
    },
    .X86 => extern struct {
        pExtension: ?*u8 align(2),
        ulExtension: usize align(2),
    },
};
pub const DBBINDING = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        iOrdinal: usize,
        obValue: usize,
        obLength: usize,
        obStatus: usize,
        pTypeInfo: ?*ITypeInfo,
        pObject: ?*DBOBJECT,
        pBindExt: ?*DBBINDEXT,
        dwPart: u32,
        dwMemOwner: u32,
        eParamIO: u32,
        cbMaxLen: usize,
        dwFlags: u32,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        iOrdinal: usize align(2),
        obValue: usize align(2),
        obLength: usize align(2),
        obStatus: usize align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        pObject: ?*DBOBJECT align(2),
        pBindExt: ?*DBBINDEXT align(2),
        dwPart: u32 align(2),
        dwMemOwner: u32 align(2),
        eParamIO: u32 align(2),
        cbMaxLen: usize align(2),
        dwFlags: u32 align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBFAILUREINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRow: usize,
        iColumn: usize,
        failure: HRESULT,
    },
    .X86 => extern struct {
        hRow: usize align(2),
        iColumn: usize align(2),
        failure: HRESULT align(2),
    },
};
pub const DBCOLUMNINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        iOrdinal: usize,
        dwFlags: u32,
        ulColumnSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
        columnid: DBID,
    },
    .X86 => extern struct {
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        iOrdinal: usize align(2),
        dwFlags: u32 align(2),
        ulColumnSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
        columnid: DBID align(2),
    },
};
pub const DBPARAMS = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        cParamSets: usize,
        hAccessor: usize,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        cParamSets: usize align(2),
        hAccessor: usize align(2),
    },
};
pub const DBPARAMINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwFlags: u32,
        iOrdinal: usize,
        pwszName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        ulParamSize: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        dwFlags: u32 align(2),
        iOrdinal: usize align(2),
        pwszName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        ulParamSize: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBPROPIDSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyIDs: ?*u32,
        cPropertyIDs: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyIDs: ?*u32 align(2),
        cPropertyIDs: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROPINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDescription: ?PWSTR,
        dwPropertyID: u32,
        dwFlags: u32,
        vtType: u16,
        vValues: VARIANT,
    },
    .X86 => extern struct {
        pwszDescription: ?PWSTR align(2),
        dwPropertyID: u32 align(2),
        dwFlags: u32 align(2),
        vtType: u16 align(2),
        vValues: VARIANT align(2),
    },
};
pub const DBPROPINFOSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO,
        cPropertyInfos: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgPropertyInfos: ?*DBPROPINFO align(2),
        cPropertyInfos: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBPROP = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwPropertyID: u32,
        dwOptions: u32,
        dwStatus: u32,
        colid: DBID,
        vValue: VARIANT,
    },
    .X86 => extern struct {
        dwPropertyID: u32 align(2),
        dwOptions: u32 align(2),
        dwStatus: u32 align(2),
        colid: DBID align(2),
        vValue: VARIANT align(2),
    },
};
pub const DBPROPSET = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rgProperties: ?*DBPROP,
        cProperties: u32,
        guidPropertySet: Guid,
    },
    .X86 => extern struct {
        rgProperties: ?*DBPROP align(2),
        cProperties: u32 align(2),
        guidPropertySet: Guid align(2),
    },
};
pub const DBINDEXCOLUMNDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pColumnID: ?*DBID,
        eIndexColOrder: u32,
    },
    .X86 => extern struct {
        pColumnID: ?*DBID align(2),
        eIndexColOrder: u32 align(2),
    },
};
pub const DBCOLUMNDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszTypeName: ?PWSTR,
        pTypeInfo: ?*ITypeInfo,
        rgPropertySets: ?*DBPROPSET,
        pclsid: ?*Guid,
        cPropertySets: u32,
        ulColumnSize: usize,
        dbcid: DBID,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszTypeName: ?PWSTR align(2),
        pTypeInfo: ?*ITypeInfo align(2),
        rgPropertySets: ?*DBPROPSET align(2),
        pclsid: ?*Guid align(2),
        cPropertySets: u32 align(2),
        ulColumnSize: usize align(2),
        dbcid: DBID align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCOLUMNACCESS = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pData: ?*anyopaque,
        columnid: DBID,
        cbDataLen: usize,
        dwStatus: u32,
        cbMaxLen: usize,
        dwReserved: usize,
        wType: u16,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pData: ?*anyopaque align(2),
        columnid: DBID align(2),
        cbDataLen: usize align(2),
        dwStatus: u32 align(2),
        cbMaxLen: usize align(2),
        dwReserved: usize align(2),
        wType: u16 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBCONSTRAINTDESC = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pConstraintID: ?*DBID,
        ConstraintType: u32,
        cColumns: usize,
        rgColumnList: ?*DBID,
        pReferencedTableID: ?*DBID,
        cForeignKeyColumns: usize,
        rgForeignKeyColumnList: ?*DBID,
        pwszConstraintText: ?PWSTR,
        UpdateRule: u32,
        DeleteRule: u32,
        MatchType: u32,
        Deferrability: u32,
        cReserved: usize,
        rgReserved: ?*DBPROPSET,
    },
    .X86 => extern struct {
        pConstraintID: ?*DBID align(2),
        ConstraintType: u32 align(2),
        cColumns: usize align(2),
        rgColumnList: ?*DBID align(2),
        pReferencedTableID: ?*DBID align(2),
        cForeignKeyColumns: usize align(2),
        rgForeignKeyColumnList: ?*DBID align(2),
        pwszConstraintText: ?PWSTR align(2),
        UpdateRule: u32 align(2),
        DeleteRule: u32 align(2),
        MatchType: u32 align(2),
        Deferrability: u32 align(2),
        cReserved: usize align(2),
        rgReserved: ?*DBPROPSET align(2),
    },
};
pub const MDAXISINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: usize,
        iAxis: usize,
        cDimensions: usize,
        cCoordinates: usize,
        rgcColumns: ?*usize,
        rgpwszDimensionNames: ?*?PWSTR,
    },
    .X86 => extern struct {
        cbSize: usize align(2),
        iAxis: usize align(2),
        cDimensions: usize align(2),
        cCoordinates: usize align(2),
        rgcColumns: ?*usize align(2),
        rgpwszDimensionNames: ?*?PWSTR align(2),
    },
};
pub const RMTPACK = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pISeqStream: ?*ISequentialStream,
        cbData: u32,
        cBSTR: u32,
        rgBSTR: ?*?BSTR,
        cVARIANT: u32,
        rgVARIANT: ?*VARIANT,
        cIDISPATCH: u32,
        rgIDISPATCH: ?*?*IDispatch,
        cIUNKNOWN: u32,
        rgIUNKNOWN: ?*?*IUnknown,
        cPROPVARIANT: u32,
        rgPROPVARIANT: ?*PROPVARIANT,
        cArray: u32,
        rgArray: ?*VARIANT,
    },
    .X86 => extern struct {
        pISeqStream: ?*ISequentialStream align(2),
        cbData: u32 align(2),
        cBSTR: u32 align(2),
        rgBSTR: ?*?BSTR align(2),
        cVARIANT: u32 align(2),
        rgVARIANT: ?*VARIANT align(2),
        cIDISPATCH: u32 align(2),
        rgIDISPATCH: ?*?*IDispatch align(2),
        cIUNKNOWN: u32 align(2),
        rgIUNKNOWN: ?*?*IUnknown align(2),
        cPROPVARIANT: u32 align(2),
        rgPROPVARIANT: ?*PROPVARIANT align(2),
        cArray: u32 align(2),
        rgArray: ?*VARIANT align(2),
    },
};
pub const DBPARAMBINDINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszDataSourceType: ?PWSTR,
        pwszName: ?PWSTR,
        ulParamSize: usize,
        dwFlags: u32,
        bPrecision: u8,
        bScale: u8,
    },
    .X86 => extern struct {
        pwszDataSourceType: ?PWSTR align(2),
        pwszName: ?PWSTR align(2),
        ulParamSize: usize align(2),
        dwFlags: u32 align(2),
        bPrecision: u8 align(2),
        bScale: u8 align(2),
    },
};
pub const DBLITERALINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pwszLiteralValue: ?PWSTR,
        pwszInvalidChars: ?PWSTR,
        pwszInvalidStartingChars: ?PWSTR,
        lt: u32,
        fSupported: BOOL,
        cchMaxLen: u32,
    },
    .X86 => extern struct {
        pwszLiteralValue: ?PWSTR align(2),
        pwszInvalidChars: ?PWSTR align(2),
        pwszInvalidStartingChars: ?PWSTR align(2),
        lt: u32 align(2),
        fSupported: BOOL align(2),
        cchMaxLen: u32 align(2),
    },
};
pub const ERRORINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hrError: HRESULT,
        dwMinor: u32,
        clsid: Guid,
        iid: Guid,
        dispid: i32,
    },
    .X86 => extern struct {
        hrError: HRESULT align(2),
        dwMinor: u32 align(2),
        clsid: Guid align(2),
        iid: Guid align(2),
        dispid: i32 align(2),
    },
};
pub const tagDBROWWATCHRANGE = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hRegion: usize,
        eChangeKind: u32,
        hRow: usize,
        iRow: usize,
    },
    .X86 => extern struct {
        hRegion: usize align(2),
        eChangeKind: u32 align(2),
        hRow: usize align(2),
        iRow: usize align(2),
    },
};
pub const DBCOST = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        eKind: u32,
        dwUnits: u32,
        lValue: i32,
    },
    .X86 => extern struct {
        eKind: u32 align(2),
        dwUnits: u32 align(2),
        lValue: i32 align(2),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (211)
//--------------------------------------------------------------------------------
pub extern "odbc32" fn SQLAllocConnect(
    environment_handle: ?*anyopaque,
    connection_handle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocEnv(
    environment_handle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocHandle(
    handle_type: i16,
    input_handle: ?*anyopaque,
    output_handle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLAllocStmt(
    connection_handle: ?*anyopaque,
    statement_handle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindCol(
            statement_handle: ?*anyopaque,
            column_number: u16,
            target_type: i16,
            target_value: ?*anyopaque,
            buffer_length: i64,
            str_len_or__ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindParam(
            statement_handle: ?*anyopaque,
            parameter_number: u16,
            value_type: i16,
            parameter_type: i16,
            length_precision: u64,
            parameter_scale: i16,
            parameter_value: ?*anyopaque,
            str_len_or__ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLCancel(
    statement_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCancelHandle(
    handle_type: i16,
    input_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCloseCursor(
    statement_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttribute(
            statement_handle: ?*anyopaque,
            column_number: u16,
            field_identifier: u16,
            // TODO: what to do with BytesParamIndex 4?
            character_attribute: ?*anyopaque,
            buffer_length: i16,
            string_length: ?*i16,
            numeric_attribute: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLColumns(
    statement_handle: ?*anyopaque,
    catalog_name: ?[*:0]u8,
    name_length1: i16,
    schema_name: ?[*:0]u8,
    name_length2: i16,
    table_name: ?[*:0]u8,
    name_length3: i16,
    column_name: ?[*:0]u8,
    name_length4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCompleteAsync(
    handle_type: i16,
    handle: ?*anyopaque,
    async_ret_code_ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLConnect(
    connection_handle: ?*anyopaque,
    server_name: [*:0]u8,
    name_length1: i16,
    user_name: [*:0]u8,
    name_length2: i16,
    authentication: [*:0]u8,
    name_length3: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLCopyDesc(
    source_desc_handle: ?*anyopaque,
    target_desc_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSources(
    environment_handle: ?*anyopaque,
    direction: u16,
    server_name: ?[*:0]u8,
    buffer_length1: i16,
    name_length1_ptr: ?*i16,
    description: ?[*:0]u8,
    buffer_length2: i16,
    name_length2_ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeCol(
            statement_handle: ?*anyopaque,
            column_number: u16,
            column_name: ?[*:0]u8,
            buffer_length: i16,
            name_length: ?*i16,
            data_type: ?*i16,
            column_size: ?*u64,
            decimal_digits: ?*i16,
            nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLDisconnect(
    connection_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLEndTran(
    handle_type: i16,
    handle: ?*anyopaque,
    completion_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLError(
    environment_handle: ?*anyopaque,
    connection_handle: ?*anyopaque,
    statement_handle: ?*anyopaque,
    sqlstate: *[6]u8,
    native_error: ?*i32,
    message_text: ?[*:0]u8,
    buffer_length: i16,
    text_length: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirect(
    statement_handle: ?*anyopaque,
    statement_text: ?[*:0]u8,
    text_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecute(
    statement_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFetch(
    statement_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLFetchScroll(
            statement_handle: ?*anyopaque,
            fetch_orientation: i16,
            fetch_offset: i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLFreeConnect(
    connection_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeEnv(
    environment_handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeHandle(
    handle_type: i16,
    handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLFreeStmt(
    statement_handle: ?*anyopaque,
    option: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttr(
    connection_handle: ?*anyopaque,
    attribute: i32,
    value: ?*anyopaque,
    buffer_length: i32,
    string_length_ptr: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOption(
    connection_handle: ?*anyopaque,
    option: u16,
    value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorName(
    statement_handle: ?*anyopaque,
    cursor_name: ?[*:0]u8,
    buffer_length: i16,
    name_length_ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetData(
            statement_handle: ?*anyopaque,
            column_number: u16,
            target_type: i16,
            target_value: ?*anyopaque,
            buffer_length: i64,
            str_len_or__ind_ptr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDescField(
    descriptor_handle: ?*anyopaque,
    rec_number: i16,
    field_identifier: i16,
    value: ?*anyopaque,
    buffer_length: i32,
    string_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRec(
            descriptor_handle: ?*anyopaque,
            rec_number: i16,
            name: ?[*:0]u8,
            buffer_length: i16,
            string_length_ptr: ?*i16,
            type_ptr: ?*i16,
            sub_type_ptr: ?*i16,
            length_ptr: ?*i64,
            precision_ptr: ?*i16,
            scale_ptr: ?*i16,
            nullable_ptr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagField(
    handle_type: i16,
    handle: ?*anyopaque,
    rec_number: i16,
    diag_identifier: i16,
    diag_info: ?*anyopaque,
    buffer_length: i16,
    string_length: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRec(
    handle_type: i16,
    handle: ?*anyopaque,
    rec_number: i16,
    sqlstate: ?*[6]u8,
    native_error: ?*i32,
    message_text: ?[*:0]u8,
    buffer_length: i16,
    text_length: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetEnvAttr(
    environment_handle: ?*anyopaque,
    attribute: i32,
    value: ?*anyopaque,
    buffer_length: i32,
    string_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetFunctions(
    connection_handle: ?*anyopaque,
    function_id: u16,
    supported: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfo(
    connection_handle: ?*anyopaque,
    info_type: u16,
    // TODO: what to do with BytesParamIndex 3?
    info_value: ?*anyopaque,
    buffer_length: i16,
    string_length_ptr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttr(
    statement_handle: ?*anyopaque,
    attribute: i32,
    value: ?*anyopaque,
    buffer_length: i32,
    string_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtOption(
    statement_handle: ?*anyopaque,
    option: u16,
    value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfo(
    statement_handle: ?*anyopaque,
    data_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumResultCols(
    statement_handle: ?*anyopaque,
    column_count: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLParamData(
    statement_handle: ?*anyopaque,
    value: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepare(
    statement_handle: ?*anyopaque,
    statement_text: [*:0]u8,
    text_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLPutData(
            statement_handle: ?*anyopaque,
            data: ?*anyopaque,
            str_len_or__ind: i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLRowCount(
            statement_handle: ?*anyopaque,
            row_count: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetConnectAttr(
    connection_handle: ?*anyopaque,
    attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    value: ?*anyopaque,
    string_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOption(
            connection_handle: ?*anyopaque,
            option: u16,
            value: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetCursorName(
    statement_handle: ?*anyopaque,
    cursor_name: [*:0]u8,
    name_length: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescField(
    descriptor_handle: ?*anyopaque,
    rec_number: i16,
    field_identifier: i16,
    value: ?*anyopaque,
    buffer_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetDescRec(
            descriptor_handle: ?*anyopaque,
            rec_number: i16,
            type: i16,
            sub_type: i16,
            length: i64,
            precision: i16,
            scale: i16,
            // TODO: what to do with BytesParamIndex 4?
            data: ?*anyopaque,
            string_length: ?*i64,
            indicator: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetEnvAttr(
    environment_handle: ?*anyopaque,
    attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    value: ?*anyopaque,
    string_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetParam(
            statement_handle: ?*anyopaque,
            parameter_number: u16,
            value_type: i16,
            parameter_type: i16,
            length_precision: u64,
            parameter_scale: i16,
            parameter_value: ?*anyopaque,
            str_len_or__ind: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSetStmtAttr(
    statement_handle: ?*anyopaque,
    attribute: i32,
    value: ?*anyopaque,
    string_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetStmtOption(
            statement_handle: ?*anyopaque,
            option: u16,
            value: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumns(
    statement_handle: ?*anyopaque,
    identifier_type: u16,
    catalog_name: ?[*:0]u8,
    name_length1: i16,
    schema_name: ?[*:0]u8,
    name_length2: i16,
    table_name: ?[*:0]u8,
    name_length3: i16,
    scope: u16,
    nullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatistics(
    statement_handle: ?*anyopaque,
    catalog_name: ?[*:0]u8,
    name_length1: i16,
    schema_name: ?[*:0]u8,
    name_length2: i16,
    table_name: ?[*:0]u8,
    name_length3: i16,
    unique: u16,
    reserved: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTables(
    statement_handle: ?*anyopaque,
    catalog_name: ?[*:0]u8,
    name_length1: i16,
    schema_name: ?[*:0]u8,
    name_length2: i16,
    table_name: ?[*:0]u8,
    name_length3: i16,
    table_type: ?[*:0]u8,
    name_length4: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTransact(
    environment_handle: ?*anyopaque,
    connection_handle: ?*anyopaque,
    completion_type: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_batch(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_bind(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
    param3: i32,
    param4: ?*u8,
    param5: i32,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: u8,
    param3: i32,
    param4: i32,
    param5: ?*u8,
    param6: i32,
    param7: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_collen(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_colptr(
    param0: ?*anyopaque,
    param1: ?*u8,
    param2: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_columns(
    param0: ?*anyopaque,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_control(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_done(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "odbcbcp" fn bcp_exec(
    param0: ?*anyopaque,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_getcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
    param5: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?[*:0]const u8,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_initW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?[*:0]const u16,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_moretext(
    param0: ?*anyopaque,
    param1: i32,
    param2: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_readfmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_sendrow(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_setcolfmt(
    param0: ?*anyopaque,
    param1: i32,
    param2: i32,
    param3: ?*anyopaque,
    param4: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn bcp_writefmtW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn dbprtypeA(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "odbcbcp" fn dbprtypeW(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "odbcbcp" fn SQLLinkedServers(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsA(
    param0: ?*anyopaque,
    param1: ?[*:0]const u8,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLLinkedCatalogsW(
    param0: ?*anyopaque,
    param1: ?[*:0]const u16,
    param2: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLInitEnumServers(
    pwch_server_name: ?PWSTR,
    pwch_instance_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "odbcbcp" fn SQLGetNextEnumeration(
    h_enum_handle: ?HANDLE,
    prg_enum_data: ?*u8,
    pi_enum_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbcbcp" fn SQLCloseEnumServers(
    h_enum_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnect(
    hdbc: ?*anyopaque,
    hwnd: isize,
    sz_conn_str_in: [*:0]u8,
    cch_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u8,
    cch_conn_str_out_max: i16,
    pcch_conn_str_out: ?*i16,
    f_driver_completion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnect(
    hdbc: ?*anyopaque,
    sz_conn_str_in: [*:0]u8,
    cch_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u8,
    cch_conn_str_out_max: i16,
    pcch_conn_str_out: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBulkOperations(
    statement_handle: ?*anyopaque,
    operation: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributes(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLColumnPrivileges(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cch_table_name: i16,
    sz_column_name: ?[*:0]u8,
    cch_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeParam(
            hstmt: ?*anyopaque,
            ipar: u16,
            pf_sql_type: ?*i16,
            pcb_param_def: ?*u64,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLExtendedFetch(
            hstmt: ?*anyopaque,
            f_fetch_type: u16,
            irow: i64,
            pcrow: ?*u64,
            rgf_row_status: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLForeignKeys(
    hstmt: ?*anyopaque,
    sz_pk_catalog_name: ?[*:0]u8,
    cch_pk_catalog_name: i16,
    sz_pk_schema_name: ?[*:0]u8,
    cch_pk_schema_name: i16,
    sz_pk_table_name: ?[*:0]u8,
    cch_pk_table_name: i16,
    sz_fk_catalog_name: ?[*:0]u8,
    cch_fk_catalog_name: i16,
    sz_fk_schema_name: ?[*:0]u8,
    cch_fk_schema_name: i16,
    sz_fk_table_name: ?[*:0]u8,
    cch_fk_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLMoreResults(
    hstmt: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSql(
    hdbc: ?*anyopaque,
    sz_sql_str_in: [*:0]u8,
    cch_sql_str_in: i32,
    sz_sql_str: ?[*:0]u8,
    cch_sql_str_max: i32,
    pcb_sql_str: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNumParams(
    hstmt: ?*anyopaque,
    pcpar: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLParamOptions(
            hstmt: ?*anyopaque,
            crow: u64,
            pirow: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLPrimaryKeys(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cch_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumns(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cch_schema_name: i16,
    sz_proc_name: ?[*:0]u8,
    cch_proc_name: i16,
    sz_column_name: ?[*:0]u8,
    cch_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedures(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cch_schema_name: i16,
    sz_proc_name: ?[*:0]u8,
    cch_proc_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetPos(
            hstmt: ?*anyopaque,
            irow: u64,
            f_option: u16,
            f_lock: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLTablePrivileges(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cch_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDrivers(
    henv: ?*anyopaque,
    f_direction: u16,
    sz_driver_desc: ?[*:0]u8,
    cch_driver_desc_max: i16,
    pcch_driver_desc: ?*i16,
    sz_driver_attributes: ?[*:0]u8,
    cch_drvr_attr_max: i16,
    pcch_drvr_attr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLBindParameter(
            hstmt: ?*anyopaque,
            ipar: u16,
            f_param_type: i16,
            f_c_type: i16,
            f_sql_type: i16,
            cb_col_def: u64,
            ib_scale: i16,
            rgb_value: ?*anyopaque,
            cb_value_max: i64,
            pcb_value: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLAllocHandleStd(
    f_handle_type: i16,
    h_input: ?*anyopaque,
    ph_output: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetScrollOptions(
            hstmt: ?*anyopaque,
            f_concurrency: u16,
            crow_keyset: i64,
            crow_rowset: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn ODBCSetTryWaitValue(
    dw_value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "odbc32" fn ODBCGetTryWaitValue() callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributeW(
            hstmt: ?*anyopaque,
            i_col: u16,
            i_field: u16,
            // TODO: what to do with BytesParamIndex 4?
            p_char_attr: ?*anyopaque,
            cb_desc_max: i16,
            pcb_char_attr: ?*i16,
            p_num_attr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributesW(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLConnectW(
    hdbc: ?*anyopaque,
    sz_d_s_n: [*:0]u16,
    cch_d_s_n: i16,
    sz_u_i_d: [*:0]u16,
    cch_u_i_d: i16,
    sz_auth_str: [*:0]u16,
    cch_auth_str: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeColW(
            hstmt: ?*anyopaque,
            icol: u16,
            sz_col_name: ?[*:0]u16,
            cch_col_name_max: i16,
            pcch_col_name: ?*i16,
            pf_sql_type: ?*i16,
            pcb_col_def: ?*u64,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLErrorW(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    wsz_sql_state: *[6]u16,
    pf_native_error: ?*i32,
    wsz_error_msg: ?[*:0]u16,
    cch_error_msg_max: i16,
    pcch_error_msg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectW(
    hstmt: ?*anyopaque,
    sz_sql_str: ?[*:0]u16,
    text_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrW(
    hdbc: ?*anyopaque,
    f_attribute: i32,
    rgb_value: ?*anyopaque,
    cb_value_max: i32,
    pcb_value: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameW(
    hstmt: ?*anyopaque,
    sz_cursor: ?[*:0]u16,
    cch_cursor_max: i16,
    pcch_cursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetDescFieldW(
    descriptor_handle: ?*anyopaque,
    rec_number: i16,
    field_identifier: i16,
    value: ?*anyopaque,
    buffer_length: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldW(
    hdesc: ?*anyopaque,
    i_record: i16,
    i_field: i16,
    rgb_value: ?*anyopaque,
    cb_buffer_length: i32,
    string_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRecW(
            hdesc: ?*anyopaque,
            i_record: i16,
            sz_name: ?[*:0]u16,
            cch_name_max: i16,
            pcch_name: ?*i16,
            pf_type: ?*i16,
            pf_sub_type: ?*i16,
            p_length: ?*i64,
            p_precision: ?*i16,
            p_scale: ?*i16,
            p_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagFieldW(
    f_handle_type: i16,
    handle: ?*anyopaque,
    i_record: i16,
    f_diag_field: i16,
    rgb_diag_info: ?*anyopaque,
    cb_buffer_length: i16,
    pcb_string_length: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecW(
    f_handle_type: i16,
    handle: ?*anyopaque,
    i_record: i16,
    sz_sql_state: ?*[6]u16,
    pf_native_error: ?*i32,
    sz_error_msg: ?[*:0]u16,
    cch_error_msg_max: i16,
    pcch_error_msg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareW(
    hstmt: ?*anyopaque,
    sz_sql_str: [*:0]u16,
    cch_sql_str: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrW(
    hdbc: ?*anyopaque,
    f_attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgb_value: ?*anyopaque,
    cb_value: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameW(
    hstmt: ?*anyopaque,
    sz_cursor: [*:0]u16,
    cch_cursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
    sz_column_name: ?[*:0]u16,
    cch_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionW(
    hdbc: ?*anyopaque,
    f_option: u16,
    pv_param: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoW(
    hdbc: ?*anyopaque,
    f_info_type: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgb_info_value: ?*anyopaque,
    cb_info_value_max: i16,
    pcb_info_value: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoW(
    statement_handle: ?*anyopaque,
    data_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionW(
            hdbc: ?*anyopaque,
            f_option: u16,
            v_param: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumnsW(
    hstmt: ?*anyopaque,
    f_col_type: u16,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
    f_scope: u16,
    f_nullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
    f_unique: u16,
    f_accuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
    sz_table_type: ?[*:0]u16,
    cch_table_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesW(
    henv: ?*anyopaque,
    f_direction: u16,
    sz_d_s_n: ?[*:0]u16,
    cch_d_s_n_max: i16,
    pcch_d_s_n: ?*i16,
    wsz_description: ?[*:0]u16,
    cch_description_max: i16,
    pcch_description: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectW(
    hdbc: ?*anyopaque,
    hwnd: isize,
    sz_conn_str_in: [*:0]u16,
    cch_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u16,
    cch_conn_str_out_max: i16,
    pcch_conn_str_out: ?*i16,
    f_driver_completion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectW(
    hdbc: ?*anyopaque,
    sz_conn_str_in: [*:0]u16,
    cch_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u16,
    cch_conn_str_out_max: i16,
    pcch_conn_str_out: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
    sz_column_name: ?[*:0]u16,
    cch_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrW(
    hstmt: ?*anyopaque,
    f_attribute: i32,
    rgb_value: ?*anyopaque,
    cb_value_max: i32,
    pcb_value: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetStmtAttrW(
    hstmt: ?*anyopaque,
    f_attribute: i32,
    rgb_value: ?*anyopaque,
    cb_value_max: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysW(
    hstmt: ?*anyopaque,
    sz_pk_catalog_name: ?[*:0]u16,
    cch_pk_catalog_name: i16,
    sz_pk_schema_name: ?[*:0]u16,
    cch_pk_schema_name: i16,
    sz_pk_table_name: ?[*:0]u16,
    cch_pk_table_name: i16,
    sz_fk_catalog_name: ?[*:0]u16,
    cch_fk_catalog_name: i16,
    sz_fk_schema_name: ?[*:0]u16,
    cch_fk_schema_name: i16,
    sz_fk_table_name: ?[*:0]u16,
    cch_fk_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlW(
    hdbc: ?*anyopaque,
    sz_sql_str_in: [*:0]u16,
    cch_sql_str_in: i32,
    sz_sql_str: ?[*:0]u16,
    cch_sql_str_max: i32,
    pcch_sql_str: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_proc_name: ?[*:0]u16,
    cch_proc_name: i16,
    sz_column_name: ?[*:0]u16,
    cch_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_proc_name: ?[*:0]u16,
    cch_proc_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesW(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u16,
    cch_catalog_name: i16,
    sz_schema_name: ?[*:0]u16,
    cch_schema_name: i16,
    sz_table_name: ?[*:0]u16,
    cch_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversW(
    henv: ?*anyopaque,
    f_direction: u16,
    sz_driver_desc: ?[*:0]u16,
    cch_driver_desc_max: i16,
    pcch_driver_desc: ?*i16,
    sz_driver_attributes: ?[*:0]u16,
    cch_drvr_attr_max: i16,
    pcch_drvr_attr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributeA(
            hstmt: ?*anyopaque,
            i_col: i16,
            i_field: i16,
            // TODO: what to do with BytesParamIndex 4?
            p_char_attr: ?*anyopaque,
            cb_char_attr_max: i16,
            pcb_char_attr: ?*i16,
            p_num_attr: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLColAttributesA(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLConnectA(
    hdbc: ?*anyopaque,
    sz_d_s_n: [*:0]u8,
    cb_d_s_n: i16,
    sz_u_i_d: [*:0]u8,
    cb_u_i_d: i16,
    sz_auth_str: [*:0]u8,
    cb_auth_str: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLDescribeColA(
            hstmt: ?*anyopaque,
            icol: u16,
            sz_col_name: ?[*:0]u8,
            cb_col_name_max: i16,
            pcb_col_name: ?*i16,
            pf_sql_type: ?*i16,
            pcb_col_def: ?*u64,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLErrorA(
    henv: ?*anyopaque,
    hdbc: ?*anyopaque,
    hstmt: ?*anyopaque,
    sz_sql_state: ?*u8,
    pf_native_error: ?*i32,
    sz_error_msg: ?[*:0]u8,
    cb_error_msg_max: i16,
    pcb_error_msg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLExecDirectA(
    hstmt: ?*anyopaque,
    sz_sql_str: ?[*:0]u8,
    cb_sql_str: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectAttrA(
    hdbc: ?*anyopaque,
    f_attribute: i32,
    rgb_value: ?*anyopaque,
    cb_value_max: i32,
    pcb_value: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetCursorNameA(
    hstmt: ?*anyopaque,
    sz_cursor: ?[*:0]u8,
    cb_cursor_max: i16,
    pcb_cursor: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDescFieldA(
    hdesc: ?*anyopaque,
    i_record: i16,
    i_field: i16,
    rgb_value: ?*anyopaque,
    cb_buffer_length: i32,
    string_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLGetDescRecA(
            hdesc: ?*anyopaque,
            i_record: i16,
            sz_name: ?[*:0]u8,
            cb_name_max: i16,
            pcb_name: ?*i16,
            pf_type: ?*i16,
            pf_sub_type: ?*i16,
            p_length: ?*i64,
            p_precision: ?*i16,
            p_scale: ?*i16,
            p_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLGetDiagFieldA(
    f_handle_type: i16,
    handle: ?*anyopaque,
    i_record: i16,
    f_diag_field: i16,
    rgb_diag_info: ?*anyopaque,
    cb_diag_info_max: i16,
    pcb_diag_info: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetDiagRecA(
    f_handle_type: i16,
    handle: ?*anyopaque,
    i_record: i16,
    sz_sql_state: ?*[6]u8,
    pf_native_error: ?*i32,
    sz_error_msg: ?[*:0]u8,
    cb_error_msg_max: i16,
    pcb_error_msg: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetStmtAttrA(
    hstmt: ?*anyopaque,
    f_attribute: i32,
    rgb_value: ?*anyopaque,
    cb_value_max: i32,
    pcb_value: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetTypeInfoA(
    statement_handle: ?*anyopaque,
    data_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrepareA(
    hstmt: ?*anyopaque,
    sz_sql_str: [*:0]u8,
    cb_sql_str: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetConnectAttrA(
    hdbc: ?*anyopaque,
    f_attribute: i32,
    // TODO: what to do with BytesParamIndex 3?
    rgb_value: ?*anyopaque,
    cb_value: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLSetCursorNameA(
    hstmt: ?*anyopaque,
    sz_cursor: [*:0]u8,
    cb_cursor: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnsA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
    sz_column_name: ?[*:0]u8,
    cb_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetConnectOptionA(
    hdbc: ?*anyopaque,
    f_option: u16,
    pv_param: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLGetInfoA(
    hdbc: ?*anyopaque,
    f_info_type: u16,
    // TODO: what to do with BytesParamIndex 3?
    rgb_info_value: ?*anyopaque,
    cb_info_value_max: i16,
    pcb_info_value: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionA(
            hdbc: ?*anyopaque,
            f_option: u16,
            v_param: u64,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub extern "odbc32" fn SQLSpecialColumnsA(
    hstmt: ?*anyopaque,
    f_col_type: u16,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
    f_scope: u16,
    f_nullable: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLStatisticsA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
    f_unique: u16,
    f_accuracy: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablesA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
    sz_table_type: ?[*:0]u8,
    cb_table_type: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDataSourcesA(
    henv: ?*anyopaque,
    f_direction: u16,
    sz_d_s_n: ?[*:0]u8,
    cb_d_s_n_max: i16,
    pcb_d_s_n: ?*i16,
    sz_description: ?[*:0]u8,
    cb_description_max: i16,
    pcb_description: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriverConnectA(
    hdbc: ?*anyopaque,
    hwnd: isize,
    sz_conn_str_in: [*:0]u8,
    cb_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u8,
    cb_conn_str_out_max: i16,
    pcb_conn_str_out: ?*i16,
    f_driver_completion: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLBrowseConnectA(
    hdbc: ?*anyopaque,
    sz_conn_str_in: [*:0]u8,
    cb_conn_str_in: i16,
    sz_conn_str_out: ?[*:0]u8,
    cb_conn_str_out_max: i16,
    pcb_conn_str_out: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLColumnPrivilegesA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
    sz_column_name: ?[*:0]u8,
    cb_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLForeignKeysA(
    hstmt: ?*anyopaque,
    sz_pk_catalog_name: ?[*:0]u8,
    cb_pk_catalog_name: i16,
    sz_pk_schema_name: ?[*:0]u8,
    cb_pk_schema_name: i16,
    sz_pk_table_name: ?[*:0]u8,
    cb_pk_table_name: i16,
    sz_fk_catalog_name: ?[*:0]u8,
    cb_fk_catalog_name: i16,
    sz_fk_schema_name: ?[*:0]u8,
    cb_fk_schema_name: i16,
    sz_fk_table_name: ?[*:0]u8,
    cb_fk_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLNativeSqlA(
    hdbc: ?*anyopaque,
    sz_sql_str_in: [*:0]u8,
    cb_sql_str_in: i32,
    sz_sql_str: ?[*:0]u8,
    cb_sql_str_max: i32,
    pcb_sql_str: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLPrimaryKeysA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProcedureColumnsA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_proc_name: ?[*:0]u8,
    cb_proc_name: i16,
    sz_column_name: ?[*:0]u8,
    cb_column_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLProceduresA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_proc_name: ?[*:0]u8,
    cb_proc_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLTablePrivilegesA(
    hstmt: ?*anyopaque,
    sz_catalog_name: ?[*:0]u8,
    cb_catalog_name: i16,
    sz_schema_name: ?[*:0]u8,
    cb_schema_name: i16,
    sz_table_name: ?[*:0]u8,
    cb_table_name: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub extern "odbc32" fn SQLDriversA(
    henv: ?*anyopaque,
    f_direction: u16,
    sz_driver_desc: ?[*:0]u8,
    cb_driver_desc_max: i16,
    pcb_driver_desc: ?*i16,
    sz_driver_attributes: ?[*:0]u8,
    cb_drvr_attr_max: i16,
    pcb_drvr_attr: ?*i16,
) callconv(@import("std").os.windows.WINAPI) i16;

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindCol(
            statement_handle: ?*anyopaque,
            column_number: u16,
            target_type: i16,
            target_value: ?*anyopaque,
            buffer_length: i32,
            str_len_or__ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindParam(
            statement_handle: ?*anyopaque,
            parameter_number: u16,
            value_type: i16,
            parameter_type: i16,
            length_precision: u32,
            parameter_scale: i16,
            parameter_value: ?*anyopaque,
            str_len_or__ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttribute(
            statement_handle: ?*anyopaque,
            column_number: u16,
            field_identifier: u16,
            // TODO: what to do with BytesParamIndex 4?
            character_attribute: ?*anyopaque,
            buffer_length: i16,
            string_length: ?*i16,
            numeric_attribute: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeCol(
            statement_handle: ?*anyopaque,
            column_number: u16,
            column_name: ?[*:0]u8,
            buffer_length: i16,
            name_length: ?*i16,
            data_type: ?*i16,
            column_size: ?*u32,
            decimal_digits: ?*i16,
            nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLFetchScroll(
            statement_handle: ?*anyopaque,
            fetch_orientation: i16,
            fetch_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetData(
            statement_handle: ?*anyopaque,
            column_number: u16,
            target_type: i16,
            target_value: ?*anyopaque,
            buffer_length: i32,
            str_len_or__ind_ptr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRec(
            descriptor_handle: ?*anyopaque,
            rec_number: i16,
            name: ?[*:0]u8,
            buffer_length: i16,
            string_length_ptr: ?*i16,
            type_ptr: ?*i16,
            sub_type_ptr: ?*i16,
            length_ptr: ?*i32,
            precision_ptr: ?*i16,
            scale_ptr: ?*i16,
            nullable_ptr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLPutData(
            statement_handle: ?*anyopaque,
            data: ?*anyopaque,
            str_len_or__ind: i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLRowCount(
            statement_handle: ?*anyopaque,
            row_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOption(
            connection_handle: ?*anyopaque,
            option: u16,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetDescRec(
            descriptor_handle: ?*anyopaque,
            rec_number: i16,
            type: i16,
            sub_type: i16,
            length: i32,
            precision: i16,
            scale: i16,
            // TODO: what to do with BytesParamIndex 4?
            data: ?*anyopaque,
            string_length: ?*i32,
            indicator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetParam(
            statement_handle: ?*anyopaque,
            parameter_number: u16,
            value_type: i16,
            parameter_type: i16,
            length_precision: u32,
            parameter_scale: i16,
            parameter_value: ?*anyopaque,
            str_len_or__ind: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetStmtOption(
            statement_handle: ?*anyopaque,
            option: u16,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributes(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeParam(
            hstmt: ?*anyopaque,
            ipar: u16,
            pf_sql_type: ?*i16,
            pcb_param_def: ?*u32,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLExtendedFetch(
            hstmt: ?*anyopaque,
            f_fetch_type: u16,
            irow: i32,
            pcrow: ?*u32,
            rgf_row_status: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLParamOptions(
            hstmt: ?*anyopaque,
            crow: u32,
            pirow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetPos(
            hstmt: ?*anyopaque,
            irow: u16,
            f_option: u16,
            f_lock: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLBindParameter(
            hstmt: ?*anyopaque,
            ipar: u16,
            f_param_type: i16,
            f_c_type: i16,
            f_sql_type: i16,
            cb_col_def: u32,
            ib_scale: i16,
            rgb_value: ?*anyopaque,
            cb_value_max: i32,
            pcb_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetScrollOptions(
            hstmt: ?*anyopaque,
            f_concurrency: u16,
            crow_keyset: i32,
            crow_rowset: u16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributeW(
            hstmt: ?*anyopaque,
            i_col: u16,
            i_field: u16,
            // TODO: what to do with BytesParamIndex 4?
            p_char_attr: ?*anyopaque,
            cb_desc_max: i16,
            pcb_char_attr: ?*i16,
            p_num_attr: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributesW(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeColW(
            hstmt: ?*anyopaque,
            icol: u16,
            sz_col_name: ?[*:0]u16,
            cch_col_name_max: i16,
            pcch_col_name: ?*i16,
            pf_sql_type: ?*i16,
            pcb_col_def: ?*u32,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRecW(
            hdesc: ?*anyopaque,
            i_record: i16,
            sz_name: ?[*:0]u16,
            cch_name_max: i16,
            pcch_name: ?*i16,
            pf_type: ?*i16,
            pf_sub_type: ?*i16,
            p_length: ?*i32,
            p_precision: ?*i16,
            p_scale: ?*i16,
            p_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionW(
            hdbc: ?*anyopaque,
            f_option: u16,
            v_param: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributeA(
            hstmt: ?*anyopaque,
            i_col: i16,
            i_field: i16,
            // TODO: what to do with BytesParamIndex 4?
            p_char_attr: ?*anyopaque,
            cb_char_attr_max: i16,
            pcb_char_attr: ?*i16,
            p_num_attr: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLColAttributesA(
            hstmt: ?*anyopaque,
            icol: u16,
            f_desc_type: u16,
            // TODO: what to do with BytesParamIndex 4?
            rgb_desc: ?*anyopaque,
            cb_desc_max: i16,
            pcb_desc: ?*i16,
            pf_desc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLDescribeColA(
            hstmt: ?*anyopaque,
            icol: u16,
            sz_col_name: ?[*:0]u8,
            cb_col_name_max: i16,
            pcb_col_name: ?*i16,
            pf_sql_type: ?*i16,
            pcb_col_def: ?*u32,
            pib_scale: ?*i16,
            pf_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLGetDescRecA(
            hdesc: ?*anyopaque,
            i_record: i16,
            sz_name: ?[*:0]u8,
            cb_name_max: i16,
            pcb_name: ?*i16,
            pf_type: ?*i16,
            pf_sub_type: ?*i16,
            p_length: ?*i32,
            p_precision: ?*i16,
            p_scale: ?*i16,
            p_nullable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../zig.zig").arch) {
    .X86 => struct {
        pub extern "odbc32" fn SQLSetConnectOptionA(
            hdbc: ?*anyopaque,
            f_option: u16,
            v_param: u32,
        ) callconv(@import("std").os.windows.WINAPI) i16;
    },
    else => struct {},
};

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const bcp_init = thismodule.bcp_initA;
        pub const bcp_readfmt = thismodule.bcp_readfmtA;
        pub const bcp_writefmt = thismodule.bcp_writefmtA;
        pub const dbprtype = thismodule.dbprtypeA;
        pub const SQLLinkedCatalogs = thismodule.SQLLinkedCatalogsA;
    },
    .wide => struct {
        pub const bcp_init = thismodule.bcp_initW;
        pub const bcp_readfmt = thismodule.bcp_readfmtW;
        pub const bcp_writefmt = thismodule.bcp_writefmtW;
        pub const dbprtype = thismodule.dbprtypeW;
        pub const SQLLinkedCatalogs = thismodule.SQLLinkedCatalogsW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const bcp_init = *opaque {};
        pub const bcp_readfmt = *opaque {};
        pub const bcp_writefmt = *opaque {};
        pub const dbprtype = *opaque {};
        pub const SQLLinkedCatalogs = *opaque {};
    } else struct {
        pub const bcp_init = @compileError("'bcp_init' requires that UNICODE be set to true or false in the root module");
        pub const bcp_readfmt = @compileError("'bcp_readfmt' requires that UNICODE be set to true or false in the root module");
        pub const bcp_writefmt = @compileError("'bcp_writefmt' requires that UNICODE be set to true or false in the root module");
        pub const dbprtype = @compileError("'dbprtype' requires that UNICODE be set to true or false in the root module");
        pub const SQLLinkedCatalogs = @compileError("'SQLLinkedCatalogs' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (44)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CONDITION_OPERATION = @import("../system/search/common.zig").CONDITION_OPERATION;
const CONDITION_TYPE = @import("../system/search/common.zig").CONDITION_TYPE;
const COSERVERINFO = @import("../system/com.zig").COSERVERINFO;
const CY = @import("../system/com.zig").CY;
const DBID = @import("../storage/index_server.zig").DBID;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const EXPLICIT_ACCESS_W = @import("../security/authorization.zig").EXPLICIT_ACCESS_W;
const FILETIME = @import("../foundation.zig").FILETIME;
const FILTERREGION = @import("../storage/index_server.zig").FILTERREGION;
const FULLPROPSPEC = @import("../storage/index_server.zig").FULLPROPSPEC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IAuthenticate = @import("../system/com.zig").IAuthenticate;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IErrorInfo = @import("../system/com.zig").IErrorInfo;
const IFilter = @import("../storage/index_server.zig").IFilter;
const IMoniker = @import("../system/com.zig").IMoniker;
const IObjectArray = @import("../ui/shell/common.zig").IObjectArray;
const IPersistStream = @import("../system/com.zig").IPersistStream;
const IPhraseSink = @import("../storage/index_server.zig").IPhraseSink;
const ISequentialStream = @import("../system/com.zig").ISequentialStream;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITransaction = @import("../system/distributed_transaction_coordinator.zig").ITransaction;
const ITransactionOptions = @import("../system/distributed_transaction_coordinator.zig").ITransactionOptions;
const ITypeInfo = @import("../system/com.zig").ITypeInfo;
const IUnknown = @import("../system/com.zig").IUnknown;
const MULTI_QI = @import("../system/com.zig").MULTI_QI;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPSPEC = @import("../system/com/structured_storage.zig").PROPSPEC;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TRUSTEE_W = @import("../security/authorization.zig").TRUSTEE_W;
const VARIANT = @import("../system/com.zig").VARIANT;
const WORDREP_BREAK_TYPE = @import("../storage/index_server.zig").WORDREP_BREAK_TYPE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SQL_ASYNC_NOTIFICATION_CALLBACK")) {
        _ = SQL_ASYNC_NOTIFICATION_CALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("search/common.zig");
