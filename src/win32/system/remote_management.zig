//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (546)
//--------------------------------------------------------------------------------
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_0 = @as(u32, 0);
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_1 = @as(u32, 1);
pub const WSMAN_OPERATION_INFOV1 = @as(u32, 0);
pub const WSMAN_OPERATION_INFOV2 = @as(u32, 2864434397);
pub const WSMAN_DEFAULT_TIMEOUT_MS = @as(u32, 60000);
pub const WSMAN_STREAM_ID_STDIN = "stdin";
pub const WSMAN_STREAM_ID_STDOUT = "stdout";
pub const WSMAN_STREAM_ID_STDERR = "stderr";
pub const WSMAN_SHELL_NS = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell";
pub const WSMAN_CMDSHELL_OPTION_CODEPAGE = "WINRS_CODEPAGE";
pub const WSMAN_SHELL_OPTION_NOPROFILE = "WINRS_NOPROFILE";
pub const WSMAN_CMDSHELL_OPTION_CONSOLEMODE_STDIN = "WINRS_CONSOLEMODE_STDIN";
pub const WSMAN_CMDSHELL_OPTION_SKIP_CMD_SHELL = "WINRS_SKIP_CMD_SHELL";
pub const WSMAN_FLAG_RECEIVE_RESULT_NO_MORE_DATA = @as(u32, 1);
pub const WSMAN_FLAG_RECEIVE_FLUSH = @as(u32, 2);
pub const WSMAN_FLAG_RECEIVE_RESULT_DATA_BOUNDARY = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_MAX_ENVELOPE_SIZE = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_TIMEOUT = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_REMAINING_RESULT_SIZE = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_LARGEST_RESULT_SIZE = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_LOCALE = @as(u32, 5);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_DATA_LOCALE = @as(u32, 6);
pub const WSMAN_PLUGIN_PARAMS_SHAREDHOST = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_RUNAS_USER = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_AUTORESTART = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_HOSTIDLETIMEOUTSECONDS = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_NAME = @as(u32, 5);
pub const WSMAN_PLUGIN_STARTUP_REQUEST_RECEIVED = @as(u32, 0);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_REBOOT = @as(u32, 1);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_CRASH = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_SYSTEM = @as(u32, 1);
pub const WSMAN_PLUGIN_SHUTDOWN_SERVICE = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_IISHOST = @as(u32, 3);
pub const WSMAN_PLUGIN_SHUTDOWN_IDLETIMEOUT_ELAPSED = @as(u32, 4);
pub const WSMAN_FLAG_SEND_NO_MORE_DATA = @as(u32, 1);
pub const ERROR_WSMAN_RESOURCE_NOT_FOUND = @as(u32, 2150858752);
pub const ERROR_WSMAN_INVALID_ACTIONURI = @as(u32, 2150858753);
pub const ERROR_WSMAN_INVALID_URI = @as(u32, 2150858754);
pub const ERROR_WSMAN_PROVIDER_FAILURE = @as(u32, 2150858755);
pub const ERROR_WSMAN_BATCH_COMPLETE = @as(u32, 2150858756);
pub const ERROR_WSMAN_CONFIG_CORRUPTED = @as(u32, 2150858757);
pub const ERROR_WSMAN_PULL_IN_PROGRESS = @as(u32, 2150858758);
pub const ERROR_WSMAN_ENUMERATION_CLOSED = @as(u32, 2150858759);
pub const ERROR_WSMAN_SUBSCRIPTION_CLOSED = @as(u32, 2150858760);
pub const ERROR_WSMAN_SUBSCRIPTION_CLOSE_IN_PROGRESS = @as(u32, 2150858761);
pub const ERROR_WSMAN_SUBSCRIPTION_CLIENT_DID_NOT_CALL_WITHIN_HEARTBEAT = @as(u32, 2150858762);
pub const ERROR_WSMAN_SUBSCRIPTION_NO_HEARTBEAT = @as(u32, 2150858763);
pub const ERROR_WSMAN_UNSUPPORTED_TIMEOUT = @as(u32, 2150858764);
pub const ERROR_WSMAN_SOAP_VERSION_MISMATCH = @as(u32, 2150858765);
pub const ERROR_WSMAN_SOAP_DATA_ENCODING_UNKNOWN = @as(u32, 2150858766);
pub const ERROR_WSMAN_INVALID_MESSAGE_INFORMATION_HEADER = @as(u32, 2150858767);
pub const ERROR_WSMAN_SOAP_FAULT_MUST_UNDERSTAND = @as(u32, 2150858768);
pub const ERROR_WSMAN_MESSAGE_INFORMATION_HEADER_REQUIRED = @as(u32, 2150858769);
pub const ERROR_WSMAN_DESTINATION_UNREACHABLE = @as(u32, 2150858770);
pub const ERROR_WSMAN_ACTION_NOT_SUPPORTED = @as(u32, 2150858771);
pub const ERROR_WSMAN_ENDPOINT_UNAVAILABLE = @as(u32, 2150858772);
pub const ERROR_WSMAN_INVALID_REPRESENTATION = @as(u32, 2150858773);
pub const ERROR_WSMAN_ENUMERATE_INVALID_EXPIRATION_TIME = @as(u32, 2150858774);
pub const ERROR_WSMAN_ENUMERATE_UNSUPPORTED_EXPIRATION_TIME = @as(u32, 2150858775);
pub const ERROR_WSMAN_ENUMERATE_FILTERING_NOT_SUPPORTED = @as(u32, 2150858776);
pub const ERROR_WSMAN_ENUMERATE_FILTER_DIALECT_REQUESTED_UNAVAILABLE = @as(u32, 2150858777);
pub const ERROR_WSMAN_ENUMERATE_CANNOT_PROCESS_FILTER = @as(u32, 2150858778);
pub const ERROR_WSMAN_ENUMERATE_INVALID_ENUMERATION_CONTEXT = @as(u32, 2150858779);
pub const ERROR_WSMAN_ENUMERATE_TIMED_OUT = @as(u32, 2150858780);
pub const ERROR_WSMAN_ENUMERATE_UNABLE_TO_RENEW = @as(u32, 2150858781);
pub const ERROR_WSMAN_EVENTING_DELIVERY_MODE_REQUESTED_UNAVAILABLE = @as(u32, 2150858782);
pub const ERROR_WSMAN_EVENTING_INVALID_EXPIRATION_TIME = @as(u32, 2150858783);
pub const ERROR_WSMAN_EVENTING_UNSUPPORTED_EXPIRATION_TYPE = @as(u32, 2150858784);
pub const ERROR_WSMAN_EVENTING_FILTERING_NOT_SUPPORTED = @as(u32, 2150858785);
pub const ERROR_WSMAN_EVENTING_FILTERING_REQUESTED_UNAVAILABLE = @as(u32, 2150858786);
pub const ERROR_WSMAN_EVENTING_SOURCE_UNABLE_TO_PROCESS = @as(u32, 2150858787);
pub const ERROR_WSMAN_EVENTING_UNABLE_TO_RENEW = @as(u32, 2150858788);
pub const ERROR_WSMAN_EVENTING_INVALID_MESSAGE = @as(u32, 2150858789);
pub const ERROR_WSMAN_ENVELOPE_TOO_LARGE = @as(u32, 2150858790);
pub const ERROR_WSMAN_INVALID_SOAP_BODY = @as(u32, 2150858791);
pub const ERROR_WSMAN_INVALID_RESUMPTION_CONTEXT = @as(u32, 2150858792);
pub const ERROR_WSMAN_OPERATION_TIMEDOUT = @as(u32, 2150858793);
pub const ERROR_WSMAN_RESUMPTION_NOT_SUPPORTED = @as(u32, 2150858794);
pub const ERROR_WSMAN_RESUMPTION_TYPE_NOT_SUPPORTED = @as(u32, 2150858795);
pub const ERROR_WSMAN_UNSUPPORTED_ENCODING = @as(u32, 2150858796);
pub const ERROR_WSMAN_URI_LIMIT = @as(u32, 2150858797);
pub const ERROR_WSMAN_INVALID_PROPOSED_ID = @as(u32, 2150858798);
pub const ERROR_WSMAN_INVALID_BATCH_PARAMETER = @as(u32, 2150858799);
pub const ERROR_WSMAN_NO_ACK = @as(u32, 2150858800);
pub const ERROR_WSMAN_ACTION_MISMATCH = @as(u32, 2150858801);
pub const ERROR_WSMAN_CONCURRENCY = @as(u32, 2150858802);
pub const ERROR_WSMAN_ALREADY_EXISTS = @as(u32, 2150858803);
pub const ERROR_WSMAN_DELIVERY_REFUSED = @as(u32, 2150858804);
pub const ERROR_WSMAN_ENCODING_LIMIT = @as(u32, 2150858805);
pub const ERROR_WSMAN_FAILED_AUTHENTICATION = @as(u32, 2150858806);
pub const ERROR_WSMAN_INCOMPATIBLE_EPR = @as(u32, 2150858807);
pub const ERROR_WSMAN_INVALID_BOOKMARK = @as(u32, 2150858808);
pub const ERROR_WSMAN_INVALID_OPTIONS = @as(u32, 2150858809);
pub const ERROR_WSMAN_INVALID_PARAMETER = @as(u32, 2150858810);
pub const ERROR_WSMAN_INVALID_RESOURCE_URI = @as(u32, 2150858811);
pub const ERROR_WSMAN_INVALID_SYSTEM = @as(u32, 2150858812);
pub const ERROR_WSMAN_INVALID_SELECTORS = @as(u32, 2150858813);
pub const ERROR_WSMAN_METADATA_REDIRECT = @as(u32, 2150858814);
pub const ERROR_WSMAN_QUOTA_LIMIT = @as(u32, 2150858815);
pub const ERROR_WSMAN_RENAME_FAILURE = @as(u32, 2150858816);
pub const ERROR_WSMAN_SCHEMA_VALIDATION_ERROR = @as(u32, 2150858817);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE = @as(u32, 2150858818);
pub const ERROR_WSMAN_INVALID_XML = @as(u32, 2150858819);
pub const ERROR_WSMAN_INVALID_KEY = @as(u32, 2150858820);
pub const ERROR_WSMAN_DELIVER_IN_PROGRESS = @as(u32, 2150858821);
pub const ERROR_WSMAN_SYSTEM_NOT_FOUND = @as(u32, 2150858822);
pub const ERROR_WSMAN_MAX_ENVELOPE_SIZE = @as(u32, 2150858823);
pub const ERROR_WSMAN_MAX_ENVELOPE_SIZE_EXCEEDED = @as(u32, 2150858824);
pub const ERROR_WSMAN_SERVER_ENVELOPE_LIMIT = @as(u32, 2150858825);
pub const ERROR_WSMAN_SELECTOR_LIMIT = @as(u32, 2150858826);
pub const ERROR_WSMAN_OPTION_LIMIT = @as(u32, 2150858827);
pub const ERROR_WSMAN_CHARACTER_SET = @as(u32, 2150858828);
pub const ERROR_WSMAN_UNREPORTABLE_SUCCESS = @as(u32, 2150858829);
pub const ERROR_WSMAN_WHITESPACE = @as(u32, 2150858830);
pub const ERROR_WSMAN_FILTERING_REQUIRED = @as(u32, 2150858831);
pub const ERROR_WSMAN_BOOKMARK_EXPIRED = @as(u32, 2150858832);
pub const ERROR_WSMAN_OPTIONS_NOT_SUPPORTED = @as(u32, 2150858833);
pub const ERROR_WSMAN_OPTIONS_INVALID_NAME = @as(u32, 2150858834);
pub const ERROR_WSMAN_OPTIONS_INVALID_VALUE = @as(u32, 2150858835);
pub const ERROR_WSMAN_PARAMETER_TYPE_MISMATCH = @as(u32, 2150858836);
pub const ERROR_WSMAN_INVALID_PARAMETER_NAME = @as(u32, 2150858837);
pub const ERROR_WSMAN_INVALID_XML_VALUES = @as(u32, 2150858838);
pub const ERROR_WSMAN_INVALID_XML_MISSING_VALUES = @as(u32, 2150858839);
pub const ERROR_WSMAN_INVALID_XML_NAMESPACE = @as(u32, 2150858840);
pub const ERROR_WSMAN_INVALID_XML_FRAGMENT = @as(u32, 2150858841);
pub const ERROR_WSMAN_INSUFFCIENT_SELECTORS = @as(u32, 2150858842);
pub const ERROR_WSMAN_UNEXPECTED_SELECTORS = @as(u32, 2150858843);
pub const ERROR_WSMAN_SELECTOR_TYPEMISMATCH = @as(u32, 2150858844);
pub const ERROR_WSMAN_INVALID_SELECTOR_VALUE = @as(u32, 2150858845);
pub const ERROR_WSMAN_AMBIGUOUS_SELECTORS = @as(u32, 2150858846);
pub const ERROR_WSMAN_DUPLICATE_SELECTORS = @as(u32, 2150858847);
pub const ERROR_WSMAN_INVALID_TARGET_SELECTORS = @as(u32, 2150858848);
pub const ERROR_WSMAN_INVALID_TARGET_RESOURCEURI = @as(u32, 2150858849);
pub const ERROR_WSMAN_INVALID_TARGET_SYSTEM = @as(u32, 2150858850);
pub const ERROR_WSMAN_TARGET_ALREADY_EXISTS = @as(u32, 2150858851);
pub const ERROR_WSMAN_AUTHORIZATION_MODE_NOT_SUPPORTED = @as(u32, 2150858852);
pub const ERROR_WSMAN_ACK_NOT_SUPPORTED = @as(u32, 2150858853);
pub const ERROR_WSMAN_OPERATION_TIMEOUT_NOT_SUPPORTED = @as(u32, 2150858854);
pub const ERROR_WSMAN_LOCALE_NOT_SUPPORTED = @as(u32, 2150858855);
pub const ERROR_WSMAN_EXPIRATION_TIME_NOT_SUPPORTED = @as(u32, 2150858856);
pub const ERROR_WSMAN_DELIVERY_RETRIES_NOT_SUPPORTED = @as(u32, 2150858857);
pub const ERROR_WSMAN_HEARTBEATS_NOT_SUPPORTED = @as(u32, 2150858858);
pub const ERROR_WSMAN_BOOKMARKS_NOT_SUPPORTED = @as(u32, 2150858859);
pub const ERROR_WSMAN_MAXITEMS_NOT_SUPPORTED = @as(u32, 2150858860);
pub const ERROR_WSMAN_MAXTIME_NOT_SUPPORTED = @as(u32, 2150858861);
pub const ERROR_WSMAN_MAXENVELOPE_SIZE_NOT_SUPPORTED = @as(u32, 2150858862);
pub const ERROR_WSMAN_MAXENVELOPE_POLICY_NOT_SUPPORTED = @as(u32, 2150858863);
pub const ERROR_WSMAN_FILTERING_REQUIRED_NOT_SUPPORTED = @as(u32, 2150858864);
pub const ERROR_WSMAN_INSECURE_ADDRESS_NOT_SUPPORTED = @as(u32, 2150858865);
pub const ERROR_WSMAN_FORMAT_MISMATCH_NOT_SUPPORTED = @as(u32, 2150858866);
pub const ERROR_WSMAN_FORMAT_SECURITY_TOKEN_NOT_SUPPORTED = @as(u32, 2150858867);
pub const ERROR_WSMAN_BAD_METHOD = @as(u32, 2150858868);
pub const ERROR_WSMAN_UNSUPPORTED_MEDIA = @as(u32, 2150858869);
pub const ERROR_WSMAN_UNSUPPORTED_ADDRESSING_MODE = @as(u32, 2150858870);
pub const ERROR_WSMAN_FRAGMENT_TRANSFER_NOT_SUPPORTED = @as(u32, 2150858871);
pub const ERROR_WSMAN_ENUMERATION_INITIALIZING = @as(u32, 2150858872);
pub const ERROR_WSMAN_CONNECTOR_GET = @as(u32, 2150858873);
pub const ERROR_WSMAN_URI_QUERY_STRING_SYNTAX_ERROR = @as(u32, 2150858874);
pub const ERROR_WSMAN_INEXISTENT_MAC_ADDRESS = @as(u32, 2150858875);
pub const ERROR_WSMAN_NO_UNICAST_ADDRESSES = @as(u32, 2150858876);
pub const ERROR_WSMAN_NO_DHCP_ADDRESSES = @as(u32, 2150858877);
pub const ERROR_WSMAN_MIN_ENVELOPE_SIZE = @as(u32, 2150858878);
pub const ERROR_WSMAN_EPR_NESTING_EXCEEDED = @as(u32, 2150858879);
pub const ERROR_WSMAN_REQUEST_INIT_ERROR = @as(u32, 2150858880);
pub const ERROR_WSMAN_INVALID_TIMEOUT_HEADER = @as(u32, 2150858881);
pub const ERROR_WSMAN_CERT_NOT_FOUND = @as(u32, 2150858882);
pub const ERROR_WSMAN_PLUGIN_FAILED = @as(u32, 2150858883);
pub const ERROR_WSMAN_ENUMERATION_INVALID = @as(u32, 2150858884);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_MUTUAL = @as(u32, 2150858885);
pub const ERROR_WSMAN_ENUMERATION_MODE_UNSUPPORTED = @as(u32, 2150858886);
pub const ERROR_WSMAN_MUSTUNDERSTAND_ON_LOCALE_UNSUPPORTED = @as(u32, 2150858887);
pub const ERROR_WSMAN_POLICY_CORRUPTED = @as(u32, 2150858888);
pub const ERROR_WSMAN_LISTENER_ADDRESS_INVALID = @as(u32, 2150858889);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_GPO_CONTROLLED_SETTING = @as(u32, 2150858890);
pub const ERROR_WSMAN_EVENTING_CONCURRENT_CLIENT_RECEIVE = @as(u32, 2150858891);
pub const ERROR_WSMAN_EVENTING_FAST_SENDER = @as(u32, 2150858892);
pub const ERROR_WSMAN_EVENTING_INSECURE_PUSHSUBSCRIPTION_CONNECTION = @as(u32, 2150858893);
pub const ERROR_WSMAN_EVENTING_INVALID_EVENTSOURCE = @as(u32, 2150858894);
pub const ERROR_WSMAN_EVENTING_NOMATCHING_LISTENER = @as(u32, 2150858895);
pub const ERROR_WSMAN_FRAGMENT_DIALECT_REQUESTED_UNAVAILABLE = @as(u32, 2150858896);
pub const ERROR_WSMAN_MISSING_FRAGMENT_PATH = @as(u32, 2150858897);
pub const ERROR_WSMAN_INVALID_FRAGMENT_DIALECT = @as(u32, 2150858898);
pub const ERROR_WSMAN_INVALID_FRAGMENT_PATH = @as(u32, 2150858899);
pub const ERROR_WSMAN_EVENTING_INCOMPATIBLE_BATCHPARAMS_AND_DELIVERYMODE = @as(u32, 2150858900);
pub const ERROR_WSMAN_EVENTING_LOOPBACK_TESTFAILED = @as(u32, 2150858901);
pub const ERROR_WSMAN_EVENTING_INVALID_ENDTO_ADDRESSS = @as(u32, 2150858902);
pub const ERROR_WSMAN_EVENTING_INVALID_INCOMING_EVENT_PACKET_HEADER = @as(u32, 2150858903);
pub const ERROR_WSMAN_SESSION_ALREADY_CLOSED = @as(u32, 2150858904);
pub const ERROR_WSMAN_SUBSCRIPTION_LISTENER_NOLONGERVALID = @as(u32, 2150858905);
pub const ERROR_WSMAN_PROVIDER_LOAD_FAILED = @as(u32, 2150858906);
pub const ERROR_WSMAN_EVENTING_SUBSCRIPTIONCLOSED_BYREMOTESERVICE = @as(u32, 2150858907);
pub const ERROR_WSMAN_EVENTING_DELIVERYFAILED_FROMSOURCE = @as(u32, 2150858908);
pub const ERROR_WSMAN_SECURITY_UNMAPPED = @as(u32, 2150858909);
pub const ERROR_WSMAN_EVENTING_SUBSCRIPTION_CANCELLED_BYSOURCE = @as(u32, 2150858910);
pub const ERROR_WSMAN_INVALID_HOSTNAME_PATTERN = @as(u32, 2150858911);
pub const ERROR_WSMAN_EVENTING_MISSING_NOTIFYTO = @as(u32, 2150858912);
pub const ERROR_WSMAN_EVENTING_MISSING_NOTIFYTO_ADDRESSS = @as(u32, 2150858913);
pub const ERROR_WSMAN_EVENTING_INVALID_NOTIFYTO_ADDRESSS = @as(u32, 2150858914);
pub const ERROR_WSMAN_EVENTING_INVALID_LOCALE_IN_DELIVERY = @as(u32, 2150858915);
pub const ERROR_WSMAN_EVENTING_INVALID_HEARTBEAT = @as(u32, 2150858916);
pub const ERROR_WSMAN_MACHINE_OPTION_REQUIRED = @as(u32, 2150858917);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE_OPTIONS = @as(u32, 2150858918);
pub const ERROR_WSMAN_BATCHSIZE_TOO_SMALL = @as(u32, 2150858919);
pub const ERROR_WSMAN_EVENTING_DELIVERY_MODE_REQUESTED_INVALID = @as(u32, 2150858920);
pub const ERROR_WSMAN_PROVSYS_NOT_SUPPORTED = @as(u32, 2150858921);
pub const ERROR_WSMAN_PUSH_SUBSCRIPTION_CONFIG_INVALID = @as(u32, 2150858922);
pub const ERROR_WSMAN_CREDS_PASSED_WITH_NO_AUTH_FLAG = @as(u32, 2150858923);
pub const ERROR_WSMAN_CLIENT_INVALID_FLAG = @as(u32, 2150858924);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_AUTH_FLAGS = @as(u32, 2150858925);
pub const ERROR_WSMAN_CLIENT_SPN_WRONG_AUTH = @as(u32, 2150858926);
pub const ERROR_WSMAN_CLIENT_CERT_UNNEEDED_CREDS = @as(u32, 2150858927);
pub const ERROR_WSMAN_CLIENT_USERNAME_PASSWORD_NEEDED = @as(u32, 2150858928);
pub const ERROR_WSMAN_CLIENT_CERT_UNNEEDED_USERNAME = @as(u32, 2150858929);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_NEEDED = @as(u32, 2150858930);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FLAG_NEEDED = @as(u32, 2150858931);
pub const ERROR_WSMAN_CLIENT_CERT_NEEDED = @as(u32, 2150858932);
pub const ERROR_WSMAN_CLIENT_CERT_UNKNOWN_TYPE = @as(u32, 2150858933);
pub const ERROR_WSMAN_CLIENT_CERT_UNKNOWN_LOCATION = @as(u32, 2150858934);
pub const ERROR_WSMAN_CLIENT_INVALID_CERT = @as(u32, 2150858935);
pub const ERROR_WSMAN_CLIENT_LOCAL_INVALID_CREDS = @as(u32, 2150858936);
pub const ERROR_WSMAN_CLIENT_LOCAL_INVALID_CONNECTION_OPTIONS = @as(u32, 2150858937);
pub const ERROR_WSMAN_CLIENT_CREATESESSION_NULL_PARAM = @as(u32, 2150858938);
pub const ERROR_WSMAN_CLIENT_ENUMERATE_NULL_PARAM = @as(u32, 2150858939);
pub const ERROR_WSMAN_CLIENT_SUBSCRIBE_NULL_PARAM = @as(u32, 2150858940);
pub const ERROR_WSMAN_CLIENT_NULL_RESULT_PARAM = @as(u32, 2150858941);
pub const ERROR_WSMAN_CLIENT_NO_HANDLE = @as(u32, 2150858942);
pub const ERROR_WSMAN_CLIENT_BLANK_URI = @as(u32, 2150858943);
pub const ERROR_WSMAN_CLIENT_INVALID_RESOURCE_LOCATOR = @as(u32, 2150858944);
pub const ERROR_WSMAN_CLIENT_BLANK_INPUT_XML = @as(u32, 2150858945);
pub const ERROR_WSMAN_CLIENT_BATCH_ITEMS_TOO_SMALL = @as(u32, 2150858946);
pub const ERROR_WSMAN_CLIENT_MAX_CHARS_TOO_SMALL = @as(u32, 2150858947);
pub const ERROR_WSMAN_CLIENT_BLANK_ACTION_URI = @as(u32, 2150858948);
pub const ERROR_WSMAN_CLIENT_ZERO_HEARTBEAT = @as(u32, 2150858949);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_DELIVERY_MODES = @as(u32, 2150858950);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_ENVELOPE_POLICIES = @as(u32, 2150858951);
pub const ERROR_WSMAN_CLIENT_UNKNOWN_EXPIRATION_TYPE = @as(u32, 2150858952);
pub const ERROR_WSMAN_CLIENT_MISSING_EXPIRATION = @as(u32, 2150858953);
pub const ERROR_WSMAN_CLIENT_PULL_INVALID_FLAGS = @as(u32, 2150858954);
pub const ERROR_WSMAN_CLIENT_PUSH_UNSUPPORTED_TRANSPORT = @as(u32, 2150858955);
pub const ERROR_WSMAN_CLIENT_PUSH_HOST_TOO_LONG = @as(u32, 2150858956);
pub const ERROR_WSMAN_CLIENT_COMPRESSION_INVALID_OPTION = @as(u32, 2150858957);
pub const ERROR_WSMAN_CLIENT_DELIVERENDSUBSCRIPTION_NULL_PARAM = @as(u32, 2150858958);
pub const ERROR_WSMAN_CLIENT_DELIVEREVENTS_NULL_PARAM = @as(u32, 2150858959);
pub const ERROR_WSMAN_CLIENT_GETBOOKMARK_NULL_PARAM = @as(u32, 2150858960);
pub const ERROR_WSMAN_CLIENT_DECODEOBJECT_NULL_PARAM = @as(u32, 2150858961);
pub const ERROR_WSMAN_CLIENT_ENCODEOBJECT_NULL_PARAM = @as(u32, 2150858962);
pub const ERROR_WSMAN_CLIENT_ENUMERATORADDOBJECT_NULL_PARAM = @as(u32, 2150858963);
pub const ERROR_WSMAN_CLIENT_ENUMERATORNEXTOBJECT_NULL_PARAM = @as(u32, 2150858964);
pub const ERROR_WSMAN_CLIENT_CONSTRUCTERROR_NULL_PARAM = @as(u32, 2150858965);
pub const ERROR_WSMAN_SERVER_NONPULLSUBSCRIBE_NULL_PARAM = @as(u32, 2150858966);
pub const ERROR_WSMAN_CLIENT_UNENCRYPTED_HTTP_ONLY = @as(u32, 2150858967);
pub const ERROR_WSMAN_CANNOT_USE_CERTIFICATES_FOR_HTTP = @as(u32, 2150858968);
pub const ERROR_WSMAN_CONNECTIONSTR_INVALID = @as(u32, 2150858969);
pub const ERROR_WSMAN_TRANSPORT_NOT_SUPPORTED = @as(u32, 2150858970);
pub const ERROR_WSMAN_PORT_INVALID = @as(u32, 2150858971);
pub const ERROR_WSMAN_CONFIG_PORT_INVALID = @as(u32, 2150858972);
pub const ERROR_WSMAN_SENDHEARBEAT_EMPTY_ENUMERATOR = @as(u32, 2150858973);
pub const ERROR_WSMAN_CLIENT_UNENCRYPTED_DISABLED = @as(u32, 2150858974);
pub const ERROR_WSMAN_CLIENT_BASIC_AUTHENTICATION_DISABLED = @as(u32, 2150858975);
pub const ERROR_WSMAN_CLIENT_DIGEST_AUTHENTICATION_DISABLED = @as(u32, 2150858976);
pub const ERROR_WSMAN_CLIENT_NEGOTIATE_AUTHENTICATION_DISABLED = @as(u32, 2150858977);
pub const ERROR_WSMAN_CLIENT_KERBEROS_AUTHENTICATION_DISABLED = @as(u32, 2150858978);
pub const ERROR_WSMAN_CLIENT_CERTIFICATES_AUTHENTICATION_DISABLED = @as(u32, 2150858979);
pub const ERROR_WSMAN_SERVER_NOT_TRUSTED = @as(u32, 2150858980);
pub const ERROR_WSMAN_EXPLICIT_CREDENTIALS_REQUIRED = @as(u32, 2150858981);
pub const ERROR_WSMAN_CERT_THUMBPRINT_NOT_BLANK = @as(u32, 2150858982);
pub const ERROR_WSMAN_CERT_THUMBPRINT_BLANK = @as(u32, 2150858983);
pub const ERROR_WSMAN_CONFIG_CANNOT_SHARE_SSL_CONFIG = @as(u32, 2150858984);
pub const ERROR_WSMAN_CONFIG_CERT_CN_DOES_NOT_MATCH_HOSTNAME = @as(u32, 2150858985);
pub const ERROR_WSMAN_CONFIG_HOSTNAME_CHANGE_WITHOUT_CERT = @as(u32, 2150858986);
pub const ERROR_WSMAN_CONFIG_THUMBPRINT_SHOULD_BE_EMPTY = @as(u32, 2150858987);
pub const ERROR_WSMAN_INVALID_IPFILTER = @as(u32, 2150858988);
pub const ERROR_WSMAN_CANNOT_CHANGE_KEYS = @as(u32, 2150858989);
pub const ERROR_WSMAN_CERT_INVALID_USAGE = @as(u32, 2150858990);
pub const ERROR_WSMAN_RESPONSE_NO_RESULTS = @as(u32, 2150858991);
pub const ERROR_WSMAN_CREATE_RESPONSE_NO_EPR = @as(u32, 2150858992);
pub const ERROR_WSMAN_RESPONSE_INVALID_ENUMERATION_CONTEXT = @as(u32, 2150858993);
pub const ERROR_WSMAN_RESPONSE_NO_XML_FRAGMENT_WRAPPER = @as(u32, 2150858994);
pub const ERROR_WSMAN_RESPONSE_INVALID_MESSAGE_INFORMATION_HEADER = @as(u32, 2150858995);
pub const ERROR_WSMAN_RESPONSE_NO_SOAP_HEADER_BODY = @as(u32, 2150858996);
pub const ERROR_WSMAN_HTTP_NO_RESPONSE_DATA = @as(u32, 2150858997);
pub const ERROR_WSMAN_RESPONSE_INVALID_SOAP_FAULT = @as(u32, 2150858998);
pub const ERROR_WSMAN_HTTP_INVALID_CONTENT_TYPE_IN_RESPONSE_DATA = @as(u32, 2150858999);
pub const ERROR_WSMAN_HTTP_CONTENT_TYPE_MISSMATCH_RESPONSE_DATA = @as(u32, 2150859000);
pub const ERROR_WSMAN_CANNOT_DECRYPT = @as(u32, 2150859001);
pub const ERROR_WSMAN_INVALID_URI_WMI_SINGLETON = @as(u32, 2150859002);
pub const ERROR_WSMAN_INVALID_URI_WMI_ENUM_WQL = @as(u32, 2150859003);
pub const ERROR_WSMAN_NO_IDENTIFY_FOR_LOCAL_SESSION = @as(u32, 2150859004);
pub const ERROR_WSMAN_NO_PUSH_SUBSCRIPTION_FOR_LOCAL_SESSION = @as(u32, 2150859005);
pub const ERROR_WSMAN_INVALID_SUBSCRIPTION_MANAGER = @as(u32, 2150859006);
pub const ERROR_WSMAN_NON_PULL_SUBSCRIPTION_NOT_SUPPORTED = @as(u32, 2150859007);
pub const ERROR_WSMAN_WMI_MAX_NESTED = @as(u32, 2150859008);
pub const ERROR_WSMAN_REMOTE_CIMPATH_NOT_SUPPORTED = @as(u32, 2150859009);
pub const ERROR_WSMAN_WMI_PROVIDER_NOT_CAPABLE = @as(u32, 2150859010);
pub const ERROR_WSMAN_WMI_INVALID_VALUE = @as(u32, 2150859011);
pub const ERROR_WSMAN_WMI_SVC_ACCESS_DENIED = @as(u32, 2150859012);
pub const ERROR_WSMAN_WMI_PROVIDER_ACCESS_DENIED = @as(u32, 2150859013);
pub const ERROR_WSMAN_WMI_CANNOT_CONNECT_ACCESS_DENIED = @as(u32, 2150859014);
pub const ERROR_WSMAN_INVALID_FILTER_XML = @as(u32, 2150859015);
pub const ERROR_WSMAN_ENUMERATE_WMI_INVALID_KEY = @as(u32, 2150859016);
pub const ERROR_WSMAN_INVALID_FRAGMENT_PATH_BLANK = @as(u32, 2150859017);
pub const ERROR_WSMAN_INVALID_CHARACTERS_IN_RESPONSE = @as(u32, 2150859018);
pub const ERROR_WSMAN_KERBEROS_IPADDRESS = @as(u32, 2150859019);
pub const ERROR_WSMAN_CLIENT_WORKGROUP_NO_KERBEROS = @as(u32, 2150859020);
pub const ERROR_WSMAN_INVALID_BATCH_SETTINGS_PARAMETER = @as(u32, 2150859021);
pub const ERROR_WSMAN_SERVER_DESTINATION_LOCALHOST = @as(u32, 2150859022);
pub const ERROR_WSMAN_UNKNOWN_HTTP_STATUS_RETURNED = @as(u32, 2150859023);
pub const ERROR_WSMAN_UNSUPPORTED_HTTP_STATUS_REDIRECT = @as(u32, 2150859024);
pub const ERROR_WSMAN_HTTP_REQUEST_TOO_LARGE_STATUS = @as(u32, 2150859025);
pub const ERROR_WSMAN_HTTP_SERVICE_UNAVAILABLE_STATUS = @as(u32, 2150859026);
pub const ERROR_WSMAN_HTTP_NOT_FOUND_STATUS = @as(u32, 2150859027);
pub const ERROR_WSMAN_EVENTING_MISSING_LOCALE_IN_DELIVERY = @as(u32, 2150859028);
pub const ERROR_WSMAN_QUICK_CONFIG_FAILED_CERT_REQUIRED = @as(u32, 2150859029);
pub const ERROR_WSMAN_QUICK_CONFIG_FIREWALL_EXCEPTIONS_DISALLOWED = @as(u32, 2150859030);
pub const ERROR_WSMAN_QUICK_CONFIG_LOCAL_POLICY_CHANGE_DISALLOWED = @as(u32, 2150859031);
pub const ERROR_WSMAN_INVALID_SELECTOR_NAME = @as(u32, 2150859032);
pub const ERROR_WSMAN_ENCODING_TYPE = @as(u32, 2150859033);
pub const ERROR_WSMAN_ENDPOINT_UNAVAILABLE_INVALID_VALUE = @as(u32, 2150859034);
pub const ERROR_WSMAN_INVALID_HEADER = @as(u32, 2150859035);
pub const ERROR_WSMAN_ENUMERATE_UNSUPPORTED_EXPIRATION_TYPE = @as(u32, 2150859036);
pub const ERROR_WSMAN_MAX_ELEMENTS_NOT_SUPPORTED = @as(u32, 2150859037);
pub const ERROR_WSMAN_WMI_PROVIDER_INVALID_PARAMETER = @as(u32, 2150859038);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_ENUM_MODE_FLAGS = @as(u32, 2150859039);
pub const ERROR_WINRS_CLIENT_INVALID_FLAG = @as(u32, 2150859040);
pub const ERROR_WINRS_CLIENT_NULL_PARAM = @as(u32, 2150859041);
pub const ERROR_WSMAN_CANNOT_PROCESS_FILTER = @as(u32, 2150859042);
pub const ERROR_WSMAN_CLIENT_ENUMERATORADDEVENT_NULL_PARAM = @as(u32, 2150859043);
pub const ERROR_WSMAN_ADDOBJECT_MISSING_OBJECT = @as(u32, 2150859044);
pub const ERROR_WSMAN_ADDOBJECT_MISSING_EPR = @as(u32, 2150859045);
pub const ERROR_WSMAN_NETWORK_TIMEDOUT = @as(u32, 2150859046);
pub const ERROR_WINRS_RECEIVE_IN_PROGRESS = @as(u32, 2150859047);
pub const ERROR_WINRS_RECEIVE_NO_RESPONSE_DATA = @as(u32, 2150859048);
pub const ERROR_WINRS_CLIENT_CREATESHELL_NULL_PARAM = @as(u32, 2150859049);
pub const ERROR_WINRS_CLIENT_CLOSESHELL_NULL_PARAM = @as(u32, 2150859050);
pub const ERROR_WINRS_CLIENT_FREECREATESHELLRESULT_NULL_PARAM = @as(u32, 2150859051);
pub const ERROR_WINRS_CLIENT_RUNCOMMAND_NULL_PARAM = @as(u32, 2150859052);
pub const ERROR_WINRS_CLIENT_FREERUNCOMMANDRESULT_NULL_PARAM = @as(u32, 2150859053);
pub const ERROR_WINRS_CLIENT_SIGNAL_NULL_PARAM = @as(u32, 2150859054);
pub const ERROR_WINRS_CLIENT_RECEIVE_NULL_PARAM = @as(u32, 2150859055);
pub const ERROR_WINRS_CLIENT_FREEPULLRESULT_NULL_PARAM = @as(u32, 2150859056);
pub const ERROR_WINRS_CLIENT_PULL_NULL_PARAM = @as(u32, 2150859057);
pub const ERROR_WINRS_CLIENT_CLOSERECEIVEHANDLE_NULL_PARAM = @as(u32, 2150859058);
pub const ERROR_WINRS_CLIENT_SEND_NULL_PARAM = @as(u32, 2150859059);
pub const ERROR_WINRS_CLIENT_PUSH_NULL_PARAM = @as(u32, 2150859060);
pub const ERROR_WINRS_CLIENT_CLOSESENDHANDLE_NULL_PARAM = @as(u32, 2150859061);
pub const ERROR_WINRS_CLIENT_GET_NULL_PARAM = @as(u32, 2150859062);
pub const ERROR_WSMAN_POLYMORPHISM_MODE_UNSUPPORTED = @as(u32, 2150859063);
pub const ERROR_WSMAN_REQUEST_NOT_SUPPORTED_AT_SERVICE = @as(u32, 2150859064);
pub const ERROR_WSMAN_URI_NON_DMTF_CLASS = @as(u32, 2150859065);
pub const ERROR_WSMAN_URI_WRONG_DMTF_VERSION = @as(u32, 2150859066);
pub const ERROR_WSMAN_DIFFERENT_CIM_SELECTOR = @as(u32, 2150859067);
pub const ERROR_WSMAN_PUSHSUBSCRIPTION_INVALIDUSERACCOUNT = @as(u32, 2150859068);
pub const ERROR_WSMAN_EVENTING_NONDOMAINJOINED_PUBLISHER = @as(u32, 2150859069);
pub const ERROR_WSMAN_EVENTING_NONDOMAINJOINED_COLLECTOR = @as(u32, 2150859070);
pub const ERROR_WSMAN_CONFIG_READONLY_PROPERTY = @as(u32, 2150859071);
pub const ERROR_WINRS_CODE_PAGE_NOT_SUPPORTED = @as(u32, 2150859072);
pub const ERROR_WSMAN_CLIENT_DISABLE_LOOPBACK_WITH_EXPLICIT_CREDENTIALS = @as(u32, 2150859073);
pub const ERROR_WSMAN_CLIENT_INVALID_DISABLE_LOOPBACK = @as(u32, 2150859074);
pub const ERROR_WSMAN_CLIENT_ENUM_RECEIVED_TOO_MANY_ITEMS = @as(u32, 2150859075);
pub const ERROR_WSMAN_MULTIPLE_CREDENTIALS = @as(u32, 2150859076);
pub const ERROR_WSMAN_AUTHENTICATION_INVALID_FLAG = @as(u32, 2150859077);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FOR_DEFAULT_AUTHENTICATION = @as(u32, 2150859078);
pub const ERROR_WSMAN_CLIENT_USERNAME_AND_PASSWORD_NEEDED = @as(u32, 2150859079);
pub const ERROR_WSMAN_CLIENT_INVALID_CERT_DNS_OR_UPN = @as(u32, 2150859080);
pub const ERROR_WSMAN_CREATESHELL_NULL_ENVIRONMENT_VARIABLE_NAME = @as(u32, 2150859081);
pub const ERROR_WSMAN_SHELL_ALREADY_CLOSED = @as(u32, 2150859082);
pub const ERROR_WSMAN_CREATESHELL_NULL_STREAMID = @as(u32, 2150859083);
pub const ERROR_WSMAN_SHELL_INVALID_SHELL_HANDLE = @as(u32, 2150859084);
pub const ERROR_WSMAN_SHELL_INVALID_COMMAND_HANDLE = @as(u32, 2150859085);
pub const ERROR_WSMAN_RUNSHELLCOMMAND_NULL_ARGUMENT = @as(u32, 2150859086);
pub const ERROR_WSMAN_COMMAND_ALREADY_CLOSED = @as(u32, 2150859087);
pub const ERROR_WSMAN_SENDSHELLINPUT_INVALID_STREAMID_INDEX = @as(u32, 2150859088);
pub const ERROR_WSMAN_SHELL_SYNCHRONOUS_NOT_SUPPORTED = @as(u32, 2150859089);
pub const ERROR_WSMAN_NO_CERTMAPPING_OPERATION_FOR_LOCAL_SESSION = @as(u32, 2150859090);
pub const ERROR_WSMAN_CERTMAPPING_CONFIGLIMIT_EXCEEDED = @as(u32, 2150859091);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDUSERCREDENTIALS = @as(u32, 2150859092);
pub const ERROR_WSMAN_CERT_INVALID_USAGE_CLIENT = @as(u32, 2150859093);
pub const ERROR_WSMAN_CERT_MISSING_AUTH_FLAG = @as(u32, 2150859094);
pub const ERROR_WSMAN_CERT_MULTIPLE_CREDENTIALS_FLAG = @as(u32, 2150859095);
pub const ERROR_WSMAN_CONFIG_SHELL_URI_INVALID = @as(u32, 2150859096);
pub const ERROR_WSMAN_CONFIG_SHELL_URI_CMDSHELLURI_NOTPERMITTED = @as(u32, 2150859097);
pub const ERROR_WSMAN_CONFIG_SHELLURI_INVALID_PROCESSPATH = @as(u32, 2150859098);
pub const ERROR_WINRS_SHELL_URI_INVALID = @as(u32, 2150859099);
pub const ERROR_WSMAN_INVALID_SECURITY_DESCRIPTOR = @as(u32, 2150859100);
pub const ERROR_WSMAN_POLICY_TOO_COMPLEX = @as(u32, 2150859101);
pub const ERROR_WSMAN_POLICY_CANNOT_COMPLY = @as(u32, 2150859102);
pub const ERROR_WSMAN_INVALID_CONNECTIONRETRY = @as(u32, 2150859103);
pub const ERROR_WSMAN_URISECURITY_INVALIDURIKEY = @as(u32, 2150859104);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDSUBJECTKEY = @as(u32, 2150859105);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDISSUERKEY = @as(u32, 2150859106);
pub const ERROR_WSMAN_INVALID_PUBLISHERS_TYPE = @as(u32, 2150859107);
pub const ERROR_WSMAN_CLIENT_INVALID_DELIVERY_RETRY = @as(u32, 2150859108);
pub const ERROR_WSMAN_CLIENT_NULL_PUBLISHERS = @as(u32, 2150859109);
pub const ERROR_WSMAN_CLIENT_NULL_ISSUERS = @as(u32, 2150859110);
pub const ERROR_WSMAN_CLIENT_NO_SOURCES = @as(u32, 2150859111);
pub const ERROR_WSMAN_INVALID_SUBSCRIBE_OBJECT = @as(u32, 2150859112);
pub const ERROR_WSMAN_PUBLIC_FIREWALL_PROFILE_ACTIVE = @as(u32, 2150859113);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDTOOLONG = @as(u32, 2150859114);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDBLANK = @as(u32, 2150859115);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDUSERTUPLE = @as(u32, 2150859116);
pub const ERROR_WSMAN_INVALID_PROVIDER_RESPONSE = @as(u32, 2150859117);
pub const ERROR_WSMAN_SHELL_NOT_INITIALIZED = @as(u32, 2150859118);
pub const ERROR_WSMAN_CONFIG_SHELLURI_INVALID_OPERATION_ON_KEY = @as(u32, 2150859119);
pub const ERROR_WSMAN_HTTP_STATUS_SERVER_ERROR = @as(u32, 2150859120);
pub const ERROR_WSMAN_HTTP_STATUS_BAD_REQUEST = @as(u32, 2150859121);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_CERTMAPPING_KEYS = @as(u32, 2150859122);
pub const ERROR_WSMAN_HTML_ERROR = @as(u32, 2150859123);
pub const ERROR_WSMAN_CLIENT_INITIALIZE_NULL_PARAM = @as(u32, 2150859124);
pub const ERROR_WSMAN_CLIENT_INVALID_INIT_APPLICATION_FLAG = @as(u32, 2150859125);
pub const ERROR_WSMAN_CLIENT_INVALID_DEINIT_APPLICATION_FLAG = @as(u32, 2150859126);
pub const ERROR_WSMAN_CLIENT_SETSESSIONOPTION_NULL_PARAM = @as(u32, 2150859127);
pub const ERROR_WSMAN_CLIENT_SETSESSIONOPTION_INVALID_PARAM = @as(u32, 2150859128);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_INVALID_PARAM = @as(u32, 2150859129);
pub const ERROR_WSMAN_CLIENT_CREATESHELL_NULL_PARAM = @as(u32, 2150859130);
pub const ERROR_WSMAN_CLIENT_INVALID_CREATE_SHELL_FLAG = @as(u32, 2150859131);
pub const ERROR_WSMAN_CLIENT_INVALID_CLOSE_SHELL_FLAG = @as(u32, 2150859132);
pub const ERROR_WSMAN_CLIENT_INVALID_CLOSE_COMMAND_FLAG = @as(u32, 2150859133);
pub const ERROR_WSMAN_CLIENT_CLOSESHELL_NULL_PARAM = @as(u32, 2150859134);
pub const ERROR_WSMAN_CLIENT_CLOSECOMMAND_NULL_PARAM = @as(u32, 2150859135);
pub const ERROR_WSMAN_CLIENT_RUNCOMMAND_NULL_PARAM = @as(u32, 2150859136);
pub const ERROR_WSMAN_CLIENT_INVALID_RUNCOMMAND_FLAG = @as(u32, 2150859137);
pub const ERROR_WSMAN_CLIENT_RUNCOMMAND_NOTCOMPLETED = @as(u32, 2150859138);
pub const ERROR_WSMAN_NO_COMMAND_RESPONSE = @as(u32, 2150859139);
pub const ERROR_WSMAN_INVALID_OPTIONSET = @as(u32, 2150859140);
pub const ERROR_WSMAN_NO_COMMANDID = @as(u32, 2150859141);
pub const ERROR_WSMAN_CLIENT_SIGNAL_NULL_PARAM = @as(u32, 2150859142);
pub const ERROR_WSMAN_CLIENT_INVALID_SIGNAL_SHELL_FLAG = @as(u32, 2150859143);
pub const ERROR_WSMAN_CLIENT_SEND_NULL_PARAM = @as(u32, 2150859144);
pub const ERROR_WSMAN_CLIENT_INVALID_SEND_SHELL_FLAG = @as(u32, 2150859145);
pub const ERROR_WSMAN_CLIENT_INVALID_SEND_SHELL_PARAMETER = @as(u32, 2150859146);
pub const ERROR_WSMAN_SHELL_INVALID_INPUT_STREAM = @as(u32, 2150859147);
pub const ERROR_WSMAN_CLIENT_RECEIVE_NULL_PARAM = @as(u32, 2150859148);
pub const ERROR_WSMAN_SHELL_INVALID_DESIRED_STREAMS = @as(u32, 2150859149);
pub const ERROR_WSMAN_CLIENT_INVALID_RECEIVE_SHELL_FLAG = @as(u32, 2150859150);
pub const ERROR_WSMAN_NO_RECEIVE_RESPONSE = @as(u32, 2150859151);
pub const ERROR_WSMAN_PLUGIN_CONFIGURATION_CORRUPTED = @as(u32, 2150859152);
pub const ERROR_WSMAN_INVALID_FILEPATH = @as(u32, 2150859153);
pub const ERROR_WSMAN_FILE_NOT_PRESENT = @as(u32, 2150859154);
pub const ERROR_WSMAN_IISCONFIGURATION_READ_FAILED = @as(u32, 2150859155);
pub const ERROR_WSMAN_CLIENT_INVALID_LOCALE = @as(u32, 2150859156);
pub const ERROR_WSMAN_CLIENT_INVALID_UI_LANGUAGE = @as(u32, 2150859157);
pub const ERROR_WSMAN_CLIENT_GETERRORMESSAGE_NULL_PARAM = @as(u32, 2150859158);
pub const ERROR_WSMAN_CLIENT_INVALID_LANGUAGE_CODE = @as(u32, 2150859159);
pub const ERROR_WSMAN_CLIENT_INVALID_GETERRORMESSAGE_FLAG = @as(u32, 2150859160);
pub const ERROR_WSMAN_REDIRECT_REQUESTED = @as(u32, 2150859161);
pub const ERROR_WSMAN_PROXY_AUTHENTICATION_INVALID_FLAG = @as(u32, 2150859162);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FOR_PROXY_AUTHENTICATION = @as(u32, 2150859163);
pub const ERROR_WSMAN_PROXY_ACCESS_TYPE = @as(u32, 2150859164);
pub const ERROR_WSMAN_INVALID_OPTION_NO_PROXY_SERVER = @as(u32, 2150859165);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_DWORD_NULL_PARAM = @as(u32, 2150859166);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_DWORD_INVALID_PARAM = @as(u32, 2150859167);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_STRING_INVALID_PARAM = @as(u32, 2150859168);
pub const ERROR_WSMAN_CREDSSP_USERNAME_PASSWORD_NEEDED = @as(u32, 2150859169);
pub const ERROR_WSMAN_CLIENT_CREDSSP_AUTHENTICATION_DISABLED = @as(u32, 2150859170);
pub const ERROR_WSMAN_CLIENT_ALLOWFRESHCREDENTIALS = @as(u32, 2150859171);
pub const ERROR_WSMAN_CLIENT_ALLOWFRESHCREDENTIALS_NTLMONLY = @as(u32, 2150859172);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLS = @as(u32, 2150859173);
pub const ERROR_WSMAN_QUOTA_MAX_OPERATIONS = @as(u32, 2150859174);
pub const ERROR_WSMAN_QUOTA_USER = @as(u32, 2150859175);
pub const ERROR_WSMAN_QUOTA_SYSTEM = @as(u32, 2150859176);
pub const ERROR_WSMAN_DIFFERENT_AUTHZ_TOKEN = @as(u32, 2150859177);
pub const ERROR_WSMAN_REDIRECT_LOCATION_NOT_AVAILABLE = @as(u32, 2150859178);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLUSERS = @as(u32, 2150859179);
pub const ERROR_WSMAN_REMOTESHELLS_NOT_ALLOWED = @as(u32, 2150859180);
pub const ERROR_WSMAN_PULL_PARAMS_NOT_SAME_AS_ENUM = @as(u32, 2150859181);
pub const ERROR_WSMAN_DEPRECATED_CONFIG_SETTING = @as(u32, 2150859182);
pub const ERROR_WSMAN_URI_SECURITY_URI = @as(u32, 2150859183);
pub const ERROR_WSMAN_CANNOT_USE_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS_FOR_HTTP = @as(u32, 2150859184);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_HTTP = @as(u32, 2150859185);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_KERBEROS = @as(u32, 2150859186);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_CREDSSP = @as(u32, 2150859187);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_PROXY_AUTH_FLAGS = @as(u32, 2150859188);
pub const ERROR_WSMAN_INVALID_REDIRECT_ERROR = @as(u32, 2150859189);
pub const ERROR_REDIRECT_LOCATION_TOO_LONG = @as(u32, 2150859190);
pub const ERROR_REDIRECT_LOCATION_INVALID = @as(u32, 2150859191);
pub const ERROR_SERVICE_CBT_HARDENING_INVALID = @as(u32, 2150859192);
pub const ERROR_WSMAN_NAME_NOT_RESOLVED = @as(u32, 2150859193);
pub const ERROR_WSMAN_SSL_CONNECTION_ABORTED = @as(u32, 2150859194);
pub const ERROR_WSMAN_DEFAULTAUTH_IPADDRESS = @as(u32, 2150859195);
pub const ERROR_WSMAN_CUSTOMREMOTESHELL_DEPRECATED = @as(u32, 2150859196);
pub const ERROR_WSMAN_FEATURE_DEPRECATED = @as(u32, 2150859197);
pub const ERROR_WSMAN_INVALID_USESSL_PARAM = @as(u32, 2150859198);
pub const ERROR_WSMAN_INVALID_CONFIGSDDL_URL = @as(u32, 2150859199);
pub const ERROR_WSMAN_ENUMERATE_SHELLCOMAMNDS_FILTER_EXPECTED = @as(u32, 2150859200);
pub const ERROR_WSMAN_ENUMERATE_SHELLCOMMANDS_EPRS_NOTSUPPORTED = @as(u32, 2150859201);
pub const ERROR_WSMAN_CLIENT_CREATESHELL_NAME_INVALID = @as(u32, 2150859202);
pub const ERROR_WSMAN_RUNAS_INVALIDUSERCREDENTIALS = @as(u32, 2150859203);
pub const ERROR_WINRS_SHELL_DISCONNECTED = @as(u32, 2150859204);
pub const ERROR_WINRS_SHELL_DISCONNECT_NOT_SUPPORTED = @as(u32, 2150859205);
pub const ERROR_WINRS_SHELL_CLIENTSESSIONID_MISMATCH = @as(u32, 2150859206);
pub const ERROR_WSMAN_CLIENT_DISCONNECTSHELL_NULL_PARAM = @as(u32, 2150859207);
pub const ERROR_WSMAN_CLIENT_RECONNECTSHELL_NULL_PARAM = @as(u32, 2150859208);
pub const ERROR_WSMAN_CLIENT_CONNECTSHELL_NULL_PARAM = @as(u32, 2150859209);
pub const ERROR_WSMAN_CLIENT_CONNECTCOMMAND_NULL_PARAM = @as(u32, 2150859210);
pub const ERROR_WINRS_CONNECT_RESPONSE_BAD_BODY = @as(u32, 2150859211);
pub const ERROR_WSMAN_COMMAND_TERMINATED = @as(u32, 2150859212);
pub const ERROR_WINRS_SHELL_CONNECTED_TO_DIFFERENT_CLIENT = @as(u32, 2150859213);
pub const ERROR_WINRS_SHELL_DISCONNECT_OPERATION_NOT_GRACEFUL = @as(u32, 2150859214);
pub const ERROR_WINRS_SHELL_DISCONNECT_OPERATION_NOT_VALID = @as(u32, 2150859215);
pub const ERROR_WINRS_SHELL_RECONNECT_OPERATION_NOT_VALID = @as(u32, 2150859216);
pub const ERROR_WSMAN_CONFIG_GROUP_POLICY_CHANGE_NOTIFICATION_SUBSCRIPTION_FAILED = @as(u32, 2150859217);
pub const ERROR_WSMAN_CLIENT_RECONNECTSHELLCOMMAND_NULL_PARAM = @as(u32, 2150859218);
pub const ERROR_WINRS_SHELLCOMMAND_RECONNECT_OPERATION_NOT_VALID = @as(u32, 2150859219);
pub const ERROR_WINRS_SHELLCOMMAND_CLIENTID_NOT_VALID = @as(u32, 2150859220);
pub const ERROR_WINRS_SHELL_CLIENTID_NOT_VALID = @as(u32, 2150859221);
pub const ERROR_WINRS_SHELLCOMMAND_CLIENTID_RESOURCE_CONFLICT = @as(u32, 2150859222);
pub const ERROR_WINRS_SHELL_CLIENTID_RESOURCE_CONFLICT = @as(u32, 2150859223);
pub const ERROR_WINRS_SHELLCOMMAND_DISCONNECT_OPERATION_NOT_VALID = @as(u32, 2150859224);
pub const ERROR_WSMAN_SUBSCRIBE_WMI_INVALID_KEY = @as(u32, 2150859225);
pub const ERROR_WSMAN_CLIENT_INVALID_DISCONNECT_SHELL_FLAG = @as(u32, 2150859226);
pub const ERROR_WSMAN_CLIENT_INVALID_SHELL_COMMAND_PAIR = @as(u32, 2150859227);
pub const ERROR_WSMAN_SEMANTICCALLBACK_TIMEDOUT = @as(u32, 2150859228);
pub const ERROR_WSMAN_SERVICE_REMOTE_ACCESS_DISABLED = @as(u32, 2150859229);
pub const ERROR_WSMAN_SERVICE_STREAM_DISCONNECTED = @as(u32, 2150859230);
pub const ERROR_WSMAN_CREATESHELL_RUNAS_FAILED = @as(u32, 2150859231);
pub const ERROR_WSMAN_INVALID_XML_RUNAS_DISABLED = @as(u32, 2150859232);
pub const ERROR_WSMAN_WRONG_METADATA = @as(u32, 2150859233);
pub const ERROR_WSMAN_UNSUPPORTED_TYPE = @as(u32, 2150859234);
pub const ERROR_WSMAN_REMOTE_CONNECTION_NOT_ALLOWED = @as(u32, 2150859235);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLS_PPQ = @as(u32, 2150859236);
pub const ERROR_WSMAN_QUOTA_MAX_USERS_PPQ = @as(u32, 2150859237);
pub const ERROR_WSMAN_QUOTA_MAX_PLUGINSHELLS_PPQ = @as(u32, 2150859238);
pub const ERROR_WSMAN_QUOTA_MAX_PLUGINOPERATIONS_PPQ = @as(u32, 2150859239);
pub const ERROR_WSMAN_QUOTA_MAX_OPERATIONS_USER_PPQ = @as(u32, 2150859240);
pub const ERROR_WSMAN_QUOTA_MAX_COMMANDS_PER_SHELL_PPQ = @as(u32, 2150859241);
pub const ERROR_WSMAN_QUOTA_MIN_REQUIREMENT_NOT_AVAILABLE_PPQ = @as(u32, 2150859242);
pub const ERROR_WSMAN_NEW_DESERIALIZER = @as(u32, 2150859243);
pub const ERROR_WSMAN_DESERIALIZE_CLASS = @as(u32, 2150859244);
pub const ERROR_WSMAN_GETCLASS = @as(u32, 2150859245);
pub const ERROR_WSMAN_NEW_SESSION = @as(u32, 2150859246);
pub const ERROR_WSMAN_NULL_KEY = @as(u32, 2150859247);
pub const ERROR_WSMAN_MUTUAL_AUTH_FAILED = @as(u32, 2150859248);
pub const ERROR_WSMAN_UNSUPPORTED_OCTETTYPE = @as(u32, 2150859249);
pub const ERROR_WINRS_IDLETIMEOUT_OUTOFBOUNDS = @as(u32, 2150859250);
pub const ERROR_WSMAN_INSUFFICIENT_METADATA_FOR_BASIC = @as(u32, 2150859251);
pub const ERROR_WSMAN_INVALID_LITERAL_URI = @as(u32, 2150859252);
pub const ERROR_WSMAN_OBJECTONLY_INVALID = @as(u32, 2150859253);
pub const ERROR_WSMAN_MISSING_CLASSNAME = @as(u32, 2150859254);
pub const ERROR_WSMAN_EVENTING_INVALID_ENCODING_IN_DELIVERY = @as(u32, 2150859255);
pub const ERROR_WSMAN_DESTINATION_INVALID = @as(u32, 2150859256);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE_IDENTIFY = @as(u32, 2150859257);
pub const ERROR_WSMAN_CLIENT_SESSION_UNUSABLE = @as(u32, 2150859258);
pub const ERROR_WSMAN_VIRTUALACCOUNT_NOTSUPPORTED = @as(u32, 2150859259);
pub const ERROR_WSMAN_VIRTUALACCOUNT_NOTSUPPORTED_DOWNLEVEL = @as(u32, 2150859260);
pub const ERROR_WSMAN_RUNASUSER_MANAGEDACCOUNT_LOGON_FAILED = @as(u32, 2150859261);
pub const ERROR_WSMAN_CERTMAPPING_CREDENTIAL_MANAGEMENT_FAILIED = @as(u32, 2150859262);

//--------------------------------------------------------------------------------
// Section: Types (76)
//--------------------------------------------------------------------------------
pub const WSMAN_DATA_TEXT = extern struct {
    bufferLength: u32,
    buffer: ?[*:0]const u16,
};

pub const WSMAN_DATA_BINARY = extern struct {
    dataLength: u32,
    data: ?*u8,
};

pub const WSManDataType = enum(i32) {
    NONE = 0,
    TYPE_TEXT = 1,
    TYPE_BINARY = 2,
    TYPE_DWORD = 4,
};
pub const WSMAN_DATA_NONE = WSManDataType.NONE;
pub const WSMAN_DATA_TYPE_TEXT = WSManDataType.TYPE_TEXT;
pub const WSMAN_DATA_TYPE_BINARY = WSManDataType.TYPE_BINARY;
pub const WSMAN_DATA_TYPE_DWORD = WSManDataType.TYPE_DWORD;

pub const WSMAN_DATA = extern struct {
    type: WSManDataType,
    Anonymous: extern union {
        text: WSMAN_DATA_TEXT,
        binaryData: WSMAN_DATA_BINARY,
        number: u32,
    },
};

pub const WSMAN_ERROR = extern struct {
    code: u32,
    errorDetail: ?[*:0]const u16,
    language: ?[*:0]const u16,
    machineName: ?[*:0]const u16,
    pluginName: ?[*:0]const u16,
};

pub const WSMAN_USERNAME_PASSWORD_CREDS = extern struct {
    username: ?[*:0]const u16,
    password: ?[*:0]const u16,
};

pub const WSManAuthenticationFlags = enum(i32) {
    DEFAULT_AUTHENTICATION = 0,
    NO_AUTHENTICATION = 1,
    AUTH_DIGEST = 2,
    AUTH_NEGOTIATE = 4,
    AUTH_BASIC = 8,
    AUTH_KERBEROS = 16,
    AUTH_CREDSSP = 128,
    AUTH_CLIENT_CERTIFICATE = 32,
};
pub const WSMAN_FLAG_DEFAULT_AUTHENTICATION = WSManAuthenticationFlags.DEFAULT_AUTHENTICATION;
pub const WSMAN_FLAG_NO_AUTHENTICATION = WSManAuthenticationFlags.NO_AUTHENTICATION;
pub const WSMAN_FLAG_AUTH_DIGEST = WSManAuthenticationFlags.AUTH_DIGEST;
pub const WSMAN_FLAG_AUTH_NEGOTIATE = WSManAuthenticationFlags.AUTH_NEGOTIATE;
pub const WSMAN_FLAG_AUTH_BASIC = WSManAuthenticationFlags.AUTH_BASIC;
pub const WSMAN_FLAG_AUTH_KERBEROS = WSManAuthenticationFlags.AUTH_KERBEROS;
pub const WSMAN_FLAG_AUTH_CREDSSP = WSManAuthenticationFlags.AUTH_CREDSSP;
pub const WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE = WSManAuthenticationFlags.AUTH_CLIENT_CERTIFICATE;

pub const WSMAN_AUTHENTICATION_CREDENTIALS = extern struct {
    authenticationMechanism: u32,
    Anonymous: extern union {
        userAccount: WSMAN_USERNAME_PASSWORD_CREDS,
        certificateThumbprint: ?[*:0]const u16,
    },
};

pub const WSMAN_OPTION = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
    mustComply: BOOL,
};

pub const WSMAN_OPTION_SET = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
};

pub const WSMAN_OPTION_SETEX = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
    optionTypes: ?*?PWSTR,
};

pub const WSMAN_KEY = extern struct {
    key: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_SELECTOR_SET = extern struct {
    numberKeys: u32,
    keys: ?*WSMAN_KEY,
};

pub const WSMAN_FRAGMENT = extern struct {
    path: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_FILTER = extern struct {
    filter: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_OPERATION_INFO = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SET,
    reserved: ?*anyopaque,
    version: u32,
};

pub const WSMAN_OPERATION_INFOEX = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SETEX,
    version: u32,
    uiLocale: ?[*:0]const u16,
    dataLocale: ?[*:0]const u16,
};

pub const WSMAN_API = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManProxyAccessType = enum(i32) {
    IE_PROXY_CONFIG = 1,
    WINHTTP_PROXY_CONFIG = 2,
    AUTO_DETECT = 4,
    NO_PROXY_SERVER = 8,
};
pub const WSMAN_OPTION_PROXY_IE_PROXY_CONFIG = WSManProxyAccessType.IE_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG = WSManProxyAccessType.WINHTTP_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_AUTO_DETECT = WSManProxyAccessType.AUTO_DETECT;
pub const WSMAN_OPTION_PROXY_NO_PROXY_SERVER = WSManProxyAccessType.NO_PROXY_SERVER;

pub const WSMAN_PROXY_INFO = extern struct {
    accessType: u32,
    authenticationCredentials: WSMAN_AUTHENTICATION_CREDENTIALS,
};

pub const WSMAN_SESSION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManSessionOption = enum(i32) {
    DEFAULT_OPERATION_TIMEOUTMS = 1,
    MAX_RETRY_TIME = 11,
    TIMEOUTMS_CREATE_SHELL = 12,
    TIMEOUTMS_RUN_SHELL_COMMAND = 13,
    TIMEOUTMS_RECEIVE_SHELL_OUTPUT = 14,
    TIMEOUTMS_SEND_SHELL_INPUT = 15,
    TIMEOUTMS_SIGNAL_SHELL = 16,
    TIMEOUTMS_CLOSE_SHELL = 17,
    SKIP_CA_CHECK = 18,
    SKIP_CN_CHECK = 19,
    UNENCRYPTED_MESSAGES = 20,
    UTF16 = 21,
    ENABLE_SPN_SERVER_PORT = 22,
    MACHINE_ID = 23,
    LOCALE = 25,
    UI_LANGUAGE = 26,
    MAX_ENVELOPE_SIZE_KB = 28,
    SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = 29,
    REDIRECT_LOCATION = 30,
    SKIP_REVOCATION_CHECK = 31,
    ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = 32,
    USE_SSL = 33,
    USE_INTEARACTIVE_TOKEN = 34,
};
pub const WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = WSManSessionOption.DEFAULT_OPERATION_TIMEOUTMS;
pub const WSMAN_OPTION_MAX_RETRY_TIME = WSManSessionOption.MAX_RETRY_TIME;
pub const WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL = WSManSessionOption.TIMEOUTMS_CREATE_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND = WSManSessionOption.TIMEOUTMS_RUN_SHELL_COMMAND;
pub const WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT = WSManSessionOption.TIMEOUTMS_RECEIVE_SHELL_OUTPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT = WSManSessionOption.TIMEOUTMS_SEND_SHELL_INPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL = WSManSessionOption.TIMEOUTMS_SIGNAL_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL = WSManSessionOption.TIMEOUTMS_CLOSE_SHELL;
pub const WSMAN_OPTION_SKIP_CA_CHECK = WSManSessionOption.SKIP_CA_CHECK;
pub const WSMAN_OPTION_SKIP_CN_CHECK = WSManSessionOption.SKIP_CN_CHECK;
pub const WSMAN_OPTION_UNENCRYPTED_MESSAGES = WSManSessionOption.UNENCRYPTED_MESSAGES;
pub const WSMAN_OPTION_UTF16 = WSManSessionOption.UTF16;
pub const WSMAN_OPTION_ENABLE_SPN_SERVER_PORT = WSManSessionOption.ENABLE_SPN_SERVER_PORT;
pub const WSMAN_OPTION_MACHINE_ID = WSManSessionOption.MACHINE_ID;
pub const WSMAN_OPTION_LOCALE = WSManSessionOption.LOCALE;
pub const WSMAN_OPTION_UI_LANGUAGE = WSManSessionOption.UI_LANGUAGE;
pub const WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB = WSManSessionOption.MAX_ENVELOPE_SIZE_KB;
pub const WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = WSManSessionOption.SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB;
pub const WSMAN_OPTION_REDIRECT_LOCATION = WSManSessionOption.REDIRECT_LOCATION;
pub const WSMAN_OPTION_SKIP_REVOCATION_CHECK = WSManSessionOption.SKIP_REVOCATION_CHECK;
pub const WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = WSManSessionOption.ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS;
pub const WSMAN_OPTION_USE_SSL = WSManSessionOption.USE_SSL;
pub const WSMAN_OPTION_USE_INTEARACTIVE_TOKEN = WSManSessionOption.USE_INTEARACTIVE_TOKEN;

pub const WSMAN_OPERATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManCallbackFlags = enum(i32) {
    END_OF_OPERATION = 1,
    END_OF_STREAM = 8,
    SHELL_SUPPORTS_DISCONNECT = 32,
    SHELL_AUTODISCONNECTED = 64,
    NETWORK_FAILURE_DETECTED = 256,
    RETRYING_AFTER_NETWORK_FAILURE = 512,
    RECONNECTED_AFTER_NETWORK_FAILURE = 1024,
    SHELL_AUTODISCONNECTING = 2048,
    RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = 4096,
    RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = 8192,
};
pub const WSMAN_FLAG_CALLBACK_END_OF_OPERATION = WSManCallbackFlags.END_OF_OPERATION;
pub const WSMAN_FLAG_CALLBACK_END_OF_STREAM = WSManCallbackFlags.END_OF_STREAM;
pub const WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = WSManCallbackFlags.SHELL_SUPPORTS_DISCONNECT;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED = WSManCallbackFlags.SHELL_AUTODISCONNECTED;
pub const WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = WSManCallbackFlags.NETWORK_FAILURE_DETECTED;
pub const WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RETRYING_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RECONNECTED_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING = WSManCallbackFlags.SHELL_AUTODISCONNECTING;
pub const WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = WSManCallbackFlags.RETRY_ABORTED_DUE_TO_INTERNAL_ERROR;
pub const WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = WSManCallbackFlags.RECEIVE_DELAY_STREAM_REQUEST_PROCESSED;

pub const WSMAN_SHELL = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_COMMAND = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_STREAM_ID_SET = extern struct {
    streamIDsCount: u32,
    streamIDs: ?*?PWSTR,
};

pub const WSMAN_ENVIRONMENT_VARIABLE = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_ENVIRONMENT_VARIABLE_SET = extern struct {
    varsCount: u32,
    vars: ?*WSMAN_ENVIRONMENT_VARIABLE,
};

pub const WSMAN_SHELL_STARTUP_INFO_V10 = extern struct {
    inputStreamSet: ?*WSMAN_STREAM_ID_SET,
    outputStreamSet: ?*WSMAN_STREAM_ID_SET,
    idleTimeoutMs: u32,
    workingDirectory: ?[*:0]const u16,
    variableSet: ?*WSMAN_ENVIRONMENT_VARIABLE_SET,
};

pub const WSMAN_SHELL_STARTUP_INFO_V11 = extern struct {
    __AnonymousBase_wsman_L665_C48: WSMAN_SHELL_STARTUP_INFO_V10,
    name: ?[*:0]const u16,
};

pub const WSMAN_SHELL_DISCONNECT_INFO = extern struct {
    idleTimeoutMs: u32,
};

pub const WSManShellFlag = enum(i32) {
    NO_COMPRESSION = 1,
    DELETE_SERVER_SESSION = 2,
    SERVER_BUFFERING_MODE_DROP = 4,
    SERVER_BUFFERING_MODE_BLOCK = 8,
    RECEIVE_DELAY_OUTPUT_STREAM = 16,
};
pub const WSMAN_FLAG_NO_COMPRESSION = WSManShellFlag.NO_COMPRESSION;
pub const WSMAN_FLAG_DELETE_SERVER_SESSION = WSManShellFlag.DELETE_SERVER_SESSION;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = WSManShellFlag.SERVER_BUFFERING_MODE_DROP;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = WSManShellFlag.SERVER_BUFFERING_MODE_BLOCK;
pub const WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = WSManShellFlag.RECEIVE_DELAY_OUTPUT_STREAM;

pub const WSMAN_RECEIVE_DATA_RESULT = extern struct {
    streamId: ?[*:0]const u16,
    streamData: WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
};

pub const WSMAN_CONNECT_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_CREATE_SHELL_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_RESPONSE_DATA = extern union {
    receiveData: WSMAN_RECEIVE_DATA_RESULT,
    connectData: WSMAN_CONNECT_DATA,
    createData: WSMAN_CREATE_SHELL_DATA,
};

pub const WSMAN_SHELL_COMPLETION_FUNCTION = *const fn (
    operation_context: ?*anyopaque,
    flags: u32,
    @"error": ?*WSMAN_ERROR,
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    operation_handle: ?*WSMAN_OPERATION,
    data: ?*WSMAN_RESPONSE_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_SHELL_ASYNC = extern struct {
    operationContext: ?*anyopaque,
    completionFunction: ?WSMAN_SHELL_COMPLETION_FUNCTION,
};

pub const WSMAN_COMMAND_ARG_SET = extern struct {
    argsCount: u32,
    args: ?*?PWSTR,
};

pub const WSMAN_CERTIFICATE_DETAILS = extern struct {
    subject: ?[*:0]const u16,
    issuerName: ?[*:0]const u16,
    issuerThumbprint: ?[*:0]const u16,
    subjectName: ?[*:0]const u16,
};

pub const WSMAN_SENDER_DETAILS = extern struct {
    senderName: ?[*:0]const u16,
    authenticationMechanism: ?[*:0]const u16,
    certificateDetails: ?*WSMAN_CERTIFICATE_DETAILS,
    clientToken: ?HANDLE,
    httpURL: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_REQUEST = extern struct {
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    locale: ?[*:0]const u16,
    resourceUri: ?[*:0]const u16,
    operationInfo: ?*WSMAN_OPERATION_INFO,
    shutdownNotification: i32,
    shutdownNotificationHandle: ?HANDLE,
    dataLocale: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT = *const fn (
    shell_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT = *const fn (
    shell_context: ?*anyopaque,
    command_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_STARTUP = *const fn (
    flags: u32,
    application_identification: ?[*:0]const u16,
    extra_info: ?[*:0]const u16,
    plugin_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHUTDOWN = *const fn (
    plugin_context: ?*anyopaque,
    flags: u32,
    reason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHELL = *const fn (
    plugin_context: ?*anyopaque,
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    startup_info: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    inbound_shell_information: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_COMMAND = *const fn (
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shell_context: ?*anyopaque,
    command_line: ?[*:0]const u16,
    arguments: ?*WSMAN_COMMAND_ARG_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SEND = *const fn (
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shell_context: ?*anyopaque,
    command_context: ?*anyopaque,
    stream: ?[*:0]const u16,
    inbound_data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RECEIVE = *const fn (
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shell_context: ?*anyopaque,
    command_context: ?*anyopaque,
    stream_set: ?*WSMAN_STREAM_ID_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SIGNAL = *const fn (
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shell_context: ?*anyopaque,
    command_context: ?*anyopaque,
    code: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_CONNECT = *const fn (
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shell_context: ?*anyopaque,
    command_context: ?*anyopaque,
    inbound_connect_information: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_AUTHZ_QUOTA = extern struct {
    maxAllowedConcurrentShells: u32,
    maxAllowedConcurrentOperations: u32,
    timeslotSize: u32,
    maxAllowedOperationsPerTimeslot: u32,
};

pub const WSMAN_PLUGIN_AUTHORIZE_USER = *const fn (
    plugin_context: ?*anyopaque,
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_OPERATION = *const fn (
    plugin_context: ?*anyopaque,
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    operation: u32,
    action: ?[*:0]const u16,
    resource_uri: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA = *const fn (
    plugin_context: ?*anyopaque,
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT = *const fn (
    user_authorization_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WSMan_Value = Guid.initString("bced617b-ec03-420b-8508-977dc7a686bd");
pub const CLSID_WSMan = &CLSID_WSMan_Value;

const CLSID_WSManInternal_Value = Guid.initString("7de087a5-5dcb-4df7-bb12-0924ad8fbd9a");
pub const CLSID_WSManInternal = &CLSID_WSManInternal_Value;

pub const WSManSessionFlags = enum(i32) {
    UTF8 = 1,
    CredUsernamePassword = 4096,
    SkipCACheck = 8192,
    SkipCNCheck = 16384,
    UseNoAuthentication = 32768,
    UseDigest = 65536,
    UseNegotiate = 131072,
    UseBasic = 262144,
    UseKerberos = 524288,
    NoEncryption = 1048576,
    UseClientCertificate = 2097152,
    EnableSPNServerPort = 4194304,
    UTF16 = 8388608,
    UseCredSsp = 16777216,
    SkipRevocationCheck = 33554432,
    AllowNegotiateImplicitCredentials = 67108864,
    UseSsl = 134217728,
};
pub const WSManFlagUTF8 = WSManSessionFlags.UTF8;
pub const WSManFlagCredUsernamePassword = WSManSessionFlags.CredUsernamePassword;
pub const WSManFlagSkipCACheck = WSManSessionFlags.SkipCACheck;
pub const WSManFlagSkipCNCheck = WSManSessionFlags.SkipCNCheck;
pub const WSManFlagUseNoAuthentication = WSManSessionFlags.UseNoAuthentication;
pub const WSManFlagUseDigest = WSManSessionFlags.UseDigest;
pub const WSManFlagUseNegotiate = WSManSessionFlags.UseNegotiate;
pub const WSManFlagUseBasic = WSManSessionFlags.UseBasic;
pub const WSManFlagUseKerberos = WSManSessionFlags.UseKerberos;
pub const WSManFlagNoEncryption = WSManSessionFlags.NoEncryption;
pub const WSManFlagUseClientCertificate = WSManSessionFlags.UseClientCertificate;
pub const WSManFlagEnableSPNServerPort = WSManSessionFlags.EnableSPNServerPort;
pub const WSManFlagUTF16 = WSManSessionFlags.UTF16;
pub const WSManFlagUseCredSsp = WSManSessionFlags.UseCredSsp;
pub const WSManFlagSkipRevocationCheck = WSManSessionFlags.SkipRevocationCheck;
pub const WSManFlagAllowNegotiateImplicitCredentials = WSManSessionFlags.AllowNegotiateImplicitCredentials;
pub const WSManFlagUseSsl = WSManSessionFlags.UseSsl;

pub const WSManEnumFlags = enum(i32) {
    NonXmlText = 1,
    ReturnObject = 0,
    ReturnEPR = 2,
    ReturnObjectAndEPR = 4,
    // HierarchyDeep = 0, this enum value conflicts with ReturnObject
    HierarchyShallow = 32,
    HierarchyDeepBasePropsOnly = 64,
    // AssociatedInstance = 0, this enum value conflicts with ReturnObject
    AssociationInstance = 128,
};
pub const WSManFlagNonXmlText = WSManEnumFlags.NonXmlText;
pub const WSManFlagReturnObject = WSManEnumFlags.ReturnObject;
pub const WSManFlagReturnEPR = WSManEnumFlags.ReturnEPR;
pub const WSManFlagReturnObjectAndEPR = WSManEnumFlags.ReturnObjectAndEPR;
pub const WSManFlagHierarchyDeep = WSManEnumFlags.ReturnObject;
pub const WSManFlagHierarchyShallow = WSManEnumFlags.HierarchyShallow;
pub const WSManFlagHierarchyDeepBasePropsOnly = WSManEnumFlags.HierarchyDeepBasePropsOnly;
pub const WSManFlagAssociatedInstance = WSManEnumFlags.ReturnObject;
pub const WSManFlagAssociationInstance = WSManEnumFlags.AssociationInstance;

pub const WSManProxyAccessTypeFlags = enum(i32) {
    IEConfig = 1,
    WinHttpConfig = 2,
    AutoDetect = 4,
    NoProxyServer = 8,
};
pub const WSManProxyIEConfig = WSManProxyAccessTypeFlags.IEConfig;
pub const WSManProxyWinHttpConfig = WSManProxyAccessTypeFlags.WinHttpConfig;
pub const WSManProxyAutoDetect = WSManProxyAccessTypeFlags.AutoDetect;
pub const WSManProxyNoProxyServer = WSManProxyAccessTypeFlags.NoProxyServer;

pub const WSManProxyAuthenticationFlags = enum(i32) {
    Negotiate = 1,
    Basic = 2,
    Digest = 4,
};
pub const WSManFlagProxyAuthenticationUseNegotiate = WSManProxyAuthenticationFlags.Negotiate;
pub const WSManFlagProxyAuthenticationUseBasic = WSManProxyAuthenticationFlags.Basic;
pub const WSManFlagProxyAuthenticationUseDigest = WSManProxyAuthenticationFlags.Digest;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSMan_Value = Guid.initString("190d8637-5cd3-496d-ad24-69636bb5a3b5");
pub const IID_IWSMan = &IID_IWSMan_Value;
pub const IWSMan = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateSession: *const fn (
            self: *const IWSMan,
            connection: ?BSTR,
            flags: i32,
            connection_options: ?*IDispatch,
            session: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConnectionOptions: *const fn (
            self: *const IWSMan,
            connection_options: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CommandLine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn createSession(self: *const T, connection_: ?BSTR, flags_: i32, connection_options_: ?*IDispatch, session_: ?*?*IDispatch) HRESULT {
                return @as(*const IWSMan.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IWSMan, @ptrCast(self)), connection_, flags_, connection_options_, session_);
            }
            pub inline fn createConnectionOptions(self: *const T, connection_options_: ?*?*IDispatch) HRESULT {
                return @as(*const IWSMan.VTable, @ptrCast(self.vtable)).CreateConnectionOptions(@as(*const IWSMan, @ptrCast(self)), connection_options_);
            }
            pub inline fn getCommandLine(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IWSMan.VTable, @ptrCast(self.vtable)).get_CommandLine(@as(*const IWSMan, @ptrCast(self)), value_);
            }
            pub inline fn getError(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IWSMan.VTable, @ptrCast(self.vtable)).get_Error(@as(*const IWSMan, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx_Value = Guid.initString("2d53bdaa-798e-49e6-a1aa-74d01256f411");
pub const IID_IWSManEx = &IID_IWSManEx_Value;
pub const IWSManEx = extern struct {
    pub const VTable = extern struct {
        base: IWSMan.VTable,
        CreateResourceLocator: *const fn (
            self: *const IWSManEx,
            str_resource_locator: ?BSTR,
            new_resource_locator: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUTF8: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagCredUsernamePassword: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCACheck: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCNCheck: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseDigest: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNegotiate: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseBasic: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseKerberos: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagNoEncryption: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagEnableSPNServerPort: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNoAuthentication: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagNonXmlText: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnEPR: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObjectAndEPR: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorMessage: *const fn (
            self: *const IWSManEx,
            error_number: u32,
            error_message: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeep: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyShallow: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeepBasePropsOnly: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObject: *const fn (
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWSMan.MethodMixin(T);
            pub inline fn createResourceLocator(self: *const T, str_resource_locator_: ?BSTR, new_resource_locator_: ?*?*IDispatch) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).CreateResourceLocator(@as(*const IWSManEx, @ptrCast(self)), str_resource_locator_, new_resource_locator_);
            }
            pub inline fn sessionFlagUTF8(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUTF8(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagCredUsernamePassword(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagCredUsernamePassword(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagSkipCACheck(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagSkipCACheck(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagSkipCNCheck(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagSkipCNCheck(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseDigest(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUseDigest(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseNegotiate(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUseNegotiate(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseBasic(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUseBasic(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseKerberos(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUseKerberos(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagNoEncryption(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagNoEncryption(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagEnableSPNServerPort(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagEnableSPNServerPort(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseNoAuthentication(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).SessionFlagUseNoAuthentication(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagNonXmlText(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagNonXmlText(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagReturnEPR(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagReturnEPR(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagReturnObjectAndEPR(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagReturnObjectAndEPR(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn getErrorMessage(self: *const T, error_number_: u32, error_message_: ?*?BSTR) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).GetErrorMessage(@as(*const IWSManEx, @ptrCast(self)), error_number_, error_message_);
            }
            pub inline fn enumerationFlagHierarchyDeep(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagHierarchyDeep(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagHierarchyShallow(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagHierarchyShallow(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagHierarchyDeepBasePropsOnly(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagHierarchyDeepBasePropsOnly(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagReturnObject(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx.VTable, @ptrCast(self.vtable)).EnumerationFlagReturnObject(@as(*const IWSManEx, @ptrCast(self)), flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx2_Value = Guid.initString("1d1b5ae0-42d9-4021-8261-3987619512e9");
pub const IID_IWSManEx2 = &IID_IWSManEx2_Value;
pub const IWSManEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx.VTable,
        SessionFlagUseClientCertificate: *const fn (
            self: *const IWSManEx2,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWSManEx.MethodMixin(T);
            pub inline fn sessionFlagUseClientCertificate(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx2.VTable, @ptrCast(self.vtable)).SessionFlagUseClientCertificate(@as(*const IWSManEx2, @ptrCast(self)), flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManEx3_Value = Guid.initString("6400e966-011d-4eac-8474-049e0848afad");
pub const IID_IWSManEx3 = &IID_IWSManEx3_Value;
pub const IWSManEx3 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx2.VTable,
        SessionFlagUTF16: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseCredSsp: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociationInstance: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociatedInstance: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipRevocationCheck: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagAllowNegotiateImplicitCredentials: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseSsl: *const fn (
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWSManEx2.MethodMixin(T);
            pub inline fn sessionFlagUTF16(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).SessionFlagUTF16(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseCredSsp(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).SessionFlagUseCredSsp(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagAssociationInstance(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).EnumerationFlagAssociationInstance(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn enumerationFlagAssociatedInstance(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).EnumerationFlagAssociatedInstance(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagSkipRevocationCheck(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).SessionFlagSkipRevocationCheck(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagAllowNegotiateImplicitCredentials(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).SessionFlagAllowNegotiateImplicitCredentials(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
            pub inline fn sessionFlagUseSsl(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IWSManEx3.VTable, @ptrCast(self.vtable)).SessionFlagUseSsl(@as(*const IWSManEx3, @ptrCast(self)), flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptions_Value = Guid.initString("f704e861-9e52-464f-b786-da5eb2320fdd");
pub const IID_IWSManConnectionOptions = &IID_IWSManConnectionOptions_Value;
pub const IWSManConnectionOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManConnectionOptions,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManConnectionOptions,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManConnectionOptions,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getUserName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptions.VTable, @ptrCast(self.vtable)).get_UserName(@as(*const IWSManConnectionOptions, @ptrCast(self)), name_);
            }
            pub inline fn putUserName(self: *const T, name_: ?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptions.VTable, @ptrCast(self.vtable)).put_UserName(@as(*const IWSManConnectionOptions, @ptrCast(self)), name_);
            }
            pub inline fn putPassword(self: *const T, password_: ?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptions.VTable, @ptrCast(self.vtable)).put_Password(@as(*const IWSManConnectionOptions, @ptrCast(self)), password_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptionsEx_Value = Guid.initString("ef43edf7-2a48-4d93-9526-8bd6ab6d4a6b");
pub const IID_IWSManConnectionOptionsEx = &IID_IWSManConnectionOptionsEx_Value;
pub const IWSManConnectionOptionsEx = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptions.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateThumbprint: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateThumbprint: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWSManConnectionOptions.MethodMixin(T);
            pub inline fn getCertificateThumbprint(self: *const T, thumbprint_: ?*?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptionsEx.VTable, @ptrCast(self.vtable)).get_CertificateThumbprint(@as(*const IWSManConnectionOptionsEx, @ptrCast(self)), thumbprint_);
            }
            pub inline fn putCertificateThumbprint(self: *const T, thumbprint_: ?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptionsEx.VTable, @ptrCast(self.vtable)).put_CertificateThumbprint(@as(*const IWSManConnectionOptionsEx, @ptrCast(self)), thumbprint_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManConnectionOptionsEx2_Value = Guid.initString("f500c9ec-24ee-48ab-b38d-fc9a164c658e");
pub const IID_IWSManConnectionOptionsEx2 = &IID_IWSManConnectionOptionsEx2_Value;
pub const IWSManConnectionOptionsEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptionsEx.VTable,
        SetProxy: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            access_type: i32,
            authentication_mechanism: i32,
            user_name: ?BSTR,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyIEConfig: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyWinHttpConfig: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAutoDetect: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyNoProxyServer: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseNegotiate: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseBasic: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseDigest: *const fn (
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWSManConnectionOptionsEx.MethodMixin(T);
            pub inline fn setProxy(self: *const T, access_type_: i32, authentication_mechanism_: i32, user_name_: ?BSTR, password_: ?BSTR) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).SetProxy(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), access_type_, authentication_mechanism_, user_name_, password_);
            }
            pub inline fn proxyIEConfig(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyIEConfig(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyWinHttpConfig(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyWinHttpConfig(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyAutoDetect(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyAutoDetect(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyNoProxyServer(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyNoProxyServer(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyAuthenticationUseNegotiate(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyAuthenticationUseNegotiate(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyAuthenticationUseBasic(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyAuthenticationUseBasic(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
            pub inline fn proxyAuthenticationUseDigest(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManConnectionOptionsEx2.VTable, @ptrCast(self.vtable)).ProxyAuthenticationUseDigest(@as(*const IWSManConnectionOptionsEx2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManSession_Value = Guid.initString("fc84fc58-1286-40c4-9da0-c8ef6ec241e0");
pub const IID_IWSManSession = &IID_IWSManSession_Value;
pub const IWSManSession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Get: *const fn (
            self: *const IWSManSession,
            resource_uri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Put: *const fn (
            self: *const IWSManSession,
            resource_uri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            result_resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: *const fn (
            self: *const IWSManSession,
            resource_uri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            new_uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const IWSManSession,
            resource_uri: VARIANT,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: *const fn (
            self: *const IWSManSession,
            action_uri: ?BSTR,
            resource_uri: VARIANT,
            parameters: ?BSTR,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enumerate: *const fn (
            self: *const IWSManSession,
            resource_uri: VARIANT,
            filter: ?BSTR,
            dialect: ?BSTR,
            flags: i32,
            result_set: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Identify: *const fn (
            self: *const IWSManSession,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManSession,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BatchItems: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BatchItems: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Timeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Timeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn get(self: *const T, resource_uri_: VARIANT, flags_: i32, resource_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Get(@as(*const IWSManSession, @ptrCast(self)), resource_uri_, flags_, resource_);
            }
            pub inline fn put(self: *const T, resource_uri_: VARIANT, resource_: ?BSTR, flags_: i32, result_resource_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Put(@as(*const IWSManSession, @ptrCast(self)), resource_uri_, resource_, flags_, result_resource_);
            }
            pub inline fn create(self: *const T, resource_uri_: VARIANT, resource_: ?BSTR, flags_: i32, new_uri_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Create(@as(*const IWSManSession, @ptrCast(self)), resource_uri_, resource_, flags_, new_uri_);
            }
            pub inline fn delete(self: *const T, resource_uri_: VARIANT, flags_: i32) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Delete(@as(*const IWSManSession, @ptrCast(self)), resource_uri_, flags_);
            }
            pub inline fn invoke(self: *const T, action_uri_: ?BSTR, resource_uri_: VARIANT, parameters_: ?BSTR, flags_: i32, result_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IWSManSession, @ptrCast(self)), action_uri_, resource_uri_, parameters_, flags_, result_);
            }
            pub inline fn enumerate(self: *const T, resource_uri_: VARIANT, filter_: ?BSTR, dialect_: ?BSTR, flags_: i32, result_set_: ?*?*IDispatch) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Enumerate(@as(*const IWSManSession, @ptrCast(self)), resource_uri_, filter_, dialect_, flags_, result_set_);
            }
            pub inline fn identify(self: *const T, flags_: i32, result_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).Identify(@as(*const IWSManSession, @ptrCast(self)), flags_, result_);
            }
            pub inline fn getError(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).get_Error(@as(*const IWSManSession, @ptrCast(self)), value_);
            }
            pub inline fn getBatchItems(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).get_BatchItems(@as(*const IWSManSession, @ptrCast(self)), value_);
            }
            pub inline fn putBatchItems(self: *const T, value_: i32) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).put_BatchItems(@as(*const IWSManSession, @ptrCast(self)), value_);
            }
            pub inline fn getTimeout(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).get_Timeout(@as(*const IWSManSession, @ptrCast(self)), value_);
            }
            pub inline fn putTimeout(self: *const T, value_: i32) HRESULT {
                return @as(*const IWSManSession.VTable, @ptrCast(self.vtable)).put_Timeout(@as(*const IWSManSession, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEnumerator_Value = Guid.initString("f3457ca9-abb9-4fa5-b850-90e8ca300e7f");
pub const IID_IWSManEnumerator = &IID_IWSManEnumerator_Value;
pub const IWSManEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ReadItem: *const fn (
            self: *const IWSManEnumerator,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AtEndOfStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManEnumerator,
            eos: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManEnumerator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn readItem(self: *const T, resource_: ?*?BSTR) HRESULT {
                return @as(*const IWSManEnumerator.VTable, @ptrCast(self.vtable)).ReadItem(@as(*const IWSManEnumerator, @ptrCast(self)), resource_);
            }
            pub inline fn getAtEndOfStream(self: *const T, eos_: ?*i16) HRESULT {
                return @as(*const IWSManEnumerator.VTable, @ptrCast(self.vtable)).get_AtEndOfStream(@as(*const IWSManEnumerator, @ptrCast(self)), eos_);
            }
            pub inline fn getError(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IWSManEnumerator.VTable, @ptrCast(self.vtable)).get_Error(@as(*const IWSManEnumerator, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManResourceLocator_Value = Guid.initString("a7a1ba28-de41-466a-ad0a-c4059ead7428");
pub const IID_IWSManResourceLocator = &IID_IWSManResourceLocator_Value;
pub const IWSManResourceLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResourceURI: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            uri: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResourceURI: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSelector: *const fn (
            self: *const IWSManResourceLocator,
            resource_sel_name: ?BSTR,
            sel_value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSelectors: *const fn (
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentDialect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentDialect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOption: *const fn (
            self: *const IWSManResourceLocator,
            option_name: ?BSTR,
            option_value: VARIANT,
            must_comply: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MustUnderstandOptions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            must_understand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MustUnderstandOptions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            must_understand: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearOptions: *const fn (
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWSManResourceLocator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putResourceURI(self: *const T, uri_: ?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).put_ResourceURI(@as(*const IWSManResourceLocator, @ptrCast(self)), uri_);
            }
            pub inline fn getResourceURI(self: *const T, uri_: ?*?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).get_ResourceURI(@as(*const IWSManResourceLocator, @ptrCast(self)), uri_);
            }
            pub inline fn addSelector(self: *const T, resource_sel_name_: ?BSTR, sel_value_: VARIANT) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).AddSelector(@as(*const IWSManResourceLocator, @ptrCast(self)), resource_sel_name_, sel_value_);
            }
            pub inline fn clearSelectors(self: *const T) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).ClearSelectors(@as(*const IWSManResourceLocator, @ptrCast(self)));
            }
            pub inline fn getFragmentPath(self: *const T, text_: ?*?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).get_FragmentPath(@as(*const IWSManResourceLocator, @ptrCast(self)), text_);
            }
            pub inline fn putFragmentPath(self: *const T, text_: ?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).put_FragmentPath(@as(*const IWSManResourceLocator, @ptrCast(self)), text_);
            }
            pub inline fn getFragmentDialect(self: *const T, text_: ?*?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).get_FragmentDialect(@as(*const IWSManResourceLocator, @ptrCast(self)), text_);
            }
            pub inline fn putFragmentDialect(self: *const T, text_: ?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).put_FragmentDialect(@as(*const IWSManResourceLocator, @ptrCast(self)), text_);
            }
            pub inline fn addOption(self: *const T, option_name_: ?BSTR, option_value_: VARIANT, must_comply_: BOOL) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).AddOption(@as(*const IWSManResourceLocator, @ptrCast(self)), option_name_, option_value_, must_comply_);
            }
            pub inline fn putMustUnderstandOptions(self: *const T, must_understand_: BOOL) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).put_MustUnderstandOptions(@as(*const IWSManResourceLocator, @ptrCast(self)), must_understand_);
            }
            pub inline fn getMustUnderstandOptions(self: *const T, must_understand_: ?*BOOL) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).get_MustUnderstandOptions(@as(*const IWSManResourceLocator, @ptrCast(self)), must_understand_);
            }
            pub inline fn clearOptions(self: *const T) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).ClearOptions(@as(*const IWSManResourceLocator, @ptrCast(self)));
            }
            pub inline fn getError(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IWSManResourceLocator.VTable, @ptrCast(self.vtable)).get_Error(@as(*const IWSManResourceLocator, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManResourceLocatorInternal_Value = Guid.initString("effaead7-7ec8-4716-b9be-f2e7e9fb4adb");
pub const IID_IWSManResourceLocatorInternal = &IID_IWSManResourceLocatorInternal_Value;
pub const IWSManResourceLocatorInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManInternal_Value = Guid.initString("04ae2b1d-9954-4d99-94a9-a961e72c3a13");
pub const IID_IWSManInternal = &IID_IWSManInternal_Value;
pub const IWSManInternal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConfigSDDL: *const fn (
            self: *const IWSManInternal,
            session: ?*IDispatch,
            resource_uri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn configSDDL(self: *const T, session_: ?*IDispatch, resource_uri_: VARIANT, flags_: i32, resource_: ?*?BSTR) HRESULT {
                return @as(*const IWSManInternal.VTable, @ptrCast(self.vtable)).ConfigSDDL(@as(*const IWSManInternal, @ptrCast(self)), session_, resource_uri_, flags_, resource_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (33)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManInitialize(
    flags: u32,
    api_handle: ?*?*WSMAN_API,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManDeinitialize(
    api_handle: ?*WSMAN_API,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetErrorMessage(
    api_handle: ?*WSMAN_API,
    flags: u32,
    language_code: ?[*:0]const u16,
    error_code: u32,
    message_length: u32,
    message: ?[*:0]u16,
    message_length_used: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCreateSession(
    api_handle: ?*WSMAN_API,
    connection: ?[*:0]const u16,
    flags: u32,
    server_authentication_credentials: ?*WSMAN_AUTHENTICATION_CREDENTIALS,
    proxy_info: ?*WSMAN_PROXY_INFO,
    session: ?*?*WSMAN_SESSION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseSession(
    session: ?*WSMAN_SESSION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSetSessionOption(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetSessionOptionAsDword(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetSessionOptionAsString(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    string_length: u32,
    string: ?[*:0]u16,
    string_length_used: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseOperation(
    operation_handle: ?*WSMAN_OPERATION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCreateShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resource_uri: ?[*:0]const u16,
    startup_info: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    create_xml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManRunShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    command_line: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSignalShell(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    code: ?[*:0]const u16,
    @"async": ?*WSMAN_SHELL_ASYNC,
    signal_operation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManReceiveShellOutput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    desired_stream_set: ?*WSMAN_STREAM_ID_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    receive_operation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSendShellInput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    stream_id: ?[*:0]const u16,
    stream_data: ?*WSMAN_DATA,
    end_of_stream: BOOL,
    @"async": ?*WSMAN_SHELL_ASYNC,
    send_operation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseCommand(
    command_handle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseShell(
    shell_handle: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManCreateShellEx(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resource_uri: ?[*:0]const u16,
    shell_id: ?[*:0]const u16,
    startup_info: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    create_xml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManRunShellCommandEx(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    command_id: ?[*:0]const u16,
    command_line: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManDisconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    disconnect_info: ?*WSMAN_SHELL_DISCONNECT_INFO,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManReconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManReconnectShellCommand(
    command_handle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManConnectShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resource_uri: ?[*:0]const u16,
    shell_i_d: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connect_xml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManConnectShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    command_i_d: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connect_xml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginReportContext(
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginReceiveResult(
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    stream: ?[*:0]const u16,
    stream_result: ?*WSMAN_DATA,
    command_state: ?[*:0]const u16,
    exit_code: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginOperationComplete(
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    error_code: u32,
    extended_information: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginGetOperationParameters(
    request_details: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wsmsvc" fn WSManPluginGetConfiguration(
    plugin_context: ?*anyopaque,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wsmsvc" fn WSManPluginReportCompletion(
    plugin_context: ?*anyopaque,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginFreeRequestDetails(
    request_details: ?*WSMAN_PLUGIN_REQUEST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzUserComplete(
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    user_authorization_context: ?*anyopaque,
    impersonation_token: ?HANDLE,
    user_is_administrator: BOOL,
    error_code: u32,
    extended_error_information: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzOperationComplete(
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    user_authorization_context: ?*anyopaque,
    error_code: u32,
    extended_error_information: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzQueryQuotaComplete(
    sender_details: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    quota: ?*WSMAN_AUTHZ_QUOTA,
    error_code: u32,
    extended_error_information: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "WSMAN_SHELL_COMPLETION_FUNCTION")) {
        _ = WSMAN_SHELL_COMPLETION_FUNCTION;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT")) {
        _ = WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT")) {
        _ = WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_STARTUP")) {
        _ = WSMAN_PLUGIN_STARTUP;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHUTDOWN")) {
        _ = WSMAN_PLUGIN_SHUTDOWN;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHELL")) {
        _ = WSMAN_PLUGIN_SHELL;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_COMMAND")) {
        _ = WSMAN_PLUGIN_COMMAND;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SEND")) {
        _ = WSMAN_PLUGIN_SEND;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RECEIVE")) {
        _ = WSMAN_PLUGIN_RECEIVE;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SIGNAL")) {
        _ = WSMAN_PLUGIN_SIGNAL;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_CONNECT")) {
        _ = WSMAN_PLUGIN_CONNECT;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_USER")) {
        _ = WSMAN_PLUGIN_AUTHORIZE_USER;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_OPERATION")) {
        _ = WSMAN_PLUGIN_AUTHORIZE_OPERATION;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA")) {
        _ = WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA;
    }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT")) {
        _ = WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
