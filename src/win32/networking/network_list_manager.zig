//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (15)
//--------------------------------------------------------------------------------
pub const NA_DomainAuthenticationFailed = "NA_DomainAuthenticationFailed";
pub const NA_NetworkClass = "NA_NetworkClass";
pub const NA_NameSetByPolicy = "NA_NameSetByPolicy";
pub const NA_IconSetByPolicy = "NA_IconSetByPolicy";
pub const NA_DescriptionSetByPolicy = "NA_DescriptionSetByPolicy";
pub const NA_CategorySetByPolicy = "NA_CategorySetByPolicy";
pub const NA_NameReadOnly = "NA_NameReadOnly";
pub const NA_IconReadOnly = "NA_IconReadOnly";
pub const NA_DescriptionReadOnly = "NA_DescriptionReadOnly";
pub const NA_CategoryReadOnly = "NA_CategoryReadOnly";
pub const NA_AllowMerge = "NA_AllowMerge";
pub const NA_InternetConnectivityV4 = "NA_InternetConnectivityV4";
pub const NA_InternetConnectivityV6 = "NA_InternetConnectivityV6";
pub const NLM_MAX_ADDRESS_LIST_SIZE = @as(u32, 10);
pub const NLM_UNKNOWN_DATAPLAN_STATUS = @as(u32, 4294967295);

//--------------------------------------------------------------------------------
// Section: Types (26)
//--------------------------------------------------------------------------------
const CLSID_NetworkListManager_Value = Guid.initString("dcb00c01-570f-4a9b-8d69-199fdba5723b");
pub const CLSID_NetworkListManager = &CLSID_NetworkListManager_Value;

pub const NLM_CONNECTION_COST = enum(i32) {
    UNKNOWN = 0,
    UNRESTRICTED = 1,
    FIXED = 2,
    VARIABLE = 4,
    OVERDATALIMIT = 65536,
    CONGESTED = 131072,
    ROAMING = 262144,
    APPROACHINGDATALIMIT = 524288,
};
pub const NLM_CONNECTION_COST_UNKNOWN = NLM_CONNECTION_COST.UNKNOWN;
pub const NLM_CONNECTION_COST_UNRESTRICTED = NLM_CONNECTION_COST.UNRESTRICTED;
pub const NLM_CONNECTION_COST_FIXED = NLM_CONNECTION_COST.FIXED;
pub const NLM_CONNECTION_COST_VARIABLE = NLM_CONNECTION_COST.VARIABLE;
pub const NLM_CONNECTION_COST_OVERDATALIMIT = NLM_CONNECTION_COST.OVERDATALIMIT;
pub const NLM_CONNECTION_COST_CONGESTED = NLM_CONNECTION_COST.CONGESTED;
pub const NLM_CONNECTION_COST_ROAMING = NLM_CONNECTION_COST.ROAMING;
pub const NLM_CONNECTION_COST_APPROACHINGDATALIMIT = NLM_CONNECTION_COST.APPROACHINGDATALIMIT;

pub const NLM_USAGE_DATA = extern struct {
    UsageInMegabytes: u32,
    LastSyncTime: FILETIME,
};

pub const NLM_DATAPLAN_STATUS = extern struct {
    InterfaceGuid: Guid,
    UsageData: NLM_USAGE_DATA,
    DataLimitInMegabytes: u32,
    InboundBandwidthInKbps: u32,
    OutboundBandwidthInKbps: u32,
    NextBillingCycle: FILETIME,
    MaxTransferSizeInMegabytes: u32,
    Reserved: u32,
};

pub const NLM_SOCKADDR = extern struct {
    data: [128]u8,
};

pub const NLM_NETWORK_CLASS = enum(i32) {
    IDENTIFYING = 1,
    IDENTIFIED = 2,
    UNIDENTIFIED = 3,
};
pub const NLM_NETWORK_IDENTIFYING = NLM_NETWORK_CLASS.IDENTIFYING;
pub const NLM_NETWORK_IDENTIFIED = NLM_NETWORK_CLASS.IDENTIFIED;
pub const NLM_NETWORK_UNIDENTIFIED = NLM_NETWORK_CLASS.UNIDENTIFIED;

pub const NLM_SIMULATED_PROFILE_INFO = extern struct {
    ProfileName: [256]u16,
    cost: NLM_CONNECTION_COST,
    UsageInMegabytes: u32,
    DataLimitInMegabytes: u32,
};

pub const NLM_INTERNET_CONNECTIVITY = enum(i32) {
    WEBHIJACK = 1,
    PROXIED = 2,
    CORPORATE = 4,
};
pub const NLM_INTERNET_CONNECTIVITY_WEBHIJACK = NLM_INTERNET_CONNECTIVITY.WEBHIJACK;
pub const NLM_INTERNET_CONNECTIVITY_PROXIED = NLM_INTERNET_CONNECTIVITY.PROXIED;
pub const NLM_INTERNET_CONNECTIVITY_CORPORATE = NLM_INTERNET_CONNECTIVITY.CORPORATE;

pub const NLM_CONNECTIVITY = enum(i32) {
    DISCONNECTED = 0,
    IPV4_NOTRAFFIC = 1,
    IPV6_NOTRAFFIC = 2,
    IPV4_SUBNET = 16,
    IPV4_LOCALNETWORK = 32,
    IPV4_INTERNET = 64,
    IPV6_SUBNET = 256,
    IPV6_LOCALNETWORK = 512,
    IPV6_INTERNET = 1024,
};
pub const NLM_CONNECTIVITY_DISCONNECTED = NLM_CONNECTIVITY.DISCONNECTED;
pub const NLM_CONNECTIVITY_IPV4_NOTRAFFIC = NLM_CONNECTIVITY.IPV4_NOTRAFFIC;
pub const NLM_CONNECTIVITY_IPV6_NOTRAFFIC = NLM_CONNECTIVITY.IPV6_NOTRAFFIC;
pub const NLM_CONNECTIVITY_IPV4_SUBNET = NLM_CONNECTIVITY.IPV4_SUBNET;
pub const NLM_CONNECTIVITY_IPV4_LOCALNETWORK = NLM_CONNECTIVITY.IPV4_LOCALNETWORK;
pub const NLM_CONNECTIVITY_IPV4_INTERNET = NLM_CONNECTIVITY.IPV4_INTERNET;
pub const NLM_CONNECTIVITY_IPV6_SUBNET = NLM_CONNECTIVITY.IPV6_SUBNET;
pub const NLM_CONNECTIVITY_IPV6_LOCALNETWORK = NLM_CONNECTIVITY.IPV6_LOCALNETWORK;
pub const NLM_CONNECTIVITY_IPV6_INTERNET = NLM_CONNECTIVITY.IPV6_INTERNET;

pub const NLM_DOMAIN_TYPE = enum(i32) {
    NON_DOMAIN_NETWORK = 0,
    DOMAIN_NETWORK = 1,
    DOMAIN_AUTHENTICATED = 2,
};
pub const NLM_DOMAIN_TYPE_NON_DOMAIN_NETWORK = NLM_DOMAIN_TYPE.NON_DOMAIN_NETWORK;
pub const NLM_DOMAIN_TYPE_DOMAIN_NETWORK = NLM_DOMAIN_TYPE.DOMAIN_NETWORK;
pub const NLM_DOMAIN_TYPE_DOMAIN_AUTHENTICATED = NLM_DOMAIN_TYPE.DOMAIN_AUTHENTICATED;

pub const NLM_ENUM_NETWORK = enum(i32) {
    CONNECTED = 1,
    DISCONNECTED = 2,
    ALL = 3,
};
pub const NLM_ENUM_NETWORK_CONNECTED = NLM_ENUM_NETWORK.CONNECTED;
pub const NLM_ENUM_NETWORK_DISCONNECTED = NLM_ENUM_NETWORK.DISCONNECTED;
pub const NLM_ENUM_NETWORK_ALL = NLM_ENUM_NETWORK.ALL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkListManager_Value = Guid.initString("dcb00000-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkListManager = &IID_INetworkListManager_Value;
pub const INetworkListManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetNetworks: *const fn (
            self: *const INetworkListManager,
            flags: NLM_ENUM_NETWORK,
            pp_enum_network: ?*?*IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetwork: *const fn (
            self: *const INetworkListManager,
            gd_network_id: Guid,
            pp_network: ?*?*INetwork,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnections: *const fn (
            self: *const INetworkListManager,
            pp_enum: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnection: *const fn (
            self: *const INetworkListManager,
            gd_network_connection_id: Guid,
            pp_network_connection: ?*?*INetworkConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetworkListManager,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetworkListManager,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: *const fn (
            self: *const INetworkListManager,
            p_connectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSimulatedProfileInfo: *const fn (
            self: *const INetworkListManager,
            p_simulated_info: ?*NLM_SIMULATED_PROFILE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSimulatedProfileInfo: *const fn (
            self: *const INetworkListManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNetworks(self: *const T, flags_: NLM_ENUM_NETWORK, pp_enum_network_: ?*?*IEnumNetworks) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).GetNetworks(@as(*const INetworkListManager, @ptrCast(self)), flags_, pp_enum_network_);
            }
            pub inline fn getNetwork(self: *const T, gd_network_id_: Guid, pp_network_: ?*?*INetwork) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).GetNetwork(@as(*const INetworkListManager, @ptrCast(self)), gd_network_id_, pp_network_);
            }
            pub inline fn getNetworkConnections(self: *const T, pp_enum_: ?*?*IEnumNetworkConnections) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).GetNetworkConnections(@as(*const INetworkListManager, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getNetworkConnection(self: *const T, gd_network_connection_id_: Guid, pp_network_connection_: ?*?*INetworkConnection) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).GetNetworkConnection(@as(*const INetworkListManager, @ptrCast(self)), gd_network_connection_id_, pp_network_connection_);
            }
            pub inline fn getIsConnectedToInternet(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).get_IsConnectedToInternet(@as(*const INetworkListManager, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getIsConnected(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).get_IsConnected(@as(*const INetworkListManager, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getConnectivity(self: *const T, p_connectivity_: ?*NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).GetConnectivity(@as(*const INetworkListManager, @ptrCast(self)), p_connectivity_);
            }
            pub inline fn setSimulatedProfileInfo(self: *const T, p_simulated_info_: ?*NLM_SIMULATED_PROFILE_INFO) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).SetSimulatedProfileInfo(@as(*const INetworkListManager, @ptrCast(self)), p_simulated_info_);
            }
            pub inline fn clearSimulatedProfileInfo(self: *const T) HRESULT {
                return @as(*const INetworkListManager.VTable, @ptrCast(self.vtable)).ClearSimulatedProfileInfo(@as(*const INetworkListManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkListManagerEvents_Value = Guid.initString("dcb00001-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkListManagerEvents = &IID_INetworkListManagerEvents_Value;
pub const INetworkListManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectivityChanged: *const fn (
            self: *const INetworkListManagerEvents,
            new_connectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn connectivityChanged(self: *const T, new_connectivity_: NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetworkListManagerEvents.VTable, @ptrCast(self.vtable)).ConnectivityChanged(@as(*const INetworkListManagerEvents, @ptrCast(self)), new_connectivity_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_NETWORK_CATEGORY = enum(i32) {
    PUBLIC = 0,
    PRIVATE = 1,
    DOMAIN_AUTHENTICATED = 2,
};
pub const NLM_NETWORK_CATEGORY_PUBLIC = NLM_NETWORK_CATEGORY.PUBLIC;
pub const NLM_NETWORK_CATEGORY_PRIVATE = NLM_NETWORK_CATEGORY.PRIVATE;
pub const NLM_NETWORK_CATEGORY_DOMAIN_AUTHENTICATED = NLM_NETWORK_CATEGORY.DOMAIN_AUTHENTICATED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetwork_Value = Guid.initString("dcb00002-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetwork = &IID_INetwork_Value;
pub const INetwork = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: *const fn (
            self: *const INetwork,
            psz_network_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: *const fn (
            self: *const INetwork,
            sz_network_new_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: *const fn (
            self: *const INetwork,
            psz_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: *const fn (
            self: *const INetwork,
            sz_description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkId: *const fn (
            self: *const INetwork,
            pgd_guid_network_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomainType: *const fn (
            self: *const INetwork,
            p_network_type: ?*NLM_DOMAIN_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnections: *const fn (
            self: *const INetwork,
            pp_enum_network_connection: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeCreatedAndConnected: *const fn (
            self: *const INetwork,
            pdw_low_date_time_created: ?*u32,
            pdw_high_date_time_created: ?*u32,
            pdw_low_date_time_connected: ?*u32,
            pdw_high_date_time_connected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetwork,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetwork,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: *const fn (
            self: *const INetwork,
            p_connectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: *const fn (
            self: *const INetwork,
            p_category: ?*NLM_NETWORK_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCategory: *const fn (
            self: *const INetwork,
            new_category: NLM_NETWORK_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, psz_network_name_: ?*?BSTR) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetName(@as(*const INetwork, @ptrCast(self)), psz_network_name_);
            }
            pub inline fn setName(self: *const T, sz_network_new_name_: ?BSTR) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).SetName(@as(*const INetwork, @ptrCast(self)), sz_network_new_name_);
            }
            pub inline fn getDescription(self: *const T, psz_description_: ?*?BSTR) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const INetwork, @ptrCast(self)), psz_description_);
            }
            pub inline fn setDescription(self: *const T, sz_description_: ?BSTR) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const INetwork, @ptrCast(self)), sz_description_);
            }
            pub inline fn getNetworkId(self: *const T, pgd_guid_network_id_: ?*Guid) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetNetworkId(@as(*const INetwork, @ptrCast(self)), pgd_guid_network_id_);
            }
            pub inline fn getDomainType(self: *const T, p_network_type_: ?*NLM_DOMAIN_TYPE) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetDomainType(@as(*const INetwork, @ptrCast(self)), p_network_type_);
            }
            pub inline fn getNetworkConnections(self: *const T, pp_enum_network_connection_: ?*?*IEnumNetworkConnections) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetNetworkConnections(@as(*const INetwork, @ptrCast(self)), pp_enum_network_connection_);
            }
            pub inline fn getTimeCreatedAndConnected(self: *const T, pdw_low_date_time_created_: ?*u32, pdw_high_date_time_created_: ?*u32, pdw_low_date_time_connected_: ?*u32, pdw_high_date_time_connected_: ?*u32) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetTimeCreatedAndConnected(@as(*const INetwork, @ptrCast(self)), pdw_low_date_time_created_, pdw_high_date_time_created_, pdw_low_date_time_connected_, pdw_high_date_time_connected_);
            }
            pub inline fn getIsConnectedToInternet(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).get_IsConnectedToInternet(@as(*const INetwork, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getIsConnected(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).get_IsConnected(@as(*const INetwork, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getConnectivity(self: *const T, p_connectivity_: ?*NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetConnectivity(@as(*const INetwork, @ptrCast(self)), p_connectivity_);
            }
            pub inline fn getCategory(self: *const T, p_category_: ?*NLM_NETWORK_CATEGORY) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).GetCategory(@as(*const INetwork, @ptrCast(self)), p_category_);
            }
            pub inline fn setCategory(self: *const T, new_category_: NLM_NETWORK_CATEGORY) HRESULT {
                return @as(*const INetwork.VTable, @ptrCast(self.vtable)).SetCategory(@as(*const INetwork, @ptrCast(self)), new_category_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumNetworks_Value = Guid.initString("dcb00003-570f-4a9b-8d69-199fdba5723b");
pub const IID_IEnumNetworks = &IID_IEnumNetworks_Value;
pub const IEnumNetworks = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEnumNetworks,
            pp_enum_var: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumNetworks,
            celt: u32,
            rgelt: [*]?*INetwork,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumNetworks,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumNetworks,
            pp_enum_network: ?*?*IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, pp_enum_var_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IEnumNetworks.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IEnumNetworks, @ptrCast(self)), pp_enum_var_);
            }
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*INetwork, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumNetworks.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetworks, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumNetworks.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetworks, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumNetworks.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetworks, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_network_: ?*?*IEnumNetworks) HRESULT {
                return @as(*const IEnumNetworks.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetworks, @ptrCast(self)), pp_enum_network_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_NETWORK_PROPERTY_CHANGE = enum(i32) {
    CONNECTION = 1,
    DESCRIPTION = 2,
    NAME = 4,
    ICON = 8,
    CATEGORY_VALUE = 16,
};
pub const NLM_NETWORK_PROPERTY_CHANGE_CONNECTION = NLM_NETWORK_PROPERTY_CHANGE.CONNECTION;
pub const NLM_NETWORK_PROPERTY_CHANGE_DESCRIPTION = NLM_NETWORK_PROPERTY_CHANGE.DESCRIPTION;
pub const NLM_NETWORK_PROPERTY_CHANGE_NAME = NLM_NETWORK_PROPERTY_CHANGE.NAME;
pub const NLM_NETWORK_PROPERTY_CHANGE_ICON = NLM_NETWORK_PROPERTY_CHANGE.ICON;
pub const NLM_NETWORK_PROPERTY_CHANGE_CATEGORY_VALUE = NLM_NETWORK_PROPERTY_CHANGE.CATEGORY_VALUE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkEvents_Value = Guid.initString("dcb00004-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkEvents = &IID_INetworkEvents_Value;
pub const INetworkEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NetworkAdded: *const fn (
            self: *const INetworkEvents,
            network_id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkDeleted: *const fn (
            self: *const INetworkEvents,
            network_id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkConnectivityChanged: *const fn (
            self: *const INetworkEvents,
            network_id: Guid,
            new_connectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkPropertyChanged: *const fn (
            self: *const INetworkEvents,
            network_id: Guid,
            flags: NLM_NETWORK_PROPERTY_CHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn networkAdded(self: *const T, network_id_: Guid) HRESULT {
                return @as(*const INetworkEvents.VTable, @ptrCast(self.vtable)).NetworkAdded(@as(*const INetworkEvents, @ptrCast(self)), network_id_);
            }
            pub inline fn networkDeleted(self: *const T, network_id_: Guid) HRESULT {
                return @as(*const INetworkEvents.VTable, @ptrCast(self.vtable)).NetworkDeleted(@as(*const INetworkEvents, @ptrCast(self)), network_id_);
            }
            pub inline fn networkConnectivityChanged(self: *const T, network_id_: Guid, new_connectivity_: NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetworkEvents.VTable, @ptrCast(self.vtable)).NetworkConnectivityChanged(@as(*const INetworkEvents, @ptrCast(self)), network_id_, new_connectivity_);
            }
            pub inline fn networkPropertyChanged(self: *const T, network_id_: Guid, flags_: NLM_NETWORK_PROPERTY_CHANGE) HRESULT {
                return @as(*const INetworkEvents.VTable, @ptrCast(self.vtable)).NetworkPropertyChanged(@as(*const INetworkEvents, @ptrCast(self)), network_id_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkConnection_Value = Guid.initString("dcb00005-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnection = &IID_INetworkConnection_Value;
pub const INetworkConnection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetNetwork: *const fn (
            self: *const INetworkConnection,
            pp_network: ?*?*INetwork,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetworkConnection,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const INetworkConnection,
            pb_is_connected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: *const fn (
            self: *const INetworkConnection,
            p_connectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectionId: *const fn (
            self: *const INetworkConnection,
            pgd_connection_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterId: *const fn (
            self: *const INetworkConnection,
            pgd_adapter_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomainType: *const fn (
            self: *const INetworkConnection,
            p_domain_type: ?*NLM_DOMAIN_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNetwork(self: *const T, pp_network_: ?*?*INetwork) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).GetNetwork(@as(*const INetworkConnection, @ptrCast(self)), pp_network_);
            }
            pub inline fn getIsConnectedToInternet(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).get_IsConnectedToInternet(@as(*const INetworkConnection, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getIsConnected(self: *const T, pb_is_connected_: ?*i16) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).get_IsConnected(@as(*const INetworkConnection, @ptrCast(self)), pb_is_connected_);
            }
            pub inline fn getConnectivity(self: *const T, p_connectivity_: ?*NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).GetConnectivity(@as(*const INetworkConnection, @ptrCast(self)), p_connectivity_);
            }
            pub inline fn getConnectionId(self: *const T, pgd_connection_id_: ?*Guid) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).GetConnectionId(@as(*const INetworkConnection, @ptrCast(self)), pgd_connection_id_);
            }
            pub inline fn getAdapterId(self: *const T, pgd_adapter_id_: ?*Guid) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).GetAdapterId(@as(*const INetworkConnection, @ptrCast(self)), pgd_adapter_id_);
            }
            pub inline fn getDomainType(self: *const T, p_domain_type_: ?*NLM_DOMAIN_TYPE) HRESULT {
                return @as(*const INetworkConnection.VTable, @ptrCast(self.vtable)).GetDomainType(@as(*const INetworkConnection, @ptrCast(self)), p_domain_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumNetworkConnections_Value = Guid.initString("dcb00006-570f-4a9b-8d69-199fdba5723b");
pub const IID_IEnumNetworkConnections = &IID_IEnumNetworkConnections_Value;
pub const IEnumNetworkConnections = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEnumNetworkConnections,
            pp_enum_var: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumNetworkConnections,
            celt: u32,
            rgelt: [*]?*INetworkConnection,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumNetworkConnections,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumNetworkConnections,
            pp_enum_network: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, pp_enum_var_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IEnumNetworkConnections.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IEnumNetworkConnections, @ptrCast(self)), pp_enum_var_);
            }
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*INetworkConnection, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumNetworkConnections.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetworkConnections, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumNetworkConnections.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetworkConnections, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumNetworkConnections.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetworkConnections, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_network_: ?*?*IEnumNetworkConnections) HRESULT {
                return @as(*const IEnumNetworkConnections.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetworkConnections, @ptrCast(self)), pp_enum_network_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_CONNECTION_PROPERTY_CHANGE = enum(i32) {
    N = 1,
};
pub const NLM_CONNECTION_PROPERTY_CHANGE_AUTHENTICATION = NLM_CONNECTION_PROPERTY_CHANGE.N;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkConnectionEvents_Value = Guid.initString("dcb00007-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionEvents = &IID_INetworkConnectionEvents_Value;
pub const INetworkConnectionEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NetworkConnectionConnectivityChanged: *const fn (
            self: *const INetworkConnectionEvents,
            connection_id: Guid,
            new_connectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkConnectionPropertyChanged: *const fn (
            self: *const INetworkConnectionEvents,
            connection_id: Guid,
            flags: NLM_CONNECTION_PROPERTY_CHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn networkConnectionConnectivityChanged(self: *const T, connection_id_: Guid, new_connectivity_: NLM_CONNECTIVITY) HRESULT {
                return @as(*const INetworkConnectionEvents.VTable, @ptrCast(self.vtable)).NetworkConnectionConnectivityChanged(@as(*const INetworkConnectionEvents, @ptrCast(self)), connection_id_, new_connectivity_);
            }
            pub inline fn networkConnectionPropertyChanged(self: *const T, connection_id_: Guid, flags_: NLM_CONNECTION_PROPERTY_CHANGE) HRESULT {
                return @as(*const INetworkConnectionEvents.VTable, @ptrCast(self.vtable)).NetworkConnectionPropertyChanged(@as(*const INetworkConnectionEvents, @ptrCast(self)), connection_id_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkCostManager_Value = Guid.initString("dcb00008-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkCostManager = &IID_INetworkCostManager_Value;
pub const INetworkCostManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCost: *const fn (
            self: *const INetworkCostManager,
            p_cost: ?*u32,
            p_dest_i_p_addr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataPlanStatus: *const fn (
            self: *const INetworkCostManager,
            p_data_plan_status: ?*NLM_DATAPLAN_STATUS,
            p_dest_i_p_addr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestinationAddresses: *const fn (
            self: *const INetworkCostManager,
            length: u32,
            p_dest_i_p_addr_list: [*]NLM_SOCKADDR,
            b_append: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCost(self: *const T, p_cost_: ?*u32, p_dest_i_p_addr_: ?*NLM_SOCKADDR) HRESULT {
                return @as(*const INetworkCostManager.VTable, @ptrCast(self.vtable)).GetCost(@as(*const INetworkCostManager, @ptrCast(self)), p_cost_, p_dest_i_p_addr_);
            }
            pub inline fn getDataPlanStatus(self: *const T, p_data_plan_status_: ?*NLM_DATAPLAN_STATUS, p_dest_i_p_addr_: ?*NLM_SOCKADDR) HRESULT {
                return @as(*const INetworkCostManager.VTable, @ptrCast(self.vtable)).GetDataPlanStatus(@as(*const INetworkCostManager, @ptrCast(self)), p_data_plan_status_, p_dest_i_p_addr_);
            }
            pub inline fn setDestinationAddresses(self: *const T, length_: u32, p_dest_i_p_addr_list_: [*]NLM_SOCKADDR, b_append_: i16) HRESULT {
                return @as(*const INetworkCostManager.VTable, @ptrCast(self.vtable)).SetDestinationAddresses(@as(*const INetworkCostManager, @ptrCast(self)), length_, p_dest_i_p_addr_list_, b_append_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkCostManagerEvents_Value = Guid.initString("dcb00009-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkCostManagerEvents = &IID_INetworkCostManagerEvents_Value;
pub const INetworkCostManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CostChanged: *const fn (
            self: *const INetworkCostManagerEvents,
            new_cost: u32,
            p_dest_addr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DataPlanStatusChanged: *const fn (
            self: *const INetworkCostManagerEvents,
            p_dest_addr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn costChanged(self: *const T, new_cost_: u32, p_dest_addr_: ?*NLM_SOCKADDR) HRESULT {
                return @as(*const INetworkCostManagerEvents.VTable, @ptrCast(self.vtable)).CostChanged(@as(*const INetworkCostManagerEvents, @ptrCast(self)), new_cost_, p_dest_addr_);
            }
            pub inline fn dataPlanStatusChanged(self: *const T, p_dest_addr_: ?*NLM_SOCKADDR) HRESULT {
                return @as(*const INetworkCostManagerEvents.VTable, @ptrCast(self.vtable)).DataPlanStatusChanged(@as(*const INetworkCostManagerEvents, @ptrCast(self)), p_dest_addr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkConnectionCost_Value = Guid.initString("dcb0000a-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionCost = &IID_INetworkConnectionCost_Value;
pub const INetworkConnectionCost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCost: *const fn (
            self: *const INetworkConnectionCost,
            p_cost: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataPlanStatus: *const fn (
            self: *const INetworkConnectionCost,
            p_data_plan_status: ?*NLM_DATAPLAN_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCost(self: *const T, p_cost_: ?*u32) HRESULT {
                return @as(*const INetworkConnectionCost.VTable, @ptrCast(self.vtable)).GetCost(@as(*const INetworkConnectionCost, @ptrCast(self)), p_cost_);
            }
            pub inline fn getDataPlanStatus(self: *const T, p_data_plan_status_: ?*NLM_DATAPLAN_STATUS) HRESULT {
                return @as(*const INetworkConnectionCost.VTable, @ptrCast(self.vtable)).GetDataPlanStatus(@as(*const INetworkConnectionCost, @ptrCast(self)), p_data_plan_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkConnectionCostEvents_Value = Guid.initString("dcb0000b-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionCostEvents = &IID_INetworkConnectionCostEvents_Value;
pub const INetworkConnectionCostEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectionCostChanged: *const fn (
            self: *const INetworkConnectionCostEvents,
            connection_id: Guid,
            new_cost: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionDataPlanStatusChanged: *const fn (
            self: *const INetworkConnectionCostEvents,
            connection_id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn connectionCostChanged(self: *const T, connection_id_: Guid, new_cost_: u32) HRESULT {
                return @as(*const INetworkConnectionCostEvents.VTable, @ptrCast(self.vtable)).ConnectionCostChanged(@as(*const INetworkConnectionCostEvents, @ptrCast(self)), connection_id_, new_cost_);
            }
            pub inline fn connectionDataPlanStatusChanged(self: *const T, connection_id_: Guid) HRESULT {
                return @as(*const INetworkConnectionCostEvents.VTable, @ptrCast(self.vtable)).ConnectionDataPlanStatusChanged(@as(*const INetworkConnectionCostEvents, @ptrCast(self)), connection_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
