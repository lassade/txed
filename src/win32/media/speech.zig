//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (68)
//--------------------------------------------------------------------------------
pub const SPDUI_EngineProperties = "EngineProperties";
pub const SPDUI_AddRemoveWord = "AddRemoveWord";
pub const SPDUI_UserTraining = "UserTraining";
pub const SPDUI_MicTraining = "MicTraining";
pub const SPDUI_RecoProfileProperties = "RecoProfileProperties";
pub const SPDUI_AudioProperties = "AudioProperties";
pub const SPDUI_AudioVolume = "AudioVolume";
pub const SPDUI_UserEnrollment = "UserEnrollment";
pub const SPDUI_ShareData = "ShareData";
pub const SPDUI_Tutorial = "Tutorial";
pub const SPREG_USER_ROOT = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech";
pub const SPREG_LOCAL_MACHINE_ROOT = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech";
pub const SPCAT_AUDIOOUT = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioOutput";
pub const SPCAT_AUDIOIN = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput";
pub const SPCAT_VOICES = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices";
pub const SPCAT_RECOGNIZERS = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers";
pub const SPCAT_APPLEXICONS = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AppLexicons";
pub const SPCAT_PHONECONVERTERS = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\PhoneConverters";
pub const SPCAT_TEXTNORMALIZERS = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\TextNormalizers";
pub const SPCAT_RECOPROFILES = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\RecoProfiles";
pub const SPMMSYS_AUDIO_IN_TOKEN_ID = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput\\TokenEnums\\MMAudioIn\\";
pub const SPMMSYS_AUDIO_OUT_TOKEN_ID = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioOutput\\TokenEnums\\MMAudioOut\\";
pub const SPCURRENT_USER_LEXICON_TOKEN_ID = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\CurrentUserLexicon";
pub const SPCURRENT_USER_SHORTCUT_TOKEN_ID = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\CurrentUserShortcut";
pub const SPTOKENVALUE_CLSID = "CLSID";
pub const SPTOKENKEY_FILES = "Files";
pub const SPTOKENKEY_UI = "UI";
pub const SPTOKENKEY_ATTRIBUTES = "Attributes";
pub const SPTOKENKEY_RETAINEDAUDIO = "SecondsPerRetainedAudioEvent";
pub const SPTOKENKEY_AUDIO_LATENCY_WARNING = "LatencyWarningThreshold";
pub const SPTOKENKEY_AUDIO_LATENCY_TRUNCATE = "LatencyTruncateThreshold";
pub const SPTOKENKEY_AUDIO_LATENCY_UPDATE_INTERVAL = "LatencyUpdateInterval";
pub const SPVOICECATEGORY_TTSRATE = "DefaultTTSRate";
pub const SPPROP_RESOURCE_USAGE = "ResourceUsage";
pub const SPPROP_HIGH_CONFIDENCE_THRESHOLD = "HighConfidenceThreshold";
pub const SPPROP_NORMAL_CONFIDENCE_THRESHOLD = "NormalConfidenceThreshold";
pub const SPPROP_LOW_CONFIDENCE_THRESHOLD = "LowConfidenceThreshold";
pub const SPPROP_RESPONSE_SPEED = "ResponseSpeed";
pub const SPPROP_COMPLEX_RESPONSE_SPEED = "ComplexResponseSpeed";
pub const SPPROP_ADAPTATION_ON = "AdaptationOn";
pub const SPPROP_PERSISTED_BACKGROUND_ADAPTATION = "PersistedBackgroundAdaptation";
pub const SPPROP_PERSISTED_LANGUAGE_MODEL_ADAPTATION = "PersistedLanguageModelAdaptation";
pub const SPPROP_UX_IS_LISTENING = "UXIsListening";
pub const SPTOPIC_SPELLING = "Spelling";
pub const SPWILDCARD = "...";
pub const SPDICTATION = "*";
pub const SPINFDICTATION = "*+";
pub const SPREG_SAFE_USER_TOKENS = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\UserTokens";
pub const SP_LOW_CONFIDENCE = @as(i32, -1);
pub const SP_NORMAL_CONFIDENCE = @as(u32, 0);
pub const DEFAULT_WEIGHT = @as(u32, 1);
pub const SP_MAX_WORD_LENGTH = @as(u32, 128);
pub const SP_MAX_PRON_LENGTH = @as(u32, 384);
pub const SP_EMULATE_RESULT = @as(u32, 1073741824);
pub const SP_STREAMPOS_ASAP = @as(u32, 0);
pub const SP_STREAMPOS_REALTIME = @as(i32, -1);
pub const SPRP_NORMAL = @as(u32, 0);
pub const SP_MAX_LANGIDS = @as(u32, 20);
pub const SPRECOEXTENSION = "RecoExtension";
pub const SPALTERNATESCLSID = "AlternatesCLSID";
pub const SR_LOCALIZED_DESCRIPTION = "Description";
pub const SAPI_ERROR_BASE = @as(u32, 20480);
pub const Speech_Default_Weight = @as(f32, 1);
pub const Speech_Max_Word_Length = @as(i32, 128);
pub const Speech_Max_Pron_Length = @as(i32, 384);
pub const Speech_StreamPos_Asap = @as(i32, 0);
pub const Speech_StreamPos_RealTime = @as(i32, -1);
pub const SpeechAllElements = @as(i32, -1);

//--------------------------------------------------------------------------------
// Section: Types (294)
//--------------------------------------------------------------------------------
const CLSID_SpNotifyTranslator_Value = Guid.initString("e2ae5372-5d40-11d2-960e-00c04f8ee628");
pub const CLSID_SpNotifyTranslator = &CLSID_SpNotifyTranslator_Value;

const CLSID_SpObjectTokenCategory_Value = Guid.initString("a910187f-0c7a-45ac-92cc-59edafb77b53");
pub const CLSID_SpObjectTokenCategory = &CLSID_SpObjectTokenCategory_Value;

const CLSID_SpObjectToken_Value = Guid.initString("ef411752-3736-4cb4-9c8c-8ef4ccb58efe");
pub const CLSID_SpObjectToken = &CLSID_SpObjectToken_Value;

const CLSID_SpResourceManager_Value = Guid.initString("96749373-3391-11d2-9ee3-00c04f797396");
pub const CLSID_SpResourceManager = &CLSID_SpResourceManager_Value;

const CLSID_SpStreamFormatConverter_Value = Guid.initString("7013943a-e2ec-11d2-a086-00c04f8ef9b5");
pub const CLSID_SpStreamFormatConverter = &CLSID_SpStreamFormatConverter_Value;

const CLSID_SpMMAudioEnum_Value = Guid.initString("ab1890a0-e91f-11d2-bb91-00c04f8ee6c0");
pub const CLSID_SpMMAudioEnum = &CLSID_SpMMAudioEnum_Value;

const CLSID_SpMMAudioIn_Value = Guid.initString("cf3d2e50-53f2-11d2-960c-00c04f8ee628");
pub const CLSID_SpMMAudioIn = &CLSID_SpMMAudioIn_Value;

const CLSID_SpMMAudioOut_Value = Guid.initString("a8c680eb-3d32-11d2-9ee7-00c04f797396");
pub const CLSID_SpMMAudioOut = &CLSID_SpMMAudioOut_Value;

const CLSID_SpStream_Value = Guid.initString("715d9c59-4442-11d2-9605-00c04f8ee628");
pub const CLSID_SpStream = &CLSID_SpStream_Value;

const CLSID_SpVoice_Value = Guid.initString("96749377-3391-11d2-9ee3-00c04f797396");
pub const CLSID_SpVoice = &CLSID_SpVoice_Value;

const CLSID_SpSharedRecoContext_Value = Guid.initString("47206204-5eca-11d2-960f-00c04f8ee628");
pub const CLSID_SpSharedRecoContext = &CLSID_SpSharedRecoContext_Value;

const CLSID_SpInprocRecognizer_Value = Guid.initString("41b89b6b-9399-11d2-9623-00c04f8ee628");
pub const CLSID_SpInprocRecognizer = &CLSID_SpInprocRecognizer_Value;

const CLSID_SpSharedRecognizer_Value = Guid.initString("3bee4890-4fe9-4a37-8c1e-5e7e12791c1f");
pub const CLSID_SpSharedRecognizer = &CLSID_SpSharedRecognizer_Value;

const CLSID_SpLexicon_Value = Guid.initString("0655e396-25d0-11d3-9c26-00c04f8ef87c");
pub const CLSID_SpLexicon = &CLSID_SpLexicon_Value;

const CLSID_SpUnCompressedLexicon_Value = Guid.initString("c9e37c15-df92-4727-85d6-72e5eeb6995a");
pub const CLSID_SpUnCompressedLexicon = &CLSID_SpUnCompressedLexicon_Value;

const CLSID_SpCompressedLexicon_Value = Guid.initString("90903716-2f42-11d3-9c26-00c04f8ef87c");
pub const CLSID_SpCompressedLexicon = &CLSID_SpCompressedLexicon_Value;

const CLSID_SpShortcut_Value = Guid.initString("0d722f1a-9fcf-4e62-96d8-6df8f01a26aa");
pub const CLSID_SpShortcut = &CLSID_SpShortcut_Value;

const CLSID_SpPhoneConverter_Value = Guid.initString("9185f743-1143-4c28-86b5-bff14f20e5c8");
pub const CLSID_SpPhoneConverter = &CLSID_SpPhoneConverter_Value;

const CLSID_SpPhoneticAlphabetConverter_Value = Guid.initString("4f414126-dfe3-4629-99ee-797978317ead");
pub const CLSID_SpPhoneticAlphabetConverter = &CLSID_SpPhoneticAlphabetConverter_Value;

const CLSID_SpNullPhoneConverter_Value = Guid.initString("455f24e9-7396-4a16-9715-7c0fdbe3efe3");
pub const CLSID_SpNullPhoneConverter = &CLSID_SpNullPhoneConverter_Value;

const CLSID_SpTextSelectionInformation_Value = Guid.initString("0f92030a-cbfd-4ab8-a164-ff5985547ff6");
pub const CLSID_SpTextSelectionInformation = &CLSID_SpTextSelectionInformation_Value;

const CLSID_SpPhraseInfoBuilder_Value = Guid.initString("c23fc28d-c55f-4720-8b32-91f73c2bd5d1");
pub const CLSID_SpPhraseInfoBuilder = &CLSID_SpPhraseInfoBuilder_Value;

const CLSID_SpAudioFormat_Value = Guid.initString("9ef96870-e160-4792-820d-48cf0649e4ec");
pub const CLSID_SpAudioFormat = &CLSID_SpAudioFormat_Value;

const CLSID_SpWaveFormatEx_Value = Guid.initString("c79a574c-63be-44b9-801f-283f87f898be");
pub const CLSID_SpWaveFormatEx = &CLSID_SpWaveFormatEx_Value;

const CLSID_SpInProcRecoContext_Value = Guid.initString("73ad6842-ace0-45e8-a4dd-8795881a2c2a");
pub const CLSID_SpInProcRecoContext = &CLSID_SpInProcRecoContext_Value;

const CLSID_SpCustomStream_Value = Guid.initString("8dbef13f-1948-4aa8-8cf0-048eebed95d8");
pub const CLSID_SpCustomStream = &CLSID_SpCustomStream_Value;

const CLSID_SpFileStream_Value = Guid.initString("947812b3-2ae1-4644-ba86-9e90ded7ec91");
pub const CLSID_SpFileStream = &CLSID_SpFileStream_Value;

const CLSID_SpMemoryStream_Value = Guid.initString("5fb7ef7d-dff4-468a-b6b7-2fcbd188f994");
pub const CLSID_SpMemoryStream = &CLSID_SpMemoryStream_Value;

pub const SPDATAKEYLOCATION = enum(i32) {
    DefaultLocation = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    CurrentConfig = 5,
};
pub const SPDKL_DefaultLocation = SPDATAKEYLOCATION.DefaultLocation;
pub const SPDKL_CurrentUser = SPDATAKEYLOCATION.CurrentUser;
pub const SPDKL_LocalMachine = SPDATAKEYLOCATION.LocalMachine;
pub const SPDKL_CurrentConfig = SPDATAKEYLOCATION.CurrentConfig;

pub const SPSTREAMFORMAT = enum(i32) {
    Default = -1,
    NoAssignedFormat = 0,
    Text = 1,
    NonStandardFormat = 2,
    ExtendedAudioFormat = 3,
    @"8kHz8BitMono" = 4,
    @"8kHz8BitStereo" = 5,
    @"8kHz16BitMono" = 6,
    @"8kHz16BitStereo" = 7,
    @"11kHz8BitMono" = 8,
    @"11kHz8BitStereo" = 9,
    @"11kHz16BitMono" = 10,
    @"11kHz16BitStereo" = 11,
    @"12kHz8BitMono" = 12,
    @"12kHz8BitStereo" = 13,
    @"12kHz16BitMono" = 14,
    @"12kHz16BitStereo" = 15,
    @"16kHz8BitMono" = 16,
    @"16kHz8BitStereo" = 17,
    @"16kHz16BitMono" = 18,
    @"16kHz16BitStereo" = 19,
    @"22kHz8BitMono" = 20,
    @"22kHz8BitStereo" = 21,
    @"22kHz16BitMono" = 22,
    @"22kHz16BitStereo" = 23,
    @"24kHz8BitMono" = 24,
    @"24kHz8BitStereo" = 25,
    @"24kHz16BitMono" = 26,
    @"24kHz16BitStereo" = 27,
    @"32kHz8BitMono" = 28,
    @"32kHz8BitStereo" = 29,
    @"32kHz16BitMono" = 30,
    @"32kHz16BitStereo" = 31,
    @"44kHz8BitMono" = 32,
    @"44kHz8BitStereo" = 33,
    @"44kHz16BitMono" = 34,
    @"44kHz16BitStereo" = 35,
    @"48kHz8BitMono" = 36,
    @"48kHz8BitStereo" = 37,
    @"48kHz16BitMono" = 38,
    @"48kHz16BitStereo" = 39,
    TrueSpeech_8kHz1BitMono = 40,
    CCITT_ALaw_8kHzMono = 41,
    CCITT_ALaw_8kHzStereo = 42,
    CCITT_ALaw_11kHzMono = 43,
    CCITT_ALaw_11kHzStereo = 44,
    CCITT_ALaw_22kHzMono = 45,
    CCITT_ALaw_22kHzStereo = 46,
    CCITT_ALaw_44kHzMono = 47,
    CCITT_ALaw_44kHzStereo = 48,
    CCITT_uLaw_8kHzMono = 49,
    CCITT_uLaw_8kHzStereo = 50,
    CCITT_uLaw_11kHzMono = 51,
    CCITT_uLaw_11kHzStereo = 52,
    CCITT_uLaw_22kHzMono = 53,
    CCITT_uLaw_22kHzStereo = 54,
    CCITT_uLaw_44kHzMono = 55,
    CCITT_uLaw_44kHzStereo = 56,
    ADPCM_8kHzMono = 57,
    ADPCM_8kHzStereo = 58,
    ADPCM_11kHzMono = 59,
    ADPCM_11kHzStereo = 60,
    ADPCM_22kHzMono = 61,
    ADPCM_22kHzStereo = 62,
    ADPCM_44kHzMono = 63,
    ADPCM_44kHzStereo = 64,
    GSM610_8kHzMono = 65,
    GSM610_11kHzMono = 66,
    GSM610_22kHzMono = 67,
    GSM610_44kHzMono = 68,
    NUM_FORMATS = 69,
};
pub const SPSF_Default = SPSTREAMFORMAT.Default;
pub const SPSF_NoAssignedFormat = SPSTREAMFORMAT.NoAssignedFormat;
pub const SPSF_Text = SPSTREAMFORMAT.Text;
pub const SPSF_NonStandardFormat = SPSTREAMFORMAT.NonStandardFormat;
pub const SPSF_ExtendedAudioFormat = SPSTREAMFORMAT.ExtendedAudioFormat;
pub const SPSF_8kHz8BitMono = SPSTREAMFORMAT.@"8kHz8BitMono";
pub const SPSF_8kHz8BitStereo = SPSTREAMFORMAT.@"8kHz8BitStereo";
pub const SPSF_8kHz16BitMono = SPSTREAMFORMAT.@"8kHz16BitMono";
pub const SPSF_8kHz16BitStereo = SPSTREAMFORMAT.@"8kHz16BitStereo";
pub const SPSF_11kHz8BitMono = SPSTREAMFORMAT.@"11kHz8BitMono";
pub const SPSF_11kHz8BitStereo = SPSTREAMFORMAT.@"11kHz8BitStereo";
pub const SPSF_11kHz16BitMono = SPSTREAMFORMAT.@"11kHz16BitMono";
pub const SPSF_11kHz16BitStereo = SPSTREAMFORMAT.@"11kHz16BitStereo";
pub const SPSF_12kHz8BitMono = SPSTREAMFORMAT.@"12kHz8BitMono";
pub const SPSF_12kHz8BitStereo = SPSTREAMFORMAT.@"12kHz8BitStereo";
pub const SPSF_12kHz16BitMono = SPSTREAMFORMAT.@"12kHz16BitMono";
pub const SPSF_12kHz16BitStereo = SPSTREAMFORMAT.@"12kHz16BitStereo";
pub const SPSF_16kHz8BitMono = SPSTREAMFORMAT.@"16kHz8BitMono";
pub const SPSF_16kHz8BitStereo = SPSTREAMFORMAT.@"16kHz8BitStereo";
pub const SPSF_16kHz16BitMono = SPSTREAMFORMAT.@"16kHz16BitMono";
pub const SPSF_16kHz16BitStereo = SPSTREAMFORMAT.@"16kHz16BitStereo";
pub const SPSF_22kHz8BitMono = SPSTREAMFORMAT.@"22kHz8BitMono";
pub const SPSF_22kHz8BitStereo = SPSTREAMFORMAT.@"22kHz8BitStereo";
pub const SPSF_22kHz16BitMono = SPSTREAMFORMAT.@"22kHz16BitMono";
pub const SPSF_22kHz16BitStereo = SPSTREAMFORMAT.@"22kHz16BitStereo";
pub const SPSF_24kHz8BitMono = SPSTREAMFORMAT.@"24kHz8BitMono";
pub const SPSF_24kHz8BitStereo = SPSTREAMFORMAT.@"24kHz8BitStereo";
pub const SPSF_24kHz16BitMono = SPSTREAMFORMAT.@"24kHz16BitMono";
pub const SPSF_24kHz16BitStereo = SPSTREAMFORMAT.@"24kHz16BitStereo";
pub const SPSF_32kHz8BitMono = SPSTREAMFORMAT.@"32kHz8BitMono";
pub const SPSF_32kHz8BitStereo = SPSTREAMFORMAT.@"32kHz8BitStereo";
pub const SPSF_32kHz16BitMono = SPSTREAMFORMAT.@"32kHz16BitMono";
pub const SPSF_32kHz16BitStereo = SPSTREAMFORMAT.@"32kHz16BitStereo";
pub const SPSF_44kHz8BitMono = SPSTREAMFORMAT.@"44kHz8BitMono";
pub const SPSF_44kHz8BitStereo = SPSTREAMFORMAT.@"44kHz8BitStereo";
pub const SPSF_44kHz16BitMono = SPSTREAMFORMAT.@"44kHz16BitMono";
pub const SPSF_44kHz16BitStereo = SPSTREAMFORMAT.@"44kHz16BitStereo";
pub const SPSF_48kHz8BitMono = SPSTREAMFORMAT.@"48kHz8BitMono";
pub const SPSF_48kHz8BitStereo = SPSTREAMFORMAT.@"48kHz8BitStereo";
pub const SPSF_48kHz16BitMono = SPSTREAMFORMAT.@"48kHz16BitMono";
pub const SPSF_48kHz16BitStereo = SPSTREAMFORMAT.@"48kHz16BitStereo";
pub const SPSF_TrueSpeech_8kHz1BitMono = SPSTREAMFORMAT.TrueSpeech_8kHz1BitMono;
pub const SPSF_CCITT_ALaw_8kHzMono = SPSTREAMFORMAT.CCITT_ALaw_8kHzMono;
pub const SPSF_CCITT_ALaw_8kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_8kHzStereo;
pub const SPSF_CCITT_ALaw_11kHzMono = SPSTREAMFORMAT.CCITT_ALaw_11kHzMono;
pub const SPSF_CCITT_ALaw_11kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_11kHzStereo;
pub const SPSF_CCITT_ALaw_22kHzMono = SPSTREAMFORMAT.CCITT_ALaw_22kHzMono;
pub const SPSF_CCITT_ALaw_22kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_22kHzStereo;
pub const SPSF_CCITT_ALaw_44kHzMono = SPSTREAMFORMAT.CCITT_ALaw_44kHzMono;
pub const SPSF_CCITT_ALaw_44kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_44kHzStereo;
pub const SPSF_CCITT_uLaw_8kHzMono = SPSTREAMFORMAT.CCITT_uLaw_8kHzMono;
pub const SPSF_CCITT_uLaw_8kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_8kHzStereo;
pub const SPSF_CCITT_uLaw_11kHzMono = SPSTREAMFORMAT.CCITT_uLaw_11kHzMono;
pub const SPSF_CCITT_uLaw_11kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_11kHzStereo;
pub const SPSF_CCITT_uLaw_22kHzMono = SPSTREAMFORMAT.CCITT_uLaw_22kHzMono;
pub const SPSF_CCITT_uLaw_22kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_22kHzStereo;
pub const SPSF_CCITT_uLaw_44kHzMono = SPSTREAMFORMAT.CCITT_uLaw_44kHzMono;
pub const SPSF_CCITT_uLaw_44kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_44kHzStereo;
pub const SPSF_ADPCM_8kHzMono = SPSTREAMFORMAT.ADPCM_8kHzMono;
pub const SPSF_ADPCM_8kHzStereo = SPSTREAMFORMAT.ADPCM_8kHzStereo;
pub const SPSF_ADPCM_11kHzMono = SPSTREAMFORMAT.ADPCM_11kHzMono;
pub const SPSF_ADPCM_11kHzStereo = SPSTREAMFORMAT.ADPCM_11kHzStereo;
pub const SPSF_ADPCM_22kHzMono = SPSTREAMFORMAT.ADPCM_22kHzMono;
pub const SPSF_ADPCM_22kHzStereo = SPSTREAMFORMAT.ADPCM_22kHzStereo;
pub const SPSF_ADPCM_44kHzMono = SPSTREAMFORMAT.ADPCM_44kHzMono;
pub const SPSF_ADPCM_44kHzStereo = SPSTREAMFORMAT.ADPCM_44kHzStereo;
pub const SPSF_GSM610_8kHzMono = SPSTREAMFORMAT.GSM610_8kHzMono;
pub const SPSF_GSM610_11kHzMono = SPSTREAMFORMAT.GSM610_11kHzMono;
pub const SPSF_GSM610_22kHzMono = SPSTREAMFORMAT.GSM610_22kHzMono;
pub const SPSF_GSM610_44kHzMono = SPSTREAMFORMAT.GSM610_44kHzMono;
pub const SPSF_NUM_FORMATS = SPSTREAMFORMAT.NUM_FORMATS;

pub const ISpNotifyCallback = extern struct {
    pub const VTable = extern struct {
        NotifyCallback: *const fn (
            self: *const ISpNotifyCallback,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn notifyCallback(self: *const T, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifyCallback.VTable, @ptrCast(self.vtable)).NotifyCallback(@as(*const ISpNotifyCallback, @ptrCast(self)), w_param_, l_param_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPNOTIFYCALLBACK = *const fn (
    w_param: WPARAM,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) void;

const IID_ISpNotifySource_Value = Guid.initString("5eff4aef-8487-11d2-961c-00c04f8ee628");
pub const IID_ISpNotifySource = &IID_ISpNotifySource_Value;
pub const ISpNotifySource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNotifySink: *const fn (
            self: *const ISpNotifySource,
            p_notify_sink: ?*ISpNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyWindowMessage: *const fn (
            self: *const ISpNotifySource,
            h_wnd: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyCallbackFunction: *const fn (
            self: *const ISpNotifySource,
            pfn_callback: ?*?SPNOTIFYCALLBACK,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyCallbackInterface: *const fn (
            self: *const ISpNotifySource,
            p_sp_callback: ?*ISpNotifyCallback,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyWin32Event: *const fn (
            self: *const ISpNotifySource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForNotifyEvent: *const fn (
            self: *const ISpNotifySource,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: *const fn (
            self: *const ISpNotifySource,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setNotifySink(self: *const T, p_notify_sink_: ?*ISpNotifySink) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).SetNotifySink(@as(*const ISpNotifySource, @ptrCast(self)), p_notify_sink_);
            }
            pub inline fn setNotifyWindowMessage(self: *const T, h_wnd_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).SetNotifyWindowMessage(@as(*const ISpNotifySource, @ptrCast(self)), h_wnd_, msg_, w_param_, l_param_);
            }
            pub inline fn setNotifyCallbackFunction(self: *const T, pfn_callback_: ?*?SPNOTIFYCALLBACK, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).SetNotifyCallbackFunction(@as(*const ISpNotifySource, @ptrCast(self)), pfn_callback_, w_param_, l_param_);
            }
            pub inline fn setNotifyCallbackInterface(self: *const T, p_sp_callback_: ?*ISpNotifyCallback, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).SetNotifyCallbackInterface(@as(*const ISpNotifySource, @ptrCast(self)), p_sp_callback_, w_param_, l_param_);
            }
            pub inline fn setNotifyWin32Event(self: *const T) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).SetNotifyWin32Event(@as(*const ISpNotifySource, @ptrCast(self)));
            }
            pub inline fn waitForNotifyEvent(self: *const T, dw_milliseconds_: u32) HRESULT {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).WaitForNotifyEvent(@as(*const ISpNotifySource, @ptrCast(self)), dw_milliseconds_);
            }
            pub inline fn getNotifyEventHandle(self: *const T) ?HANDLE {
                return @as(*const ISpNotifySource.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const ISpNotifySource, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpNotifySink_Value = Guid.initString("259684dc-37c3-11d2-9603-00c04f8ee628");
pub const IID_ISpNotifySink = &IID_ISpNotifySink_Value;
pub const ISpNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: *const fn (
            self: *const ISpNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn notify(self: *const T) HRESULT {
                return @as(*const ISpNotifySink.VTable, @ptrCast(self.vtable)).Notify(@as(*const ISpNotifySink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpNotifyTranslator_Value = Guid.initString("aca16614-5d3d-11d2-960e-00c04f8ee628");
pub const IID_ISpNotifyTranslator = &IID_ISpNotifyTranslator_Value;
pub const ISpNotifyTranslator = extern struct {
    pub const VTable = extern struct {
        base: ISpNotifySink.VTable,
        InitWindowMessage: *const fn (
            self: *const ISpNotifyTranslator,
            h_wnd: ?HWND,
            msg: u32,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitCallback: *const fn (
            self: *const ISpNotifyTranslator,
            pfn_callback: ?*?SPNOTIFYCALLBACK,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitSpNotifyCallback: *const fn (
            self: *const ISpNotifyTranslator,
            p_sp_callback: ?*ISpNotifyCallback,
            w_param: WPARAM,
            l_param: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitWin32Event: *const fn (
            self: *const ISpNotifyTranslator,
            h_event: ?HANDLE,
            f_close_handle_on_release: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Wait: *const fn (
            self: *const ISpNotifyTranslator,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventHandle: *const fn (
            self: *const ISpNotifyTranslator,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpNotifySink.MethodMixin(T);
            pub inline fn initWindowMessage(self: *const T, h_wnd_: ?HWND, msg_: u32, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).InitWindowMessage(@as(*const ISpNotifyTranslator, @ptrCast(self)), h_wnd_, msg_, w_param_, l_param_);
            }
            pub inline fn initCallback(self: *const T, pfn_callback_: ?*?SPNOTIFYCALLBACK, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).InitCallback(@as(*const ISpNotifyTranslator, @ptrCast(self)), pfn_callback_, w_param_, l_param_);
            }
            pub inline fn initSpNotifyCallback(self: *const T, p_sp_callback_: ?*ISpNotifyCallback, w_param_: WPARAM, l_param_: LPARAM) HRESULT {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).InitSpNotifyCallback(@as(*const ISpNotifyTranslator, @ptrCast(self)), p_sp_callback_, w_param_, l_param_);
            }
            pub inline fn initWin32Event(self: *const T, h_event_: ?HANDLE, f_close_handle_on_release_: BOOL) HRESULT {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).InitWin32Event(@as(*const ISpNotifyTranslator, @ptrCast(self)), h_event_, f_close_handle_on_release_);
            }
            pub inline fn wait(self: *const T, dw_milliseconds_: u32) HRESULT {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).Wait(@as(*const ISpNotifyTranslator, @ptrCast(self)), dw_milliseconds_);
            }
            pub inline fn getEventHandle(self: *const T) ?HANDLE {
                return @as(*const ISpNotifyTranslator.VTable, @ptrCast(self.vtable)).GetEventHandle(@as(*const ISpNotifyTranslator, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpDataKey_Value = Guid.initString("14056581-e16c-11d2-bb90-00c04f8ee6c0");
pub const IID_ISpDataKey = &IID_ISpDataKey_Value;
pub const ISpDataKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetData: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            cb_data: u32,
            p_data: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            pcb_data: ?*u32,
            p_data: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStringValue: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            psz_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            ppsz_value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDWORD: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            dw_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDWORD: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
            pdw_value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenKey: *const fn (
            self: *const ISpDataKey,
            psz_sub_key_name: ?[*:0]const u16,
            pp_sub_key: ?*?*ISpDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateKey: *const fn (
            self: *const ISpDataKey,
            psz_sub_key: ?[*:0]const u16,
            pp_sub_key: ?*?*ISpDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteKey: *const fn (
            self: *const ISpDataKey,
            psz_sub_key: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteValue: *const fn (
            self: *const ISpDataKey,
            psz_value_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumKeys: *const fn (
            self: *const ISpDataKey,
            index: u32,
            ppsz_sub_key_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumValues: *const fn (
            self: *const ISpDataKey,
            index: u32,
            ppsz_value_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setData(self: *const T, psz_value_name_: ?[*:0]const u16, cb_data_: u32, p_data_: ?*const u8) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).SetData(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, cb_data_, p_data_);
            }
            pub inline fn getData(self: *const T, psz_value_name_: ?[*:0]const u16, pcb_data_: ?*u32, p_data_: ?*u8) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).GetData(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, pcb_data_, p_data_);
            }
            pub inline fn setStringValue(self: *const T, psz_value_name_: ?[*:0]const u16, psz_value_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).SetStringValue(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, psz_value_);
            }
            pub inline fn getStringValue(self: *const T, psz_value_name_: ?[*:0]const u16, ppsz_value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, ppsz_value_);
            }
            pub inline fn setDWORD(self: *const T, psz_value_name_: ?[*:0]const u16, dw_value_: u32) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).SetDWORD(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, dw_value_);
            }
            pub inline fn getDWORD(self: *const T, psz_value_name_: ?[*:0]const u16, pdw_value_: ?*u32) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).GetDWORD(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_, pdw_value_);
            }
            pub inline fn openKey(self: *const T, psz_sub_key_name_: ?[*:0]const u16, pp_sub_key_: ?*?*ISpDataKey) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).OpenKey(@as(*const ISpDataKey, @ptrCast(self)), psz_sub_key_name_, pp_sub_key_);
            }
            pub inline fn createKey(self: *const T, psz_sub_key_: ?[*:0]const u16, pp_sub_key_: ?*?*ISpDataKey) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).CreateKey(@as(*const ISpDataKey, @ptrCast(self)), psz_sub_key_, pp_sub_key_);
            }
            pub inline fn deleteKey(self: *const T, psz_sub_key_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).DeleteKey(@as(*const ISpDataKey, @ptrCast(self)), psz_sub_key_);
            }
            pub inline fn deleteValue(self: *const T, psz_value_name_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).DeleteValue(@as(*const ISpDataKey, @ptrCast(self)), psz_value_name_);
            }
            pub inline fn enumKeys(self: *const T, index_: u32, ppsz_sub_key_name_: ?*?PWSTR) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).EnumKeys(@as(*const ISpDataKey, @ptrCast(self)), index_, ppsz_sub_key_name_);
            }
            pub inline fn enumValues(self: *const T, index_: u32, ppsz_value_name_: ?*?PWSTR) HRESULT {
                return @as(*const ISpDataKey.VTable, @ptrCast(self.vtable)).EnumValues(@as(*const ISpDataKey, @ptrCast(self)), index_, ppsz_value_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRegDataKey_Value = Guid.initString("92a66e2b-c830-4149-83df-6fc2ba1e7a5b");
pub const IID_ISpRegDataKey = &IID_ISpRegDataKey_Value;
pub const ISpRegDataKey = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetKey: *const fn (
            self: *const ISpRegDataKey,
            hkey: ?HKEY,
            f_read_only: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpDataKey.MethodMixin(T);
            pub inline fn setKey(self: *const T, hkey_: ?HKEY, f_read_only_: BOOL) HRESULT {
                return @as(*const ISpRegDataKey.VTable, @ptrCast(self.vtable)).SetKey(@as(*const ISpRegDataKey, @ptrCast(self)), hkey_, f_read_only_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectTokenCategory_Value = Guid.initString("2d3d3845-39af-4850-bbf9-40b49780011d");
pub const IID_ISpObjectTokenCategory = &IID_ISpObjectTokenCategory_Value;
pub const ISpObjectTokenCategory = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetId: *const fn (
            self: *const ISpObjectTokenCategory,
            psz_category_id: ?[*:0]const u16,
            f_create_if_not_exist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetId: *const fn (
            self: *const ISpObjectTokenCategory,
            ppsz_co_mem_category_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataKey: *const fn (
            self: *const ISpObjectTokenCategory,
            spdkl: SPDATAKEYLOCATION,
            pp_data_key: ?*?*ISpDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTokens: *const fn (
            self: *const ISpObjectTokenCategory,
            pzs_req_attribs: ?[*:0]const u16,
            psz_opt_attribs: ?[*:0]const u16,
            pp_enum: ?*?*IEnumSpObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTokenId: *const fn (
            self: *const ISpObjectTokenCategory,
            psz_token_id: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTokenId: *const fn (
            self: *const ISpObjectTokenCategory,
            ppsz_co_mem_token_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpDataKey.MethodMixin(T);
            pub inline fn setId(self: *const T, psz_category_id_: ?[*:0]const u16, f_create_if_not_exist_: BOOL) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).SetId(@as(*const ISpObjectTokenCategory, @ptrCast(self)), psz_category_id_, f_create_if_not_exist_);
            }
            pub inline fn getId(self: *const T, ppsz_co_mem_category_id_: ?*?PWSTR) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).GetId(@as(*const ISpObjectTokenCategory, @ptrCast(self)), ppsz_co_mem_category_id_);
            }
            pub inline fn getDataKey(self: *const T, spdkl_: SPDATAKEYLOCATION, pp_data_key_: ?*?*ISpDataKey) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).GetDataKey(@as(*const ISpObjectTokenCategory, @ptrCast(self)), spdkl_, pp_data_key_);
            }
            pub inline fn enumTokens(self: *const T, pzs_req_attribs_: ?[*:0]const u16, psz_opt_attribs_: ?[*:0]const u16, pp_enum_: ?*?*IEnumSpObjectTokens) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).EnumTokens(@as(*const ISpObjectTokenCategory, @ptrCast(self)), pzs_req_attribs_, psz_opt_attribs_, pp_enum_);
            }
            pub inline fn setDefaultTokenId(self: *const T, psz_token_id_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).SetDefaultTokenId(@as(*const ISpObjectTokenCategory, @ptrCast(self)), psz_token_id_);
            }
            pub inline fn getDefaultTokenId(self: *const T, ppsz_co_mem_token_id_: ?*?PWSTR) HRESULT {
                return @as(*const ISpObjectTokenCategory.VTable, @ptrCast(self.vtable)).GetDefaultTokenId(@as(*const ISpObjectTokenCategory, @ptrCast(self)), ppsz_co_mem_token_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectToken_Value = Guid.initString("14056589-e16c-11d2-bb90-00c04f8ee6c0");
pub const IID_ISpObjectToken = &IID_ISpObjectToken_Value;
pub const ISpObjectToken = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetId: *const fn (
            self: *const ISpObjectToken,
            psz_category_id: ?[*:0]const u16,
            psz_token_id: ?[*:0]const u16,
            f_create_if_not_exist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetId: *const fn (
            self: *const ISpObjectToken,
            ppsz_co_mem_token_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: *const fn (
            self: *const ISpObjectToken,
            pp_token_category: ?*?*ISpObjectTokenCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: *const fn (
            self: *const ISpObjectToken,
            p_unk_outer: ?*IUnknown,
            dw_cls_context: u32,
            riid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStorageFileName: *const fn (
            self: *const ISpObjectToken,
            clsid_caller: ?*const Guid,
            psz_value_name: ?[*:0]const u16,
            psz_file_name_specifier: ?[*:0]const u16,
            n_folder: u32,
            ppsz_file_path: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStorageFileName: *const fn (
            self: *const ISpObjectToken,
            clsid_caller: ?*const Guid,
            psz_key_name: ?[*:0]const u16,
            f_delete_file: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const ISpObjectToken,
            pclsid_caller: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUISupported: *const fn (
            self: *const ISpObjectToken,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
            punk_object: ?*IUnknown,
            pf_supported: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpObjectToken,
            hwnd_parent: ?HWND,
            psz_title: ?[*:0]const u16,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
            punk_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MatchesAttributes: *const fn (
            self: *const ISpObjectToken,
            psz_attributes: ?[*:0]const u16,
            pf_matches: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpDataKey.MethodMixin(T);
            pub inline fn setId(self: *const T, psz_category_id_: ?[*:0]const u16, psz_token_id_: ?[*:0]const u16, f_create_if_not_exist_: BOOL) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).SetId(@as(*const ISpObjectToken, @ptrCast(self)), psz_category_id_, psz_token_id_, f_create_if_not_exist_);
            }
            pub inline fn getId(self: *const T, ppsz_co_mem_token_id_: ?*?PWSTR) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).GetId(@as(*const ISpObjectToken, @ptrCast(self)), ppsz_co_mem_token_id_);
            }
            pub inline fn getCategory(self: *const T, pp_token_category_: ?*?*ISpObjectTokenCategory) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).GetCategory(@as(*const ISpObjectToken, @ptrCast(self)), pp_token_category_);
            }
            pub inline fn createInstance(self: *const T, p_unk_outer_: ?*IUnknown, dw_cls_context_: u32, riid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const ISpObjectToken, @ptrCast(self)), p_unk_outer_, dw_cls_context_, riid_, ppv_object_);
            }
            pub inline fn getStorageFileName(self: *const T, clsid_caller_: ?*const Guid, psz_value_name_: ?[*:0]const u16, psz_file_name_specifier_: ?[*:0]const u16, n_folder_: u32, ppsz_file_path_: ?*?PWSTR) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).GetStorageFileName(@as(*const ISpObjectToken, @ptrCast(self)), clsid_caller_, psz_value_name_, psz_file_name_specifier_, n_folder_, ppsz_file_path_);
            }
            pub inline fn removeStorageFileName(self: *const T, clsid_caller_: ?*const Guid, psz_key_name_: ?[*:0]const u16, f_delete_file_: BOOL) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).RemoveStorageFileName(@as(*const ISpObjectToken, @ptrCast(self)), clsid_caller_, psz_key_name_, f_delete_file_);
            }
            pub inline fn remove(self: *const T, pclsid_caller_: ?*const Guid) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).Remove(@as(*const ISpObjectToken, @ptrCast(self)), pclsid_caller_);
            }
            pub inline fn isUISupported(self: *const T, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32, punk_object_: ?*IUnknown, pf_supported_: ?*BOOL) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpObjectToken, @ptrCast(self)), psz_type_of_u_i_, pv_extra_data_, cb_extra_data_, punk_object_, pf_supported_);
            }
            pub inline fn displayUI(self: *const T, hwnd_parent_: ?HWND, psz_title_: ?[*:0]const u16, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32, punk_object_: ?*IUnknown) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpObjectToken, @ptrCast(self)), hwnd_parent_, psz_title_, psz_type_of_u_i_, pv_extra_data_, cb_extra_data_, punk_object_);
            }
            pub inline fn matchesAttributes(self: *const T, psz_attributes_: ?[*:0]const u16, pf_matches_: ?*BOOL) HRESULT {
                return @as(*const ISpObjectToken.VTable, @ptrCast(self.vtable)).MatchesAttributes(@as(*const ISpObjectToken, @ptrCast(self)), psz_attributes_, pf_matches_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectTokenInit_Value = Guid.initString("b8aab0cf-346f-49d8-9499-c8b03f161d51");
pub const IID_ISpObjectTokenInit = &IID_ISpObjectTokenInit_Value;
pub const ISpObjectTokenInit = extern struct {
    pub const VTable = extern struct {
        base: ISpObjectToken.VTable,
        InitFromDataKey: *const fn (
            self: *const ISpObjectTokenInit,
            psz_category_id: ?[*:0]const u16,
            psz_token_id: ?[*:0]const u16,
            p_data_key: ?*ISpDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpObjectToken.MethodMixin(T);
            pub inline fn initFromDataKey(self: *const T, psz_category_id_: ?[*:0]const u16, psz_token_id_: ?[*:0]const u16, p_data_key_: ?*ISpDataKey) HRESULT {
                return @as(*const ISpObjectTokenInit.VTable, @ptrCast(self.vtable)).InitFromDataKey(@as(*const ISpObjectTokenInit, @ptrCast(self)), psz_category_id_, psz_token_id_, p_data_key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSpObjectTokens_Value = Guid.initString("06b64f9e-7fda-11d2-b4f2-00c04f797396");
pub const IID_IEnumSpObjectTokens = &IID_IEnumSpObjectTokens_Value;
pub const IEnumSpObjectTokens = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSpObjectTokens,
            celt: u32,
            pelt: ?*?*ISpObjectToken,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumSpObjectTokens,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumSpObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumSpObjectTokens,
            pp_enum: ?*?*IEnumSpObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const IEnumSpObjectTokens,
            index: u32,
            pp_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: *const fn (
            self: *const IEnumSpObjectTokens,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, pelt_: ?*?*ISpObjectToken, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSpObjectTokens, @ptrCast(self)), celt_, pelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSpObjectTokens, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSpObjectTokens, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumSpObjectTokens) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSpObjectTokens, @ptrCast(self)), pp_enum_);
            }
            pub inline fn item(self: *const T, index_: u32, pp_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).Item(@as(*const IEnumSpObjectTokens, @ptrCast(self)), index_, pp_token_);
            }
            pub inline fn getCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const IEnumSpObjectTokens.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumSpObjectTokens, @ptrCast(self)), p_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectWithToken_Value = Guid.initString("5b559f40-e952-11d2-bb91-00c04f8ee6c0");
pub const IID_ISpObjectWithToken = &IID_ISpObjectWithToken_Value;
pub const ISpObjectWithToken = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetObjectToken: *const fn (
            self: *const ISpObjectWithToken,
            p_token: ?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectToken: *const fn (
            self: *const ISpObjectWithToken,
            pp_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setObjectToken(self: *const T, p_token_: ?*ISpObjectToken) HRESULT {
                return @as(*const ISpObjectWithToken.VTable, @ptrCast(self.vtable)).SetObjectToken(@as(*const ISpObjectWithToken, @ptrCast(self)), p_token_);
            }
            pub inline fn getObjectToken(self: *const T, pp_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpObjectWithToken.VTable, @ptrCast(self.vtable)).GetObjectToken(@as(*const ISpObjectWithToken, @ptrCast(self)), pp_token_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpResourceManager_Value = Guid.initString("93384e18-5014-43d5-adbb-a78e055926bd");
pub const IID_ISpResourceManager = &IID_ISpResourceManager_Value;
pub const ISpResourceManager = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        SetObject: *const fn (
            self: *const ISpResourceManager,
            guid_service_id: ?*const Guid,
            p_unk_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: *const fn (
            self: *const ISpResourceManager,
            guid_service_id: ?*const Guid,
            object_c_l_s_i_d: ?*const Guid,
            object_i_i_d: ?*const Guid,
            f_release_when_last_external_ref_released: BOOL,
            pp_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IServiceProvider.MethodMixin(T);
            pub inline fn setObject(self: *const T, guid_service_id_: ?*const Guid, p_unk_object_: ?*IUnknown) HRESULT {
                return @as(*const ISpResourceManager.VTable, @ptrCast(self.vtable)).SetObject(@as(*const ISpResourceManager, @ptrCast(self)), guid_service_id_, p_unk_object_);
            }
            pub inline fn getObject(self: *const T, guid_service_id_: ?*const Guid, object_c_l_s_i_d_: ?*const Guid, object_i_i_d_: ?*const Guid, f_release_when_last_external_ref_released_: BOOL, pp_object_: ?*?*anyopaque) HRESULT {
                return @as(*const ISpResourceManager.VTable, @ptrCast(self.vtable)).GetObject(@as(*const ISpResourceManager, @ptrCast(self)), guid_service_id_, object_c_l_s_i_d_, object_i_i_d_, f_release_when_last_external_ref_released_, pp_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPEVENTLPARAMTYPE = enum(i32) {
    UNDEFINED = 0,
    TOKEN = 1,
    OBJECT = 2,
    POINTER = 3,
    STRING = 4,
};
pub const SPET_LPARAM_IS_UNDEFINED = SPEVENTLPARAMTYPE.UNDEFINED;
pub const SPET_LPARAM_IS_TOKEN = SPEVENTLPARAMTYPE.TOKEN;
pub const SPET_LPARAM_IS_OBJECT = SPEVENTLPARAMTYPE.OBJECT;
pub const SPET_LPARAM_IS_POINTER = SPEVENTLPARAMTYPE.POINTER;
pub const SPET_LPARAM_IS_STRING = SPEVENTLPARAMTYPE.STRING;

pub const SPEVENTENUM = enum(i32) {
    UNDEFINED = 0,
    START_INPUT_STREAM = 1,
    END_INPUT_STREAM = 2,
    VOICE_CHANGE = 3,
    TTS_BOOKMARK = 4,
    WORD_BOUNDARY = 5,
    PHONEME = 6,
    SENTENCE_BOUNDARY = 7,
    VISEME = 8,
    TTS_AUDIO_LEVEL = 9,
    TTS_PRIVATE = 15,
    // MIN_TTS = 1, this enum value conflicts with START_INPUT_STREAM
    // MAX_TTS = 15, this enum value conflicts with TTS_PRIVATE
    END_SR_STREAM = 34,
    SOUND_START = 35,
    SOUND_END = 36,
    PHRASE_START = 37,
    RECOGNITION = 38,
    HYPOTHESIS = 39,
    SR_BOOKMARK = 40,
    PROPERTY_NUM_CHANGE = 41,
    PROPERTY_STRING_CHANGE = 42,
    FALSE_RECOGNITION = 43,
    INTERFERENCE = 44,
    REQUEST_UI = 45,
    RECO_STATE_CHANGE = 46,
    ADAPTATION = 47,
    START_SR_STREAM = 48,
    RECO_OTHER_CONTEXT = 49,
    SR_AUDIO_LEVEL = 50,
    SR_RETAINEDAUDIO = 51,
    SR_PRIVATE = 52,
    RESERVED4 = 53,
    RESERVED5 = 54,
    RESERVED6 = 55,
    // MIN_SR = 34, this enum value conflicts with END_SR_STREAM
    // MAX_SR = 55, this enum value conflicts with RESERVED6
    RESERVED1 = 30,
    RESERVED2 = 33,
    RESERVED3 = 63,
};
pub const SPEI_UNDEFINED = SPEVENTENUM.UNDEFINED;
pub const SPEI_START_INPUT_STREAM = SPEVENTENUM.START_INPUT_STREAM;
pub const SPEI_END_INPUT_STREAM = SPEVENTENUM.END_INPUT_STREAM;
pub const SPEI_VOICE_CHANGE = SPEVENTENUM.VOICE_CHANGE;
pub const SPEI_TTS_BOOKMARK = SPEVENTENUM.TTS_BOOKMARK;
pub const SPEI_WORD_BOUNDARY = SPEVENTENUM.WORD_BOUNDARY;
pub const SPEI_PHONEME = SPEVENTENUM.PHONEME;
pub const SPEI_SENTENCE_BOUNDARY = SPEVENTENUM.SENTENCE_BOUNDARY;
pub const SPEI_VISEME = SPEVENTENUM.VISEME;
pub const SPEI_TTS_AUDIO_LEVEL = SPEVENTENUM.TTS_AUDIO_LEVEL;
pub const SPEI_TTS_PRIVATE = SPEVENTENUM.TTS_PRIVATE;
pub const SPEI_MIN_TTS = SPEVENTENUM.START_INPUT_STREAM;
pub const SPEI_MAX_TTS = SPEVENTENUM.TTS_PRIVATE;
pub const SPEI_END_SR_STREAM = SPEVENTENUM.END_SR_STREAM;
pub const SPEI_SOUND_START = SPEVENTENUM.SOUND_START;
pub const SPEI_SOUND_END = SPEVENTENUM.SOUND_END;
pub const SPEI_PHRASE_START = SPEVENTENUM.PHRASE_START;
pub const SPEI_RECOGNITION = SPEVENTENUM.RECOGNITION;
pub const SPEI_HYPOTHESIS = SPEVENTENUM.HYPOTHESIS;
pub const SPEI_SR_BOOKMARK = SPEVENTENUM.SR_BOOKMARK;
pub const SPEI_PROPERTY_NUM_CHANGE = SPEVENTENUM.PROPERTY_NUM_CHANGE;
pub const SPEI_PROPERTY_STRING_CHANGE = SPEVENTENUM.PROPERTY_STRING_CHANGE;
pub const SPEI_FALSE_RECOGNITION = SPEVENTENUM.FALSE_RECOGNITION;
pub const SPEI_INTERFERENCE = SPEVENTENUM.INTERFERENCE;
pub const SPEI_REQUEST_UI = SPEVENTENUM.REQUEST_UI;
pub const SPEI_RECO_STATE_CHANGE = SPEVENTENUM.RECO_STATE_CHANGE;
pub const SPEI_ADAPTATION = SPEVENTENUM.ADAPTATION;
pub const SPEI_START_SR_STREAM = SPEVENTENUM.START_SR_STREAM;
pub const SPEI_RECO_OTHER_CONTEXT = SPEVENTENUM.RECO_OTHER_CONTEXT;
pub const SPEI_SR_AUDIO_LEVEL = SPEVENTENUM.SR_AUDIO_LEVEL;
pub const SPEI_SR_RETAINEDAUDIO = SPEVENTENUM.SR_RETAINEDAUDIO;
pub const SPEI_SR_PRIVATE = SPEVENTENUM.SR_PRIVATE;
pub const SPEI_RESERVED4 = SPEVENTENUM.RESERVED4;
pub const SPEI_RESERVED5 = SPEVENTENUM.RESERVED5;
pub const SPEI_RESERVED6 = SPEVENTENUM.RESERVED6;
pub const SPEI_MIN_SR = SPEVENTENUM.END_SR_STREAM;
pub const SPEI_MAX_SR = SPEVENTENUM.RESERVED6;
pub const SPEI_RESERVED1 = SPEVENTENUM.RESERVED1;
pub const SPEI_RESERVED2 = SPEVENTENUM.RESERVED2;
pub const SPEI_RESERVED3 = SPEVENTENUM.RESERVED3;

pub const SPEVENT = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const SPSERIALIZEDEVENT = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    SerializedwParam: u32,
    SerializedlParam: i32,
};

pub const SPSERIALIZEDEVENT64 = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    SerializedwParam: u64,
    SerializedlParam: i64,
};

pub const SPEVENTEX = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    wParam: WPARAM,
    lParam: LPARAM,
    ullAudioTimeOffset: u64,
};

pub const SPINTERFERENCE = enum(i32) {
    NONE = 0,
    NOISE = 1,
    NOSIGNAL = 2,
    TOOLOUD = 3,
    TOOQUIET = 4,
    TOOFAST = 5,
    TOOSLOW = 6,
    LATENCY_WARNING = 7,
    LATENCY_TRUNCATE_BEGIN = 8,
    LATENCY_TRUNCATE_END = 9,
};
pub const SPINTERFERENCE_NONE = SPINTERFERENCE.NONE;
pub const SPINTERFERENCE_NOISE = SPINTERFERENCE.NOISE;
pub const SPINTERFERENCE_NOSIGNAL = SPINTERFERENCE.NOSIGNAL;
pub const SPINTERFERENCE_TOOLOUD = SPINTERFERENCE.TOOLOUD;
pub const SPINTERFERENCE_TOOQUIET = SPINTERFERENCE.TOOQUIET;
pub const SPINTERFERENCE_TOOFAST = SPINTERFERENCE.TOOFAST;
pub const SPINTERFERENCE_TOOSLOW = SPINTERFERENCE.TOOSLOW;
pub const SPINTERFERENCE_LATENCY_WARNING = SPINTERFERENCE.LATENCY_WARNING;
pub const SPINTERFERENCE_LATENCY_TRUNCATE_BEGIN = SPINTERFERENCE.LATENCY_TRUNCATE_BEGIN;
pub const SPINTERFERENCE_LATENCY_TRUNCATE_END = SPINTERFERENCE.LATENCY_TRUNCATE_END;

pub const SPENDSRSTREAMFLAGS = enum(i32) {
    NONE = 0,
    STREAM_RELEASED = 1,
    EMULATED = 2,
};
pub const SPESF_NONE = SPENDSRSTREAMFLAGS.NONE;
pub const SPESF_STREAM_RELEASED = SPENDSRSTREAMFLAGS.STREAM_RELEASED;
pub const SPESF_EMULATED = SPENDSRSTREAMFLAGS.EMULATED;

pub const SPVFEATURE = enum(i32) {
    STRESSED = 1,
    EMPHASIS = 2,
};
pub const SPVFEATURE_STRESSED = SPVFEATURE.STRESSED;
pub const SPVFEATURE_EMPHASIS = SPVFEATURE.EMPHASIS;

pub const SPVISEMES = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
};
pub const SP_VISEME_0 = SPVISEMES.@"0";
pub const SP_VISEME_1 = SPVISEMES.@"1";
pub const SP_VISEME_2 = SPVISEMES.@"2";
pub const SP_VISEME_3 = SPVISEMES.@"3";
pub const SP_VISEME_4 = SPVISEMES.@"4";
pub const SP_VISEME_5 = SPVISEMES.@"5";
pub const SP_VISEME_6 = SPVISEMES.@"6";
pub const SP_VISEME_7 = SPVISEMES.@"7";
pub const SP_VISEME_8 = SPVISEMES.@"8";
pub const SP_VISEME_9 = SPVISEMES.@"9";
pub const SP_VISEME_10 = SPVISEMES.@"10";
pub const SP_VISEME_11 = SPVISEMES.@"11";
pub const SP_VISEME_12 = SPVISEMES.@"12";
pub const SP_VISEME_13 = SPVISEMES.@"13";
pub const SP_VISEME_14 = SPVISEMES.@"14";
pub const SP_VISEME_15 = SPVISEMES.@"15";
pub const SP_VISEME_16 = SPVISEMES.@"16";
pub const SP_VISEME_17 = SPVISEMES.@"17";
pub const SP_VISEME_18 = SPVISEMES.@"18";
pub const SP_VISEME_19 = SPVISEMES.@"19";
pub const SP_VISEME_20 = SPVISEMES.@"20";
pub const SP_VISEME_21 = SPVISEMES.@"21";

pub const SPEVENTSOURCEINFO = extern struct {
    ullEventInterest: u64,
    ullQueuedInterest: u64,
    ulCount: u32,
};

const IID_ISpEventSource_Value = Guid.initString("be7a9cce-5f9e-11d2-960f-00c04f8ee628");
pub const IID_ISpEventSource = &IID_ISpEventSource_Value;
pub const ISpEventSource = extern struct {
    pub const VTable = extern struct {
        base: ISpNotifySource.VTable,
        SetInterest: *const fn (
            self: *const ISpEventSource,
            ull_event_interest: u64,
            ull_queued_interest: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvents: *const fn (
            self: *const ISpEventSource,
            ul_count: u32,
            p_event_array: ?*SPEVENT,
            pul_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: *const fn (
            self: *const ISpEventSource,
            p_info: ?*SPEVENTSOURCEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpNotifySource.MethodMixin(T);
            pub inline fn setInterest(self: *const T, ull_event_interest_: u64, ull_queued_interest_: u64) HRESULT {
                return @as(*const ISpEventSource.VTable, @ptrCast(self.vtable)).SetInterest(@as(*const ISpEventSource, @ptrCast(self)), ull_event_interest_, ull_queued_interest_);
            }
            pub inline fn getEvents(self: *const T, ul_count_: u32, p_event_array_: ?*SPEVENT, pul_fetched_: ?*u32) HRESULT {
                return @as(*const ISpEventSource.VTable, @ptrCast(self.vtable)).GetEvents(@as(*const ISpEventSource, @ptrCast(self)), ul_count_, p_event_array_, pul_fetched_);
            }
            pub inline fn getInfo(self: *const T, p_info_: ?*SPEVENTSOURCEINFO) HRESULT {
                return @as(*const ISpEventSource.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ISpEventSource, @ptrCast(self)), p_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpEventSource2_Value = Guid.initString("2373a435-6a4b-429e-a6ac-d4231a61975b");
pub const IID_ISpEventSource2 = &IID_ISpEventSource2_Value;
pub const ISpEventSource2 = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        GetEventsEx: *const fn (
            self: *const ISpEventSource2,
            ul_count: u32,
            p_event_array: ?*SPEVENTEX,
            pul_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpEventSource.MethodMixin(T);
            pub inline fn getEventsEx(self: *const T, ul_count_: u32, p_event_array_: ?*SPEVENTEX, pul_fetched_: ?*u32) HRESULT {
                return @as(*const ISpEventSource2.VTable, @ptrCast(self.vtable)).GetEventsEx(@as(*const ISpEventSource2, @ptrCast(self)), ul_count_, p_event_array_, pul_fetched_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpEventSink_Value = Guid.initString("be7a9cc9-5f9e-11d2-960f-00c04f8ee628");
pub const IID_ISpEventSink = &IID_ISpEventSink_Value;
pub const ISpEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddEvents: *const fn (
            self: *const ISpEventSink,
            p_event_array: ?*const SPEVENT,
            ul_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventInterest: *const fn (
            self: *const ISpEventSink,
            pull_event_interest: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addEvents(self: *const T, p_event_array_: ?*const SPEVENT, ul_count_: u32) HRESULT {
                return @as(*const ISpEventSink.VTable, @ptrCast(self.vtable)).AddEvents(@as(*const ISpEventSink, @ptrCast(self)), p_event_array_, ul_count_);
            }
            pub inline fn getEventInterest(self: *const T, pull_event_interest_: ?*u64) HRESULT {
                return @as(*const ISpEventSink.VTable, @ptrCast(self.vtable)).GetEventInterest(@as(*const ISpEventSink, @ptrCast(self)), pull_event_interest_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpStreamFormat_Value = Guid.initString("bed530be-2606-4f4d-a1c0-54c5cda5566f");
pub const IID_ISpStreamFormat = &IID_ISpStreamFormat_Value;
pub const ISpStreamFormat = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        GetFormat: *const fn (
            self: *const ISpStreamFormat,
            pguid_format_id: ?*Guid,
            pp_co_mem_wave_format_ex: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStream.MethodMixin(T);
            pub inline fn getFormat(self: *const T, pguid_format_id_: ?*Guid, pp_co_mem_wave_format_ex_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const ISpStreamFormat.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const ISpStreamFormat, @ptrCast(self)), pguid_format_id_, pp_co_mem_wave_format_ex_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPFILEMODE = enum(i32) {
    OPEN_READONLY = 0,
    OPEN_READWRITE = 1,
    CREATE = 2,
    CREATE_ALWAYS = 3,
    NUM_MODES = 4,
};
pub const SPFM_OPEN_READONLY = SPFILEMODE.OPEN_READONLY;
pub const SPFM_OPEN_READWRITE = SPFILEMODE.OPEN_READWRITE;
pub const SPFM_CREATE = SPFILEMODE.CREATE;
pub const SPFM_CREATE_ALWAYS = SPFILEMODE.CREATE_ALWAYS;
pub const SPFM_NUM_MODES = SPFILEMODE.NUM_MODES;

const IID_ISpStream_Value = Guid.initString("12e3cca9-7518-44c5-a5e7-ba5a79cb929e");
pub const IID_ISpStream = &IID_ISpStream_Value;
pub const ISpStream = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetBaseStream: *const fn (
            self: *const ISpStream,
            p_stream: ?*IStream,
            rguid_format: ?*const Guid,
            p_wave_format_ex: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseStream: *const fn (
            self: *const ISpStream,
            pp_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToFile: *const fn (
            self: *const ISpStream,
            psz_file_name: ?[*:0]const u16,
            e_mode: SPFILEMODE,
            p_format_id: ?*const Guid,
            p_wave_format_ex: ?*const WAVEFORMATEX,
            ull_event_interest: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const ISpStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpStreamFormat.MethodMixin(T);
            pub inline fn setBaseStream(self: *const T, p_stream_: ?*IStream, rguid_format_: ?*const Guid, p_wave_format_ex_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpStream.VTable, @ptrCast(self.vtable)).SetBaseStream(@as(*const ISpStream, @ptrCast(self)), p_stream_, rguid_format_, p_wave_format_ex_);
            }
            pub inline fn getBaseStream(self: *const T, pp_stream_: ?*?*IStream) HRESULT {
                return @as(*const ISpStream.VTable, @ptrCast(self.vtable)).GetBaseStream(@as(*const ISpStream, @ptrCast(self)), pp_stream_);
            }
            pub inline fn bindToFile(self: *const T, psz_file_name_: ?[*:0]const u16, e_mode_: SPFILEMODE, p_format_id_: ?*const Guid, p_wave_format_ex_: ?*const WAVEFORMATEX, ull_event_interest_: u64) HRESULT {
                return @as(*const ISpStream.VTable, @ptrCast(self.vtable)).BindToFile(@as(*const ISpStream, @ptrCast(self)), psz_file_name_, e_mode_, p_format_id_, p_wave_format_ex_, ull_event_interest_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const ISpStream.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpStream, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpStreamFormatConverter_Value = Guid.initString("678a932c-ea71-4446-9b41-78fda6280a29");
pub const IID_ISpStreamFormatConverter = &IID_ISpStreamFormatConverter_Value;
pub const ISpStreamFormatConverter = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetBaseStream: *const fn (
            self: *const ISpStreamFormatConverter,
            p_stream: ?*ISpStreamFormat,
            f_set_format_to_base_stream_format: BOOL,
            f_write_to_base_stream: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseStream: *const fn (
            self: *const ISpStreamFormatConverter,
            pp_stream: ?*?*ISpStreamFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const ISpStreamFormatConverter,
            rguid_format_id_of_converted_stream: ?*const Guid,
            p_wave_format_ex_of_converted_stream: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSeekPosition: *const fn (
            self: *const ISpStreamFormatConverter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScaleConvertedToBaseOffset: *const fn (
            self: *const ISpStreamFormatConverter,
            ull_offset_converted_stream: u64,
            pull_offset_base_stream: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScaleBaseToConvertedOffset: *const fn (
            self: *const ISpStreamFormatConverter,
            ull_offset_base_stream: u64,
            pull_offset_converted_stream: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpStreamFormat.MethodMixin(T);
            pub inline fn setBaseStream(self: *const T, p_stream_: ?*ISpStreamFormat, f_set_format_to_base_stream_format_: BOOL, f_write_to_base_stream_: BOOL) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).SetBaseStream(@as(*const ISpStreamFormatConverter, @ptrCast(self)), p_stream_, f_set_format_to_base_stream_format_, f_write_to_base_stream_);
            }
            pub inline fn getBaseStream(self: *const T, pp_stream_: ?*?*ISpStreamFormat) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).GetBaseStream(@as(*const ISpStreamFormatConverter, @ptrCast(self)), pp_stream_);
            }
            pub inline fn setFormat(self: *const T, rguid_format_id_of_converted_stream_: ?*const Guid, p_wave_format_ex_of_converted_stream_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const ISpStreamFormatConverter, @ptrCast(self)), rguid_format_id_of_converted_stream_, p_wave_format_ex_of_converted_stream_);
            }
            pub inline fn resetSeekPosition(self: *const T) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).ResetSeekPosition(@as(*const ISpStreamFormatConverter, @ptrCast(self)));
            }
            pub inline fn scaleConvertedToBaseOffset(self: *const T, ull_offset_converted_stream_: u64, pull_offset_base_stream_: ?*u64) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).ScaleConvertedToBaseOffset(@as(*const ISpStreamFormatConverter, @ptrCast(self)), ull_offset_converted_stream_, pull_offset_base_stream_);
            }
            pub inline fn scaleBaseToConvertedOffset(self: *const T, ull_offset_base_stream_: u64, pull_offset_converted_stream_: ?*u64) HRESULT {
                return @as(*const ISpStreamFormatConverter.VTable, @ptrCast(self.vtable)).ScaleBaseToConvertedOffset(@as(*const ISpStreamFormatConverter, @ptrCast(self)), ull_offset_base_stream_, pull_offset_converted_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPAUDIOSTATE = enum(i32) {
    CLOSED = 0,
    STOP = 1,
    PAUSE = 2,
    RUN = 3,
};
pub const SPAS_CLOSED = SPAUDIOSTATE.CLOSED;
pub const SPAS_STOP = SPAUDIOSTATE.STOP;
pub const SPAS_PAUSE = SPAUDIOSTATE.PAUSE;
pub const SPAS_RUN = SPAUDIOSTATE.RUN;

pub const SPAUDIOSTATUS = extern struct {
    cbFreeBuffSpace: i32,
    cbNonBlockingIO: u32,
    State: SPAUDIOSTATE,
    CurSeekPos: u64,
    CurDevicePos: u64,
    dwAudioLevel: u32,
    dwReserved2: u32,
};

pub const SPAUDIOBUFFERINFO = extern struct {
    ulMsMinNotification: u32,
    ulMsBufferSize: u32,
    ulMsEventBias: u32,
};

const IID_ISpAudio_Value = Guid.initString("c05c768f-fae8-4ec2-8e07-338321c12452");
pub const IID_ISpAudio = &IID_ISpAudio_Value;
pub const ISpAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetState: *const fn (
            self: *const ISpAudio,
            new_state: SPAUDIOSTATE,
            ull_reserved: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const ISpAudio,
            rguid_fmt_id: ?*const Guid,
            p_wave_format_ex: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ISpAudio,
            p_status: ?*SPAUDIOSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBufferInfo: *const fn (
            self: *const ISpAudio,
            p_buff_info: ?*const SPAUDIOBUFFERINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferInfo: *const fn (
            self: *const ISpAudio,
            p_buff_info: ?*SPAUDIOBUFFERINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultFormat: *const fn (
            self: *const ISpAudio,
            p_format_id: ?*Guid,
            pp_co_mem_wave_format_ex: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EventHandle: *const fn (
            self: *const ISpAudio,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        GetVolumeLevel: *const fn (
            self: *const ISpAudio,
            p_level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVolumeLevel: *const fn (
            self: *const ISpAudio,
            level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferNotifySize: *const fn (
            self: *const ISpAudio,
            pcb_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBufferNotifySize: *const fn (
            self: *const ISpAudio,
            cb_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpStreamFormat.MethodMixin(T);
            pub inline fn setState(self: *const T, new_state_: SPAUDIOSTATE, ull_reserved_: u64) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).SetState(@as(*const ISpAudio, @ptrCast(self)), new_state_, ull_reserved_);
            }
            pub inline fn setFormat(self: *const T, rguid_fmt_id_: ?*const Guid, p_wave_format_ex_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const ISpAudio, @ptrCast(self)), rguid_fmt_id_, p_wave_format_ex_);
            }
            pub inline fn getStatus(self: *const T, p_status_: ?*SPAUDIOSTATUS) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ISpAudio, @ptrCast(self)), p_status_);
            }
            pub inline fn setBufferInfo(self: *const T, p_buff_info_: ?*const SPAUDIOBUFFERINFO) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).SetBufferInfo(@as(*const ISpAudio, @ptrCast(self)), p_buff_info_);
            }
            pub inline fn getBufferInfo(self: *const T, p_buff_info_: ?*SPAUDIOBUFFERINFO) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).GetBufferInfo(@as(*const ISpAudio, @ptrCast(self)), p_buff_info_);
            }
            pub inline fn getDefaultFormat(self: *const T, p_format_id_: ?*Guid, pp_co_mem_wave_format_ex_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).GetDefaultFormat(@as(*const ISpAudio, @ptrCast(self)), p_format_id_, pp_co_mem_wave_format_ex_);
            }
            pub inline fn eventHandle(self: *const T) ?HANDLE {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).EventHandle(@as(*const ISpAudio, @ptrCast(self)));
            }
            pub inline fn getVolumeLevel(self: *const T, p_level_: ?*u32) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).GetVolumeLevel(@as(*const ISpAudio, @ptrCast(self)), p_level_);
            }
            pub inline fn setVolumeLevel(self: *const T, level_: u32) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).SetVolumeLevel(@as(*const ISpAudio, @ptrCast(self)), level_);
            }
            pub inline fn getBufferNotifySize(self: *const T, pcb_size_: ?*u32) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).GetBufferNotifySize(@as(*const ISpAudio, @ptrCast(self)), pcb_size_);
            }
            pub inline fn setBufferNotifySize(self: *const T, cb_size_: u32) HRESULT {
                return @as(*const ISpAudio.VTable, @ptrCast(self.vtable)).SetBufferNotifySize(@as(*const ISpAudio, @ptrCast(self)), cb_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpMMSysAudio_Value = Guid.initString("15806f6e-1d70-4b48-98e6-3b1a007509ab");
pub const IID_ISpMMSysAudio = &IID_ISpMMSysAudio_Value;
pub const ISpMMSysAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpAudio.VTable,
        GetDeviceId: *const fn (
            self: *const ISpMMSysAudio,
            pu_device_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeviceId: *const fn (
            self: *const ISpMMSysAudio,
            u_device_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMMHandle: *const fn (
            self: *const ISpMMSysAudio,
            p_handle: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineId: *const fn (
            self: *const ISpMMSysAudio,
            pu_line_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineId: *const fn (
            self: *const ISpMMSysAudio,
            u_line_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpAudio.MethodMixin(T);
            pub inline fn getDeviceId(self: *const T, pu_device_id_: ?*u32) HRESULT {
                return @as(*const ISpMMSysAudio.VTable, @ptrCast(self.vtable)).GetDeviceId(@as(*const ISpMMSysAudio, @ptrCast(self)), pu_device_id_);
            }
            pub inline fn setDeviceId(self: *const T, u_device_id_: u32) HRESULT {
                return @as(*const ISpMMSysAudio.VTable, @ptrCast(self.vtable)).SetDeviceId(@as(*const ISpMMSysAudio, @ptrCast(self)), u_device_id_);
            }
            pub inline fn getMMHandle(self: *const T, p_handle_: ?*?*anyopaque) HRESULT {
                return @as(*const ISpMMSysAudio.VTable, @ptrCast(self.vtable)).GetMMHandle(@as(*const ISpMMSysAudio, @ptrCast(self)), p_handle_);
            }
            pub inline fn getLineId(self: *const T, pu_line_id_: ?*u32) HRESULT {
                return @as(*const ISpMMSysAudio.VTable, @ptrCast(self.vtable)).GetLineId(@as(*const ISpMMSysAudio, @ptrCast(self)), pu_line_id_);
            }
            pub inline fn setLineId(self: *const T, u_line_id_: u32) HRESULT {
                return @as(*const ISpMMSysAudio.VTable, @ptrCast(self.vtable)).SetLineId(@as(*const ISpMMSysAudio, @ptrCast(self)), u_line_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpTranscript_Value = Guid.initString("10f63bce-201a-11d3-ac70-00c04f8ee6c0");
pub const IID_ISpTranscript = &IID_ISpTranscript_Value;
pub const ISpTranscript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTranscript: *const fn (
            self: *const ISpTranscript,
            ppsz_transcript: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendTranscript: *const fn (
            self: *const ISpTranscript,
            psz_transcript: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTranscript(self: *const T, ppsz_transcript_: ?*?PWSTR) HRESULT {
                return @as(*const ISpTranscript.VTable, @ptrCast(self.vtable)).GetTranscript(@as(*const ISpTranscript, @ptrCast(self)), ppsz_transcript_);
            }
            pub inline fn appendTranscript(self: *const T, psz_transcript_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpTranscript.VTable, @ptrCast(self.vtable)).AppendTranscript(@as(*const ISpTranscript, @ptrCast(self)), psz_transcript_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPDISPLYATTRIBUTES = enum(i32) {
    ONE_TRAILING_SPACE = 2,
    TWO_TRAILING_SPACES = 4,
    CONSUME_LEADING_SPACES = 8,
    BUFFER_POSITION = 16,
    ALL = 31,
    USER_SPECIFIED = 128,
};
pub const SPAF_ONE_TRAILING_SPACE = SPDISPLYATTRIBUTES.ONE_TRAILING_SPACE;
pub const SPAF_TWO_TRAILING_SPACES = SPDISPLYATTRIBUTES.TWO_TRAILING_SPACES;
pub const SPAF_CONSUME_LEADING_SPACES = SPDISPLYATTRIBUTES.CONSUME_LEADING_SPACES;
pub const SPAF_BUFFER_POSITION = SPDISPLYATTRIBUTES.BUFFER_POSITION;
pub const SPAF_ALL = SPDISPLYATTRIBUTES.ALL;
pub const SPAF_USER_SPECIFIED = SPDISPLYATTRIBUTES.USER_SPECIFIED;

pub const SPPHRASEELEMENT = extern struct {
    ulAudioTimeOffset: u32,
    ulAudioSizeTime: u32,
    ulAudioStreamOffset: u32,
    ulAudioSizeBytes: u32,
    ulRetainedStreamOffset: u32,
    ulRetainedSizeBytes: u32,
    pszDisplayText: ?[*:0]const u16,
    pszLexicalForm: ?[*:0]const u16,
    pszPronunciation: ?*const u16,
    bDisplayAttributes: u8,
    RequiredConfidence: i8,
    ActualConfidence: i8,
    Reserved: u8,
    SREngineConfidence: f32,
};

pub const SPPHRASERULE = extern struct {
    pszName: ?[*:0]const u16,
    ulId: u32,
    ulFirstElement: u32,
    ulCountOfElements: u32,
    pNextSibling: ?*const SPPHRASERULE,
    pFirstChild: ?*const SPPHRASERULE,
    SREngineConfidence: f32,
    Confidence: i8,
};

pub const SPPHRASEPROPERTYUNIONTYPE = enum(i32) {
    UNUSED = 0,
    ARRAY_INDEX = 1,
};
pub const SPPPUT_UNUSED = SPPHRASEPROPERTYUNIONTYPE.UNUSED;
pub const SPPPUT_ARRAY_INDEX = SPPHRASEPROPERTYUNIONTYPE.ARRAY_INDEX;

pub const SPPHRASEPROPERTY = extern struct {
    pszName: ?[*:0]const u16,
    Anonymous: extern union {
        ulId: u32,
        Anonymous: extern struct {
            bType: u8,
            bReserved: u8,
            usArrayIndex: u16,
        },
    },
    pszValue: ?[*:0]const u16,
    vValue: VARIANT,
    ulFirstElement: u32,
    ulCountOfElements: u32,
    pNextSibling: ?*const SPPHRASEPROPERTY,
    pFirstChild: ?*const SPPHRASEPROPERTY,
    SREngineConfidence: f32,
    Confidence: i8,
};

pub const SPPHRASEREPLACEMENT = extern struct {
    bDisplayAttributes: u8,
    pszReplacementText: ?[*:0]const u16,
    ulFirstElement: u32,
    ulCountOfElements: u32,
};

pub const SPSEMANTICERRORINFO = extern struct {
    ulLineNumber: u32,
    pszScriptLine: ?PWSTR,
    pszSource: ?PWSTR,
    pszDescription: ?PWSTR,
    hrResultCode: HRESULT,
};

pub const SPSEMANTICFORMAT = enum(i32) {
    SAPI_PROPERTIES = 0,
    SRGS_SEMANTICINTERPRETATION_MS = 1,
    SRGS_SAPIPROPERTIES = 2,
    UPS = 4,
    SRGS_SEMANTICINTERPRETATION_W3C = 8,
};
pub const SPSMF_SAPI_PROPERTIES = SPSEMANTICFORMAT.SAPI_PROPERTIES;
pub const SPSMF_SRGS_SEMANTICINTERPRETATION_MS = SPSEMANTICFORMAT.SRGS_SEMANTICINTERPRETATION_MS;
pub const SPSMF_SRGS_SAPIPROPERTIES = SPSEMANTICFORMAT.SRGS_SAPIPROPERTIES;
pub const SPSMF_UPS = SPSEMANTICFORMAT.UPS;
pub const SPSMF_SRGS_SEMANTICINTERPRETATION_W3C = SPSEMANTICFORMAT.SRGS_SEMANTICINTERPRETATION_W3C;

pub const SPPHRASE_50 = extern struct {
    cbSize: u32,
    LangID: u16,
    wHomophoneGroupId: u16,
    ullGrammarID: u64,
    ftStartTime: u64,
    ullAudioStreamPosition: u64,
    ulAudioSizeBytes: u32,
    ulRetainedSizeBytes: u32,
    ulAudioSizeTime: u32,
    Rule: SPPHRASERULE,
    pProperties: ?*const SPPHRASEPROPERTY,
    pElements: ?*const SPPHRASEELEMENT,
    cReplacements: u32,
    pReplacements: ?*const SPPHRASEREPLACEMENT,
    SREngineID: Guid,
    ulSREnginePrivateDataSize: u32,
    pSREnginePrivateData: ?*const u8,
};

pub const SPPHRASE = extern struct {
    __AnonymousBase_sapi53_L5821_C34: SPPHRASE_50,
    pSML: ?PWSTR,
    pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
};

pub const SPSERIALIZEDPHRASE = extern struct {
    ulSerializedSize: u32,
};

pub const SPRULE = extern struct {
    pszRuleName: ?[*:0]const u16,
    ulRuleId: u32,
    dwAttributes: u32,
};

pub const SPVALUETYPE = enum(i32) {
    PROPERTY = 1,
    REPLACEMENT = 2,
    RULE = 4,
    DISPLAYTEXT = 8,
    LEXICALFORM = 16,
    PRONUNCIATION = 32,
    AUDIO = 64,
    ALTERNATES = 128,
    ALL = 255,
};
pub const SPDF_PROPERTY = SPVALUETYPE.PROPERTY;
pub const SPDF_REPLACEMENT = SPVALUETYPE.REPLACEMENT;
pub const SPDF_RULE = SPVALUETYPE.RULE;
pub const SPDF_DISPLAYTEXT = SPVALUETYPE.DISPLAYTEXT;
pub const SPDF_LEXICALFORM = SPVALUETYPE.LEXICALFORM;
pub const SPDF_PRONUNCIATION = SPVALUETYPE.PRONUNCIATION;
pub const SPDF_AUDIO = SPVALUETYPE.AUDIO;
pub const SPDF_ALTERNATES = SPVALUETYPE.ALTERNATES;
pub const SPDF_ALL = SPVALUETYPE.ALL;

pub const SPBINARYGRAMMAR = extern struct {
    ulTotalSerializedSize: u32,
};

pub const SPPHRASERNG = enum(i32) {
    S = -1,
};
pub const SPPR_ALL_ELEMENTS = SPPHRASERNG.S;

pub const SPSTATEHANDLE__ = extern struct {
    unused: i32,
};

pub const SPRECOEVENTFLAGS = enum(i32) {
    AutoPause = 1,
    Emulated = 2,
    SMLTimeout = 4,
    ExtendableParse = 8,
    ReSent = 16,
    Hypothesis = 32,
    FalseRecognition = 64,
};
pub const SPREF_AutoPause = SPRECOEVENTFLAGS.AutoPause;
pub const SPREF_Emulated = SPRECOEVENTFLAGS.Emulated;
pub const SPREF_SMLTimeout = SPRECOEVENTFLAGS.SMLTimeout;
pub const SPREF_ExtendableParse = SPRECOEVENTFLAGS.ExtendableParse;
pub const SPREF_ReSent = SPRECOEVENTFLAGS.ReSent;
pub const SPREF_Hypothesis = SPRECOEVENTFLAGS.Hypothesis;
pub const SPREF_FalseRecognition = SPRECOEVENTFLAGS.FalseRecognition;

pub const SPPARTOFSPEECH = enum(i32) {
    NotOverriden = -1,
    Unknown = 0,
    Noun = 4096,
    Verb = 8192,
    Modifier = 12288,
    Function = 16384,
    Interjection = 20480,
    Noncontent = 24576,
    LMA = 28672,
    SuppressWord = 61440,
};
pub const SPPS_NotOverriden = SPPARTOFSPEECH.NotOverriden;
pub const SPPS_Unknown = SPPARTOFSPEECH.Unknown;
pub const SPPS_Noun = SPPARTOFSPEECH.Noun;
pub const SPPS_Verb = SPPARTOFSPEECH.Verb;
pub const SPPS_Modifier = SPPARTOFSPEECH.Modifier;
pub const SPPS_Function = SPPARTOFSPEECH.Function;
pub const SPPS_Interjection = SPPARTOFSPEECH.Interjection;
pub const SPPS_Noncontent = SPPARTOFSPEECH.Noncontent;
pub const SPPS_LMA = SPPARTOFSPEECH.LMA;
pub const SPPS_SuppressWord = SPPARTOFSPEECH.SuppressWord;

pub const SPLEXICONTYPE = enum(i32) {
    USER = 1,
    APP = 2,
    VENDORLEXICON = 4,
    LETTERTOSOUND = 8,
    MORPHOLOGY = 16,
    RESERVED4 = 32,
    USER_SHORTCUT = 64,
    RESERVED6 = 128,
    RESERVED7 = 256,
    RESERVED8 = 512,
    RESERVED9 = 1024,
    RESERVED10 = 2048,
    PRIVATE1 = 4096,
    PRIVATE2 = 8192,
    PRIVATE3 = 16384,
    PRIVATE4 = 32768,
    PRIVATE5 = 65536,
    PRIVATE6 = 131072,
    PRIVATE7 = 262144,
    PRIVATE8 = 524288,
    PRIVATE9 = 1048576,
    PRIVATE10 = 2097152,
    PRIVATE11 = 4194304,
    PRIVATE12 = 8388608,
    PRIVATE13 = 16777216,
    PRIVATE14 = 33554432,
    PRIVATE15 = 67108864,
    PRIVATE16 = 134217728,
    PRIVATE17 = 268435456,
    PRIVATE18 = 536870912,
    PRIVATE19 = 1073741824,
    PRIVATE20 = -2147483648,
};
pub const eLEXTYPE_USER = SPLEXICONTYPE.USER;
pub const eLEXTYPE_APP = SPLEXICONTYPE.APP;
pub const eLEXTYPE_VENDORLEXICON = SPLEXICONTYPE.VENDORLEXICON;
pub const eLEXTYPE_LETTERTOSOUND = SPLEXICONTYPE.LETTERTOSOUND;
pub const eLEXTYPE_MORPHOLOGY = SPLEXICONTYPE.MORPHOLOGY;
pub const eLEXTYPE_RESERVED4 = SPLEXICONTYPE.RESERVED4;
pub const eLEXTYPE_USER_SHORTCUT = SPLEXICONTYPE.USER_SHORTCUT;
pub const eLEXTYPE_RESERVED6 = SPLEXICONTYPE.RESERVED6;
pub const eLEXTYPE_RESERVED7 = SPLEXICONTYPE.RESERVED7;
pub const eLEXTYPE_RESERVED8 = SPLEXICONTYPE.RESERVED8;
pub const eLEXTYPE_RESERVED9 = SPLEXICONTYPE.RESERVED9;
pub const eLEXTYPE_RESERVED10 = SPLEXICONTYPE.RESERVED10;
pub const eLEXTYPE_PRIVATE1 = SPLEXICONTYPE.PRIVATE1;
pub const eLEXTYPE_PRIVATE2 = SPLEXICONTYPE.PRIVATE2;
pub const eLEXTYPE_PRIVATE3 = SPLEXICONTYPE.PRIVATE3;
pub const eLEXTYPE_PRIVATE4 = SPLEXICONTYPE.PRIVATE4;
pub const eLEXTYPE_PRIVATE5 = SPLEXICONTYPE.PRIVATE5;
pub const eLEXTYPE_PRIVATE6 = SPLEXICONTYPE.PRIVATE6;
pub const eLEXTYPE_PRIVATE7 = SPLEXICONTYPE.PRIVATE7;
pub const eLEXTYPE_PRIVATE8 = SPLEXICONTYPE.PRIVATE8;
pub const eLEXTYPE_PRIVATE9 = SPLEXICONTYPE.PRIVATE9;
pub const eLEXTYPE_PRIVATE10 = SPLEXICONTYPE.PRIVATE10;
pub const eLEXTYPE_PRIVATE11 = SPLEXICONTYPE.PRIVATE11;
pub const eLEXTYPE_PRIVATE12 = SPLEXICONTYPE.PRIVATE12;
pub const eLEXTYPE_PRIVATE13 = SPLEXICONTYPE.PRIVATE13;
pub const eLEXTYPE_PRIVATE14 = SPLEXICONTYPE.PRIVATE14;
pub const eLEXTYPE_PRIVATE15 = SPLEXICONTYPE.PRIVATE15;
pub const eLEXTYPE_PRIVATE16 = SPLEXICONTYPE.PRIVATE16;
pub const eLEXTYPE_PRIVATE17 = SPLEXICONTYPE.PRIVATE17;
pub const eLEXTYPE_PRIVATE18 = SPLEXICONTYPE.PRIVATE18;
pub const eLEXTYPE_PRIVATE19 = SPLEXICONTYPE.PRIVATE19;
pub const eLEXTYPE_PRIVATE20 = SPLEXICONTYPE.PRIVATE20;

pub const SPWORDTYPE = enum(i32) {
    ADDED = 1,
    DELETED = 2,
};
pub const eWORDTYPE_ADDED = SPWORDTYPE.ADDED;
pub const eWORDTYPE_DELETED = SPWORDTYPE.DELETED;

pub const SPPRONUNCIATIONFLAGS = enum(i32) {
    D = 1,
};
pub const ePRONFLAG_USED = SPPRONUNCIATIONFLAGS.D;

pub const SPWORDPRONUNCIATION = extern struct {
    pNextWordPronunciation: ?*SPWORDPRONUNCIATION,
    eLexiconType: SPLEXICONTYPE,
    LangID: u16,
    wPronunciationFlags: u16,
    ePartOfSpeech: SPPARTOFSPEECH,
    szPronunciation: [1]u16,
};

pub const SPWORDPRONUNCIATIONLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstWordPronunciation: ?*SPWORDPRONUNCIATION,
};

pub const SPWORD = extern struct {
    pNextWord: ?*SPWORD,
    LangID: u16,
    wReserved: u16,
    eWordType: SPWORDTYPE,
    pszWord: ?PWSTR,
    pFirstWordPronunciation: ?*SPWORDPRONUNCIATION,
};

pub const SPWORDLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstWord: ?*SPWORD,
};

const IID_ISpLexicon_Value = Guid.initString("da41a7c2-5383-4db2-916b-6c1719e3db58");
pub const IID_ISpLexicon = &IID_ISpLexicon_Value;
pub const ISpLexicon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPronunciations: *const fn (
            self: *const ISpLexicon,
            psz_word: ?[*:0]const u16,
            lang_i_d: u16,
            dw_flags: u32,
            p_word_pronunciation_list: ?*SPWORDPRONUNCIATIONLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPronunciation: *const fn (
            self: *const ISpLexicon,
            psz_word: ?[*:0]const u16,
            lang_i_d: u16,
            e_part_of_speech: SPPARTOFSPEECH,
            psz_pronunciation: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePronunciation: *const fn (
            self: *const ISpLexicon,
            psz_word: ?[*:0]const u16,
            lang_i_d: u16,
            e_part_of_speech: SPPARTOFSPEECH,
            psz_pronunciation: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGeneration: *const fn (
            self: *const ISpLexicon,
            pdw_generation: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerationChange: *const fn (
            self: *const ISpLexicon,
            dw_flags: u32,
            pdw_generation: ?*u32,
            p_word_list: ?*SPWORDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: *const fn (
            self: *const ISpLexicon,
            dw_flags: u32,
            pdw_generation: ?*u32,
            pdw_cookie: ?*u32,
            p_word_list: ?*SPWORDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPronunciations(self: *const T, psz_word_: ?[*:0]const u16, lang_i_d_: u16, dw_flags_: u32, p_word_pronunciation_list_: ?*SPWORDPRONUNCIATIONLIST) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).GetPronunciations(@as(*const ISpLexicon, @ptrCast(self)), psz_word_, lang_i_d_, dw_flags_, p_word_pronunciation_list_);
            }
            pub inline fn addPronunciation(self: *const T, psz_word_: ?[*:0]const u16, lang_i_d_: u16, e_part_of_speech_: SPPARTOFSPEECH, psz_pronunciation_: ?*u16) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).AddPronunciation(@as(*const ISpLexicon, @ptrCast(self)), psz_word_, lang_i_d_, e_part_of_speech_, psz_pronunciation_);
            }
            pub inline fn removePronunciation(self: *const T, psz_word_: ?[*:0]const u16, lang_i_d_: u16, e_part_of_speech_: SPPARTOFSPEECH, psz_pronunciation_: ?*u16) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).RemovePronunciation(@as(*const ISpLexicon, @ptrCast(self)), psz_word_, lang_i_d_, e_part_of_speech_, psz_pronunciation_);
            }
            pub inline fn getGeneration(self: *const T, pdw_generation_: ?*u32) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).GetGeneration(@as(*const ISpLexicon, @ptrCast(self)), pdw_generation_);
            }
            pub inline fn getGenerationChange(self: *const T, dw_flags_: u32, pdw_generation_: ?*u32, p_word_list_: ?*SPWORDLIST) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).GetGenerationChange(@as(*const ISpLexicon, @ptrCast(self)), dw_flags_, pdw_generation_, p_word_list_);
            }
            pub inline fn getWords(self: *const T, dw_flags_: u32, pdw_generation_: ?*u32, pdw_cookie_: ?*u32, p_word_list_: ?*SPWORDLIST) HRESULT {
                return @as(*const ISpLexicon.VTable, @ptrCast(self.vtable)).GetWords(@as(*const ISpLexicon, @ptrCast(self)), dw_flags_, pdw_generation_, pdw_cookie_, p_word_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpContainerLexicon_Value = Guid.initString("8565572f-c094-41cc-b56e-10bd9c3ff044");
pub const IID_ISpContainerLexicon = &IID_ISpContainerLexicon_Value;
pub const ISpContainerLexicon = extern struct {
    pub const VTable = extern struct {
        base: ISpLexicon.VTable,
        AddLexicon: *const fn (
            self: *const ISpContainerLexicon,
            p_add_lexicon: ?*ISpLexicon,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpLexicon.MethodMixin(T);
            pub inline fn addLexicon(self: *const T, p_add_lexicon_: ?*ISpLexicon, dw_flags_: u32) HRESULT {
                return @as(*const ISpContainerLexicon.VTable, @ptrCast(self.vtable)).AddLexicon(@as(*const ISpContainerLexicon, @ptrCast(self)), p_add_lexicon_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPSHORTCUTTYPE = enum(i32) {
    SHT_NotOverriden = -1,
    SHT_Unknown = 0,
    SHT_EMAIL = 4096,
    SHT_OTHER = 8192,
    PS_RESERVED1 = 12288,
    PS_RESERVED2 = 16384,
    PS_RESERVED3 = 20480,
    PS_RESERVED4 = 61440,
};
pub const SPSHT_NotOverriden = SPSHORTCUTTYPE.SHT_NotOverriden;
pub const SPSHT_Unknown = SPSHORTCUTTYPE.SHT_Unknown;
pub const SPSHT_EMAIL = SPSHORTCUTTYPE.SHT_EMAIL;
pub const SPSHT_OTHER = SPSHORTCUTTYPE.SHT_OTHER;
pub const SPPS_RESERVED1 = SPSHORTCUTTYPE.PS_RESERVED1;
pub const SPPS_RESERVED2 = SPSHORTCUTTYPE.PS_RESERVED2;
pub const SPPS_RESERVED3 = SPSHORTCUTTYPE.PS_RESERVED3;
pub const SPPS_RESERVED4 = SPSHORTCUTTYPE.PS_RESERVED4;

pub const SPSHORTCUTPAIR = extern struct {
    pNextSHORTCUTPAIR: ?*SPSHORTCUTPAIR,
    LangID: u16,
    shType: SPSHORTCUTTYPE,
    pszDisplay: ?PWSTR,
    pszSpoken: ?PWSTR,
};

pub const SPSHORTCUTPAIRLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstShortcutPair: ?*SPSHORTCUTPAIR,
};

const IID_ISpShortcut_Value = Guid.initString("3df681e2-ea56-11d9-8bde-f66bad1e3f3a");
pub const IID_ISpShortcut = &IID_ISpShortcut_Value;
pub const ISpShortcut = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddShortcut: *const fn (
            self: *const ISpShortcut,
            psz_display: ?[*:0]const u16,
            lang_i_d: u16,
            psz_spoken: ?[*:0]const u16,
            sh_type: SPSHORTCUTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveShortcut: *const fn (
            self: *const ISpShortcut,
            psz_display: ?[*:0]const u16,
            lang_i_d: u16,
            psz_spoken: ?[*:0]const u16,
            sh_type: SPSHORTCUTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShortcuts: *const fn (
            self: *const ISpShortcut,
            lang_i_d: u16,
            p_shortcutpair_list: ?*SPSHORTCUTPAIRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGeneration: *const fn (
            self: *const ISpShortcut,
            pdw_generation: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWordsFromGenerationChange: *const fn (
            self: *const ISpShortcut,
            pdw_generation: ?*u32,
            p_word_list: ?*SPWORDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: *const fn (
            self: *const ISpShortcut,
            pdw_generation: ?*u32,
            pdw_cookie: ?*u32,
            p_word_list: ?*SPWORDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShortcutsForGeneration: *const fn (
            self: *const ISpShortcut,
            pdw_generation: ?*u32,
            pdw_cookie: ?*u32,
            p_shortcutpair_list: ?*SPSHORTCUTPAIRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerationChange: *const fn (
            self: *const ISpShortcut,
            pdw_generation: ?*u32,
            p_shortcutpair_list: ?*SPSHORTCUTPAIRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addShortcut(self: *const T, psz_display_: ?[*:0]const u16, lang_i_d_: u16, psz_spoken_: ?[*:0]const u16, sh_type_: SPSHORTCUTTYPE) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).AddShortcut(@as(*const ISpShortcut, @ptrCast(self)), psz_display_, lang_i_d_, psz_spoken_, sh_type_);
            }
            pub inline fn removeShortcut(self: *const T, psz_display_: ?[*:0]const u16, lang_i_d_: u16, psz_spoken_: ?[*:0]const u16, sh_type_: SPSHORTCUTTYPE) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).RemoveShortcut(@as(*const ISpShortcut, @ptrCast(self)), psz_display_, lang_i_d_, psz_spoken_, sh_type_);
            }
            pub inline fn getShortcuts(self: *const T, lang_i_d_: u16, p_shortcutpair_list_: ?*SPSHORTCUTPAIRLIST) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetShortcuts(@as(*const ISpShortcut, @ptrCast(self)), lang_i_d_, p_shortcutpair_list_);
            }
            pub inline fn getGeneration(self: *const T, pdw_generation_: ?*u32) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetGeneration(@as(*const ISpShortcut, @ptrCast(self)), pdw_generation_);
            }
            pub inline fn getWordsFromGenerationChange(self: *const T, pdw_generation_: ?*u32, p_word_list_: ?*SPWORDLIST) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetWordsFromGenerationChange(@as(*const ISpShortcut, @ptrCast(self)), pdw_generation_, p_word_list_);
            }
            pub inline fn getWords(self: *const T, pdw_generation_: ?*u32, pdw_cookie_: ?*u32, p_word_list_: ?*SPWORDLIST) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetWords(@as(*const ISpShortcut, @ptrCast(self)), pdw_generation_, pdw_cookie_, p_word_list_);
            }
            pub inline fn getShortcutsForGeneration(self: *const T, pdw_generation_: ?*u32, pdw_cookie_: ?*u32, p_shortcutpair_list_: ?*SPSHORTCUTPAIRLIST) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetShortcutsForGeneration(@as(*const ISpShortcut, @ptrCast(self)), pdw_generation_, pdw_cookie_, p_shortcutpair_list_);
            }
            pub inline fn getGenerationChange(self: *const T, pdw_generation_: ?*u32, p_shortcutpair_list_: ?*SPSHORTCUTPAIRLIST) HRESULT {
                return @as(*const ISpShortcut.VTable, @ptrCast(self.vtable)).GetGenerationChange(@as(*const ISpShortcut, @ptrCast(self)), pdw_generation_, p_shortcutpair_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneConverter_Value = Guid.initString("8445c581-0cac-4a38-abfe-9b2ce2826455");
pub const IID_ISpPhoneConverter = &IID_ISpPhoneConverter_Value;
pub const ISpPhoneConverter = extern struct {
    pub const VTable = extern struct {
        base: ISpObjectWithToken.VTable,
        PhoneToId: *const fn (
            self: *const ISpPhoneConverter,
            psz_phone: ?[*:0]const u16,
            p_id: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IdToPhone: *const fn (
            self: *const ISpPhoneConverter,
            p_id: ?*u16,
            psz_phone: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpObjectWithToken.MethodMixin(T);
            pub inline fn phoneToId(self: *const T, psz_phone_: ?[*:0]const u16, p_id_: ?*u16) HRESULT {
                return @as(*const ISpPhoneConverter.VTable, @ptrCast(self.vtable)).PhoneToId(@as(*const ISpPhoneConverter, @ptrCast(self)), psz_phone_, p_id_);
            }
            pub inline fn idToPhone(self: *const T, p_id_: ?*u16, psz_phone_: ?PWSTR) HRESULT {
                return @as(*const ISpPhoneConverter.VTable, @ptrCast(self.vtable)).IdToPhone(@as(*const ISpPhoneConverter, @ptrCast(self)), p_id_, psz_phone_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneticAlphabetConverter_Value = Guid.initString("133adcd4-19b4-4020-9fdc-842e78253b17");
pub const IID_ISpPhoneticAlphabetConverter = &IID_ISpPhoneticAlphabetConverter_Value;
pub const ISpPhoneticAlphabetConverter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLangId: *const fn (
            self: *const ISpPhoneticAlphabetConverter,
            p_lang_i_d: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLangId: *const fn (
            self: *const ISpPhoneticAlphabetConverter,
            lang_i_d: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SAPI2UPS: *const fn (
            self: *const ISpPhoneticAlphabetConverter,
            psz_s_a_p_i_id: ?*const u16,
            psz_u_p_s_id: [*:0]u16,
            c_max_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UPS2SAPI: *const fn (
            self: *const ISpPhoneticAlphabetConverter,
            psz_u_p_s_id: ?*const u16,
            psz_s_a_p_i_id: [*:0]u16,
            c_max_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxConvertLength: *const fn (
            self: *const ISpPhoneticAlphabetConverter,
            c_src_length: u32,
            b_s_a_p_i2_u_p_s: BOOL,
            pc_max_dest_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLangId(self: *const T, p_lang_i_d_: ?*u16) HRESULT {
                return @as(*const ISpPhoneticAlphabetConverter.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const ISpPhoneticAlphabetConverter, @ptrCast(self)), p_lang_i_d_);
            }
            pub inline fn setLangId(self: *const T, lang_i_d_: u16) HRESULT {
                return @as(*const ISpPhoneticAlphabetConverter.VTable, @ptrCast(self.vtable)).SetLangId(@as(*const ISpPhoneticAlphabetConverter, @ptrCast(self)), lang_i_d_);
            }
            pub inline fn sapi2ups(self: *const T, psz_s_a_p_i_id_: ?*const u16, psz_u_p_s_id_: [*:0]u16, c_max_length_: u32) HRESULT {
                return @as(*const ISpPhoneticAlphabetConverter.VTable, @ptrCast(self.vtable)).SAPI2UPS(@as(*const ISpPhoneticAlphabetConverter, @ptrCast(self)), psz_s_a_p_i_id_, psz_u_p_s_id_, c_max_length_);
            }
            pub inline fn ups2sapi(self: *const T, psz_u_p_s_id_: ?*const u16, psz_s_a_p_i_id_: [*:0]u16, c_max_length_: u32) HRESULT {
                return @as(*const ISpPhoneticAlphabetConverter.VTable, @ptrCast(self.vtable)).UPS2SAPI(@as(*const ISpPhoneticAlphabetConverter, @ptrCast(self)), psz_u_p_s_id_, psz_s_a_p_i_id_, c_max_length_);
            }
            pub inline fn getMaxConvertLength(self: *const T, c_src_length_: u32, b_s_a_p_i2_u_p_s_: BOOL, pc_max_dest_length_: ?*u32) HRESULT {
                return @as(*const ISpPhoneticAlphabetConverter.VTable, @ptrCast(self.vtable)).GetMaxConvertLength(@as(*const ISpPhoneticAlphabetConverter, @ptrCast(self)), c_src_length_, b_s_a_p_i2_u_p_s_, pc_max_dest_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneticAlphabetSelection_Value = Guid.initString("b2745efd-42ce-48ca-81f1-a96e02538a90");
pub const IID_ISpPhoneticAlphabetSelection = &IID_ISpPhoneticAlphabetSelection_Value;
pub const ISpPhoneticAlphabetSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsAlphabetUPS: *const fn (
            self: *const ISpPhoneticAlphabetSelection,
            pf_is_u_p_s: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlphabetToUPS: *const fn (
            self: *const ISpPhoneticAlphabetSelection,
            f_force_u_p_s: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isAlphabetUPS(self: *const T, pf_is_u_p_s_: ?*BOOL) HRESULT {
                return @as(*const ISpPhoneticAlphabetSelection.VTable, @ptrCast(self.vtable)).IsAlphabetUPS(@as(*const ISpPhoneticAlphabetSelection, @ptrCast(self)), pf_is_u_p_s_);
            }
            pub inline fn setAlphabetToUPS(self: *const T, f_force_u_p_s_: BOOL) HRESULT {
                return @as(*const ISpPhoneticAlphabetSelection.VTable, @ptrCast(self.vtable)).SetAlphabetToUPS(@as(*const ISpPhoneticAlphabetSelection, @ptrCast(self)), f_force_u_p_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPVPITCH = extern struct {
    MiddleAdj: i32,
    RangeAdj: i32,
};

pub const SPVACTIONS = enum(i32) {
    Speak = 0,
    Silence = 1,
    Pronounce = 2,
    Bookmark = 3,
    SpellOut = 4,
    Section = 5,
    ParseUnknownTag = 6,
};
pub const SPVA_Speak = SPVACTIONS.Speak;
pub const SPVA_Silence = SPVACTIONS.Silence;
pub const SPVA_Pronounce = SPVACTIONS.Pronounce;
pub const SPVA_Bookmark = SPVACTIONS.Bookmark;
pub const SPVA_SpellOut = SPVACTIONS.SpellOut;
pub const SPVA_Section = SPVACTIONS.Section;
pub const SPVA_ParseUnknownTag = SPVACTIONS.ParseUnknownTag;

pub const SPVCONTEXT = extern struct {
    pCategory: ?[*:0]const u16,
    pBefore: ?[*:0]const u16,
    pAfter: ?[*:0]const u16,
};

pub const SPVSTATE = extern struct {
    eAction: SPVACTIONS,
    LangID: u16,
    wReserved: u16,
    EmphAdj: i32,
    RateAdj: i32,
    Volume: u32,
    PitchAdj: SPVPITCH,
    SilenceMSecs: u32,
    pPhoneIds: ?*u16,
    ePartOfSpeech: SPPARTOFSPEECH,
    Context: SPVCONTEXT,
};

pub const SPRUNSTATE = enum(i32) {
    DONE = 1,
    IS_SPEAKING = 2,
};
pub const SPRS_DONE = SPRUNSTATE.DONE;
pub const SPRS_IS_SPEAKING = SPRUNSTATE.IS_SPEAKING;

pub const SPVLIMITS = enum(i32) {
    IN_VOLUME = 0,
    AX_VOLUME = 100,
    IN_RATE = -10,
    AX_RATE = 10,
};
pub const SPMIN_VOLUME = SPVLIMITS.IN_VOLUME;
pub const SPMAX_VOLUME = SPVLIMITS.AX_VOLUME;
pub const SPMIN_RATE = SPVLIMITS.IN_RATE;
pub const SPMAX_RATE = SPVLIMITS.AX_RATE;

pub const SPVPRIORITY = enum(i32) {
    NORMAL = 0,
    ALERT = 1,
    OVER = 2,
};
pub const SPVPRI_NORMAL = SPVPRIORITY.NORMAL;
pub const SPVPRI_ALERT = SPVPRIORITY.ALERT;
pub const SPVPRI_OVER = SPVPRIORITY.OVER;

pub const SPVOICESTATUS = extern struct {
    ulCurrentStream: u32,
    ulLastStreamQueued: u32,
    hrLastResult: HRESULT,
    dwRunningState: u32,
    ulInputWordPos: u32,
    ulInputWordLen: u32,
    ulInputSentPos: u32,
    ulInputSentLen: u32,
    lBookmarkId: i32,
    PhonemeId: u16,
    VisemeId: SPVISEMES,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const SPEAKFLAGS = enum(i32) {
    DEFAULT = 0,
    ASYNC = 1,
    PURGEBEFORESPEAK = 2,
    IS_FILENAME = 4,
    IS_XML = 8,
    IS_NOT_XML = 16,
    PERSIST_XML = 32,
    NLP_SPEAK_PUNC = 64,
    PARSE_SAPI = 128,
    PARSE_SSML = 256,
    // PARSE_AUTODETECT = 0, this enum value conflicts with DEFAULT
    // NLP_MASK = 64, this enum value conflicts with NLP_SPEAK_PUNC
    PARSE_MASK = 384,
    VOICE_MASK = 511,
    UNUSED_FLAGS = -512,
};
pub const SPF_DEFAULT = SPEAKFLAGS.DEFAULT;
pub const SPF_ASYNC = SPEAKFLAGS.ASYNC;
pub const SPF_PURGEBEFORESPEAK = SPEAKFLAGS.PURGEBEFORESPEAK;
pub const SPF_IS_FILENAME = SPEAKFLAGS.IS_FILENAME;
pub const SPF_IS_XML = SPEAKFLAGS.IS_XML;
pub const SPF_IS_NOT_XML = SPEAKFLAGS.IS_NOT_XML;
pub const SPF_PERSIST_XML = SPEAKFLAGS.PERSIST_XML;
pub const SPF_NLP_SPEAK_PUNC = SPEAKFLAGS.NLP_SPEAK_PUNC;
pub const SPF_PARSE_SAPI = SPEAKFLAGS.PARSE_SAPI;
pub const SPF_PARSE_SSML = SPEAKFLAGS.PARSE_SSML;
pub const SPF_PARSE_AUTODETECT = SPEAKFLAGS.DEFAULT;
pub const SPF_NLP_MASK = SPEAKFLAGS.NLP_SPEAK_PUNC;
pub const SPF_PARSE_MASK = SPEAKFLAGS.PARSE_MASK;
pub const SPF_VOICE_MASK = SPEAKFLAGS.VOICE_MASK;
pub const SPF_UNUSED_FLAGS = SPEAKFLAGS.UNUSED_FLAGS;

const IID_ISpVoice_Value = Guid.initString("6c44df74-72b9-4992-a1ec-ef996e0422d4");
pub const IID_ISpVoice = &IID_ISpVoice_Value;
pub const ISpVoice = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        SetOutput: *const fn (
            self: *const ISpVoice,
            p_unk_output: ?*IUnknown,
            f_allow_format_changes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputObjectToken: *const fn (
            self: *const ISpVoice,
            pp_object_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStream: *const fn (
            self: *const ISpVoice,
            pp_stream: ?*?*ISpStreamFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const ISpVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const ISpVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVoice: *const fn (
            self: *const ISpVoice,
            p_token: ?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVoice: *const fn (
            self: *const ISpVoice,
            pp_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Speak: *const fn (
            self: *const ISpVoice,
            pwcs: ?[*:0]const u16,
            dw_flags: u32,
            pul_stream_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakStream: *const fn (
            self: *const ISpVoice,
            p_stream: ?*IStream,
            dw_flags: u32,
            pul_stream_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ISpVoice,
            p_status: ?*SPVOICESTATUS,
            ppsz_last_bookmark: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const ISpVoice,
            p_item_type: ?[*:0]const u16,
            l_num_items: i32,
            pul_num_skipped: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPriority: *const fn (
            self: *const ISpVoice,
            e_priority: SPVPRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: *const fn (
            self: *const ISpVoice,
            pe_priority: ?*SPVPRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlertBoundary: *const fn (
            self: *const ISpVoice,
            e_boundary: SPEVENTENUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlertBoundary: *const fn (
            self: *const ISpVoice,
            pe_boundary: ?*SPEVENTENUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRate: *const fn (
            self: *const ISpVoice,
            rate_adjust: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRate: *const fn (
            self: *const ISpVoice,
            p_rate_adjust: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVolume: *const fn (
            self: *const ISpVoice,
            us_volume: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: *const fn (
            self: *const ISpVoice,
            pus_volume: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitUntilDone: *const fn (
            self: *const ISpVoice,
            ms_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncSpeakTimeout: *const fn (
            self: *const ISpVoice,
            ms_timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSyncSpeakTimeout: *const fn (
            self: *const ISpVoice,
            pms_timeout: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakCompleteEvent: *const fn (
            self: *const ISpVoice,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        IsUISupported: *const fn (
            self: *const ISpVoice,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
            pf_supported: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpVoice,
            hwnd_parent: ?HWND,
            psz_title: ?[*:0]const u16,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpEventSource.MethodMixin(T);
            pub inline fn setOutput(self: *const T, p_unk_output_: ?*IUnknown, f_allow_format_changes_: BOOL) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetOutput(@as(*const ISpVoice, @ptrCast(self)), p_unk_output_, f_allow_format_changes_);
            }
            pub inline fn getOutputObjectToken(self: *const T, pp_object_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetOutputObjectToken(@as(*const ISpVoice, @ptrCast(self)), pp_object_token_);
            }
            pub inline fn getOutputStream(self: *const T, pp_stream_: ?*?*ISpStreamFormat) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetOutputStream(@as(*const ISpVoice, @ptrCast(self)), pp_stream_);
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).Pause(@as(*const ISpVoice, @ptrCast(self)));
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).Resume(@as(*const ISpVoice, @ptrCast(self)));
            }
            pub inline fn setVoice(self: *const T, p_token_: ?*ISpObjectToken) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetVoice(@as(*const ISpVoice, @ptrCast(self)), p_token_);
            }
            pub inline fn getVoice(self: *const T, pp_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetVoice(@as(*const ISpVoice, @ptrCast(self)), pp_token_);
            }
            pub inline fn speak(self: *const T, pwcs_: ?[*:0]const u16, dw_flags_: u32, pul_stream_number_: ?*u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).Speak(@as(*const ISpVoice, @ptrCast(self)), pwcs_, dw_flags_, pul_stream_number_);
            }
            pub inline fn speakStream(self: *const T, p_stream_: ?*IStream, dw_flags_: u32, pul_stream_number_: ?*u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SpeakStream(@as(*const ISpVoice, @ptrCast(self)), p_stream_, dw_flags_, pul_stream_number_);
            }
            pub inline fn getStatus(self: *const T, p_status_: ?*SPVOICESTATUS, ppsz_last_bookmark_: ?*?PWSTR) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ISpVoice, @ptrCast(self)), p_status_, ppsz_last_bookmark_);
            }
            pub inline fn skip(self: *const T, p_item_type_: ?[*:0]const u16, l_num_items_: i32, pul_num_skipped_: ?*u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).Skip(@as(*const ISpVoice, @ptrCast(self)), p_item_type_, l_num_items_, pul_num_skipped_);
            }
            pub inline fn setPriority(self: *const T, e_priority_: SPVPRIORITY) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetPriority(@as(*const ISpVoice, @ptrCast(self)), e_priority_);
            }
            pub inline fn getPriority(self: *const T, pe_priority_: ?*SPVPRIORITY) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const ISpVoice, @ptrCast(self)), pe_priority_);
            }
            pub inline fn setAlertBoundary(self: *const T, e_boundary_: SPEVENTENUM) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetAlertBoundary(@as(*const ISpVoice, @ptrCast(self)), e_boundary_);
            }
            pub inline fn getAlertBoundary(self: *const T, pe_boundary_: ?*SPEVENTENUM) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetAlertBoundary(@as(*const ISpVoice, @ptrCast(self)), pe_boundary_);
            }
            pub inline fn setRate(self: *const T, rate_adjust_: i32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetRate(@as(*const ISpVoice, @ptrCast(self)), rate_adjust_);
            }
            pub inline fn getRate(self: *const T, p_rate_adjust_: ?*i32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetRate(@as(*const ISpVoice, @ptrCast(self)), p_rate_adjust_);
            }
            pub inline fn setVolume(self: *const T, us_volume_: u16) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const ISpVoice, @ptrCast(self)), us_volume_);
            }
            pub inline fn getVolume(self: *const T, pus_volume_: ?*u16) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetVolume(@as(*const ISpVoice, @ptrCast(self)), pus_volume_);
            }
            pub inline fn waitUntilDone(self: *const T, ms_timeout_: u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).WaitUntilDone(@as(*const ISpVoice, @ptrCast(self)), ms_timeout_);
            }
            pub inline fn setSyncSpeakTimeout(self: *const T, ms_timeout_: u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SetSyncSpeakTimeout(@as(*const ISpVoice, @ptrCast(self)), ms_timeout_);
            }
            pub inline fn getSyncSpeakTimeout(self: *const T, pms_timeout_: ?*u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).GetSyncSpeakTimeout(@as(*const ISpVoice, @ptrCast(self)), pms_timeout_);
            }
            pub inline fn speakCompleteEvent(self: *const T) ?HANDLE {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).SpeakCompleteEvent(@as(*const ISpVoice, @ptrCast(self)));
            }
            pub inline fn isUISupported(self: *const T, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32, pf_supported_: ?*BOOL) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpVoice, @ptrCast(self)), psz_type_of_u_i_, pv_extra_data_, cb_extra_data_, pf_supported_);
            }
            pub inline fn displayUI(self: *const T, hwnd_parent_: ?HWND, psz_title_: ?[*:0]const u16, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32) HRESULT {
                return @as(*const ISpVoice.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpVoice, @ptrCast(self)), hwnd_parent_, psz_title_, psz_type_of_u_i_, pv_extra_data_, cb_extra_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhrase_Value = Guid.initString("1a5c0354-b621-4b5a-8791-d306ed379e53");
pub const IID_ISpPhrase = &IID_ISpPhrase_Value;
pub const ISpPhrase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPhrase: *const fn (
            self: *const ISpPhrase,
            pp_co_mem_phrase: ?*?*SPPHRASE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSerializedPhrase: *const fn (
            self: *const ISpPhrase,
            pp_co_mem_phrase: ?*?*SPSERIALIZEDPHRASE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ISpPhrase,
            ul_start: u32,
            ul_count: u32,
            f_use_text_replacements: BOOL,
            ppsz_co_mem_text: ?*?PWSTR,
            pb_display_attributes: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Discard: *const fn (
            self: *const ISpPhrase,
            dw_value_types: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPhrase(self: *const T, pp_co_mem_phrase_: ?*?*SPPHRASE) HRESULT {
                return @as(*const ISpPhrase.VTable, @ptrCast(self.vtable)).GetPhrase(@as(*const ISpPhrase, @ptrCast(self)), pp_co_mem_phrase_);
            }
            pub inline fn getSerializedPhrase(self: *const T, pp_co_mem_phrase_: ?*?*SPSERIALIZEDPHRASE) HRESULT {
                return @as(*const ISpPhrase.VTable, @ptrCast(self.vtable)).GetSerializedPhrase(@as(*const ISpPhrase, @ptrCast(self)), pp_co_mem_phrase_);
            }
            pub inline fn getText(self: *const T, ul_start_: u32, ul_count_: u32, f_use_text_replacements_: BOOL, ppsz_co_mem_text_: ?*?PWSTR, pb_display_attributes_: ?*u8) HRESULT {
                return @as(*const ISpPhrase.VTable, @ptrCast(self.vtable)).GetText(@as(*const ISpPhrase, @ptrCast(self)), ul_start_, ul_count_, f_use_text_replacements_, ppsz_co_mem_text_, pb_display_attributes_);
            }
            pub inline fn discard(self: *const T, dw_value_types_: u32) HRESULT {
                return @as(*const ISpPhrase.VTable, @ptrCast(self.vtable)).Discard(@as(*const ISpPhrase, @ptrCast(self)), dw_value_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhraseAlt_Value = Guid.initString("8fcebc98-4e49-4067-9c6c-d86a0e092e3d");
pub const IID_ISpPhraseAlt = &IID_ISpPhraseAlt_Value;
pub const ISpPhraseAlt = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetAltInfo: *const fn (
            self: *const ISpPhraseAlt,
            pp_parent: ?*?*ISpPhrase,
            pul_start_element_in_parent: ?*u32,
            pc_elements_in_parent: ?*u32,
            pc_elements_in_alt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const ISpPhraseAlt,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpPhrase.MethodMixin(T);
            pub inline fn getAltInfo(self: *const T, pp_parent_: ?*?*ISpPhrase, pul_start_element_in_parent_: ?*u32, pc_elements_in_parent_: ?*u32, pc_elements_in_alt_: ?*u32) HRESULT {
                return @as(*const ISpPhraseAlt.VTable, @ptrCast(self.vtable)).GetAltInfo(@as(*const ISpPhraseAlt, @ptrCast(self)), pp_parent_, pul_start_element_in_parent_, pc_elements_in_parent_, pc_elements_in_alt_);
            }
            pub inline fn commit(self: *const T) HRESULT {
                return @as(*const ISpPhraseAlt.VTable, @ptrCast(self.vtable)).Commit(@as(*const ISpPhraseAlt, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPXMLRESULTOPTIONS = enum(i32) {
    SML = 0,
    Alternates_SML = 1,
};
pub const SPXRO_SML = SPXMLRESULTOPTIONS.SML;
pub const SPXRO_Alternates_SML = SPXMLRESULTOPTIONS.Alternates_SML;

const IID_ISpPhrase2_Value = Guid.initString("f264da52-e457-4696-b856-a737b717af79");
pub const IID_ISpPhrase2 = &IID_ISpPhrase2_Value;
pub const ISpPhrase2 = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetXMLResult: *const fn (
            self: *const ISpPhrase2,
            ppsz_co_mem_x_m_l_result: ?*?PWSTR,
            options: SPXMLRESULTOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXMLErrorInfo: *const fn (
            self: *const ISpPhrase2,
            p_semantic_error_info: ?*SPSEMANTICERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudio: *const fn (
            self: *const ISpPhrase2,
            ul_start_element: u32,
            c_elements: u32,
            pp_stream: ?*?*ISpStreamFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpPhrase.MethodMixin(T);
            pub inline fn getXMLResult(self: *const T, ppsz_co_mem_x_m_l_result_: ?*?PWSTR, options_: SPXMLRESULTOPTIONS) HRESULT {
                return @as(*const ISpPhrase2.VTable, @ptrCast(self.vtable)).GetXMLResult(@as(*const ISpPhrase2, @ptrCast(self)), ppsz_co_mem_x_m_l_result_, options_);
            }
            pub inline fn getXMLErrorInfo(self: *const T, p_semantic_error_info_: ?*SPSEMANTICERRORINFO) HRESULT {
                return @as(*const ISpPhrase2.VTable, @ptrCast(self.vtable)).GetXMLErrorInfo(@as(*const ISpPhrase2, @ptrCast(self)), p_semantic_error_info_);
            }
            pub inline fn getAudio(self: *const T, ul_start_element_: u32, c_elements_: u32, pp_stream_: ?*?*ISpStreamFormat) HRESULT {
                return @as(*const ISpPhrase2.VTable, @ptrCast(self.vtable)).GetAudio(@as(*const ISpPhrase2, @ptrCast(self)), ul_start_element_, c_elements_, pp_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECORESULTTIMES = extern struct {
    ftStreamTime: FILETIME,
    ullLength: u64,
    dwTickCount: u32,
    ullStart: u64,
};

pub const SPSERIALIZEDRESULT = extern struct {
    ulSerializedSize: u32,
};

const IID_ISpRecoResult_Value = Guid.initString("20b053be-e235-43cd-9a2a-8d17a48b7842");
pub const IID_ISpRecoResult = &IID_ISpRecoResult_Value;
pub const ISpRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetResultTimes: *const fn (
            self: *const ISpRecoResult,
            p_times: ?*SPRECORESULTTIMES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternates: *const fn (
            self: *const ISpRecoResult,
            ul_start_element: u32,
            c_elements: u32,
            ul_request_count: u32,
            pp_phrases: [*]?*ISpPhraseAlt,
            pc_phrases_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudio: *const fn (
            self: *const ISpRecoResult,
            ul_start_element: u32,
            c_elements: u32,
            pp_stream: ?*?*ISpStreamFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakAudio: *const fn (
            self: *const ISpRecoResult,
            ul_start_element: u32,
            c_elements: u32,
            dw_flags: u32,
            pul_stream_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Serialize: *const fn (
            self: *const ISpRecoResult,
            pp_co_mem_serialized_result: ?*?*SPSERIALIZEDRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScaleAudio: *const fn (
            self: *const ISpRecoResult,
            p_audio_format_id: ?*const Guid,
            p_wave_format_ex: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecoContext: *const fn (
            self: *const ISpRecoResult,
            pp_reco_context: ?*?*ISpRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpPhrase.MethodMixin(T);
            pub inline fn getResultTimes(self: *const T, p_times_: ?*SPRECORESULTTIMES) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).GetResultTimes(@as(*const ISpRecoResult, @ptrCast(self)), p_times_);
            }
            pub inline fn getAlternates(self: *const T, ul_start_element_: u32, c_elements_: u32, ul_request_count_: u32, pp_phrases_: [*]?*ISpPhraseAlt, pc_phrases_returned_: ?*u32) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).GetAlternates(@as(*const ISpRecoResult, @ptrCast(self)), ul_start_element_, c_elements_, ul_request_count_, pp_phrases_, pc_phrases_returned_);
            }
            pub inline fn getAudio(self: *const T, ul_start_element_: u32, c_elements_: u32, pp_stream_: ?*?*ISpStreamFormat) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).GetAudio(@as(*const ISpRecoResult, @ptrCast(self)), ul_start_element_, c_elements_, pp_stream_);
            }
            pub inline fn speakAudio(self: *const T, ul_start_element_: u32, c_elements_: u32, dw_flags_: u32, pul_stream_number_: ?*u32) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).SpeakAudio(@as(*const ISpRecoResult, @ptrCast(self)), ul_start_element_, c_elements_, dw_flags_, pul_stream_number_);
            }
            pub inline fn serialize(self: *const T, pp_co_mem_serialized_result_: ?*?*SPSERIALIZEDRESULT) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ISpRecoResult, @ptrCast(self)), pp_co_mem_serialized_result_);
            }
            pub inline fn scaleAudio(self: *const T, p_audio_format_id_: ?*const Guid, p_wave_format_ex_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).ScaleAudio(@as(*const ISpRecoResult, @ptrCast(self)), p_audio_format_id_, p_wave_format_ex_);
            }
            pub inline fn getRecoContext(self: *const T, pp_reco_context_: ?*?*ISpRecoContext) HRESULT {
                return @as(*const ISpRecoResult.VTable, @ptrCast(self.vtable)).GetRecoContext(@as(*const ISpRecoResult, @ptrCast(self)), pp_reco_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPCOMMITFLAGS = enum(i32) {
    NONE = 0,
    ADD_TO_USER_LEXICON = 1,
    DEFINITE_CORRECTION = 2,
};
pub const SPCF_NONE = SPCOMMITFLAGS.NONE;
pub const SPCF_ADD_TO_USER_LEXICON = SPCOMMITFLAGS.ADD_TO_USER_LEXICON;
pub const SPCF_DEFINITE_CORRECTION = SPCOMMITFLAGS.DEFINITE_CORRECTION;

const IID_ISpRecoResult2_Value = Guid.initString("27cac6c4-88f2-41f2-8817-0c95e59f1e6e");
pub const IID_ISpRecoResult2 = &IID_ISpRecoResult2_Value;
pub const ISpRecoResult2 = extern struct {
    pub const VTable = extern struct {
        base: ISpRecoResult.VTable,
        CommitAlternate: *const fn (
            self: *const ISpRecoResult2,
            p_phrase_alt: ?*ISpPhraseAlt,
            pp_new_result: ?*?*ISpRecoResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitText: *const fn (
            self: *const ISpRecoResult2,
            ul_start_element: u32,
            c_elements: u32,
            psz_corrected_data: ?[*:0]const u16,
            e_commit_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextFeedback: *const fn (
            self: *const ISpRecoResult2,
            psz_feedback: ?[*:0]const u16,
            f_successful: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpRecoResult.MethodMixin(T);
            pub inline fn commitAlternate(self: *const T, p_phrase_alt_: ?*ISpPhraseAlt, pp_new_result_: ?*?*ISpRecoResult) HRESULT {
                return @as(*const ISpRecoResult2.VTable, @ptrCast(self.vtable)).CommitAlternate(@as(*const ISpRecoResult2, @ptrCast(self)), p_phrase_alt_, pp_new_result_);
            }
            pub inline fn commitText(self: *const T, ul_start_element_: u32, c_elements_: u32, psz_corrected_data_: ?[*:0]const u16, e_commit_flags_: u32) HRESULT {
                return @as(*const ISpRecoResult2.VTable, @ptrCast(self.vtable)).CommitText(@as(*const ISpRecoResult2, @ptrCast(self)), ul_start_element_, c_elements_, psz_corrected_data_, e_commit_flags_);
            }
            pub inline fn setTextFeedback(self: *const T, psz_feedback_: ?[*:0]const u16, f_successful_: BOOL) HRESULT {
                return @as(*const ISpRecoResult2.VTable, @ptrCast(self.vtable)).SetTextFeedback(@as(*const ISpRecoResult2, @ptrCast(self)), psz_feedback_, f_successful_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpXMLRecoResult_Value = Guid.initString("ae39362b-45a8-4074-9b9e-ccf49aa2d0b6");
pub const IID_ISpXMLRecoResult = &IID_ISpXMLRecoResult_Value;
pub const ISpXMLRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpRecoResult.VTable,
        GetXMLResult: *const fn (
            self: *const ISpXMLRecoResult,
            ppsz_co_mem_x_m_l_result: ?*?PWSTR,
            options: SPXMLRESULTOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXMLErrorInfo: *const fn (
            self: *const ISpXMLRecoResult,
            p_semantic_error_info: ?*SPSEMANTICERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpRecoResult.MethodMixin(T);
            pub inline fn getXMLResult(self: *const T, ppsz_co_mem_x_m_l_result_: ?*?PWSTR, options_: SPXMLRESULTOPTIONS) HRESULT {
                return @as(*const ISpXMLRecoResult.VTable, @ptrCast(self.vtable)).GetXMLResult(@as(*const ISpXMLRecoResult, @ptrCast(self)), ppsz_co_mem_x_m_l_result_, options_);
            }
            pub inline fn getXMLErrorInfo(self: *const T, p_semantic_error_info_: ?*SPSEMANTICERRORINFO) HRESULT {
                return @as(*const ISpXMLRecoResult.VTable, @ptrCast(self.vtable)).GetXMLErrorInfo(@as(*const ISpXMLRecoResult, @ptrCast(self)), p_semantic_error_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPTEXTSELECTIONINFO = extern struct {
    ulStartActiveOffset: u32,
    cchActiveChars: u32,
    ulStartSelection: u32,
    cchSelection: u32,
};

pub const SPWORDPRONOUNCEABLE = enum(i32) {
    UNKNOWN_WORD_UNPRONOUNCEABLE = 0,
    UNKNOWN_WORD_PRONOUNCEABLE = 1,
    KNOWN_WORD_PRONOUNCEABLE = 2,
};
pub const SPWP_UNKNOWN_WORD_UNPRONOUNCEABLE = SPWORDPRONOUNCEABLE.UNKNOWN_WORD_UNPRONOUNCEABLE;
pub const SPWP_UNKNOWN_WORD_PRONOUNCEABLE = SPWORDPRONOUNCEABLE.UNKNOWN_WORD_PRONOUNCEABLE;
pub const SPWP_KNOWN_WORD_PRONOUNCEABLE = SPWORDPRONOUNCEABLE.KNOWN_WORD_PRONOUNCEABLE;

pub const SPGRAMMARSTATE = enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
    EXCLUSIVE = 3,
};
pub const SPGS_DISABLED = SPGRAMMARSTATE.DISABLED;
pub const SPGS_ENABLED = SPGRAMMARSTATE.ENABLED;
pub const SPGS_EXCLUSIVE = SPGRAMMARSTATE.EXCLUSIVE;

pub const SPCONTEXTSTATE = enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
};
pub const SPCS_DISABLED = SPCONTEXTSTATE.DISABLED;
pub const SPCS_ENABLED = SPCONTEXTSTATE.ENABLED;

pub const SPRULESTATE = enum(i32) {
    INACTIVE = 0,
    ACTIVE = 1,
    ACTIVE_WITH_AUTO_PAUSE = 3,
    ACTIVE_USER_DELIMITED = 4,
};
pub const SPRS_INACTIVE = SPRULESTATE.INACTIVE;
pub const SPRS_ACTIVE = SPRULESTATE.ACTIVE;
pub const SPRS_ACTIVE_WITH_AUTO_PAUSE = SPRULESTATE.ACTIVE_WITH_AUTO_PAUSE;
pub const SPRS_ACTIVE_USER_DELIMITED = SPRULESTATE.ACTIVE_USER_DELIMITED;

pub const SPGRAMMARWORDTYPE = enum(i32) {
    DISPLAY = 0,
    LEXICAL = 1,
    PRONUNCIATION = 2,
    LEXICAL_NO_SPECIAL_CHARS = 3,
};
pub const SPWT_DISPLAY = SPGRAMMARWORDTYPE.DISPLAY;
pub const SPWT_LEXICAL = SPGRAMMARWORDTYPE.LEXICAL;
pub const SPWT_PRONUNCIATION = SPGRAMMARWORDTYPE.PRONUNCIATION;
pub const SPWT_LEXICAL_NO_SPECIAL_CHARS = SPGRAMMARWORDTYPE.LEXICAL_NO_SPECIAL_CHARS;

pub const SPPROPERTYINFO = extern struct {
    pszName: ?[*:0]const u16,
    ulId: u32,
    pszValue: ?[*:0]const u16,
    vValue: VARIANT,
};

pub const SPCFGRULEATTRIBUTES = enum(i32) {
    TopLevel = 1,
    Active = 2,
    Export = 4,
    Import = 8,
    Interpreter = 16,
    Dynamic = 32,
    Root = 64,
    AutoPause = 65536,
    UserDelimited = 131072,
};
pub const SPRAF_TopLevel = SPCFGRULEATTRIBUTES.TopLevel;
pub const SPRAF_Active = SPCFGRULEATTRIBUTES.Active;
pub const SPRAF_Export = SPCFGRULEATTRIBUTES.Export;
pub const SPRAF_Import = SPCFGRULEATTRIBUTES.Import;
pub const SPRAF_Interpreter = SPCFGRULEATTRIBUTES.Interpreter;
pub const SPRAF_Dynamic = SPCFGRULEATTRIBUTES.Dynamic;
pub const SPRAF_Root = SPCFGRULEATTRIBUTES.Root;
pub const SPRAF_AutoPause = SPCFGRULEATTRIBUTES.AutoPause;
pub const SPRAF_UserDelimited = SPCFGRULEATTRIBUTES.UserDelimited;

const IID_ISpGrammarBuilder_Value = Guid.initString("8137828f-591a-4a42-be58-49ea7ebaac68");
pub const IID_ISpGrammarBuilder = &IID_ISpGrammarBuilder_Value;
pub const ISpGrammarBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetGrammar: *const fn (
            self: *const ISpGrammarBuilder,
            new_language: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRule: *const fn (
            self: *const ISpGrammarBuilder,
            psz_rule_name: ?[*:0]const u16,
            dw_rule_id: u32,
            dw_attributes: u32,
            f_create_if_not_exist: BOOL,
            ph_initial_state: ?*?*SPSTATEHANDLE__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearRule: *const fn (
            self: *const ISpGrammarBuilder,
            h_state: ?*SPSTATEHANDLE__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNewState: *const fn (
            self: *const ISpGrammarBuilder,
            h_state: ?*SPSTATEHANDLE__,
            ph_state: ?*?*SPSTATEHANDLE__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddWordTransition: *const fn (
            self: *const ISpGrammarBuilder,
            h_from_state: ?*SPSTATEHANDLE__,
            h_to_state: ?*SPSTATEHANDLE__,
            psz: ?[*:0]const u16,
            psz_separators: ?[*:0]const u16,
            e_word_type: SPGRAMMARWORDTYPE,
            weight: f32,
            p_prop_info: ?*const SPPROPERTYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRuleTransition: *const fn (
            self: *const ISpGrammarBuilder,
            h_from_state: ?*SPSTATEHANDLE__,
            h_to_state: ?*SPSTATEHANDLE__,
            h_rule: ?*SPSTATEHANDLE__,
            weight: f32,
            p_prop_info: ?*const SPPROPERTYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddResource: *const fn (
            self: *const ISpGrammarBuilder,
            h_rule_state: ?*SPSTATEHANDLE__,
            psz_resource_name: ?[*:0]const u16,
            psz_resource_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const ISpGrammarBuilder,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn resetGrammar(self: *const T, new_language_: u16) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).ResetGrammar(@as(*const ISpGrammarBuilder, @ptrCast(self)), new_language_);
            }
            pub inline fn getRule(self: *const T, psz_rule_name_: ?[*:0]const u16, dw_rule_id_: u32, dw_attributes_: u32, f_create_if_not_exist_: BOOL, ph_initial_state_: ?*?*SPSTATEHANDLE__) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).GetRule(@as(*const ISpGrammarBuilder, @ptrCast(self)), psz_rule_name_, dw_rule_id_, dw_attributes_, f_create_if_not_exist_, ph_initial_state_);
            }
            pub inline fn clearRule(self: *const T, h_state_: ?*SPSTATEHANDLE__) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).ClearRule(@as(*const ISpGrammarBuilder, @ptrCast(self)), h_state_);
            }
            pub inline fn createNewState(self: *const T, h_state_: ?*SPSTATEHANDLE__, ph_state_: ?*?*SPSTATEHANDLE__) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).CreateNewState(@as(*const ISpGrammarBuilder, @ptrCast(self)), h_state_, ph_state_);
            }
            pub inline fn addWordTransition(self: *const T, h_from_state_: ?*SPSTATEHANDLE__, h_to_state_: ?*SPSTATEHANDLE__, psz_: ?[*:0]const u16, psz_separators_: ?[*:0]const u16, e_word_type_: SPGRAMMARWORDTYPE, weight_: f32, p_prop_info_: ?*const SPPROPERTYINFO) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).AddWordTransition(@as(*const ISpGrammarBuilder, @ptrCast(self)), h_from_state_, h_to_state_, psz_, psz_separators_, e_word_type_, weight_, p_prop_info_);
            }
            pub inline fn addRuleTransition(self: *const T, h_from_state_: ?*SPSTATEHANDLE__, h_to_state_: ?*SPSTATEHANDLE__, h_rule_: ?*SPSTATEHANDLE__, weight_: f32, p_prop_info_: ?*const SPPROPERTYINFO) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).AddRuleTransition(@as(*const ISpGrammarBuilder, @ptrCast(self)), h_from_state_, h_to_state_, h_rule_, weight_, p_prop_info_);
            }
            pub inline fn addResource(self: *const T, h_rule_state_: ?*SPSTATEHANDLE__, psz_resource_name_: ?[*:0]const u16, psz_resource_value_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).AddResource(@as(*const ISpGrammarBuilder, @ptrCast(self)), h_rule_state_, psz_resource_name_, psz_resource_value_);
            }
            pub inline fn commit(self: *const T, dw_reserved_: u32) HRESULT {
                return @as(*const ISpGrammarBuilder.VTable, @ptrCast(self.vtable)).Commit(@as(*const ISpGrammarBuilder, @ptrCast(self)), dw_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPLOADOPTIONS = enum(i32) {
    STATIC = 0,
    DYNAMIC = 1,
};
pub const SPLO_STATIC = SPLOADOPTIONS.STATIC;
pub const SPLO_DYNAMIC = SPLOADOPTIONS.DYNAMIC;

const IID_ISpRecoGrammar_Value = Guid.initString("2177db29-7f45-47d0-8554-067e91c80502");
pub const IID_ISpRecoGrammar = &IID_ISpRecoGrammar_Value;
pub const ISpRecoGrammar = extern struct {
    pub const VTable = extern struct {
        base: ISpGrammarBuilder.VTable,
        GetGrammarId: *const fn (
            self: *const ISpRecoGrammar,
            pull_grammar_id: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecoContext: *const fn (
            self: *const ISpRecoGrammar,
            pp_reco_ctxt: ?*?*ISpRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromFile: *const fn (
            self: *const ISpRecoGrammar,
            psz_file_name: ?[*:0]const u16,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromObject: *const fn (
            self: *const ISpRecoGrammar,
            rcid: ?*const Guid,
            psz_grammar_name: ?[*:0]const u16,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromResource: *const fn (
            self: *const ISpRecoGrammar,
            h_module: ?HINSTANCE,
            psz_resource_name: ?[*:0]const u16,
            psz_resource_type: ?[*:0]const u16,
            w_language: u16,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromMemory: *const fn (
            self: *const ISpRecoGrammar,
            p_grammar: ?*const SPBINARYGRAMMAR,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromProprietaryGrammar: *const fn (
            self: *const ISpRecoGrammar,
            rguid_param: ?*const Guid,
            psz_string_param: ?[*:0]const u16,
            pv_data_prarm: ?*const anyopaque,
            cb_data_size: u32,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRuleState: *const fn (
            self: *const ISpRecoGrammar,
            psz_name: ?[*:0]const u16,
            p_reserved: ?*anyopaque,
            new_state: SPRULESTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRuleIdState: *const fn (
            self: *const ISpRecoGrammar,
            ul_rule_id: u32,
            new_state: SPRULESTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadDictation: *const fn (
            self: *const ISpRecoGrammar,
            psz_topic_name: ?[*:0]const u16,
            options: SPLOADOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnloadDictation: *const fn (
            self: *const ISpRecoGrammar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDictationState: *const fn (
            self: *const ISpRecoGrammar,
            new_state: SPRULESTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWordSequenceData: *const fn (
            self: *const ISpRecoGrammar,
            p_text: ?[*:0]const u16,
            cch_text: u32,
            p_info: ?*const SPTEXTSELECTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextSelection: *const fn (
            self: *const ISpRecoGrammar,
            p_info: ?*const SPTEXTSELECTIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPronounceable: *const fn (
            self: *const ISpRecoGrammar,
            psz_word: ?[*:0]const u16,
            p_word_pronounceable: ?*SPWORDPRONOUNCEABLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGrammarState: *const fn (
            self: *const ISpRecoGrammar,
            e_grammar_state: SPGRAMMARSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCmd: *const fn (
            self: *const ISpRecoGrammar,
            p_stream: ?*IStream,
            ppsz_co_mem_error_text: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGrammarState: *const fn (
            self: *const ISpRecoGrammar,
            pe_grammar_state: ?*SPGRAMMARSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpGrammarBuilder.MethodMixin(T);
            pub inline fn getGrammarId(self: *const T, pull_grammar_id_: ?*u64) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).GetGrammarId(@as(*const ISpRecoGrammar, @ptrCast(self)), pull_grammar_id_);
            }
            pub inline fn getRecoContext(self: *const T, pp_reco_ctxt_: ?*?*ISpRecoContext) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).GetRecoContext(@as(*const ISpRecoGrammar, @ptrCast(self)), pp_reco_ctxt_);
            }
            pub inline fn loadCmdFromFile(self: *const T, psz_file_name_: ?[*:0]const u16, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadCmdFromFile(@as(*const ISpRecoGrammar, @ptrCast(self)), psz_file_name_, options_);
            }
            pub inline fn loadCmdFromObject(self: *const T, rcid_: ?*const Guid, psz_grammar_name_: ?[*:0]const u16, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadCmdFromObject(@as(*const ISpRecoGrammar, @ptrCast(self)), rcid_, psz_grammar_name_, options_);
            }
            pub inline fn loadCmdFromResource(self: *const T, h_module_: ?HINSTANCE, psz_resource_name_: ?[*:0]const u16, psz_resource_type_: ?[*:0]const u16, w_language_: u16, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadCmdFromResource(@as(*const ISpRecoGrammar, @ptrCast(self)), h_module_, psz_resource_name_, psz_resource_type_, w_language_, options_);
            }
            pub inline fn loadCmdFromMemory(self: *const T, p_grammar_: ?*const SPBINARYGRAMMAR, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadCmdFromMemory(@as(*const ISpRecoGrammar, @ptrCast(self)), p_grammar_, options_);
            }
            pub inline fn loadCmdFromProprietaryGrammar(self: *const T, rguid_param_: ?*const Guid, psz_string_param_: ?[*:0]const u16, pv_data_prarm_: ?*const anyopaque, cb_data_size_: u32, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadCmdFromProprietaryGrammar(@as(*const ISpRecoGrammar, @ptrCast(self)), rguid_param_, psz_string_param_, pv_data_prarm_, cb_data_size_, options_);
            }
            pub inline fn setRuleState(self: *const T, psz_name_: ?[*:0]const u16, p_reserved_: ?*anyopaque, new_state_: SPRULESTATE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetRuleState(@as(*const ISpRecoGrammar, @ptrCast(self)), psz_name_, p_reserved_, new_state_);
            }
            pub inline fn setRuleIdState(self: *const T, ul_rule_id_: u32, new_state_: SPRULESTATE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetRuleIdState(@as(*const ISpRecoGrammar, @ptrCast(self)), ul_rule_id_, new_state_);
            }
            pub inline fn loadDictation(self: *const T, psz_topic_name_: ?[*:0]const u16, options_: SPLOADOPTIONS) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).LoadDictation(@as(*const ISpRecoGrammar, @ptrCast(self)), psz_topic_name_, options_);
            }
            pub inline fn unloadDictation(self: *const T) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).UnloadDictation(@as(*const ISpRecoGrammar, @ptrCast(self)));
            }
            pub inline fn setDictationState(self: *const T, new_state_: SPRULESTATE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetDictationState(@as(*const ISpRecoGrammar, @ptrCast(self)), new_state_);
            }
            pub inline fn setWordSequenceData(self: *const T, p_text_: ?[*:0]const u16, cch_text_: u32, p_info_: ?*const SPTEXTSELECTIONINFO) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetWordSequenceData(@as(*const ISpRecoGrammar, @ptrCast(self)), p_text_, cch_text_, p_info_);
            }
            pub inline fn setTextSelection(self: *const T, p_info_: ?*const SPTEXTSELECTIONINFO) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetTextSelection(@as(*const ISpRecoGrammar, @ptrCast(self)), p_info_);
            }
            pub inline fn isPronounceable(self: *const T, psz_word_: ?[*:0]const u16, p_word_pronounceable_: ?*SPWORDPRONOUNCEABLE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).IsPronounceable(@as(*const ISpRecoGrammar, @ptrCast(self)), psz_word_, p_word_pronounceable_);
            }
            pub inline fn setGrammarState(self: *const T, e_grammar_state_: SPGRAMMARSTATE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SetGrammarState(@as(*const ISpRecoGrammar, @ptrCast(self)), e_grammar_state_);
            }
            pub inline fn saveCmd(self: *const T, p_stream_: ?*IStream, ppsz_co_mem_error_text_: ?*?PWSTR) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).SaveCmd(@as(*const ISpRecoGrammar, @ptrCast(self)), p_stream_, ppsz_co_mem_error_text_);
            }
            pub inline fn getGrammarState(self: *const T, pe_grammar_state_: ?*SPGRAMMARSTATE) HRESULT {
                return @as(*const ISpRecoGrammar.VTable, @ptrCast(self.vtable)).GetGrammarState(@as(*const ISpRecoGrammar, @ptrCast(self)), pe_grammar_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPMATCHINGMODE = enum(i32) {
    AllWords = 0,
    Subsequence = 1,
    OrderedSubset = 3,
    SubsequenceContentRequired = 5,
    OrderedSubsetContentRequired = 7,
};
pub const AllWords = SPMATCHINGMODE.AllWords;
pub const Subsequence = SPMATCHINGMODE.Subsequence;
pub const OrderedSubset = SPMATCHINGMODE.OrderedSubset;
pub const SubsequenceContentRequired = SPMATCHINGMODE.SubsequenceContentRequired;
pub const OrderedSubsetContentRequired = SPMATCHINGMODE.OrderedSubsetContentRequired;

pub const PHONETICALPHABET = enum(i32) {
    Ipa = 0,
    Ups = 1,
    Sapi = 2,
};
pub const PA_Ipa = PHONETICALPHABET.Ipa;
pub const PA_Ups = PHONETICALPHABET.Ups;
pub const PA_Sapi = PHONETICALPHABET.Sapi;

const IID_ISpGrammarBuilder2_Value = Guid.initString("8ab10026-20cc-4b20-8c22-a49c9ba78f60");
pub const IID_ISpGrammarBuilder2 = &IID_ISpGrammarBuilder2_Value;
pub const ISpGrammarBuilder2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTextSubset: *const fn (
            self: *const ISpGrammarBuilder2,
            h_from_state: ?*SPSTATEHANDLE__,
            h_to_state: ?*SPSTATEHANDLE__,
            psz: ?[*:0]const u16,
            e_match_mode: SPMATCHINGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPhoneticAlphabet: *const fn (
            self: *const ISpGrammarBuilder2,
            phonetic_a_lphabet: PHONETICALPHABET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addTextSubset(self: *const T, h_from_state_: ?*SPSTATEHANDLE__, h_to_state_: ?*SPSTATEHANDLE__, psz_: ?[*:0]const u16, e_match_mode_: SPMATCHINGMODE) HRESULT {
                return @as(*const ISpGrammarBuilder2.VTable, @ptrCast(self.vtable)).AddTextSubset(@as(*const ISpGrammarBuilder2, @ptrCast(self)), h_from_state_, h_to_state_, psz_, e_match_mode_);
            }
            pub inline fn setPhoneticAlphabet(self: *const T, phonetic_a_lphabet_: PHONETICALPHABET) HRESULT {
                return @as(*const ISpGrammarBuilder2.VTable, @ptrCast(self.vtable)).SetPhoneticAlphabet(@as(*const ISpGrammarBuilder2, @ptrCast(self)), phonetic_a_lphabet_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRecoGrammar2_Value = Guid.initString("4b37bc9e-9ed6-44a3-93d3-18f022b79ec3");
pub const IID_ISpRecoGrammar2 = &IID_ISpRecoGrammar2_Value;
pub const ISpRecoGrammar2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRules: *const fn (
            self: *const ISpRecoGrammar2,
            pp_co_mem_rules: ?*?*SPRULE,
            pu_num_rules: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromFile2: *const fn (
            self: *const ISpRecoGrammar2,
            psz_file_name: ?[*:0]const u16,
            options: SPLOADOPTIONS,
            psz_sharing_uri: ?[*:0]const u16,
            psz_base_uri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCmdFromMemory2: *const fn (
            self: *const ISpRecoGrammar2,
            p_grammar: ?*const SPBINARYGRAMMAR,
            options: SPLOADOPTIONS,
            psz_sharing_uri: ?[*:0]const u16,
            psz_base_uri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRulePriority: *const fn (
            self: *const ISpRecoGrammar2,
            psz_rule_name: ?[*:0]const u16,
            ul_rule_id: u32,
            n_rule_priority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRuleWeight: *const fn (
            self: *const ISpRecoGrammar2,
            psz_rule_name: ?[*:0]const u16,
            ul_rule_id: u32,
            fl_weight: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDictationWeight: *const fn (
            self: *const ISpRecoGrammar2,
            fl_weight: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGrammarLoader: *const fn (
            self: *const ISpRecoGrammar2,
            p_loader: ?*ISpeechResourceLoader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSMLSecurityManager: *const fn (
            self: *const ISpRecoGrammar2,
            p_s_m_l_security_manager: ?*IInternetSecurityManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRules(self: *const T, pp_co_mem_rules_: ?*?*SPRULE, pu_num_rules_: ?*u32) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).GetRules(@as(*const ISpRecoGrammar2, @ptrCast(self)), pp_co_mem_rules_, pu_num_rules_);
            }
            pub inline fn loadCmdFromFile2(self: *const T, psz_file_name_: ?[*:0]const u16, options_: SPLOADOPTIONS, psz_sharing_uri_: ?[*:0]const u16, psz_base_uri_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).LoadCmdFromFile2(@as(*const ISpRecoGrammar2, @ptrCast(self)), psz_file_name_, options_, psz_sharing_uri_, psz_base_uri_);
            }
            pub inline fn loadCmdFromMemory2(self: *const T, p_grammar_: ?*const SPBINARYGRAMMAR, options_: SPLOADOPTIONS, psz_sharing_uri_: ?[*:0]const u16, psz_base_uri_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).LoadCmdFromMemory2(@as(*const ISpRecoGrammar2, @ptrCast(self)), p_grammar_, options_, psz_sharing_uri_, psz_base_uri_);
            }
            pub inline fn setRulePriority(self: *const T, psz_rule_name_: ?[*:0]const u16, ul_rule_id_: u32, n_rule_priority_: i32) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).SetRulePriority(@as(*const ISpRecoGrammar2, @ptrCast(self)), psz_rule_name_, ul_rule_id_, n_rule_priority_);
            }
            pub inline fn setRuleWeight(self: *const T, psz_rule_name_: ?[*:0]const u16, ul_rule_id_: u32, fl_weight_: f32) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).SetRuleWeight(@as(*const ISpRecoGrammar2, @ptrCast(self)), psz_rule_name_, ul_rule_id_, fl_weight_);
            }
            pub inline fn setDictationWeight(self: *const T, fl_weight_: f32) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).SetDictationWeight(@as(*const ISpRecoGrammar2, @ptrCast(self)), fl_weight_);
            }
            pub inline fn setGrammarLoader(self: *const T, p_loader_: ?*ISpeechResourceLoader) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).SetGrammarLoader(@as(*const ISpRecoGrammar2, @ptrCast(self)), p_loader_);
            }
            pub inline fn setSMLSecurityManager(self: *const T, p_s_m_l_security_manager_: ?*IInternetSecurityManager) HRESULT {
                return @as(*const ISpRecoGrammar2.VTable, @ptrCast(self.vtable)).SetSMLSecurityManager(@as(*const ISpRecoGrammar2, @ptrCast(self)), p_s_m_l_security_manager_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechResourceLoader_Value = Guid.initString("b9ac5783-fcd0-4b21-b119-b4f8da8fd2c3");
pub const IID_ISpeechResourceLoader = &IID_ISpeechResourceLoader_Value;
pub const ISpeechResourceLoader = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        LoadResource: *const fn (
            self: *const ISpeechResourceLoader,
            bstr_resource_uri: ?BSTR,
            f_always_reload: i16,
            p_stream: ?*?*IUnknown,
            pbstr_m_i_m_e_type: ?*?BSTR,
            pf_modified: ?*i16,
            pbstr_redirect_url: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalCopy: *const fn (
            self: *const ISpeechResourceLoader,
            bstr_resource_uri: ?BSTR,
            pbstr_local_path: ?*?BSTR,
            pbstr_m_i_m_e_type: ?*?BSTR,
            pbstr_redirect_url: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseLocalCopy: *const fn (
            self: *const ISpeechResourceLoader,
            pbstr_local_path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn loadResource(self: *const T, bstr_resource_uri_: ?BSTR, f_always_reload_: i16, p_stream_: ?*?*IUnknown, pbstr_m_i_m_e_type_: ?*?BSTR, pf_modified_: ?*i16, pbstr_redirect_url_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechResourceLoader.VTable, @ptrCast(self.vtable)).LoadResource(@as(*const ISpeechResourceLoader, @ptrCast(self)), bstr_resource_uri_, f_always_reload_, p_stream_, pbstr_m_i_m_e_type_, pf_modified_, pbstr_redirect_url_);
            }
            pub inline fn getLocalCopy(self: *const T, bstr_resource_uri_: ?BSTR, pbstr_local_path_: ?*?BSTR, pbstr_m_i_m_e_type_: ?*?BSTR, pbstr_redirect_url_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechResourceLoader.VTable, @ptrCast(self.vtable)).GetLocalCopy(@as(*const ISpeechResourceLoader, @ptrCast(self)), bstr_resource_uri_, pbstr_local_path_, pbstr_m_i_m_e_type_, pbstr_redirect_url_);
            }
            pub inline fn releaseLocalCopy(self: *const T, pbstr_local_path_: ?BSTR) HRESULT {
                return @as(*const ISpeechResourceLoader.VTable, @ptrCast(self.vtable)).ReleaseLocalCopy(@as(*const ISpeechResourceLoader, @ptrCast(self)), pbstr_local_path_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECOCONTEXTSTATUS = extern struct {
    eInterference: SPINTERFERENCE,
    szRequestTypeOfUI: [255]u16,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const SPBOOKMARKOPTIONS = enum(i32) {
    NONE = 0,
    PAUSE = 1,
    AHEAD = 2,
    TIME_UNITS = 4,
};
pub const SPBO_NONE = SPBOOKMARKOPTIONS.NONE;
pub const SPBO_PAUSE = SPBOOKMARKOPTIONS.PAUSE;
pub const SPBO_AHEAD = SPBOOKMARKOPTIONS.AHEAD;
pub const SPBO_TIME_UNITS = SPBOOKMARKOPTIONS.TIME_UNITS;

pub const SPAUDIOOPTIONS = enum(i32) {
    NONE = 0,
    RETAIN_AUDIO = 1,
};
pub const SPAO_NONE = SPAUDIOOPTIONS.NONE;
pub const SPAO_RETAIN_AUDIO = SPAUDIOOPTIONS.RETAIN_AUDIO;

const IID_ISpRecoContext_Value = Guid.initString("f740a62f-7c15-489e-8234-940a33d9272d");
pub const IID_ISpRecoContext = &IID_ISpRecoContext_Value;
pub const ISpRecoContext = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        GetRecognizer: *const fn (
            self: *const ISpRecoContext,
            pp_recognizer: ?*?*ISpRecognizer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateGrammar: *const fn (
            self: *const ISpRecoContext,
            ull_grammar_id: u64,
            pp_grammar: ?*?*ISpRecoGrammar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ISpRecoContext,
            p_status: ?*SPRECOCONTEXTSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxAlternates: *const fn (
            self: *const ISpRecoContext,
            pc_alternates: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxAlternates: *const fn (
            self: *const ISpRecoContext,
            c_alternates: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioOptions: *const fn (
            self: *const ISpRecoContext,
            options: SPAUDIOOPTIONS,
            p_audio_format_id: ?*const Guid,
            p_wave_format_ex: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioOptions: *const fn (
            self: *const ISpRecoContext,
            p_options: ?*SPAUDIOOPTIONS,
            p_audio_format_id: ?*Guid,
            pp_co_mem_w_f_e_x: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeserializeResult: *const fn (
            self: *const ISpRecoContext,
            p_serialized_result: ?*const SPSERIALIZEDRESULT,
            pp_result: ?*?*ISpRecoResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Bookmark: *const fn (
            self: *const ISpRecoContext,
            options: SPBOOKMARKOPTIONS,
            ull_stream_position: u64,
            lparam_event: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdaptationData: *const fn (
            self: *const ISpRecoContext,
            p_adaptation_data: ?[*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const ISpRecoContext,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const ISpRecoContext,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVoice: *const fn (
            self: *const ISpRecoContext,
            p_voice: ?*ISpVoice,
            f_allow_format_changes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVoice: *const fn (
            self: *const ISpRecoContext,
            pp_voice: ?*?*ISpVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVoicePurgeEvent: *const fn (
            self: *const ISpRecoContext,
            ull_event_interest: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVoicePurgeEvent: *const fn (
            self: *const ISpRecoContext,
            pull_event_interest: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContextState: *const fn (
            self: *const ISpRecoContext,
            e_context_state: SPCONTEXTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextState: *const fn (
            self: *const ISpRecoContext,
            pe_context_state: ?*SPCONTEXTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpEventSource.MethodMixin(T);
            pub inline fn getRecognizer(self: *const T, pp_recognizer_: ?*?*ISpRecognizer) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetRecognizer(@as(*const ISpRecoContext, @ptrCast(self)), pp_recognizer_);
            }
            pub inline fn createGrammar(self: *const T, ull_grammar_id_: u64, pp_grammar_: ?*?*ISpRecoGrammar) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).CreateGrammar(@as(*const ISpRecoContext, @ptrCast(self)), ull_grammar_id_, pp_grammar_);
            }
            pub inline fn getStatus(self: *const T, p_status_: ?*SPRECOCONTEXTSTATUS) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ISpRecoContext, @ptrCast(self)), p_status_);
            }
            pub inline fn getMaxAlternates(self: *const T, pc_alternates_: ?*u32) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetMaxAlternates(@as(*const ISpRecoContext, @ptrCast(self)), pc_alternates_);
            }
            pub inline fn setMaxAlternates(self: *const T, c_alternates_: u32) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetMaxAlternates(@as(*const ISpRecoContext, @ptrCast(self)), c_alternates_);
            }
            pub inline fn setAudioOptions(self: *const T, options_: SPAUDIOOPTIONS, p_audio_format_id_: ?*const Guid, p_wave_format_ex_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetAudioOptions(@as(*const ISpRecoContext, @ptrCast(self)), options_, p_audio_format_id_, p_wave_format_ex_);
            }
            pub inline fn getAudioOptions(self: *const T, p_options_: ?*SPAUDIOOPTIONS, p_audio_format_id_: ?*Guid, pp_co_mem_w_f_e_x_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetAudioOptions(@as(*const ISpRecoContext, @ptrCast(self)), p_options_, p_audio_format_id_, pp_co_mem_w_f_e_x_);
            }
            pub inline fn deserializeResult(self: *const T, p_serialized_result_: ?*const SPSERIALIZEDRESULT, pp_result_: ?*?*ISpRecoResult) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).DeserializeResult(@as(*const ISpRecoContext, @ptrCast(self)), p_serialized_result_, pp_result_);
            }
            pub inline fn bookmark(self: *const T, options_: SPBOOKMARKOPTIONS, ull_stream_position_: u64, lparam_event_: LPARAM) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).Bookmark(@as(*const ISpRecoContext, @ptrCast(self)), options_, ull_stream_position_, lparam_event_);
            }
            pub inline fn setAdaptationData(self: *const T, p_adaptation_data_: ?[*:0]const u16, cch_: u32) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetAdaptationData(@as(*const ISpRecoContext, @ptrCast(self)), p_adaptation_data_, cch_);
            }
            pub inline fn pause(self: *const T, dw_reserved_: u32) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).Pause(@as(*const ISpRecoContext, @ptrCast(self)), dw_reserved_);
            }
            pub inline fn @"resume"(self: *const T, dw_reserved_: u32) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).Resume(@as(*const ISpRecoContext, @ptrCast(self)), dw_reserved_);
            }
            pub inline fn setVoice(self: *const T, p_voice_: ?*ISpVoice, f_allow_format_changes_: BOOL) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetVoice(@as(*const ISpRecoContext, @ptrCast(self)), p_voice_, f_allow_format_changes_);
            }
            pub inline fn getVoice(self: *const T, pp_voice_: ?*?*ISpVoice) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetVoice(@as(*const ISpRecoContext, @ptrCast(self)), pp_voice_);
            }
            pub inline fn setVoicePurgeEvent(self: *const T, ull_event_interest_: u64) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetVoicePurgeEvent(@as(*const ISpRecoContext, @ptrCast(self)), ull_event_interest_);
            }
            pub inline fn getVoicePurgeEvent(self: *const T, pull_event_interest_: ?*u64) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetVoicePurgeEvent(@as(*const ISpRecoContext, @ptrCast(self)), pull_event_interest_);
            }
            pub inline fn setContextState(self: *const T, e_context_state_: SPCONTEXTSTATE) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).SetContextState(@as(*const ISpRecoContext, @ptrCast(self)), e_context_state_);
            }
            pub inline fn getContextState(self: *const T, pe_context_state_: ?*SPCONTEXTSTATE) HRESULT {
                return @as(*const ISpRecoContext.VTable, @ptrCast(self.vtable)).GetContextState(@as(*const ISpRecoContext, @ptrCast(self)), pe_context_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPGRAMMAROPTIONS = enum(i32) {
    SAPI = 1,
    SRGS = 2,
    UPS = 4,
    SRGS_MS_SCRIPT = 8,
    SRGS_W3C_SCRIPT = 256,
    SRGS_STG_SCRIPT = 512,
    SRGS_SCRIPT = 778,
    FILE = 16,
    HTTP = 32,
    RES = 64,
    OBJECT = 128,
    DEFAULT = 1019,
    ALL = 1023,
};
pub const SPGO_SAPI = SPGRAMMAROPTIONS.SAPI;
pub const SPGO_SRGS = SPGRAMMAROPTIONS.SRGS;
pub const SPGO_UPS = SPGRAMMAROPTIONS.UPS;
pub const SPGO_SRGS_MS_SCRIPT = SPGRAMMAROPTIONS.SRGS_MS_SCRIPT;
pub const SPGO_SRGS_W3C_SCRIPT = SPGRAMMAROPTIONS.SRGS_W3C_SCRIPT;
pub const SPGO_SRGS_STG_SCRIPT = SPGRAMMAROPTIONS.SRGS_STG_SCRIPT;
pub const SPGO_SRGS_SCRIPT = SPGRAMMAROPTIONS.SRGS_SCRIPT;
pub const SPGO_FILE = SPGRAMMAROPTIONS.FILE;
pub const SPGO_HTTP = SPGRAMMAROPTIONS.HTTP;
pub const SPGO_RES = SPGRAMMAROPTIONS.RES;
pub const SPGO_OBJECT = SPGRAMMAROPTIONS.OBJECT;
pub const SPGO_DEFAULT = SPGRAMMAROPTIONS.DEFAULT;
pub const SPGO_ALL = SPGRAMMAROPTIONS.ALL;

pub const SPADAPTATIONSETTINGS = enum(i32) {
    Default = 0,
    CurrentRecognizer = 1,
    RecoProfile = 2,
    Immediate = 4,
    Reset = 8,
    HighVolumeDataSource = 16,
};
pub const SPADS_Default = SPADAPTATIONSETTINGS.Default;
pub const SPADS_CurrentRecognizer = SPADAPTATIONSETTINGS.CurrentRecognizer;
pub const SPADS_RecoProfile = SPADAPTATIONSETTINGS.RecoProfile;
pub const SPADS_Immediate = SPADAPTATIONSETTINGS.Immediate;
pub const SPADS_Reset = SPADAPTATIONSETTINGS.Reset;
pub const SPADS_HighVolumeDataSource = SPADAPTATIONSETTINGS.HighVolumeDataSource;

pub const SPADAPTATIONRELEVANCE = enum(i32) {
    Unknown = 0,
    Low = 1,
    Medium = 2,
    High = 3,
};
pub const SPAR_Unknown = SPADAPTATIONRELEVANCE.Unknown;
pub const SPAR_Low = SPADAPTATIONRELEVANCE.Low;
pub const SPAR_Medium = SPADAPTATIONRELEVANCE.Medium;
pub const SPAR_High = SPADAPTATIONRELEVANCE.High;

const IID_ISpRecoContext2_Value = Guid.initString("bead311c-52ff-437f-9464-6b21054ca73d");
pub const IID_ISpRecoContext2 = &IID_ISpRecoContext2_Value;
pub const ISpRecoContext2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGrammarOptions: *const fn (
            self: *const ISpRecoContext2,
            e_grammar_options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGrammarOptions: *const fn (
            self: *const ISpRecoContext2,
            pe_grammar_options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdaptationData2: *const fn (
            self: *const ISpRecoContext2,
            p_adaptation_data: ?[*:0]const u16,
            cch: u32,
            p_topic_name: ?[*:0]const u16,
            e_adaptation_settings: u32,
            e_relevance: SPADAPTATIONRELEVANCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setGrammarOptions(self: *const T, e_grammar_options_: u32) HRESULT {
                return @as(*const ISpRecoContext2.VTable, @ptrCast(self.vtable)).SetGrammarOptions(@as(*const ISpRecoContext2, @ptrCast(self)), e_grammar_options_);
            }
            pub inline fn getGrammarOptions(self: *const T, pe_grammar_options_: ?*u32) HRESULT {
                return @as(*const ISpRecoContext2.VTable, @ptrCast(self.vtable)).GetGrammarOptions(@as(*const ISpRecoContext2, @ptrCast(self)), pe_grammar_options_);
            }
            pub inline fn setAdaptationData2(self: *const T, p_adaptation_data_: ?[*:0]const u16, cch_: u32, p_topic_name_: ?[*:0]const u16, e_adaptation_settings_: u32, e_relevance_: SPADAPTATIONRELEVANCE) HRESULT {
                return @as(*const ISpRecoContext2.VTable, @ptrCast(self.vtable)).SetAdaptationData2(@as(*const ISpRecoContext2, @ptrCast(self)), p_adaptation_data_, cch_, p_topic_name_, e_adaptation_settings_, e_relevance_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpProperties_Value = Guid.initString("5b4fb971-b115-4de1-ad97-e482e3bf6ee4");
pub const IID_ISpProperties = &IID_ISpProperties_Value;
pub const ISpProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPropertyNum: *const fn (
            self: *const ISpProperties,
            p_name: ?[*:0]const u16,
            l_value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyNum: *const fn (
            self: *const ISpProperties,
            p_name: ?[*:0]const u16,
            pl_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPropertyString: *const fn (
            self: *const ISpProperties,
            p_name: ?[*:0]const u16,
            p_value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyString: *const fn (
            self: *const ISpProperties,
            p_name: ?[*:0]const u16,
            pp_co_mem_value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setPropertyNum(self: *const T, p_name_: ?[*:0]const u16, l_value_: i32) HRESULT {
                return @as(*const ISpProperties.VTable, @ptrCast(self.vtable)).SetPropertyNum(@as(*const ISpProperties, @ptrCast(self)), p_name_, l_value_);
            }
            pub inline fn getPropertyNum(self: *const T, p_name_: ?[*:0]const u16, pl_value_: ?*i32) HRESULT {
                return @as(*const ISpProperties.VTable, @ptrCast(self.vtable)).GetPropertyNum(@as(*const ISpProperties, @ptrCast(self)), p_name_, pl_value_);
            }
            pub inline fn setPropertyString(self: *const T, p_name_: ?[*:0]const u16, p_value_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpProperties.VTable, @ptrCast(self.vtable)).SetPropertyString(@as(*const ISpProperties, @ptrCast(self)), p_name_, p_value_);
            }
            pub inline fn getPropertyString(self: *const T, p_name_: ?[*:0]const u16, pp_co_mem_value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpProperties.VTable, @ptrCast(self.vtable)).GetPropertyString(@as(*const ISpProperties, @ptrCast(self)), p_name_, pp_co_mem_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECOGNIZERSTATUS = extern struct {
    AudioStatus: SPAUDIOSTATUS,
    ullRecognitionStreamPos: u64,
    ulStreamNumber: u32,
    ulNumActive: u32,
    clsidEngine: Guid,
    cLangIDs: u32,
    aLangID: [20]u16,
    ullRecognitionStreamTime: u64,
};

pub const SPWAVEFORMATTYPE = enum(i32) {
    INPUT = 0,
    SRENGINE = 1,
};
pub const SPWF_INPUT = SPWAVEFORMATTYPE.INPUT;
pub const SPWF_SRENGINE = SPWAVEFORMATTYPE.SRENGINE;

pub const SPRECOSTATE = enum(i32) {
    INACTIVE = 0,
    ACTIVE = 1,
    ACTIVE_ALWAYS = 2,
    INACTIVE_WITH_PURGE = 3,
    NUM_STATES = 4,
};
pub const SPRST_INACTIVE = SPRECOSTATE.INACTIVE;
pub const SPRST_ACTIVE = SPRECOSTATE.ACTIVE;
pub const SPRST_ACTIVE_ALWAYS = SPRECOSTATE.ACTIVE_ALWAYS;
pub const SPRST_INACTIVE_WITH_PURGE = SPRECOSTATE.INACTIVE_WITH_PURGE;
pub const SPRST_NUM_STATES = SPRECOSTATE.NUM_STATES;

const IID_ISpRecognizer_Value = Guid.initString("c2b5f241-daa0-4507-9e16-5a1eaa2b7a5c");
pub const IID_ISpRecognizer = &IID_ISpRecognizer_Value;
pub const ISpRecognizer = extern struct {
    pub const VTable = extern struct {
        base: ISpProperties.VTable,
        SetRecognizer: *const fn (
            self: *const ISpRecognizer,
            p_recognizer: ?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecognizer: *const fn (
            self: *const ISpRecognizer,
            pp_recognizer: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInput: *const fn (
            self: *const ISpRecognizer,
            p_unk_input: ?*IUnknown,
            f_allow_format_changes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputObjectToken: *const fn (
            self: *const ISpRecognizer,
            pp_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStream: *const fn (
            self: *const ISpRecognizer,
            pp_stream: ?*?*ISpStreamFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRecoContext: *const fn (
            self: *const ISpRecognizer,
            pp_new_ctxt: ?*?*ISpRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecoProfile: *const fn (
            self: *const ISpRecognizer,
            pp_token: ?*?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecoProfile: *const fn (
            self: *const ISpRecognizer,
            p_token: ?*ISpObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSharedInstance: *const fn (
            self: *const ISpRecognizer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecoState: *const fn (
            self: *const ISpRecognizer,
            p_state: ?*SPRECOSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecoState: *const fn (
            self: *const ISpRecognizer,
            new_state: SPRECOSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const ISpRecognizer,
            p_status: ?*SPRECOGNIZERSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: *const fn (
            self: *const ISpRecognizer,
            wave_format_type: SPWAVEFORMATTYPE,
            p_format_id: ?*Guid,
            pp_co_mem_w_f_e_x: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUISupported: *const fn (
            self: *const ISpRecognizer,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
            pf_supported: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpRecognizer,
            hwnd_parent: ?HWND,
            psz_title: ?[*:0]const u16,
            psz_type_of_u_i: ?[*:0]const u16,
            pv_extra_data: ?*anyopaque,
            cb_extra_data: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmulateRecognition: *const fn (
            self: *const ISpRecognizer,
            p_phrase: ?*ISpPhrase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpProperties.MethodMixin(T);
            pub inline fn setRecognizer(self: *const T, p_recognizer_: ?*ISpObjectToken) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).SetRecognizer(@as(*const ISpRecognizer, @ptrCast(self)), p_recognizer_);
            }
            pub inline fn getRecognizer(self: *const T, pp_recognizer_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetRecognizer(@as(*const ISpRecognizer, @ptrCast(self)), pp_recognizer_);
            }
            pub inline fn setInput(self: *const T, p_unk_input_: ?*IUnknown, f_allow_format_changes_: BOOL) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).SetInput(@as(*const ISpRecognizer, @ptrCast(self)), p_unk_input_, f_allow_format_changes_);
            }
            pub inline fn getInputObjectToken(self: *const T, pp_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetInputObjectToken(@as(*const ISpRecognizer, @ptrCast(self)), pp_token_);
            }
            pub inline fn getInputStream(self: *const T, pp_stream_: ?*?*ISpStreamFormat) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetInputStream(@as(*const ISpRecognizer, @ptrCast(self)), pp_stream_);
            }
            pub inline fn createRecoContext(self: *const T, pp_new_ctxt_: ?*?*ISpRecoContext) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).CreateRecoContext(@as(*const ISpRecognizer, @ptrCast(self)), pp_new_ctxt_);
            }
            pub inline fn getRecoProfile(self: *const T, pp_token_: ?*?*ISpObjectToken) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetRecoProfile(@as(*const ISpRecognizer, @ptrCast(self)), pp_token_);
            }
            pub inline fn setRecoProfile(self: *const T, p_token_: ?*ISpObjectToken) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).SetRecoProfile(@as(*const ISpRecognizer, @ptrCast(self)), p_token_);
            }
            pub inline fn isSharedInstance(self: *const T) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).IsSharedInstance(@as(*const ISpRecognizer, @ptrCast(self)));
            }
            pub inline fn getRecoState(self: *const T, p_state_: ?*SPRECOSTATE) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetRecoState(@as(*const ISpRecognizer, @ptrCast(self)), p_state_);
            }
            pub inline fn setRecoState(self: *const T, new_state_: SPRECOSTATE) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).SetRecoState(@as(*const ISpRecognizer, @ptrCast(self)), new_state_);
            }
            pub inline fn getStatus(self: *const T, p_status_: ?*SPRECOGNIZERSTATUS) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ISpRecognizer, @ptrCast(self)), p_status_);
            }
            pub inline fn getFormat(self: *const T, wave_format_type_: SPWAVEFORMATTYPE, p_format_id_: ?*Guid, pp_co_mem_w_f_e_x_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const ISpRecognizer, @ptrCast(self)), wave_format_type_, p_format_id_, pp_co_mem_w_f_e_x_);
            }
            pub inline fn isUISupported(self: *const T, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32, pf_supported_: ?*BOOL) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpRecognizer, @ptrCast(self)), psz_type_of_u_i_, pv_extra_data_, cb_extra_data_, pf_supported_);
            }
            pub inline fn displayUI(self: *const T, hwnd_parent_: ?HWND, psz_title_: ?[*:0]const u16, psz_type_of_u_i_: ?[*:0]const u16, pv_extra_data_: ?*anyopaque, cb_extra_data_: u32) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpRecognizer, @ptrCast(self)), hwnd_parent_, psz_title_, psz_type_of_u_i_, pv_extra_data_, cb_extra_data_);
            }
            pub inline fn emulateRecognition(self: *const T, p_phrase_: ?*ISpPhrase) HRESULT {
                return @as(*const ISpRecognizer.VTable, @ptrCast(self.vtable)).EmulateRecognition(@as(*const ISpRecognizer, @ptrCast(self)), p_phrase_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpSerializeState_Value = Guid.initString("21b501a0-0ec7-46c9-92c3-a2bc784c54b9");
pub const IID_ISpSerializeState = &IID_ISpSerializeState_Value;
pub const ISpSerializeState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSerializedState: *const fn (
            self: *const ISpSerializeState,
            ppb_data: ?*?*u8,
            pul_size: ?*u32,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSerializedState: *const fn (
            self: *const ISpSerializeState,
            pb_data: ?*u8,
            ul_size: u32,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSerializedState(self: *const T, ppb_data_: ?*?*u8, pul_size_: ?*u32, dw_reserved_: u32) HRESULT {
                return @as(*const ISpSerializeState.VTable, @ptrCast(self.vtable)).GetSerializedState(@as(*const ISpSerializeState, @ptrCast(self)), ppb_data_, pul_size_, dw_reserved_);
            }
            pub inline fn setSerializedState(self: *const T, pb_data_: ?*u8, ul_size_: u32, dw_reserved_: u32) HRESULT {
                return @as(*const ISpSerializeState.VTable, @ptrCast(self.vtable)).SetSerializedState(@as(*const ISpSerializeState, @ptrCast(self)), pb_data_, ul_size_, dw_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRecognizer2_Value = Guid.initString("8fc6d974-c81e-4098-93c5-0147f61ed4d3");
pub const IID_ISpRecognizer2 = &IID_ISpRecognizer2_Value;
pub const ISpRecognizer2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EmulateRecognitionEx: *const fn (
            self: *const ISpRecognizer2,
            p_phrase: ?*ISpPhrase,
            dw_compare_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrainingState: *const fn (
            self: *const ISpRecognizer2,
            f_doing_training: BOOL,
            f_adapt_from_training_data: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetAcousticModelAdaptation: *const fn (
            self: *const ISpRecognizer2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn emulateRecognitionEx(self: *const T, p_phrase_: ?*ISpPhrase, dw_compare_flags_: u32) HRESULT {
                return @as(*const ISpRecognizer2.VTable, @ptrCast(self.vtable)).EmulateRecognitionEx(@as(*const ISpRecognizer2, @ptrCast(self)), p_phrase_, dw_compare_flags_);
            }
            pub inline fn setTrainingState(self: *const T, f_doing_training_: BOOL, f_adapt_from_training_data_: BOOL) HRESULT {
                return @as(*const ISpRecognizer2.VTable, @ptrCast(self.vtable)).SetTrainingState(@as(*const ISpRecognizer2, @ptrCast(self)), f_doing_training_, f_adapt_from_training_data_);
            }
            pub inline fn resetAcousticModelAdaptation(self: *const T) HRESULT {
                return @as(*const ISpRecognizer2.VTable, @ptrCast(self.vtable)).ResetAcousticModelAdaptation(@as(*const ISpRecognizer2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPNORMALIZATIONLIST = extern struct {
    ulSize: u32,
    ppszzNormalizedList: ?*?*u16,
};

const IID_ISpEnginePronunciation_Value = Guid.initString("c360ce4b-76d1-4214-ad68-52657d5083da");
pub const IID_ISpEnginePronunciation = &IID_ISpEnginePronunciation_Value;
pub const ISpEnginePronunciation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Normalize: *const fn (
            self: *const ISpEnginePronunciation,
            psz_word: ?[*:0]const u16,
            psz_left_context: ?[*:0]const u16,
            psz_right_context: ?[*:0]const u16,
            lang_i_d: u16,
            p_normalization_list: ?*SPNORMALIZATIONLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPronunciations: *const fn (
            self: *const ISpEnginePronunciation,
            psz_word: ?[*:0]const u16,
            psz_left_context: ?[*:0]const u16,
            psz_right_context: ?[*:0]const u16,
            lang_i_d: u16,
            p_engine_pronunciation_list: ?*SPWORDPRONUNCIATIONLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn normalize(self: *const T, psz_word_: ?[*:0]const u16, psz_left_context_: ?[*:0]const u16, psz_right_context_: ?[*:0]const u16, lang_i_d_: u16, p_normalization_list_: ?*SPNORMALIZATIONLIST) HRESULT {
                return @as(*const ISpEnginePronunciation.VTable, @ptrCast(self.vtable)).Normalize(@as(*const ISpEnginePronunciation, @ptrCast(self)), psz_word_, psz_left_context_, psz_right_context_, lang_i_d_, p_normalization_list_);
            }
            pub inline fn getPronunciations(self: *const T, psz_word_: ?[*:0]const u16, psz_left_context_: ?[*:0]const u16, psz_right_context_: ?[*:0]const u16, lang_i_d_: u16, p_engine_pronunciation_list_: ?*SPWORDPRONUNCIATIONLIST) HRESULT {
                return @as(*const ISpEnginePronunciation.VTable, @ptrCast(self.vtable)).GetPronunciations(@as(*const ISpEnginePronunciation, @ptrCast(self)), psz_word_, psz_left_context_, psz_right_context_, lang_i_d_, p_engine_pronunciation_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SPDISPLAYTOKEN = extern struct {
    pszLexical: ?[*:0]const u16,
    pszDisplay: ?[*:0]const u16,
    bDisplayAttributes: u8,
};

pub const SPDISPLAYPHRASE = extern struct {
    ulNumTokens: u32,
    pTokens: ?*SPDISPLAYTOKEN,
};

const IID_ISpDisplayAlternates_Value = Guid.initString("c8d7c7e2-0dde-44b7-afe3-b0c991fbeb5e");
pub const IID_ISpDisplayAlternates = &IID_ISpDisplayAlternates_Value;
pub const ISpDisplayAlternates = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayAlternates: *const fn (
            self: *const ISpDisplayAlternates,
            p_phrase: ?*const SPDISPLAYPHRASE,
            c_request_count: u32,
            pp_co_mem_phrases: ?*?*SPDISPLAYPHRASE,
            pc_phrases_returned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullStopTrailSpace: *const fn (
            self: *const ISpDisplayAlternates,
            ul_trail_space: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDisplayAlternates(self: *const T, p_phrase_: ?*const SPDISPLAYPHRASE, c_request_count_: u32, pp_co_mem_phrases_: ?*?*SPDISPLAYPHRASE, pc_phrases_returned_: ?*u32) HRESULT {
                return @as(*const ISpDisplayAlternates.VTable, @ptrCast(self.vtable)).GetDisplayAlternates(@as(*const ISpDisplayAlternates, @ptrCast(self)), p_phrase_, c_request_count_, pp_co_mem_phrases_, pc_phrases_returned_);
            }
            pub inline fn setFullStopTrailSpace(self: *const T, ul_trail_space_: u32) HRESULT {
                return @as(*const ISpDisplayAlternates.VTable, @ptrCast(self.vtable)).SetFullStopTrailSpace(@as(*const ISpDisplayAlternates, @ptrCast(self)), ul_trail_space_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DISPID_SpeechDataKey = enum(i32) {
    SetBinaryValue = 1,
    GetBinaryValue = 2,
    SetStringValue = 3,
    GetStringValue = 4,
    SetLongValue = 5,
    GetlongValue = 6,
    OpenKey = 7,
    CreateKey = 8,
    DeleteKey = 9,
    DeleteValue = 10,
    EnumKeys = 11,
    EnumValues = 12,
};
pub const DISPID_SDKSetBinaryValue = DISPID_SpeechDataKey.SetBinaryValue;
pub const DISPID_SDKGetBinaryValue = DISPID_SpeechDataKey.GetBinaryValue;
pub const DISPID_SDKSetStringValue = DISPID_SpeechDataKey.SetStringValue;
pub const DISPID_SDKGetStringValue = DISPID_SpeechDataKey.GetStringValue;
pub const DISPID_SDKSetLongValue = DISPID_SpeechDataKey.SetLongValue;
pub const DISPID_SDKGetlongValue = DISPID_SpeechDataKey.GetlongValue;
pub const DISPID_SDKOpenKey = DISPID_SpeechDataKey.OpenKey;
pub const DISPID_SDKCreateKey = DISPID_SpeechDataKey.CreateKey;
pub const DISPID_SDKDeleteKey = DISPID_SpeechDataKey.DeleteKey;
pub const DISPID_SDKDeleteValue = DISPID_SpeechDataKey.DeleteValue;
pub const DISPID_SDKEnumKeys = DISPID_SpeechDataKey.EnumKeys;
pub const DISPID_SDKEnumValues = DISPID_SpeechDataKey.EnumValues;

pub const DISPID_SpeechObjectToken = enum(i32) {
    Id = 1,
    DataKey = 2,
    Category = 3,
    GetDescription = 4,
    SetId = 5,
    GetAttribute = 6,
    CreateInstance = 7,
    Remove = 8,
    GetStorageFileName = 9,
    RemoveStorageFileName = 10,
    IsUISupported = 11,
    DisplayUI = 12,
    MatchesAttributes = 13,
};
pub const DISPID_SOTId = DISPID_SpeechObjectToken.Id;
pub const DISPID_SOTDataKey = DISPID_SpeechObjectToken.DataKey;
pub const DISPID_SOTCategory = DISPID_SpeechObjectToken.Category;
pub const DISPID_SOTGetDescription = DISPID_SpeechObjectToken.GetDescription;
pub const DISPID_SOTSetId = DISPID_SpeechObjectToken.SetId;
pub const DISPID_SOTGetAttribute = DISPID_SpeechObjectToken.GetAttribute;
pub const DISPID_SOTCreateInstance = DISPID_SpeechObjectToken.CreateInstance;
pub const DISPID_SOTRemove = DISPID_SpeechObjectToken.Remove;
pub const DISPID_SOTGetStorageFileName = DISPID_SpeechObjectToken.GetStorageFileName;
pub const DISPID_SOTRemoveStorageFileName = DISPID_SpeechObjectToken.RemoveStorageFileName;
pub const DISPID_SOTIsUISupported = DISPID_SpeechObjectToken.IsUISupported;
pub const DISPID_SOTDisplayUI = DISPID_SpeechObjectToken.DisplayUI;
pub const DISPID_SOTMatchesAttributes = DISPID_SpeechObjectToken.MatchesAttributes;

pub const SpeechDataKeyLocation = enum(i32) {
    DefaultLocation = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    CurrentConfig = 5,
};
pub const SDKLDefaultLocation = SpeechDataKeyLocation.DefaultLocation;
pub const SDKLCurrentUser = SpeechDataKeyLocation.CurrentUser;
pub const SDKLLocalMachine = SpeechDataKeyLocation.LocalMachine;
pub const SDKLCurrentConfig = SpeechDataKeyLocation.CurrentConfig;

pub const SpeechTokenContext = enum(u32) {
    InprocServer = 1,
    InprocHandler = 2,
    LocalServer = 4,
    RemoteServer = 16,
    All = 23,
};
pub const STCInprocServer = SpeechTokenContext.InprocServer;
pub const STCInprocHandler = SpeechTokenContext.InprocHandler;
pub const STCLocalServer = SpeechTokenContext.LocalServer;
pub const STCRemoteServer = SpeechTokenContext.RemoteServer;
pub const STCAll = SpeechTokenContext.All;

pub const SpeechTokenShellFolder = enum(i32) {
    AppData = 26,
    LocalAppData = 28,
    CommonAppData = 35,
    FlagCreate = 32768,
};
pub const STSF_AppData = SpeechTokenShellFolder.AppData;
pub const STSF_LocalAppData = SpeechTokenShellFolder.LocalAppData;
pub const STSF_CommonAppData = SpeechTokenShellFolder.CommonAppData;
pub const STSF_FlagCreate = SpeechTokenShellFolder.FlagCreate;

pub const DISPID_SpeechObjectTokens = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SOTsCount = DISPID_SpeechObjectTokens.Count;
pub const DISPID_SOTsItem = DISPID_SpeechObjectTokens.Item;
pub const DISPID_SOTs_NewEnum = DISPID_SpeechObjectTokens._NewEnum;

pub const DISPID_SpeechObjectTokenCategory = enum(i32) {
    Id = 1,
    Default = 2,
    SetId = 3,
    GetDataKey = 4,
    EnumerateTokens = 5,
};
pub const DISPID_SOTCId = DISPID_SpeechObjectTokenCategory.Id;
pub const DISPID_SOTCDefault = DISPID_SpeechObjectTokenCategory.Default;
pub const DISPID_SOTCSetId = DISPID_SpeechObjectTokenCategory.SetId;
pub const DISPID_SOTCGetDataKey = DISPID_SpeechObjectTokenCategory.GetDataKey;
pub const DISPID_SOTCEnumerateTokens = DISPID_SpeechObjectTokenCategory.EnumerateTokens;

pub const SpeechAudioFormatType = enum(i32) {
    Default = -1,
    NoAssignedFormat = 0,
    Text = 1,
    NonStandardFormat = 2,
    ExtendedAudioFormat = 3,
    @"8kHz8BitMono" = 4,
    @"8kHz8BitStereo" = 5,
    @"8kHz16BitMono" = 6,
    @"8kHz16BitStereo" = 7,
    @"11kHz8BitMono" = 8,
    @"11kHz8BitStereo" = 9,
    @"11kHz16BitMono" = 10,
    @"11kHz16BitStereo" = 11,
    @"12kHz8BitMono" = 12,
    @"12kHz8BitStereo" = 13,
    @"12kHz16BitMono" = 14,
    @"12kHz16BitStereo" = 15,
    @"16kHz8BitMono" = 16,
    @"16kHz8BitStereo" = 17,
    @"16kHz16BitMono" = 18,
    @"16kHz16BitStereo" = 19,
    @"22kHz8BitMono" = 20,
    @"22kHz8BitStereo" = 21,
    @"22kHz16BitMono" = 22,
    @"22kHz16BitStereo" = 23,
    @"24kHz8BitMono" = 24,
    @"24kHz8BitStereo" = 25,
    @"24kHz16BitMono" = 26,
    @"24kHz16BitStereo" = 27,
    @"32kHz8BitMono" = 28,
    @"32kHz8BitStereo" = 29,
    @"32kHz16BitMono" = 30,
    @"32kHz16BitStereo" = 31,
    @"44kHz8BitMono" = 32,
    @"44kHz8BitStereo" = 33,
    @"44kHz16BitMono" = 34,
    @"44kHz16BitStereo" = 35,
    @"48kHz8BitMono" = 36,
    @"48kHz8BitStereo" = 37,
    @"48kHz16BitMono" = 38,
    @"48kHz16BitStereo" = 39,
    TrueSpeech_8kHz1BitMono = 40,
    CCITT_ALaw_8kHzMono = 41,
    CCITT_ALaw_8kHzStereo = 42,
    CCITT_ALaw_11kHzMono = 43,
    CCITT_ALaw_11kHzStereo = 44,
    CCITT_ALaw_22kHzMono = 45,
    CCITT_ALaw_22kHzStereo = 46,
    CCITT_ALaw_44kHzMono = 47,
    CCITT_ALaw_44kHzStereo = 48,
    CCITT_uLaw_8kHzMono = 49,
    CCITT_uLaw_8kHzStereo = 50,
    CCITT_uLaw_11kHzMono = 51,
    CCITT_uLaw_11kHzStereo = 52,
    CCITT_uLaw_22kHzMono = 53,
    CCITT_uLaw_22kHzStereo = 54,
    CCITT_uLaw_44kHzMono = 55,
    CCITT_uLaw_44kHzStereo = 56,
    ADPCM_8kHzMono = 57,
    ADPCM_8kHzStereo = 58,
    ADPCM_11kHzMono = 59,
    ADPCM_11kHzStereo = 60,
    ADPCM_22kHzMono = 61,
    ADPCM_22kHzStereo = 62,
    ADPCM_44kHzMono = 63,
    ADPCM_44kHzStereo = 64,
    GSM610_8kHzMono = 65,
    GSM610_11kHzMono = 66,
    GSM610_22kHzMono = 67,
    GSM610_44kHzMono = 68,
};
pub const SAFTDefault = SpeechAudioFormatType.Default;
pub const SAFTNoAssignedFormat = SpeechAudioFormatType.NoAssignedFormat;
pub const SAFTText = SpeechAudioFormatType.Text;
pub const SAFTNonStandardFormat = SpeechAudioFormatType.NonStandardFormat;
pub const SAFTExtendedAudioFormat = SpeechAudioFormatType.ExtendedAudioFormat;
pub const SAFT8kHz8BitMono = SpeechAudioFormatType.@"8kHz8BitMono";
pub const SAFT8kHz8BitStereo = SpeechAudioFormatType.@"8kHz8BitStereo";
pub const SAFT8kHz16BitMono = SpeechAudioFormatType.@"8kHz16BitMono";
pub const SAFT8kHz16BitStereo = SpeechAudioFormatType.@"8kHz16BitStereo";
pub const SAFT11kHz8BitMono = SpeechAudioFormatType.@"11kHz8BitMono";
pub const SAFT11kHz8BitStereo = SpeechAudioFormatType.@"11kHz8BitStereo";
pub const SAFT11kHz16BitMono = SpeechAudioFormatType.@"11kHz16BitMono";
pub const SAFT11kHz16BitStereo = SpeechAudioFormatType.@"11kHz16BitStereo";
pub const SAFT12kHz8BitMono = SpeechAudioFormatType.@"12kHz8BitMono";
pub const SAFT12kHz8BitStereo = SpeechAudioFormatType.@"12kHz8BitStereo";
pub const SAFT12kHz16BitMono = SpeechAudioFormatType.@"12kHz16BitMono";
pub const SAFT12kHz16BitStereo = SpeechAudioFormatType.@"12kHz16BitStereo";
pub const SAFT16kHz8BitMono = SpeechAudioFormatType.@"16kHz8BitMono";
pub const SAFT16kHz8BitStereo = SpeechAudioFormatType.@"16kHz8BitStereo";
pub const SAFT16kHz16BitMono = SpeechAudioFormatType.@"16kHz16BitMono";
pub const SAFT16kHz16BitStereo = SpeechAudioFormatType.@"16kHz16BitStereo";
pub const SAFT22kHz8BitMono = SpeechAudioFormatType.@"22kHz8BitMono";
pub const SAFT22kHz8BitStereo = SpeechAudioFormatType.@"22kHz8BitStereo";
pub const SAFT22kHz16BitMono = SpeechAudioFormatType.@"22kHz16BitMono";
pub const SAFT22kHz16BitStereo = SpeechAudioFormatType.@"22kHz16BitStereo";
pub const SAFT24kHz8BitMono = SpeechAudioFormatType.@"24kHz8BitMono";
pub const SAFT24kHz8BitStereo = SpeechAudioFormatType.@"24kHz8BitStereo";
pub const SAFT24kHz16BitMono = SpeechAudioFormatType.@"24kHz16BitMono";
pub const SAFT24kHz16BitStereo = SpeechAudioFormatType.@"24kHz16BitStereo";
pub const SAFT32kHz8BitMono = SpeechAudioFormatType.@"32kHz8BitMono";
pub const SAFT32kHz8BitStereo = SpeechAudioFormatType.@"32kHz8BitStereo";
pub const SAFT32kHz16BitMono = SpeechAudioFormatType.@"32kHz16BitMono";
pub const SAFT32kHz16BitStereo = SpeechAudioFormatType.@"32kHz16BitStereo";
pub const SAFT44kHz8BitMono = SpeechAudioFormatType.@"44kHz8BitMono";
pub const SAFT44kHz8BitStereo = SpeechAudioFormatType.@"44kHz8BitStereo";
pub const SAFT44kHz16BitMono = SpeechAudioFormatType.@"44kHz16BitMono";
pub const SAFT44kHz16BitStereo = SpeechAudioFormatType.@"44kHz16BitStereo";
pub const SAFT48kHz8BitMono = SpeechAudioFormatType.@"48kHz8BitMono";
pub const SAFT48kHz8BitStereo = SpeechAudioFormatType.@"48kHz8BitStereo";
pub const SAFT48kHz16BitMono = SpeechAudioFormatType.@"48kHz16BitMono";
pub const SAFT48kHz16BitStereo = SpeechAudioFormatType.@"48kHz16BitStereo";
pub const SAFTTrueSpeech_8kHz1BitMono = SpeechAudioFormatType.TrueSpeech_8kHz1BitMono;
pub const SAFTCCITT_ALaw_8kHzMono = SpeechAudioFormatType.CCITT_ALaw_8kHzMono;
pub const SAFTCCITT_ALaw_8kHzStereo = SpeechAudioFormatType.CCITT_ALaw_8kHzStereo;
pub const SAFTCCITT_ALaw_11kHzMono = SpeechAudioFormatType.CCITT_ALaw_11kHzMono;
pub const SAFTCCITT_ALaw_11kHzStereo = SpeechAudioFormatType.CCITT_ALaw_11kHzStereo;
pub const SAFTCCITT_ALaw_22kHzMono = SpeechAudioFormatType.CCITT_ALaw_22kHzMono;
pub const SAFTCCITT_ALaw_22kHzStereo = SpeechAudioFormatType.CCITT_ALaw_22kHzStereo;
pub const SAFTCCITT_ALaw_44kHzMono = SpeechAudioFormatType.CCITT_ALaw_44kHzMono;
pub const SAFTCCITT_ALaw_44kHzStereo = SpeechAudioFormatType.CCITT_ALaw_44kHzStereo;
pub const SAFTCCITT_uLaw_8kHzMono = SpeechAudioFormatType.CCITT_uLaw_8kHzMono;
pub const SAFTCCITT_uLaw_8kHzStereo = SpeechAudioFormatType.CCITT_uLaw_8kHzStereo;
pub const SAFTCCITT_uLaw_11kHzMono = SpeechAudioFormatType.CCITT_uLaw_11kHzMono;
pub const SAFTCCITT_uLaw_11kHzStereo = SpeechAudioFormatType.CCITT_uLaw_11kHzStereo;
pub const SAFTCCITT_uLaw_22kHzMono = SpeechAudioFormatType.CCITT_uLaw_22kHzMono;
pub const SAFTCCITT_uLaw_22kHzStereo = SpeechAudioFormatType.CCITT_uLaw_22kHzStereo;
pub const SAFTCCITT_uLaw_44kHzMono = SpeechAudioFormatType.CCITT_uLaw_44kHzMono;
pub const SAFTCCITT_uLaw_44kHzStereo = SpeechAudioFormatType.CCITT_uLaw_44kHzStereo;
pub const SAFTADPCM_8kHzMono = SpeechAudioFormatType.ADPCM_8kHzMono;
pub const SAFTADPCM_8kHzStereo = SpeechAudioFormatType.ADPCM_8kHzStereo;
pub const SAFTADPCM_11kHzMono = SpeechAudioFormatType.ADPCM_11kHzMono;
pub const SAFTADPCM_11kHzStereo = SpeechAudioFormatType.ADPCM_11kHzStereo;
pub const SAFTADPCM_22kHzMono = SpeechAudioFormatType.ADPCM_22kHzMono;
pub const SAFTADPCM_22kHzStereo = SpeechAudioFormatType.ADPCM_22kHzStereo;
pub const SAFTADPCM_44kHzMono = SpeechAudioFormatType.ADPCM_44kHzMono;
pub const SAFTADPCM_44kHzStereo = SpeechAudioFormatType.ADPCM_44kHzStereo;
pub const SAFTGSM610_8kHzMono = SpeechAudioFormatType.GSM610_8kHzMono;
pub const SAFTGSM610_11kHzMono = SpeechAudioFormatType.GSM610_11kHzMono;
pub const SAFTGSM610_22kHzMono = SpeechAudioFormatType.GSM610_22kHzMono;
pub const SAFTGSM610_44kHzMono = SpeechAudioFormatType.GSM610_44kHzMono;

pub const DISPID_SpeechAudioFormat = enum(i32) {
    Type = 1,
    Guid = 2,
    GetWaveFormatEx = 3,
    SetWaveFormatEx = 4,
};
pub const DISPID_SAFType = DISPID_SpeechAudioFormat.Type;
pub const DISPID_SAFGuid = DISPID_SpeechAudioFormat.Guid;
pub const DISPID_SAFGetWaveFormatEx = DISPID_SpeechAudioFormat.GetWaveFormatEx;
pub const DISPID_SAFSetWaveFormatEx = DISPID_SpeechAudioFormat.SetWaveFormatEx;

pub const DISPID_SpeechBaseStream = enum(i32) {
    Format = 1,
    Read = 2,
    Write = 3,
    Seek = 4,
};
pub const DISPID_SBSFormat = DISPID_SpeechBaseStream.Format;
pub const DISPID_SBSRead = DISPID_SpeechBaseStream.Read;
pub const DISPID_SBSWrite = DISPID_SpeechBaseStream.Write;
pub const DISPID_SBSSeek = DISPID_SpeechBaseStream.Seek;

pub const SpeechStreamSeekPositionType = enum(u32) {
    Start = 0,
    CurrentPosition = 1,
    End = 2,
};
pub const SSSPTRelativeToStart = SpeechStreamSeekPositionType.Start;
pub const SSSPTRelativeToCurrentPosition = SpeechStreamSeekPositionType.CurrentPosition;
pub const SSSPTRelativeToEnd = SpeechStreamSeekPositionType.End;

pub const DISPID_SpeechAudio = enum(i32) {
    Status = 200,
    BufferInfo = 201,
    DefaultFormat = 202,
    Volume = 203,
    BufferNotifySize = 204,
    EventHandle = 205,
    SetState = 206,
};
pub const DISPID_SAStatus = DISPID_SpeechAudio.Status;
pub const DISPID_SABufferInfo = DISPID_SpeechAudio.BufferInfo;
pub const DISPID_SADefaultFormat = DISPID_SpeechAudio.DefaultFormat;
pub const DISPID_SAVolume = DISPID_SpeechAudio.Volume;
pub const DISPID_SABufferNotifySize = DISPID_SpeechAudio.BufferNotifySize;
pub const DISPID_SAEventHandle = DISPID_SpeechAudio.EventHandle;
pub const DISPID_SASetState = DISPID_SpeechAudio.SetState;

pub const SpeechAudioState = enum(i32) {
    Closed = 0,
    Stop = 1,
    Pause = 2,
    Run = 3,
};
pub const SASClosed = SpeechAudioState.Closed;
pub const SASStop = SpeechAudioState.Stop;
pub const SASPause = SpeechAudioState.Pause;
pub const SASRun = SpeechAudioState.Run;

pub const DISPID_SpeechMMSysAudio = enum(i32) {
    DeviceId = 300,
    LineId = 301,
    MMHandle = 302,
};
pub const DISPID_SMSADeviceId = DISPID_SpeechMMSysAudio.DeviceId;
pub const DISPID_SMSALineId = DISPID_SpeechMMSysAudio.LineId;
pub const DISPID_SMSAMMHandle = DISPID_SpeechMMSysAudio.MMHandle;

pub const DISPID_SpeechFileStream = enum(i32) {
    Open = 100,
    Close = 101,
};
pub const DISPID_SFSOpen = DISPID_SpeechFileStream.Open;
pub const DISPID_SFSClose = DISPID_SpeechFileStream.Close;

pub const SpeechStreamFileMode = enum(i32) {
    OpenForRead = 0,
    OpenReadWrite = 1,
    Create = 2,
    CreateForWrite = 3,
};
pub const SSFMOpenForRead = SpeechStreamFileMode.OpenForRead;
pub const SSFMOpenReadWrite = SpeechStreamFileMode.OpenReadWrite;
pub const SSFMCreate = SpeechStreamFileMode.Create;
pub const SSFMCreateForWrite = SpeechStreamFileMode.CreateForWrite;

pub const DISPID_SpeechCustomStream = enum(i32) {
    m = 100,
};
pub const DISPID_SCSBaseStream = DISPID_SpeechCustomStream.m;

pub const DISPID_SpeechMemoryStream = enum(i32) {
    SetData = 100,
    GetData = 101,
};
pub const DISPID_SMSSetData = DISPID_SpeechMemoryStream.SetData;
pub const DISPID_SMSGetData = DISPID_SpeechMemoryStream.GetData;

pub const DISPID_SpeechAudioStatus = enum(i32) {
    FreeBufferSpace = 1,
    NonBlockingIO = 2,
    State = 3,
    CurrentSeekPosition = 4,
    CurrentDevicePosition = 5,
};
pub const DISPID_SASFreeBufferSpace = DISPID_SpeechAudioStatus.FreeBufferSpace;
pub const DISPID_SASNonBlockingIO = DISPID_SpeechAudioStatus.NonBlockingIO;
pub const DISPID_SASState = DISPID_SpeechAudioStatus.State;
pub const DISPID_SASCurrentSeekPosition = DISPID_SpeechAudioStatus.CurrentSeekPosition;
pub const DISPID_SASCurrentDevicePosition = DISPID_SpeechAudioStatus.CurrentDevicePosition;

pub const DISPID_SpeechAudioBufferInfo = enum(i32) {
    MinNotification = 1,
    BufferSize = 2,
    EventBias = 3,
};
pub const DISPID_SABIMinNotification = DISPID_SpeechAudioBufferInfo.MinNotification;
pub const DISPID_SABIBufferSize = DISPID_SpeechAudioBufferInfo.BufferSize;
pub const DISPID_SABIEventBias = DISPID_SpeechAudioBufferInfo.EventBias;

pub const DISPID_SpeechWaveFormatEx = enum(i32) {
    FormatTag = 1,
    Channels = 2,
    SamplesPerSec = 3,
    AvgBytesPerSec = 4,
    BlockAlign = 5,
    BitsPerSample = 6,
    ExtraData = 7,
};
pub const DISPID_SWFEFormatTag = DISPID_SpeechWaveFormatEx.FormatTag;
pub const DISPID_SWFEChannels = DISPID_SpeechWaveFormatEx.Channels;
pub const DISPID_SWFESamplesPerSec = DISPID_SpeechWaveFormatEx.SamplesPerSec;
pub const DISPID_SWFEAvgBytesPerSec = DISPID_SpeechWaveFormatEx.AvgBytesPerSec;
pub const DISPID_SWFEBlockAlign = DISPID_SpeechWaveFormatEx.BlockAlign;
pub const DISPID_SWFEBitsPerSample = DISPID_SpeechWaveFormatEx.BitsPerSample;
pub const DISPID_SWFEExtraData = DISPID_SpeechWaveFormatEx.ExtraData;

pub const DISPID_SpeechVoice = enum(i32) {
    Status = 1,
    Voice = 2,
    AudioOutput = 3,
    AudioOutputStream = 4,
    Rate = 5,
    Volume = 6,
    AllowAudioOuputFormatChangesOnNextSet = 7,
    EventInterests = 8,
    Priority = 9,
    AlertBoundary = 10,
    SyncronousSpeakTimeout = 11,
    Speak = 12,
    SpeakStream = 13,
    Pause = 14,
    Resume = 15,
    Skip = 16,
    GetVoices = 17,
    GetAudioOutputs = 18,
    WaitUntilDone = 19,
    SpeakCompleteEvent = 20,
    IsUISupported = 21,
    DisplayUI = 22,
};
pub const DISPID_SVStatus = DISPID_SpeechVoice.Status;
pub const DISPID_SVVoice = DISPID_SpeechVoice.Voice;
pub const DISPID_SVAudioOutput = DISPID_SpeechVoice.AudioOutput;
pub const DISPID_SVAudioOutputStream = DISPID_SpeechVoice.AudioOutputStream;
pub const DISPID_SVRate = DISPID_SpeechVoice.Rate;
pub const DISPID_SVVolume = DISPID_SpeechVoice.Volume;
pub const DISPID_SVAllowAudioOuputFormatChangesOnNextSet = DISPID_SpeechVoice.AllowAudioOuputFormatChangesOnNextSet;
pub const DISPID_SVEventInterests = DISPID_SpeechVoice.EventInterests;
pub const DISPID_SVPriority = DISPID_SpeechVoice.Priority;
pub const DISPID_SVAlertBoundary = DISPID_SpeechVoice.AlertBoundary;
pub const DISPID_SVSyncronousSpeakTimeout = DISPID_SpeechVoice.SyncronousSpeakTimeout;
pub const DISPID_SVSpeak = DISPID_SpeechVoice.Speak;
pub const DISPID_SVSpeakStream = DISPID_SpeechVoice.SpeakStream;
pub const DISPID_SVPause = DISPID_SpeechVoice.Pause;
pub const DISPID_SVResume = DISPID_SpeechVoice.Resume;
pub const DISPID_SVSkip = DISPID_SpeechVoice.Skip;
pub const DISPID_SVGetVoices = DISPID_SpeechVoice.GetVoices;
pub const DISPID_SVGetAudioOutputs = DISPID_SpeechVoice.GetAudioOutputs;
pub const DISPID_SVWaitUntilDone = DISPID_SpeechVoice.WaitUntilDone;
pub const DISPID_SVSpeakCompleteEvent = DISPID_SpeechVoice.SpeakCompleteEvent;
pub const DISPID_SVIsUISupported = DISPID_SpeechVoice.IsUISupported;
pub const DISPID_SVDisplayUI = DISPID_SpeechVoice.DisplayUI;

pub const SpeechVoicePriority = enum(i32) {
    Normal = 0,
    Alert = 1,
    Over = 2,
};
pub const SVPNormal = SpeechVoicePriority.Normal;
pub const SVPAlert = SpeechVoicePriority.Alert;
pub const SVPOver = SpeechVoicePriority.Over;

pub const SpeechVoiceSpeakFlags = enum(i32) {
    Default = 0,
    lagsAsync = 1,
    PurgeBeforeSpeak = 2,
    IsFilename = 4,
    IsXML = 8,
    IsNotXML = 16,
    PersistXML = 32,
    NLPSpeakPunc = 64,
    ParseSapi = 128,
    ParseSsml = 256,
    // ParseAutodetect = 0, this enum value conflicts with Default
    // NLPMask = 64, this enum value conflicts with NLPSpeakPunc
    ParseMask = 384,
    VoiceMask = 511,
    UnusedFlags = -512,
};
pub const SVSFDefault = SpeechVoiceSpeakFlags.Default;
pub const SVSFlagsAsync = SpeechVoiceSpeakFlags.lagsAsync;
pub const SVSFPurgeBeforeSpeak = SpeechVoiceSpeakFlags.PurgeBeforeSpeak;
pub const SVSFIsFilename = SpeechVoiceSpeakFlags.IsFilename;
pub const SVSFIsXML = SpeechVoiceSpeakFlags.IsXML;
pub const SVSFIsNotXML = SpeechVoiceSpeakFlags.IsNotXML;
pub const SVSFPersistXML = SpeechVoiceSpeakFlags.PersistXML;
pub const SVSFNLPSpeakPunc = SpeechVoiceSpeakFlags.NLPSpeakPunc;
pub const SVSFParseSapi = SpeechVoiceSpeakFlags.ParseSapi;
pub const SVSFParseSsml = SpeechVoiceSpeakFlags.ParseSsml;
pub const SVSFParseAutodetect = SpeechVoiceSpeakFlags.Default;
pub const SVSFNLPMask = SpeechVoiceSpeakFlags.NLPSpeakPunc;
pub const SVSFParseMask = SpeechVoiceSpeakFlags.ParseMask;
pub const SVSFVoiceMask = SpeechVoiceSpeakFlags.VoiceMask;
pub const SVSFUnusedFlags = SpeechVoiceSpeakFlags.UnusedFlags;

pub const SpeechVoiceEvents = enum(i32) {
    StartInputStream = 2,
    EndInputStream = 4,
    VoiceChange = 8,
    Bookmark = 16,
    WordBoundary = 32,
    Phoneme = 64,
    SentenceBoundary = 128,
    Viseme = 256,
    AudioLevel = 512,
    Private = 32768,
    AllEvents = 33790,
};
pub const SVEStartInputStream = SpeechVoiceEvents.StartInputStream;
pub const SVEEndInputStream = SpeechVoiceEvents.EndInputStream;
pub const SVEVoiceChange = SpeechVoiceEvents.VoiceChange;
pub const SVEBookmark = SpeechVoiceEvents.Bookmark;
pub const SVEWordBoundary = SpeechVoiceEvents.WordBoundary;
pub const SVEPhoneme = SpeechVoiceEvents.Phoneme;
pub const SVESentenceBoundary = SpeechVoiceEvents.SentenceBoundary;
pub const SVEViseme = SpeechVoiceEvents.Viseme;
pub const SVEAudioLevel = SpeechVoiceEvents.AudioLevel;
pub const SVEPrivate = SpeechVoiceEvents.Private;
pub const SVEAllEvents = SpeechVoiceEvents.AllEvents;

pub const DISPID_SpeechVoiceStatus = enum(i32) {
    CurrentStreamNumber = 1,
    LastStreamNumberQueued = 2,
    LastResult = 3,
    RunningState = 4,
    InputWordPosition = 5,
    InputWordLength = 6,
    InputSentencePosition = 7,
    InputSentenceLength = 8,
    LastBookmark = 9,
    LastBookmarkId = 10,
    PhonemeId = 11,
    VisemeId = 12,
};
pub const DISPID_SVSCurrentStreamNumber = DISPID_SpeechVoiceStatus.CurrentStreamNumber;
pub const DISPID_SVSLastStreamNumberQueued = DISPID_SpeechVoiceStatus.LastStreamNumberQueued;
pub const DISPID_SVSLastResult = DISPID_SpeechVoiceStatus.LastResult;
pub const DISPID_SVSRunningState = DISPID_SpeechVoiceStatus.RunningState;
pub const DISPID_SVSInputWordPosition = DISPID_SpeechVoiceStatus.InputWordPosition;
pub const DISPID_SVSInputWordLength = DISPID_SpeechVoiceStatus.InputWordLength;
pub const DISPID_SVSInputSentencePosition = DISPID_SpeechVoiceStatus.InputSentencePosition;
pub const DISPID_SVSInputSentenceLength = DISPID_SpeechVoiceStatus.InputSentenceLength;
pub const DISPID_SVSLastBookmark = DISPID_SpeechVoiceStatus.LastBookmark;
pub const DISPID_SVSLastBookmarkId = DISPID_SpeechVoiceStatus.LastBookmarkId;
pub const DISPID_SVSPhonemeId = DISPID_SpeechVoiceStatus.PhonemeId;
pub const DISPID_SVSVisemeId = DISPID_SpeechVoiceStatus.VisemeId;

pub const SpeechRunState = enum(i32) {
    Done = 1,
    IsSpeaking = 2,
};
pub const SRSEDone = SpeechRunState.Done;
pub const SRSEIsSpeaking = SpeechRunState.IsSpeaking;

pub const SpeechVisemeType = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
};
pub const SVP_0 = SpeechVisemeType.@"0";
pub const SVP_1 = SpeechVisemeType.@"1";
pub const SVP_2 = SpeechVisemeType.@"2";
pub const SVP_3 = SpeechVisemeType.@"3";
pub const SVP_4 = SpeechVisemeType.@"4";
pub const SVP_5 = SpeechVisemeType.@"5";
pub const SVP_6 = SpeechVisemeType.@"6";
pub const SVP_7 = SpeechVisemeType.@"7";
pub const SVP_8 = SpeechVisemeType.@"8";
pub const SVP_9 = SpeechVisemeType.@"9";
pub const SVP_10 = SpeechVisemeType.@"10";
pub const SVP_11 = SpeechVisemeType.@"11";
pub const SVP_12 = SpeechVisemeType.@"12";
pub const SVP_13 = SpeechVisemeType.@"13";
pub const SVP_14 = SpeechVisemeType.@"14";
pub const SVP_15 = SpeechVisemeType.@"15";
pub const SVP_16 = SpeechVisemeType.@"16";
pub const SVP_17 = SpeechVisemeType.@"17";
pub const SVP_18 = SpeechVisemeType.@"18";
pub const SVP_19 = SpeechVisemeType.@"19";
pub const SVP_20 = SpeechVisemeType.@"20";
pub const SVP_21 = SpeechVisemeType.@"21";

pub const SpeechVisemeFeature = enum(i32) {
    None = 0,
    Stressed = 1,
    Emphasis = 2,
};
pub const SVF_None = SpeechVisemeFeature.None;
pub const SVF_Stressed = SpeechVisemeFeature.Stressed;
pub const SVF_Emphasis = SpeechVisemeFeature.Emphasis;

pub const DISPID_SpeechVoiceEvent = enum(i32) {
    StreamStart = 1,
    StreamEnd = 2,
    VoiceChange = 3,
    Bookmark = 4,
    Word = 5,
    Phoneme = 6,
    SentenceBoundary = 7,
    Viseme = 8,
    AudioLevel = 9,
    EnginePrivate = 10,
};
pub const DISPID_SVEStreamStart = DISPID_SpeechVoiceEvent.StreamStart;
pub const DISPID_SVEStreamEnd = DISPID_SpeechVoiceEvent.StreamEnd;
pub const DISPID_SVEVoiceChange = DISPID_SpeechVoiceEvent.VoiceChange;
pub const DISPID_SVEBookmark = DISPID_SpeechVoiceEvent.Bookmark;
pub const DISPID_SVEWord = DISPID_SpeechVoiceEvent.Word;
pub const DISPID_SVEPhoneme = DISPID_SpeechVoiceEvent.Phoneme;
pub const DISPID_SVESentenceBoundary = DISPID_SpeechVoiceEvent.SentenceBoundary;
pub const DISPID_SVEViseme = DISPID_SpeechVoiceEvent.Viseme;
pub const DISPID_SVEAudioLevel = DISPID_SpeechVoiceEvent.AudioLevel;
pub const DISPID_SVEEnginePrivate = DISPID_SpeechVoiceEvent.EnginePrivate;

pub const DISPID_SpeechRecognizer = enum(i32) {
    RRecognizer = 1,
    RAllowAudioInputFormatChangesOnNextSet = 2,
    RAudioInput = 3,
    RAudioInputStream = 4,
    RIsShared = 5,
    RState = 6,
    RStatus = 7,
    RProfile = 8,
    REmulateRecognition = 9,
    RCreateRecoContext = 10,
    RGetFormat = 11,
    RSetPropertyNumber = 12,
    RGetPropertyNumber = 13,
    RSetPropertyString = 14,
    RGetPropertyString = 15,
    RIsUISupported = 16,
    RDisplayUI = 17,
    RGetRecognizers = 18,
    VGetAudioInputs = 19,
    VGetProfiles = 20,
};
pub const DISPID_SRRecognizer = DISPID_SpeechRecognizer.RRecognizer;
pub const DISPID_SRAllowAudioInputFormatChangesOnNextSet = DISPID_SpeechRecognizer.RAllowAudioInputFormatChangesOnNextSet;
pub const DISPID_SRAudioInput = DISPID_SpeechRecognizer.RAudioInput;
pub const DISPID_SRAudioInputStream = DISPID_SpeechRecognizer.RAudioInputStream;
pub const DISPID_SRIsShared = DISPID_SpeechRecognizer.RIsShared;
pub const DISPID_SRState = DISPID_SpeechRecognizer.RState;
pub const DISPID_SRStatus = DISPID_SpeechRecognizer.RStatus;
pub const DISPID_SRProfile = DISPID_SpeechRecognizer.RProfile;
pub const DISPID_SREmulateRecognition = DISPID_SpeechRecognizer.REmulateRecognition;
pub const DISPID_SRCreateRecoContext = DISPID_SpeechRecognizer.RCreateRecoContext;
pub const DISPID_SRGetFormat = DISPID_SpeechRecognizer.RGetFormat;
pub const DISPID_SRSetPropertyNumber = DISPID_SpeechRecognizer.RSetPropertyNumber;
pub const DISPID_SRGetPropertyNumber = DISPID_SpeechRecognizer.RGetPropertyNumber;
pub const DISPID_SRSetPropertyString = DISPID_SpeechRecognizer.RSetPropertyString;
pub const DISPID_SRGetPropertyString = DISPID_SpeechRecognizer.RGetPropertyString;
pub const DISPID_SRIsUISupported = DISPID_SpeechRecognizer.RIsUISupported;
pub const DISPID_SRDisplayUI = DISPID_SpeechRecognizer.RDisplayUI;
pub const DISPID_SRGetRecognizers = DISPID_SpeechRecognizer.RGetRecognizers;
pub const DISPID_SVGetAudioInputs = DISPID_SpeechRecognizer.VGetAudioInputs;
pub const DISPID_SVGetProfiles = DISPID_SpeechRecognizer.VGetProfiles;

pub const SpeechRecognizerState = enum(i32) {
    Inactive = 0,
    Active = 1,
    ActiveAlways = 2,
    InactiveWithPurge = 3,
};
pub const SRSInactive = SpeechRecognizerState.Inactive;
pub const SRSActive = SpeechRecognizerState.Active;
pub const SRSActiveAlways = SpeechRecognizerState.ActiveAlways;
pub const SRSInactiveWithPurge = SpeechRecognizerState.InactiveWithPurge;

pub const SpeechDisplayAttributes = enum(i32) {
    No_Trailing_Space = 0,
    One_Trailing_Space = 2,
    Two_Trailing_Spaces = 4,
    Consume_Leading_Spaces = 8,
};
pub const SDA_No_Trailing_Space = SpeechDisplayAttributes.No_Trailing_Space;
pub const SDA_One_Trailing_Space = SpeechDisplayAttributes.One_Trailing_Space;
pub const SDA_Two_Trailing_Spaces = SpeechDisplayAttributes.Two_Trailing_Spaces;
pub const SDA_Consume_Leading_Spaces = SpeechDisplayAttributes.Consume_Leading_Spaces;

pub const SpeechFormatType = enum(i32) {
    Input = 0,
    SREngine = 1,
};
pub const SFTInput = SpeechFormatType.Input;
pub const SFTSREngine = SpeechFormatType.SREngine;

pub const SpeechEmulationCompareFlags = enum(i32) {
    IgnoreCase = 1,
    IgnoreKanaType = 65536,
    IgnoreWidth = 131072,
    NoSpecialChars = 536870912,
    EmulateResult = 1073741824,
    Default = 196609,
};
pub const SECFIgnoreCase = SpeechEmulationCompareFlags.IgnoreCase;
pub const SECFIgnoreKanaType = SpeechEmulationCompareFlags.IgnoreKanaType;
pub const SECFIgnoreWidth = SpeechEmulationCompareFlags.IgnoreWidth;
pub const SECFNoSpecialChars = SpeechEmulationCompareFlags.NoSpecialChars;
pub const SECFEmulateResult = SpeechEmulationCompareFlags.EmulateResult;
pub const SECFDefault = SpeechEmulationCompareFlags.Default;

pub const DISPID_SpeechRecognizerStatus = enum(i32) {
    AudioStatus = 1,
    CurrentStreamPosition = 2,
    CurrentStreamNumber = 3,
    NumberOfActiveRules = 4,
    ClsidEngine = 5,
    SupportedLanguages = 6,
};
pub const DISPID_SRSAudioStatus = DISPID_SpeechRecognizerStatus.AudioStatus;
pub const DISPID_SRSCurrentStreamPosition = DISPID_SpeechRecognizerStatus.CurrentStreamPosition;
pub const DISPID_SRSCurrentStreamNumber = DISPID_SpeechRecognizerStatus.CurrentStreamNumber;
pub const DISPID_SRSNumberOfActiveRules = DISPID_SpeechRecognizerStatus.NumberOfActiveRules;
pub const DISPID_SRSClsidEngine = DISPID_SpeechRecognizerStatus.ClsidEngine;
pub const DISPID_SRSSupportedLanguages = DISPID_SpeechRecognizerStatus.SupportedLanguages;

pub const DISPID_SpeechRecoContext = enum(i32) {
    CRecognizer = 1,
    CAudioInInterferenceStatus = 2,
    CRequestedUIType = 3,
    CVoice = 4,
    AllowVoiceFormatMatchingOnNextSet = 5,
    CVoicePurgeEvent = 6,
    CEventInterests = 7,
    CCmdMaxAlternates = 8,
    CState = 9,
    CRetainedAudio = 10,
    CRetainedAudioFormat = 11,
    CPause = 12,
    CResume = 13,
    CCreateGrammar = 14,
    CCreateResultFromMemory = 15,
    CBookmark = 16,
    CSetAdaptationData = 17,
};
pub const DISPID_SRCRecognizer = DISPID_SpeechRecoContext.CRecognizer;
pub const DISPID_SRCAudioInInterferenceStatus = DISPID_SpeechRecoContext.CAudioInInterferenceStatus;
pub const DISPID_SRCRequestedUIType = DISPID_SpeechRecoContext.CRequestedUIType;
pub const DISPID_SRCVoice = DISPID_SpeechRecoContext.CVoice;
pub const DISPID_SRAllowVoiceFormatMatchingOnNextSet = DISPID_SpeechRecoContext.AllowVoiceFormatMatchingOnNextSet;
pub const DISPID_SRCVoicePurgeEvent = DISPID_SpeechRecoContext.CVoicePurgeEvent;
pub const DISPID_SRCEventInterests = DISPID_SpeechRecoContext.CEventInterests;
pub const DISPID_SRCCmdMaxAlternates = DISPID_SpeechRecoContext.CCmdMaxAlternates;
pub const DISPID_SRCState = DISPID_SpeechRecoContext.CState;
pub const DISPID_SRCRetainedAudio = DISPID_SpeechRecoContext.CRetainedAudio;
pub const DISPID_SRCRetainedAudioFormat = DISPID_SpeechRecoContext.CRetainedAudioFormat;
pub const DISPID_SRCPause = DISPID_SpeechRecoContext.CPause;
pub const DISPID_SRCResume = DISPID_SpeechRecoContext.CResume;
pub const DISPID_SRCCreateGrammar = DISPID_SpeechRecoContext.CCreateGrammar;
pub const DISPID_SRCCreateResultFromMemory = DISPID_SpeechRecoContext.CCreateResultFromMemory;
pub const DISPID_SRCBookmark = DISPID_SpeechRecoContext.CBookmark;
pub const DISPID_SRCSetAdaptationData = DISPID_SpeechRecoContext.CSetAdaptationData;

pub const SpeechRetainedAudioOptions = enum(i32) {
    None = 0,
    RetainAudio = 1,
};
pub const SRAONone = SpeechRetainedAudioOptions.None;
pub const SRAORetainAudio = SpeechRetainedAudioOptions.RetainAudio;

pub const SpeechBookmarkOptions = enum(i32) {
    None = 0,
    Pause = 1,
};
pub const SBONone = SpeechBookmarkOptions.None;
pub const SBOPause = SpeechBookmarkOptions.Pause;

pub const SpeechInterference = enum(i32) {
    None = 0,
    Noise = 1,
    NoSignal = 2,
    TooLoud = 3,
    TooQuiet = 4,
    TooFast = 5,
    TooSlow = 6,
};
pub const SINone = SpeechInterference.None;
pub const SINoise = SpeechInterference.Noise;
pub const SINoSignal = SpeechInterference.NoSignal;
pub const SITooLoud = SpeechInterference.TooLoud;
pub const SITooQuiet = SpeechInterference.TooQuiet;
pub const SITooFast = SpeechInterference.TooFast;
pub const SITooSlow = SpeechInterference.TooSlow;

pub const SpeechRecoEvents = enum(i32) {
    StreamEnd = 1,
    SoundStart = 2,
    SoundEnd = 4,
    PhraseStart = 8,
    Recognition = 16,
    Hypothesis = 32,
    Bookmark = 64,
    PropertyNumChange = 128,
    PropertyStringChange = 256,
    FalseRecognition = 512,
    Interference = 1024,
    RequestUI = 2048,
    StateChange = 4096,
    Adaptation = 8192,
    StreamStart = 16384,
    RecoOtherContext = 32768,
    AudioLevel = 65536,
    Private = 262144,
    AllEvents = 393215,
};
pub const SREStreamEnd = SpeechRecoEvents.StreamEnd;
pub const SRESoundStart = SpeechRecoEvents.SoundStart;
pub const SRESoundEnd = SpeechRecoEvents.SoundEnd;
pub const SREPhraseStart = SpeechRecoEvents.PhraseStart;
pub const SRERecognition = SpeechRecoEvents.Recognition;
pub const SREHypothesis = SpeechRecoEvents.Hypothesis;
pub const SREBookmark = SpeechRecoEvents.Bookmark;
pub const SREPropertyNumChange = SpeechRecoEvents.PropertyNumChange;
pub const SREPropertyStringChange = SpeechRecoEvents.PropertyStringChange;
pub const SREFalseRecognition = SpeechRecoEvents.FalseRecognition;
pub const SREInterference = SpeechRecoEvents.Interference;
pub const SRERequestUI = SpeechRecoEvents.RequestUI;
pub const SREStateChange = SpeechRecoEvents.StateChange;
pub const SREAdaptation = SpeechRecoEvents.Adaptation;
pub const SREStreamStart = SpeechRecoEvents.StreamStart;
pub const SRERecoOtherContext = SpeechRecoEvents.RecoOtherContext;
pub const SREAudioLevel = SpeechRecoEvents.AudioLevel;
pub const SREPrivate = SpeechRecoEvents.Private;
pub const SREAllEvents = SpeechRecoEvents.AllEvents;

pub const SpeechRecoContextState = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const SRCS_Disabled = SpeechRecoContextState.Disabled;
pub const SRCS_Enabled = SpeechRecoContextState.Enabled;

pub const DISPIDSPRG = enum(i32) {
    Id = 1,
    RecoContext = 2,
    State = 3,
    Rules = 4,
    Reset = 5,
    Commit = 6,
    CmdLoadFromFile = 7,
    CmdLoadFromObject = 8,
    CmdLoadFromResource = 9,
    CmdLoadFromMemory = 10,
    CmdLoadFromProprietaryGrammar = 11,
    CmdSetRuleState = 12,
    CmdSetRuleIdState = 13,
    DictationLoad = 14,
    DictationUnload = 15,
    DictationSetState = 16,
    SetWordSequenceData = 17,
    SetTextSelection = 18,
    IsPronounceable = 19,
};
pub const DISPID_SRGId = DISPIDSPRG.Id;
pub const DISPID_SRGRecoContext = DISPIDSPRG.RecoContext;
pub const DISPID_SRGState = DISPIDSPRG.State;
pub const DISPID_SRGRules = DISPIDSPRG.Rules;
pub const DISPID_SRGReset = DISPIDSPRG.Reset;
pub const DISPID_SRGCommit = DISPIDSPRG.Commit;
pub const DISPID_SRGCmdLoadFromFile = DISPIDSPRG.CmdLoadFromFile;
pub const DISPID_SRGCmdLoadFromObject = DISPIDSPRG.CmdLoadFromObject;
pub const DISPID_SRGCmdLoadFromResource = DISPIDSPRG.CmdLoadFromResource;
pub const DISPID_SRGCmdLoadFromMemory = DISPIDSPRG.CmdLoadFromMemory;
pub const DISPID_SRGCmdLoadFromProprietaryGrammar = DISPIDSPRG.CmdLoadFromProprietaryGrammar;
pub const DISPID_SRGCmdSetRuleState = DISPIDSPRG.CmdSetRuleState;
pub const DISPID_SRGCmdSetRuleIdState = DISPIDSPRG.CmdSetRuleIdState;
pub const DISPID_SRGDictationLoad = DISPIDSPRG.DictationLoad;
pub const DISPID_SRGDictationUnload = DISPIDSPRG.DictationUnload;
pub const DISPID_SRGDictationSetState = DISPIDSPRG.DictationSetState;
pub const DISPID_SRGSetWordSequenceData = DISPIDSPRG.SetWordSequenceData;
pub const DISPID_SRGSetTextSelection = DISPIDSPRG.SetTextSelection;
pub const DISPID_SRGIsPronounceable = DISPIDSPRG.IsPronounceable;

pub const SpeechLoadOption = enum(i32) {
    Static = 0,
    Dynamic = 1,
};
pub const SLOStatic = SpeechLoadOption.Static;
pub const SLODynamic = SpeechLoadOption.Dynamic;

pub const SpeechWordPronounceable = enum(i32) {
    UnknownWordUnpronounceable = 0,
    UnknownWordPronounceable = 1,
    KnownWordPronounceable = 2,
};
pub const SWPUnknownWordUnpronounceable = SpeechWordPronounceable.UnknownWordUnpronounceable;
pub const SWPUnknownWordPronounceable = SpeechWordPronounceable.UnknownWordPronounceable;
pub const SWPKnownWordPronounceable = SpeechWordPronounceable.KnownWordPronounceable;

pub const SpeechGrammarState = enum(i32) {
    Enabled = 1,
    Disabled = 0,
    Exclusive = 3,
};
pub const SGSEnabled = SpeechGrammarState.Enabled;
pub const SGSDisabled = SpeechGrammarState.Disabled;
pub const SGSExclusive = SpeechGrammarState.Exclusive;

pub const SpeechRuleState = enum(i32) {
    Inactive = 0,
    Active = 1,
    ActiveWithAutoPause = 3,
    ActiveUserDelimited = 4,
};
pub const SGDSInactive = SpeechRuleState.Inactive;
pub const SGDSActive = SpeechRuleState.Active;
pub const SGDSActiveWithAutoPause = SpeechRuleState.ActiveWithAutoPause;
pub const SGDSActiveUserDelimited = SpeechRuleState.ActiveUserDelimited;

pub const SpeechRuleAttributes = enum(i32) {
    TopLevel = 1,
    DefaultToActive = 2,
    Export = 4,
    Import = 8,
    Interpreter = 16,
    Dynamic = 32,
    Root = 64,
};
pub const SRATopLevel = SpeechRuleAttributes.TopLevel;
pub const SRADefaultToActive = SpeechRuleAttributes.DefaultToActive;
pub const SRAExport = SpeechRuleAttributes.Export;
pub const SRAImport = SpeechRuleAttributes.Import;
pub const SRAInterpreter = SpeechRuleAttributes.Interpreter;
pub const SRADynamic = SpeechRuleAttributes.Dynamic;
pub const SRARoot = SpeechRuleAttributes.Root;

pub const SpeechGrammarWordType = enum(i32) {
    Display = 0,
    Lexical = 1,
    Pronounciation = 2,
    LexicalNoSpecialChars = 3,
};
pub const SGDisplay = SpeechGrammarWordType.Display;
pub const SGLexical = SpeechGrammarWordType.Lexical;
pub const SGPronounciation = SpeechGrammarWordType.Pronounciation;
pub const SGLexicalNoSpecialChars = SpeechGrammarWordType.LexicalNoSpecialChars;

pub const DISPID_SpeechRecoContextEvents = enum(i32) {
    StartStream = 1,
    EndStream = 2,
    Bookmark = 3,
    SoundStart = 4,
    SoundEnd = 5,
    PhraseStart = 6,
    Recognition = 7,
    Hypothesis = 8,
    PropertyNumberChange = 9,
    PropertyStringChange = 10,
    FalseRecognition = 11,
    Interference = 12,
    RequestUI = 13,
    RecognizerStateChange = 14,
    Adaptation = 15,
    RecognitionForOtherContext = 16,
    AudioLevel = 17,
    EnginePrivate = 18,
};
pub const DISPID_SRCEStartStream = DISPID_SpeechRecoContextEvents.StartStream;
pub const DISPID_SRCEEndStream = DISPID_SpeechRecoContextEvents.EndStream;
pub const DISPID_SRCEBookmark = DISPID_SpeechRecoContextEvents.Bookmark;
pub const DISPID_SRCESoundStart = DISPID_SpeechRecoContextEvents.SoundStart;
pub const DISPID_SRCESoundEnd = DISPID_SpeechRecoContextEvents.SoundEnd;
pub const DISPID_SRCEPhraseStart = DISPID_SpeechRecoContextEvents.PhraseStart;
pub const DISPID_SRCERecognition = DISPID_SpeechRecoContextEvents.Recognition;
pub const DISPID_SRCEHypothesis = DISPID_SpeechRecoContextEvents.Hypothesis;
pub const DISPID_SRCEPropertyNumberChange = DISPID_SpeechRecoContextEvents.PropertyNumberChange;
pub const DISPID_SRCEPropertyStringChange = DISPID_SpeechRecoContextEvents.PropertyStringChange;
pub const DISPID_SRCEFalseRecognition = DISPID_SpeechRecoContextEvents.FalseRecognition;
pub const DISPID_SRCEInterference = DISPID_SpeechRecoContextEvents.Interference;
pub const DISPID_SRCERequestUI = DISPID_SpeechRecoContextEvents.RequestUI;
pub const DISPID_SRCERecognizerStateChange = DISPID_SpeechRecoContextEvents.RecognizerStateChange;
pub const DISPID_SRCEAdaptation = DISPID_SpeechRecoContextEvents.Adaptation;
pub const DISPID_SRCERecognitionForOtherContext = DISPID_SpeechRecoContextEvents.RecognitionForOtherContext;
pub const DISPID_SRCEAudioLevel = DISPID_SpeechRecoContextEvents.AudioLevel;
pub const DISPID_SRCEEnginePrivate = DISPID_SpeechRecoContextEvents.EnginePrivate;

pub const SpeechRecognitionType = enum(i32) {
    Standard = 0,
    Autopause = 1,
    Emulated = 2,
    SMLTimeout = 4,
    ExtendableParse = 8,
    ReSent = 16,
};
pub const SRTStandard = SpeechRecognitionType.Standard;
pub const SRTAutopause = SpeechRecognitionType.Autopause;
pub const SRTEmulated = SpeechRecognitionType.Emulated;
pub const SRTSMLTimeout = SpeechRecognitionType.SMLTimeout;
pub const SRTExtendableParse = SpeechRecognitionType.ExtendableParse;
pub const SRTReSent = SpeechRecognitionType.ReSent;

pub const DISPID_SpeechGrammarRule = enum(i32) {
    Attributes = 1,
    InitialState = 2,
    Name = 3,
    Id = 4,
    Clear = 5,
    AddResource = 6,
    AddState = 7,
};
pub const DISPID_SGRAttributes = DISPID_SpeechGrammarRule.Attributes;
pub const DISPID_SGRInitialState = DISPID_SpeechGrammarRule.InitialState;
pub const DISPID_SGRName = DISPID_SpeechGrammarRule.Name;
pub const DISPID_SGRId = DISPID_SpeechGrammarRule.Id;
pub const DISPID_SGRClear = DISPID_SpeechGrammarRule.Clear;
pub const DISPID_SGRAddResource = DISPID_SpeechGrammarRule.AddResource;
pub const DISPID_SGRAddState = DISPID_SpeechGrammarRule.AddState;

pub const DISPID_SpeechGrammarRules = enum(i32) {
    Count = 1,
    Dynamic = 2,
    Add = 3,
    Commit = 4,
    CommitAndSave = 5,
    FindRule = 6,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SGRsCount = DISPID_SpeechGrammarRules.Count;
pub const DISPID_SGRsDynamic = DISPID_SpeechGrammarRules.Dynamic;
pub const DISPID_SGRsAdd = DISPID_SpeechGrammarRules.Add;
pub const DISPID_SGRsCommit = DISPID_SpeechGrammarRules.Commit;
pub const DISPID_SGRsCommitAndSave = DISPID_SpeechGrammarRules.CommitAndSave;
pub const DISPID_SGRsFindRule = DISPID_SpeechGrammarRules.FindRule;
pub const DISPID_SGRsItem = DISPID_SpeechGrammarRules.Item;
pub const DISPID_SGRs_NewEnum = DISPID_SpeechGrammarRules._NewEnum;

pub const DISPID_SpeechGrammarRuleState = enum(i32) {
    Rule = 1,
    Transitions = 2,
    AddWordTransition = 3,
    AddRuleTransition = 4,
    AddSpecialTransition = 5,
};
pub const DISPID_SGRSRule = DISPID_SpeechGrammarRuleState.Rule;
pub const DISPID_SGRSTransitions = DISPID_SpeechGrammarRuleState.Transitions;
pub const DISPID_SGRSAddWordTransition = DISPID_SpeechGrammarRuleState.AddWordTransition;
pub const DISPID_SGRSAddRuleTransition = DISPID_SpeechGrammarRuleState.AddRuleTransition;
pub const DISPID_SGRSAddSpecialTransition = DISPID_SpeechGrammarRuleState.AddSpecialTransition;

pub const SpeechSpecialTransitionType = enum(i32) {
    Wildcard = 1,
    Dictation = 2,
    TextBuffer = 3,
};
pub const SSTTWildcard = SpeechSpecialTransitionType.Wildcard;
pub const SSTTDictation = SpeechSpecialTransitionType.Dictation;
pub const SSTTTextBuffer = SpeechSpecialTransitionType.TextBuffer;

pub const DISPID_SpeechGrammarRuleStateTransitions = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SGRSTsCount = DISPID_SpeechGrammarRuleStateTransitions.Count;
pub const DISPID_SGRSTsItem = DISPID_SpeechGrammarRuleStateTransitions.Item;
pub const DISPID_SGRSTs_NewEnum = DISPID_SpeechGrammarRuleStateTransitions._NewEnum;

pub const DISPID_SpeechGrammarRuleStateTransition = enum(i32) {
    Type = 1,
    Text = 2,
    Rule = 3,
    Weight = 4,
    PropertyName = 5,
    PropertyId = 6,
    PropertyValue = 7,
    NextState = 8,
};
pub const DISPID_SGRSTType = DISPID_SpeechGrammarRuleStateTransition.Type;
pub const DISPID_SGRSTText = DISPID_SpeechGrammarRuleStateTransition.Text;
pub const DISPID_SGRSTRule = DISPID_SpeechGrammarRuleStateTransition.Rule;
pub const DISPID_SGRSTWeight = DISPID_SpeechGrammarRuleStateTransition.Weight;
pub const DISPID_SGRSTPropertyName = DISPID_SpeechGrammarRuleStateTransition.PropertyName;
pub const DISPID_SGRSTPropertyId = DISPID_SpeechGrammarRuleStateTransition.PropertyId;
pub const DISPID_SGRSTPropertyValue = DISPID_SpeechGrammarRuleStateTransition.PropertyValue;
pub const DISPID_SGRSTNextState = DISPID_SpeechGrammarRuleStateTransition.NextState;

pub const SpeechGrammarRuleStateTransitionType = enum(i32) {
    Epsilon = 0,
    Word = 1,
    Rule = 2,
    Dictation = 3,
    Wildcard = 4,
    TextBuffer = 5,
};
pub const SGRSTTEpsilon = SpeechGrammarRuleStateTransitionType.Epsilon;
pub const SGRSTTWord = SpeechGrammarRuleStateTransitionType.Word;
pub const SGRSTTRule = SpeechGrammarRuleStateTransitionType.Rule;
pub const SGRSTTDictation = SpeechGrammarRuleStateTransitionType.Dictation;
pub const SGRSTTWildcard = SpeechGrammarRuleStateTransitionType.Wildcard;
pub const SGRSTTTextBuffer = SpeechGrammarRuleStateTransitionType.TextBuffer;

pub const DISPIDSPTSI = enum(i32) {
    ActiveOffset = 1,
    ActiveLength = 2,
    SelectionOffset = 3,
    SelectionLength = 4,
};
pub const DISPIDSPTSI_ActiveOffset = DISPIDSPTSI.ActiveOffset;
pub const DISPIDSPTSI_ActiveLength = DISPIDSPTSI.ActiveLength;
pub const DISPIDSPTSI_SelectionOffset = DISPIDSPTSI.SelectionOffset;
pub const DISPIDSPTSI_SelectionLength = DISPIDSPTSI.SelectionLength;

pub const DISPID_SpeechRecoResult = enum(i32) {
    RecoContext = 1,
    Times = 2,
    AudioFormat = 3,
    PhraseInfo = 4,
    Alternates = 5,
    Audio = 6,
    SpeakAudio = 7,
    SaveToMemory = 8,
    DiscardResultInfo = 9,
};
pub const DISPID_SRRRecoContext = DISPID_SpeechRecoResult.RecoContext;
pub const DISPID_SRRTimes = DISPID_SpeechRecoResult.Times;
pub const DISPID_SRRAudioFormat = DISPID_SpeechRecoResult.AudioFormat;
pub const DISPID_SRRPhraseInfo = DISPID_SpeechRecoResult.PhraseInfo;
pub const DISPID_SRRAlternates = DISPID_SpeechRecoResult.Alternates;
pub const DISPID_SRRAudio = DISPID_SpeechRecoResult.Audio;
pub const DISPID_SRRSpeakAudio = DISPID_SpeechRecoResult.SpeakAudio;
pub const DISPID_SRRSaveToMemory = DISPID_SpeechRecoResult.SaveToMemory;
pub const DISPID_SRRDiscardResultInfo = DISPID_SpeechRecoResult.DiscardResultInfo;

pub const SpeechDiscardType = enum(i32) {
    Property = 1,
    Replacement = 2,
    Rule = 4,
    DisplayText = 8,
    LexicalForm = 16,
    Pronunciation = 32,
    Audio = 64,
    Alternates = 128,
    All = 255,
};
pub const SDTProperty = SpeechDiscardType.Property;
pub const SDTReplacement = SpeechDiscardType.Replacement;
pub const SDTRule = SpeechDiscardType.Rule;
pub const SDTDisplayText = SpeechDiscardType.DisplayText;
pub const SDTLexicalForm = SpeechDiscardType.LexicalForm;
pub const SDTPronunciation = SpeechDiscardType.Pronunciation;
pub const SDTAudio = SpeechDiscardType.Audio;
pub const SDTAlternates = SpeechDiscardType.Alternates;
pub const SDTAll = SpeechDiscardType.All;

pub const DISPID_SpeechXMLRecoResult = enum(i32) {
    Result = 10,
    ErrorInfo = 11,
};
pub const DISPID_SRRGetXMLResult = DISPID_SpeechXMLRecoResult.Result;
pub const DISPID_SRRGetXMLErrorInfo = DISPID_SpeechXMLRecoResult.ErrorInfo;

pub const DISPID_SpeechRecoResult2 = enum(i32) {
    k = 12,
};
pub const DISPID_SRRSetTextFeedback = DISPID_SpeechRecoResult2.k;

pub const DISPID_SpeechPhraseBuilder = enum(i32) {
    y = 1,
};
pub const DISPID_SPPBRestorePhraseFromMemory = DISPID_SpeechPhraseBuilder.y;

pub const DISPID_SpeechRecoResultTimes = enum(i32) {
    StreamTime = 1,
    Length = 2,
    TickCount = 3,
    OffsetFromStart = 4,
};
pub const DISPID_SRRTStreamTime = DISPID_SpeechRecoResultTimes.StreamTime;
pub const DISPID_SRRTLength = DISPID_SpeechRecoResultTimes.Length;
pub const DISPID_SRRTTickCount = DISPID_SpeechRecoResultTimes.TickCount;
pub const DISPID_SRRTOffsetFromStart = DISPID_SpeechRecoResultTimes.OffsetFromStart;

pub const DISPID_SpeechPhraseAlternate = enum(i32) {
    RecoResult = 1,
    StartElementInResult = 2,
    NumberOfElementsInResult = 3,
    PhraseInfo = 4,
    Commit = 5,
};
pub const DISPID_SPARecoResult = DISPID_SpeechPhraseAlternate.RecoResult;
pub const DISPID_SPAStartElementInResult = DISPID_SpeechPhraseAlternate.StartElementInResult;
pub const DISPID_SPANumberOfElementsInResult = DISPID_SpeechPhraseAlternate.NumberOfElementsInResult;
pub const DISPID_SPAPhraseInfo = DISPID_SpeechPhraseAlternate.PhraseInfo;
pub const DISPID_SPACommit = DISPID_SpeechPhraseAlternate.Commit;

pub const DISPID_SpeechPhraseAlternates = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPAsCount = DISPID_SpeechPhraseAlternates.Count;
pub const DISPID_SPAsItem = DISPID_SpeechPhraseAlternates.Item;
pub const DISPID_SPAs_NewEnum = DISPID_SpeechPhraseAlternates._NewEnum;

pub const DISPID_SpeechPhraseInfo = enum(i32) {
    LanguageId = 1,
    GrammarId = 2,
    StartTime = 3,
    AudioStreamPosition = 4,
    AudioSizeBytes = 5,
    RetainedSizeBytes = 6,
    AudioSizeTime = 7,
    Rule = 8,
    Properties = 9,
    Elements = 10,
    Replacements = 11,
    EngineId = 12,
    EnginePrivateData = 13,
    SaveToMemory = 14,
    GetText = 15,
    GetDisplayAttributes = 16,
};
pub const DISPID_SPILanguageId = DISPID_SpeechPhraseInfo.LanguageId;
pub const DISPID_SPIGrammarId = DISPID_SpeechPhraseInfo.GrammarId;
pub const DISPID_SPIStartTime = DISPID_SpeechPhraseInfo.StartTime;
pub const DISPID_SPIAudioStreamPosition = DISPID_SpeechPhraseInfo.AudioStreamPosition;
pub const DISPID_SPIAudioSizeBytes = DISPID_SpeechPhraseInfo.AudioSizeBytes;
pub const DISPID_SPIRetainedSizeBytes = DISPID_SpeechPhraseInfo.RetainedSizeBytes;
pub const DISPID_SPIAudioSizeTime = DISPID_SpeechPhraseInfo.AudioSizeTime;
pub const DISPID_SPIRule = DISPID_SpeechPhraseInfo.Rule;
pub const DISPID_SPIProperties = DISPID_SpeechPhraseInfo.Properties;
pub const DISPID_SPIElements = DISPID_SpeechPhraseInfo.Elements;
pub const DISPID_SPIReplacements = DISPID_SpeechPhraseInfo.Replacements;
pub const DISPID_SPIEngineId = DISPID_SpeechPhraseInfo.EngineId;
pub const DISPID_SPIEnginePrivateData = DISPID_SpeechPhraseInfo.EnginePrivateData;
pub const DISPID_SPISaveToMemory = DISPID_SpeechPhraseInfo.SaveToMemory;
pub const DISPID_SPIGetText = DISPID_SpeechPhraseInfo.GetText;
pub const DISPID_SPIGetDisplayAttributes = DISPID_SpeechPhraseInfo.GetDisplayAttributes;

pub const DISPID_SpeechPhraseElement = enum(i32) {
    AudioTimeOffset = 1,
    AudioSizeTime = 2,
    AudioStreamOffset = 3,
    AudioSizeBytes = 4,
    RetainedStreamOffset = 5,
    RetainedSizeBytes = 6,
    DisplayText = 7,
    LexicalForm = 8,
    Pronunciation = 9,
    DisplayAttributes = 10,
    RequiredConfidence = 11,
    ActualConfidence = 12,
    EngineConfidence = 13,
};
pub const DISPID_SPEAudioTimeOffset = DISPID_SpeechPhraseElement.AudioTimeOffset;
pub const DISPID_SPEAudioSizeTime = DISPID_SpeechPhraseElement.AudioSizeTime;
pub const DISPID_SPEAudioStreamOffset = DISPID_SpeechPhraseElement.AudioStreamOffset;
pub const DISPID_SPEAudioSizeBytes = DISPID_SpeechPhraseElement.AudioSizeBytes;
pub const DISPID_SPERetainedStreamOffset = DISPID_SpeechPhraseElement.RetainedStreamOffset;
pub const DISPID_SPERetainedSizeBytes = DISPID_SpeechPhraseElement.RetainedSizeBytes;
pub const DISPID_SPEDisplayText = DISPID_SpeechPhraseElement.DisplayText;
pub const DISPID_SPELexicalForm = DISPID_SpeechPhraseElement.LexicalForm;
pub const DISPID_SPEPronunciation = DISPID_SpeechPhraseElement.Pronunciation;
pub const DISPID_SPEDisplayAttributes = DISPID_SpeechPhraseElement.DisplayAttributes;
pub const DISPID_SPERequiredConfidence = DISPID_SpeechPhraseElement.RequiredConfidence;
pub const DISPID_SPEActualConfidence = DISPID_SpeechPhraseElement.ActualConfidence;
pub const DISPID_SPEEngineConfidence = DISPID_SpeechPhraseElement.EngineConfidence;

pub const SpeechEngineConfidence = enum(i32) {
    LowConfidence = -1,
    NormalConfidence = 0,
    HighConfidence = 1,
};
pub const SECLowConfidence = SpeechEngineConfidence.LowConfidence;
pub const SECNormalConfidence = SpeechEngineConfidence.NormalConfidence;
pub const SECHighConfidence = SpeechEngineConfidence.HighConfidence;

pub const DISPID_SpeechPhraseElements = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPEsCount = DISPID_SpeechPhraseElements.Count;
pub const DISPID_SPEsItem = DISPID_SpeechPhraseElements.Item;
pub const DISPID_SPEs_NewEnum = DISPID_SpeechPhraseElements._NewEnum;

pub const DISPID_SpeechPhraseReplacement = enum(i32) {
    DisplayAttributes = 1,
    Text = 2,
    FirstElement = 3,
    NumberOfElements = 4,
};
pub const DISPID_SPRDisplayAttributes = DISPID_SpeechPhraseReplacement.DisplayAttributes;
pub const DISPID_SPRText = DISPID_SpeechPhraseReplacement.Text;
pub const DISPID_SPRFirstElement = DISPID_SpeechPhraseReplacement.FirstElement;
pub const DISPID_SPRNumberOfElements = DISPID_SpeechPhraseReplacement.NumberOfElements;

pub const DISPID_SpeechPhraseReplacements = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPRsCount = DISPID_SpeechPhraseReplacements.Count;
pub const DISPID_SPRsItem = DISPID_SpeechPhraseReplacements.Item;
pub const DISPID_SPRs_NewEnum = DISPID_SpeechPhraseReplacements._NewEnum;

pub const DISPID_SpeechPhraseProperty = enum(i32) {
    Name = 1,
    Id = 2,
    Value = 3,
    FirstElement = 4,
    NumberOfElements = 5,
    EngineConfidence = 6,
    Confidence = 7,
    Parent = 8,
    Children = 9,
};
pub const DISPID_SPPName = DISPID_SpeechPhraseProperty.Name;
pub const DISPID_SPPId = DISPID_SpeechPhraseProperty.Id;
pub const DISPID_SPPValue = DISPID_SpeechPhraseProperty.Value;
pub const DISPID_SPPFirstElement = DISPID_SpeechPhraseProperty.FirstElement;
pub const DISPID_SPPNumberOfElements = DISPID_SpeechPhraseProperty.NumberOfElements;
pub const DISPID_SPPEngineConfidence = DISPID_SpeechPhraseProperty.EngineConfidence;
pub const DISPID_SPPConfidence = DISPID_SpeechPhraseProperty.Confidence;
pub const DISPID_SPPParent = DISPID_SpeechPhraseProperty.Parent;
pub const DISPID_SPPChildren = DISPID_SpeechPhraseProperty.Children;

pub const DISPID_SpeechPhraseProperties = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPPsCount = DISPID_SpeechPhraseProperties.Count;
pub const DISPID_SPPsItem = DISPID_SpeechPhraseProperties.Item;
pub const DISPID_SPPs_NewEnum = DISPID_SpeechPhraseProperties._NewEnum;

pub const DISPID_SpeechPhraseRule = enum(i32) {
    Name = 1,
    Id = 2,
    FirstElement = 3,
    NumberOfElements = 4,
    Parent = 5,
    Children = 6,
    Confidence = 7,
    EngineConfidence = 8,
};
pub const DISPID_SPRuleName = DISPID_SpeechPhraseRule.Name;
pub const DISPID_SPRuleId = DISPID_SpeechPhraseRule.Id;
pub const DISPID_SPRuleFirstElement = DISPID_SpeechPhraseRule.FirstElement;
pub const DISPID_SPRuleNumberOfElements = DISPID_SpeechPhraseRule.NumberOfElements;
pub const DISPID_SPRuleParent = DISPID_SpeechPhraseRule.Parent;
pub const DISPID_SPRuleChildren = DISPID_SpeechPhraseRule.Children;
pub const DISPID_SPRuleConfidence = DISPID_SpeechPhraseRule.Confidence;
pub const DISPID_SPRuleEngineConfidence = DISPID_SpeechPhraseRule.EngineConfidence;

pub const DISPID_SpeechPhraseRules = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPRulesCount = DISPID_SpeechPhraseRules.Count;
pub const DISPID_SPRulesItem = DISPID_SpeechPhraseRules.Item;
pub const DISPID_SPRules_NewEnum = DISPID_SpeechPhraseRules._NewEnum;

pub const DISPID_SpeechLexicon = enum(i32) {
    GenerationId = 1,
    GetWords = 2,
    AddPronunciation = 3,
    AddPronunciationByPhoneIds = 4,
    RemovePronunciation = 5,
    RemovePronunciationByPhoneIds = 6,
    GetPronunciations = 7,
    GetGenerationChange = 8,
};
pub const DISPID_SLGenerationId = DISPID_SpeechLexicon.GenerationId;
pub const DISPID_SLGetWords = DISPID_SpeechLexicon.GetWords;
pub const DISPID_SLAddPronunciation = DISPID_SpeechLexicon.AddPronunciation;
pub const DISPID_SLAddPronunciationByPhoneIds = DISPID_SpeechLexicon.AddPronunciationByPhoneIds;
pub const DISPID_SLRemovePronunciation = DISPID_SpeechLexicon.RemovePronunciation;
pub const DISPID_SLRemovePronunciationByPhoneIds = DISPID_SpeechLexicon.RemovePronunciationByPhoneIds;
pub const DISPID_SLGetPronunciations = DISPID_SpeechLexicon.GetPronunciations;
pub const DISPID_SLGetGenerationChange = DISPID_SpeechLexicon.GetGenerationChange;

pub const SpeechLexiconType = enum(i32) {
    User = 1,
    App = 2,
};
pub const SLTUser = SpeechLexiconType.User;
pub const SLTApp = SpeechLexiconType.App;

pub const SpeechPartOfSpeech = enum(i32) {
    NotOverriden = -1,
    Unknown = 0,
    Noun = 4096,
    Verb = 8192,
    Modifier = 12288,
    Function = 16384,
    Interjection = 20480,
    LMA = 28672,
    SuppressWord = 61440,
};
pub const SPSNotOverriden = SpeechPartOfSpeech.NotOverriden;
pub const SPSUnknown = SpeechPartOfSpeech.Unknown;
pub const SPSNoun = SpeechPartOfSpeech.Noun;
pub const SPSVerb = SpeechPartOfSpeech.Verb;
pub const SPSModifier = SpeechPartOfSpeech.Modifier;
pub const SPSFunction = SpeechPartOfSpeech.Function;
pub const SPSInterjection = SpeechPartOfSpeech.Interjection;
pub const SPSLMA = SpeechPartOfSpeech.LMA;
pub const SPSSuppressWord = SpeechPartOfSpeech.SuppressWord;

pub const DISPID_SpeechLexiconWords = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SLWsCount = DISPID_SpeechLexiconWords.Count;
pub const DISPID_SLWsItem = DISPID_SpeechLexiconWords.Item;
pub const DISPID_SLWs_NewEnum = DISPID_SpeechLexiconWords._NewEnum;

pub const SpeechWordType = enum(i32) {
    Added = 1,
    Deleted = 2,
};
pub const SWTAdded = SpeechWordType.Added;
pub const SWTDeleted = SpeechWordType.Deleted;

pub const DISPID_SpeechLexiconWord = enum(i32) {
    LangId = 1,
    Type = 2,
    Word = 3,
    Pronunciations = 4,
};
pub const DISPID_SLWLangId = DISPID_SpeechLexiconWord.LangId;
pub const DISPID_SLWType = DISPID_SpeechLexiconWord.Type;
pub const DISPID_SLWWord = DISPID_SpeechLexiconWord.Word;
pub const DISPID_SLWPronunciations = DISPID_SpeechLexiconWord.Pronunciations;

pub const DISPID_SpeechLexiconProns = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SLPsCount = DISPID_SpeechLexiconProns.Count;
pub const DISPID_SLPsItem = DISPID_SpeechLexiconProns.Item;
pub const DISPID_SLPs_NewEnum = DISPID_SpeechLexiconProns._NewEnum;

pub const DISPID_SpeechLexiconPronunciation = enum(i32) {
    Type = 1,
    LangId = 2,
    PartOfSpeech = 3,
    PhoneIds = 4,
    Symbolic = 5,
};
pub const DISPID_SLPType = DISPID_SpeechLexiconPronunciation.Type;
pub const DISPID_SLPLangId = DISPID_SpeechLexiconPronunciation.LangId;
pub const DISPID_SLPPartOfSpeech = DISPID_SpeechLexiconPronunciation.PartOfSpeech;
pub const DISPID_SLPPhoneIds = DISPID_SpeechLexiconPronunciation.PhoneIds;
pub const DISPID_SLPSymbolic = DISPID_SpeechLexiconPronunciation.Symbolic;

pub const DISPID_SpeechPhoneConverter = enum(i32) {
    LangId = 1,
    PhoneToId = 2,
    IdToPhone = 3,
};
pub const DISPID_SPCLangId = DISPID_SpeechPhoneConverter.LangId;
pub const DISPID_SPCPhoneToId = DISPID_SpeechPhoneConverter.PhoneToId;
pub const DISPID_SPCIdToPhone = DISPID_SpeechPhoneConverter.IdToPhone;

const IID_ISpeechDataKey_Value = Guid.initString("ce17c09b-4efa-44d5-a4c9-59d9585ab0cd");
pub const IID_ISpeechDataKey = &IID_ISpeechDataKey_Value;
pub const ISpeechDataKey = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetBinaryValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBinaryValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStringValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLongValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLongValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenKey: *const fn (
            self: *const ISpeechDataKey,
            sub_key_name: ?BSTR,
            sub_key: ?*?*ISpeechDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateKey: *const fn (
            self: *const ISpeechDataKey,
            sub_key_name: ?BSTR,
            sub_key: ?*?*ISpeechDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteKey: *const fn (
            self: *const ISpeechDataKey,
            sub_key_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteValue: *const fn (
            self: *const ISpeechDataKey,
            value_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumKeys: *const fn (
            self: *const ISpeechDataKey,
            index: i32,
            sub_key_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumValues: *const fn (
            self: *const ISpeechDataKey,
            index: i32,
            value_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn setBinaryValue(self: *const T, value_name_: ?BSTR, value_: VARIANT) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).SetBinaryValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn getBinaryValue(self: *const T, value_name_: ?BSTR, value_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).GetBinaryValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn setStringValue(self: *const T, value_name_: ?BSTR, value_: ?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).SetStringValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn getStringValue(self: *const T, value_name_: ?BSTR, value_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn setLongValue(self: *const T, value_name_: ?BSTR, value_: i32) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).SetLongValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn getLongValue(self: *const T, value_name_: ?BSTR, value_: ?*i32) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).GetLongValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_, value_);
            }
            pub inline fn openKey(self: *const T, sub_key_name_: ?BSTR, sub_key_: ?*?*ISpeechDataKey) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).OpenKey(@as(*const ISpeechDataKey, @ptrCast(self)), sub_key_name_, sub_key_);
            }
            pub inline fn createKey(self: *const T, sub_key_name_: ?BSTR, sub_key_: ?*?*ISpeechDataKey) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).CreateKey(@as(*const ISpeechDataKey, @ptrCast(self)), sub_key_name_, sub_key_);
            }
            pub inline fn deleteKey(self: *const T, sub_key_name_: ?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).DeleteKey(@as(*const ISpeechDataKey, @ptrCast(self)), sub_key_name_);
            }
            pub inline fn deleteValue(self: *const T, value_name_: ?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).DeleteValue(@as(*const ISpeechDataKey, @ptrCast(self)), value_name_);
            }
            pub inline fn enumKeys(self: *const T, index_: i32, sub_key_name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).EnumKeys(@as(*const ISpeechDataKey, @ptrCast(self)), index_, sub_key_name_);
            }
            pub inline fn enumValues(self: *const T, index_: i32, value_name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechDataKey.VTable, @ptrCast(self.vtable)).EnumValues(@as(*const ISpeechDataKey, @ptrCast(self)), index_, value_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectToken_Value = Guid.initString("c74a3adc-b727-4500-a84a-b526721c8b8c");
pub const IID_ISpeechObjectToken = &IID_ISpeechObjectToken_Value;
pub const ISpeechObjectToken = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectToken,
            object_id: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataKey: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectToken,
            data_key: ?*?*ISpeechDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectToken,
            category: ?*?*ISpeechObjectTokenCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: *const fn (
            self: *const ISpeechObjectToken,
            locale: i32,
            description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetId: *const fn (
            self: *const ISpeechObjectToken,
            id: ?BSTR,
            category_i_d: ?BSTR,
            create_if_not_exist: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttribute: *const fn (
            self: *const ISpeechObjectToken,
            attribute_name: ?BSTR,
            attribute_value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: *const fn (
            self: *const ISpeechObjectToken,
            p_unk_outer: ?*IUnknown,
            cls_context: SpeechTokenContext,
            object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const ISpeechObjectToken,
            object_storage_c_l_s_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStorageFileName: *const fn (
            self: *const ISpeechObjectToken,
            object_storage_c_l_s_i_d: ?BSTR,
            key_name: ?BSTR,
            file_name: ?BSTR,
            folder: SpeechTokenShellFolder,
            file_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStorageFileName: *const fn (
            self: *const ISpeechObjectToken,
            object_storage_c_l_s_i_d: ?BSTR,
            key_name: ?BSTR,
            delete_file_a: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUISupported: *const fn (
            self: *const ISpeechObjectToken,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
            object: ?*IUnknown,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpeechObjectToken,
            h_wnd: i32,
            title: ?BSTR,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
            object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MatchesAttributes: *const fn (
            self: *const ISpeechObjectToken,
            attributes: ?BSTR,
            matches: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getId(self: *const T, object_id_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechObjectToken, @ptrCast(self)), object_id_);
            }
            pub inline fn getDataKey(self: *const T, data_key_: ?*?*ISpeechDataKey) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).get_DataKey(@as(*const ISpeechObjectToken, @ptrCast(self)), data_key_);
            }
            pub inline fn getCategory(self: *const T, category_: ?*?*ISpeechObjectTokenCategory) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).get_Category(@as(*const ISpeechObjectToken, @ptrCast(self)), category_);
            }
            pub inline fn getDescription(self: *const T, locale_: i32, description_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ISpeechObjectToken, @ptrCast(self)), locale_, description_);
            }
            pub inline fn setId(self: *const T, id_: ?BSTR, category_i_d_: ?BSTR, create_if_not_exist_: i16) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).SetId(@as(*const ISpeechObjectToken, @ptrCast(self)), id_, category_i_d_, create_if_not_exist_);
            }
            pub inline fn getAttribute(self: *const T, attribute_name_: ?BSTR, attribute_value_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).GetAttribute(@as(*const ISpeechObjectToken, @ptrCast(self)), attribute_name_, attribute_value_);
            }
            pub inline fn createInstance(self: *const T, p_unk_outer_: ?*IUnknown, cls_context_: SpeechTokenContext, object_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const ISpeechObjectToken, @ptrCast(self)), p_unk_outer_, cls_context_, object_);
            }
            pub inline fn remove(self: *const T, object_storage_c_l_s_i_d_: ?BSTR) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).Remove(@as(*const ISpeechObjectToken, @ptrCast(self)), object_storage_c_l_s_i_d_);
            }
            pub inline fn getStorageFileName(self: *const T, object_storage_c_l_s_i_d_: ?BSTR, key_name_: ?BSTR, file_name_: ?BSTR, folder_: SpeechTokenShellFolder, file_path_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).GetStorageFileName(@as(*const ISpeechObjectToken, @ptrCast(self)), object_storage_c_l_s_i_d_, key_name_, file_name_, folder_, file_path_);
            }
            pub inline fn removeStorageFileName(self: *const T, object_storage_c_l_s_i_d_: ?BSTR, key_name_: ?BSTR, delete_file_a_: i16) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).RemoveStorageFileName(@as(*const ISpeechObjectToken, @ptrCast(self)), object_storage_c_l_s_i_d_, key_name_, delete_file_a_);
            }
            pub inline fn isUISupported(self: *const T, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT, object_: ?*IUnknown, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpeechObjectToken, @ptrCast(self)), type_of_u_i_, extra_data_, object_, supported_);
            }
            pub inline fn displayUI(self: *const T, h_wnd_: i32, title_: ?BSTR, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT, object_: ?*IUnknown) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpeechObjectToken, @ptrCast(self)), h_wnd_, title_, type_of_u_i_, extra_data_, object_);
            }
            pub inline fn matchesAttributes(self: *const T, attributes_: ?BSTR, matches_: ?*i16) HRESULT {
                return @as(*const ISpeechObjectToken.VTable, @ptrCast(self.vtable)).MatchesAttributes(@as(*const ISpeechObjectToken, @ptrCast(self)), attributes_, matches_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectTokens_Value = Guid.initString("9285b776-2e7b-4bc0-b53e-580eb6fa967f");
pub const IID_ISpeechObjectTokens = &IID_ISpeechObjectTokens_Value;
pub const ISpeechObjectTokens = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectTokens,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechObjectTokens,
            index: i32,
            token: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectTokens,
            pp_enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechObjectTokens.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechObjectTokens, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, token_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechObjectTokens.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechObjectTokens, @ptrCast(self)), index_, token_);
            }
            pub inline fn getNewEnum(self: *const T, pp_enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechObjectTokens.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechObjectTokens, @ptrCast(self)), pp_enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectTokenCategory_Value = Guid.initString("ca7eac50-2d01-4145-86d4-5ae7d70f4469");
pub const IID_ISpeechObjectTokenCategory = &IID_ISpeechObjectTokenCategory_Value;
pub const ISpeechObjectTokenCategory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectTokenCategory,
            id: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Default: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectTokenCategory,
            token_id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Default: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechObjectTokenCategory,
            token_id: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetId: *const fn (
            self: *const ISpeechObjectTokenCategory,
            id: ?BSTR,
            create_if_not_exist: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataKey: *const fn (
            self: *const ISpeechObjectTokenCategory,
            location: SpeechDataKeyLocation,
            data_key: ?*?*ISpeechDataKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateTokens: *const fn (
            self: *const ISpeechObjectTokenCategory,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getId(self: *const T, id_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), id_);
            }
            pub inline fn putDefault(self: *const T, token_id_: ?BSTR) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).put_Default(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), token_id_);
            }
            pub inline fn getDefault(self: *const T, token_id_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).get_Default(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), token_id_);
            }
            pub inline fn setId(self: *const T, id_: ?BSTR, create_if_not_exist_: i16) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).SetId(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), id_, create_if_not_exist_);
            }
            pub inline fn getDataKey(self: *const T, location_: SpeechDataKeyLocation, data_key_: ?*?*ISpeechDataKey) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).GetDataKey(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), location_, data_key_);
            }
            pub inline fn enumerateTokens(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechObjectTokenCategory.VTable, @ptrCast(self.vtable)).EnumerateTokens(@as(*const ISpeechObjectTokenCategory, @ptrCast(self)), required_attributes_, optional_attributes_, tokens_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioBufferInfo_Value = Guid.initString("11b103d8-1142-4edf-a093-82fb3915f8cc");
pub const IID_ISpeechAudioBufferInfo = &IID_ISpeechAudioBufferInfo_Value;
pub const ISpeechAudioBufferInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinNotification: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            min_notification: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinNotification: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            min_notification: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            buffer_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            buffer_size: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventBias: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            event_bias: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventBias: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioBufferInfo,
            event_bias: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getMinNotification(self: *const T, min_notification_: ?*i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).get_MinNotification(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), min_notification_);
            }
            pub inline fn putMinNotification(self: *const T, min_notification_: i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).put_MinNotification(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), min_notification_);
            }
            pub inline fn getBufferSize(self: *const T, buffer_size_: ?*i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).get_BufferSize(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), buffer_size_);
            }
            pub inline fn putBufferSize(self: *const T, buffer_size_: i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).put_BufferSize(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), buffer_size_);
            }
            pub inline fn getEventBias(self: *const T, event_bias_: ?*i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).get_EventBias(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), event_bias_);
            }
            pub inline fn putEventBias(self: *const T, event_bias_: i32) HRESULT {
                return @as(*const ISpeechAudioBufferInfo.VTable, @ptrCast(self.vtable)).put_EventBias(@as(*const ISpeechAudioBufferInfo, @ptrCast(self)), event_bias_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioStatus_Value = Guid.initString("c62d9c91-7458-47f6-862d-1ef86fb0b278");
pub const IID_ISpeechAudioStatus = &IID_ISpeechAudioStatus_Value;
pub const ISpeechAudioStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeBufferSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioStatus,
            free_buffer_space: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonBlockingIO: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioStatus,
            non_blocking_i_o: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioStatus,
            state: ?*SpeechAudioState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSeekPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioStatus,
            current_seek_position: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDevicePosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioStatus,
            current_device_position: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getFreeBufferSpace(self: *const T, free_buffer_space_: ?*i32) HRESULT {
                return @as(*const ISpeechAudioStatus.VTable, @ptrCast(self.vtable)).get_FreeBufferSpace(@as(*const ISpeechAudioStatus, @ptrCast(self)), free_buffer_space_);
            }
            pub inline fn getNonBlockingIO(self: *const T, non_blocking_i_o_: ?*i32) HRESULT {
                return @as(*const ISpeechAudioStatus.VTable, @ptrCast(self.vtable)).get_NonBlockingIO(@as(*const ISpeechAudioStatus, @ptrCast(self)), non_blocking_i_o_);
            }
            pub inline fn getState(self: *const T, state_: ?*SpeechAudioState) HRESULT {
                return @as(*const ISpeechAudioStatus.VTable, @ptrCast(self.vtable)).get_State(@as(*const ISpeechAudioStatus, @ptrCast(self)), state_);
            }
            pub inline fn getCurrentSeekPosition(self: *const T, current_seek_position_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechAudioStatus.VTable, @ptrCast(self.vtable)).get_CurrentSeekPosition(@as(*const ISpeechAudioStatus, @ptrCast(self)), current_seek_position_);
            }
            pub inline fn getCurrentDevicePosition(self: *const T, current_device_position_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechAudioStatus.VTable, @ptrCast(self.vtable)).get_CurrentDevicePosition(@as(*const ISpeechAudioStatus, @ptrCast(self)), current_device_position_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioFormat_Value = Guid.initString("e6e9c590-3e18-40e3-8299-061f98bde7c7");
pub const IID_ISpeechAudioFormat = &IID_ISpeechAudioFormat_Value;
pub const ISpeechAudioFormat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioFormat,
            audio_format: ?*SpeechAudioFormatType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioFormat,
            audio_format: SpeechAudioFormatType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioFormat,
            guid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guid: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudioFormat,
            guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWaveFormatEx: *const fn (
            self: *const ISpeechAudioFormat,
            speech_wave_format_ex: ?*?*ISpeechWaveFormatEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWaveFormatEx: *const fn (
            self: *const ISpeechAudioFormat,
            speech_wave_format_ex: ?*ISpeechWaveFormatEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, audio_format_: ?*SpeechAudioFormatType) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).get_Type(@as(*const ISpeechAudioFormat, @ptrCast(self)), audio_format_);
            }
            pub inline fn putType(self: *const T, audio_format_: SpeechAudioFormatType) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).put_Type(@as(*const ISpeechAudioFormat, @ptrCast(self)), audio_format_);
            }
            pub inline fn getGuid(self: *const T, guid_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).get_Guid(@as(*const ISpeechAudioFormat, @ptrCast(self)), guid_);
            }
            pub inline fn putGuid(self: *const T, guid_: ?BSTR) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).put_Guid(@as(*const ISpeechAudioFormat, @ptrCast(self)), guid_);
            }
            pub inline fn getWaveFormatEx(self: *const T, speech_wave_format_ex_: ?*?*ISpeechWaveFormatEx) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).GetWaveFormatEx(@as(*const ISpeechAudioFormat, @ptrCast(self)), speech_wave_format_ex_);
            }
            pub inline fn setWaveFormatEx(self: *const T, speech_wave_format_ex_: ?*ISpeechWaveFormatEx) HRESULT {
                return @as(*const ISpeechAudioFormat.VTable, @ptrCast(self.vtable)).SetWaveFormatEx(@as(*const ISpeechAudioFormat, @ptrCast(self)), speech_wave_format_ex_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechWaveFormatEx_Value = Guid.initString("7a1ef0d5-1581-4741-88e4-209a49f11a10");
pub const IID_ISpeechWaveFormatEx = &IID_ISpeechWaveFormatEx_Value;
pub const ISpeechWaveFormatEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FormatTag: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            format_tag: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FormatTag: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            format_tag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channels: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            channels: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channels: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            channels: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SamplesPerSec: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            samples_per_sec: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SamplesPerSec: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            samples_per_sec: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgBytesPerSec: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            avg_bytes_per_sec: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AvgBytesPerSec: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            avg_bytes_per_sec: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockAlign: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            block_align: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockAlign: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            block_align: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerSample: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            bits_per_sample: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BitsPerSample: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            bits_per_sample: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtraData: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            extra_data: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtraData: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechWaveFormatEx,
            extra_data: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getFormatTag(self: *const T, format_tag_: ?*i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_FormatTag(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), format_tag_);
            }
            pub inline fn putFormatTag(self: *const T, format_tag_: i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_FormatTag(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), format_tag_);
            }
            pub inline fn getChannels(self: *const T, channels_: ?*i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_Channels(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), channels_);
            }
            pub inline fn putChannels(self: *const T, channels_: i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_Channels(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), channels_);
            }
            pub inline fn getSamplesPerSec(self: *const T, samples_per_sec_: ?*i32) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_SamplesPerSec(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), samples_per_sec_);
            }
            pub inline fn putSamplesPerSec(self: *const T, samples_per_sec_: i32) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_SamplesPerSec(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), samples_per_sec_);
            }
            pub inline fn getAvgBytesPerSec(self: *const T, avg_bytes_per_sec_: ?*i32) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_AvgBytesPerSec(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), avg_bytes_per_sec_);
            }
            pub inline fn putAvgBytesPerSec(self: *const T, avg_bytes_per_sec_: i32) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_AvgBytesPerSec(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), avg_bytes_per_sec_);
            }
            pub inline fn getBlockAlign(self: *const T, block_align_: ?*i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_BlockAlign(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), block_align_);
            }
            pub inline fn putBlockAlign(self: *const T, block_align_: i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_BlockAlign(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), block_align_);
            }
            pub inline fn getBitsPerSample(self: *const T, bits_per_sample_: ?*i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_BitsPerSample(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), bits_per_sample_);
            }
            pub inline fn putBitsPerSample(self: *const T, bits_per_sample_: i16) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_BitsPerSample(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), bits_per_sample_);
            }
            pub inline fn getExtraData(self: *const T, extra_data_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).get_ExtraData(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), extra_data_);
            }
            pub inline fn putExtraData(self: *const T, extra_data_: VARIANT) HRESULT {
                return @as(*const ISpeechWaveFormatEx.VTable, @ptrCast(self.vtable)).put_ExtraData(@as(*const ISpeechWaveFormatEx, @ptrCast(self)), extra_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechBaseStream_Value = Guid.initString("6450336f-7d49-4ced-8097-49d6dee37294");
pub const IID_ISpeechBaseStream = &IID_ISpeechBaseStream_Value;
pub const ISpeechBaseStream = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Format: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechBaseStream,
            audio_format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_Format: *const fn (
            self: *const ISpeechBaseStream,
            audio_format: ?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: *const fn (
            self: *const ISpeechBaseStream,
            buffer: ?*VARIANT,
            number_of_bytes: i32,
            bytes_read: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: *const fn (
            self: *const ISpeechBaseStream,
            buffer: VARIANT,
            bytes_written: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: *const fn (
            self: *const ISpeechBaseStream,
            position: VARIANT,
            origin: SpeechStreamSeekPositionType,
            new_position: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getFormat(self: *const T, audio_format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechBaseStream.VTable, @ptrCast(self.vtable)).get_Format(@as(*const ISpeechBaseStream, @ptrCast(self)), audio_format_);
            }
            pub inline fn putrefFormat(self: *const T, audio_format_: ?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechBaseStream.VTable, @ptrCast(self.vtable)).putref_Format(@as(*const ISpeechBaseStream, @ptrCast(self)), audio_format_);
            }
            pub inline fn read(self: *const T, buffer_: ?*VARIANT, number_of_bytes_: i32, bytes_read_: ?*i32) HRESULT {
                return @as(*const ISpeechBaseStream.VTable, @ptrCast(self.vtable)).Read(@as(*const ISpeechBaseStream, @ptrCast(self)), buffer_, number_of_bytes_, bytes_read_);
            }
            pub inline fn write(self: *const T, buffer_: VARIANT, bytes_written_: ?*i32) HRESULT {
                return @as(*const ISpeechBaseStream.VTable, @ptrCast(self.vtable)).Write(@as(*const ISpeechBaseStream, @ptrCast(self)), buffer_, bytes_written_);
            }
            pub inline fn seek(self: *const T, position_: VARIANT, origin_: SpeechStreamSeekPositionType, new_position_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechBaseStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const ISpeechBaseStream, @ptrCast(self)), position_, origin_, new_position_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechFileStream_Value = Guid.initString("af67f125-ab39-4e93-b4a2-cc2e66e182a7");
pub const IID_ISpeechFileStream = &IID_ISpeechFileStream_Value;
pub const ISpeechFileStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        Open: *const fn (
            self: *const ISpeechFileStream,
            file_name: ?BSTR,
            file_mode: SpeechStreamFileMode,
            do_events: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const ISpeechFileStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechBaseStream.MethodMixin(T);
            pub inline fn open(self: *const T, file_name_: ?BSTR, file_mode_: SpeechStreamFileMode, do_events_: i16) HRESULT {
                return @as(*const ISpeechFileStream.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpeechFileStream, @ptrCast(self)), file_name_, file_mode_, do_events_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const ISpeechFileStream.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpeechFileStream, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechMemoryStream_Value = Guid.initString("eeb14b68-808b-4abe-a5ea-b51da7588008");
pub const IID_ISpeechMemoryStream = &IID_ISpeechMemoryStream_Value;
pub const ISpeechMemoryStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        SetData: *const fn (
            self: *const ISpeechMemoryStream,
            data: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const ISpeechMemoryStream,
            p_data: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechBaseStream.MethodMixin(T);
            pub inline fn setData(self: *const T, data_: VARIANT) HRESULT {
                return @as(*const ISpeechMemoryStream.VTable, @ptrCast(self.vtable)).SetData(@as(*const ISpeechMemoryStream, @ptrCast(self)), data_);
            }
            pub inline fn getData(self: *const T, p_data_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechMemoryStream.VTable, @ptrCast(self.vtable)).GetData(@as(*const ISpeechMemoryStream, @ptrCast(self)), p_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechCustomStream_Value = Guid.initString("1a9e9f4f-104f-4db8-a115-efd7fd0c97ae");
pub const IID_ISpeechCustomStream = &IID_ISpeechCustomStream_Value;
pub const ISpeechCustomStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechCustomStream,
            pp_unk_stream: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_BaseStream: *const fn (
            self: *const ISpeechCustomStream,
            p_unk_stream: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechBaseStream.MethodMixin(T);
            pub inline fn getBaseStream(self: *const T, pp_unk_stream_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechCustomStream.VTable, @ptrCast(self.vtable)).get_BaseStream(@as(*const ISpeechCustomStream, @ptrCast(self)), pp_unk_stream_);
            }
            pub inline fn putrefBaseStream(self: *const T, p_unk_stream_: ?*IUnknown) HRESULT {
                return @as(*const ISpeechCustomStream.VTable, @ptrCast(self.vtable)).putref_BaseStream(@as(*const ISpeechCustomStream, @ptrCast(self)), p_unk_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudio_Value = Guid.initString("cff8e175-019e-11d3-a08e-00c04f8ef9b5");
pub const IID_ISpeechAudio = &IID_ISpeechAudio_Value;
pub const ISpeechAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            status: ?*?*ISpeechAudioStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            buffer_info: ?*?*ISpeechAudioBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            stream_format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            volume: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            volume: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferNotifySize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            buffer_notify_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferNotifySize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            buffer_notify_size: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventHandle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechAudio,
            event_handle: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: *const fn (
            self: *const ISpeechAudio,
            state: SpeechAudioState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechBaseStream.MethodMixin(T);
            pub inline fn getStatus(self: *const T, status_: ?*?*ISpeechAudioStatus) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_Status(@as(*const ISpeechAudio, @ptrCast(self)), status_);
            }
            pub inline fn getBufferInfo(self: *const T, buffer_info_: ?*?*ISpeechAudioBufferInfo) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_BufferInfo(@as(*const ISpeechAudio, @ptrCast(self)), buffer_info_);
            }
            pub inline fn getDefaultFormat(self: *const T, stream_format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_DefaultFormat(@as(*const ISpeechAudio, @ptrCast(self)), stream_format_);
            }
            pub inline fn getVolume(self: *const T, volume_: ?*i32) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const ISpeechAudio, @ptrCast(self)), volume_);
            }
            pub inline fn putVolume(self: *const T, volume_: i32) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const ISpeechAudio, @ptrCast(self)), volume_);
            }
            pub inline fn getBufferNotifySize(self: *const T, buffer_notify_size_: ?*i32) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_BufferNotifySize(@as(*const ISpeechAudio, @ptrCast(self)), buffer_notify_size_);
            }
            pub inline fn putBufferNotifySize(self: *const T, buffer_notify_size_: i32) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).put_BufferNotifySize(@as(*const ISpeechAudio, @ptrCast(self)), buffer_notify_size_);
            }
            pub inline fn getEventHandle(self: *const T, event_handle_: ?*i32) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).get_EventHandle(@as(*const ISpeechAudio, @ptrCast(self)), event_handle_);
            }
            pub inline fn setState(self: *const T, state_: SpeechAudioState) HRESULT {
                return @as(*const ISpeechAudio.VTable, @ptrCast(self.vtable)).SetState(@as(*const ISpeechAudio, @ptrCast(self)), state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechMMSysAudio_Value = Guid.initString("3c76af6d-1fd7-4831-81d1-3b71d5a13c44");
pub const IID_ISpeechMMSysAudio = &IID_ISpeechMMSysAudio_Value;
pub const ISpeechMMSysAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpeechAudio.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechMMSysAudio,
            device_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DeviceId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechMMSysAudio,
            device_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LineId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechMMSysAudio,
            line_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LineId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechMMSysAudio,
            line_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MMHandle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechMMSysAudio,
            handle: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechAudio.MethodMixin(T);
            pub inline fn getDeviceId(self: *const T, device_id_: ?*i32) HRESULT {
                return @as(*const ISpeechMMSysAudio.VTable, @ptrCast(self.vtable)).get_DeviceId(@as(*const ISpeechMMSysAudio, @ptrCast(self)), device_id_);
            }
            pub inline fn putDeviceId(self: *const T, device_id_: i32) HRESULT {
                return @as(*const ISpeechMMSysAudio.VTable, @ptrCast(self.vtable)).put_DeviceId(@as(*const ISpeechMMSysAudio, @ptrCast(self)), device_id_);
            }
            pub inline fn getLineId(self: *const T, line_id_: ?*i32) HRESULT {
                return @as(*const ISpeechMMSysAudio.VTable, @ptrCast(self.vtable)).get_LineId(@as(*const ISpeechMMSysAudio, @ptrCast(self)), line_id_);
            }
            pub inline fn putLineId(self: *const T, line_id_: i32) HRESULT {
                return @as(*const ISpeechMMSysAudio.VTable, @ptrCast(self.vtable)).put_LineId(@as(*const ISpeechMMSysAudio, @ptrCast(self)), line_id_);
            }
            pub inline fn getMMHandle(self: *const T, handle_: ?*i32) HRESULT {
                return @as(*const ISpeechMMSysAudio.VTable, @ptrCast(self.vtable)).get_MMHandle(@as(*const ISpeechMMSysAudio, @ptrCast(self)), handle_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechVoice_Value = Guid.initString("269316d8-57bd-11d2-9eee-00c04f797396");
pub const IID_ISpeechVoice = &IID_ISpeechVoice_Value;
pub const ISpeechVoice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            status: ?*?*ISpeechVoiceStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Voice: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            voice: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_Voice: *const fn (
            self: *const ISpeechVoice,
            voice: ?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioOutput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            audio_output: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioOutput: *const fn (
            self: *const ISpeechVoice,
            audio_output: ?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioOutputStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            audio_output_stream: ?*?*ISpeechBaseStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioOutputStream: *const fn (
            self: *const ISpeechVoice,
            audio_output_stream: ?*ISpeechBaseStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            rate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            volume: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            volume: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowAudioOutputFormatChangesOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowAudioOutputFormatChangesOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventInterests: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            event_interest_flags: ?*SpeechVoiceEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventInterests: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            event_interest_flags: SpeechVoiceEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Priority: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            priority: SpeechVoicePriority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Priority: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            priority: ?*SpeechVoicePriority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlertBoundary: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            boundary: SpeechVoiceEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlertBoundary: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            boundary: ?*SpeechVoiceEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SynchronousSpeakTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            ms_timeout: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SynchronousSpeakTimeout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoice,
            ms_timeout: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Speak: *const fn (
            self: *const ISpeechVoice,
            text: ?BSTR,
            flags: SpeechVoiceSpeakFlags,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakStream: *const fn (
            self: *const ISpeechVoice,
            stream: ?*ISpeechBaseStream,
            flags: SpeechVoiceSpeakFlags,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const ISpeechVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const ISpeechVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const ISpeechVoice,
            type: ?BSTR,
            num_items: i32,
            num_skipped: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVoices: *const fn (
            self: *const ISpeechVoice,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            object_tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioOutputs: *const fn (
            self: *const ISpeechVoice,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            object_tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitUntilDone: *const fn (
            self: *const ISpeechVoice,
            ms_timeout: i32,
            done: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakCompleteEvent: *const fn (
            self: *const ISpeechVoice,
            handle: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUISupported: *const fn (
            self: *const ISpeechVoice,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpeechVoice,
            h_wnd_parent: i32,
            title: ?BSTR,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStatus(self: *const T, status_: ?*?*ISpeechVoiceStatus) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_Status(@as(*const ISpeechVoice, @ptrCast(self)), status_);
            }
            pub inline fn getVoice(self: *const T, voice_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_Voice(@as(*const ISpeechVoice, @ptrCast(self)), voice_);
            }
            pub inline fn putrefVoice(self: *const T, voice_: ?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).putref_Voice(@as(*const ISpeechVoice, @ptrCast(self)), voice_);
            }
            pub inline fn getAudioOutput(self: *const T, audio_output_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_AudioOutput(@as(*const ISpeechVoice, @ptrCast(self)), audio_output_);
            }
            pub inline fn putrefAudioOutput(self: *const T, audio_output_: ?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).putref_AudioOutput(@as(*const ISpeechVoice, @ptrCast(self)), audio_output_);
            }
            pub inline fn getAudioOutputStream(self: *const T, audio_output_stream_: ?*?*ISpeechBaseStream) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_AudioOutputStream(@as(*const ISpeechVoice, @ptrCast(self)), audio_output_stream_);
            }
            pub inline fn putrefAudioOutputStream(self: *const T, audio_output_stream_: ?*ISpeechBaseStream) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).putref_AudioOutputStream(@as(*const ISpeechVoice, @ptrCast(self)), audio_output_stream_);
            }
            pub inline fn getRate(self: *const T, rate_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const ISpeechVoice, @ptrCast(self)), rate_);
            }
            pub inline fn putRate(self: *const T, rate_: i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const ISpeechVoice, @ptrCast(self)), rate_);
            }
            pub inline fn getVolume(self: *const T, volume_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const ISpeechVoice, @ptrCast(self)), volume_);
            }
            pub inline fn putVolume(self: *const T, volume_: i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const ISpeechVoice, @ptrCast(self)), volume_);
            }
            pub inline fn putAllowAudioOutputFormatChangesOnNextSet(self: *const T, allow_: i16) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_AllowAudioOutputFormatChangesOnNextSet(@as(*const ISpeechVoice, @ptrCast(self)), allow_);
            }
            pub inline fn getAllowAudioOutputFormatChangesOnNextSet(self: *const T, allow_: ?*i16) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_AllowAudioOutputFormatChangesOnNextSet(@as(*const ISpeechVoice, @ptrCast(self)), allow_);
            }
            pub inline fn getEventInterests(self: *const T, event_interest_flags_: ?*SpeechVoiceEvents) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_EventInterests(@as(*const ISpeechVoice, @ptrCast(self)), event_interest_flags_);
            }
            pub inline fn putEventInterests(self: *const T, event_interest_flags_: SpeechVoiceEvents) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_EventInterests(@as(*const ISpeechVoice, @ptrCast(self)), event_interest_flags_);
            }
            pub inline fn putPriority(self: *const T, priority_: SpeechVoicePriority) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_Priority(@as(*const ISpeechVoice, @ptrCast(self)), priority_);
            }
            pub inline fn getPriority(self: *const T, priority_: ?*SpeechVoicePriority) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_Priority(@as(*const ISpeechVoice, @ptrCast(self)), priority_);
            }
            pub inline fn putAlertBoundary(self: *const T, boundary_: SpeechVoiceEvents) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_AlertBoundary(@as(*const ISpeechVoice, @ptrCast(self)), boundary_);
            }
            pub inline fn getAlertBoundary(self: *const T, boundary_: ?*SpeechVoiceEvents) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_AlertBoundary(@as(*const ISpeechVoice, @ptrCast(self)), boundary_);
            }
            pub inline fn putSynchronousSpeakTimeout(self: *const T, ms_timeout_: i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).put_SynchronousSpeakTimeout(@as(*const ISpeechVoice, @ptrCast(self)), ms_timeout_);
            }
            pub inline fn getSynchronousSpeakTimeout(self: *const T, ms_timeout_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).get_SynchronousSpeakTimeout(@as(*const ISpeechVoice, @ptrCast(self)), ms_timeout_);
            }
            pub inline fn speak(self: *const T, text_: ?BSTR, flags_: SpeechVoiceSpeakFlags, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).Speak(@as(*const ISpeechVoice, @ptrCast(self)), text_, flags_, stream_number_);
            }
            pub inline fn speakStream(self: *const T, stream_: ?*ISpeechBaseStream, flags_: SpeechVoiceSpeakFlags, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).SpeakStream(@as(*const ISpeechVoice, @ptrCast(self)), stream_, flags_, stream_number_);
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).Pause(@as(*const ISpeechVoice, @ptrCast(self)));
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).Resume(@as(*const ISpeechVoice, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, type_: ?BSTR, num_items_: i32, num_skipped_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).Skip(@as(*const ISpeechVoice, @ptrCast(self)), type_, num_items_, num_skipped_);
            }
            pub inline fn getVoices(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, object_tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).GetVoices(@as(*const ISpeechVoice, @ptrCast(self)), required_attributes_, optional_attributes_, object_tokens_);
            }
            pub inline fn getAudioOutputs(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, object_tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).GetAudioOutputs(@as(*const ISpeechVoice, @ptrCast(self)), required_attributes_, optional_attributes_, object_tokens_);
            }
            pub inline fn waitUntilDone(self: *const T, ms_timeout_: i32, done_: ?*i16) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).WaitUntilDone(@as(*const ISpeechVoice, @ptrCast(self)), ms_timeout_, done_);
            }
            pub inline fn speakCompleteEvent(self: *const T, handle_: ?*i32) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).SpeakCompleteEvent(@as(*const ISpeechVoice, @ptrCast(self)), handle_);
            }
            pub inline fn isUISupported(self: *const T, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpeechVoice, @ptrCast(self)), type_of_u_i_, extra_data_, supported_);
            }
            pub inline fn displayUI(self: *const T, h_wnd_parent_: i32, title_: ?BSTR, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT) HRESULT {
                return @as(*const ISpeechVoice.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpeechVoice, @ptrCast(self)), h_wnd_parent_, title_, type_of_u_i_, extra_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechVoiceStatus_Value = Guid.initString("8be47b07-57f6-11d2-9eee-00c04f797396");
pub const IID_ISpeechVoiceStatus = &IID_ISpeechVoiceStatus_Value;
pub const ISpeechVoiceStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastStreamNumberQueued: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastHResult: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            h_result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunningState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            state: ?*SpeechRunState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputWordPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            position: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputWordLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputSentencePosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            position: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputSentenceLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBookmark: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            bookmark: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBookmarkId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            bookmark_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhonemeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            phone_id: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VisemeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechVoiceStatus,
            viseme_id: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCurrentStreamNumber(self: *const T, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_CurrentStreamNumber(@as(*const ISpeechVoiceStatus, @ptrCast(self)), stream_number_);
            }
            pub inline fn getLastStreamNumberQueued(self: *const T, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_LastStreamNumberQueued(@as(*const ISpeechVoiceStatus, @ptrCast(self)), stream_number_);
            }
            pub inline fn getLastHResult(self: *const T, h_result_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_LastHResult(@as(*const ISpeechVoiceStatus, @ptrCast(self)), h_result_);
            }
            pub inline fn getRunningState(self: *const T, state_: ?*SpeechRunState) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_RunningState(@as(*const ISpeechVoiceStatus, @ptrCast(self)), state_);
            }
            pub inline fn getInputWordPosition(self: *const T, position_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_InputWordPosition(@as(*const ISpeechVoiceStatus, @ptrCast(self)), position_);
            }
            pub inline fn getInputWordLength(self: *const T, length_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_InputWordLength(@as(*const ISpeechVoiceStatus, @ptrCast(self)), length_);
            }
            pub inline fn getInputSentencePosition(self: *const T, position_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_InputSentencePosition(@as(*const ISpeechVoiceStatus, @ptrCast(self)), position_);
            }
            pub inline fn getInputSentenceLength(self: *const T, length_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_InputSentenceLength(@as(*const ISpeechVoiceStatus, @ptrCast(self)), length_);
            }
            pub inline fn getLastBookmark(self: *const T, bookmark_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_LastBookmark(@as(*const ISpeechVoiceStatus, @ptrCast(self)), bookmark_);
            }
            pub inline fn getLastBookmarkId(self: *const T, bookmark_id_: ?*i32) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_LastBookmarkId(@as(*const ISpeechVoiceStatus, @ptrCast(self)), bookmark_id_);
            }
            pub inline fn getPhonemeId(self: *const T, phone_id_: ?*i16) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_PhonemeId(@as(*const ISpeechVoiceStatus, @ptrCast(self)), phone_id_);
            }
            pub inline fn getVisemeId(self: *const T, viseme_id_: ?*i16) HRESULT {
                return @as(*const ISpeechVoiceStatus.VTable, @ptrCast(self.vtable)).get_VisemeId(@as(*const ISpeechVoiceStatus, @ptrCast(self)), viseme_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__ISpeechVoiceEvents_Value = Guid.initString("a372acd1-3bef-4bbd-8ffb-cb3e2b416af8");
pub const IID__ISpeechVoiceEvents = &IID__ISpeechVoiceEvents_Value;
pub const _ISpeechVoiceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecognizer_Value = Guid.initString("2d5f1c0c-bd75-4b08-9478-3b11fea2586c");
pub const IID_ISpeechRecognizer = &IID_ISpeechRecognizer_Value;
pub const ISpeechRecognizer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_Recognizer: *const fn (
            self: *const ISpeechRecognizer,
            recognizer: ?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            recognizer: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowAudioInputFormatChangesOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowAudioInputFormatChangesOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioInput: *const fn (
            self: *const ISpeechRecognizer,
            audio_input: ?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            audio_input: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioInputStream: *const fn (
            self: *const ISpeechRecognizer,
            audio_input_stream: ?*ISpeechBaseStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInputStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            audio_input_stream: ?*?*ISpeechBaseStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsShared: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            shared: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            state: SpeechRecognizerState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            state: ?*SpeechRecognizerState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            status: ?*?*ISpeechRecognizerStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_Profile: *const fn (
            self: *const ISpeechRecognizer,
            profile: ?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizer,
            profile: ?*?*ISpeechObjectToken,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmulateRecognition: *const fn (
            self: *const ISpeechRecognizer,
            text_elements: VARIANT,
            element_display_attributes: ?*VARIANT,
            language_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRecoContext: *const fn (
            self: *const ISpeechRecognizer,
            new_context: ?*?*ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: *const fn (
            self: *const ISpeechRecognizer,
            type: SpeechFormatType,
            format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPropertyNumber: *const fn (
            self: *const ISpeechRecognizer,
            name: ?BSTR,
            value: i32,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyNumber: *const fn (
            self: *const ISpeechRecognizer,
            name: ?BSTR,
            value: ?*i32,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPropertyString: *const fn (
            self: *const ISpeechRecognizer,
            name: ?BSTR,
            value: ?BSTR,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyString: *const fn (
            self: *const ISpeechRecognizer,
            name: ?BSTR,
            value: ?*?BSTR,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUISupported: *const fn (
            self: *const ISpeechRecognizer,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
            supported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUI: *const fn (
            self: *const ISpeechRecognizer,
            h_wnd_parent: i32,
            title: ?BSTR,
            type_of_u_i: ?BSTR,
            extra_data: ?*const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecognizers: *const fn (
            self: *const ISpeechRecognizer,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            object_tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioInputs: *const fn (
            self: *const ISpeechRecognizer,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            object_tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProfiles: *const fn (
            self: *const ISpeechRecognizer,
            required_attributes: ?BSTR,
            optional_attributes: ?BSTR,
            object_tokens: ?*?*ISpeechObjectTokens,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putrefRecognizer(self: *const T, recognizer_: ?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).putref_Recognizer(@as(*const ISpeechRecognizer, @ptrCast(self)), recognizer_);
            }
            pub inline fn getRecognizer(self: *const T, recognizer_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_Recognizer(@as(*const ISpeechRecognizer, @ptrCast(self)), recognizer_);
            }
            pub inline fn putAllowAudioInputFormatChangesOnNextSet(self: *const T, allow_: i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).put_AllowAudioInputFormatChangesOnNextSet(@as(*const ISpeechRecognizer, @ptrCast(self)), allow_);
            }
            pub inline fn getAllowAudioInputFormatChangesOnNextSet(self: *const T, allow_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_AllowAudioInputFormatChangesOnNextSet(@as(*const ISpeechRecognizer, @ptrCast(self)), allow_);
            }
            pub inline fn putrefAudioInput(self: *const T, audio_input_: ?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).putref_AudioInput(@as(*const ISpeechRecognizer, @ptrCast(self)), audio_input_);
            }
            pub inline fn getAudioInput(self: *const T, audio_input_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_AudioInput(@as(*const ISpeechRecognizer, @ptrCast(self)), audio_input_);
            }
            pub inline fn putrefAudioInputStream(self: *const T, audio_input_stream_: ?*ISpeechBaseStream) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).putref_AudioInputStream(@as(*const ISpeechRecognizer, @ptrCast(self)), audio_input_stream_);
            }
            pub inline fn getAudioInputStream(self: *const T, audio_input_stream_: ?*?*ISpeechBaseStream) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_AudioInputStream(@as(*const ISpeechRecognizer, @ptrCast(self)), audio_input_stream_);
            }
            pub inline fn getIsShared(self: *const T, shared_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_IsShared(@as(*const ISpeechRecognizer, @ptrCast(self)), shared_);
            }
            pub inline fn putState(self: *const T, state_: SpeechRecognizerState) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).put_State(@as(*const ISpeechRecognizer, @ptrCast(self)), state_);
            }
            pub inline fn getState(self: *const T, state_: ?*SpeechRecognizerState) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_State(@as(*const ISpeechRecognizer, @ptrCast(self)), state_);
            }
            pub inline fn getStatus(self: *const T, status_: ?*?*ISpeechRecognizerStatus) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_Status(@as(*const ISpeechRecognizer, @ptrCast(self)), status_);
            }
            pub inline fn putrefProfile(self: *const T, profile_: ?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).putref_Profile(@as(*const ISpeechRecognizer, @ptrCast(self)), profile_);
            }
            pub inline fn getProfile(self: *const T, profile_: ?*?*ISpeechObjectToken) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).get_Profile(@as(*const ISpeechRecognizer, @ptrCast(self)), profile_);
            }
            pub inline fn emulateRecognition(self: *const T, text_elements_: VARIANT, element_display_attributes_: ?*VARIANT, language_id_: i32) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).EmulateRecognition(@as(*const ISpeechRecognizer, @ptrCast(self)), text_elements_, element_display_attributes_, language_id_);
            }
            pub inline fn createRecoContext(self: *const T, new_context_: ?*?*ISpeechRecoContext) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).CreateRecoContext(@as(*const ISpeechRecognizer, @ptrCast(self)), new_context_);
            }
            pub inline fn getFormat(self: *const T, type_: SpeechFormatType, format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const ISpeechRecognizer, @ptrCast(self)), type_, format_);
            }
            pub inline fn setPropertyNumber(self: *const T, name_: ?BSTR, value_: i32, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).SetPropertyNumber(@as(*const ISpeechRecognizer, @ptrCast(self)), name_, value_, supported_);
            }
            pub inline fn getPropertyNumber(self: *const T, name_: ?BSTR, value_: ?*i32, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetPropertyNumber(@as(*const ISpeechRecognizer, @ptrCast(self)), name_, value_, supported_);
            }
            pub inline fn setPropertyString(self: *const T, name_: ?BSTR, value_: ?BSTR, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).SetPropertyString(@as(*const ISpeechRecognizer, @ptrCast(self)), name_, value_, supported_);
            }
            pub inline fn getPropertyString(self: *const T, name_: ?BSTR, value_: ?*?BSTR, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetPropertyString(@as(*const ISpeechRecognizer, @ptrCast(self)), name_, value_, supported_);
            }
            pub inline fn isUISupported(self: *const T, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT, supported_: ?*i16) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).IsUISupported(@as(*const ISpeechRecognizer, @ptrCast(self)), type_of_u_i_, extra_data_, supported_);
            }
            pub inline fn displayUI(self: *const T, h_wnd_parent_: i32, title_: ?BSTR, type_of_u_i_: ?BSTR, extra_data_: ?*const VARIANT) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).DisplayUI(@as(*const ISpeechRecognizer, @ptrCast(self)), h_wnd_parent_, title_, type_of_u_i_, extra_data_);
            }
            pub inline fn getRecognizers(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, object_tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetRecognizers(@as(*const ISpeechRecognizer, @ptrCast(self)), required_attributes_, optional_attributes_, object_tokens_);
            }
            pub inline fn getAudioInputs(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, object_tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetAudioInputs(@as(*const ISpeechRecognizer, @ptrCast(self)), required_attributes_, optional_attributes_, object_tokens_);
            }
            pub inline fn getProfiles(self: *const T, required_attributes_: ?BSTR, optional_attributes_: ?BSTR, object_tokens_: ?*?*ISpeechObjectTokens) HRESULT {
                return @as(*const ISpeechRecognizer.VTable, @ptrCast(self.vtable)).GetProfiles(@as(*const ISpeechRecognizer, @ptrCast(self)), required_attributes_, optional_attributes_, object_tokens_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecognizerStatus_Value = Guid.initString("bff9e781-53ec-484e-bb8a-0e1b5551e35c");
pub const IID_ISpeechRecognizerStatus = &IID_ISpeechRecognizerStatus_Value;
pub const ISpeechRecognizerStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStatus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            audio_status: ?*?*ISpeechAudioStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            p_current_stream_pos: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfActiveRules: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            number_of_active_rules: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClsidEngine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            clsid_engine: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecognizerStatus,
            supported_languages: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAudioStatus(self: *const T, audio_status_: ?*?*ISpeechAudioStatus) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_AudioStatus(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), audio_status_);
            }
            pub inline fn getCurrentStreamPosition(self: *const T, p_current_stream_pos_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_CurrentStreamPosition(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), p_current_stream_pos_);
            }
            pub inline fn getCurrentStreamNumber(self: *const T, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_CurrentStreamNumber(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), stream_number_);
            }
            pub inline fn getNumberOfActiveRules(self: *const T, number_of_active_rules_: ?*i32) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_NumberOfActiveRules(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), number_of_active_rules_);
            }
            pub inline fn getClsidEngine(self: *const T, clsid_engine_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_ClsidEngine(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), clsid_engine_);
            }
            pub inline fn getSupportedLanguages(self: *const T, supported_languages_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecognizerStatus.VTable, @ptrCast(self.vtable)).get_SupportedLanguages(@as(*const ISpeechRecognizerStatus, @ptrCast(self)), supported_languages_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoContext_Value = Guid.initString("580aa49d-7e1e-4809-b8e2-57da806104b8");
pub const IID_ISpeechRecoContext = &IID_ISpeechRecoContext_Value;
pub const ISpeechRecoContext = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            recognizer: ?*?*ISpeechRecognizer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInputInterferenceStatus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            interference: ?*SpeechInterference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedUIType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            u_i_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_Voice: *const fn (
            self: *const ISpeechRecoContext,
            voice: ?*ISpeechVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Voice: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            voice: ?*?*ISpeechVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowVoiceFormatMatchingOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowVoiceFormatMatchingOnNextSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            p_allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VoicePurgeEvent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            event_interest: SpeechRecoEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VoicePurgeEvent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            event_interest: ?*SpeechRecoEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventInterests: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            event_interest: SpeechRecoEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventInterests: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            event_interest: ?*SpeechRecoEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CmdMaxAlternates: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            max_alternates: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CmdMaxAlternates: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            max_alternates: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            state: SpeechRecoContextState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            state: ?*SpeechRecoContextState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RetainedAudio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            option: SpeechRetainedAudioOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedAudio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            option: ?*SpeechRetainedAudioOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_RetainedAudioFormat: *const fn (
            self: *const ISpeechRecoContext,
            format: ?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedAudioFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoContext,
            format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateGrammar: *const fn (
            self: *const ISpeechRecoContext,
            grammar_id: VARIANT,
            grammar: ?*?*ISpeechRecoGrammar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateResultFromMemory: *const fn (
            self: *const ISpeechRecoContext,
            result_block: ?*VARIANT,
            result: ?*?*ISpeechRecoResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Bookmark: *const fn (
            self: *const ISpeechRecoContext,
            options: SpeechBookmarkOptions,
            stream_pos: VARIANT,
            bookmark_id: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdaptationData: *const fn (
            self: *const ISpeechRecoContext,
            adaptation_string: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRecognizer(self: *const T, recognizer_: ?*?*ISpeechRecognizer) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_Recognizer(@as(*const ISpeechRecoContext, @ptrCast(self)), recognizer_);
            }
            pub inline fn getAudioInputInterferenceStatus(self: *const T, interference_: ?*SpeechInterference) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_AudioInputInterferenceStatus(@as(*const ISpeechRecoContext, @ptrCast(self)), interference_);
            }
            pub inline fn getRequestedUIType(self: *const T, u_i_type_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_RequestedUIType(@as(*const ISpeechRecoContext, @ptrCast(self)), u_i_type_);
            }
            pub inline fn putrefVoice(self: *const T, voice_: ?*ISpeechVoice) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).putref_Voice(@as(*const ISpeechRecoContext, @ptrCast(self)), voice_);
            }
            pub inline fn getVoice(self: *const T, voice_: ?*?*ISpeechVoice) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_Voice(@as(*const ISpeechRecoContext, @ptrCast(self)), voice_);
            }
            pub inline fn putAllowVoiceFormatMatchingOnNextSet(self: *const T, allow_: i16) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_AllowVoiceFormatMatchingOnNextSet(@as(*const ISpeechRecoContext, @ptrCast(self)), allow_);
            }
            pub inline fn getAllowVoiceFormatMatchingOnNextSet(self: *const T, p_allow_: ?*i16) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_AllowVoiceFormatMatchingOnNextSet(@as(*const ISpeechRecoContext, @ptrCast(self)), p_allow_);
            }
            pub inline fn putVoicePurgeEvent(self: *const T, event_interest_: SpeechRecoEvents) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_VoicePurgeEvent(@as(*const ISpeechRecoContext, @ptrCast(self)), event_interest_);
            }
            pub inline fn getVoicePurgeEvent(self: *const T, event_interest_: ?*SpeechRecoEvents) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_VoicePurgeEvent(@as(*const ISpeechRecoContext, @ptrCast(self)), event_interest_);
            }
            pub inline fn putEventInterests(self: *const T, event_interest_: SpeechRecoEvents) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_EventInterests(@as(*const ISpeechRecoContext, @ptrCast(self)), event_interest_);
            }
            pub inline fn getEventInterests(self: *const T, event_interest_: ?*SpeechRecoEvents) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_EventInterests(@as(*const ISpeechRecoContext, @ptrCast(self)), event_interest_);
            }
            pub inline fn putCmdMaxAlternates(self: *const T, max_alternates_: i32) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_CmdMaxAlternates(@as(*const ISpeechRecoContext, @ptrCast(self)), max_alternates_);
            }
            pub inline fn getCmdMaxAlternates(self: *const T, max_alternates_: ?*i32) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_CmdMaxAlternates(@as(*const ISpeechRecoContext, @ptrCast(self)), max_alternates_);
            }
            pub inline fn putState(self: *const T, state_: SpeechRecoContextState) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_State(@as(*const ISpeechRecoContext, @ptrCast(self)), state_);
            }
            pub inline fn getState(self: *const T, state_: ?*SpeechRecoContextState) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_State(@as(*const ISpeechRecoContext, @ptrCast(self)), state_);
            }
            pub inline fn putRetainedAudio(self: *const T, option_: SpeechRetainedAudioOptions) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).put_RetainedAudio(@as(*const ISpeechRecoContext, @ptrCast(self)), option_);
            }
            pub inline fn getRetainedAudio(self: *const T, option_: ?*SpeechRetainedAudioOptions) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_RetainedAudio(@as(*const ISpeechRecoContext, @ptrCast(self)), option_);
            }
            pub inline fn putrefRetainedAudioFormat(self: *const T, format_: ?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).putref_RetainedAudioFormat(@as(*const ISpeechRecoContext, @ptrCast(self)), format_);
            }
            pub inline fn getRetainedAudioFormat(self: *const T, format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).get_RetainedAudioFormat(@as(*const ISpeechRecoContext, @ptrCast(self)), format_);
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).Pause(@as(*const ISpeechRecoContext, @ptrCast(self)));
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).Resume(@as(*const ISpeechRecoContext, @ptrCast(self)));
            }
            pub inline fn createGrammar(self: *const T, grammar_id_: VARIANT, grammar_: ?*?*ISpeechRecoGrammar) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).CreateGrammar(@as(*const ISpeechRecoContext, @ptrCast(self)), grammar_id_, grammar_);
            }
            pub inline fn createResultFromMemory(self: *const T, result_block_: ?*VARIANT, result_: ?*?*ISpeechRecoResult) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).CreateResultFromMemory(@as(*const ISpeechRecoContext, @ptrCast(self)), result_block_, result_);
            }
            pub inline fn bookmark(self: *const T, options_: SpeechBookmarkOptions, stream_pos_: VARIANT, bookmark_id_: VARIANT) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).Bookmark(@as(*const ISpeechRecoContext, @ptrCast(self)), options_, stream_pos_, bookmark_id_);
            }
            pub inline fn setAdaptationData(self: *const T, adaptation_string_: ?BSTR) HRESULT {
                return @as(*const ISpeechRecoContext.VTable, @ptrCast(self.vtable)).SetAdaptationData(@as(*const ISpeechRecoContext, @ptrCast(self)), adaptation_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoGrammar_Value = Guid.initString("b6d6f79f-2158-4e50-b5bc-9a9ccd852a09");
pub const IID_ISpeechRecoGrammar = &IID_ISpeechRecoGrammar_Value;
pub const ISpeechRecoGrammar = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoGrammar,
            id: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoGrammar,
            reco_context: ?*?*ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoGrammar,
            state: SpeechGrammarState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoGrammar,
            state: ?*SpeechGrammarState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoGrammar,
            rules: ?*?*ISpeechGrammarRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ISpeechRecoGrammar,
            new_language: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdLoadFromFile: *const fn (
            self: *const ISpeechRecoGrammar,
            file_name: ?BSTR,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdLoadFromObject: *const fn (
            self: *const ISpeechRecoGrammar,
            class_id: ?BSTR,
            grammar_name: ?BSTR,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdLoadFromResource: *const fn (
            self: *const ISpeechRecoGrammar,
            h_module: i32,
            resource_name: VARIANT,
            resource_type: VARIANT,
            language_id: i32,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdLoadFromMemory: *const fn (
            self: *const ISpeechRecoGrammar,
            grammar_data: VARIANT,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdLoadFromProprietaryGrammar: *const fn (
            self: *const ISpeechRecoGrammar,
            proprietary_guid: ?BSTR,
            proprietary_string: ?BSTR,
            proprietary_data: VARIANT,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdSetRuleState: *const fn (
            self: *const ISpeechRecoGrammar,
            name: ?BSTR,
            state: SpeechRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CmdSetRuleIdState: *const fn (
            self: *const ISpeechRecoGrammar,
            rule_id: i32,
            state: SpeechRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DictationLoad: *const fn (
            self: *const ISpeechRecoGrammar,
            topic_name: ?BSTR,
            load_option: SpeechLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DictationUnload: *const fn (
            self: *const ISpeechRecoGrammar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DictationSetState: *const fn (
            self: *const ISpeechRecoGrammar,
            state: SpeechRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWordSequenceData: *const fn (
            self: *const ISpeechRecoGrammar,
            text: ?BSTR,
            text_length: i32,
            info: ?*ISpeechTextSelectionInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextSelection: *const fn (
            self: *const ISpeechRecoGrammar,
            info: ?*ISpeechTextSelectionInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPronounceable: *const fn (
            self: *const ISpeechRecoGrammar,
            word: ?BSTR,
            word_pronounceable: ?*SpeechWordPronounceable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getId(self: *const T, id_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechRecoGrammar, @ptrCast(self)), id_);
            }
            pub inline fn getRecoContext(self: *const T, reco_context_: ?*?*ISpeechRecoContext) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).get_RecoContext(@as(*const ISpeechRecoGrammar, @ptrCast(self)), reco_context_);
            }
            pub inline fn putState(self: *const T, state_: SpeechGrammarState) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).put_State(@as(*const ISpeechRecoGrammar, @ptrCast(self)), state_);
            }
            pub inline fn getState(self: *const T, state_: ?*SpeechGrammarState) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).get_State(@as(*const ISpeechRecoGrammar, @ptrCast(self)), state_);
            }
            pub inline fn getRules(self: *const T, rules_: ?*?*ISpeechGrammarRules) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).get_Rules(@as(*const ISpeechRecoGrammar, @ptrCast(self)), rules_);
            }
            pub inline fn reset(self: *const T, new_language_: i32) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISpeechRecoGrammar, @ptrCast(self)), new_language_);
            }
            pub inline fn cmdLoadFromFile(self: *const T, file_name_: ?BSTR, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdLoadFromFile(@as(*const ISpeechRecoGrammar, @ptrCast(self)), file_name_, load_option_);
            }
            pub inline fn cmdLoadFromObject(self: *const T, class_id_: ?BSTR, grammar_name_: ?BSTR, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdLoadFromObject(@as(*const ISpeechRecoGrammar, @ptrCast(self)), class_id_, grammar_name_, load_option_);
            }
            pub inline fn cmdLoadFromResource(self: *const T, h_module_: i32, resource_name_: VARIANT, resource_type_: VARIANT, language_id_: i32, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdLoadFromResource(@as(*const ISpeechRecoGrammar, @ptrCast(self)), h_module_, resource_name_, resource_type_, language_id_, load_option_);
            }
            pub inline fn cmdLoadFromMemory(self: *const T, grammar_data_: VARIANT, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdLoadFromMemory(@as(*const ISpeechRecoGrammar, @ptrCast(self)), grammar_data_, load_option_);
            }
            pub inline fn cmdLoadFromProprietaryGrammar(self: *const T, proprietary_guid_: ?BSTR, proprietary_string_: ?BSTR, proprietary_data_: VARIANT, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdLoadFromProprietaryGrammar(@as(*const ISpeechRecoGrammar, @ptrCast(self)), proprietary_guid_, proprietary_string_, proprietary_data_, load_option_);
            }
            pub inline fn cmdSetRuleState(self: *const T, name_: ?BSTR, state_: SpeechRuleState) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdSetRuleState(@as(*const ISpeechRecoGrammar, @ptrCast(self)), name_, state_);
            }
            pub inline fn cmdSetRuleIdState(self: *const T, rule_id_: i32, state_: SpeechRuleState) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).CmdSetRuleIdState(@as(*const ISpeechRecoGrammar, @ptrCast(self)), rule_id_, state_);
            }
            pub inline fn dictationLoad(self: *const T, topic_name_: ?BSTR, load_option_: SpeechLoadOption) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).DictationLoad(@as(*const ISpeechRecoGrammar, @ptrCast(self)), topic_name_, load_option_);
            }
            pub inline fn dictationUnload(self: *const T) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).DictationUnload(@as(*const ISpeechRecoGrammar, @ptrCast(self)));
            }
            pub inline fn dictationSetState(self: *const T, state_: SpeechRuleState) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).DictationSetState(@as(*const ISpeechRecoGrammar, @ptrCast(self)), state_);
            }
            pub inline fn setWordSequenceData(self: *const T, text_: ?BSTR, text_length_: i32, info_: ?*ISpeechTextSelectionInformation) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).SetWordSequenceData(@as(*const ISpeechRecoGrammar, @ptrCast(self)), text_, text_length_, info_);
            }
            pub inline fn setTextSelection(self: *const T, info_: ?*ISpeechTextSelectionInformation) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).SetTextSelection(@as(*const ISpeechRecoGrammar, @ptrCast(self)), info_);
            }
            pub inline fn isPronounceable(self: *const T, word_: ?BSTR, word_pronounceable_: ?*SpeechWordPronounceable) HRESULT {
                return @as(*const ISpeechRecoGrammar.VTable, @ptrCast(self.vtable)).IsPronounceable(@as(*const ISpeechRecoGrammar, @ptrCast(self)), word_, word_pronounceable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__ISpeechRecoContextEvents_Value = Guid.initString("7b8fcb42-0e9d-4f00-a048-7b04d6179d3d");
pub const IID__ISpeechRecoContextEvents = &IID__ISpeechRecoContextEvents_Value;
pub const _ISpeechRecoContextEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRule_Value = Guid.initString("afe719cf-5dd1-44f2-999c-7a399f1cfccc");
pub const IID_ISpeechGrammarRule = &IID_ISpeechGrammarRule_Value;
pub const ISpeechGrammarRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRule,
            attributes: ?*SpeechRuleAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRule,
            state: ?*?*ISpeechGrammarRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRule,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRule,
            id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: *const fn (
            self: *const ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddResource: *const fn (
            self: *const ISpeechGrammarRule,
            resource_name: ?BSTR,
            resource_value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddState: *const fn (
            self: *const ISpeechGrammarRule,
            state: ?*?*ISpeechGrammarRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAttributes(self: *const T, attributes_: ?*SpeechRuleAttributes) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).get_Attributes(@as(*const ISpeechGrammarRule, @ptrCast(self)), attributes_);
            }
            pub inline fn getInitialState(self: *const T, state_: ?*?*ISpeechGrammarRuleState) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).get_InitialState(@as(*const ISpeechGrammarRule, @ptrCast(self)), state_);
            }
            pub inline fn getName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ISpeechGrammarRule, @ptrCast(self)), name_);
            }
            pub inline fn getId(self: *const T, id_: ?*i32) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechGrammarRule, @ptrCast(self)), id_);
            }
            pub inline fn clear(self: *const T) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).Clear(@as(*const ISpeechGrammarRule, @ptrCast(self)));
            }
            pub inline fn addResource(self: *const T, resource_name_: ?BSTR, resource_value_: ?BSTR) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).AddResource(@as(*const ISpeechGrammarRule, @ptrCast(self)), resource_name_, resource_value_);
            }
            pub inline fn addState(self: *const T, state_: ?*?*ISpeechGrammarRuleState) HRESULT {
                return @as(*const ISpeechGrammarRule.VTable, @ptrCast(self.vtable)).AddState(@as(*const ISpeechGrammarRule, @ptrCast(self)), state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRules_Value = Guid.initString("6ffa3b44-fc2d-40d1-8afc-32911c7f1ad1");
pub const IID_ISpeechGrammarRules = &IID_ISpeechGrammarRules_Value;
pub const ISpeechGrammarRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRules,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRule: *const fn (
            self: *const ISpeechGrammarRules,
            rule_name_or_id: VARIANT,
            rule: ?*?*ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechGrammarRules,
            index: i32,
            rule: ?*?*ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRules,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dynamic: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRules,
            dynamic: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const ISpeechGrammarRules,
            rule_name: ?BSTR,
            attributes: SpeechRuleAttributes,
            rule_id: i32,
            rule: ?*?*ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const ISpeechGrammarRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitAndSave: *const fn (
            self: *const ISpeechGrammarRules,
            error_text: ?*?BSTR,
            save_stream: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechGrammarRules, @ptrCast(self)), count_);
            }
            pub inline fn findRule(self: *const T, rule_name_or_id_: VARIANT, rule_: ?*?*ISpeechGrammarRule) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).FindRule(@as(*const ISpeechGrammarRules, @ptrCast(self)), rule_name_or_id_, rule_);
            }
            pub inline fn item(self: *const T, index_: i32, rule_: ?*?*ISpeechGrammarRule) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechGrammarRules, @ptrCast(self)), index_, rule_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechGrammarRules, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
            pub inline fn getDynamic(self: *const T, dynamic_: ?*i16) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).get_Dynamic(@as(*const ISpeechGrammarRules, @ptrCast(self)), dynamic_);
            }
            pub inline fn add(self: *const T, rule_name_: ?BSTR, attributes_: SpeechRuleAttributes, rule_id_: i32, rule_: ?*?*ISpeechGrammarRule) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).Add(@as(*const ISpeechGrammarRules, @ptrCast(self)), rule_name_, attributes_, rule_id_, rule_);
            }
            pub inline fn commit(self: *const T) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).Commit(@as(*const ISpeechGrammarRules, @ptrCast(self)));
            }
            pub inline fn commitAndSave(self: *const T, error_text_: ?*?BSTR, save_stream_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechGrammarRules.VTable, @ptrCast(self.vtable)).CommitAndSave(@as(*const ISpeechGrammarRules, @ptrCast(self)), error_text_, save_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleState_Value = Guid.initString("d4286f2c-ee67-45ae-b928-28d695362eda");
pub const IID_ISpeechGrammarRuleState = &IID_ISpeechGrammarRuleState_Value;
pub const ISpeechGrammarRuleState = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleState,
            rule: ?*?*ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Transitions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleState,
            transitions: ?*?*ISpeechGrammarRuleStateTransitions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddWordTransition: *const fn (
            self: *const ISpeechGrammarRuleState,
            dest_state: ?*ISpeechGrammarRuleState,
            words: ?BSTR,
            separators: ?BSTR,
            type: SpeechGrammarWordType,
            property_name: ?BSTR,
            property_id: i32,
            property_value: ?*VARIANT,
            weight: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRuleTransition: *const fn (
            self: *const ISpeechGrammarRuleState,
            destination_state: ?*ISpeechGrammarRuleState,
            rule: ?*ISpeechGrammarRule,
            property_name: ?BSTR,
            property_id: i32,
            property_value: ?*VARIANT,
            weight: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSpecialTransition: *const fn (
            self: *const ISpeechGrammarRuleState,
            destination_state: ?*ISpeechGrammarRuleState,
            type: SpeechSpecialTransitionType,
            property_name: ?BSTR,
            property_id: i32,
            property_value: ?*VARIANT,
            weight: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRule(self: *const T, rule_: ?*?*ISpeechGrammarRule) HRESULT {
                return @as(*const ISpeechGrammarRuleState.VTable, @ptrCast(self.vtable)).get_Rule(@as(*const ISpeechGrammarRuleState, @ptrCast(self)), rule_);
            }
            pub inline fn getTransitions(self: *const T, transitions_: ?*?*ISpeechGrammarRuleStateTransitions) HRESULT {
                return @as(*const ISpeechGrammarRuleState.VTable, @ptrCast(self.vtable)).get_Transitions(@as(*const ISpeechGrammarRuleState, @ptrCast(self)), transitions_);
            }
            pub inline fn addWordTransition(self: *const T, dest_state_: ?*ISpeechGrammarRuleState, words_: ?BSTR, separators_: ?BSTR, type_: SpeechGrammarWordType, property_name_: ?BSTR, property_id_: i32, property_value_: ?*VARIANT, weight_: f32) HRESULT {
                return @as(*const ISpeechGrammarRuleState.VTable, @ptrCast(self.vtable)).AddWordTransition(@as(*const ISpeechGrammarRuleState, @ptrCast(self)), dest_state_, words_, separators_, type_, property_name_, property_id_, property_value_, weight_);
            }
            pub inline fn addRuleTransition(self: *const T, destination_state_: ?*ISpeechGrammarRuleState, rule_: ?*ISpeechGrammarRule, property_name_: ?BSTR, property_id_: i32, property_value_: ?*VARIANT, weight_: f32) HRESULT {
                return @as(*const ISpeechGrammarRuleState.VTable, @ptrCast(self.vtable)).AddRuleTransition(@as(*const ISpeechGrammarRuleState, @ptrCast(self)), destination_state_, rule_, property_name_, property_id_, property_value_, weight_);
            }
            pub inline fn addSpecialTransition(self: *const T, destination_state_: ?*ISpeechGrammarRuleState, type_: SpeechSpecialTransitionType, property_name_: ?BSTR, property_id_: i32, property_value_: ?*VARIANT, weight_: f32) HRESULT {
                return @as(*const ISpeechGrammarRuleState.VTable, @ptrCast(self.vtable)).AddSpecialTransition(@as(*const ISpeechGrammarRuleState, @ptrCast(self)), destination_state_, type_, property_name_, property_id_, property_value_, weight_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleStateTransition_Value = Guid.initString("cafd1db1-41d1-4a06-9863-e2e81da17a9a");
pub const IID_ISpeechGrammarRuleStateTransition = &IID_ISpeechGrammarRuleStateTransition_Value;
pub const ISpeechGrammarRuleStateTransition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            type: ?*SpeechGrammarRuleStateTransitionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            rule: ?*?*ISpeechGrammarRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Weight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            weight: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            property_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            property_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransition,
            next_state: ?*?*ISpeechGrammarRuleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, type_: ?*SpeechGrammarRuleStateTransitionType) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_Type(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), type_);
            }
            pub inline fn getText(self: *const T, text_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_Text(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), text_);
            }
            pub inline fn getRule(self: *const T, rule_: ?*?*ISpeechGrammarRule) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_Rule(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), rule_);
            }
            pub inline fn getWeight(self: *const T, weight_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_Weight(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), weight_);
            }
            pub inline fn getPropertyName(self: *const T, property_name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_PropertyName(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), property_name_);
            }
            pub inline fn getPropertyId(self: *const T, property_id_: ?*i32) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_PropertyId(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), property_id_);
            }
            pub inline fn getPropertyValue(self: *const T, property_value_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_PropertyValue(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), property_value_);
            }
            pub inline fn getNextState(self: *const T, next_state_: ?*?*ISpeechGrammarRuleState) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransition.VTable, @ptrCast(self.vtable)).get_NextState(@as(*const ISpeechGrammarRuleStateTransition, @ptrCast(self)), next_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleStateTransitions_Value = Guid.initString("eabce657-75bc-44a2-aa7f-c56476742963");
pub const IID_ISpeechGrammarRuleStateTransitions = &IID_ISpeechGrammarRuleStateTransitions_Value;
pub const ISpeechGrammarRuleStateTransitions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransitions,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechGrammarRuleStateTransitions,
            index: i32,
            transition: ?*?*ISpeechGrammarRuleStateTransition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechGrammarRuleStateTransitions,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransitions.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechGrammarRuleStateTransitions, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, transition_: ?*?*ISpeechGrammarRuleStateTransition) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransitions.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechGrammarRuleStateTransitions, @ptrCast(self)), index_, transition_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechGrammarRuleStateTransitions.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechGrammarRuleStateTransitions, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechTextSelectionInformation_Value = Guid.initString("3b9c7e7a-6eee-4ded-9092-11657279adbe");
pub const IID_ISpeechTextSelectionInformation = &IID_ISpeechTextSelectionInformation_Value;
pub const ISpeechTextSelectionInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            active_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            active_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            active_length: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            active_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectionOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            selection_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            selection_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectionLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            selection_length: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionLength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechTextSelectionInformation,
            selection_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putActiveOffset(self: *const T, active_offset_: i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).put_ActiveOffset(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), active_offset_);
            }
            pub inline fn getActiveOffset(self: *const T, active_offset_: ?*i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).get_ActiveOffset(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), active_offset_);
            }
            pub inline fn putActiveLength(self: *const T, active_length_: i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).put_ActiveLength(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), active_length_);
            }
            pub inline fn getActiveLength(self: *const T, active_length_: ?*i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).get_ActiveLength(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), active_length_);
            }
            pub inline fn putSelectionOffset(self: *const T, selection_offset_: i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).put_SelectionOffset(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), selection_offset_);
            }
            pub inline fn getSelectionOffset(self: *const T, selection_offset_: ?*i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).get_SelectionOffset(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), selection_offset_);
            }
            pub inline fn putSelectionLength(self: *const T, selection_length_: i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).put_SelectionLength(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), selection_length_);
            }
            pub inline fn getSelectionLength(self: *const T, selection_length_: ?*i32) HRESULT {
                return @as(*const ISpeechTextSelectionInformation.VTable, @ptrCast(self.vtable)).get_SelectionLength(@as(*const ISpeechTextSelectionInformation, @ptrCast(self)), selection_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResult_Value = Guid.initString("ed2879cf-ced9-4ee6-a534-de0191d5468d");
pub const IID_ISpeechRecoResult = &IID_ISpeechRecoResult_Value;
pub const ISpeechRecoResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResult,
            reco_context: ?*?*ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Times: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResult,
            times: ?*?*ISpeechRecoResultTimes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioFormat: *const fn (
            self: *const ISpeechRecoResult,
            format: ?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResult,
            format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResult,
            phrase_info: ?*?*ISpeechPhraseInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Alternates: *const fn (
            self: *const ISpeechRecoResult,
            request_count: i32,
            start_element: i32,
            elements: i32,
            alternates: ?*?*ISpeechPhraseAlternates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Audio: *const fn (
            self: *const ISpeechRecoResult,
            start_element: i32,
            elements: i32,
            stream: ?*?*ISpeechMemoryStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakAudio: *const fn (
            self: *const ISpeechRecoResult,
            start_element: i32,
            elements: i32,
            flags: SpeechVoiceSpeakFlags,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveToMemory: *const fn (
            self: *const ISpeechRecoResult,
            result_block: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardResultInfo: *const fn (
            self: *const ISpeechRecoResult,
            value_types: SpeechDiscardType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRecoContext(self: *const T, reco_context_: ?*?*ISpeechRecoContext) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).get_RecoContext(@as(*const ISpeechRecoResult, @ptrCast(self)), reco_context_);
            }
            pub inline fn getTimes(self: *const T, times_: ?*?*ISpeechRecoResultTimes) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).get_Times(@as(*const ISpeechRecoResult, @ptrCast(self)), times_);
            }
            pub inline fn putrefAudioFormat(self: *const T, format_: ?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).putref_AudioFormat(@as(*const ISpeechRecoResult, @ptrCast(self)), format_);
            }
            pub inline fn getAudioFormat(self: *const T, format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).get_AudioFormat(@as(*const ISpeechRecoResult, @ptrCast(self)), format_);
            }
            pub inline fn getPhraseInfo(self: *const T, phrase_info_: ?*?*ISpeechPhraseInfo) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).get_PhraseInfo(@as(*const ISpeechRecoResult, @ptrCast(self)), phrase_info_);
            }
            pub inline fn alternates(self: *const T, request_count_: i32, start_element_: i32, elements_: i32, alternates_: ?*?*ISpeechPhraseAlternates) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).Alternates(@as(*const ISpeechRecoResult, @ptrCast(self)), request_count_, start_element_, elements_, alternates_);
            }
            pub inline fn audio(self: *const T, start_element_: i32, elements_: i32, stream_: ?*?*ISpeechMemoryStream) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).Audio(@as(*const ISpeechRecoResult, @ptrCast(self)), start_element_, elements_, stream_);
            }
            pub inline fn speakAudio(self: *const T, start_element_: i32, elements_: i32, flags_: SpeechVoiceSpeakFlags, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).SpeakAudio(@as(*const ISpeechRecoResult, @ptrCast(self)), start_element_, elements_, flags_, stream_number_);
            }
            pub inline fn saveToMemory(self: *const T, result_block_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).SaveToMemory(@as(*const ISpeechRecoResult, @ptrCast(self)), result_block_);
            }
            pub inline fn discardResultInfo(self: *const T, value_types_: SpeechDiscardType) HRESULT {
                return @as(*const ISpeechRecoResult.VTable, @ptrCast(self.vtable)).DiscardResultInfo(@as(*const ISpeechRecoResult, @ptrCast(self)), value_types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResult2_Value = Guid.initString("8e0a246d-d3c8-45de-8657-04290c458c3c");
pub const IID_ISpeechRecoResult2 = &IID_ISpeechRecoResult2_Value;
pub const ISpeechRecoResult2 = extern struct {
    pub const VTable = extern struct {
        base: ISpeechRecoResult.VTable,
        SetTextFeedback: *const fn (
            self: *const ISpeechRecoResult2,
            feedback: ?BSTR,
            was_successful: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechRecoResult.MethodMixin(T);
            pub inline fn setTextFeedback(self: *const T, feedback_: ?BSTR, was_successful_: i16) HRESULT {
                return @as(*const ISpeechRecoResult2.VTable, @ptrCast(self.vtable)).SetTextFeedback(@as(*const ISpeechRecoResult2, @ptrCast(self)), feedback_, was_successful_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResultTimes_Value = Guid.initString("62b3b8fb-f6e7-41be-bdcb-056b1c29efc0");
pub const IID_ISpeechRecoResultTimes = &IID_ISpeechRecoResultTimes_Value;
pub const ISpeechRecoResultTimes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultTimes,
            time: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultTimes,
            length: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultTimes,
            tick_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OffsetFromStart: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultTimes,
            offset_from_start: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStreamTime(self: *const T, time_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoResultTimes.VTable, @ptrCast(self.vtable)).get_StreamTime(@as(*const ISpeechRecoResultTimes, @ptrCast(self)), time_);
            }
            pub inline fn getLength(self: *const T, length_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoResultTimes.VTable, @ptrCast(self.vtable)).get_Length(@as(*const ISpeechRecoResultTimes, @ptrCast(self)), length_);
            }
            pub inline fn getTickCount(self: *const T, tick_count_: ?*i32) HRESULT {
                return @as(*const ISpeechRecoResultTimes.VTable, @ptrCast(self.vtable)).get_TickCount(@as(*const ISpeechRecoResultTimes, @ptrCast(self)), tick_count_);
            }
            pub inline fn getOffsetFromStart(self: *const T, offset_from_start_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoResultTimes.VTable, @ptrCast(self.vtable)).get_OffsetFromStart(@as(*const ISpeechRecoResultTimes, @ptrCast(self)), offset_from_start_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseAlternate_Value = Guid.initString("27864a2a-2b9f-4cb8-92d3-0d2722fd1e73");
pub const IID_ISpeechPhraseAlternate = &IID_ISpeechPhraseAlternate_Value;
pub const ISpeechPhraseAlternate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoResult: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternate,
            reco_result: ?*?*ISpeechRecoResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartElementInResult: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternate,
            start_element: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElementsInResult: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternate,
            number_of_elements: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternate,
            phrase_info: ?*?*ISpeechPhraseInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const ISpeechPhraseAlternate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRecoResult(self: *const T, reco_result_: ?*?*ISpeechRecoResult) HRESULT {
                return @as(*const ISpeechPhraseAlternate.VTable, @ptrCast(self.vtable)).get_RecoResult(@as(*const ISpeechPhraseAlternate, @ptrCast(self)), reco_result_);
            }
            pub inline fn getStartElementInResult(self: *const T, start_element_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseAlternate.VTable, @ptrCast(self.vtable)).get_StartElementInResult(@as(*const ISpeechPhraseAlternate, @ptrCast(self)), start_element_);
            }
            pub inline fn getNumberOfElementsInResult(self: *const T, number_of_elements_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseAlternate.VTable, @ptrCast(self.vtable)).get_NumberOfElementsInResult(@as(*const ISpeechPhraseAlternate, @ptrCast(self)), number_of_elements_);
            }
            pub inline fn getPhraseInfo(self: *const T, phrase_info_: ?*?*ISpeechPhraseInfo) HRESULT {
                return @as(*const ISpeechPhraseAlternate.VTable, @ptrCast(self.vtable)).get_PhraseInfo(@as(*const ISpeechPhraseAlternate, @ptrCast(self)), phrase_info_);
            }
            pub inline fn commit(self: *const T) HRESULT {
                return @as(*const ISpeechPhraseAlternate.VTable, @ptrCast(self.vtable)).Commit(@as(*const ISpeechPhraseAlternate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseAlternates_Value = Guid.initString("b238b6d5-f276-4c3d-a6c1-2974801c3cc2");
pub const IID_ISpeechPhraseAlternates = &IID_ISpeechPhraseAlternates_Value;
pub const ISpeechPhraseAlternates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternates,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechPhraseAlternates,
            index: i32,
            phrase_alternate: ?*?*ISpeechPhraseAlternate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseAlternates,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseAlternates.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechPhraseAlternates, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, phrase_alternate_: ?*?*ISpeechPhraseAlternate) HRESULT {
                return @as(*const ISpeechPhraseAlternates.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechPhraseAlternates, @ptrCast(self)), index_, phrase_alternate_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechPhraseAlternates.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechPhraseAlternates, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseInfo_Value = Guid.initString("961559cf-4e67-4662-8bf0-d93f1fcd61b3");
pub const IID_ISpeechPhraseInfo = &IID_ISpeechPhraseInfo_Value;
pub const ISpeechPhraseInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            language_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GrammarId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            grammar_id: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            start_time: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            audio_stream_position: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeBytes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            p_audio_size_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedSizeBytes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            retained_size_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            audio_size_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            rule: ?*?*ISpeechPhraseRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            properties: ?*?*ISpeechPhraseProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Elements: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            elements: ?*?*ISpeechPhraseElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Replacements: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            replacements: ?*?*ISpeechPhraseReplacements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            engine_id_guid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnginePrivateData: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseInfo,
            private_data: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveToMemory: *const fn (
            self: *const ISpeechPhraseInfo,
            phrase_block: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const ISpeechPhraseInfo,
            start_element: i32,
            elements: i32,
            use_replacements: i16,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAttributes: *const fn (
            self: *const ISpeechPhraseInfo,
            start_element: i32,
            elements: i32,
            use_replacements: i16,
            display_attributes: ?*SpeechDisplayAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getLanguageId(self: *const T, language_id_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_LanguageId(@as(*const ISpeechPhraseInfo, @ptrCast(self)), language_id_);
            }
            pub inline fn getGrammarId(self: *const T, grammar_id_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_GrammarId(@as(*const ISpeechPhraseInfo, @ptrCast(self)), grammar_id_);
            }
            pub inline fn getStartTime(self: *const T, start_time_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_StartTime(@as(*const ISpeechPhraseInfo, @ptrCast(self)), start_time_);
            }
            pub inline fn getAudioStreamPosition(self: *const T, audio_stream_position_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_AudioStreamPosition(@as(*const ISpeechPhraseInfo, @ptrCast(self)), audio_stream_position_);
            }
            pub inline fn getAudioSizeBytes(self: *const T, p_audio_size_bytes_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_AudioSizeBytes(@as(*const ISpeechPhraseInfo, @ptrCast(self)), p_audio_size_bytes_);
            }
            pub inline fn getRetainedSizeBytes(self: *const T, retained_size_bytes_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_RetainedSizeBytes(@as(*const ISpeechPhraseInfo, @ptrCast(self)), retained_size_bytes_);
            }
            pub inline fn getAudioSizeTime(self: *const T, audio_size_time_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_AudioSizeTime(@as(*const ISpeechPhraseInfo, @ptrCast(self)), audio_size_time_);
            }
            pub inline fn getRule(self: *const T, rule_: ?*?*ISpeechPhraseRule) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_Rule(@as(*const ISpeechPhraseInfo, @ptrCast(self)), rule_);
            }
            pub inline fn getProperties(self: *const T, properties_: ?*?*ISpeechPhraseProperties) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_Properties(@as(*const ISpeechPhraseInfo, @ptrCast(self)), properties_);
            }
            pub inline fn getElements(self: *const T, elements_: ?*?*ISpeechPhraseElements) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_Elements(@as(*const ISpeechPhraseInfo, @ptrCast(self)), elements_);
            }
            pub inline fn getReplacements(self: *const T, replacements_: ?*?*ISpeechPhraseReplacements) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_Replacements(@as(*const ISpeechPhraseInfo, @ptrCast(self)), replacements_);
            }
            pub inline fn getEngineId(self: *const T, engine_id_guid_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_EngineId(@as(*const ISpeechPhraseInfo, @ptrCast(self)), engine_id_guid_);
            }
            pub inline fn getEnginePrivateData(self: *const T, private_data_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).get_EnginePrivateData(@as(*const ISpeechPhraseInfo, @ptrCast(self)), private_data_);
            }
            pub inline fn saveToMemory(self: *const T, phrase_block_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).SaveToMemory(@as(*const ISpeechPhraseInfo, @ptrCast(self)), phrase_block_);
            }
            pub inline fn getText(self: *const T, start_element_: i32, elements_: i32, use_replacements_: i16, text_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).GetText(@as(*const ISpeechPhraseInfo, @ptrCast(self)), start_element_, elements_, use_replacements_, text_);
            }
            pub inline fn getDisplayAttributes(self: *const T, start_element_: i32, elements_: i32, use_replacements_: i16, display_attributes_: ?*SpeechDisplayAttributes) HRESULT {
                return @as(*const ISpeechPhraseInfo.VTable, @ptrCast(self.vtable)).GetDisplayAttributes(@as(*const ISpeechPhraseInfo, @ptrCast(self)), start_element_, elements_, use_replacements_, display_attributes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseElement_Value = Guid.initString("e6176f96-e373-4801-b223-3b62c068c0b4");
pub const IID_ISpeechPhraseElement = &IID_ISpeechPhraseElement_Value;
pub const ISpeechPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioTimeOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            audio_time_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            audio_size_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            audio_stream_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeBytes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            audio_size_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedStreamOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            retained_stream_offset: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedSizeBytes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            retained_size_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayText: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            display_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LexicalForm: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            lexical_form: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pronunciation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            pronunciation: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            display_attributes: ?*SpeechDisplayAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequiredConfidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            required_confidence: ?*SpeechEngineConfidence,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActualConfidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            actual_confidence: ?*SpeechEngineConfidence,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElement,
            engine_confidence: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAudioTimeOffset(self: *const T, audio_time_offset_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_AudioTimeOffset(@as(*const ISpeechPhraseElement, @ptrCast(self)), audio_time_offset_);
            }
            pub inline fn getAudioSizeTime(self: *const T, audio_size_time_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_AudioSizeTime(@as(*const ISpeechPhraseElement, @ptrCast(self)), audio_size_time_);
            }
            pub inline fn getAudioStreamOffset(self: *const T, audio_stream_offset_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_AudioStreamOffset(@as(*const ISpeechPhraseElement, @ptrCast(self)), audio_stream_offset_);
            }
            pub inline fn getAudioSizeBytes(self: *const T, audio_size_bytes_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_AudioSizeBytes(@as(*const ISpeechPhraseElement, @ptrCast(self)), audio_size_bytes_);
            }
            pub inline fn getRetainedStreamOffset(self: *const T, retained_stream_offset_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_RetainedStreamOffset(@as(*const ISpeechPhraseElement, @ptrCast(self)), retained_stream_offset_);
            }
            pub inline fn getRetainedSizeBytes(self: *const T, retained_size_bytes_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_RetainedSizeBytes(@as(*const ISpeechPhraseElement, @ptrCast(self)), retained_size_bytes_);
            }
            pub inline fn getDisplayText(self: *const T, display_text_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_DisplayText(@as(*const ISpeechPhraseElement, @ptrCast(self)), display_text_);
            }
            pub inline fn getLexicalForm(self: *const T, lexical_form_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_LexicalForm(@as(*const ISpeechPhraseElement, @ptrCast(self)), lexical_form_);
            }
            pub inline fn getPronunciation(self: *const T, pronunciation_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_Pronunciation(@as(*const ISpeechPhraseElement, @ptrCast(self)), pronunciation_);
            }
            pub inline fn getDisplayAttributes(self: *const T, display_attributes_: ?*SpeechDisplayAttributes) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_DisplayAttributes(@as(*const ISpeechPhraseElement, @ptrCast(self)), display_attributes_);
            }
            pub inline fn getRequiredConfidence(self: *const T, required_confidence_: ?*SpeechEngineConfidence) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_RequiredConfidence(@as(*const ISpeechPhraseElement, @ptrCast(self)), required_confidence_);
            }
            pub inline fn getActualConfidence(self: *const T, actual_confidence_: ?*SpeechEngineConfidence) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_ActualConfidence(@as(*const ISpeechPhraseElement, @ptrCast(self)), actual_confidence_);
            }
            pub inline fn getEngineConfidence(self: *const T, engine_confidence_: ?*f32) HRESULT {
                return @as(*const ISpeechPhraseElement.VTable, @ptrCast(self.vtable)).get_EngineConfidence(@as(*const ISpeechPhraseElement, @ptrCast(self)), engine_confidence_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseElements_Value = Guid.initString("0626b328-3478-467d-a0b3-d0853b93dda3");
pub const IID_ISpeechPhraseElements = &IID_ISpeechPhraseElements_Value;
pub const ISpeechPhraseElements = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElements,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechPhraseElements,
            index: i32,
            element: ?*?*ISpeechPhraseElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseElements,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseElements.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechPhraseElements, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, element_: ?*?*ISpeechPhraseElement) HRESULT {
                return @as(*const ISpeechPhraseElements.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechPhraseElements, @ptrCast(self)), index_, element_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechPhraseElements.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechPhraseElements, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseReplacement_Value = Guid.initString("2890a410-53a7-4fb5-94ec-06d4998e3d02");
pub const IID_ISpeechPhraseReplacement = &IID_ISpeechPhraseReplacement_Value;
pub const ISpeechPhraseReplacement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacement,
            display_attributes: ?*SpeechDisplayAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacement,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacement,
            first_element: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacement,
            number_of_elements: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getDisplayAttributes(self: *const T, display_attributes_: ?*SpeechDisplayAttributes) HRESULT {
                return @as(*const ISpeechPhraseReplacement.VTable, @ptrCast(self.vtable)).get_DisplayAttributes(@as(*const ISpeechPhraseReplacement, @ptrCast(self)), display_attributes_);
            }
            pub inline fn getText(self: *const T, text_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseReplacement.VTable, @ptrCast(self.vtable)).get_Text(@as(*const ISpeechPhraseReplacement, @ptrCast(self)), text_);
            }
            pub inline fn getFirstElement(self: *const T, first_element_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseReplacement.VTable, @ptrCast(self.vtable)).get_FirstElement(@as(*const ISpeechPhraseReplacement, @ptrCast(self)), first_element_);
            }
            pub inline fn getNumberOfElements(self: *const T, number_of_elements_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseReplacement.VTable, @ptrCast(self.vtable)).get_NumberOfElements(@as(*const ISpeechPhraseReplacement, @ptrCast(self)), number_of_elements_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseReplacements_Value = Guid.initString("38bc662f-2257-4525-959e-2069d2596c05");
pub const IID_ISpeechPhraseReplacements = &IID_ISpeechPhraseReplacements_Value;
pub const ISpeechPhraseReplacements = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacements,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechPhraseReplacements,
            index: i32,
            reps: ?*?*ISpeechPhraseReplacement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseReplacements,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseReplacements.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechPhraseReplacements, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, reps_: ?*?*ISpeechPhraseReplacement) HRESULT {
                return @as(*const ISpeechPhraseReplacements.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechPhraseReplacements, @ptrCast(self)), index_, reps_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechPhraseReplacements.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechPhraseReplacements, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseProperty_Value = Guid.initString("ce563d48-961e-4732-a2e1-378a42b430be");
pub const IID_ISpeechPhraseProperty = &IID_ISpeechPhraseProperty_Value;
pub const ISpeechPhraseProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            first_element: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            number_of_elements: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            confidence: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            confidence: ?*SpeechEngineConfidence,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            parent_property: ?*?*ISpeechPhraseProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperty,
            children: ?*?*ISpeechPhraseProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ISpeechPhraseProperty, @ptrCast(self)), name_);
            }
            pub inline fn getId(self: *const T, id_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechPhraseProperty, @ptrCast(self)), id_);
            }
            pub inline fn getValue(self: *const T, value_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Value(@as(*const ISpeechPhraseProperty, @ptrCast(self)), value_);
            }
            pub inline fn getFirstElement(self: *const T, first_element_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_FirstElement(@as(*const ISpeechPhraseProperty, @ptrCast(self)), first_element_);
            }
            pub inline fn getNumberOfElements(self: *const T, number_of_elements_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_NumberOfElements(@as(*const ISpeechPhraseProperty, @ptrCast(self)), number_of_elements_);
            }
            pub inline fn getEngineConfidence(self: *const T, confidence_: ?*f32) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_EngineConfidence(@as(*const ISpeechPhraseProperty, @ptrCast(self)), confidence_);
            }
            pub inline fn getConfidence(self: *const T, confidence_: ?*SpeechEngineConfidence) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Confidence(@as(*const ISpeechPhraseProperty, @ptrCast(self)), confidence_);
            }
            pub inline fn getParent(self: *const T, parent_property_: ?*?*ISpeechPhraseProperty) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const ISpeechPhraseProperty, @ptrCast(self)), parent_property_);
            }
            pub inline fn getChildren(self: *const T, children_: ?*?*ISpeechPhraseProperties) HRESULT {
                return @as(*const ISpeechPhraseProperty.VTable, @ptrCast(self.vtable)).get_Children(@as(*const ISpeechPhraseProperty, @ptrCast(self)), children_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseProperties_Value = Guid.initString("08166b47-102e-4b23-a599-bdb98dbfd1f4");
pub const IID_ISpeechPhraseProperties = &IID_ISpeechPhraseProperties_Value;
pub const ISpeechPhraseProperties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperties,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechPhraseProperties,
            index: i32,
            property: ?*?*ISpeechPhraseProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseProperties,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseProperties.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechPhraseProperties, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, property_: ?*?*ISpeechPhraseProperty) HRESULT {
                return @as(*const ISpeechPhraseProperties.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechPhraseProperties, @ptrCast(self)), index_, property_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechPhraseProperties.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechPhraseProperties, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseRule_Value = Guid.initString("a7bfe112-a4a0-48d9-b602-c313843f6964");
pub const IID_ISpeechPhraseRule = &IID_ISpeechPhraseRule_Value;
pub const ISpeechPhraseRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            first_element: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            number_of_elements: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            parent: ?*?*ISpeechPhraseRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            children: ?*?*ISpeechPhraseRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            actual_confidence: ?*SpeechEngineConfidence,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRule,
            engine_confidence: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ISpeechPhraseRule, @ptrCast(self)), name_);
            }
            pub inline fn getId(self: *const T, id_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpeechPhraseRule, @ptrCast(self)), id_);
            }
            pub inline fn getFirstElement(self: *const T, first_element_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_FirstElement(@as(*const ISpeechPhraseRule, @ptrCast(self)), first_element_);
            }
            pub inline fn getNumberOfElements(self: *const T, number_of_elements_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_NumberOfElements(@as(*const ISpeechPhraseRule, @ptrCast(self)), number_of_elements_);
            }
            pub inline fn getParent(self: *const T, parent_: ?*?*ISpeechPhraseRule) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const ISpeechPhraseRule, @ptrCast(self)), parent_);
            }
            pub inline fn getChildren(self: *const T, children_: ?*?*ISpeechPhraseRules) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_Children(@as(*const ISpeechPhraseRule, @ptrCast(self)), children_);
            }
            pub inline fn getConfidence(self: *const T, actual_confidence_: ?*SpeechEngineConfidence) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_Confidence(@as(*const ISpeechPhraseRule, @ptrCast(self)), actual_confidence_);
            }
            pub inline fn getEngineConfidence(self: *const T, engine_confidence_: ?*f32) HRESULT {
                return @as(*const ISpeechPhraseRule.VTable, @ptrCast(self.vtable)).get_EngineConfidence(@as(*const ISpeechPhraseRule, @ptrCast(self)), engine_confidence_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseRules_Value = Guid.initString("9047d593-01dd-4b72-81a3-e4a0ca69f407");
pub const IID_ISpeechPhraseRules = &IID_ISpeechPhraseRules_Value;
pub const ISpeechPhraseRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRules,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechPhraseRules,
            index: i32,
            rule: ?*?*ISpeechPhraseRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhraseRules,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechPhraseRules.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechPhraseRules, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, rule_: ?*?*ISpeechPhraseRule) HRESULT {
                return @as(*const ISpeechPhraseRules.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechPhraseRules, @ptrCast(self)), index_, rule_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechPhraseRules.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechPhraseRules, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexicon_Value = Guid.initString("3da7627a-c7ae-4b23-8708-638c50362c25");
pub const IID_ISpeechLexicon = &IID_ISpeechLexicon_Value;
pub const ISpeechLexicon = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenerationId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexicon,
            generation_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: *const fn (
            self: *const ISpeechLexicon,
            flags: SpeechLexiconType,
            generation_i_d: ?*i32,
            words: ?*?*ISpeechLexiconWords,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPronunciation: *const fn (
            self: *const ISpeechLexicon,
            bstr_word: ?BSTR,
            lang_id: i32,
            part_of_speech: SpeechPartOfSpeech,
            bstr_pronunciation: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPronunciationByPhoneIds: *const fn (
            self: *const ISpeechLexicon,
            bstr_word: ?BSTR,
            lang_id: i32,
            part_of_speech: SpeechPartOfSpeech,
            phone_ids: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePronunciation: *const fn (
            self: *const ISpeechLexicon,
            bstr_word: ?BSTR,
            lang_id: i32,
            part_of_speech: SpeechPartOfSpeech,
            bstr_pronunciation: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePronunciationByPhoneIds: *const fn (
            self: *const ISpeechLexicon,
            bstr_word: ?BSTR,
            lang_id: i32,
            part_of_speech: SpeechPartOfSpeech,
            phone_ids: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPronunciations: *const fn (
            self: *const ISpeechLexicon,
            bstr_word: ?BSTR,
            lang_id: i32,
            type_flags: SpeechLexiconType,
            pp_pronunciations: ?*?*ISpeechLexiconPronunciations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerationChange: *const fn (
            self: *const ISpeechLexicon,
            generation_i_d: ?*i32,
            pp_words: ?*?*ISpeechLexiconWords,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getGenerationId(self: *const T, generation_id_: ?*i32) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).get_GenerationId(@as(*const ISpeechLexicon, @ptrCast(self)), generation_id_);
            }
            pub inline fn getWords(self: *const T, flags_: SpeechLexiconType, generation_i_d_: ?*i32, words_: ?*?*ISpeechLexiconWords) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).GetWords(@as(*const ISpeechLexicon, @ptrCast(self)), flags_, generation_i_d_, words_);
            }
            pub inline fn addPronunciation(self: *const T, bstr_word_: ?BSTR, lang_id_: i32, part_of_speech_: SpeechPartOfSpeech, bstr_pronunciation_: ?BSTR) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).AddPronunciation(@as(*const ISpeechLexicon, @ptrCast(self)), bstr_word_, lang_id_, part_of_speech_, bstr_pronunciation_);
            }
            pub inline fn addPronunciationByPhoneIds(self: *const T, bstr_word_: ?BSTR, lang_id_: i32, part_of_speech_: SpeechPartOfSpeech, phone_ids_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).AddPronunciationByPhoneIds(@as(*const ISpeechLexicon, @ptrCast(self)), bstr_word_, lang_id_, part_of_speech_, phone_ids_);
            }
            pub inline fn removePronunciation(self: *const T, bstr_word_: ?BSTR, lang_id_: i32, part_of_speech_: SpeechPartOfSpeech, bstr_pronunciation_: ?BSTR) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).RemovePronunciation(@as(*const ISpeechLexicon, @ptrCast(self)), bstr_word_, lang_id_, part_of_speech_, bstr_pronunciation_);
            }
            pub inline fn removePronunciationByPhoneIds(self: *const T, bstr_word_: ?BSTR, lang_id_: i32, part_of_speech_: SpeechPartOfSpeech, phone_ids_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).RemovePronunciationByPhoneIds(@as(*const ISpeechLexicon, @ptrCast(self)), bstr_word_, lang_id_, part_of_speech_, phone_ids_);
            }
            pub inline fn getPronunciations(self: *const T, bstr_word_: ?BSTR, lang_id_: i32, type_flags_: SpeechLexiconType, pp_pronunciations_: ?*?*ISpeechLexiconPronunciations) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).GetPronunciations(@as(*const ISpeechLexicon, @ptrCast(self)), bstr_word_, lang_id_, type_flags_, pp_pronunciations_);
            }
            pub inline fn getGenerationChange(self: *const T, generation_i_d_: ?*i32, pp_words_: ?*?*ISpeechLexiconWords) HRESULT {
                return @as(*const ISpeechLexicon.VTable, @ptrCast(self.vtable)).GetGenerationChange(@as(*const ISpeechLexicon, @ptrCast(self)), generation_i_d_, pp_words_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconWords_Value = Guid.initString("8d199862-415e-47d5-ac4f-faa608b424e6");
pub const IID_ISpeechLexiconWords = &IID_ISpeechLexiconWords_Value;
pub const ISpeechLexiconWords = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWords,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechLexiconWords,
            index: i32,
            word: ?*?*ISpeechLexiconWord,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWords,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechLexiconWords.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechLexiconWords, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, word_: ?*?*ISpeechLexiconWord) HRESULT {
                return @as(*const ISpeechLexiconWords.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechLexiconWords, @ptrCast(self)), index_, word_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechLexiconWords.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechLexiconWords, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconWord_Value = Guid.initString("4e5b933c-c9be-48ed-8842-1ee51bb1d4ff");
pub const IID_ISpeechLexiconWord = &IID_ISpeechLexiconWord_Value;
pub const ISpeechLexiconWord = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWord,
            lang_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWord,
            word_type: ?*SpeechWordType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Word: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWord,
            word: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pronunciations: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconWord,
            pronunciations: ?*?*ISpeechLexiconPronunciations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getLangId(self: *const T, lang_id_: ?*i32) HRESULT {
                return @as(*const ISpeechLexiconWord.VTable, @ptrCast(self.vtable)).get_LangId(@as(*const ISpeechLexiconWord, @ptrCast(self)), lang_id_);
            }
            pub inline fn getType(self: *const T, word_type_: ?*SpeechWordType) HRESULT {
                return @as(*const ISpeechLexiconWord.VTable, @ptrCast(self.vtable)).get_Type(@as(*const ISpeechLexiconWord, @ptrCast(self)), word_type_);
            }
            pub inline fn getWord(self: *const T, word_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechLexiconWord.VTable, @ptrCast(self.vtable)).get_Word(@as(*const ISpeechLexiconWord, @ptrCast(self)), word_);
            }
            pub inline fn getPronunciations(self: *const T, pronunciations_: ?*?*ISpeechLexiconPronunciations) HRESULT {
                return @as(*const ISpeechLexiconWord.VTable, @ptrCast(self.vtable)).get_Pronunciations(@as(*const ISpeechLexiconWord, @ptrCast(self)), pronunciations_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconPronunciations_Value = Guid.initString("72829128-5682-4704-a0d4-3e2bb6f2ead3");
pub const IID_ISpeechLexiconPronunciations = &IID_ISpeechLexiconPronunciations_Value;
pub const ISpeechLexiconPronunciations = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciations,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const ISpeechLexiconPronunciations,
            index: i32,
            pronunciation: ?*?*ISpeechLexiconPronunciation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciations,
            enum_v_a_r_i_a_n_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ISpeechLexiconPronunciations.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ISpeechLexiconPronunciations, @ptrCast(self)), count_);
            }
            pub inline fn item(self: *const T, index_: i32, pronunciation_: ?*?*ISpeechLexiconPronunciation) HRESULT {
                return @as(*const ISpeechLexiconPronunciations.VTable, @ptrCast(self.vtable)).Item(@as(*const ISpeechLexiconPronunciations, @ptrCast(self)), index_, pronunciation_);
            }
            pub inline fn getNewEnum(self: *const T, enum_v_a_r_i_a_n_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ISpeechLexiconPronunciations.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ISpeechLexiconPronunciations, @ptrCast(self)), enum_v_a_r_i_a_n_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconPronunciation_Value = Guid.initString("95252c5d-9e43-4f4a-9899-48ee73352f9f");
pub const IID_ISpeechLexiconPronunciation = &IID_ISpeechLexiconPronunciation_Value;
pub const ISpeechLexiconPronunciation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciation,
            lexicon_type: ?*SpeechLexiconType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciation,
            lang_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PartOfSpeech: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciation,
            part_of_speech: ?*SpeechPartOfSpeech,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneIds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciation,
            phone_ids: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Symbolic: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechLexiconPronunciation,
            symbolic: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, lexicon_type_: ?*SpeechLexiconType) HRESULT {
                return @as(*const ISpeechLexiconPronunciation.VTable, @ptrCast(self.vtable)).get_Type(@as(*const ISpeechLexiconPronunciation, @ptrCast(self)), lexicon_type_);
            }
            pub inline fn getLangId(self: *const T, lang_id_: ?*i32) HRESULT {
                return @as(*const ISpeechLexiconPronunciation.VTable, @ptrCast(self.vtable)).get_LangId(@as(*const ISpeechLexiconPronunciation, @ptrCast(self)), lang_id_);
            }
            pub inline fn getPartOfSpeech(self: *const T, part_of_speech_: ?*SpeechPartOfSpeech) HRESULT {
                return @as(*const ISpeechLexiconPronunciation.VTable, @ptrCast(self.vtable)).get_PartOfSpeech(@as(*const ISpeechLexiconPronunciation, @ptrCast(self)), part_of_speech_);
            }
            pub inline fn getPhoneIds(self: *const T, phone_ids_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechLexiconPronunciation.VTable, @ptrCast(self.vtable)).get_PhoneIds(@as(*const ISpeechLexiconPronunciation, @ptrCast(self)), phone_ids_);
            }
            pub inline fn getSymbolic(self: *const T, symbolic_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechLexiconPronunciation.VTable, @ptrCast(self.vtable)).get_Symbolic(@as(*const ISpeechLexiconPronunciation, @ptrCast(self)), symbolic_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechXMLRecoResult_Value = Guid.initString("aaec54af-8f85-4924-944d-b79d39d72e19");
pub const IID_ISpeechXMLRecoResult = &IID_ISpeechXMLRecoResult_Value;
pub const ISpeechXMLRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpeechRecoResult.VTable,
        GetXMLResult: *const fn (
            self: *const ISpeechXMLRecoResult,
            options: SPXMLRESULTOPTIONS,
            p_result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXMLErrorInfo: *const fn (
            self: *const ISpeechXMLRecoResult,
            line_number: ?*i32,
            script_line: ?*?BSTR,
            source: ?*?BSTR,
            description: ?*?BSTR,
            result_code: ?*i32,
            is_error: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpeechRecoResult.MethodMixin(T);
            pub inline fn getXMLResult(self: *const T, options_: SPXMLRESULTOPTIONS, p_result_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechXMLRecoResult.VTable, @ptrCast(self.vtable)).GetXMLResult(@as(*const ISpeechXMLRecoResult, @ptrCast(self)), options_, p_result_);
            }
            pub inline fn getXMLErrorInfo(self: *const T, line_number_: ?*i32, script_line_: ?*?BSTR, source_: ?*?BSTR, description_: ?*?BSTR, result_code_: ?*i32, is_error_: ?*i16) HRESULT {
                return @as(*const ISpeechXMLRecoResult.VTable, @ptrCast(self.vtable)).GetXMLErrorInfo(@as(*const ISpeechXMLRecoResult, @ptrCast(self)), line_number_, script_line_, source_, description_, result_code_, is_error_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResultDispatch_Value = Guid.initString("6d60eb64-aced-40a6-bbf3-4e557f71dee2");
pub const IID_ISpeechRecoResultDispatch = &IID_ISpeechRecoResultDispatch_Value;
pub const ISpeechRecoResultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultDispatch,
            reco_context: ?*?*ISpeechRecoContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Times: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultDispatch,
            times: ?*?*ISpeechRecoResultTimes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_AudioFormat: *const fn (
            self: *const ISpeechRecoResultDispatch,
            format: ?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultDispatch,
            format: ?*?*ISpeechAudioFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechRecoResultDispatch,
            phrase_info: ?*?*ISpeechPhraseInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Alternates: *const fn (
            self: *const ISpeechRecoResultDispatch,
            request_count: i32,
            start_element: i32,
            elements: i32,
            alternates: ?*?*ISpeechPhraseAlternates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Audio: *const fn (
            self: *const ISpeechRecoResultDispatch,
            start_element: i32,
            elements: i32,
            stream: ?*?*ISpeechMemoryStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SpeakAudio: *const fn (
            self: *const ISpeechRecoResultDispatch,
            start_element: i32,
            elements: i32,
            flags: SpeechVoiceSpeakFlags,
            stream_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveToMemory: *const fn (
            self: *const ISpeechRecoResultDispatch,
            result_block: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardResultInfo: *const fn (
            self: *const ISpeechRecoResultDispatch,
            value_types: SpeechDiscardType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXMLResult: *const fn (
            self: *const ISpeechRecoResultDispatch,
            options: SPXMLRESULTOPTIONS,
            p_result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXMLErrorInfo: *const fn (
            self: *const ISpeechRecoResultDispatch,
            line_number: ?*i32,
            script_line: ?*?BSTR,
            source: ?*?BSTR,
            description: ?*?BSTR,
            result_code: ?*HRESULT,
            is_error: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextFeedback: *const fn (
            self: *const ISpeechRecoResultDispatch,
            feedback: ?BSTR,
            was_successful: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRecoContext(self: *const T, reco_context_: ?*?*ISpeechRecoContext) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).get_RecoContext(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), reco_context_);
            }
            pub inline fn getTimes(self: *const T, times_: ?*?*ISpeechRecoResultTimes) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).get_Times(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), times_);
            }
            pub inline fn putrefAudioFormat(self: *const T, format_: ?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).putref_AudioFormat(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), format_);
            }
            pub inline fn getAudioFormat(self: *const T, format_: ?*?*ISpeechAudioFormat) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).get_AudioFormat(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), format_);
            }
            pub inline fn getPhraseInfo(self: *const T, phrase_info_: ?*?*ISpeechPhraseInfo) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).get_PhraseInfo(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), phrase_info_);
            }
            pub inline fn alternates(self: *const T, request_count_: i32, start_element_: i32, elements_: i32, alternates_: ?*?*ISpeechPhraseAlternates) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).Alternates(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), request_count_, start_element_, elements_, alternates_);
            }
            pub inline fn audio(self: *const T, start_element_: i32, elements_: i32, stream_: ?*?*ISpeechMemoryStream) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).Audio(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), start_element_, elements_, stream_);
            }
            pub inline fn speakAudio(self: *const T, start_element_: i32, elements_: i32, flags_: SpeechVoiceSpeakFlags, stream_number_: ?*i32) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).SpeakAudio(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), start_element_, elements_, flags_, stream_number_);
            }
            pub inline fn saveToMemory(self: *const T, result_block_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).SaveToMemory(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), result_block_);
            }
            pub inline fn discardResultInfo(self: *const T, value_types_: SpeechDiscardType) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).DiscardResultInfo(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), value_types_);
            }
            pub inline fn getXMLResult(self: *const T, options_: SPXMLRESULTOPTIONS, p_result_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).GetXMLResult(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), options_, p_result_);
            }
            pub inline fn getXMLErrorInfo(self: *const T, line_number_: ?*i32, script_line_: ?*?BSTR, source_: ?*?BSTR, description_: ?*?BSTR, result_code_: ?*HRESULT, is_error_: ?*i16) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).GetXMLErrorInfo(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), line_number_, script_line_, source_, description_, result_code_, is_error_);
            }
            pub inline fn setTextFeedback(self: *const T, feedback_: ?BSTR, was_successful_: i16) HRESULT {
                return @as(*const ISpeechRecoResultDispatch.VTable, @ptrCast(self.vtable)).SetTextFeedback(@as(*const ISpeechRecoResultDispatch, @ptrCast(self)), feedback_, was_successful_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseInfoBuilder_Value = Guid.initString("3b151836-df3a-4e0a-846c-d2adc9334333");
pub const IID_ISpeechPhraseInfoBuilder = &IID_ISpeechPhraseInfoBuilder_Value;
pub const ISpeechPhraseInfoBuilder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        RestorePhraseFromMemory: *const fn (
            self: *const ISpeechPhraseInfoBuilder,
            phrase_in_memory: ?*VARIANT,
            phrase_info: ?*?*ISpeechPhraseInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn restorePhraseFromMemory(self: *const T, phrase_in_memory_: ?*VARIANT, phrase_info_: ?*?*ISpeechPhraseInfo) HRESULT {
                return @as(*const ISpeechPhraseInfoBuilder.VTable, @ptrCast(self.vtable)).RestorePhraseFromMemory(@as(*const ISpeechPhraseInfoBuilder, @ptrCast(self)), phrase_in_memory_, phrase_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhoneConverter_Value = Guid.initString("c3e4f353-433f-43d6-89a1-6a62a7054c3d");
pub const IID_ISpeechPhoneConverter = &IID_ISpeechPhoneConverter_Value;
pub const ISpeechPhoneConverter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhoneConverter,
            language_id: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LanguageId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpeechPhoneConverter,
            language_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PhoneToId: *const fn (
            self: *const ISpeechPhoneConverter,
            phonemes: ?BSTR,
            id_array: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IdToPhone: *const fn (
            self: *const ISpeechPhoneConverter,
            id_array: VARIANT,
            phonemes: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getLanguageId(self: *const T, language_id_: ?*i32) HRESULT {
                return @as(*const ISpeechPhoneConverter.VTable, @ptrCast(self.vtable)).get_LanguageId(@as(*const ISpeechPhoneConverter, @ptrCast(self)), language_id_);
            }
            pub inline fn putLanguageId(self: *const T, language_id_: i32) HRESULT {
                return @as(*const ISpeechPhoneConverter.VTable, @ptrCast(self.vtable)).put_LanguageId(@as(*const ISpeechPhoneConverter, @ptrCast(self)), language_id_);
            }
            pub inline fn phoneToId(self: *const T, phonemes_: ?BSTR, id_array_: ?*VARIANT) HRESULT {
                return @as(*const ISpeechPhoneConverter.VTable, @ptrCast(self.vtable)).PhoneToId(@as(*const ISpeechPhoneConverter, @ptrCast(self)), phonemes_, id_array_);
            }
            pub inline fn idToPhone(self: *const T, id_array_: VARIANT, phonemes_: ?*?BSTR) HRESULT {
                return @as(*const ISpeechPhoneConverter.VTable, @ptrCast(self.vtable)).IdToPhone(@as(*const ISpeechPhoneConverter, @ptrCast(self)), id_array_, phonemes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IInternetSecurityManager = @import("../system/com/urlmon.zig").IInternetSecurityManager;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SPNOTIFYCALLBACK")) {
        _ = SPNOTIFYCALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
