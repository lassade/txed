//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (16)
//--------------------------------------------------------------------------------
pub const DMO_E_INVALIDSTREAMINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const DMO_E_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const DMO_E_TYPE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const DMO_E_NOTACCEPTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const DMO_E_TYPE_NOT_ACCEPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const DMO_E_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const DMOCATEGORY_AUDIO_DECODER = Guid.initString("57f2db8b-e6bb-4513-9d43-dcd2a6593125");
pub const DMOCATEGORY_AUDIO_ENCODER = Guid.initString("33d9a761-90c8-11d0-bd43-00a0c911ce86");
pub const DMOCATEGORY_VIDEO_DECODER = Guid.initString("4a69b442-28be-4991-969c-b500adf5d8a8");
pub const DMOCATEGORY_VIDEO_ENCODER = Guid.initString("33d9a760-90c8-11d0-bd43-00a0c911ce86");
pub const DMOCATEGORY_AUDIO_EFFECT = Guid.initString("f3602b3f-0592-48df-a4cd-674721e7ebeb");
pub const DMOCATEGORY_VIDEO_EFFECT = Guid.initString("d990ee14-776c-4723-be46-3da2f56f10b9");
pub const DMOCATEGORY_AUDIO_CAPTURE_EFFECT = Guid.initString("f665aaba-3e09-4920-aa5f-219811148f09");
pub const DMOCATEGORY_ACOUSTIC_ECHO_CANCEL = Guid.initString("bf963d80-c559-11d0-8a2b-00a0c9255ac1");
pub const DMOCATEGORY_AUDIO_NOISE_SUPPRESS = Guid.initString("e07f903f-62fd-4e60-8cdd-dea7236665b5");
pub const DMOCATEGORY_AGC = Guid.initString("e88c9ba0-c557-11d0-8a2b-00a0c9255ac1");

//--------------------------------------------------------------------------------
// Section: Types (21)
//--------------------------------------------------------------------------------
pub const DMO_MEDIA_TYPE = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
    pUnk: ?*IUnknown,
    cbFormat: u32,
    pbFormat: ?*u8,
};

pub const _DMO_INPUT_DATA_BUFFER_FLAGS = enum(i32) {
    SYNCPOINT = 1,
    TIME = 2,
    TIMELENGTH = 4,
    DISCONTINUITY = 8,
};
pub const DMO_INPUT_DATA_BUFFERF_SYNCPOINT = _DMO_INPUT_DATA_BUFFER_FLAGS.SYNCPOINT;
pub const DMO_INPUT_DATA_BUFFERF_TIME = _DMO_INPUT_DATA_BUFFER_FLAGS.TIME;
pub const DMO_INPUT_DATA_BUFFERF_TIMELENGTH = _DMO_INPUT_DATA_BUFFER_FLAGS.TIMELENGTH;
pub const DMO_INPUT_DATA_BUFFERF_DISCONTINUITY = _DMO_INPUT_DATA_BUFFER_FLAGS.DISCONTINUITY;

pub const _DMO_OUTPUT_DATA_BUFFER_FLAGS = enum(i32) {
    SYNCPOINT = 1,
    TIME = 2,
    TIMELENGTH = 4,
    DISCONTINUITY = 8,
    INCOMPLETE = 16777216,
};
pub const DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT = _DMO_OUTPUT_DATA_BUFFER_FLAGS.SYNCPOINT;
pub const DMO_OUTPUT_DATA_BUFFERF_TIME = _DMO_OUTPUT_DATA_BUFFER_FLAGS.TIME;
pub const DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH = _DMO_OUTPUT_DATA_BUFFER_FLAGS.TIMELENGTH;
pub const DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DISCONTINUITY;
pub const DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE = _DMO_OUTPUT_DATA_BUFFER_FLAGS.INCOMPLETE;

pub const _DMO_INPUT_STATUS_FLAGS = enum(i32) {
    A = 1,
};
pub const DMO_INPUT_STATUSF_ACCEPT_DATA = _DMO_INPUT_STATUS_FLAGS.A;

pub const _DMO_INPUT_STREAM_INFO_FLAGS = enum(i32) {
    WHOLE_SAMPLES = 1,
    SINGLE_SAMPLE_PER_BUFFER = 2,
    FIXED_SAMPLE_SIZE = 4,
    HOLDS_BUFFERS = 8,
};
pub const DMO_INPUT_STREAMF_WHOLE_SAMPLES = _DMO_INPUT_STREAM_INFO_FLAGS.WHOLE_SAMPLES;
pub const DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = _DMO_INPUT_STREAM_INFO_FLAGS.SINGLE_SAMPLE_PER_BUFFER;
pub const DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE = _DMO_INPUT_STREAM_INFO_FLAGS.FIXED_SAMPLE_SIZE;
pub const DMO_INPUT_STREAMF_HOLDS_BUFFERS = _DMO_INPUT_STREAM_INFO_FLAGS.HOLDS_BUFFERS;

pub const _DMO_OUTPUT_STREAM_INFO_FLAGS = enum(i32) {
    WHOLE_SAMPLES = 1,
    SINGLE_SAMPLE_PER_BUFFER = 2,
    FIXED_SAMPLE_SIZE = 4,
    DISCARDABLE = 8,
    OPTIONAL = 16,
};
pub const DMO_OUTPUT_STREAMF_WHOLE_SAMPLES = _DMO_OUTPUT_STREAM_INFO_FLAGS.WHOLE_SAMPLES;
pub const DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = _DMO_OUTPUT_STREAM_INFO_FLAGS.SINGLE_SAMPLE_PER_BUFFER;
pub const DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE = _DMO_OUTPUT_STREAM_INFO_FLAGS.FIXED_SAMPLE_SIZE;
pub const DMO_OUTPUT_STREAMF_DISCARDABLE = _DMO_OUTPUT_STREAM_INFO_FLAGS.DISCARDABLE;
pub const DMO_OUTPUT_STREAMF_OPTIONAL = _DMO_OUTPUT_STREAM_INFO_FLAGS.OPTIONAL;

pub const _DMO_SET_TYPE_FLAGS = enum(i32) {
    TEST_ONLY = 1,
    CLEAR = 2,
};
pub const DMO_SET_TYPEF_TEST_ONLY = _DMO_SET_TYPE_FLAGS.TEST_ONLY;
pub const DMO_SET_TYPEF_CLEAR = _DMO_SET_TYPE_FLAGS.CLEAR;

pub const _DMO_PROCESS_OUTPUT_FLAGS = enum(i32) {
    R = 1,
};
pub const DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = _DMO_PROCESS_OUTPUT_FLAGS.R;

const IID_IMediaBuffer_Value = Guid.initString("59eff8b9-938c-4a26-82f2-95cb84cdc837");
pub const IID_IMediaBuffer = &IID_IMediaBuffer_Value;
pub const IMediaBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLength: *const fn (
            self: *const IMediaBuffer,
            cb_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxLength: *const fn (
            self: *const IMediaBuffer,
            pcb_max_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferAndLength: *const fn (
            self: *const IMediaBuffer,
            pp_buffer: ?*?*u8,
            pcb_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setLength(self: *const T, cb_length_: u32) HRESULT {
                return @as(*const IMediaBuffer.VTable, @ptrCast(self.vtable)).SetLength(@as(*const IMediaBuffer, @ptrCast(self)), cb_length_);
            }
            pub inline fn getMaxLength(self: *const T, pcb_max_length_: ?*u32) HRESULT {
                return @as(*const IMediaBuffer.VTable, @ptrCast(self.vtable)).GetMaxLength(@as(*const IMediaBuffer, @ptrCast(self)), pcb_max_length_);
            }
            pub inline fn getBufferAndLength(self: *const T, pp_buffer_: ?*?*u8, pcb_length_: ?*u32) HRESULT {
                return @as(*const IMediaBuffer.VTable, @ptrCast(self.vtable)).GetBufferAndLength(@as(*const IMediaBuffer, @ptrCast(self)), pp_buffer_, pcb_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DMO_OUTPUT_DATA_BUFFER = extern struct {
    pBuffer: ?*IMediaBuffer,
    dwStatus: u32,
    rtTimestamp: i64,
    rtTimelength: i64,
};

const IID_IMediaObject_Value = Guid.initString("d8ad0f58-5494-4102-97c5-ec798e59bcf4");
pub const IID_IMediaObject = &IID_IMediaObject_Value;
pub const IMediaObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: *const fn (
            self: *const IMediaObject,
            pc_input_streams: ?*u32,
            pc_output_streams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamInfo: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamInfo: *const fn (
            self: *const IMediaObject,
            dw_output_stream_index: u32,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputType: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            dw_type_index: u32,
            pmt: ?*DMO_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputType: *const fn (
            self: *const IMediaObject,
            dw_output_stream_index: u32,
            dw_type_index: u32,
            pmt: ?*DMO_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputType: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            pmt: ?*const DMO_MEDIA_TYPE,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputType: *const fn (
            self: *const IMediaObject,
            dw_output_stream_index: u32,
            pmt: ?*const DMO_MEDIA_TYPE,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCurrentType: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            pmt: ?*DMO_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCurrentType: *const fn (
            self: *const IMediaObject,
            dw_output_stream_index: u32,
            pmt: ?*DMO_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputSizeInfo: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            pcb_size: ?*u32,
            pcb_max_lookahead: ?*u32,
            pcb_alignment: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputSizeInfo: *const fn (
            self: *const IMediaObject,
            dw_output_stream_index: u32,
            pcb_size: ?*u32,
            pcb_alignment: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputMaxLatency: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            prt_max_latency: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputMaxLatency: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            rt_max_latency: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: *const fn (
            self: *const IMediaObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Discontinuity: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateStreamingResources: *const fn (
            self: *const IMediaObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeStreamingResources: *const fn (
            self: *const IMediaObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStatus: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            dw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessInput: *const fn (
            self: *const IMediaObject,
            dw_input_stream_index: u32,
            p_buffer: ?*IMediaBuffer,
            dw_flags: u32,
            rt_timestamp: i64,
            rt_timelength: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessOutput: *const fn (
            self: *const IMediaObject,
            dw_flags: u32,
            c_output_buffer_count: u32,
            p_output_buffers: [*]DMO_OUTPUT_DATA_BUFFER,
            pdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lock: *const fn (
            self: *const IMediaObject,
            b_lock: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStreamCount(self: *const T, pc_input_streams_: ?*u32, pc_output_streams_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMediaObject, @ptrCast(self)), pc_input_streams_, pc_output_streams_);
            }
            pub inline fn getInputStreamInfo(self: *const T, dw_input_stream_index_: u32, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputStreamInfo(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, pdw_flags_);
            }
            pub inline fn getOutputStreamInfo(self: *const T, dw_output_stream_index_: u32, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetOutputStreamInfo(@as(*const IMediaObject, @ptrCast(self)), dw_output_stream_index_, pdw_flags_);
            }
            pub inline fn getInputType(self: *const T, dw_input_stream_index_: u32, dw_type_index_: u32, pmt_: ?*DMO_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputType(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, dw_type_index_, pmt_);
            }
            pub inline fn getOutputType(self: *const T, dw_output_stream_index_: u32, dw_type_index_: u32, pmt_: ?*DMO_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetOutputType(@as(*const IMediaObject, @ptrCast(self)), dw_output_stream_index_, dw_type_index_, pmt_);
            }
            pub inline fn setInputType(self: *const T, dw_input_stream_index_: u32, pmt_: ?*const DMO_MEDIA_TYPE, dw_flags_: u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).SetInputType(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, pmt_, dw_flags_);
            }
            pub inline fn setOutputType(self: *const T, dw_output_stream_index_: u32, pmt_: ?*const DMO_MEDIA_TYPE, dw_flags_: u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).SetOutputType(@as(*const IMediaObject, @ptrCast(self)), dw_output_stream_index_, pmt_, dw_flags_);
            }
            pub inline fn getInputCurrentType(self: *const T, dw_input_stream_index_: u32, pmt_: ?*DMO_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputCurrentType(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, pmt_);
            }
            pub inline fn getOutputCurrentType(self: *const T, dw_output_stream_index_: u32, pmt_: ?*DMO_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetOutputCurrentType(@as(*const IMediaObject, @ptrCast(self)), dw_output_stream_index_, pmt_);
            }
            pub inline fn getInputSizeInfo(self: *const T, dw_input_stream_index_: u32, pcb_size_: ?*u32, pcb_max_lookahead_: ?*u32, pcb_alignment_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputSizeInfo(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, pcb_size_, pcb_max_lookahead_, pcb_alignment_);
            }
            pub inline fn getOutputSizeInfo(self: *const T, dw_output_stream_index_: u32, pcb_size_: ?*u32, pcb_alignment_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetOutputSizeInfo(@as(*const IMediaObject, @ptrCast(self)), dw_output_stream_index_, pcb_size_, pcb_alignment_);
            }
            pub inline fn getInputMaxLatency(self: *const T, dw_input_stream_index_: u32, prt_max_latency_: ?*i64) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputMaxLatency(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, prt_max_latency_);
            }
            pub inline fn setInputMaxLatency(self: *const T, dw_input_stream_index_: u32, rt_max_latency_: i64) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).SetInputMaxLatency(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, rt_max_latency_);
            }
            pub inline fn flush(self: *const T) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMediaObject, @ptrCast(self)));
            }
            pub inline fn discontinuity(self: *const T, dw_input_stream_index_: u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).Discontinuity(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_);
            }
            pub inline fn allocateStreamingResources(self: *const T) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).AllocateStreamingResources(@as(*const IMediaObject, @ptrCast(self)));
            }
            pub inline fn freeStreamingResources(self: *const T) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).FreeStreamingResources(@as(*const IMediaObject, @ptrCast(self)));
            }
            pub inline fn getInputStatus(self: *const T, dw_input_stream_index_: u32, dw_flags_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).GetInputStatus(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, dw_flags_);
            }
            pub inline fn processInput(self: *const T, dw_input_stream_index_: u32, p_buffer_: ?*IMediaBuffer, dw_flags_: u32, rt_timestamp_: i64, rt_timelength_: i64) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).ProcessInput(@as(*const IMediaObject, @ptrCast(self)), dw_input_stream_index_, p_buffer_, dw_flags_, rt_timestamp_, rt_timelength_);
            }
            pub inline fn processOutput(self: *const T, dw_flags_: u32, c_output_buffer_count_: u32, p_output_buffers_: [*]DMO_OUTPUT_DATA_BUFFER, pdw_status_: ?*u32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).ProcessOutput(@as(*const IMediaObject, @ptrCast(self)), dw_flags_, c_output_buffer_count_, p_output_buffers_, pdw_status_);
            }
            pub inline fn lock(self: *const T, b_lock_: i32) HRESULT {
                return @as(*const IMediaObject.VTable, @ptrCast(self.vtable)).Lock(@as(*const IMediaObject, @ptrCast(self)), b_lock_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDMO_Value = Guid.initString("2c3cd98a-2bfa-4a53-9c27-5249ba64ba0f");
pub const IID_IEnumDMO = &IID_IEnumDMO_Value;
pub const IEnumDMO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumDMO,
            c_items_to_fetch: u32,
            p_c_l_s_i_d: [*]Guid,
            names: [*]?PWSTR,
            pc_items_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumDMO,
            c_items_to_skip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumDMO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumDMO,
            pp_enum: ?*?*IEnumDMO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_items_to_fetch_: u32, p_c_l_s_i_d_: [*]Guid, names_: [*]?PWSTR, pc_items_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumDMO.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDMO, @ptrCast(self)), c_items_to_fetch_, p_c_l_s_i_d_, names_, pc_items_fetched_);
            }
            pub inline fn skip(self: *const T, c_items_to_skip_: u32) HRESULT {
                return @as(*const IEnumDMO.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDMO, @ptrCast(self)), c_items_to_skip_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumDMO.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDMO, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumDMO) HRESULT {
                return @as(*const IEnumDMO.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDMO, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _DMO_INPLACE_PROCESS_FLAGS = enum(i32) {
    NORMAL = 0,
    ZERO = 1,
};
pub const DMO_INPLACE_NORMAL = _DMO_INPLACE_PROCESS_FLAGS.NORMAL;
pub const DMO_INPLACE_ZERO = _DMO_INPLACE_PROCESS_FLAGS.ZERO;

const IID_IMediaObjectInPlace_Value = Guid.initString("651b9ad0-0fc7-4aa9-9538-d89931010741");
pub const IID_IMediaObjectInPlace = &IID_IMediaObjectInPlace_Value;
pub const IMediaObjectInPlace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Process: *const fn (
            self: *const IMediaObjectInPlace,
            ul_size: u32,
            // TODO: what to do with BytesParamIndex 0?
            p_data: ?*u8,
            ref_time_start: i64,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IMediaObjectInPlace,
            pp_media_object: ?*?*IMediaObjectInPlace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLatency: *const fn (
            self: *const IMediaObjectInPlace,
            p_latency_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn process(self: *const T, ul_size_: u32, p_data_: ?*u8, ref_time_start_: i64, dw_flags_: u32) HRESULT {
                return @as(*const IMediaObjectInPlace.VTable, @ptrCast(self.vtable)).Process(@as(*const IMediaObjectInPlace, @ptrCast(self)), ul_size_, p_data_, ref_time_start_, dw_flags_);
            }
            pub inline fn clone(self: *const T, pp_media_object_: ?*?*IMediaObjectInPlace) HRESULT {
                return @as(*const IMediaObjectInPlace.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMediaObjectInPlace, @ptrCast(self)), pp_media_object_);
            }
            pub inline fn getLatency(self: *const T, p_latency_time_: ?*i64) HRESULT {
                return @as(*const IMediaObjectInPlace.VTable, @ptrCast(self.vtable)).GetLatency(@as(*const IMediaObjectInPlace, @ptrCast(self)), p_latency_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _DMO_QUALITY_STATUS_FLAGS = enum(i32) {
    D = 1,
};
pub const DMO_QUALITY_STATUS_ENABLED = _DMO_QUALITY_STATUS_FLAGS.D;

const IID_IDMOQualityControl_Value = Guid.initString("65abea96-cf36-453f-af8a-705e98f16260");
pub const IID_IDMOQualityControl = &IID_IDMOQualityControl_Value;
pub const IDMOQualityControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNow: *const fn (
            self: *const IDMOQualityControl,
            rt_now: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: *const fn (
            self: *const IDMOQualityControl,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IDMOQualityControl,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setNow(self: *const T, rt_now_: i64) HRESULT {
                return @as(*const IDMOQualityControl.VTable, @ptrCast(self.vtable)).SetNow(@as(*const IDMOQualityControl, @ptrCast(self)), rt_now_);
            }
            pub inline fn setStatus(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IDMOQualityControl.VTable, @ptrCast(self.vtable)).SetStatus(@as(*const IDMOQualityControl, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getStatus(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IDMOQualityControl.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IDMOQualityControl, @ptrCast(self)), pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _DMO_VIDEO_OUTPUT_STREAM_FLAGS = enum(i32) {
    E = 1,
};
pub const DMO_VOSF_NEEDS_PREVIOUS_SAMPLE = _DMO_VIDEO_OUTPUT_STREAM_FLAGS.E;

const IID_IDMOVideoOutputOptimizations_Value = Guid.initString("be8f4f4e-5b16-4d29-b350-7f6b5d9298ac");
pub const IID_IDMOVideoOutputOptimizations = &IID_IDMOVideoOutputOptimizations_Value;
pub const IDMOVideoOutputOptimizations = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOperationModePreferences: *const fn (
            self: *const IDMOVideoOutputOptimizations,
            ul_output_stream_index: u32,
            pdw_requested_capabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOperationMode: *const fn (
            self: *const IDMOVideoOutputOptimizations,
            ul_output_stream_index: u32,
            dw_enabled_features: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentOperationMode: *const fn (
            self: *const IDMOVideoOutputOptimizations,
            ul_output_stream_index: u32,
            pdw_enabled_features: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSampleRequirements: *const fn (
            self: *const IDMOVideoOutputOptimizations,
            ul_output_stream_index: u32,
            pdw_requested_features: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryOperationModePreferences(self: *const T, ul_output_stream_index_: u32, pdw_requested_capabilities_: ?*u32) HRESULT {
                return @as(*const IDMOVideoOutputOptimizations.VTable, @ptrCast(self.vtable)).QueryOperationModePreferences(@as(*const IDMOVideoOutputOptimizations, @ptrCast(self)), ul_output_stream_index_, pdw_requested_capabilities_);
            }
            pub inline fn setOperationMode(self: *const T, ul_output_stream_index_: u32, dw_enabled_features_: u32) HRESULT {
                return @as(*const IDMOVideoOutputOptimizations.VTable, @ptrCast(self.vtable)).SetOperationMode(@as(*const IDMOVideoOutputOptimizations, @ptrCast(self)), ul_output_stream_index_, dw_enabled_features_);
            }
            pub inline fn getCurrentOperationMode(self: *const T, ul_output_stream_index_: u32, pdw_enabled_features_: ?*u32) HRESULT {
                return @as(*const IDMOVideoOutputOptimizations.VTable, @ptrCast(self.vtable)).GetCurrentOperationMode(@as(*const IDMOVideoOutputOptimizations, @ptrCast(self)), ul_output_stream_index_, pdw_enabled_features_);
            }
            pub inline fn getCurrentSampleRequirements(self: *const T, ul_output_stream_index_: u32, pdw_requested_features_: ?*u32) HRESULT {
                return @as(*const IDMOVideoOutputOptimizations.VTable, @ptrCast(self.vtable)).GetCurrentSampleRequirements(@as(*const IDMOVideoOutputOptimizations, @ptrCast(self)), ul_output_stream_index_, pdw_requested_features_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DMO_PARTIAL_MEDIATYPE = extern struct {
    type: Guid,
    subtype: Guid,
};

pub const DMO_REGISTER_FLAGS = enum(i32) {
    D = 1,
};
pub const DMO_REGISTERF_IS_KEYED = DMO_REGISTER_FLAGS.D;

pub const DMO_ENUM_FLAGS = enum(i32) {
    D = 1,
};
pub const DMO_ENUMF_INCLUDE_KEYED = DMO_ENUM_FLAGS.D;

//--------------------------------------------------------------------------------
// Section: Functions (11)
//--------------------------------------------------------------------------------
pub extern "msdmo" fn DMORegister(
    sz_name: ?[*:0]const u16,
    clsid_d_m_o: ?*const Guid,
    guid_category: ?*const Guid,
    dw_flags: u32,
    c_in_types: u32,
    p_in_types: ?*const DMO_PARTIAL_MEDIATYPE,
    c_out_types: u32,
    p_out_types: ?*const DMO_PARTIAL_MEDIATYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn DMOUnregister(
    clsid_d_m_o: ?*const Guid,
    guid_category: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn DMOEnum(
    guid_category: ?*const Guid,
    dw_flags: u32,
    c_in_types: u32,
    p_in_types: ?*const DMO_PARTIAL_MEDIATYPE,
    c_out_types: u32,
    p_out_types: ?*const DMO_PARTIAL_MEDIATYPE,
    pp_enum: ?*?*IEnumDMO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn DMOGetTypes(
    clsid_d_m_o: ?*const Guid,
    ul_input_types_requested: u32,
    pul_input_types_supplied: ?*u32,
    p_input_types: ?*DMO_PARTIAL_MEDIATYPE,
    ul_output_types_requested: u32,
    pul_output_types_supplied: ?*u32,
    p_output_types: ?*DMO_PARTIAL_MEDIATYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn DMOGetName(
    clsid_d_m_o: ?*const Guid,
    sz_name: *[80]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoInitMediaType(
    pmt: ?*DMO_MEDIA_TYPE,
    cb_format: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoFreeMediaType(
    pmt: ?*DMO_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoCopyMediaType(
    pmt_dest: ?*DMO_MEDIA_TYPE,
    pmt_src: ?*const DMO_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoCreateMediaType(
    ppmt: ?*?*DMO_MEDIA_TYPE,
    cb_format: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoDeleteMediaType(
    pmt: ?*DMO_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msdmo" fn MoDuplicateMediaType(
    ppmt_dest: ?*?*DMO_MEDIA_TYPE,
    pmt_src: ?*const DMO_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (5)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
