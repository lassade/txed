//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (485)
//--------------------------------------------------------------------------------
pub const MIXERCONTROL_CONTROLTYPE_CUSTOM = @as(u32, 0);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = @as(u32, 268500992);
pub const MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = @as(u32, 268566528);
pub const MIXERCONTROL_CONTROLTYPE_PEAKMETER = @as(u32, 268566529);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = @as(u32, 268632064);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEAN = @as(u32, 536936448);
pub const MIXERCONTROL_CONTROLTYPE_ONOFF = @as(u32, 536936449);
pub const MIXERCONTROL_CONTROLTYPE_MUTE = @as(u32, 536936450);
pub const MIXERCONTROL_CONTROLTYPE_MONO = @as(u32, 536936451);
pub const MIXERCONTROL_CONTROLTYPE_LOUDNESS = @as(u32, 536936452);
pub const MIXERCONTROL_CONTROLTYPE_STEREOENH = @as(u32, 536936453);
pub const MIXERCONTROL_CONTROLTYPE_BASS_BOOST = @as(u32, 536945271);
pub const MIXERCONTROL_CONTROLTYPE_BUTTON = @as(u32, 553713664);
pub const MIXERCONTROL_CONTROLTYPE_DECIBELS = @as(u32, 805568512);
pub const MIXERCONTROL_CONTROLTYPE_SIGNED = @as(u32, 805437440);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNED = @as(u32, 805502976);
pub const MIXERCONTROL_CONTROLTYPE_PERCENT = @as(u32, 805634048);
pub const MIXERCONTROL_CONTROLTYPE_SLIDER = @as(u32, 1073872896);
pub const MIXERCONTROL_CONTROLTYPE_PAN = @as(u32, 1073872897);
pub const MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = @as(u32, 1073872898);
pub const MIXERCONTROL_CONTROLTYPE_FADER = @as(u32, 1342373888);
pub const MIXERCONTROL_CONTROLTYPE_VOLUME = @as(u32, 1342373889);
pub const MIXERCONTROL_CONTROLTYPE_BASS = @as(u32, 1342373890);
pub const MIXERCONTROL_CONTROLTYPE_TREBLE = @as(u32, 1342373891);
pub const MIXERCONTROL_CONTROLTYPE_EQUALIZER = @as(u32, 1342373892);
pub const MIXERCONTROL_CONTROLTYPE_SINGLESELECT = @as(u32, 1879113728);
pub const MIXERCONTROL_CONTROLTYPE_MUX = @as(u32, 1879113729);
pub const MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = @as(u32, 1895890944);
pub const MIXERCONTROL_CONTROLTYPE_MIXER = @as(u32, 1895890945);
pub const MIXERCONTROL_CONTROLTYPE_MICROTIME = @as(u32, 1610809344);
pub const MIXERCONTROL_CONTROLTYPE_MILLITIME = @as(u32, 1627586560);
pub const WAVE_MAPPER = @as(u32, 4294967295);
pub const ENDPOINT_FORMAT_RESET_MIX_ONLY = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_VOLUME = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_MUTE = @as(u32, 2);
pub const ENDPOINT_HARDWARE_SUPPORT_METER = @as(u32, 4);
pub const AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ = @as(u32, 1);
pub const AMBISONICS_PARAM_VERSION_1 = @as(u32, 1);
pub const AUDCLNT_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287487));
pub const AUDCLNT_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287486));
pub const AUDCLNT_E_WRONG_ENDPOINT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287485));
pub const AUDCLNT_E_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287484));
pub const AUDCLNT_E_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287483));
pub const AUDCLNT_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287482));
pub const AUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287481));
pub const AUDCLNT_E_UNSUPPORTED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287480));
pub const AUDCLNT_E_INVALID_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287479));
pub const AUDCLNT_E_DEVICE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287478));
pub const AUDCLNT_E_BUFFER_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287477));
pub const AUDCLNT_E_THREAD_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287476));
pub const AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287474));
pub const AUDCLNT_E_ENDPOINT_CREATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287473));
pub const AUDCLNT_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287472));
pub const AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287471));
pub const AUDCLNT_E_EXCLUSIVE_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287470));
pub const AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287469));
pub const AUDCLNT_E_EVENTHANDLE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287468));
pub const AUDCLNT_E_INCORRECT_BUFFER_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287467));
pub const AUDCLNT_E_BUFFER_SIZE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287466));
pub const AUDCLNT_E_CPUUSAGE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287465));
pub const AUDCLNT_E_BUFFER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287464));
pub const AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287463));
pub const AUDCLNT_E_INVALID_DEVICE_PERIOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287456));
pub const AUDCLNT_E_INVALID_STREAM_FLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287455));
pub const AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287454));
pub const AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287453));
pub const AUDCLNT_E_OFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287452));
pub const AUDCLNT_E_NONOFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287451));
pub const AUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287450));
pub const AUDCLNT_E_RAW_MODE_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287449));
pub const AUDCLNT_E_ENGINE_PERIODICITY_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287448));
pub const AUDCLNT_E_ENGINE_FORMAT_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287447));
pub const AUDCLNT_E_HEADTRACKING_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287440));
pub const AUDCLNT_E_HEADTRACKING_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287424));
pub const AUDCLNT_E_EFFECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287423));
pub const AUDCLNT_E_EFFECT_STATE_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287422));
pub const AUDCLNT_S_BUFFER_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196161));
pub const AUDCLNT_S_THREAD_ALREADY_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196162));
pub const AUDCLNT_S_POSITION_STALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196163));
pub const AUDCLNT_STREAMFLAGS_CROSSPROCESS = @as(u32, 65536);
pub const AUDCLNT_STREAMFLAGS_LOOPBACK = @as(u32, 131072);
pub const AUDCLNT_STREAMFLAGS_EVENTCALLBACK = @as(u32, 262144);
pub const AUDCLNT_STREAMFLAGS_NOPERSIST = @as(u32, 524288);
pub const AUDCLNT_STREAMFLAGS_RATEADJUST = @as(u32, 1048576);
pub const AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY = @as(u32, 134217728);
pub const AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM = @as(u32, 2147483648);
pub const AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED = @as(u32, 268435456);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE = @as(u32, 536870912);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED = @as(u32, 1073741824);
pub const SPTLAUDCLNT_E_DESTROYED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287232));
pub const SPTLAUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287231));
pub const SPTLAUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287230));
pub const SPTLAUDCLNT_E_NO_MORE_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287229));
pub const SPTLAUDCLNT_E_PROPERTY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287228));
pub const SPTLAUDCLNT_E_ERRORS_IN_OBJECT_CALLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287227));
pub const SPTLAUDCLNT_E_METADATA_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287226));
pub const SPTLAUDCLNT_E_STREAM_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287225));
pub const SPTLAUDCLNT_E_INVALID_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287224));
pub const SPTLAUDCLNT_E_STREAM_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287222));
pub const SPTLAUDCLNT_E_STATIC_OBJECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287221));
pub const SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287220));
pub const SPTLAUDCLNT_E_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287219));
pub const DEVICE_STATE_ACTIVE = @as(u32, 1);
pub const DEVICE_STATE_DISABLED = @as(u32, 2);
pub const DEVICE_STATE_NOTPRESENT = @as(u32, 4);
pub const DEVICE_STATE_UNPLUGGED = @as(u32, 8);
pub const DEVICE_STATEMASK_ALL = @as(u32, 15);
pub const PKEY_AudioEndpoint_FormFactor = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 0 };
pub const PKEY_AudioEndpoint_ControlPanelPageProvider = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 1 };
pub const PKEY_AudioEndpoint_Association = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 2 };
pub const PKEY_AudioEndpoint_PhysicalSpeakers = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 3 };
pub const PKEY_AudioEndpoint_GUID = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 4 };
pub const PKEY_AudioEndpoint_Disable_SysFx = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 5 };
pub const ENDPOINT_SYSFX_ENABLED = @as(u32, 0);
pub const ENDPOINT_SYSFX_DISABLED = @as(u32, 1);
pub const PKEY_AudioEndpoint_FullRangeSpeakers = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 6 };
pub const PKEY_AudioEndpoint_Supports_EventDriven_Mode = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 7 };
pub const PKEY_AudioEndpoint_JackSubType = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 8 };
pub const PKEY_AudioEndpoint_Default_VolumeInDb = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 9 };
pub const PKEY_AudioEngine_DeviceFormat = PROPERTYKEY{ .fmtid = Guid.initString("f19f064d-082c-4e27-bc73-6882a1bb8e4c"), .pid = 0 };
pub const PKEY_AudioEngine_OEMFormat = PROPERTYKEY{ .fmtid = Guid.initString("e4870e26-3cc5-4cd2-ba46-ca0a9a70ed04"), .pid = 3 };
pub const PKEY_AudioEndpointLogo_IconEffects = PROPERTYKEY{ .fmtid = Guid.initString("f1ab780d-2010-4ed3-a3a6-8b87f0f0c476"), .pid = 0 };
pub const PKEY_AudioEndpointLogo_IconPath = PROPERTYKEY{ .fmtid = Guid.initString("f1ab780d-2010-4ed3-a3a6-8b87f0f0c476"), .pid = 1 };
pub const PKEY_AudioEndpointSettings_MenuText = PROPERTYKEY{ .fmtid = Guid.initString("14242002-0320-4de4-9555-a7d82b73c286"), .pid = 0 };
pub const PKEY_AudioEndpointSettings_LaunchContract = PROPERTYKEY{ .fmtid = Guid.initString("14242002-0320-4de4-9555-a7d82b73c286"), .pid = 1 };
pub const DEVINTERFACE_AUDIO_RENDER = Guid.initString("e6327cad-dcec-4949-ae8a-991e976a79d2");
pub const DEVINTERFACE_AUDIO_CAPTURE = Guid.initString("2eef81be-33fa-4800-9670-1cd474972c3f");
pub const DEVINTERFACE_MIDI_OUTPUT = Guid.initString("6dc23320-ab33-4ce4-80d4-bbb3ebbf2814");
pub const DEVINTERFACE_MIDI_INPUT = Guid.initString("504be32c-ccf6-4d2c-b73f-6f8b3747e22b");
pub const EVENTCONTEXT_VOLUMESLIDER = Guid.initString("e2c2e9de-09b1-4b04-84e5-07931225ee04");
pub const SPATIAL_AUDIO_STANDARD_COMMANDS_START = @as(u32, 200);
pub const SPATIAL_AUDIO_POSITION = @as(u32, 200);
pub const SPTLAUD_MD_CLNT_E_COMMAND_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286976));
pub const SPTLAUD_MD_CLNT_E_OBJECT_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286975));
pub const SPTLAUD_MD_CLNT_E_INVALID_ARGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286974));
pub const SPTLAUD_MD_CLNT_E_METADATA_FORMAT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286973));
pub const SPTLAUD_MD_CLNT_E_VALUE_BUFFER_INCORRECT_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286972));
pub const SPTLAUD_MD_CLNT_E_MEMORY_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286971));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286970));
pub const SPTLAUD_MD_CLNT_E_BUFFER_ALREADY_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286969));
pub const SPTLAUD_MD_CLNT_E_BUFFER_NOT_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286968));
pub const SPTLAUD_MD_CLNT_E_FRAMECOUNT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286967));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286960));
pub const SPTLAUD_MD_CLNT_E_ITEM_COPY_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286959));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286958));
pub const SPTLAUD_MD_CLNT_E_ITEMS_ALREADY_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286957));
pub const SPTLAUD_MD_CLNT_E_ATTACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286956));
pub const SPTLAUD_MD_CLNT_E_DETACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286955));
pub const SPTLAUD_MD_CLNT_E_NO_BUFFER_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286954));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286953));
pub const SPTLAUD_MD_CLNT_E_FRAMEOFFSET_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286952));
pub const SPTLAUD_MD_CLNT_E_ITEM_MUST_HAVE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286951));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMOFFSET_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286944));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286943));
pub const SPTLAUD_MD_CLNT_E_COMMAND_ALREADY_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286942));
pub const SPTLAUD_MD_CLNT_E_FORMAT_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286941));
pub const SPTLAUD_MD_CLNT_E_BUFFER_STILL_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286940));
pub const SPTLAUD_MD_CLNT_E_ITEMS_LOCKED_FOR_WRITING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286939));
pub const VIRTUAL_AUDIO_DEVICE_PROCESS_LOOPBACK = "VAD\\Process_Loopback";
pub const WAVERR_BADFORMAT = @as(u32, 32);
pub const WAVERR_STILLPLAYING = @as(u32, 33);
pub const WAVERR_UNPREPARED = @as(u32, 34);
pub const WAVERR_SYNC = @as(u32, 35);
pub const WAVERR_LASTERROR = @as(u32, 35);
pub const WHDR_DONE = @as(u32, 1);
pub const WHDR_PREPARED = @as(u32, 2);
pub const WHDR_BEGINLOOP = @as(u32, 4);
pub const WHDR_ENDLOOP = @as(u32, 8);
pub const WHDR_INQUEUE = @as(u32, 16);
pub const WAVECAPS_PITCH = @as(u32, 1);
pub const WAVECAPS_PLAYBACKRATE = @as(u32, 2);
pub const WAVECAPS_VOLUME = @as(u32, 4);
pub const WAVECAPS_LRVOLUME = @as(u32, 8);
pub const WAVECAPS_SYNC = @as(u32, 16);
pub const WAVECAPS_SAMPLEACCURATE = @as(u32, 32);
pub const WAVE_INVALIDFORMAT = @as(u32, 0);
pub const WAVE_FORMAT_1M08 = @as(u32, 1);
pub const WAVE_FORMAT_1S08 = @as(u32, 2);
pub const WAVE_FORMAT_1M16 = @as(u32, 4);
pub const WAVE_FORMAT_1S16 = @as(u32, 8);
pub const WAVE_FORMAT_2M08 = @as(u32, 16);
pub const WAVE_FORMAT_2S08 = @as(u32, 32);
pub const WAVE_FORMAT_2M16 = @as(u32, 64);
pub const WAVE_FORMAT_2S16 = @as(u32, 128);
pub const WAVE_FORMAT_4M08 = @as(u32, 256);
pub const WAVE_FORMAT_4S08 = @as(u32, 512);
pub const WAVE_FORMAT_4M16 = @as(u32, 1024);
pub const WAVE_FORMAT_4S16 = @as(u32, 2048);
pub const WAVE_FORMAT_44M08 = @as(u32, 256);
pub const WAVE_FORMAT_44S08 = @as(u32, 512);
pub const WAVE_FORMAT_44M16 = @as(u32, 1024);
pub const WAVE_FORMAT_44S16 = @as(u32, 2048);
pub const WAVE_FORMAT_48M08 = @as(u32, 4096);
pub const WAVE_FORMAT_48S08 = @as(u32, 8192);
pub const WAVE_FORMAT_48M16 = @as(u32, 16384);
pub const WAVE_FORMAT_48S16 = @as(u32, 32768);
pub const WAVE_FORMAT_96M08 = @as(u32, 65536);
pub const WAVE_FORMAT_96S08 = @as(u32, 131072);
pub const WAVE_FORMAT_96M16 = @as(u32, 262144);
pub const WAVE_FORMAT_96S16 = @as(u32, 524288);
pub const WAVE_FORMAT_PCM = @as(u32, 1);
pub const MIDIERR_UNPREPARED = @as(u32, 64);
pub const MIDIERR_STILLPLAYING = @as(u32, 65);
pub const MIDIERR_NOMAP = @as(u32, 66);
pub const MIDIERR_NOTREADY = @as(u32, 67);
pub const MIDIERR_NODEVICE = @as(u32, 68);
pub const MIDIERR_INVALIDSETUP = @as(u32, 69);
pub const MIDIERR_BADOPENMODE = @as(u32, 70);
pub const MIDIERR_DONT_CONTINUE = @as(u32, 71);
pub const MIDIERR_LASTERROR = @as(u32, 71);
pub const MIDIPATCHSIZE = @as(u32, 128);
pub const MIDI_CACHE_ALL = @as(u32, 1);
pub const MIDI_CACHE_BESTFIT = @as(u32, 2);
pub const MIDI_CACHE_QUERY = @as(u32, 3);
pub const MIDI_UNCACHE = @as(u32, 4);
pub const MOD_MIDIPORT = @as(u32, 1);
pub const MOD_SYNTH = @as(u32, 2);
pub const MOD_SQSYNTH = @as(u32, 3);
pub const MOD_FMSYNTH = @as(u32, 4);
pub const MOD_MAPPER = @as(u32, 5);
pub const MOD_WAVETABLE = @as(u32, 6);
pub const MOD_SWSYNTH = @as(u32, 7);
pub const MIDICAPS_VOLUME = @as(u32, 1);
pub const MIDICAPS_LRVOLUME = @as(u32, 2);
pub const MIDICAPS_CACHE = @as(u32, 4);
pub const MIDICAPS_STREAM = @as(u32, 8);
pub const MHDR_DONE = @as(u32, 1);
pub const MHDR_PREPARED = @as(u32, 2);
pub const MHDR_INQUEUE = @as(u32, 4);
pub const MHDR_ISSTRM = @as(u32, 8);
pub const MEVT_F_SHORT = @as(i32, 0);
pub const MEVT_F_LONG = @as(i32, -2147483648);
pub const MEVT_F_CALLBACK = @as(i32, 1073741824);
pub const MIDISTRM_ERROR = @as(i32, -2);
pub const MIDIPROP_SET = @as(i32, -2147483648);
pub const MIDIPROP_GET = @as(i32, 1073741824);
pub const MIDIPROP_TIMEDIV = @as(i32, 1);
pub const MIDIPROP_TEMPO = @as(i32, 2);
pub const AUXCAPS_CDAUDIO = @as(u32, 1);
pub const AUXCAPS_AUXIN = @as(u32, 2);
pub const AUXCAPS_VOLUME = @as(u32, 1);
pub const AUXCAPS_LRVOLUME = @as(u32, 2);
pub const MIXER_SHORT_NAME_CHARS = @as(u32, 16);
pub const MIXER_LONG_NAME_CHARS = @as(u32, 64);
pub const MIXERR_INVALLINE = @as(u32, 1024);
pub const MIXERR_INVALCONTROL = @as(u32, 1025);
pub const MIXERR_INVALVALUE = @as(u32, 1026);
pub const MIXERR_LASTERROR = @as(u32, 1026);
pub const MIXER_OBJECTF_HANDLE = @as(i32, -2147483648);
pub const MIXER_OBJECTF_MIXER = @as(i32, 0);
pub const MIXER_OBJECTF_WAVEOUT = @as(i32, 268435456);
pub const MIXER_OBJECTF_WAVEIN = @as(i32, 536870912);
pub const MIXER_OBJECTF_MIDIOUT = @as(i32, 805306368);
pub const MIXER_OBJECTF_MIDIIN = @as(i32, 1073741824);
pub const MIXER_OBJECTF_AUX = @as(i32, 1342177280);
pub const MIXERLINE_LINEF_ACTIVE = @as(i32, 1);
pub const MIXERLINE_LINEF_DISCONNECTED = @as(i32, 32768);
pub const MIXERLINE_LINEF_SOURCE = @as(i32, -2147483648);
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST = @as(i32, 0);
pub const MIXERLINE_COMPONENTTYPE_DST_LAST = @as(u32, 8);
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST = @as(i32, 4096);
pub const MIXERLINE_COMPONENTTYPE_SRC_LAST = @as(u32, 4106);
pub const MIXERLINE_TARGETTYPE_UNDEFINED = @as(u32, 0);
pub const MIXERLINE_TARGETTYPE_WAVEOUT = @as(u32, 1);
pub const MIXERLINE_TARGETTYPE_WAVEIN = @as(u32, 2);
pub const MIXERLINE_TARGETTYPE_MIDIOUT = @as(u32, 3);
pub const MIXERLINE_TARGETTYPE_MIDIIN = @as(u32, 4);
pub const MIXERLINE_TARGETTYPE_AUX = @as(u32, 5);
pub const MIXER_GETLINEINFOF_DESTINATION = @as(i32, 0);
pub const MIXER_GETLINEINFOF_SOURCE = @as(i32, 1);
pub const MIXER_GETLINEINFOF_LINEID = @as(i32, 2);
pub const MIXER_GETLINEINFOF_COMPONENTTYPE = @as(i32, 3);
pub const MIXER_GETLINEINFOF_TARGETTYPE = @as(i32, 4);
pub const MIXER_GETLINEINFOF_QUERYMASK = @as(i32, 15);
pub const MIXERCONTROL_CONTROLF_UNIFORM = @as(i32, 1);
pub const MIXERCONTROL_CONTROLF_MULTIPLE = @as(i32, 2);
pub const MIXERCONTROL_CONTROLF_DISABLED = @as(i32, -2147483648);
pub const MIXERCONTROL_CT_CLASS_MASK = @as(i32, -268435456);
pub const MIXERCONTROL_CT_CLASS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_CLASS_METER = @as(i32, 268435456);
pub const MIXERCONTROL_CT_CLASS_SWITCH = @as(i32, 536870912);
pub const MIXERCONTROL_CT_CLASS_NUMBER = @as(i32, 805306368);
pub const MIXERCONTROL_CT_CLASS_SLIDER = @as(i32, 1073741824);
pub const MIXERCONTROL_CT_CLASS_FADER = @as(i32, 1342177280);
pub const MIXERCONTROL_CT_CLASS_TIME = @as(i32, 1610612736);
pub const MIXERCONTROL_CT_CLASS_LIST = @as(i32, 1879048192);
pub const MIXERCONTROL_CT_SUBCLASS_MASK = @as(i32, 251658240);
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_METER_POLLED = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_LIST_SINGLE = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE = @as(i32, 16777216);
pub const MIXERCONTROL_CT_UNITS_MASK = @as(i32, 16711680);
pub const MIXERCONTROL_CT_UNITS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_UNITS_BOOLEAN = @as(i32, 65536);
pub const MIXERCONTROL_CT_UNITS_SIGNED = @as(i32, 131072);
pub const MIXERCONTROL_CT_UNITS_UNSIGNED = @as(i32, 196608);
pub const MIXERCONTROL_CT_UNITS_DECIBELS = @as(i32, 262144);
pub const MIXERCONTROL_CT_UNITS_PERCENT = @as(i32, 327680);
pub const MIXER_GETLINECONTROLSF_ALL = @as(i32, 0);
pub const MIXER_GETLINECONTROLSF_ONEBYID = @as(i32, 1);
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE = @as(i32, 2);
pub const MIXER_GETLINECONTROLSF_QUERYMASK = @as(i32, 15);
pub const MIXER_GETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT = @as(i32, 1);
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const MIXER_SETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_SETCONTROLDETAILSF_CUSTOM = @as(i32, 1);
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const DRV_MAPPER_PREFERRED_INPUT_GET = @as(u32, 16384);
pub const DRV_MAPPER_PREFERRED_OUTPUT_GET = @as(u32, 16386);
pub const DRVM_MAPPER = @as(u32, 8192);
pub const DRVM_MAPPER_STATUS = @as(u32, 8192);
pub const WIDM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEIN_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEIN_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEIN_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const WODM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEOUT_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEOUT_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEOUT_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const ACMERR_BASE = @as(u32, 512);
pub const ACMERR_NOTPOSSIBLE = @as(u32, 512);
pub const ACMERR_BUSY = @as(u32, 513);
pub const ACMERR_UNPREPARED = @as(u32, 514);
pub const ACMERR_CANCELED = @as(u32, 515);
pub const ACM_METRIC_COUNT_DRIVERS = @as(u32, 1);
pub const ACM_METRIC_COUNT_CODECS = @as(u32, 2);
pub const ACM_METRIC_COUNT_CONVERTERS = @as(u32, 3);
pub const ACM_METRIC_COUNT_FILTERS = @as(u32, 4);
pub const ACM_METRIC_COUNT_DISABLED = @as(u32, 5);
pub const ACM_METRIC_COUNT_HARDWARE = @as(u32, 6);
pub const ACM_METRIC_COUNT_LOCAL_DRIVERS = @as(u32, 20);
pub const ACM_METRIC_COUNT_LOCAL_CODECS = @as(u32, 21);
pub const ACM_METRIC_COUNT_LOCAL_CONVERTERS = @as(u32, 22);
pub const ACM_METRIC_COUNT_LOCAL_FILTERS = @as(u32, 23);
pub const ACM_METRIC_COUNT_LOCAL_DISABLED = @as(u32, 24);
pub const ACM_METRIC_HARDWARE_WAVE_INPUT = @as(u32, 30);
pub const ACM_METRIC_HARDWARE_WAVE_OUTPUT = @as(u32, 31);
pub const ACM_METRIC_MAX_SIZE_FORMAT = @as(u32, 50);
pub const ACM_METRIC_MAX_SIZE_FILTER = @as(u32, 51);
pub const ACM_METRIC_DRIVER_SUPPORT = @as(u32, 100);
pub const ACM_METRIC_DRIVER_PRIORITY = @as(u32, 101);
pub const ACM_DRIVERENUMF_NOLOCAL = @as(i32, 1073741824);
pub const ACM_DRIVERENUMF_DISABLED = @as(i32, -2147483648);
pub const ACM_DRIVERADDF_NAME = @as(i32, 1);
pub const ACM_DRIVERADDF_FUNCTION = @as(i32, 3);
pub const ACM_DRIVERADDF_NOTIFYHWND = @as(i32, 4);
pub const ACM_DRIVERADDF_TYPEMASK = @as(i32, 7);
pub const ACM_DRIVERADDF_LOCAL = @as(i32, 0);
pub const ACM_DRIVERADDF_GLOBAL = @as(i32, 8);
pub const ACMDM_USER = @as(u32, 16384);
pub const ACMDM_RESERVED_LOW = @as(u32, 24576);
pub const ACMDM_RESERVED_HIGH = @as(u32, 28671);
pub const ACMDM_DRIVER_ABOUT = @as(u32, 24587);
pub const ACM_DRIVERPRIORITYF_ENABLE = @as(i32, 1);
pub const ACM_DRIVERPRIORITYF_DISABLE = @as(i32, 2);
pub const ACM_DRIVERPRIORITYF_ABLEMASK = @as(i32, 3);
pub const ACM_DRIVERPRIORITYF_BEGIN = @as(i32, 65536);
pub const ACM_DRIVERPRIORITYF_END = @as(i32, 131072);
pub const ACM_DRIVERPRIORITYF_DEFERMASK = @as(i32, 196608);
pub const ACMDRIVERDETAILS_SHORTNAME_CHARS = @as(u32, 32);
pub const ACMDRIVERDETAILS_LONGNAME_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_COPYRIGHT_CHARS = @as(u32, 80);
pub const ACMDRIVERDETAILS_LICENSING_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_FEATURES_CHARS = @as(u32, 512);
pub const ACMDRIVERDETAILS_SUPPORTF_CODEC = @as(i32, 1);
pub const ACMDRIVERDETAILS_SUPPORTF_CONVERTER = @as(i32, 2);
pub const ACMDRIVERDETAILS_SUPPORTF_FILTER = @as(i32, 4);
pub const ACMDRIVERDETAILS_SUPPORTF_HARDWARE = @as(i32, 8);
pub const ACMDRIVERDETAILS_SUPPORTF_ASYNC = @as(i32, 16);
pub const ACMDRIVERDETAILS_SUPPORTF_LOCAL = @as(i32, 1073741824);
pub const ACMDRIVERDETAILS_SUPPORTF_DISABLED = @as(i32, -2147483648);
pub const ACMFORMATTAGDETAILS_FORMATTAG_CHARS = @as(u32, 48);
pub const ACM_FORMATTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATTAGDETAILSF_FORMATTAG = @as(i32, 1);
pub const ACM_FORMATTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FORMATTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFORMATDETAILS_FORMAT_CHARS = @as(u32, 128);
pub const ACM_FORMATDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATDETAILSF_FORMAT = @as(i32, 1);
pub const ACM_FORMATDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FORMATENUMF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATENUMF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATENUMF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATENUMF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATENUMF_CONVERT = @as(i32, 1048576);
pub const ACM_FORMATENUMF_SUGGEST = @as(i32, 2097152);
pub const ACM_FORMATENUMF_HARDWARE = @as(i32, 4194304);
pub const ACM_FORMATENUMF_INPUT = @as(i32, 8388608);
pub const ACM_FORMATENUMF_OUTPUT = @as(i32, 16777216);
pub const ACM_FORMATSUGGESTF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATSUGGESTF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATSUGGESTF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATSUGGESTF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATSUGGESTF_TYPEMASK = @as(i32, 16711680);
pub const ACMHELPMSGSTRINGA = "acmchoose_help";
pub const ACMHELPMSGSTRINGW = "acmchoose_help";
pub const ACMHELPMSGCONTEXTMENUA = "acmchoose_contextmenu";
pub const ACMHELPMSGCONTEXTMENUW = "acmchoose_contextmenu";
pub const ACMHELPMSGCONTEXTHELPA = "acmchoose_contexthelp";
pub const ACMHELPMSGCONTEXTHELPW = "acmchoose_contexthelp";
pub const ACMHELPMSGSTRING = "acmchoose_help";
pub const ACMHELPMSGCONTEXTMENU = "acmchoose_contextmenu";
pub const ACMHELPMSGCONTEXTHELP = "acmchoose_contexthelp";
pub const MM_ACM_FORMATCHOOSE = @as(u32, 32768);
pub const FORMATCHOOSE_MESSAGE = @as(u32, 0);
pub const FORMATCHOOSE_FORMATTAG_VERIFY = @as(u32, 0);
pub const FORMATCHOOSE_FORMAT_VERIFY = @as(u32, 1);
pub const FORMATCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFORMATCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFORMATCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT = @as(i32, 64);
pub const ACMFORMATCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMFILTERTAGDETAILS_FILTERTAG_CHARS = @as(u32, 48);
pub const ACM_FILTERTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERTAGDETAILSF_FILTERTAG = @as(i32, 1);
pub const ACM_FILTERTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FILTERTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFILTERDETAILS_FILTER_CHARS = @as(u32, 128);
pub const ACM_FILTERDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERDETAILSF_FILTER = @as(i32, 1);
pub const ACM_FILTERDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FILTERENUMF_DWFILTERTAG = @as(i32, 65536);
pub const MM_ACM_FILTERCHOOSE = @as(u32, 32768);
pub const FILTERCHOOSE_MESSAGE = @as(u32, 0);
pub const FILTERCHOOSE_FILTERTAG_VERIFY = @as(u32, 0);
pub const FILTERCHOOSE_FILTER_VERIFY = @as(u32, 1);
pub const FILTERCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFILTERCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFILTERCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT = @as(i32, 64);
pub const ACMFILTERCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMSTREAMHEADER_STATUSF_DONE = @as(i32, 65536);
pub const ACMSTREAMHEADER_STATUSF_PREPARED = @as(i32, 131072);
pub const ACMSTREAMHEADER_STATUSF_INQUEUE = @as(i32, 1048576);
pub const ACM_STREAMOPENF_QUERY = @as(u32, 1);
pub const ACM_STREAMOPENF_ASYNC = @as(u32, 2);
pub const ACM_STREAMOPENF_NONREALTIME = @as(u32, 4);
pub const ACM_STREAMSIZEF_SOURCE = @as(i32, 0);
pub const ACM_STREAMSIZEF_DESTINATION = @as(i32, 1);
pub const ACM_STREAMSIZEF_QUERYMASK = @as(i32, 15);
pub const ACM_STREAMCONVERTF_BLOCKALIGN = @as(u32, 4);
pub const ACM_STREAMCONVERTF_START = @as(u32, 16);
pub const ACM_STREAMCONVERTF_END = @as(u32, 32);
pub const SND_SYNC = @as(u32, 0);
pub const SND_ASYNC = @as(u32, 1);
pub const SND_NODEFAULT = @as(u32, 2);
pub const SND_MEMORY = @as(u32, 4);
pub const SND_LOOP = @as(u32, 8);
pub const SND_NOSTOP = @as(u32, 16);
pub const SND_NOWAIT = @as(i32, 8192);
pub const SND_ALIAS = @as(i32, 65536);
pub const SND_ALIAS_ID = @as(i32, 1114112);
pub const SND_FILENAME = @as(i32, 131072);
pub const SND_RESOURCE = @as(i32, 262148);
pub const SND_PURGE = @as(u32, 64);
pub const SND_APPLICATION = @as(u32, 128);
pub const SND_SENTRY = @as(i32, 524288);
pub const SND_RING = @as(i32, 1048576);
pub const SND_SYSTEM = @as(i32, 2097152);
pub const SND_ALIAS_START = @as(u32, 0);
pub const ACMDM_DRIVER_NOTIFY = @as(u32, 24577);
pub const ACMDM_DRIVER_DETAILS = @as(u32, 24586);
pub const ACMDM_HARDWARE_WAVE_CAPS_INPUT = @as(u32, 24596);
pub const ACMDM_HARDWARE_WAVE_CAPS_OUTPUT = @as(u32, 24597);
pub const ACMDM_FORMATTAG_DETAILS = @as(u32, 24601);
pub const ACMDM_FORMAT_DETAILS = @as(u32, 24602);
pub const ACMDM_FORMAT_SUGGEST = @as(u32, 24603);
pub const ACMDM_FILTERTAG_DETAILS = @as(u32, 24626);
pub const ACMDM_FILTER_DETAILS = @as(u32, 24627);
pub const ACMDM_STREAM_OPEN = @as(u32, 24652);
pub const ACMDM_STREAM_CLOSE = @as(u32, 24653);
pub const ACMDM_STREAM_SIZE = @as(u32, 24654);
pub const ACMDM_STREAM_CONVERT = @as(u32, 24655);
pub const ACMDM_STREAM_RESET = @as(u32, 24656);
pub const ACMDM_STREAM_PREPARE = @as(u32, 24657);
pub const ACMDM_STREAM_UNPREPARE = @as(u32, 24658);
pub const ACMDM_STREAM_UPDATE = @as(u32, 24659);

//--------------------------------------------------------------------------------
// Section: Types (229)
//--------------------------------------------------------------------------------
pub const LPWAVECALLBACK = *const fn (
    hdrvr: ?HDRVR,
    u_msg: u32,
    dw_user: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPMIDICALLBACK = *const fn (
    hdrvr: ?HDRVR,
    u_msg: u32,
    dw_user: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIDI_WAVE_OPEN_TYPE = enum(u32) {
    CALLBACK_TYPEMASK = 458752,
    CALLBACK_NULL = 0,
    CALLBACK_WINDOW = 65536,
    CALLBACK_TASK = 131072,
    CALLBACK_FUNCTION = 196608,
    // CALLBACK_THREAD = 131072, this enum value conflicts with CALLBACK_TASK
    CALLBACK_EVENT = 327680,
    WAVE_FORMAT_QUERY = 1,
    WAVE_ALLOWSYNC = 2,
    WAVE_MAPPED = 4,
    WAVE_FORMAT_DIRECT = 8,
    WAVE_FORMAT_DIRECT_QUERY = 9,
    WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 16,
    MIDI_IO_STATUS = 32,
    _,
    pub fn initFlags(o: struct {
        CALLBACK_TYPEMASK: u1 = 0,
        CALLBACK_NULL: u1 = 0,
        CALLBACK_WINDOW: u1 = 0,
        CALLBACK_TASK: u1 = 0,
        CALLBACK_FUNCTION: u1 = 0,
        CALLBACK_EVENT: u1 = 0,
        WAVE_FORMAT_QUERY: u1 = 0,
        WAVE_ALLOWSYNC: u1 = 0,
        WAVE_MAPPED: u1 = 0,
        WAVE_FORMAT_DIRECT: u1 = 0,
        WAVE_FORMAT_DIRECT_QUERY: u1 = 0,
        WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE: u1 = 0,
        MIDI_IO_STATUS: u1 = 0,
    }) MIDI_WAVE_OPEN_TYPE {
        return @as(MIDI_WAVE_OPEN_TYPE, @enumFromInt((if (o.CALLBACK_TYPEMASK == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK) else 0) | (if (o.CALLBACK_NULL == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL) else 0) | (if (o.CALLBACK_WINDOW == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW) else 0) | (if (o.CALLBACK_TASK == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK) else 0) | (if (o.CALLBACK_FUNCTION == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION) else 0) | (if (o.CALLBACK_EVENT == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT) else 0) | (if (o.WAVE_FORMAT_QUERY == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY) else 0) | (if (o.WAVE_ALLOWSYNC == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC) else 0) | (if (o.WAVE_MAPPED == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED) else 0) | (if (o.WAVE_FORMAT_DIRECT == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT) else 0) | (if (o.WAVE_FORMAT_DIRECT_QUERY == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY) else 0) | (if (o.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE) else 0) | (if (o.MIDI_IO_STATUS == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS) else 0)));
    }
};
pub const CALLBACK_TYPEMASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK;
pub const CALLBACK_NULL = MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL;
pub const CALLBACK_WINDOW = MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW;
pub const CALLBACK_TASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_FUNCTION = MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION;
pub const CALLBACK_THREAD = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_EVENT = MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT;
pub const WAVE_FORMAT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY;
pub const WAVE_ALLOWSYNC = MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC;
pub const WAVE_MAPPED = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED;
pub const WAVE_FORMAT_DIRECT = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT;
pub const WAVE_FORMAT_DIRECT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE;
pub const MIDI_IO_STATUS = MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS;

pub const MIXERLINE_COMPONENTTYPE = enum(u32) {
    DST_DIGITAL = 1,
    DST_HEADPHONES = 5,
    DST_LINE = 2,
    DST_MONITOR = 3,
    DST_SPEAKERS = 4,
    DST_TELEPHONE = 6,
    DST_UNDEFINED = 0,
    DST_VOICEIN = 8,
    DST_WAVEIN = 7,
    SRC_ANALOG = 4106,
    SRC_AUXILIARY = 4105,
    SRC_COMPACTDISC = 4101,
    SRC_DIGITAL = 4097,
    SRC_LINE = 4098,
    SRC_MICROPHONE = 4099,
    SRC_PCSPEAKER = 4103,
    SRC_SYNTHESIZER = 4100,
    SRC_TELEPHONE = 4102,
    SRC_UNDEFINED = 4096,
    SRC_WAVEOUT = 4104,
};
pub const MIXERLINE_COMPONENTTYPE_DST_DIGITAL = MIXERLINE_COMPONENTTYPE.DST_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = MIXERLINE_COMPONENTTYPE.DST_HEADPHONES;
pub const MIXERLINE_COMPONENTTYPE_DST_LINE = MIXERLINE_COMPONENTTYPE.DST_LINE;
pub const MIXERLINE_COMPONENTTYPE_DST_MONITOR = MIXERLINE_COMPONENTTYPE.DST_MONITOR;
pub const MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = MIXERLINE_COMPONENTTYPE.DST_SPEAKERS;
pub const MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = MIXERLINE_COMPONENTTYPE.DST_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = MIXERLINE_COMPONENTTYPE.DST_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_DST_VOICEIN = MIXERLINE_COMPONENTTYPE.DST_VOICEIN;
pub const MIXERLINE_COMPONENTTYPE_DST_WAVEIN = MIXERLINE_COMPONENTTYPE.DST_WAVEIN;
pub const MIXERLINE_COMPONENTTYPE_SRC_ANALOG = MIXERLINE_COMPONENTTYPE.SRC_ANALOG;
pub const MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = MIXERLINE_COMPONENTTYPE.SRC_AUXILIARY;
pub const MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = MIXERLINE_COMPONENTTYPE.SRC_COMPACTDISC;
pub const MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = MIXERLINE_COMPONENTTYPE.SRC_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_SRC_LINE = MIXERLINE_COMPONENTTYPE.SRC_LINE;
pub const MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = MIXERLINE_COMPONENTTYPE.SRC_MICROPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = MIXERLINE_COMPONENTTYPE.SRC_PCSPEAKER;
pub const MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = MIXERLINE_COMPONENTTYPE.SRC_SYNTHESIZER;
pub const MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = MIXERLINE_COMPONENTTYPE.SRC_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = MIXERLINE_COMPONENTTYPE.SRC_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = MIXERLINE_COMPONENTTYPE.SRC_WAVEOUT;

pub const AUDIO_VOLUME_NOTIFICATION_DATA = extern struct {
    guidEventContext: Guid,
    bMuted: BOOL,
    fMasterVolume: f32,
    nChannels: u32,
    afChannelVolumes: [1]f32,
};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIDI = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIDIIN = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIDIOUT = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIDISTRM = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIXER = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HMIXEROBJ = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HWAVE = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HWAVEOUT = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HWAVEIN = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HACMDRIVERID = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HACMDRIVER = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HACMSTREAM = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HACMOBJ = *opaque {};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMessageFilter_Value = Guid.initString("00000016-0000-0000-c000-000000000046");
pub const IID_IMessageFilter = &IID_IMessageFilter_Value;
pub const IMessageFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleInComingCall: *const fn (
            self: *const IMessageFilter,
            dw_call_type: u32,
            htask_caller: ?HTASK,
            dw_tick_count: u32,
            lp_interface_info: ?*INTERFACEINFO,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        RetryRejectedCall: *const fn (
            self: *const IMessageFilter,
            htask_callee: ?HTASK,
            dw_tick_count: u32,
            dw_reject_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        MessagePending: *const fn (
            self: *const IMessageFilter,
            htask_callee: ?HTASK,
            dw_tick_count: u32,
            dw_pending_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn handleInComingCall(self: *const T, dw_call_type_: u32, htask_caller_: ?HTASK, dw_tick_count_: u32, lp_interface_info_: ?*INTERFACEINFO) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).HandleInComingCall(@as(*const IMessageFilter, @ptrCast(self)), dw_call_type_, htask_caller_, dw_tick_count_, lp_interface_info_);
            }
            pub inline fn retryRejectedCall(self: *const T, htask_callee_: ?HTASK, dw_tick_count_: u32, dw_reject_type_: u32) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).RetryRejectedCall(@as(*const IMessageFilter, @ptrCast(self)), htask_callee_, dw_tick_count_, dw_reject_type_);
            }
            pub inline fn messagePending(self: *const T, htask_callee_: ?HTASK, dw_tick_count_: u32, dw_pending_type_: u32) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).MessagePending(@as(*const IMessageFilter, @ptrCast(self)), htask_callee_, dw_tick_count_, dw_pending_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WAVEFORMATEXTENSIBLE = extern struct {
    Format: WAVEFORMATEX align(1),
    Samples: extern union {
        wValidBitsPerSample: u16 align(1),
        wSamplesPerBlock: u16 align(1),
        wReserved: u16 align(1),
    } align(1),
    dwChannelMask: u32 align(1),
    SubFormat: Guid align(1),
};

pub const WAVEFILTER = extern struct {
    cbStruct: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwFilter: u32 align(1),
    dwReserved: [5]u32 align(1),
};

pub const VOLUMEWAVEFILTER = extern struct {
    wfltr: WAVEFILTER align(1),
    dwVolume: u32 align(1),
};

pub const ECHOWAVEFILTER = extern struct {
    wfltr: WAVEFILTER align(1),
    dwVolume: u32 align(1),
    dwDelay: u32 align(1),
};

pub const WAVEHDR = extern struct {
    lpData: ?[*]u8 align(1),
    dwBufferLength: u32 align(1),
    dwBytesRecorded: u32 align(1),
    dwUser: usize align(1),
    dwFlags: u32 align(1),
    dwLoops: u32 align(1),
    lpNext: ?*WAVEHDR align(1),
    reserved: usize align(1),
};

pub const WAVEOUTCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const WAVEOUTCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const WAVEOUTCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEOUTCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEINCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
};

pub const WAVEINCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
};

pub const WAVEINCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEINCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEFORMAT = extern struct {
    wFormatTag: u16 align(1),
    nChannels: u16 align(1),
    nSamplesPerSec: u32 align(1),
    nAvgBytesPerSec: u32 align(1),
    nBlockAlign: u16 align(1),
};

pub const PCMWAVEFORMAT = extern struct {
    wf: WAVEFORMAT align(1),
    wBitsPerSample: u16 align(1),
};

pub const WAVEFORMATEX = extern struct {
    wFormatTag: u16 align(1),
    nChannels: u16 align(1),
    nSamplesPerSec: u32 align(1),
    nAvgBytesPerSec: u32 align(1),
    nBlockAlign: u16 align(1),
    wBitsPerSample: u16 align(1),
    cbSize: u16 align(1),
};

pub const MIDIOUTCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIOUTCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIOUTCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIOUTCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIINCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwSupport: u32 align(1),
};

pub const MIDIINCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIINCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIINCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIHDR = extern struct {
    lpData: ?PSTR align(1),
    dwBufferLength: u32 align(1),
    dwBytesRecorded: u32 align(1),
    dwUser: usize align(1),
    dwFlags: u32 align(1),
    lpNext: ?*MIDIHDR align(1),
    reserved: usize align(1),
    dwOffset: u32 align(1),
    dwReserved: [8]usize align(1),
};

pub const MIDIEVENT = extern struct {
    dwDeltaTime: u32 align(1),
    dwStreamID: u32 align(1),
    dwEvent: u32 align(1),
    dwParms: [1]u32 align(1),
};

pub const MIDISTRMBUFFVER = extern struct {
    dwVersion: u32 align(1),
    dwMid: u32 align(1),
    dwOEMVersion: u32 align(1),
};

pub const MIDIPROPTIMEDIV = extern struct {
    cbStruct: u32 align(1),
    dwTimeDiv: u32 align(1),
};

pub const MIDIPROPTEMPO = extern struct {
    cbStruct: u32 align(1),
    dwTempo: u32 align(1),
};

pub const AUXCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const AUXCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const AUXCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const AUXCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
};

pub const MIXERCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
};

pub const MIXERCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERLINEA = extern struct {
    cbStruct: u32 align(1),
    dwDestination: u32 align(1),
    dwSource: u32 align(1),
    dwLineID: u32 align(1),
    fdwLine: u32 align(1),
    dwUser: usize align(1),
    dwComponentType: MIXERLINE_COMPONENTTYPE align(1),
    cChannels: u32 align(1),
    cConnections: u32 align(1),
    cControls: u32 align(1),
    szShortName: [16]CHAR align(1),
    szName: [64]CHAR align(1),
    Target: extern struct {
        dwType: u32 align(1),
        dwDeviceID: u32 align(1),
        wMid: u16 align(1),
        wPid: u16 align(1),
        vDriverVersion: u32 align(1),
        szPname: [32]CHAR align(1),
    } align(1),
};

pub const MIXERLINEW = extern struct {
    cbStruct: u32 align(1),
    dwDestination: u32 align(1),
    dwSource: u32 align(1),
    dwLineID: u32 align(1),
    fdwLine: u32 align(1),
    dwUser: usize align(1),
    dwComponentType: MIXERLINE_COMPONENTTYPE align(1),
    cChannels: u32 align(1),
    cConnections: u32 align(1),
    cControls: u32 align(1),
    szShortName: [16]u16 align(1),
    szName: [64]u16 align(1),
    Target: extern struct {
        dwType: u32 align(1),
        dwDeviceID: u32 align(1),
        wMid: u16 align(1),
        wPid: u16 align(1),
        vDriverVersion: u32 align(1),
        szPname: [32]u16 align(1),
    } align(1),
};

pub const MIXERCONTROLA = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    dwControlType: u32 align(1),
    fdwControl: u32 align(1),
    cMultipleItems: u32 align(1),
    szShortName: [16]CHAR align(1),
    szName: [64]CHAR align(1),
    Bounds: extern union {
        Anonymous1: extern struct {
            lMinimum: i32 align(1),
            lMaximum: i32 align(1),
        } align(1),
        Anonymous2: extern struct {
            dwMinimum: u32 align(1),
            dwMaximum: u32 align(1),
        } align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
    Metrics: extern union {
        cSteps: u32 align(1),
        cbCustomData: u32 align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
};

pub const MIXERCONTROLW = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    dwControlType: u32 align(1),
    fdwControl: u32 align(1),
    cMultipleItems: u32 align(1),
    szShortName: [16]u16 align(1),
    szName: [64]u16 align(1),
    Bounds: extern union {
        Anonymous1: extern struct {
            lMinimum: i32 align(1),
            lMaximum: i32 align(1),
        } align(1),
        Anonymous2: extern struct {
            dwMinimum: u32 align(1),
            dwMaximum: u32 align(1),
        } align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
    Metrics: extern union {
        cSteps: u32 align(1),
        cbCustomData: u32 align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
};

pub const MIXERLINECONTROLSA = extern struct {
    cbStruct: u32 align(1),
    dwLineID: u32 align(1),
    Anonymous: extern union {
        dwControlID: u32 align(1),
        dwControlType: u32 align(1),
    } align(1),
    cControls: u32 align(1),
    cbmxctrl: u32 align(1),
    pamxctrl: ?*MIXERCONTROLA align(1),
};

pub const MIXERLINECONTROLSW = extern struct {
    cbStruct: u32 align(1),
    dwLineID: u32 align(1),
    Anonymous: extern union {
        dwControlID: u32 align(1),
        dwControlType: u32 align(1),
    } align(1),
    cControls: u32 align(1),
    cbmxctrl: u32 align(1),
    pamxctrl: ?*MIXERCONTROLW align(1),
};

pub const MIXERCONTROLDETAILS = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    cChannels: u32 align(1),
    Anonymous: extern union {
        hwndOwner: ?HWND align(1),
        cMultipleItems: u32 align(1),
    } align(1),
    cbDetails: u32 align(1),
    paDetails: ?*anyopaque align(1),
};

pub const MIXERCONTROLDETAILS_LISTTEXTA = extern struct {
    dwParam1: u32 align(1),
    dwParam2: u32 align(1),
    szName: [64]CHAR align(1),
};

pub const MIXERCONTROLDETAILS_LISTTEXTW = extern struct {
    dwParam1: u32 align(1),
    dwParam2: u32 align(1),
    szName: [64]u16 align(1),
};

pub const MIXERCONTROLDETAILS_BOOLEAN = extern struct {
    fValue: i32 align(1),
};

pub const MIXERCONTROLDETAILS_SIGNED = extern struct {
    lValue: i32 align(1),
};

pub const MIXERCONTROLDETAILS_UNSIGNED = extern struct {
    dwValue: u32 align(1),
};

pub const AUDCLNT_SHAREMODE = enum(i32) {
    SHARED = 0,
    EXCLUSIVE = 1,
};
pub const AUDCLNT_SHAREMODE_SHARED = AUDCLNT_SHAREMODE.SHARED;
pub const AUDCLNT_SHAREMODE_EXCLUSIVE = AUDCLNT_SHAREMODE.EXCLUSIVE;

pub const AUDIO_STREAM_CATEGORY = enum(i32) {
    Other = 0,
    ForegroundOnlyMedia = 1,
    Communications = 3,
    Alerts = 4,
    SoundEffects = 5,
    GameEffects = 6,
    GameMedia = 7,
    GameChat = 8,
    Speech = 9,
    Movie = 10,
    Media = 11,
    FarFieldSpeech = 12,
    UniformSpeech = 13,
    VoiceTyping = 14,
};
pub const AudioCategory_Other = AUDIO_STREAM_CATEGORY.Other;
pub const AudioCategory_ForegroundOnlyMedia = AUDIO_STREAM_CATEGORY.ForegroundOnlyMedia;
pub const AudioCategory_Communications = AUDIO_STREAM_CATEGORY.Communications;
pub const AudioCategory_Alerts = AUDIO_STREAM_CATEGORY.Alerts;
pub const AudioCategory_SoundEffects = AUDIO_STREAM_CATEGORY.SoundEffects;
pub const AudioCategory_GameEffects = AUDIO_STREAM_CATEGORY.GameEffects;
pub const AudioCategory_GameMedia = AUDIO_STREAM_CATEGORY.GameMedia;
pub const AudioCategory_GameChat = AUDIO_STREAM_CATEGORY.GameChat;
pub const AudioCategory_Speech = AUDIO_STREAM_CATEGORY.Speech;
pub const AudioCategory_Movie = AUDIO_STREAM_CATEGORY.Movie;
pub const AudioCategory_Media = AUDIO_STREAM_CATEGORY.Media;
pub const AudioCategory_FarFieldSpeech = AUDIO_STREAM_CATEGORY.FarFieldSpeech;
pub const AudioCategory_UniformSpeech = AUDIO_STREAM_CATEGORY.UniformSpeech;
pub const AudioCategory_VoiceTyping = AUDIO_STREAM_CATEGORY.VoiceTyping;

pub const AudioSessionState = enum(i32) {
    Inactive = 0,
    Active = 1,
    Expired = 2,
};
pub const AudioSessionStateInactive = AudioSessionState.Inactive;
pub const AudioSessionStateActive = AudioSessionState.Active;
pub const AudioSessionStateExpired = AudioSessionState.Expired;

pub const _AUDCLNT_BUFFERFLAGS = enum(i32) {
    DATA_DISCONTINUITY = 1,
    SILENT = 2,
    TIMESTAMP_ERROR = 4,
};
pub const AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY = _AUDCLNT_BUFFERFLAGS.DATA_DISCONTINUITY;
pub const AUDCLNT_BUFFERFLAGS_SILENT = _AUDCLNT_BUFFERFLAGS.SILENT;
pub const AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR = _AUDCLNT_BUFFERFLAGS.TIMESTAMP_ERROR;

pub const AUDCLNT_STREAMOPTIONS = enum(u32) {
    NONE = 0,
    RAW = 1,
    MATCH_FORMAT = 2,
    AMBISONICS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RAW: u1 = 0,
        MATCH_FORMAT: u1 = 0,
        AMBISONICS: u1 = 0,
    }) AUDCLNT_STREAMOPTIONS {
        return @as(AUDCLNT_STREAMOPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.NONE) else 0) | (if (o.RAW == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.RAW) else 0) | (if (o.MATCH_FORMAT == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.MATCH_FORMAT) else 0) | (if (o.AMBISONICS == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.AMBISONICS) else 0)));
    }
};
pub const AUDCLNT_STREAMOPTIONS_NONE = AUDCLNT_STREAMOPTIONS.NONE;
pub const AUDCLNT_STREAMOPTIONS_RAW = AUDCLNT_STREAMOPTIONS.RAW;
pub const AUDCLNT_STREAMOPTIONS_MATCH_FORMAT = AUDCLNT_STREAMOPTIONS.MATCH_FORMAT;
pub const AUDCLNT_STREAMOPTIONS_AMBISONICS = AUDCLNT_STREAMOPTIONS.AMBISONICS;

pub const AudioClientProperties = extern struct {
    cbSize: u32,
    bIsOffload: BOOL,
    eCategory: AUDIO_STREAM_CATEGORY,
    Options: AUDCLNT_STREAMOPTIONS,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClient_Value = Guid.initString("1cb9ad4c-dbfa-4c32-b178-c2f568a703b2");
pub const IID_IAudioClient = &IID_IAudioClient_Value;
pub const IAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IAudioClient,
            share_mode: AUDCLNT_SHAREMODE,
            stream_flags: u32,
            hns_buffer_duration: i64,
            hns_periodicity: i64,
            p_format: ?*const WAVEFORMATEX,
            audio_session_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSize: *const fn (
            self: *const IAudioClient,
            p_num_buffer_frames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamLatency: *const fn (
            self: *const IAudioClient,
            phns_latency: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPadding: *const fn (
            self: *const IAudioClient,
            p_num_padding_frames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFormatSupported: *const fn (
            self: *const IAudioClient,
            share_mode: AUDCLNT_SHAREMODE,
            p_format: ?*const WAVEFORMATEX,
            pp_closest_match: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixFormat: *const fn (
            self: *const IAudioClient,
            pp_device_format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevicePeriod: *const fn (
            self: *const IAudioClient,
            phns_default_device_period: ?*i64,
            phns_minimum_device_period: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: *const fn (
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventHandle: *const fn (
            self: *const IAudioClient,
            event_handle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: *const fn (
            self: *const IAudioClient,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, share_mode_: AUDCLNT_SHAREMODE, stream_flags_: u32, hns_buffer_duration_: i64, hns_periodicity_: i64, p_format_: ?*const WAVEFORMATEX, audio_session_guid_: ?*const Guid) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAudioClient, @ptrCast(self)), share_mode_, stream_flags_, hns_buffer_duration_, hns_periodicity_, p_format_, audio_session_guid_);
            }
            pub inline fn getBufferSize(self: *const T, p_num_buffer_frames_: ?*u32) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetBufferSize(@as(*const IAudioClient, @ptrCast(self)), p_num_buffer_frames_);
            }
            pub inline fn getStreamLatency(self: *const T, phns_latency_: ?*i64) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetStreamLatency(@as(*const IAudioClient, @ptrCast(self)), phns_latency_);
            }
            pub inline fn getCurrentPadding(self: *const T, p_num_padding_frames_: ?*u32) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetCurrentPadding(@as(*const IAudioClient, @ptrCast(self)), p_num_padding_frames_);
            }
            pub inline fn isFormatSupported(self: *const T, share_mode_: AUDCLNT_SHAREMODE, p_format_: ?*const WAVEFORMATEX, pp_closest_match_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).IsFormatSupported(@as(*const IAudioClient, @ptrCast(self)), share_mode_, p_format_, pp_closest_match_);
            }
            pub inline fn getMixFormat(self: *const T, pp_device_format_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetMixFormat(@as(*const IAudioClient, @ptrCast(self)), pp_device_format_);
            }
            pub inline fn getDevicePeriod(self: *const T, phns_default_device_period_: ?*i64, phns_minimum_device_period_: ?*i64) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetDevicePeriod(@as(*const IAudioClient, @ptrCast(self)), phns_default_device_period_, phns_minimum_device_period_);
            }
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Start(@as(*const IAudioClient, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Stop(@as(*const IAudioClient, @ptrCast(self)));
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAudioClient, @ptrCast(self)));
            }
            pub inline fn setEventHandle(self: *const T, event_handle_: ?HANDLE) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).SetEventHandle(@as(*const IAudioClient, @ptrCast(self)), event_handle_);
            }
            pub inline fn getService(self: *const T, riid_: ?*const Guid, ppv_: ?*?*anyopaque) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetService(@as(*const IAudioClient, @ptrCast(self)), riid_, ppv_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioClient2_Value = Guid.initString("726778cd-f60a-4eda-82de-e47610cd78aa");
pub const IID_IAudioClient2 = &IID_IAudioClient2_Value;
pub const IAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient.VTable,
        IsOffloadCapable: *const fn (
            self: *const IAudioClient2,
            category: AUDIO_STREAM_CATEGORY,
            pb_offload_capable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClientProperties: *const fn (
            self: *const IAudioClient2,
            p_properties: ?*const AudioClientProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSizeLimits: *const fn (
            self: *const IAudioClient2,
            p_format: ?*const WAVEFORMATEX,
            b_event_driven: BOOL,
            phns_min_buffer_duration: ?*i64,
            phns_max_buffer_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioClient.MethodMixin(T);
            pub inline fn isOffloadCapable(self: *const T, category_: AUDIO_STREAM_CATEGORY, pb_offload_capable_: ?*BOOL) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).IsOffloadCapable(@as(*const IAudioClient2, @ptrCast(self)), category_, pb_offload_capable_);
            }
            pub inline fn setClientProperties(self: *const T, p_properties_: ?*const AudioClientProperties) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).SetClientProperties(@as(*const IAudioClient2, @ptrCast(self)), p_properties_);
            }
            pub inline fn getBufferSizeLimits(self: *const T, p_format_: ?*const WAVEFORMATEX, b_event_driven_: BOOL, phns_min_buffer_duration_: ?*i64, phns_max_buffer_duration_: ?*i64) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).GetBufferSizeLimits(@as(*const IAudioClient2, @ptrCast(self)), p_format_, b_event_driven_, phns_min_buffer_duration_, phns_max_buffer_duration_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioClient3ActivationParams = extern struct {
    tracingContextId: Guid,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAudioClient3_Value = Guid.initString("7ed4ee07-8e67-4cd4-8c1a-2b7a5987ad42");
pub const IID_IAudioClient3 = &IID_IAudioClient3_Value;
pub const IAudioClient3 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient2.VTable,
        GetSharedModeEnginePeriod: *const fn (
            self: *const IAudioClient3,
            p_format: ?*const WAVEFORMATEX,
            p_default_period_in_frames: ?*u32,
            p_fundamental_period_in_frames: ?*u32,
            p_min_period_in_frames: ?*u32,
            p_max_period_in_frames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSharedModeEnginePeriod: *const fn (
            self: *const IAudioClient3,
            pp_format: ?*?*WAVEFORMATEX,
            p_current_period_in_frames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeSharedAudioStream: *const fn (
            self: *const IAudioClient3,
            stream_flags: u32,
            period_in_frames: u32,
            p_format: ?*const WAVEFORMATEX,
            audio_session_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioClient2.MethodMixin(T);
            pub inline fn getSharedModeEnginePeriod(self: *const T, p_format_: ?*const WAVEFORMATEX, p_default_period_in_frames_: ?*u32, p_fundamental_period_in_frames_: ?*u32, p_min_period_in_frames_: ?*u32, p_max_period_in_frames_: ?*u32) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).GetSharedModeEnginePeriod(@as(*const IAudioClient3, @ptrCast(self)), p_format_, p_default_period_in_frames_, p_fundamental_period_in_frames_, p_min_period_in_frames_, p_max_period_in_frames_);
            }
            pub inline fn getCurrentSharedModeEnginePeriod(self: *const T, pp_format_: ?*?*WAVEFORMATEX, p_current_period_in_frames_: ?*u32) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).GetCurrentSharedModeEnginePeriod(@as(*const IAudioClient3, @ptrCast(self)), pp_format_, p_current_period_in_frames_);
            }
            pub inline fn initializeSharedAudioStream(self: *const T, stream_flags_: u32, period_in_frames_: u32, p_format_: ?*const WAVEFORMATEX, audio_session_guid_: ?*const Guid) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).InitializeSharedAudioStream(@as(*const IAudioClient3, @ptrCast(self)), stream_flags_, period_in_frames_, p_format_, audio_session_guid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioRenderClient_Value = Guid.initString("f294acfc-3146-4483-a7bf-addca7c260e2");
pub const IID_IAudioRenderClient = &IID_IAudioRenderClient_Value;
pub const IAudioRenderClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: *const fn (
            self: *const IAudioRenderClient,
            num_frames_requested: u32,
            pp_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: *const fn (
            self: *const IAudioRenderClient,
            num_frames_written: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBuffer(self: *const T, num_frames_requested_: u32, pp_data_: ?*?*u8) HRESULT {
                return @as(*const IAudioRenderClient.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAudioRenderClient, @ptrCast(self)), num_frames_requested_, pp_data_);
            }
            pub inline fn releaseBuffer(self: *const T, num_frames_written_: u32, dw_flags_: u32) HRESULT {
                return @as(*const IAudioRenderClient.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAudioRenderClient, @ptrCast(self)), num_frames_written_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioCaptureClient_Value = Guid.initString("c8adbd64-e71e-48a0-a4de-185c395cd317");
pub const IID_IAudioCaptureClient = &IID_IAudioCaptureClient_Value;
pub const IAudioCaptureClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: *const fn (
            self: *const IAudioCaptureClient,
            pp_data: ?*?*u8,
            p_num_frames_to_read: ?*u32,
            pdw_flags: ?*u32,
            pu64_device_position: ?*u64,
            pu64_q_p_c_position: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: *const fn (
            self: *const IAudioCaptureClient,
            num_frames_read: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextPacketSize: *const fn (
            self: *const IAudioCaptureClient,
            p_num_frames_in_next_packet: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBuffer(self: *const T, pp_data_: ?*?*u8, p_num_frames_to_read_: ?*u32, pdw_flags_: ?*u32, pu64_device_position_: ?*u64, pu64_q_p_c_position_: ?*u64) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAudioCaptureClient, @ptrCast(self)), pp_data_, p_num_frames_to_read_, pdw_flags_, pu64_device_position_, pu64_q_p_c_position_);
            }
            pub inline fn releaseBuffer(self: *const T, num_frames_read_: u32) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAudioCaptureClient, @ptrCast(self)), num_frames_read_);
            }
            pub inline fn getNextPacketSize(self: *const T, p_num_frames_in_next_packet_: ?*u32) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).GetNextPacketSize(@as(*const IAudioCaptureClient, @ptrCast(self)), p_num_frames_in_next_packet_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClock_Value = Guid.initString("cd63314f-3fba-4a1b-812c-ef96358728e7");
pub const IID_IAudioClock = &IID_IAudioClock_Value;
pub const IAudioClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrequency: *const fn (
            self: *const IAudioClock,
            pu64_frequency: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: *const fn (
            self: *const IAudioClock,
            pu64_position: ?*u64,
            pu64_q_p_c_position: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharacteristics: *const fn (
            self: *const IAudioClock,
            pdw_characteristics: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFrequency(self: *const T, pu64_frequency_: ?*u64) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IAudioClock, @ptrCast(self)), pu64_frequency_);
            }
            pub inline fn getPosition(self: *const T, pu64_position_: ?*u64, pu64_q_p_c_position_: ?*u64) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IAudioClock, @ptrCast(self)), pu64_position_, pu64_q_p_c_position_);
            }
            pub inline fn getCharacteristics(self: *const T, pdw_characteristics_: ?*u32) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetCharacteristics(@as(*const IAudioClock, @ptrCast(self)), pdw_characteristics_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClock2_Value = Guid.initString("6f49ff73-6727-49ac-a008-d98cf5e70048");
pub const IID_IAudioClock2 = &IID_IAudioClock2_Value;
pub const IAudioClock2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevicePosition: *const fn (
            self: *const IAudioClock2,
            device_position: ?*u64,
            q_p_c_position: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDevicePosition(self: *const T, device_position_: ?*u64, q_p_c_position_: ?*u64) HRESULT {
                return @as(*const IAudioClock2.VTable, @ptrCast(self.vtable)).GetDevicePosition(@as(*const IAudioClock2, @ptrCast(self)), device_position_, q_p_c_position_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClockAdjustment_Value = Guid.initString("f6e4c0a0-46d9-4fb8-be21-57a3ef2b626c");
pub const IID_IAudioClockAdjustment = &IID_IAudioClockAdjustment_Value;
pub const IAudioClockAdjustment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSampleRate: *const fn (
            self: *const IAudioClockAdjustment,
            fl_sample_rate: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setSampleRate(self: *const T, fl_sample_rate_: f32) HRESULT {
                return @as(*const IAudioClockAdjustment.VTable, @ptrCast(self.vtable)).SetSampleRate(@as(*const IAudioClockAdjustment, @ptrCast(self)), fl_sample_rate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISimpleAudioVolume_Value = Guid.initString("87ce5498-68d6-44e5-9215-6da47ef883d8");
pub const IID_ISimpleAudioVolume = &IID_ISimpleAudioVolume_Value;
pub const ISimpleAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterVolume: *const fn (
            self: *const ISimpleAudioVolume,
            f_level: f32,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolume: *const fn (
            self: *const ISimpleAudioVolume,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: *const fn (
            self: *const ISimpleAudioVolume,
            b_mute: BOOL,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: *const fn (
            self: *const ISimpleAudioVolume,
            pb_mute: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMasterVolume(self: *const T, f_level_: f32, event_context_: ?*const Guid) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMasterVolume(@as(*const ISimpleAudioVolume, @ptrCast(self)), f_level_, event_context_);
            }
            pub inline fn getMasterVolume(self: *const T, pf_level_: ?*f32) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMasterVolume(@as(*const ISimpleAudioVolume, @ptrCast(self)), pf_level_);
            }
            pub inline fn setMute(self: *const T, b_mute_: BOOL, event_context_: ?*const Guid) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMute(@as(*const ISimpleAudioVolume, @ptrCast(self)), b_mute_, event_context_);
            }
            pub inline fn getMute(self: *const T, pb_mute_: ?*BOOL) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMute(@as(*const ISimpleAudioVolume, @ptrCast(self)), pb_mute_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_DUCKING_OPTIONS = enum(u32) {
    EFAULT = 0,
    O_NOT_DUCK_OTHER_STREAMS = 1,
    _,
    pub fn initFlags(o: struct {
        EFAULT: u1 = 0,
        O_NOT_DUCK_OTHER_STREAMS: u1 = 0,
    }) AUDIO_DUCKING_OPTIONS {
        return @as(AUDIO_DUCKING_OPTIONS, @enumFromInt((if (o.EFAULT == 1) @intFromEnum(AUDIO_DUCKING_OPTIONS.EFAULT) else 0) | (if (o.O_NOT_DUCK_OTHER_STREAMS == 1) @intFromEnum(AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS) else 0)));
    }
};
pub const AUDIO_DUCKING_OPTIONS_DEFAULT = AUDIO_DUCKING_OPTIONS.EFAULT;
pub const AUDIO_DUCKING_OPTIONS_DO_NOT_DUCK_OTHER_STREAMS = AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS;

const IID_IAudioClientDuckingControl_Value = Guid.initString("c789d381-a28c-4168-b28f-d3a837924dc3");
pub const IID_IAudioClientDuckingControl = &IID_IAudioClientDuckingControl_Value;
pub const IAudioClientDuckingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDuckingOptionsForCurrentStream: *const fn (
            self: *const IAudioClientDuckingControl,
            options: AUDIO_DUCKING_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDuckingOptionsForCurrentStream(self: *const T, options_: AUDIO_DUCKING_OPTIONS) HRESULT {
                return @as(*const IAudioClientDuckingControl.VTable, @ptrCast(self.vtable)).SetDuckingOptionsForCurrentStream(@as(*const IAudioClientDuckingControl, @ptrCast(self)), options_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_EFFECT_STATE = enum(i32) {
    FF = 0,
    N = 1,
};
pub const AUDIO_EFFECT_STATE_OFF = AUDIO_EFFECT_STATE.FF;
pub const AUDIO_EFFECT_STATE_ON = AUDIO_EFFECT_STATE.N;

pub const AUDIO_EFFECT = extern struct {
    id: Guid,
    canSetState: BOOL,
    state: AUDIO_EFFECT_STATE,
};

const IID_IAudioEffectsChangedNotificationClient_Value = Guid.initString("a5ded44f-3c5d-4b2b-bd1e-5dc1ee20bbf6");
pub const IID_IAudioEffectsChangedNotificationClient = &IID_IAudioEffectsChangedNotificationClient_Value;
pub const IAudioEffectsChangedNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAudioEffectsChanged: *const fn (
            self: *const IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onAudioEffectsChanged(self: *const T) HRESULT {
                return @as(*const IAudioEffectsChangedNotificationClient.VTable, @ptrCast(self.vtable)).OnAudioEffectsChanged(@as(*const IAudioEffectsChangedNotificationClient, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEffectsManager_Value = Guid.initString("4460b3ae-4b44-4527-8676-7548a8acd260");
pub const IID_IAudioEffectsManager = &IID_IAudioEffectsManager_Value;
pub const IAudioEffectsManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterAudioEffectsChangedNotificationCallback: *const fn (
            self: *const IAudioEffectsManager,
            client: ?*IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAudioEffectsChangedNotificationCallback: *const fn (
            self: *const IAudioEffectsManager,
            client: ?*IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioEffects: *const fn (
            self: *const IAudioEffectsManager,
            effects: ?*?*AUDIO_EFFECT,
            num_effects: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioEffectState: *const fn (
            self: *const IAudioEffectsManager,
            effect_id: Guid,
            state: AUDIO_EFFECT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerAudioEffectsChangedNotificationCallback(self: *const T, client_: ?*IAudioEffectsChangedNotificationClient) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).RegisterAudioEffectsChangedNotificationCallback(@as(*const IAudioEffectsManager, @ptrCast(self)), client_);
            }
            pub inline fn unregisterAudioEffectsChangedNotificationCallback(self: *const T, client_: ?*IAudioEffectsChangedNotificationClient) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).UnregisterAudioEffectsChangedNotificationCallback(@as(*const IAudioEffectsManager, @ptrCast(self)), client_);
            }
            pub inline fn getAudioEffects(self: *const T, effects_: ?*?*AUDIO_EFFECT, num_effects_: ?*u32) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).GetAudioEffects(@as(*const IAudioEffectsManager, @ptrCast(self)), effects_, num_effects_);
            }
            pub inline fn setAudioEffectState(self: *const T, effect_id_: Guid, state_: AUDIO_EFFECT_STATE) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).SetAudioEffectState(@as(*const IAudioEffectsManager, @ptrCast(self)), effect_id_, state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioStreamVolume_Value = Guid.initString("93014887-242d-4068-8a15-cf5e93b90fe3");
pub const IID_IAudioStreamVolume = &IID_IAudioStreamVolume_Value;
pub const IAudioStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: *const fn (
            self: *const IAudioStreamVolume,
            pdw_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolume: *const fn (
            self: *const IAudioStreamVolume,
            dw_index: u32,
            f_level: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolume: *const fn (
            self: *const IAudioStreamVolume,
            dw_index: u32,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllVolumes: *const fn (
            self: *const IAudioStreamVolume,
            dw_count: u32,
            pf_volumes: [*]const f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVolumes: *const fn (
            self: *const IAudioStreamVolume,
            dw_count: u32,
            pf_volumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getChannelCount(self: *const T, pdw_count_: ?*u32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioStreamVolume, @ptrCast(self)), pdw_count_);
            }
            pub inline fn setChannelVolume(self: *const T, dw_index_: u32, f_level_: f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetChannelVolume(@as(*const IAudioStreamVolume, @ptrCast(self)), dw_index_, f_level_);
            }
            pub inline fn getChannelVolume(self: *const T, dw_index_: u32, pf_level_: ?*f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelVolume(@as(*const IAudioStreamVolume, @ptrCast(self)), dw_index_, pf_level_);
            }
            pub inline fn setAllVolumes(self: *const T, dw_count_: u32, pf_volumes_: [*]const f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetAllVolumes(@as(*const IAudioStreamVolume, @ptrCast(self)), dw_count_, pf_volumes_);
            }
            pub inline fn getAllVolumes(self: *const T, dw_count_: u32, pf_volumes_: [*]f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetAllVolumes(@as(*const IAudioStreamVolume, @ptrCast(self)), dw_count_, pf_volumes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMBISONICS_TYPE = enum(i32) {
    D = 0,
};
pub const AMBISONICS_TYPE_FULL3D = AMBISONICS_TYPE.D;

pub const AMBISONICS_CHANNEL_ORDERING = enum(i32) {
    N = 0,
};
pub const AMBISONICS_CHANNEL_ORDERING_ACN = AMBISONICS_CHANNEL_ORDERING.N;

pub const AMBISONICS_NORMALIZATION = enum(i32) {
    SN3D = 0,
    N3D = 1,
};
pub const AMBISONICS_NORMALIZATION_SN3D = AMBISONICS_NORMALIZATION.SN3D;
pub const AMBISONICS_NORMALIZATION_N3D = AMBISONICS_NORMALIZATION.N3D;

pub const AMBISONICS_PARAMS = extern struct {
    u32Size: u32,
    u32Version: u32,
    u32Type: AMBISONICS_TYPE,
    u32ChannelOrdering: AMBISONICS_CHANNEL_ORDERING,
    u32Normalization: AMBISONICS_NORMALIZATION,
    u32Order: u32,
    u32NumChannels: u32,
    pu32ChannelMap: ?*u32,
};

const IID_IAudioAmbisonicsControl_Value = Guid.initString("28724c91-df35-4856-9f76-d6a26413f3df");
pub const IID_IAudioAmbisonicsControl = &IID_IAudioAmbisonicsControl_Value;
pub const IAudioAmbisonicsControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetData: *const fn (
            self: *const IAudioAmbisonicsControl,
            p_ambisonics_params: [*]const AMBISONICS_PARAMS,
            cb_ambisonics_params: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeadTracking: *const fn (
            self: *const IAudioAmbisonicsControl,
            b_enable_head_tracking: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeadTracking: *const fn (
            self: *const IAudioAmbisonicsControl,
            pb_enable_head_tracking: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: *const fn (
            self: *const IAudioAmbisonicsControl,
            x: f32,
            y: f32,
            z: f32,
            w: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setData(self: *const T, p_ambisonics_params_: [*]const AMBISONICS_PARAMS, cb_ambisonics_params_: u32) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetData(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), p_ambisonics_params_, cb_ambisonics_params_);
            }
            pub inline fn setHeadTracking(self: *const T, b_enable_head_tracking_: BOOL) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetHeadTracking(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), b_enable_head_tracking_);
            }
            pub inline fn getHeadTracking(self: *const T, pb_enable_head_tracking_: ?*BOOL) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).GetHeadTracking(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), pb_enable_head_tracking_);
            }
            pub inline fn setRotation(self: *const T, x_: f32, y_: f32, z_: f32, w_: f32) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), x_, y_, z_, w_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IChannelAudioVolume_Value = Guid.initString("1c158861-b533-4b30-b1cf-e853e51c59b8");
pub const IID_IChannelAudioVolume = &IID_IChannelAudioVolume_Value;
pub const IChannelAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: *const fn (
            self: *const IChannelAudioVolume,
            pdw_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolume: *const fn (
            self: *const IChannelAudioVolume,
            dw_index: u32,
            f_level: f32,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolume: *const fn (
            self: *const IChannelAudioVolume,
            dw_index: u32,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllVolumes: *const fn (
            self: *const IChannelAudioVolume,
            dw_count: u32,
            pf_volumes: [*]const f32,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVolumes: *const fn (
            self: *const IChannelAudioVolume,
            dw_count: u32,
            pf_volumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getChannelCount(self: *const T, pdw_count_: ?*u32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IChannelAudioVolume, @ptrCast(self)), pdw_count_);
            }
            pub inline fn setChannelVolume(self: *const T, dw_index_: u32, f_level_: f32, event_context_: ?*const Guid) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).SetChannelVolume(@as(*const IChannelAudioVolume, @ptrCast(self)), dw_index_, f_level_, event_context_);
            }
            pub inline fn getChannelVolume(self: *const T, dw_index_: u32, pf_level_: ?*f32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetChannelVolume(@as(*const IChannelAudioVolume, @ptrCast(self)), dw_index_, pf_level_);
            }
            pub inline fn setAllVolumes(self: *const T, dw_count_: u32, pf_volumes_: [*]const f32, event_context_: ?*const Guid) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).SetAllVolumes(@as(*const IChannelAudioVolume, @ptrCast(self)), dw_count_, pf_volumes_, event_context_);
            }
            pub inline fn getAllVolumes(self: *const T, dw_count_: u32, pf_volumes_: [*]f32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetAllVolumes(@as(*const IChannelAudioVolume, @ptrCast(self)), dw_count_, pf_volumes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioObjectType = enum(u32) {
    None = 0,
    Dynamic = 1,
    FrontLeft = 2,
    FrontRight = 4,
    FrontCenter = 8,
    LowFrequency = 16,
    SideLeft = 32,
    SideRight = 64,
    BackLeft = 128,
    BackRight = 256,
    TopFrontLeft = 512,
    TopFrontRight = 1024,
    TopBackLeft = 2048,
    TopBackRight = 4096,
    BottomFrontLeft = 8192,
    BottomFrontRight = 16384,
    BottomBackLeft = 32768,
    BottomBackRight = 65536,
    BackCenter = 131072,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Dynamic: u1 = 0,
        FrontLeft: u1 = 0,
        FrontRight: u1 = 0,
        FrontCenter: u1 = 0,
        LowFrequency: u1 = 0,
        SideLeft: u1 = 0,
        SideRight: u1 = 0,
        BackLeft: u1 = 0,
        BackRight: u1 = 0,
        TopFrontLeft: u1 = 0,
        TopFrontRight: u1 = 0,
        TopBackLeft: u1 = 0,
        TopBackRight: u1 = 0,
        BottomFrontLeft: u1 = 0,
        BottomFrontRight: u1 = 0,
        BottomBackLeft: u1 = 0,
        BottomBackRight: u1 = 0,
        BackCenter: u1 = 0,
    }) AudioObjectType {
        return @as(AudioObjectType, @enumFromInt((if (o.None == 1) @intFromEnum(AudioObjectType.None) else 0) | (if (o.Dynamic == 1) @intFromEnum(AudioObjectType.Dynamic) else 0) | (if (o.FrontLeft == 1) @intFromEnum(AudioObjectType.FrontLeft) else 0) | (if (o.FrontRight == 1) @intFromEnum(AudioObjectType.FrontRight) else 0) | (if (o.FrontCenter == 1) @intFromEnum(AudioObjectType.FrontCenter) else 0) | (if (o.LowFrequency == 1) @intFromEnum(AudioObjectType.LowFrequency) else 0) | (if (o.SideLeft == 1) @intFromEnum(AudioObjectType.SideLeft) else 0) | (if (o.SideRight == 1) @intFromEnum(AudioObjectType.SideRight) else 0) | (if (o.BackLeft == 1) @intFromEnum(AudioObjectType.BackLeft) else 0) | (if (o.BackRight == 1) @intFromEnum(AudioObjectType.BackRight) else 0) | (if (o.TopFrontLeft == 1) @intFromEnum(AudioObjectType.TopFrontLeft) else 0) | (if (o.TopFrontRight == 1) @intFromEnum(AudioObjectType.TopFrontRight) else 0) | (if (o.TopBackLeft == 1) @intFromEnum(AudioObjectType.TopBackLeft) else 0) | (if (o.TopBackRight == 1) @intFromEnum(AudioObjectType.TopBackRight) else 0) | (if (o.BottomFrontLeft == 1) @intFromEnum(AudioObjectType.BottomFrontLeft) else 0) | (if (o.BottomFrontRight == 1) @intFromEnum(AudioObjectType.BottomFrontRight) else 0) | (if (o.BottomBackLeft == 1) @intFromEnum(AudioObjectType.BottomBackLeft) else 0) | (if (o.BottomBackRight == 1) @intFromEnum(AudioObjectType.BottomBackRight) else 0) | (if (o.BackCenter == 1) @intFromEnum(AudioObjectType.BackCenter) else 0)));
    }
};
pub const AudioObjectType_None = AudioObjectType.None;
pub const AudioObjectType_Dynamic = AudioObjectType.Dynamic;
pub const AudioObjectType_FrontLeft = AudioObjectType.FrontLeft;
pub const AudioObjectType_FrontRight = AudioObjectType.FrontRight;
pub const AudioObjectType_FrontCenter = AudioObjectType.FrontCenter;
pub const AudioObjectType_LowFrequency = AudioObjectType.LowFrequency;
pub const AudioObjectType_SideLeft = AudioObjectType.SideLeft;
pub const AudioObjectType_SideRight = AudioObjectType.SideRight;
pub const AudioObjectType_BackLeft = AudioObjectType.BackLeft;
pub const AudioObjectType_BackRight = AudioObjectType.BackRight;
pub const AudioObjectType_TopFrontLeft = AudioObjectType.TopFrontLeft;
pub const AudioObjectType_TopFrontRight = AudioObjectType.TopFrontRight;
pub const AudioObjectType_TopBackLeft = AudioObjectType.TopBackLeft;
pub const AudioObjectType_TopBackRight = AudioObjectType.TopBackRight;
pub const AudioObjectType_BottomFrontLeft = AudioObjectType.BottomFrontLeft;
pub const AudioObjectType_BottomFrontRight = AudioObjectType.BottomFrontRight;
pub const AudioObjectType_BottomBackLeft = AudioObjectType.BottomBackLeft;
pub const AudioObjectType_BottomBackRight = AudioObjectType.BottomBackRight;
pub const AudioObjectType_BackCenter = AudioObjectType.BackCenter;

pub const SPATIAL_AUDIO_STREAM_OPTIONS = enum(u32) {
    NONE = 0,
    OFFLOAD = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        OFFLOAD: u1 = 0,
    }) SPATIAL_AUDIO_STREAM_OPTIONS {
        return @as(SPATIAL_AUDIO_STREAM_OPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(SPATIAL_AUDIO_STREAM_OPTIONS.NONE) else 0) | (if (o.OFFLOAD == 1) @intFromEnum(SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD) else 0)));
    }
};
pub const SPATIAL_AUDIO_STREAM_OPTIONS_NONE = SPATIAL_AUDIO_STREAM_OPTIONS.NONE;
pub const SPATIAL_AUDIO_STREAM_OPTIONS_OFFLOAD = SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD;

pub const SpatialAudioObjectRenderStreamActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
};

pub const SpatialAudioObjectRenderStreamActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

const IID_IAudioFormatEnumerator_Value = Guid.initString("dcdaa858-895a-4a22-a5eb-67bda506096d");
pub const IID_IAudioFormatEnumerator = &IID_IAudioFormatEnumerator_Value;
pub const IAudioFormatEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: *const fn (
            self: *const IAudioFormatEnumerator,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: *const fn (
            self: *const IAudioFormatEnumerator,
            index: u32,
            format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*u32) HRESULT {
                return @as(*const IAudioFormatEnumerator.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAudioFormatEnumerator, @ptrCast(self)), count_);
            }
            pub inline fn getFormat(self: *const T, index_: u32, format_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioFormatEnumerator.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioFormatEnumerator, @ptrCast(self)), index_, format_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectBase_Value = Guid.initString("cce0b8f2-8d4d-4efb-a8cf-3d6ecf1c30e0");
pub const IID_ISpatialAudioObjectBase = &IID_ISpatialAudioObjectBase_Value;
pub const ISpatialAudioObjectBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: *const fn (
            self: *const ISpatialAudioObjectBase,
            buffer: ?*?*u8,
            buffer_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEndOfStream: *const fn (
            self: *const ISpatialAudioObjectBase,
            frame_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsActive: *const fn (
            self: *const ISpatialAudioObjectBase,
            is_active: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioObjectType: *const fn (
            self: *const ISpatialAudioObjectBase,
            audio_object_type: ?*AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBuffer(self: *const T, buffer_: ?*?*u8, buffer_length_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), buffer_, buffer_length_);
            }
            pub inline fn setEndOfStream(self: *const T, frame_count_: u32) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).SetEndOfStream(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), frame_count_);
            }
            pub inline fn isActive(self: *const T, is_active_: ?*BOOL) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).IsActive(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), is_active_);
            }
            pub inline fn getAudioObjectType(self: *const T, audio_object_type_: ?*AudioObjectType) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).GetAudioObjectType(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), audio_object_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObject_Value = Guid.initString("dde28967-521b-46e5-8f00-bd6f2bc8ab1d");
pub const IID_ISpatialAudioObject = &IID_ISpatialAudioObject_Value;
pub const ISpatialAudioObject = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: *const fn (
            self: *const ISpatialAudioObject,
            x: f32,
            y: f32,
            z: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVolume: *const fn (
            self: *const ISpatialAudioObject,
            volume: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            pub inline fn setPosition(self: *const T, x_: f32, y_: f32, z_: f32) HRESULT {
                return @as(*const ISpatialAudioObject.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ISpatialAudioObject, @ptrCast(self)), x_, y_, z_);
            }
            pub inline fn setVolume(self: *const T, volume_: f32) HRESULT {
                return @as(*const ISpatialAudioObject.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const ISpatialAudioObject, @ptrCast(self)), volume_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamBase_Value = Guid.initString("feaaf403-c1d8-450d-aa05-e0ccee7502a8");
pub const IID_ISpatialAudioObjectRenderStreamBase = &IID_ISpatialAudioObjectRenderStreamBase_Value;
pub const ISpatialAudioObjectRenderStreamBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableDynamicObjectCount: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
            riid: ?*const Guid,
            service: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdatingAudioObjects: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
            available_dynamic_object_count: ?*u32,
            frame_count_per_buffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUpdatingAudioObjects: *const fn (
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAvailableDynamicObjectCount(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).GetAvailableDynamicObjectCount(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), value_);
            }
            pub inline fn getService(self: *const T, riid_: ?*const Guid, service_: ?*?*anyopaque) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).GetService(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), riid_, service_);
            }
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Start(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Stop(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            pub inline fn beginUpdatingAudioObjects(self: *const T, available_dynamic_object_count_: ?*u32, frame_count_per_buffer_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).BeginUpdatingAudioObjects(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), available_dynamic_object_count_, frame_count_per_buffer_);
            }
            pub inline fn endUpdatingAudioObjects(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).EndUpdatingAudioObjects(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStream_Value = Guid.initString("bab5f473-b423-477b-85f5-b5a332a04153");
pub const IID_ISpatialAudioObjectRenderStream = &IID_ISpatialAudioObjectRenderStream_Value;
pub const ISpatialAudioObjectRenderStream = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObject: *const fn (
            self: *const ISpatialAudioObjectRenderStream,
            type: AudioObjectType,
            audio_object: ?*?*ISpatialAudioObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            pub inline fn activateSpatialAudioObject(self: *const T, type_: AudioObjectType, audio_object_: ?*?*ISpatialAudioObject) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStream.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObject(@as(*const ISpatialAudioObjectRenderStream, @ptrCast(self)), type_, audio_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamNotify_Value = Guid.initString("dddf83e6-68d7-4c70-883f-a1836afb4a50");
pub const IID_ISpatialAudioObjectRenderStreamNotify = &IID_ISpatialAudioObjectRenderStreamNotify_Value;
pub const ISpatialAudioObjectRenderStreamNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAvailableDynamicObjectCountChange: *const fn (
            self: *const ISpatialAudioObjectRenderStreamNotify,
            sender: ?*ISpatialAudioObjectRenderStreamBase,
            hns_compliance_deadline_time: i64,
            available_dynamic_object_count_change: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onAvailableDynamicObjectCountChange(self: *const T, sender_: ?*ISpatialAudioObjectRenderStreamBase, hns_compliance_deadline_time_: i64, available_dynamic_object_count_change_: u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamNotify.VTable, @ptrCast(self.vtable)).OnAvailableDynamicObjectCountChange(@as(*const ISpatialAudioObjectRenderStreamNotify, @ptrCast(self)), sender_, hns_compliance_deadline_time_, available_dynamic_object_count_change_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioClient_Value = Guid.initString("bbf8e066-aaaa-49be-9a4d-fd2a858ea27f");
pub const IID_ISpatialAudioClient = &IID_ISpatialAudioClient_Value;
pub const ISpatialAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStaticObjectPosition: *const fn (
            self: *const ISpatialAudioClient,
            type: AudioObjectType,
            x: ?*f32,
            y: ?*f32,
            z: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeStaticObjectTypeMask: *const fn (
            self: *const ISpatialAudioClient,
            mask: ?*AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxDynamicObjectCount: *const fn (
            self: *const ISpatialAudioClient,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedAudioObjectFormatEnumerator: *const fn (
            self: *const ISpatialAudioClient,
            enumerator: ?*?*IAudioFormatEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxFrameCount: *const fn (
            self: *const ISpatialAudioClient,
            object_format: ?*const WAVEFORMATEX,
            frame_count_per_buffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioObjectFormatSupported: *const fn (
            self: *const ISpatialAudioClient,
            object_format: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSpatialAudioStreamAvailable: *const fn (
            self: *const ISpatialAudioClient,
            stream_uuid: ?*const Guid,
            auxiliary_info: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioStream: *const fn (
            self: *const ISpatialAudioClient,
            activation_params: ?*const PROPVARIANT,
            riid: ?*const Guid,
            stream: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStaticObjectPosition(self: *const T, type_: AudioObjectType, x_: ?*f32, y_: ?*f32, z_: ?*f32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetStaticObjectPosition(@as(*const ISpatialAudioClient, @ptrCast(self)), type_, x_, y_, z_);
            }
            pub inline fn getNativeStaticObjectTypeMask(self: *const T, mask_: ?*AudioObjectType) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetNativeStaticObjectTypeMask(@as(*const ISpatialAudioClient, @ptrCast(self)), mask_);
            }
            pub inline fn getMaxDynamicObjectCount(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetMaxDynamicObjectCount(@as(*const ISpatialAudioClient, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedAudioObjectFormatEnumerator(self: *const T, enumerator_: ?*?*IAudioFormatEnumerator) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetSupportedAudioObjectFormatEnumerator(@as(*const ISpatialAudioClient, @ptrCast(self)), enumerator_);
            }
            pub inline fn getMaxFrameCount(self: *const T, object_format_: ?*const WAVEFORMATEX, frame_count_per_buffer_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetMaxFrameCount(@as(*const ISpatialAudioClient, @ptrCast(self)), object_format_, frame_count_per_buffer_);
            }
            pub inline fn isAudioObjectFormatSupported(self: *const T, object_format_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).IsAudioObjectFormatSupported(@as(*const ISpatialAudioClient, @ptrCast(self)), object_format_);
            }
            pub inline fn isSpatialAudioStreamAvailable(self: *const T, stream_uuid_: ?*const Guid, auxiliary_info_: ?*const PROPVARIANT) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).IsSpatialAudioStreamAvailable(@as(*const ISpatialAudioClient, @ptrCast(self)), stream_uuid_, auxiliary_info_);
            }
            pub inline fn activateSpatialAudioStream(self: *const T, activation_params_: ?*const PROPVARIANT, riid_: ?*const Guid, stream_: ?*?*anyopaque) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioStream(@as(*const ISpatialAudioClient, @ptrCast(self)), activation_params_, riid_, stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpatialAudioClient2_Value = Guid.initString("caabe452-a66a-4bee-a93e-e320463f6a53");
pub const IID_ISpatialAudioClient2 = &IID_ISpatialAudioClient2_Value;
pub const ISpatialAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioClient.VTable,
        IsOffloadCapable: *const fn (
            self: *const ISpatialAudioClient2,
            category: AUDIO_STREAM_CATEGORY,
            is_offload_capable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxFrameCountForCategory: *const fn (
            self: *const ISpatialAudioClient2,
            category: AUDIO_STREAM_CATEGORY,
            offload_enabled: BOOL,
            object_format: ?*const WAVEFORMATEX,
            frame_count_per_buffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioClient.MethodMixin(T);
            pub inline fn isOffloadCapable(self: *const T, category_: AUDIO_STREAM_CATEGORY, is_offload_capable_: ?*BOOL) HRESULT {
                return @as(*const ISpatialAudioClient2.VTable, @ptrCast(self.vtable)).IsOffloadCapable(@as(*const ISpatialAudioClient2, @ptrCast(self)), category_, is_offload_capable_);
            }
            pub inline fn getMaxFrameCountForCategory(self: *const T, category_: AUDIO_STREAM_CATEGORY, offload_enabled_: BOOL, object_format_: ?*const WAVEFORMATEX, frame_count_per_buffer_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient2.VTable, @ptrCast(self.vtable)).GetMaxFrameCountForCategory(@as(*const ISpatialAudioClient2, @ptrCast(self)), category_, offload_enabled_, object_format_, frame_count_per_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioClientActivationParams = extern struct {
    tracingContextId: Guid,
    appId: Guid,
    majorVersion: i32,
    minorVersion1: i32,
    minorVersion2: i32,
    minorVersion3: i32,
};

pub const SpatialAudioHrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const SpatialAudioHrtfDirectivity_OmniDirectional = SpatialAudioHrtfDirectivityType.OmniDirectional;
pub const SpatialAudioHrtfDirectivity_Cardioid = SpatialAudioHrtfDirectivityType.Cardioid;
pub const SpatialAudioHrtfDirectivity_Cone = SpatialAudioHrtfDirectivityType.Cone;

pub const SpatialAudioHrtfEnvironmentType = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
    Average = 4,
};
pub const SpatialAudioHrtfEnvironment_Small = SpatialAudioHrtfEnvironmentType.Small;
pub const SpatialAudioHrtfEnvironment_Medium = SpatialAudioHrtfEnvironmentType.Medium;
pub const SpatialAudioHrtfEnvironment_Large = SpatialAudioHrtfEnvironmentType.Large;
pub const SpatialAudioHrtfEnvironment_Outdoors = SpatialAudioHrtfEnvironmentType.Outdoors;
pub const SpatialAudioHrtfEnvironment_Average = SpatialAudioHrtfEnvironmentType.Average;

pub const SpatialAudioHrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const SpatialAudioHrtfDistanceDecay_NaturalDecay = SpatialAudioHrtfDistanceDecayType.NaturalDecay;
pub const SpatialAudioHrtfDistanceDecay_CustomDecay = SpatialAudioHrtfDistanceDecayType.CustomDecay;

pub const SpatialAudioHrtfDirectivity = extern struct {
    Type: SpatialAudioHrtfDirectivityType align(1),
    Scaling: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityCardioid = extern struct {
    directivity: SpatialAudioHrtfDirectivity align(1),
    Order: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityCone = extern struct {
    directivity: SpatialAudioHrtfDirectivity align(1),
    InnerAngle: f32 align(1),
    OuterAngle: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityUnion = extern union {
    Cone: SpatialAudioHrtfDirectivityCone,
    Cardiod: SpatialAudioHrtfDirectivityCardioid,
    Omni: SpatialAudioHrtfDirectivity,
};

pub const SpatialAudioHrtfDistanceDecay = extern struct {
    Type: SpatialAudioHrtfDistanceDecayType align(1),
    MaxGain: f32 align(1),
    MinGain: f32 align(1),
    UnityGainDistance: f32 align(1),
    CutoffDistance: f32 align(1),
};

pub const SpatialAudioHrtfActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay align(1),
    Directivity: ?*SpatialAudioHrtfDirectivityUnion align(1),
    Environment: ?*SpatialAudioHrtfEnvironmentType align(1),
    Orientation: ?*f32 align(1),
};

pub const SpatialAudioHrtfActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay align(1),
    Directivity: ?*SpatialAudioHrtfDirectivityUnion align(1),
    Environment: ?*SpatialAudioHrtfEnvironmentType align(1),
    Orientation: ?*f32 align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForHrtf_Value = Guid.initString("d7436ade-1978-4e14-aba0-555bd8eb83b4");
pub const IID_ISpatialAudioObjectForHrtf = &IID_ISpatialAudioObjectForHrtf_Value;
pub const ISpatialAudioObjectForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            x: f32,
            y: f32,
            z: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGain: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            gain: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOrientation: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            orientation: ?*const ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironment: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            environment: SpatialAudioHrtfEnvironmentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDistanceDecay: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            distance_decay: ?*SpatialAudioHrtfDistanceDecay,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectivity: *const fn (
            self: *const ISpatialAudioObjectForHrtf,
            directivity: ?*SpatialAudioHrtfDirectivityUnion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            pub inline fn setPosition(self: *const T, x_: f32, y_: f32, z_: f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), x_, y_, z_);
            }
            pub inline fn setGain(self: *const T, gain_: f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetGain(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), gain_);
            }
            pub inline fn setOrientation(self: *const T, orientation_: ?*const ?*f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetOrientation(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), orientation_);
            }
            pub inline fn setEnvironment(self: *const T, environment_: SpatialAudioHrtfEnvironmentType) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetEnvironment(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), environment_);
            }
            pub inline fn setDistanceDecay(self: *const T, distance_decay_: ?*SpatialAudioHrtfDistanceDecay) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetDistanceDecay(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), distance_decay_);
            }
            pub inline fn setDirectivity(self: *const T, directivity_: ?*SpatialAudioHrtfDirectivityUnion) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetDirectivity(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), directivity_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForHrtf_Value = Guid.initString("e08deef9-5363-406e-9fdc-080ee247bbe0");
pub const IID_ISpatialAudioObjectRenderStreamForHrtf = &IID_ISpatialAudioObjectRenderStreamForHrtf_Value;
pub const ISpatialAudioObjectRenderStreamForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForHrtf: *const fn (
            self: *const ISpatialAudioObjectRenderStreamForHrtf,
            type: AudioObjectType,
            audio_object: ?*?*ISpatialAudioObjectForHrtf,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            pub inline fn activateSpatialAudioObjectForHrtf(self: *const T, type_: AudioObjectType, audio_object_: ?*?*ISpatialAudioObjectForHrtf) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForHrtf.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForHrtf(@as(*const ISpatialAudioObjectRenderStreamForHrtf, @ptrCast(self)), type_, audio_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MMDeviceEnumerator_Value = Guid.initString("bcde0395-e52f-467c-8e3d-c4579291692e");
pub const CLSID_MMDeviceEnumerator = &CLSID_MMDeviceEnumerator_Value;

pub const DIRECTX_AUDIO_ACTIVATION_PARAMS = extern struct {
    cbDirectXAudioActivationParams: u32,
    guidAudioSession: Guid,
    dwAudioStreamFlags: u32,
};

pub const EDataFlow = enum(i32) {
    eRender = 0,
    eCapture = 1,
    eAll = 2,
    EDataFlow_enum_count = 3,
};
pub const eRender = EDataFlow.eRender;
pub const eCapture = EDataFlow.eCapture;
pub const eAll = EDataFlow.eAll;
pub const EDataFlow_enum_count = EDataFlow.EDataFlow_enum_count;

pub const ERole = enum(i32) {
    eConsole = 0,
    eMultimedia = 1,
    eCommunications = 2,
    ERole_enum_count = 3,
};
pub const eConsole = ERole.eConsole;
pub const eMultimedia = ERole.eMultimedia;
pub const eCommunications = ERole.eCommunications;
pub const ERole_enum_count = ERole.ERole_enum_count;

pub const EndpointFormFactor = enum(i32) {
    RemoteNetworkDevice = 0,
    Speakers = 1,
    LineLevel = 2,
    Headphones = 3,
    Microphone = 4,
    Headset = 5,
    Handset = 6,
    UnknownDigitalPassthrough = 7,
    SPDIF = 8,
    DigitalAudioDisplayDevice = 9,
    UnknownFormFactor = 10,
    EndpointFormFactor_enum_count = 11,
};
pub const RemoteNetworkDevice = EndpointFormFactor.RemoteNetworkDevice;
pub const Speakers = EndpointFormFactor.Speakers;
pub const LineLevel = EndpointFormFactor.LineLevel;
pub const Headphones = EndpointFormFactor.Headphones;
pub const Microphone = EndpointFormFactor.Microphone;
pub const Headset = EndpointFormFactor.Headset;
pub const Handset = EndpointFormFactor.Handset;
pub const UnknownDigitalPassthrough = EndpointFormFactor.UnknownDigitalPassthrough;
pub const SPDIF = EndpointFormFactor.SPDIF;
pub const DigitalAudioDisplayDevice = EndpointFormFactor.DigitalAudioDisplayDevice;
pub const UnknownFormFactor = EndpointFormFactor.UnknownFormFactor;
pub const EndpointFormFactor_enum_count = EndpointFormFactor.EndpointFormFactor_enum_count;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMNotificationClient_Value = Guid.initString("7991eec9-7e89-4d85-8390-6c703cec60c0");
pub const IID_IMMNotificationClient = &IID_IMMNotificationClient_Value;
pub const IMMNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDeviceStateChanged: *const fn (
            self: *const IMMNotificationClient,
            pwstr_device_id: ?[*:0]const u16,
            dw_new_state: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeviceAdded: *const fn (
            self: *const IMMNotificationClient,
            pwstr_device_id: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeviceRemoved: *const fn (
            self: *const IMMNotificationClient,
            pwstr_device_id: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefaultDeviceChanged: *const fn (
            self: *const IMMNotificationClient,
            flow: EDataFlow,
            role: ERole,
            pwstr_default_device_id: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPropertyValueChanged: *const fn (
            self: *const IMMNotificationClient,
            pwstr_device_id: ?[*:0]const u16,
            key: PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onDeviceStateChanged(self: *const T, pwstr_device_id_: ?[*:0]const u16, dw_new_state_: u32) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceStateChanged(@as(*const IMMNotificationClient, @ptrCast(self)), pwstr_device_id_, dw_new_state_);
            }
            pub inline fn onDeviceAdded(self: *const T, pwstr_device_id_: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceAdded(@as(*const IMMNotificationClient, @ptrCast(self)), pwstr_device_id_);
            }
            pub inline fn onDeviceRemoved(self: *const T, pwstr_device_id_: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceRemoved(@as(*const IMMNotificationClient, @ptrCast(self)), pwstr_device_id_);
            }
            pub inline fn onDefaultDeviceChanged(self: *const T, flow_: EDataFlow, role_: ERole, pwstr_default_device_id_: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDefaultDeviceChanged(@as(*const IMMNotificationClient, @ptrCast(self)), flow_, role_, pwstr_default_device_id_);
            }
            pub inline fn onPropertyValueChanged(self: *const T, pwstr_device_id_: ?[*:0]const u16, key_: PROPERTYKEY) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnPropertyValueChanged(@as(*const IMMNotificationClient, @ptrCast(self)), pwstr_device_id_, key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDevice_Value = Guid.initString("d666063f-1587-4e43-81f1-b948e807363f");
pub const IID_IMMDevice = &IID_IMMDevice_Value;
pub const IMMDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: *const fn (
            self: *const IMMDevice,
            iid: ?*const Guid,
            dw_cls_ctx: CLSCTX,
            p_activation_params: ?*PROPVARIANT,
            pp_interface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenPropertyStore: *const fn (
            self: *const IMMDevice,
            stgm_access: STGM,
            pp_properties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetId: *const fn (
            self: *const IMMDevice,
            ppstr_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IMMDevice,
            pdw_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activate(self: *const T, iid_: ?*const Guid, dw_cls_ctx_: CLSCTX, p_activation_params_: ?*PROPVARIANT, pp_interface_: ?*?*anyopaque) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMMDevice, @ptrCast(self)), iid_, dw_cls_ctx_, p_activation_params_, pp_interface_);
            }
            pub inline fn openPropertyStore(self: *const T, stgm_access_: STGM, pp_properties_: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).OpenPropertyStore(@as(*const IMMDevice, @ptrCast(self)), stgm_access_, pp_properties_);
            }
            pub inline fn getId(self: *const T, ppstr_id_: ?*?PWSTR) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).GetId(@as(*const IMMDevice, @ptrCast(self)), ppstr_id_);
            }
            pub inline fn getState(self: *const T, pdw_state_: ?*u32) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMMDevice, @ptrCast(self)), pdw_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceCollection_Value = Guid.initString("0bd7a1be-7a1a-44db-8397-cc5392387b5e");
pub const IID_IMMDeviceCollection = &IID_IMMDeviceCollection_Value;
pub const IMMDeviceCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: *const fn (
            self: *const IMMDeviceCollection,
            pc_devices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const IMMDeviceCollection,
            n_device: u32,
            pp_device: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCount(self: *const T, pc_devices_: ?*u32) HRESULT {
                return @as(*const IMMDeviceCollection.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IMMDeviceCollection, @ptrCast(self)), pc_devices_);
            }
            pub inline fn item(self: *const T, n_device_: u32, pp_device_: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceCollection.VTable, @ptrCast(self.vtable)).Item(@as(*const IMMDeviceCollection, @ptrCast(self)), n_device_, pp_device_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMEndpoint_Value = Guid.initString("1be09788-6894-4089-8586-9a2a6c265ac5");
pub const IID_IMMEndpoint = &IID_IMMEndpoint_Value;
pub const IMMEndpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataFlow: *const fn (
            self: *const IMMEndpoint,
            p_data_flow: ?*EDataFlow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDataFlow(self: *const T, p_data_flow_: ?*EDataFlow) HRESULT {
                return @as(*const IMMEndpoint.VTable, @ptrCast(self.vtable)).GetDataFlow(@as(*const IMMEndpoint, @ptrCast(self)), p_data_flow_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceEnumerator_Value = Guid.initString("a95664d2-9614-4f35-a746-de8db63617e6");
pub const IID_IMMDeviceEnumerator = &IID_IMMDeviceEnumerator_Value;
pub const IMMDeviceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumAudioEndpoints: *const fn (
            self: *const IMMDeviceEnumerator,
            data_flow: EDataFlow,
            dw_state_mask: u32,
            pp_devices: ?*?*IMMDeviceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAudioEndpoint: *const fn (
            self: *const IMMDeviceEnumerator,
            data_flow: EDataFlow,
            role: ERole,
            pp_endpoint: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevice: *const fn (
            self: *const IMMDeviceEnumerator,
            pwstr_id: ?[*:0]const u16,
            pp_device: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterEndpointNotificationCallback: *const fn (
            self: *const IMMDeviceEnumerator,
            p_client: ?*IMMNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterEndpointNotificationCallback: *const fn (
            self: *const IMMDeviceEnumerator,
            p_client: ?*IMMNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enumAudioEndpoints(self: *const T, data_flow_: EDataFlow, dw_state_mask_: u32, pp_devices_: ?*?*IMMDeviceCollection) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).EnumAudioEndpoints(@as(*const IMMDeviceEnumerator, @ptrCast(self)), data_flow_, dw_state_mask_, pp_devices_);
            }
            pub inline fn getDefaultAudioEndpoint(self: *const T, data_flow_: EDataFlow, role_: ERole, pp_endpoint_: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).GetDefaultAudioEndpoint(@as(*const IMMDeviceEnumerator, @ptrCast(self)), data_flow_, role_, pp_endpoint_);
            }
            pub inline fn getDevice(self: *const T, pwstr_id_: ?[*:0]const u16, pp_device_: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IMMDeviceEnumerator, @ptrCast(self)), pwstr_id_, pp_device_);
            }
            pub inline fn registerEndpointNotificationCallback(self: *const T, p_client_: ?*IMMNotificationClient) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).RegisterEndpointNotificationCallback(@as(*const IMMDeviceEnumerator, @ptrCast(self)), p_client_);
            }
            pub inline fn unregisterEndpointNotificationCallback(self: *const T, p_client_: ?*IMMNotificationClient) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).UnregisterEndpointNotificationCallback(@as(*const IMMDeviceEnumerator, @ptrCast(self)), p_client_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMMDeviceActivator_Value = Guid.initString("3b0d0ea4-d0a9-4b0e-935b-09516746fac0");
pub const IID_IMMDeviceActivator = &IID_IMMDeviceActivator_Value;
pub const IMMDeviceActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: *const fn (
            self: *const IMMDeviceActivator,
            iid: ?*const Guid,
            p_device: ?*IMMDevice,
            p_activation_params: ?*PROPVARIANT,
            pp_interface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activate(self: *const T, iid_: ?*const Guid, p_device_: ?*IMMDevice, p_activation_params_: ?*PROPVARIANT, pp_interface_: ?*?*anyopaque) HRESULT {
                return @as(*const IMMDeviceActivator.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMMDeviceActivator, @ptrCast(self)), iid_, p_device_, p_activation_params_, pp_interface_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceCompletionHandler_Value = Guid.initString("41d949ab-9862-444a-80f6-c261334da5eb");
pub const IID_IActivateAudioInterfaceCompletionHandler = &IID_IActivateAudioInterfaceCompletionHandler_Value;
pub const IActivateAudioInterfaceCompletionHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateCompleted: *const fn (
            self: *const IActivateAudioInterfaceCompletionHandler,
            activate_operation: ?*IActivateAudioInterfaceAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activateCompleted(self: *const T, activate_operation_: ?*IActivateAudioInterfaceAsyncOperation) HRESULT {
                return @as(*const IActivateAudioInterfaceCompletionHandler.VTable, @ptrCast(self.vtable)).ActivateCompleted(@as(*const IActivateAudioInterfaceCompletionHandler, @ptrCast(self)), activate_operation_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceAsyncOperation_Value = Guid.initString("72a22d78-cde4-431d-b8cc-843a71199b6d");
pub const IID_IActivateAudioInterfaceAsyncOperation = &IID_IActivateAudioInterfaceAsyncOperation_Value;
pub const IActivateAudioInterfaceAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActivateResult: *const fn (
            self: *const IActivateAudioInterfaceAsyncOperation,
            activate_result: ?*HRESULT,
            activated_interface: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getActivateResult(self: *const T, activate_result_: ?*HRESULT, activated_interface_: ?*?*IUnknown) HRESULT {
                return @as(*const IActivateAudioInterfaceAsyncOperation.VTable, @ptrCast(self.vtable)).GetActivateResult(@as(*const IActivateAudioInterfaceAsyncOperation, @ptrCast(self)), activate_result_, activated_interface_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioExtensionParams = extern struct {
    AddPageParam: LPARAM,
    pEndpoint: ?*IMMDevice,
    pPnpInterface: ?*IMMDevice,
    pPnpDevnode: ?*IMMDevice,
};

pub const __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 = enum(i32) {
    DEFAULT = 0,
    USER = 1,
    VOLATILE = 2,
    ENUM_COUNT = 3,
};
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_DEFAULT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.DEFAULT;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_USER = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.USER;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_VOLATILE = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.VOLATILE;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_ENUM_COUNT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.ENUM_COUNT;

const IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value = Guid.initString("20049d40-56d5-400e-a2ef-385599feed49");
pub const IID_IAudioSystemEffectsPropertyChangeNotificationClient = &IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value;
pub const IAudioSystemEffectsPropertyChangeNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPropertyChanged: *const fn (
            self: *const IAudioSystemEffectsPropertyChangeNotificationClient,
            type: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
            key: PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onPropertyChanged(self: *const T, type_: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002, key_: PROPERTYKEY) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyChangeNotificationClient.VTable, @ptrCast(self.vtable)).OnPropertyChanged(@as(*const IAudioSystemEffectsPropertyChangeNotificationClient, @ptrCast(self)), type_, key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffectsPropertyStore_Value = Guid.initString("302ae7f9-d7e0-43e4-971b-1f8293613d2a");
pub const IID_IAudioSystemEffectsPropertyStore = &IID_IAudioSystemEffectsPropertyStore_Value;
pub const IAudioSystemEffectsPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDefaultPropertyStore: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
            stgm_access: u32,
            prop_store: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenUserPropertyStore: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
            stgm_access: u32,
            prop_store: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenVolatilePropertyStore: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
            stgm_access: u32,
            prop_store: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetUserPropertyStore: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetVolatilePropertyStore: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPropertyChangeNotification: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
            callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterPropertyChangeNotification: *const fn (
            self: *const IAudioSystemEffectsPropertyStore,
            callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn openDefaultPropertyStore(self: *const T, stgm_access_: u32, prop_store_: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenDefaultPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgm_access_, prop_store_);
            }
            pub inline fn openUserPropertyStore(self: *const T, stgm_access_: u32, prop_store_: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenUserPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgm_access_, prop_store_);
            }
            pub inline fn openVolatilePropertyStore(self: *const T, stgm_access_: u32, prop_store_: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenVolatilePropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgm_access_, prop_store_);
            }
            pub inline fn resetUserPropertyStore(self: *const T) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).ResetUserPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)));
            }
            pub inline fn resetVolatilePropertyStore(self: *const T) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).ResetVolatilePropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)));
            }
            pub inline fn registerPropertyChangeNotification(self: *const T, callback_: ?*IAudioSystemEffectsPropertyChangeNotificationClient) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).RegisterPropertyChangeNotification(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), callback_);
            }
            pub inline fn unregisterPropertyChangeNotification(self: *const T, callback_: ?*IAudioSystemEffectsPropertyChangeNotificationClient) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).UnregisterPropertyChangeNotification(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), callback_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DeviceTopology_Value = Guid.initString("1df639d0-5ec1-47aa-9379-828dc1aa8c59");
pub const CLSID_DeviceTopology = &CLSID_DeviceTopology_Value;

pub const DataFlow = enum(i32) {
    In = 0,
    Out = 1,
};
pub const In = DataFlow.In;
pub const Out = DataFlow.Out;

pub const PartType = enum(i32) {
    Connector = 0,
    Subunit = 1,
};
pub const Connector = PartType.Connector;
pub const Subunit = PartType.Subunit;

pub const ConnectorType = enum(i32) {
    Unknown_Connector = 0,
    Physical_Internal = 1,
    Physical_External = 2,
    Software_IO = 3,
    Software_Fixed = 4,
    Network = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPerChannelDbLevel_Value = Guid.initString("c2f8e001-f205-4bc9-99bc-c13b1e048ccb");
pub const IID_IPerChannelDbLevel = &IID_IPerChannelDbLevel_Value;
pub const IPerChannelDbLevel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: *const fn (
            self: *const IPerChannelDbLevel,
            pc_channels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevelRange: *const fn (
            self: *const IPerChannelDbLevel,
            n_channel: u32,
            pf_min_level_d_b: ?*f32,
            pf_max_level_d_b: ?*f32,
            pf_stepping: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevel: *const fn (
            self: *const IPerChannelDbLevel,
            n_channel: u32,
            pf_level_d_b: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevel: *const fn (
            self: *const IPerChannelDbLevel,
            n_channel: u32,
            f_level_d_b: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevelUniform: *const fn (
            self: *const IPerChannelDbLevel,
            f_level_d_b: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevelAllChannels: *const fn (
            self: *const IPerChannelDbLevel,
            a_levels_d_b: [*]f32,
            c_channels: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getChannelCount(self: *const T, pc_channels_: ?*u32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IPerChannelDbLevel, @ptrCast(self)), pc_channels_);
            }
            pub inline fn getLevelRange(self: *const T, n_channel_: u32, pf_min_level_d_b_: ?*f32, pf_max_level_d_b_: ?*f32, pf_stepping_: ?*f32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetLevelRange(@as(*const IPerChannelDbLevel, @ptrCast(self)), n_channel_, pf_min_level_d_b_, pf_max_level_d_b_, pf_stepping_);
            }
            pub inline fn getLevel(self: *const T, n_channel_: u32, pf_level_d_b_: ?*f32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetLevel(@as(*const IPerChannelDbLevel, @ptrCast(self)), n_channel_, pf_level_d_b_);
            }
            pub inline fn setLevel(self: *const T, n_channel_: u32, f_level_d_b_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevel(@as(*const IPerChannelDbLevel, @ptrCast(self)), n_channel_, f_level_d_b_, pguid_event_context_);
            }
            pub inline fn setLevelUniform(self: *const T, f_level_d_b_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevelUniform(@as(*const IPerChannelDbLevel, @ptrCast(self)), f_level_d_b_, pguid_event_context_);
            }
            pub inline fn setLevelAllChannels(self: *const T, a_levels_d_b_: [*]f32, c_channels_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevelAllChannels(@as(*const IPerChannelDbLevel, @ptrCast(self)), a_levels_d_b_, c_channels_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioVolumeLevel_Value = Guid.initString("7fb7b48f-531d-44a2-bcb3-5ad5a134b3dc");
pub const IID_IAudioVolumeLevel = &IID_IAudioVolumeLevel_Value;
pub const IAudioVolumeLevel = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioChannelConfig_Value = Guid.initString("bb11c46f-ec28-493c-b88a-5db88062ce98");
pub const IID_IAudioChannelConfig = &IID_IAudioChannelConfig_Value;
pub const IAudioChannelConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetChannelConfig: *const fn (
            self: *const IAudioChannelConfig,
            dw_config: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelConfig: *const fn (
            self: *const IAudioChannelConfig,
            pdw_config: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setChannelConfig(self: *const T, dw_config_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioChannelConfig.VTable, @ptrCast(self.vtable)).SetChannelConfig(@as(*const IAudioChannelConfig, @ptrCast(self)), dw_config_, pguid_event_context_);
            }
            pub inline fn getChannelConfig(self: *const T, pdw_config_: ?*u32) HRESULT {
                return @as(*const IAudioChannelConfig.VTable, @ptrCast(self.vtable)).GetChannelConfig(@as(*const IAudioChannelConfig, @ptrCast(self)), pdw_config_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioLoudness_Value = Guid.initString("7d8b1437-dd53-4350-9c1b-1ee2890bd938");
pub const IID_IAudioLoudness = &IID_IAudioLoudness_Value;
pub const IAudioLoudness = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: *const fn (
            self: *const IAudioLoudness,
            pb_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: *const fn (
            self: *const IAudioLoudness,
            b_enable: BOOL,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEnabled(self: *const T, pb_enabled_: ?*BOOL) HRESULT {
                return @as(*const IAudioLoudness.VTable, @ptrCast(self.vtable)).GetEnabled(@as(*const IAudioLoudness, @ptrCast(self)), pb_enabled_);
            }
            pub inline fn setEnabled(self: *const T, b_enable_: BOOL, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioLoudness.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IAudioLoudness, @ptrCast(self)), b_enable_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioInputSelector_Value = Guid.initString("4f03dc02-5e6e-4653-8f72-a030c123d598");
pub const IID_IAudioInputSelector = &IID_IAudioInputSelector_Value;
pub const IAudioInputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: *const fn (
            self: *const IAudioInputSelector,
            pn_id_selected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const IAudioInputSelector,
            n_id_select: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSelection(self: *const T, pn_id_selected_: ?*u32) HRESULT {
                return @as(*const IAudioInputSelector.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IAudioInputSelector, @ptrCast(self)), pn_id_selected_);
            }
            pub inline fn setSelection(self: *const T, n_id_select_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioInputSelector.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const IAudioInputSelector, @ptrCast(self)), n_id_select_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioOutputSelector_Value = Guid.initString("bb515f69-94a7-429e-8b9c-271b3f11a3ab");
pub const IID_IAudioOutputSelector = &IID_IAudioOutputSelector_Value;
pub const IAudioOutputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: *const fn (
            self: *const IAudioOutputSelector,
            pn_id_selected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: *const fn (
            self: *const IAudioOutputSelector,
            n_id_select: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSelection(self: *const T, pn_id_selected_: ?*u32) HRESULT {
                return @as(*const IAudioOutputSelector.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IAudioOutputSelector, @ptrCast(self)), pn_id_selected_);
            }
            pub inline fn setSelection(self: *const T, n_id_select_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioOutputSelector.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const IAudioOutputSelector, @ptrCast(self)), n_id_select_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMute_Value = Guid.initString("df45aeea-b74a-4b6b-afad-2366b6aa012e");
pub const IID_IAudioMute = &IID_IAudioMute_Value;
pub const IAudioMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: *const fn (
            self: *const IAudioMute,
            b_muted: BOOL,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: *const fn (
            self: *const IAudioMute,
            pb_muted: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMute(self: *const T, b_muted_: BOOL, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioMute.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioMute, @ptrCast(self)), b_muted_, pguid_event_context_);
            }
            pub inline fn getMute(self: *const T, pb_muted_: ?*BOOL) HRESULT {
                return @as(*const IAudioMute.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioMute, @ptrCast(self)), pb_muted_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioBass_Value = Guid.initString("a2b1a1d9-4db3-425d-a2b2-bd335cb3e2e5");
pub const IID_IAudioBass = &IID_IAudioBass_Value;
pub const IAudioBass = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMidrange_Value = Guid.initString("5e54b6d7-b44b-40d9-9a9e-e691d9ce6edf");
pub const IID_IAudioMidrange = &IID_IAudioMidrange_Value;
pub const IAudioMidrange = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioTreble_Value = Guid.initString("0a717812-694e-4907-b74b-bafa5cfdca7b");
pub const IID_IAudioTreble = &IID_IAudioTreble_Value;
pub const IAudioTreble = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioAutoGainControl_Value = Guid.initString("85401fd4-6de4-4b9d-9869-2d6753a82f3c");
pub const IID_IAudioAutoGainControl = &IID_IAudioAutoGainControl_Value;
pub const IAudioAutoGainControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: *const fn (
            self: *const IAudioAutoGainControl,
            pb_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: *const fn (
            self: *const IAudioAutoGainControl,
            b_enable: BOOL,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEnabled(self: *const T, pb_enabled_: ?*BOOL) HRESULT {
                return @as(*const IAudioAutoGainControl.VTable, @ptrCast(self.vtable)).GetEnabled(@as(*const IAudioAutoGainControl, @ptrCast(self)), pb_enabled_);
            }
            pub inline fn setEnabled(self: *const T, b_enable_: BOOL, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioAutoGainControl.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IAudioAutoGainControl, @ptrCast(self)), b_enable_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioPeakMeter_Value = Guid.initString("dd79923c-0599-45e0-b8b6-c8df7db6e796");
pub const IID_IAudioPeakMeter = &IID_IAudioPeakMeter_Value;
pub const IAudioPeakMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: *const fn (
            self: *const IAudioPeakMeter,
            pc_channels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevel: *const fn (
            self: *const IAudioPeakMeter,
            n_channel: u32,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getChannelCount(self: *const T, pc_channels_: ?*u32) HRESULT {
                return @as(*const IAudioPeakMeter.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioPeakMeter, @ptrCast(self)), pc_channels_);
            }
            pub inline fn getLevel(self: *const T, n_channel_: u32, pf_level_: ?*f32) HRESULT {
                return @as(*const IAudioPeakMeter.VTable, @ptrCast(self.vtable)).GetLevel(@as(*const IAudioPeakMeter, @ptrCast(self)), n_channel_, pf_level_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceSpecificProperty_Value = Guid.initString("3b22bcbf-2586-4af0-8583-205d391b807c");
pub const IID_IDeviceSpecificProperty = &IID_IDeviceSpecificProperty_Value;
pub const IDeviceSpecificProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: *const fn (
            self: *const IDeviceSpecificProperty,
            p_v_type: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: *const fn (
            self: *const IDeviceSpecificProperty,
            pv_value: ?*anyopaque,
            pcb_value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: *const fn (
            self: *const IDeviceSpecificProperty,
            pv_value: ?*anyopaque,
            cb_value: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get4BRange: *const fn (
            self: *const IDeviceSpecificProperty,
            pl_min: ?*i32,
            pl_max: ?*i32,
            pl_stepping: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getType(self: *const T, p_v_type_: ?*u16) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDeviceSpecificProperty, @ptrCast(self)), p_v_type_);
            }
            pub inline fn getValue(self: *const T, pv_value_: ?*anyopaque, pcb_value_: ?*u32) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pv_value_, pcb_value_);
            }
            pub inline fn setValue(self: *const T, pv_value_: ?*anyopaque, cb_value_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pv_value_, cb_value_, pguid_event_context_);
            }
            pub inline fn get4BRange(self: *const T, pl_min_: ?*i32, pl_max_: ?*i32, pl_stepping_: ?*i32) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).Get4BRange(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pl_min_, pl_max_, pl_stepping_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPartsList_Value = Guid.initString("6daa848c-5eb0-45cc-aea5-998a2cda1ffb");
pub const IID_IPartsList = &IID_IPartsList_Value;
pub const IPartsList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: *const fn (
            self: *const IPartsList,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPart: *const fn (
            self: *const IPartsList,
            n_index: u32,
            pp_part: ?*?*IPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const IPartsList.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IPartsList, @ptrCast(self)), p_count_);
            }
            pub inline fn getPart(self: *const T, n_index_: u32, pp_part_: ?*?*IPart) HRESULT {
                return @as(*const IPartsList.VTable, @ptrCast(self.vtable)).GetPart(@as(*const IPartsList, @ptrCast(self)), n_index_, pp_part_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPart_Value = Guid.initString("ae2de0e4-5bca-4f2d-aa46-5d13f8fdb3a9");
pub const IID_IPart = &IID_IPart_Value;
pub const IPart = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IPart,
            ppwstr_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalId: *const fn (
            self: *const IPart,
            pn_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalId: *const fn (
            self: *const IPart,
            ppwstr_global_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartType: *const fn (
            self: *const IPart,
            p_part_type: ?*PartType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubType: *const fn (
            self: *const IPart,
            p_sub_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInterfaceCount: *const fn (
            self: *const IPart,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInterface: *const fn (
            self: *const IPart,
            n_index: u32,
            pp_interface_desc: ?*?*IControlInterface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPartsIncoming: *const fn (
            self: *const IPart,
            pp_parts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPartsOutgoing: *const fn (
            self: *const IPart,
            pp_parts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTopologyObject: *const fn (
            self: *const IPart,
            pp_topology: ?*?*IDeviceTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: *const fn (
            self: *const IPart,
            dw_cls_context: u32,
            refiid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterControlChangeCallback: *const fn (
            self: *const IPart,
            riid: ?*const Guid,
            p_notify: ?*IControlChangeNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterControlChangeCallback: *const fn (
            self: *const IPart,
            p_notify: ?*IControlChangeNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, ppwstr_name_: ?*?PWSTR) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetName(@as(*const IPart, @ptrCast(self)), ppwstr_name_);
            }
            pub inline fn getLocalId(self: *const T, pn_id_: ?*u32) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetLocalId(@as(*const IPart, @ptrCast(self)), pn_id_);
            }
            pub inline fn getGlobalId(self: *const T, ppwstr_global_id_: ?*?PWSTR) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetGlobalId(@as(*const IPart, @ptrCast(self)), ppwstr_global_id_);
            }
            pub inline fn getPartType(self: *const T, p_part_type_: ?*PartType) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetPartType(@as(*const IPart, @ptrCast(self)), p_part_type_);
            }
            pub inline fn getSubType(self: *const T, p_sub_type_: ?*Guid) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetSubType(@as(*const IPart, @ptrCast(self)), p_sub_type_);
            }
            pub inline fn getControlInterfaceCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetControlInterfaceCount(@as(*const IPart, @ptrCast(self)), p_count_);
            }
            pub inline fn getControlInterface(self: *const T, n_index_: u32, pp_interface_desc_: ?*?*IControlInterface) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetControlInterface(@as(*const IPart, @ptrCast(self)), n_index_, pp_interface_desc_);
            }
            pub inline fn enumPartsIncoming(self: *const T, pp_parts_: ?*?*IPartsList) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).EnumPartsIncoming(@as(*const IPart, @ptrCast(self)), pp_parts_);
            }
            pub inline fn enumPartsOutgoing(self: *const T, pp_parts_: ?*?*IPartsList) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).EnumPartsOutgoing(@as(*const IPart, @ptrCast(self)), pp_parts_);
            }
            pub inline fn getTopologyObject(self: *const T, pp_topology_: ?*?*IDeviceTopology) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetTopologyObject(@as(*const IPart, @ptrCast(self)), pp_topology_);
            }
            pub inline fn activate(self: *const T, dw_cls_context_: u32, refiid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).Activate(@as(*const IPart, @ptrCast(self)), dw_cls_context_, refiid_, ppv_object_);
            }
            pub inline fn registerControlChangeCallback(self: *const T, riid_: ?*const Guid, p_notify_: ?*IControlChangeNotify) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).RegisterControlChangeCallback(@as(*const IPart, @ptrCast(self)), riid_, p_notify_);
            }
            pub inline fn unregisterControlChangeCallback(self: *const T, p_notify_: ?*IControlChangeNotify) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).UnregisterControlChangeCallback(@as(*const IPart, @ptrCast(self)), p_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConnector_Value = Guid.initString("9c2c4058-23f5-41de-877a-df3af236a09e");
pub const IID_IConnector = &IID_IConnector_Value;
pub const IConnector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: *const fn (
            self: *const IConnector,
            p_type: ?*ConnectorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataFlow: *const fn (
            self: *const IConnector,
            p_flow: ?*DataFlow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectTo: *const fn (
            self: *const IConnector,
            p_connect_to: ?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: *const fn (
            self: *const IConnector,
            pb_connected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectedTo: *const fn (
            self: *const IConnector,
            pp_con_to: ?*?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectorIdConnectedTo: *const fn (
            self: *const IConnector,
            ppwstr_connector_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceIdConnectedTo: *const fn (
            self: *const IConnector,
            ppwstr_device_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getType(self: *const T, p_type_: ?*ConnectorType) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetType(@as(*const IConnector, @ptrCast(self)), p_type_);
            }
            pub inline fn getDataFlow(self: *const T, p_flow_: ?*DataFlow) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetDataFlow(@as(*const IConnector, @ptrCast(self)), p_flow_);
            }
            pub inline fn connectTo(self: *const T, p_connect_to_: ?*IConnector) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).ConnectTo(@as(*const IConnector, @ptrCast(self)), p_connect_to_);
            }
            pub inline fn disconnect(self: *const T) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IConnector, @ptrCast(self)));
            }
            pub inline fn isConnected(self: *const T, pb_connected_: ?*BOOL) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const IConnector, @ptrCast(self)), pb_connected_);
            }
            pub inline fn getConnectedTo(self: *const T, pp_con_to_: ?*?*IConnector) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetConnectedTo(@as(*const IConnector, @ptrCast(self)), pp_con_to_);
            }
            pub inline fn getConnectorIdConnectedTo(self: *const T, ppwstr_connector_id_: ?*?PWSTR) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetConnectorIdConnectedTo(@as(*const IConnector, @ptrCast(self)), ppwstr_connector_id_);
            }
            pub inline fn getDeviceIdConnectedTo(self: *const T, ppwstr_device_id_: ?*?PWSTR) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetDeviceIdConnectedTo(@as(*const IConnector, @ptrCast(self)), ppwstr_device_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISubunit_Value = Guid.initString("82149a85-dba6-4487-86bb-ea8f7fefcc71");
pub const IID_ISubunit = &IID_ISubunit_Value;
pub const ISubunit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlInterface_Value = Guid.initString("45d37c3f-5140-444a-ae24-400789f3cbf3");
pub const IID_IControlInterface = &IID_IControlInterface_Value;
pub const IControlInterface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IControlInterface,
            ppwstr_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: *const fn (
            self: *const IControlInterface,
            p_i_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, ppwstr_name_: ?*?PWSTR) HRESULT {
                return @as(*const IControlInterface.VTable, @ptrCast(self.vtable)).GetName(@as(*const IControlInterface, @ptrCast(self)), ppwstr_name_);
            }
            pub inline fn getIID(self: *const T, p_i_i_d_: ?*Guid) HRESULT {
                return @as(*const IControlInterface.VTable, @ptrCast(self.vtable)).GetIID(@as(*const IControlInterface, @ptrCast(self)), p_i_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlChangeNotify_Value = Guid.initString("a09513ed-c709-4d21-bd7b-5f34c47f3947");
pub const IID_IControlChangeNotify = &IID_IControlChangeNotify_Value;
pub const IControlChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: *const fn (
            self: *const IControlChangeNotify,
            dw_sender_process_id: u32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onNotify(self: *const T, dw_sender_process_id_: u32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IControlChangeNotify.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IControlChangeNotify, @ptrCast(self)), dw_sender_process_id_, pguid_event_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceTopology_Value = Guid.initString("2a07407e-6497-4a18-9787-32f79bd0d98f");
pub const IID_IDeviceTopology = &IID_IDeviceTopology_Value;
pub const IDeviceTopology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectorCount: *const fn (
            self: *const IDeviceTopology,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnector: *const fn (
            self: *const IDeviceTopology,
            n_index: u32,
            pp_connector: ?*?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubunitCount: *const fn (
            self: *const IDeviceTopology,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubunit: *const fn (
            self: *const IDeviceTopology,
            n_index: u32,
            pp_subunit: ?*?*ISubunit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartById: *const fn (
            self: *const IDeviceTopology,
            n_id: u32,
            pp_part: ?*?*IPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceId: *const fn (
            self: *const IDeviceTopology,
            ppwstr_device_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalPath: *const fn (
            self: *const IDeviceTopology,
            p_i_part_from: ?*IPart,
            p_i_part_to: ?*IPart,
            b_reject_mixed_paths: BOOL,
            pp_parts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getConnectorCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetConnectorCount(@as(*const IDeviceTopology, @ptrCast(self)), p_count_);
            }
            pub inline fn getConnector(self: *const T, n_index_: u32, pp_connector_: ?*?*IConnector) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetConnector(@as(*const IDeviceTopology, @ptrCast(self)), n_index_, pp_connector_);
            }
            pub inline fn getSubunitCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSubunitCount(@as(*const IDeviceTopology, @ptrCast(self)), p_count_);
            }
            pub inline fn getSubunit(self: *const T, n_index_: u32, pp_subunit_: ?*?*ISubunit) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSubunit(@as(*const IDeviceTopology, @ptrCast(self)), n_index_, pp_subunit_);
            }
            pub inline fn getPartById(self: *const T, n_id_: u32, pp_part_: ?*?*IPart) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetPartById(@as(*const IDeviceTopology, @ptrCast(self)), n_id_, pp_part_);
            }
            pub inline fn getDeviceId(self: *const T, ppwstr_device_id_: ?*?PWSTR) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetDeviceId(@as(*const IDeviceTopology, @ptrCast(self)), ppwstr_device_id_);
            }
            pub inline fn getSignalPath(self: *const T, p_i_part_from_: ?*IPart, p_i_part_to_: ?*IPart, b_reject_mixed_paths_: BOOL, pp_parts_: ?*?*IPartsList) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSignalPath(@as(*const IDeviceTopology, @ptrCast(self)), p_i_part_from_, p_i_part_to_, b_reject_mixed_paths_, pp_parts_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioSessionDisconnectReason = enum(i32) {
    DeviceRemoval = 0,
    ServerShutdown = 1,
    FormatChanged = 2,
    SessionLogoff = 3,
    SessionDisconnected = 4,
    ExclusiveModeOverride = 5,
};
pub const DisconnectReasonDeviceRemoval = AudioSessionDisconnectReason.DeviceRemoval;
pub const DisconnectReasonServerShutdown = AudioSessionDisconnectReason.ServerShutdown;
pub const DisconnectReasonFormatChanged = AudioSessionDisconnectReason.FormatChanged;
pub const DisconnectReasonSessionLogoff = AudioSessionDisconnectReason.SessionLogoff;
pub const DisconnectReasonSessionDisconnected = AudioSessionDisconnectReason.SessionDisconnected;
pub const DisconnectReasonExclusiveModeOverride = AudioSessionDisconnectReason.ExclusiveModeOverride;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionEvents_Value = Guid.initString("24918acc-64b3-37c1-8ca9-74a66e9957a8");
pub const IID_IAudioSessionEvents = &IID_IAudioSessionEvents_Value;
pub const IAudioSessionEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayNameChanged: *const fn (
            self: *const IAudioSessionEvents,
            new_display_name: ?[*:0]const u16,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnIconPathChanged: *const fn (
            self: *const IAudioSessionEvents,
            new_icon_path: ?[*:0]const u16,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSimpleVolumeChanged: *const fn (
            self: *const IAudioSessionEvents,
            new_volume: f32,
            new_mute: BOOL,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChannelVolumeChanged: *const fn (
            self: *const IAudioSessionEvents,
            channel_count: u32,
            new_channel_volume_array: [*]f32,
            changed_channel: u32,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnGroupingParamChanged: *const fn (
            self: *const IAudioSessionEvents,
            new_grouping_param: ?*const Guid,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStateChanged: *const fn (
            self: *const IAudioSessionEvents,
            new_state: AudioSessionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSessionDisconnected: *const fn (
            self: *const IAudioSessionEvents,
            disconnect_reason: AudioSessionDisconnectReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onDisplayNameChanged(self: *const T, new_display_name_: ?[*:0]const u16, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnDisplayNameChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), new_display_name_, event_context_);
            }
            pub inline fn onIconPathChanged(self: *const T, new_icon_path_: ?[*:0]const u16, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnIconPathChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), new_icon_path_, event_context_);
            }
            pub inline fn onSimpleVolumeChanged(self: *const T, new_volume_: f32, new_mute_: BOOL, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnSimpleVolumeChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), new_volume_, new_mute_, event_context_);
            }
            pub inline fn onChannelVolumeChanged(self: *const T, channel_count_: u32, new_channel_volume_array_: [*]f32, changed_channel_: u32, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnChannelVolumeChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), channel_count_, new_channel_volume_array_, changed_channel_, event_context_);
            }
            pub inline fn onGroupingParamChanged(self: *const T, new_grouping_param_: ?*const Guid, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnGroupingParamChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), new_grouping_param_, event_context_);
            }
            pub inline fn onStateChanged(self: *const T, new_state_: AudioSessionState) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnStateChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), new_state_);
            }
            pub inline fn onSessionDisconnected(self: *const T, disconnect_reason_: AudioSessionDisconnectReason) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnSessionDisconnected(@as(*const IAudioSessionEvents, @ptrCast(self)), disconnect_reason_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionControl_Value = Guid.initString("f4b1a599-7266-4319-a8ca-e70acb11e8cd");
pub const IID_IAudioSessionControl = &IID_IAudioSessionControl_Value;
pub const IAudioSessionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: *const fn (
            self: *const IAudioSessionControl,
            p_ret_val: ?*AudioSessionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: *const fn (
            self: *const IAudioSessionControl,
            p_ret_val: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplayName: *const fn (
            self: *const IAudioSessionControl,
            value: ?[*:0]const u16,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconPath: *const fn (
            self: *const IAudioSessionControl,
            p_ret_val: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconPath: *const fn (
            self: *const IAudioSessionControl,
            value: ?[*:0]const u16,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupingParam: *const fn (
            self: *const IAudioSessionControl,
            p_ret_val: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroupingParam: *const fn (
            self: *const IAudioSessionControl,
            override: ?*const Guid,
            event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAudioSessionNotification: *const fn (
            self: *const IAudioSessionControl,
            new_notifications: ?*IAudioSessionEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAudioSessionNotification: *const fn (
            self: *const IAudioSessionControl,
            new_notifications: ?*IAudioSessionEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getState(self: *const T, p_ret_val_: ?*AudioSessionState) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAudioSessionControl, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn getDisplayName(self: *const T, p_ret_val_: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IAudioSessionControl, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn setDisplayName(self: *const T, value_: ?[*:0]const u16, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetDisplayName(@as(*const IAudioSessionControl, @ptrCast(self)), value_, event_context_);
            }
            pub inline fn getIconPath(self: *const T, p_ret_val_: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetIconPath(@as(*const IAudioSessionControl, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn setIconPath(self: *const T, value_: ?[*:0]const u16, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetIconPath(@as(*const IAudioSessionControl, @ptrCast(self)), value_, event_context_);
            }
            pub inline fn getGroupingParam(self: *const T, p_ret_val_: ?*Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetGroupingParam(@as(*const IAudioSessionControl, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn setGroupingParam(self: *const T, override_: ?*const Guid, event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetGroupingParam(@as(*const IAudioSessionControl, @ptrCast(self)), override_, event_context_);
            }
            pub inline fn registerAudioSessionNotification(self: *const T, new_notifications_: ?*IAudioSessionEvents) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).RegisterAudioSessionNotification(@as(*const IAudioSessionControl, @ptrCast(self)), new_notifications_);
            }
            pub inline fn unregisterAudioSessionNotification(self: *const T, new_notifications_: ?*IAudioSessionEvents) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).UnregisterAudioSessionNotification(@as(*const IAudioSessionControl, @ptrCast(self)), new_notifications_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionControl2_Value = Guid.initString("bfb7ff88-7239-4fc9-8fa2-07c950be9c6d");
pub const IID_IAudioSessionControl2 = &IID_IAudioSessionControl2_Value;
pub const IAudioSessionControl2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionControl.VTable,
        GetSessionIdentifier: *const fn (
            self: *const IAudioSessionControl2,
            p_ret_val: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionInstanceIdentifier: *const fn (
            self: *const IAudioSessionControl2,
            p_ret_val: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessId: *const fn (
            self: *const IAudioSessionControl2,
            p_ret_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSystemSoundsSession: *const fn (
            self: *const IAudioSessionControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuckingPreference: *const fn (
            self: *const IAudioSessionControl2,
            opt_out: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSessionControl.MethodMixin(T);
            pub inline fn getSessionIdentifier(self: *const T, p_ret_val_: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetSessionIdentifier(@as(*const IAudioSessionControl2, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn getSessionInstanceIdentifier(self: *const T, p_ret_val_: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetSessionInstanceIdentifier(@as(*const IAudioSessionControl2, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn getProcessId(self: *const T, p_ret_val_: ?*u32) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetProcessId(@as(*const IAudioSessionControl2, @ptrCast(self)), p_ret_val_);
            }
            pub inline fn isSystemSoundsSession(self: *const T) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).IsSystemSoundsSession(@as(*const IAudioSessionControl2, @ptrCast(self)));
            }
            pub inline fn setDuckingPreference(self: *const T, opt_out_: BOOL) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).SetDuckingPreference(@as(*const IAudioSessionControl2, @ptrCast(self)), opt_out_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionManager_Value = Guid.initString("bfa971f1-4d5e-40bb-935e-967039bfbee4");
pub const IID_IAudioSessionManager = &IID_IAudioSessionManager_Value;
pub const IAudioSessionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAudioSessionControl: *const fn (
            self: *const IAudioSessionManager,
            audio_session_guid: ?*const Guid,
            stream_flags: u32,
            session_control: ?*?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSimpleAudioVolume: *const fn (
            self: *const IAudioSessionManager,
            audio_session_guid: ?*const Guid,
            stream_flags: u32,
            audio_volume: ?*?*ISimpleAudioVolume,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAudioSessionControl(self: *const T, audio_session_guid_: ?*const Guid, stream_flags_: u32, session_control_: ?*?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionManager.VTable, @ptrCast(self.vtable)).GetAudioSessionControl(@as(*const IAudioSessionManager, @ptrCast(self)), audio_session_guid_, stream_flags_, session_control_);
            }
            pub inline fn getSimpleAudioVolume(self: *const T, audio_session_guid_: ?*const Guid, stream_flags_: u32, audio_volume_: ?*?*ISimpleAudioVolume) HRESULT {
                return @as(*const IAudioSessionManager.VTable, @ptrCast(self.vtable)).GetSimpleAudioVolume(@as(*const IAudioSessionManager, @ptrCast(self)), audio_session_guid_, stream_flags_, audio_volume_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioVolumeDuckNotification_Value = Guid.initString("c3b284d4-6d39-4359-b3cf-b56ddb3bb39c");
pub const IID_IAudioVolumeDuckNotification = &IID_IAudioVolumeDuckNotification_Value;
pub const IAudioVolumeDuckNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnVolumeDuckNotification: *const fn (
            self: *const IAudioVolumeDuckNotification,
            session_i_d: ?[*:0]const u16,
            count_communication_sessions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnVolumeUnduckNotification: *const fn (
            self: *const IAudioVolumeDuckNotification,
            session_i_d: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onVolumeDuckNotification(self: *const T, session_i_d_: ?[*:0]const u16, count_communication_sessions_: u32) HRESULT {
                return @as(*const IAudioVolumeDuckNotification.VTable, @ptrCast(self.vtable)).OnVolumeDuckNotification(@as(*const IAudioVolumeDuckNotification, @ptrCast(self)), session_i_d_, count_communication_sessions_);
            }
            pub inline fn onVolumeUnduckNotification(self: *const T, session_i_d_: ?[*:0]const u16) HRESULT {
                return @as(*const IAudioVolumeDuckNotification.VTable, @ptrCast(self.vtable)).OnVolumeUnduckNotification(@as(*const IAudioVolumeDuckNotification, @ptrCast(self)), session_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionNotification_Value = Guid.initString("641dd20b-4d41-49cc-aba3-174b9477bb08");
pub const IID_IAudioSessionNotification = &IID_IAudioSessionNotification_Value;
pub const IAudioSessionNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSessionCreated: *const fn (
            self: *const IAudioSessionNotification,
            new_session: ?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onSessionCreated(self: *const T, new_session_: ?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionNotification.VTable, @ptrCast(self.vtable)).OnSessionCreated(@as(*const IAudioSessionNotification, @ptrCast(self)), new_session_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionEnumerator_Value = Guid.initString("e2f5bb11-0570-40ca-acdd-3aa01277dee8");
pub const IID_IAudioSessionEnumerator = &IID_IAudioSessionEnumerator_Value;
pub const IAudioSessionEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: *const fn (
            self: *const IAudioSessionEnumerator,
            session_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSession: *const fn (
            self: *const IAudioSessionEnumerator,
            session_count: i32,
            session: ?*?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCount(self: *const T, session_count_: ?*i32) HRESULT {
                return @as(*const IAudioSessionEnumerator.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAudioSessionEnumerator, @ptrCast(self)), session_count_);
            }
            pub inline fn getSession(self: *const T, session_count_: i32, session_: ?*?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionEnumerator.VTable, @ptrCast(self.vtable)).GetSession(@as(*const IAudioSessionEnumerator, @ptrCast(self)), session_count_, session_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionManager2_Value = Guid.initString("77aa99a0-1bd6-484f-8bc7-2c654c9a9b6f");
pub const IID_IAudioSessionManager2 = &IID_IAudioSessionManager2_Value;
pub const IAudioSessionManager2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionManager.VTable,
        GetSessionEnumerator: *const fn (
            self: *const IAudioSessionManager2,
            session_enum: ?*?*IAudioSessionEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterSessionNotification: *const fn (
            self: *const IAudioSessionManager2,
            session_notification: ?*IAudioSessionNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterSessionNotification: *const fn (
            self: *const IAudioSessionManager2,
            session_notification: ?*IAudioSessionNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDuckNotification: *const fn (
            self: *const IAudioSessionManager2,
            session_i_d: ?[*:0]const u16,
            duck_notification: ?*IAudioVolumeDuckNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterDuckNotification: *const fn (
            self: *const IAudioSessionManager2,
            duck_notification: ?*IAudioVolumeDuckNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSessionManager.MethodMixin(T);
            pub inline fn getSessionEnumerator(self: *const T, session_enum_: ?*?*IAudioSessionEnumerator) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).GetSessionEnumerator(@as(*const IAudioSessionManager2, @ptrCast(self)), session_enum_);
            }
            pub inline fn registerSessionNotification(self: *const T, session_notification_: ?*IAudioSessionNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).RegisterSessionNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), session_notification_);
            }
            pub inline fn unregisterSessionNotification(self: *const T, session_notification_: ?*IAudioSessionNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).UnregisterSessionNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), session_notification_);
            }
            pub inline fn registerDuckNotification(self: *const T, session_i_d_: ?[*:0]const u16, duck_notification_: ?*IAudioVolumeDuckNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).RegisterDuckNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), session_i_d_, duck_notification_);
            }
            pub inline fn unregisterDuckNotification(self: *const T, duck_notification_: ?*IAudioVolumeDuckNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).UnregisterDuckNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), duck_notification_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioMetadataWriterOverflowMode = enum(i32) {
    Fail = 0,
    MergeWithNew = 1,
    MergeWithLast = 2,
};
pub const SpatialAudioMetadataWriterOverflow_Fail = SpatialAudioMetadataWriterOverflowMode.Fail;
pub const SpatialAudioMetadataWriterOverflow_MergeWithNew = SpatialAudioMetadataWriterOverflowMode.MergeWithNew;
pub const SpatialAudioMetadataWriterOverflow_MergeWithLast = SpatialAudioMetadataWriterOverflowMode.MergeWithLast;

pub const SpatialAudioMetadataCopyMode = enum(i32) {
    Overwrite = 0,
    Append = 1,
    AppendMergeWithLast = 2,
    AppendMergeWithFirst = 3,
};
pub const SpatialAudioMetadataCopy_Overwrite = SpatialAudioMetadataCopyMode.Overwrite;
pub const SpatialAudioMetadataCopy_Append = SpatialAudioMetadataCopyMode.Append;
pub const SpatialAudioMetadataCopy_AppendMergeWithLast = SpatialAudioMetadataCopyMode.AppendMergeWithLast;
pub const SpatialAudioMetadataCopy_AppendMergeWithFirst = SpatialAudioMetadataCopyMode.AppendMergeWithFirst;

pub const SpatialAudioMetadataItemsInfo = extern struct {
    FrameCount: u16 align(1),
    ItemCount: u16 align(1),
    MaxItemCount: u16 align(1),
    MaxValueBufferLength: u32 align(1),
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    MetadataFormatId: Guid align(1),
    MaxMetadataItemCount: u16 align(1),
    MetadataActivationParams: ?*const PROPVARIANT align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    MetadataFormatId: Guid align(1),
    MaxMetadataItemCount: u32 align(1),
    MetadataActivationParams: ?*const PROPVARIANT align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItems_Value = Guid.initString("bcd7c78f-3098-4f22-b547-a2f25a381269");
pub const IID_ISpatialAudioMetadataItems = &IID_ISpatialAudioMetadataItems_Value;
pub const ISpatialAudioMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: *const fn (
            self: *const ISpatialAudioMetadataItems,
            frame_count: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemCount: *const fn (
            self: *const ISpatialAudioMetadataItems,
            item_count: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxItemCount: *const fn (
            self: *const ISpatialAudioMetadataItems,
            max_item_count: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxValueBufferLength: *const fn (
            self: *const ISpatialAudioMetadataItems,
            max_value_buffer_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: *const fn (
            self: *const ISpatialAudioMetadataItems,
            info: ?*SpatialAudioMetadataItemsInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFrameCount(self: *const T, frame_count_: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetFrameCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), frame_count_);
            }
            pub inline fn getItemCount(self: *const T, item_count_: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetItemCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), item_count_);
            }
            pub inline fn getMaxItemCount(self: *const T, max_item_count_: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetMaxItemCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), max_item_count_);
            }
            pub inline fn getMaxValueBufferLength(self: *const T, max_value_buffer_length_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetMaxValueBufferLength(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), max_value_buffer_length_);
            }
            pub inline fn getInfo(self: *const T, info_: ?*SpatialAudioMetadataItemsInfo) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataWriter_Value = Guid.initString("1b17ca01-2955-444d-a430-537dc589a844");
pub const IID_ISpatialAudioMetadataWriter = &IID_ISpatialAudioMetadataWriter_Value;
pub const ISpatialAudioMetadataWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const ISpatialAudioMetadataWriter,
            metadata_items: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNextItem: *const fn (
            self: *const ISpatialAudioMetadataWriter,
            frame_offset: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNextItemCommand: *const fn (
            self: *const ISpatialAudioMetadataWriter,
            command_i_d: u8,
            // TODO: what to do with BytesParamIndex 2?
            value_buffer: ?*const anyopaque,
            value_buffer_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const ISpatialAudioMetadataWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, metadata_items_: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), metadata_items_);
            }
            pub inline fn writeNextItem(self: *const T, frame_offset_: u16) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).WriteNextItem(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), frame_offset_);
            }
            pub inline fn writeNextItemCommand(self: *const T, command_i_d_: u8, value_buffer_: ?*const anyopaque, value_buffer_length_: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).WriteNextItemCommand(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), command_i_d_, value_buffer_, value_buffer_length_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataReader_Value = Guid.initString("b78e86a2-31d9-4c32-94d2-7df40fc7ebec");
pub const IID_ISpatialAudioMetadataReader = &IID_ISpatialAudioMetadataReader_Value;
pub const ISpatialAudioMetadataReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const ISpatialAudioMetadataReader,
            metadata_items: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadNextItem: *const fn (
            self: *const ISpatialAudioMetadataReader,
            command_count: ?*u8,
            frame_offset: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadNextItemCommand: *const fn (
            self: *const ISpatialAudioMetadataReader,
            command_i_d: ?*u8,
            // TODO: what to do with BytesParamIndex 2?
            value_buffer: ?*anyopaque,
            max_value_buffer_length: u32,
            value_buffer_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const ISpatialAudioMetadataReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, metadata_items_: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), metadata_items_);
            }
            pub inline fn readNextItem(self: *const T, command_count_: ?*u8, frame_offset_: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).ReadNextItem(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), command_count_, frame_offset_);
            }
            pub inline fn readNextItemCommand(self: *const T, command_i_d_: ?*u8, value_buffer_: ?*anyopaque, max_value_buffer_length_: u32, value_buffer_length_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).ReadNextItemCommand(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), command_i_d_, value_buffer_, max_value_buffer_length_, value_buffer_length_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataCopier_Value = Guid.initString("d224b233-e251-4fd0-9ca2-d5ecf9a68404");
pub const IID_ISpatialAudioMetadataCopier = &IID_ISpatialAudioMetadataCopier_Value;
pub const ISpatialAudioMetadataCopier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const ISpatialAudioMetadataCopier,
            metadata_items: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyMetadataForFrames: *const fn (
            self: *const ISpatialAudioMetadataCopier,
            copy_frame_count: u16,
            copy_mode: SpatialAudioMetadataCopyMode,
            dst_metadata_items: ?*ISpatialAudioMetadataItems,
            items_copied: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const ISpatialAudioMetadataCopier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, metadata_items_: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)), metadata_items_);
            }
            pub inline fn copyMetadataForFrames(self: *const T, copy_frame_count_: u16, copy_mode_: SpatialAudioMetadataCopyMode, dst_metadata_items_: ?*ISpatialAudioMetadataItems, items_copied_: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).CopyMetadataForFrames(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)), copy_frame_count_, copy_mode_, dst_metadata_items_, items_copied_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItemsBuffer_Value = Guid.initString("42640a16-e1bd-42d9-9ff6-031ab71a2dba");
pub const IID_ISpatialAudioMetadataItemsBuffer = &IID_ISpatialAudioMetadataItemsBuffer_Value;
pub const ISpatialAudioMetadataItemsBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachToBuffer: *const fn (
            self: *const ISpatialAudioMetadataItemsBuffer,
            // TODO: what to do with BytesParamIndex 1?
            buffer: ?*u8,
            buffer_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachToPopulatedBuffer: *const fn (
            self: *const ISpatialAudioMetadataItemsBuffer,
            // TODO: what to do with BytesParamIndex 1?
            buffer: ?*u8,
            buffer_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachBuffer: *const fn (
            self: *const ISpatialAudioMetadataItemsBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn attachToBuffer(self: *const T, buffer_: ?*u8, buffer_length_: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).AttachToBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)), buffer_, buffer_length_);
            }
            pub inline fn attachToPopulatedBuffer(self: *const T, buffer_: ?*u8, buffer_length_: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).AttachToPopulatedBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)), buffer_, buffer_length_);
            }
            pub inline fn detachBuffer(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).DetachBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataClient_Value = Guid.initString("777d4a3b-f6ff-4a26-85dc-68d7cdeda1d4");
pub const IID_ISpatialAudioMetadataClient = &IID_ISpatialAudioMetadataClient_Value;
pub const ISpatialAudioMetadataClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateSpatialAudioMetadataItems: *const fn (
            self: *const ISpatialAudioMetadataClient,
            max_item_count: u16,
            frame_count: u16,
            metadata_items_buffer: ?*?*ISpatialAudioMetadataItemsBuffer,
            metadata_items: ?*?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpatialAudioMetadataItemsBufferLength: *const fn (
            self: *const ISpatialAudioMetadataClient,
            max_item_count: u16,
            buffer_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataWriter: *const fn (
            self: *const ISpatialAudioMetadataClient,
            overflow_mode: SpatialAudioMetadataWriterOverflowMode,
            metadata_writer: ?*?*ISpatialAudioMetadataWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataCopier: *const fn (
            self: *const ISpatialAudioMetadataClient,
            metadata_copier: ?*?*ISpatialAudioMetadataCopier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataReader: *const fn (
            self: *const ISpatialAudioMetadataClient,
            metadata_reader: ?*?*ISpatialAudioMetadataReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn activateSpatialAudioMetadataItems(self: *const T, max_item_count_: u16, frame_count_: u16, metadata_items_buffer_: ?*?*ISpatialAudioMetadataItemsBuffer, metadata_items_: ?*?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataItems(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), max_item_count_, frame_count_, metadata_items_buffer_, metadata_items_);
            }
            pub inline fn getSpatialAudioMetadataItemsBufferLength(self: *const T, max_item_count_: u16, buffer_length_: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).GetSpatialAudioMetadataItemsBufferLength(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), max_item_count_, buffer_length_);
            }
            pub inline fn activateSpatialAudioMetadataWriter(self: *const T, overflow_mode_: SpatialAudioMetadataWriterOverflowMode, metadata_writer_: ?*?*ISpatialAudioMetadataWriter) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataWriter(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), overflow_mode_, metadata_writer_);
            }
            pub inline fn activateSpatialAudioMetadataCopier(self: *const T, metadata_copier_: ?*?*ISpatialAudioMetadataCopier) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataCopier(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), metadata_copier_);
            }
            pub inline fn activateSpatialAudioMetadataReader(self: *const T, metadata_reader_: ?*?*ISpatialAudioMetadataReader) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataReader(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), metadata_reader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataCommands_Value = Guid.initString("0df2c94b-f5f9-472d-af6b-c46e0ac9cd05");
pub const IID_ISpatialAudioObjectForMetadataCommands = &IID_ISpatialAudioObjectForMetadataCommands_Value;
pub const ISpatialAudioObjectForMetadataCommands = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        WriteNextMetadataCommand: *const fn (
            self: *const ISpatialAudioObjectForMetadataCommands,
            command_i_d: u8,
            // TODO: what to do with BytesParamIndex 2?
            value_buffer: ?*anyopaque,
            value_buffer_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            pub inline fn writeNextMetadataCommand(self: *const T, command_i_d_: u8, value_buffer_: ?*anyopaque, value_buffer_length_: u32) HRESULT {
                return @as(*const ISpatialAudioObjectForMetadataCommands.VTable, @ptrCast(self.vtable)).WriteNextMetadataCommand(@as(*const ISpatialAudioObjectForMetadataCommands, @ptrCast(self)), command_i_d_, value_buffer_, value_buffer_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataItems_Value = Guid.initString("ddea49ff-3bc0-4377-8aad-9fbcfd808566");
pub const IID_ISpatialAudioObjectForMetadataItems = &IID_ISpatialAudioObjectForMetadataItems_Value;
pub const ISpatialAudioObjectForMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        GetSpatialAudioMetadataItems: *const fn (
            self: *const ISpatialAudioObjectForMetadataItems,
            metadata_items: ?*?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            pub inline fn getSpatialAudioMetadataItems(self: *const T, metadata_items_: ?*?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioObjectForMetadataItems.VTable, @ptrCast(self.vtable)).GetSpatialAudioMetadataItems(@as(*const ISpatialAudioObjectForMetadataItems, @ptrCast(self)), metadata_items_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForMetadata_Value = Guid.initString("bbc9c907-48d5-4a2e-a0c7-f7f0d67c1fb1");
pub const IID_ISpatialAudioObjectRenderStreamForMetadata = &IID_ISpatialAudioObjectRenderStreamForMetadata_Value;
pub const ISpatialAudioObjectRenderStreamForMetadata = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForMetadataCommands: *const fn (
            self: *const ISpatialAudioObjectRenderStreamForMetadata,
            type: AudioObjectType,
            audio_object: ?*?*ISpatialAudioObjectForMetadataCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioObjectForMetadataItems: *const fn (
            self: *const ISpatialAudioObjectRenderStreamForMetadata,
            type: AudioObjectType,
            audio_object: ?*?*ISpatialAudioObjectForMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            pub inline fn activateSpatialAudioObjectForMetadataCommands(self: *const T, type_: AudioObjectType, audio_object_: ?*?*ISpatialAudioObjectForMetadataCommands) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForMetadataCommands(@as(*const ISpatialAudioObjectRenderStreamForMetadata, @ptrCast(self)), type_, audio_object_);
            }
            pub inline fn activateSpatialAudioObjectForMetadataItems(self: *const T, type_: AudioObjectType, audio_object_: ?*?*ISpatialAudioObjectForMetadataItems) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForMetadataItems(@as(*const ISpatialAudioObjectRenderStreamForMetadata, @ptrCast(self)), type_, audio_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROCESS_LOOPBACK_MODE = enum(i32) {
    INCLUDE_TARGET_PROCESS_TREE = 0,
    EXCLUDE_TARGET_PROCESS_TREE = 1,
};
pub const PROCESS_LOOPBACK_MODE_INCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.INCLUDE_TARGET_PROCESS_TREE;
pub const PROCESS_LOOPBACK_MODE_EXCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.EXCLUDE_TARGET_PROCESS_TREE;

pub const AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS = extern struct {
    TargetProcessId: u32,
    ProcessLoopbackMode: PROCESS_LOOPBACK_MODE,
};

pub const AUDIOCLIENT_ACTIVATION_TYPE = enum(i32) {
    DEFAULT = 0,
    PROCESS_LOOPBACK = 1,
};
pub const AUDIOCLIENT_ACTIVATION_TYPE_DEFAULT = AUDIOCLIENT_ACTIVATION_TYPE.DEFAULT;
pub const AUDIOCLIENT_ACTIVATION_TYPE_PROCESS_LOOPBACK = AUDIOCLIENT_ACTIVATION_TYPE.PROCESS_LOOPBACK;

pub const AUDIOCLIENT_ACTIVATION_PARAMS = extern struct {
    ActivationType: AUDIOCLIENT_ACTIVATION_TYPE,
    Anonymous: extern union {
        ProcessLoopbackParams: AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS,
    },
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PAudioStateMonitorCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const AudioStateMonitorSoundLevel = enum(i32) {
    Muted = 0,
    Low = 1,
    Full = 2,
};
pub const Muted = AudioStateMonitorSoundLevel.Muted;
pub const Low = AudioStateMonitorSoundLevel.Low;
pub const Full = AudioStateMonitorSoundLevel.Full;

const IID_IAudioStateMonitor_Value = Guid.initString("63bd8738-e30d-4c77-bf5c-834e87c657e2");
pub const IID_IAudioStateMonitor = &IID_IAudioStateMonitor_Value;
pub const IAudioStateMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCallback: *const fn (
            self: *const IAudioStateMonitor,
            callback: ?PAudioStateMonitorCallback,
            context: ?*anyopaque,
            registration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterCallback: *const fn (
            self: *const IAudioStateMonitor,
            registration: i64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetSoundLevel: *const fn (
            self: *const IAudioStateMonitor,
        ) callconv(@import("std").os.windows.WINAPI) AudioStateMonitorSoundLevel,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerCallback(self: *const T, callback_: ?PAudioStateMonitorCallback, context_: ?*anyopaque, registration_: ?*i64) HRESULT {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).RegisterCallback(@as(*const IAudioStateMonitor, @ptrCast(self)), callback_, context_, registration_);
            }
            pub inline fn unregisterCallback(self: *const T, registration_: i64) void {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).UnregisterCallback(@as(*const IAudioStateMonitor, @ptrCast(self)), registration_);
            }
            pub inline fn getSoundLevel(self: *const T) AudioStateMonitorSoundLevel {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).GetSoundLevel(@as(*const IAudioStateMonitor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACMDRIVERENUMCB = *const fn (
    hadid: ?HACMDRIVERID,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPACMDRIVERPROC = *const fn (
    param0: usize,
    param1: ?HACMDRIVERID,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const ACMDRIVERDETAILSA = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    wMid: u16 align(1),
    wPid: u16 align(1),
    vdwACM: u32 align(1),
    vdwDriver: u32 align(1),
    fdwSupport: u32 align(1),
    cFormatTags: u32 align(1),
    cFilterTags: u32 align(1),
    hicon: ?HICON align(1),
    szShortName: [32]CHAR align(1),
    szLongName: [128]CHAR align(1),
    szCopyright: [80]CHAR align(1),
    szLicensing: [128]CHAR align(1),
    szFeatures: [512]CHAR align(1),
};

pub const ACMDRIVERDETAILSW = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    wMid: u16 align(1),
    wPid: u16 align(1),
    vdwACM: u32 align(1),
    vdwDriver: u32 align(1),
    fdwSupport: u32 align(1),
    cFormatTags: u32 align(1),
    cFilterTags: u32 align(1),
    hicon: ?HICON align(1),
    szShortName: [32]u16 align(1),
    szLongName: [128]u16 align(1),
    szCopyright: [80]u16 align(1),
    szLicensing: [128]u16 align(1),
    szFeatures: [512]u16 align(1),
};

pub const ACMFORMATTAGDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFormatTagIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    cbFormatSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFormats: u32 align(1),
    szFormatTag: [48]CHAR align(1),
};

pub const ACMFORMATTAGDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFormatTagIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    cbFormatSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFormats: u32 align(1),
    szFormatTag: [48]u16 align(1),
};

pub const ACMFORMATTAGENUMCBA = *const fn (
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFORMATTAGDETAILSA,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATTAGENUMCBW = *const fn (
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFORMATTAGDETAILSW,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFormatIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    szFormat: [128]CHAR align(1),
};

pub const tACMFORMATDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFormatIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    szFormat: [128]u16 align(1),
};

pub const ACMFORMATENUMCBA = *const fn (
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFORMATDETAILSA,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATENUMCBW = *const fn (
    hadid: ?HACMDRIVERID,
    pafd: ?*tACMFORMATDETAILSW,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATCHOOSEHOOKPROCA = *const fn (
    hwnd: ?HWND,
    u_msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEHOOKPROCW = *const fn (
    hwnd: ?HWND,
    u_msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEA = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    pszTitle: ?[*:0]const u8 align(1),
    szFormatTag: [48]CHAR align(1),
    szFormat: [128]CHAR align(1),
    pszName: ?PSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfxEnum: ?*WAVEFORMATEX align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u8 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCA align(1),
};

pub const ACMFORMATCHOOSEW = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    pszTitle: ?[*:0]const u16 align(1),
    szFormatTag: [48]u16 align(1),
    szFormat: [128]u16 align(1),
    pszName: ?PWSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfxEnum: ?*WAVEFORMATEX align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u16 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCW align(1),
};

pub const ACMFILTERTAGDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFilterTagIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    cbFilterSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFilters: u32 align(1),
    szFilterTag: [48]CHAR align(1),
};

pub const ACMFILTERTAGDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFilterTagIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    cbFilterSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFilters: u32 align(1),
    szFilterTag: [48]u16 align(1),
};

pub const ACMFILTERTAGENUMCBA = *const fn (
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFILTERTAGDETAILSA,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERTAGENUMCBW = *const fn (
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFILTERTAGDETAILSW,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFilterIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    szFilter: [128]CHAR align(1),
};

pub const ACMFILTERDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFilterIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    szFilter: [128]u16 align(1),
};

pub const ACMFILTERENUMCBA = *const fn (
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFILTERDETAILSA,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERENUMCBW = *const fn (
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFILTERDETAILSW,
    dw_instance: usize,
    fdw_support: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERCHOOSEHOOKPROCA = *const fn (
    hwnd: ?HWND,
    u_msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEHOOKPROCW = *const fn (
    hwnd: ?HWND,
    u_msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEA = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    pszTitle: ?[*:0]const u8 align(1),
    szFilterTag: [48]CHAR align(1),
    szFilter: [128]CHAR align(1),
    pszName: ?PSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfltrEnum: ?*WAVEFILTER align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u8 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCA align(1),
};

pub const ACMFILTERCHOOSEW = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    pszTitle: ?[*:0]const u16 align(1),
    szFilterTag: [48]u16 align(1),
    szFilter: [128]u16 align(1),
    pszName: ?PWSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfltrEnum: ?*WAVEFILTER align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u16 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCW align(1),
};

pub const tACMDRVOPENDESCA = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    dwVersion: u32 align(1),
    dwFlags: u32 align(1),
    dwError: u32 align(1),
    pszSectionName: ?[*:0]const u8 align(1),
    pszAliasName: ?[*:0]const u8 align(1),
    dnDevNode: u32 align(1),
};

pub const tACMDRVOPENDESCW = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    dwVersion: u32 align(1),
    dwFlags: u32 align(1),
    dwError: u32 align(1),
    pszSectionName: ?[*:0]const u16 align(1),
    pszAliasName: ?[*:0]const u16 align(1),
    dnDevNode: u32 align(1),
};

pub const ACMDRVSTREAMINSTANCE = extern struct {
    cbStruct: u32 align(1),
    pwfxSrc: ?*WAVEFORMATEX align(1),
    pwfxDst: ?*WAVEFORMATEX align(1),
    pwfltr: ?*WAVEFILTER align(1),
    dwCallback: usize align(1),
    dwInstance: usize align(1),
    fdwOpen: u32 align(1),
    fdwDriver: u32 align(1),
    dwDriver: usize align(1),
    has: ?HACMSTREAM align(1),
};

pub const ACMDRVSTREAMHEADER = extern struct {
    cbStruct: u32 align(1),
    fdwStatus: u32 align(1),
    dwUser: usize align(1),
    pbSrc: ?*u8 align(1),
    cbSrcLength: u32 align(1),
    cbSrcLengthUsed: u32 align(1),
    dwSrcUser: usize align(1),
    pbDst: ?*u8 align(1),
    cbDstLength: u32 align(1),
    cbDstLengthUsed: u32 align(1),
    dwDstUser: usize align(1),
    fdwConvert: u32 align(1),
    padshNext: ?*ACMDRVSTREAMHEADER align(1),
    fdwDriver: u32 align(1),
    dwDriver: usize align(1),
    fdwPrepared: u32 align(1),
    dwPrepared: usize align(1),
    pbPreparedSrc: ?*u8 align(1),
    cbPreparedSrcLength: u32 align(1),
    pbPreparedDst: ?*u8 align(1),
    cbPreparedDstLength: u32 align(1),
};

pub const ACMDRVSTREAMSIZE = extern struct {
    cbStruct: u32 align(1),
    fdwSize: u32 align(1),
    cbSrcLength: u32 align(1),
    cbDstLength: u32 align(1),
};

pub const ACMDRVFORMATSUGGEST = extern struct {
    cbStruct: u32 align(1),
    fdwSuggest: u32 align(1),
    pwfxSrc: ?*WAVEFORMATEX align(1),
    cbwfxSrc: u32 align(1),
    pwfxDst: ?*WAVEFORMATEX align(1),
    cbwfxDst: u32 align(1),
};

pub const ACMSTREAMHEADER = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbStruct: u32 align(1),
        fdwStatus: u32 align(1),
        dwUser: usize align(1),
        pbSrc: ?*u8 align(1),
        cbSrcLength: u32 align(1),
        cbSrcLengthUsed: u32 align(1),
        dwSrcUser: usize align(1),
        pbDst: ?*u8 align(1),
        cbDstLength: u32 align(1),
        cbDstLengthUsed: u32 align(1),
        dwDstUser: usize align(1),
        dwReservedDriver: [15]u32 align(1),
    },
    .X86 => extern struct {
        cbStruct: u32 align(1),
        fdwStatus: u32 align(1),
        dwUser: usize align(1),
        pbSrc: ?*u8 align(1),
        cbSrcLength: u32 align(1),
        cbSrcLengthUsed: u32 align(1),
        dwSrcUser: usize align(1),
        pbDst: ?*u8 align(1),
        cbDstLength: u32 align(1),
        cbDstLengthUsed: u32 align(1),
        dwDstUser: usize align(1),
        dwReservedDriver: [10]u32 align(1),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (158)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterMessageFilter(
    lp_message_filter: ?*IMessageFilter,
    lplp_message_filter: ?*?*IMessageFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "winmm" fn sndPlaySoundA(
    psz_sound: ?[*:0]const u8,
    fu_sound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn sndPlaySoundW(
    psz_sound: ?[*:0]const u16,
    fu_sound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn PlaySoundA(
    psz_sound: ?[*:0]const u8,
    hmod: ?HINSTANCE,
    fdw_sound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn PlaySoundW(
    psz_sound: ?[*:0]const u16,
    hmod: ?HINSTANCE,
    fdw_sound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetDevCapsA(
    u_device_i_d: usize,
    pwoc: ?*WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetDevCapsW(
    u_device_i_d: usize,
    pwoc: ?*WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetVolume(
    hwo: ?HWAVEOUT,
    pdw_volume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetVolume(
    hwo: ?HWAVEOUT,
    dw_volume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetErrorTextA(
    mmr_error: u32,
    psz_text: [*:0]u8,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetErrorTextW(
    mmr_error: u32,
    psz_text: [*:0]u16,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutOpen(
    phwo: ?*?HWAVEOUT,
    u_device_i_d: u32,
    pwfx: ?*WAVEFORMATEX,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutClose(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutPrepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutUnprepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutWrite(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutPause(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutRestart(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutReset(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutBreakLoop(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPosition(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPitch(
    hwo: ?HWAVEOUT,
    pdw_pitch: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetPitch(
    hwo: ?HWAVEOUT,
    dw_pitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPlaybackRate(
    hwo: ?HWAVEOUT,
    pdw_rate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetPlaybackRate(
    hwo: ?HWAVEOUT,
    dw_rate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetID(
    hwo: ?HWAVEOUT,
    pu_device_i_d: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutMessage(
    hwo: ?HWAVEOUT,
    u_msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetDevCapsA(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetDevCapsW(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetErrorTextA(
    mmr_error: u32,
    psz_text: [*:0]u8,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetErrorTextW(
    mmr_error: u32,
    psz_text: [*:0]u16,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInOpen(
    phwi: ?*?HWAVEIN,
    u_device_i_d: u32,
    pwfx: ?*WAVEFORMATEX,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInClose(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInPrepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInUnprepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInAddBuffer(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInStart(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInStop(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInReset(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetPosition(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetID(
    hwi: ?HWAVEIN,
    pu_device_i_d: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInMessage(
    hwi: ?HWAVEIN,
    u_msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamOpen(
    phms: ?*?HMIDISTRM,
    pu_device_i_d: [*]u32,
    c_midi: u32,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamClose(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamProperty(
    hms: ?HMIDISTRM,
    lppropdata: ?*u8,
    dw_property: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamPosition(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    lpmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamOut(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamPause(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamRestart(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamStop(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiConnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiDisconnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetDevCapsA(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetDevCapsW(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetVolume(
    hmo: ?HMIDIOUT,
    pdw_volume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutSetVolume(
    hmo: ?HMIDIOUT,
    dw_volume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetErrorTextA(
    mmr_error: u32,
    psz_text: [*:0]u8,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetErrorTextW(
    mmr_error: u32,
    psz_text: [*:0]u16,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutOpen(
    phmo: ?*?HMIDIOUT,
    u_device_i_d: u32,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutClose(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutPrepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutUnprepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutShortMsg(
    hmo: ?HMIDIOUT,
    dw_msg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutLongMsg(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutReset(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutCachePatches(
    hmo: ?HMIDIOUT,
    u_bank: u32,
    pwpa: *[128]u16,
    fu_cache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutCacheDrumPatches(
    hmo: ?HMIDIOUT,
    u_patch: u32,
    pwkya: *[128]u16,
    fu_cache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetID(
    hmo: ?HMIDIOUT,
    pu_device_i_d: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutMessage(
    hmo: ?HMIDIOUT,
    u_msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetDevCapsA(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetDevCapsW(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetErrorTextA(
    mmr_error: u32,
    psz_text: [*:0]u8,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetErrorTextW(
    mmr_error: u32,
    psz_text: [*:0]u16,
    cch_text: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInOpen(
    phmi: ?*?HMIDIIN,
    u_device_i_d: u32,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInClose(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInPrepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInUnprepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInAddBuffer(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInStart(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInStop(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInReset(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetID(
    hmi: ?HMIDIIN,
    pu_device_i_d: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInMessage(
    hmi: ?HMIDIIN,
    u_msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetDevCapsA(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetDevCapsW(
    u_device_i_d: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxSetVolume(
    u_device_i_d: u32,
    dw_volume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetVolume(
    u_device_i_d: u32,
    pdw_volume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxOutMessage(
    u_device_i_d: u32,
    u_msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetDevCapsA(
    u_mx_id: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetDevCapsW(
    u_mx_id: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerOpen(
    phmx: ?*isize,
    u_mx_id: u32,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerClose(
    hmx: ?HMIXER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerMessage(
    hmx: ?HMIXER,
    u_msg: u32,
    dw_param1: usize,
    dw_param2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineInfoA(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEA,
    fdw_info: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineInfoW(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEW,
    fdw_info: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetID(
    hmxobj: ?HMIXEROBJ,
    pu_mx_id: ?*u32,
    fdw_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineControlsA(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSA,
    fdw_controls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineControlsW(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSW,
    fdw_controls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetControlDetailsA(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetControlDetailsW(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerSetControlDetails(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mmdevapi" fn ActivateAudioInterfaceAsync(
    device_interface_path: ?[*:0]const u16,
    riid: ?*const Guid,
    activation_params: ?*PROPVARIANT,
    completion_handler: ?*IActivateAudioInterfaceCompletionHandler,
    activation_operation: ?*?*IActivateAudioInterfaceAsyncOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitor(
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    device_id: ?[*:0]const u16,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitor(
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    device_id: ?[*:0]const u16,
    audio_state_monitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmGetVersion() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmMetrics(
    hao: ?HACMOBJ,
    u_metric: u32,
    p_metric: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverEnum(
    fn_callback: ?ACMDRIVERENUMCB,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverID(
    hao: ?HACMOBJ,
    phadid: ?*isize,
    fdw_driver_i_d: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverAddA(
    phadid: ?*isize,
    hinst_module: ?HINSTANCE,
    l_param: LPARAM,
    dw_priority: u32,
    fdw_add: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverAddW(
    phadid: ?*isize,
    hinst_module: ?HINSTANCE,
    l_param: LPARAM,
    dw_priority: u32,
    fdw_add: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverRemove(
    hadid: ?HACMDRIVERID,
    fdw_remove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverOpen(
    phad: ?*isize,
    hadid: ?HACMDRIVERID,
    fdw_open: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverClose(
    had: ?HACMDRIVER,
    fdw_close: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverMessage(
    had: ?HACMDRIVER,
    u_msg: u32,
    l_param1: LPARAM,
    l_param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverPriority(
    hadid: ?HACMDRIVERID,
    dw_priority: u32,
    fdw_priority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverDetailsA(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSA,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverDetailsW(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSW,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fn_callback: ?ACMFORMATTAGENUMCBA,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fn_callback: ?ACMFORMATTAGENUMCBW,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fn_callback: ?ACMFORMATENUMCBA,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatEnumW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fn_callback: ?ACMFORMATENUMCBW,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatSuggest(
    had: ?HACMDRIVER,
    pwfx_src: ?*WAVEFORMATEX,
    pwfx_dst: ?*WAVEFORMATEX,
    cbwfx_dst: u32,
    fdw_suggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatChooseA(
    pafmtc: ?*ACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatChooseW(
    pafmtc: ?*ACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fn_callback: ?ACMFILTERTAGENUMCBA,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fn_callback: ?ACMFILTERTAGENUMCBW,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fdw_details: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fn_callback: ?ACMFILTERENUMCBA,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterEnumW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fn_callback: ?ACMFILTERENUMCBW,
    dw_instance: usize,
    fdw_enum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterChooseA(
    pafltrc: ?*ACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterChooseW(
    pafltrc: ?*ACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamOpen(
    phas: ?*isize,
    had: ?HACMDRIVER,
    pwfx_src: ?*WAVEFORMATEX,
    pwfx_dst: ?*WAVEFORMATEX,
    pwfltr: ?*WAVEFILTER,
    dw_callback: usize,
    dw_instance: usize,
    fdw_open: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamClose(
    has: ?HACMSTREAM,
    fdw_close: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamSize(
    has: ?HACMSTREAM,
    cb_input: u32,
    pdw_output_bytes: ?*u32,
    fdw_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamReset(
    has: ?HACMSTREAM,
    fdw_reset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamMessage(
    has: ?HACMSTREAM,
    u_msg: u32,
    l_param1: LPARAM,
    l_param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamConvert(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdw_convert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamPrepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdw_prepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamUnprepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdw_unprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (56)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2A;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSA;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2A;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2A;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSA;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2A;
        pub const AUXCAPS = thismodule.AUXCAPSA;
        pub const AUXCAPS2 = thismodule.AUXCAPS2A;
        pub const MIXERCAPS = thismodule.MIXERCAPSA;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2A;
        pub const MIXERLINE = thismodule.MIXERLINEA;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLA;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTA;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSA;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBA;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCA;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEA;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBA;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCA;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEA;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCA;
        pub const sndPlaySound = thismodule.sndPlaySoundA;
        pub const PlaySound = thismodule.PlaySoundA;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsA;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextA;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsA;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextA;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsA;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextA;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsA;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextA;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsA;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsA;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoA;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsA;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsA;
        pub const acmDriverAdd = thismodule.acmDriverAddA;
        pub const acmDriverDetails = thismodule.acmDriverDetailsA;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsA;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumA;
        pub const acmFormatDetails = thismodule.acmFormatDetailsA;
        pub const acmFormatEnum = thismodule.acmFormatEnumA;
        pub const acmFormatChoose = thismodule.acmFormatChooseA;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsA;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumA;
        pub const acmFilterDetails = thismodule.acmFilterDetailsA;
        pub const acmFilterEnum = thismodule.acmFilterEnumA;
        pub const acmFilterChoose = thismodule.acmFilterChooseA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2W;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSW;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2W;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2W;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSW;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2W;
        pub const AUXCAPS = thismodule.AUXCAPSW;
        pub const AUXCAPS2 = thismodule.AUXCAPS2W;
        pub const MIXERCAPS = thismodule.MIXERCAPSW;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2W;
        pub const MIXERLINE = thismodule.MIXERLINEW;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLW;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTW;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSW;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBW;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCW;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEW;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBW;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCW;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEW;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCW;
        pub const sndPlaySound = thismodule.sndPlaySoundW;
        pub const PlaySound = thismodule.PlaySoundW;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsW;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextW;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsW;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextW;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsW;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextW;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsW;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextW;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsW;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsW;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoW;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsW;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsW;
        pub const acmDriverAdd = thismodule.acmDriverAddW;
        pub const acmDriverDetails = thismodule.acmDriverDetailsW;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsW;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumW;
        pub const acmFormatDetails = thismodule.acmFormatDetailsW;
        pub const acmFormatEnum = thismodule.acmFormatEnumW;
        pub const acmFormatChoose = thismodule.acmFormatChooseW;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsW;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumW;
        pub const acmFilterDetails = thismodule.acmFilterDetailsW;
        pub const acmFilterEnum = thismodule.acmFilterEnumW;
        pub const acmFilterChoose = thismodule.acmFilterChooseW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque {};
        pub const WAVEOUTCAPS2 = *opaque {};
        pub const WAVEINCAPS = *opaque {};
        pub const WAVEINCAPS2 = *opaque {};
        pub const MIDIOUTCAPS = *opaque {};
        pub const MIDIOUTCAPS2 = *opaque {};
        pub const MIDIINCAPS = *opaque {};
        pub const MIDIINCAPS2 = *opaque {};
        pub const AUXCAPS = *opaque {};
        pub const AUXCAPS2 = *opaque {};
        pub const MIXERCAPS = *opaque {};
        pub const MIXERCAPS2 = *opaque {};
        pub const MIXERLINE = *opaque {};
        pub const MIXERCONTROL = *opaque {};
        pub const MIXERLINECONTROLS = *opaque {};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque {};
        pub const ACMDRIVERDETAILS = *opaque {};
        pub const ACMFORMATTAGDETAILS = *opaque {};
        pub const ACMFORMATTAGENUMCB = *opaque {};
        pub const ACMFORMATENUMCB = *opaque {};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque {};
        pub const ACMFORMATCHOOSE = *opaque {};
        pub const ACMFILTERTAGDETAILS = *opaque {};
        pub const ACMFILTERTAGENUMCB = *opaque {};
        pub const ACMFILTERDETAILS = *opaque {};
        pub const ACMFILTERENUMCB = *opaque {};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque {};
        pub const ACMFILTERCHOOSE = *opaque {};
        pub const tACMDRVOPENDESC = *opaque {};
        pub const sndPlaySound = *opaque {};
        pub const PlaySound = *opaque {};
        pub const waveOutGetDevCaps = *opaque {};
        pub const waveOutGetErrorText = *opaque {};
        pub const waveInGetDevCaps = *opaque {};
        pub const waveInGetErrorText = *opaque {};
        pub const midiOutGetDevCaps = *opaque {};
        pub const midiOutGetErrorText = *opaque {};
        pub const midiInGetDevCaps = *opaque {};
        pub const midiInGetErrorText = *opaque {};
        pub const auxGetDevCaps = *opaque {};
        pub const mixerGetDevCaps = *opaque {};
        pub const mixerGetLineInfo = *opaque {};
        pub const mixerGetLineControls = *opaque {};
        pub const mixerGetControlDetails = *opaque {};
        pub const acmDriverAdd = *opaque {};
        pub const acmDriverDetails = *opaque {};
        pub const acmFormatTagDetails = *opaque {};
        pub const acmFormatTagEnum = *opaque {};
        pub const acmFormatDetails = *opaque {};
        pub const acmFormatEnum = *opaque {};
        pub const acmFormatChoose = *opaque {};
        pub const acmFilterTagDetails = *opaque {};
        pub const acmFilterTagEnum = *opaque {};
        pub const acmFilterDetails = *opaque {};
        pub const acmFilterEnum = *opaque {};
        pub const acmFilterChoose = *opaque {};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const ACMDRIVERDETAILS = @compileError("'ACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGDETAILS = @compileError("'ACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSE = @compileError("'ACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGDETAILS = @compileError("'ACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERDETAILS = @compileError("'ACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSE = @compileError("'ACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const tACMDRVOPENDESC = @compileError("'tACMDRVOPENDESC' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (23)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CHAR = @import("../foundation.zig").CHAR;
const CLSCTX = @import("../system/com.zig").CLSCTX;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDRVR = @import("../media/multimedia.zig").HDRVR;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HTASK = @import("../media.zig").HTASK;
const HWND = @import("../foundation.zig").HWND;
const INTERFACEINFO = @import("../system/com.zig").INTERFACEINFO;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MMTIME = @import("../media.zig").MMTIME;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const STGM = @import("../system/com/structured_storage.zig").STGM;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPWAVECALLBACK")) {
        _ = LPWAVECALLBACK;
    }
    if (@hasDecl(@This(), "LPMIDICALLBACK")) {
        _ = LPMIDICALLBACK;
    }
    if (@hasDecl(@This(), "ACMDRIVERENUMCB")) {
        _ = ACMDRIVERENUMCB;
    }
    if (@hasDecl(@This(), "LPACMDRIVERPROC")) {
        _ = LPACMDRIVERPROC;
    }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBA")) {
        _ = ACMFORMATTAGENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBW")) {
        _ = ACMFORMATTAGENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFORMATENUMCBA")) {
        _ = ACMFORMATENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFORMATENUMCBW")) {
        _ = ACMFORMATENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCA")) {
        _ = ACMFORMATCHOOSEHOOKPROCA;
    }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCW")) {
        _ = ACMFORMATCHOOSEHOOKPROCW;
    }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBA")) {
        _ = ACMFILTERTAGENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBW")) {
        _ = ACMFILTERTAGENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFILTERENUMCBA")) {
        _ = ACMFILTERENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFILTERENUMCBW")) {
        _ = ACMFILTERENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCA")) {
        _ = ACMFILTERCHOOSEHOOKPROCA;
    }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCW")) {
        _ = ACMFILTERCHOOSEHOOKPROCW;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (5)
//--------------------------------------------------------------------------------
pub const apo = @import("audio/apo.zig");
pub const direct_music = @import("audio/direct_music.zig");
pub const direct_sound = @import("audio/direct_sound.zig");
pub const endpoints = @import("audio/endpoints.zig");
pub const xaudio2 = @import("audio/xaudio2.zig");
