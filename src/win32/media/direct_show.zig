//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1017)
//--------------------------------------------------------------------------------
pub const EC_SND_DEVICE_ERROR_BASE = @as(u32, 512);
pub const EC_SNDDEV_IN_ERROR = @as(u32, 512);
pub const EC_SNDDEV_OUT_ERROR = @as(u32, 513);
pub const EC_SYSTEMBASE = @as(u32, 0);
pub const EC_USER = @as(u32, 32768);
pub const EC_COMPLETE = @as(u32, 1);
pub const EC_USERABORT = @as(u32, 2);
pub const EC_ERRORABORT = @as(u32, 3);
pub const EC_TIME = @as(u32, 4);
pub const EC_REPAINT = @as(u32, 5);
pub const EC_STREAM_ERROR_STOPPED = @as(u32, 6);
pub const EC_STREAM_ERROR_STILLPLAYING = @as(u32, 7);
pub const EC_ERROR_STILLPLAYING = @as(u32, 8);
pub const EC_PALETTE_CHANGED = @as(u32, 9);
pub const EC_VIDEO_SIZE_CHANGED = @as(u32, 10);
pub const EC_QUALITY_CHANGE = @as(u32, 11);
pub const EC_SHUTTING_DOWN = @as(u32, 12);
pub const EC_CLOCK_CHANGED = @as(u32, 13);
pub const EC_PAUSED = @as(u32, 14);
pub const EC_OPENING_FILE = @as(u32, 16);
pub const EC_BUFFERING_DATA = @as(u32, 17);
pub const EC_FULLSCREEN_LOST = @as(u32, 18);
pub const EC_ACTIVATE = @as(u32, 19);
pub const EC_NEED_RESTART = @as(u32, 20);
pub const EC_WINDOW_DESTROYED = @as(u32, 21);
pub const EC_DISPLAY_CHANGED = @as(u32, 22);
pub const EC_STARVATION = @as(u32, 23);
pub const EC_OLE_EVENT = @as(u32, 24);
pub const EC_NOTIFY_WINDOW = @as(u32, 25);
pub const EC_STREAM_CONTROL_STOPPED = @as(u32, 26);
pub const EC_STREAM_CONTROL_STARTED = @as(u32, 27);
pub const EC_END_OF_SEGMENT = @as(u32, 28);
pub const EC_SEGMENT_STARTED = @as(u32, 29);
pub const EC_LENGTH_CHANGED = @as(u32, 30);
pub const EC_DEVICE_LOST = @as(u32, 31);
pub const EC_SAMPLE_NEEDED = @as(u32, 32);
pub const EC_PROCESSING_LATENCY = @as(u32, 33);
pub const EC_SAMPLE_LATENCY = @as(u32, 34);
pub const EC_SCRUB_TIME = @as(u32, 35);
pub const EC_STEP_COMPLETE = @as(u32, 36);
pub const EC_TIMECODE_AVAILABLE = @as(u32, 48);
pub const EC_EXTDEVICE_MODE_CHANGE = @as(u32, 49);
pub const EC_STATE_CHANGE = @as(u32, 50);
pub const EC_GRAPH_CHANGED = @as(u32, 80);
pub const EC_CLOCK_UNSET = @as(u32, 81);
pub const EC_VMR_RENDERDEVICE_SET = @as(u32, 83);
pub const VMR_RENDER_DEVICE_OVERLAY = @as(u32, 1);
pub const VMR_RENDER_DEVICE_VIDMEM = @as(u32, 2);
pub const VMR_RENDER_DEVICE_SYSMEM = @as(u32, 4);
pub const EC_VMR_SURFACE_FLIPPED = @as(u32, 84);
pub const EC_VMR_RECONNECTION_FAILED = @as(u32, 85);
pub const EC_PREPROCESS_COMPLETE = @as(u32, 86);
pub const EC_CODECAPI_EVENT = @as(u32, 87);
pub const EC_WMT_EVENT_BASE = @as(u32, 593);
pub const EC_WMT_INDEX_EVENT = @as(u32, 593);
pub const EC_WMT_EVENT = @as(u32, 594);
pub const EC_BUILT = @as(u32, 768);
pub const EC_UNBUILT = @as(u32, 769);
pub const EC_SKIP_FRAMES = @as(u32, 37);
pub const EC_PLEASE_REOPEN = @as(u32, 64);
pub const EC_STATUS = @as(u32, 65);
pub const EC_MARKER_HIT = @as(u32, 66);
pub const EC_LOADSTATUS = @as(u32, 67);
pub const EC_FILE_CLOSED = @as(u32, 68);
pub const EC_ERRORABORTEX = @as(u32, 69);
pub const AM_LOADSTATUS_CLOSED = @as(u32, 0);
pub const AM_LOADSTATUS_LOADINGDESCR = @as(u32, 1);
pub const AM_LOADSTATUS_LOADINGMCAST = @as(u32, 2);
pub const AM_LOADSTATUS_LOCATING = @as(u32, 3);
pub const AM_LOADSTATUS_CONNECTING = @as(u32, 4);
pub const AM_LOADSTATUS_OPENING = @as(u32, 5);
pub const AM_LOADSTATUS_OPEN = @as(u32, 6);
pub const EC_NEW_PIN = @as(u32, 32);
pub const EC_RENDER_FINISHED = @as(u32, 33);
pub const EC_EOS_SOON = @as(u32, 70);
pub const EC_CONTENTPROPERTY_CHANGED = @as(u32, 71);
pub const AM_CONTENTPROPERTY_TITLE = @as(u32, 1);
pub const AM_CONTENTPROPERTY_AUTHOR = @as(u32, 2);
pub const AM_CONTENTPROPERTY_COPYRIGHT = @as(u32, 4);
pub const AM_CONTENTPROPERTY_DESCRIPTION = @as(u32, 8);
pub const EC_BANDWIDTHCHANGE = @as(u32, 72);
pub const EC_VIDEOFRAMEREADY = @as(u32, 73);
pub const EC_DVDBASE = @as(u32, 256);
pub const EC_DVD_DOMAIN_CHANGE = @as(u32, 257);
pub const EC_DVD_TITLE_CHANGE = @as(u32, 258);
pub const EC_DVD_CHAPTER_START = @as(u32, 259);
pub const EC_DVD_AUDIO_STREAM_CHANGE = @as(u32, 260);
pub const EC_DVD_SUBPICTURE_STREAM_CHANGE = @as(u32, 261);
pub const EC_DVD_ANGLE_CHANGE = @as(u32, 262);
pub const EC_DVD_BUTTON_CHANGE = @as(u32, 263);
pub const EC_DVD_VALID_UOPS_CHANGE = @as(u32, 264);
pub const EC_DVD_STILL_ON = @as(u32, 265);
pub const EC_DVD_STILL_OFF = @as(u32, 266);
pub const EC_DVD_CURRENT_TIME = @as(u32, 267);
pub const EC_DVD_ERROR = @as(u32, 268);
pub const EC_DVD_WARNING = @as(u32, 269);
pub const EC_DVD_CHAPTER_AUTOSTOP = @as(u32, 270);
pub const EC_DVD_NO_FP_PGC = @as(u32, 271);
pub const EC_DVD_PLAYBACK_RATE_CHANGE = @as(u32, 272);
pub const EC_DVD_PARENTAL_LEVEL_CHANGE = @as(u32, 273);
pub const EC_DVD_PLAYBACK_STOPPED = @as(u32, 274);
pub const EC_DVD_ANGLES_AVAILABLE = @as(u32, 275);
pub const EC_DVD_PLAYPERIOD_AUTOSTOP = @as(u32, 276);
pub const EC_DVD_BUTTON_AUTO_ACTIVATED = @as(u32, 277);
pub const EC_DVD_CMD_START = @as(u32, 278);
pub const EC_DVD_CMD_END = @as(u32, 279);
pub const EC_DVD_DISC_EJECTED = @as(u32, 280);
pub const EC_DVD_DISC_INSERTED = @as(u32, 281);
pub const EC_DVD_CURRENT_HMSF_TIME = @as(u32, 282);
pub const EC_DVD_KARAOKE_MODE = @as(u32, 283);
pub const EC_DVD_PROGRAM_CELL_CHANGE = @as(u32, 284);
pub const EC_DVD_TITLE_SET_CHANGE = @as(u32, 285);
pub const EC_DVD_PROGRAM_CHAIN_CHANGE = @as(u32, 286);
pub const EC_DVD_VOBU_Offset = @as(u32, 287);
pub const EC_DVD_VOBU_Timestamp = @as(u32, 288);
pub const EC_DVD_GPRM_Change = @as(u32, 289);
pub const EC_DVD_SPRM_Change = @as(u32, 290);
pub const EC_DVD_BeginNavigationCommands = @as(u32, 291);
pub const EC_DVD_NavigationCommand = @as(u32, 292);
pub const AM_AC3_ALTERNATE_AUDIO_1 = @as(u32, 1);
pub const AM_AC3_ALTERNATE_AUDIO_2 = @as(u32, 2);
pub const AM_AC3_ALTERNATE_AUDIO_BOTH = @as(u32, 3);
pub const AM_AC3_SERVICE_MAIN_AUDIO = @as(u32, 0);
pub const AM_AC3_SERVICE_NO_DIALOG = @as(u32, 1);
pub const AM_AC3_SERVICE_VISUALLY_IMPAIRED = @as(u32, 2);
pub const AM_AC3_SERVICE_HEARING_IMPAIRED = @as(u32, 3);
pub const AM_AC3_SERVICE_DIALOG_ONLY = @as(u32, 4);
pub const AM_AC3_SERVICE_COMMENTARY = @as(u32, 5);
pub const AM_AC3_SERVICE_EMERGENCY_FLASH = @as(u32, 6);
pub const AM_AC3_SERVICE_VOICE_OVER = @as(u32, 7);
pub const AM_UseNewCSSKey = @as(u32, 1);
pub const AM_ReverseBlockStart = @as(u32, 2);
pub const AM_ReverseBlockEnd = @as(u32, 4);
pub const AM_DVD_CGMS_RESERVED_MASK = @as(u32, 120);
pub const AM_DVD_CGMS_COPY_PROTECT_MASK = @as(u32, 24);
pub const AM_DVD_CGMS_COPY_PERMITTED = @as(u32, 0);
pub const AM_DVD_CGMS_COPY_ONCE = @as(u32, 16);
pub const AM_DVD_CGMS_NO_COPY = @as(u32, 24);
pub const AM_DVD_COPYRIGHT_MASK = @as(u32, 64);
pub const AM_DVD_NOT_COPYRIGHTED = @as(u32, 0);
pub const AM_DVD_COPYRIGHTED = @as(u32, 64);
pub const AM_DVD_SECTOR_PROTECT_MASK = @as(u32, 32);
pub const AM_DVD_SECTOR_NOT_PROTECTED = @as(u32, 0);
pub const AM_DVD_SECTOR_PROTECTED = @as(u32, 32);
pub const AMINTERLACE_IsInterlaced = @as(u32, 1);
pub const AMINTERLACE_1FieldPerSample = @as(u32, 2);
pub const AMINTERLACE_Field1First = @as(u32, 4);
pub const AMINTERLACE_UNUSED = @as(u32, 8);
pub const AMINTERLACE_FieldPatternMask = @as(u32, 48);
pub const AMINTERLACE_FieldPatField1Only = @as(u32, 0);
pub const AMINTERLACE_FieldPatField2Only = @as(u32, 16);
pub const AMINTERLACE_FieldPatBothRegular = @as(u32, 32);
pub const AMINTERLACE_FieldPatBothIrregular = @as(u32, 48);
pub const AMINTERLACE_DisplayModeMask = @as(u32, 192);
pub const AMINTERLACE_DisplayModeBobOnly = @as(u32, 0);
pub const AMINTERLACE_DisplayModeWeaveOnly = @as(u32, 64);
pub const AMINTERLACE_DisplayModeBobOrWeave = @as(u32, 128);
pub const AMCOPYPROTECT_RestrictDuplication = @as(u32, 1);
pub const AMCONTROL_USED = @as(u32, 1);
pub const AMCONTROL_PAD_TO_4x3 = @as(u32, 2);
pub const AMCONTROL_PAD_TO_16x9 = @as(u32, 4);
pub const AMCONTROL_COLORINFO_PRESENT = @as(u32, 128);
pub const AM_VIDEO_FLAG_FIELD_MASK = @as(i32, 3);
pub const AM_VIDEO_FLAG_INTERLEAVED_FRAME = @as(i32, 0);
pub const AM_VIDEO_FLAG_FIELD1 = @as(i32, 1);
pub const AM_VIDEO_FLAG_FIELD2 = @as(i32, 2);
pub const AM_VIDEO_FLAG_FIELD1FIRST = @as(i32, 4);
pub const AM_VIDEO_FLAG_WEAVE = @as(i32, 8);
pub const AM_VIDEO_FLAG_IPB_MASK = @as(i32, 48);
pub const AM_VIDEO_FLAG_I_SAMPLE = @as(i32, 0);
pub const AM_VIDEO_FLAG_P_SAMPLE = @as(i32, 16);
pub const AM_VIDEO_FLAG_B_SAMPLE = @as(i32, 32);
pub const AM_VIDEO_FLAG_REPEAT_FIELD = @as(i32, 64);
pub const AVIF_HASINDEX = @as(u32, 16);
pub const AVIF_MUSTUSEINDEX = @as(u32, 32);
pub const AVIF_ISINTERLEAVED = @as(u32, 256);
pub const AVIF_TRUSTCKTYPE = @as(u32, 2048);
pub const AVIF_WASCAPTUREFILE = @as(u32, 65536);
pub const AVIF_COPYRIGHTED = @as(u32, 131072);
pub const AVI_HEADERSIZE = @as(u32, 2048);
pub const AVISF_DISABLED = @as(u32, 1);
pub const AVISF_VIDEO_PALCHANGES = @as(u32, 65536);
pub const AVIIF_LIST = @as(i32, 1);
pub const AVIIF_KEYFRAME = @as(i32, 16);
pub const AVIIF_FIRSTPART = @as(i32, 32);
pub const AVIIF_LASTPART = @as(i32, 64);
pub const AVIIF_NOTIME = @as(i32, 256);
pub const AVIIF_COMPUSE = @as(i32, 268369920);
pub const AVIIF_NO_TIME = @as(u32, 256);
pub const AVIIF_COMPRESSOR = @as(u32, 268369920);
pub const TIMECODE_RATE_30DROP = @as(u32, 0);
pub const TIMECODE_SMPTE_BINARY_GROUP = @as(u32, 7);
pub const TIMECODE_SMPTE_COLOR_FRAME = @as(u32, 8);
pub const AVI_INDEX_OF_INDEXES = @as(u32, 0);
pub const AVI_INDEX_OF_CHUNKS = @as(u32, 1);
pub const AVI_INDEX_OF_TIMED_CHUNKS = @as(u32, 2);
pub const AVI_INDEX_OF_SUB_2FIELD = @as(u32, 3);
pub const AVI_INDEX_IS_DATA = @as(u32, 128);
pub const AVI_INDEX_SUB_DEFAULT = @as(u32, 0);
pub const AVI_INDEX_SUB_2FIELD = @as(u32, 1);
pub const STDINDEXSIZE = @as(u32, 16384);
pub const AVISTDINDEX_DELTAFRAME = @as(u32, 2147483648);
pub const AMVA_TYPEINDEX_OUTPUTFRAME = @as(u32, 4294967295);
pub const AMVA_QUERYRENDERSTATUSF_READ = @as(u32, 1);
pub const MIN_DIMENSION = @as(u32, 1);
pub const BDA_PLP_ID_NOT_SET = @as(i32, -1);
pub const CDEF_CLASS_DEFAULT = @as(u32, 1);
pub const CDEF_BYPASS_CLASS_MANAGER = @as(u32, 2);
pub const CDEF_MERIT_ABOVE_DO_NOT_USE = @as(u32, 8);
pub const CDEF_DEVMON_CMGR_DEVICE = @as(u32, 16);
pub const CDEF_DEVMON_DMO = @as(u32, 32);
pub const CDEF_DEVMON_PNP_DEVICE = @as(u32, 64);
pub const CDEF_DEVMON_FILTER = @as(u32, 128);
pub const CDEF_DEVMON_SELECTIVE_MASK = @as(u32, 240);
pub const CHARS_IN_GUID = @as(u32, 39);
pub const MAX_PIN_NAME = @as(u32, 128);
pub const MAX_FILTER_NAME = @as(u32, 128);
pub const AM_GBF_PREVFRAMESKIPPED = @as(u32, 1);
pub const AM_GBF_NOTASYNCPOINT = @as(u32, 2);
pub const AM_GBF_NOWAIT = @as(u32, 4);
pub const AM_GBF_NODDSURFACELOCK = @as(u32, 8);
pub const AMF_AUTOMATICGAIN = @as(f64, -1);
pub const AnalogVideo_NTSC_Mask = @as(u32, 7);
pub const AnalogVideo_PAL_Mask = @as(u32, 1052656);
pub const AnalogVideo_SECAM_Mask = @as(u32, 1044480);
pub const MPEG2_PROGRAM_STREAM_MAP = @as(u32, 0);
pub const MPEG2_PROGRAM_ELEMENTARY_STREAM = @as(u32, 1);
pub const MPEG2_PROGRAM_DIRECTORY_PES_PACKET = @as(u32, 2);
pub const MPEG2_PROGRAM_PACK_HEADER = @as(u32, 3);
pub const MPEG2_PROGRAM_PES_STREAM = @as(u32, 4);
pub const MPEG2_PROGRAM_SYSTEM_HEADER = @as(u32, 5);
pub const SUBSTREAM_FILTER_VAL_NONE = @as(u32, 268435456);
pub const AM_GETDECODERCAP_QUERY_VMR_SUPPORT = @as(u32, 1);
pub const VMR_NOTSUPPORTED = @as(u32, 0);
pub const VMR_SUPPORTED = @as(u32, 1);
pub const AM_QUERY_DECODER_VMR_SUPPORT = @as(u32, 1);
pub const AM_QUERY_DECODER_DXVA_1_SUPPORT = @as(u32, 2);
pub const AM_QUERY_DECODER_DVD_SUPPORT = @as(u32, 3);
pub const AM_QUERY_DECODER_ATSC_SD_SUPPORT = @as(u32, 4);
pub const AM_QUERY_DECODER_ATSC_HD_SUPPORT = @as(u32, 5);
pub const AM_GETDECODERCAP_QUERY_VMR9_SUPPORT = @as(u32, 6);
pub const AM_GETDECODERCAP_QUERY_EVR_SUPPORT = @as(u32, 7);
pub const DECODER_CAP_NOTSUPPORTED = @as(u32, 0);
pub const DECODER_CAP_SUPPORTED = @as(u32, 1);
pub const VMRBITMAP_DISABLE = @as(u32, 1);
pub const VMRBITMAP_HDC = @as(u32, 2);
pub const VMRBITMAP_ENTIREDDS = @as(u32, 4);
pub const VMRBITMAP_SRCCOLORKEY = @as(u32, 8);
pub const VMRBITMAP_SRCRECT = @as(u32, 16);
pub const DVD_TITLE_MENU = @as(u32, 0);
pub const DVD_STREAM_DATA_CURRENT = @as(u32, 2048);
pub const DVD_STREAM_DATA_VMGM = @as(u32, 1024);
pub const DVD_STREAM_DATA_VTSM = @as(u32, 1025);
pub const DVD_DEFAULT_AUDIO_STREAM = @as(u32, 15);
pub const DVD_AUDIO_CAPS_AC3 = @as(u32, 1);
pub const DVD_AUDIO_CAPS_MPEG2 = @as(u32, 2);
pub const DVD_AUDIO_CAPS_LPCM = @as(u32, 4);
pub const DVD_AUDIO_CAPS_DTS = @as(u32, 8);
pub const DVD_AUDIO_CAPS_SDDS = @as(u32, 16);
pub const MEDIATYPE_MPEG2_PACK = Guid.initString("36523b13-8ee5-11d1-8ca3-0060b057664a");
pub const PBDA_AUX_CONNECTOR_TYPE_SVideo = Guid.initString("a0e905f4-24c9-4a54-b761-213355efc13a");
pub const PBDA_AUX_CONNECTOR_TYPE_Composite = Guid.initString("f6298b4c-c725-4d42-849b-410bbb14ea62");
pub const CLSID_PBDA_AUX_DATA_TYPE = Guid.initString("fd456373-3323-4090-adca-8ed45f55cf10");
pub const CLSID_PBDA_Encoder_DATA_TYPE = Guid.initString("728fd6bc-5546-4716-b103-f899f5a1fa68");
pub const PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII = @as(u32, 0);
pub const PBDA_Encoder_Audio_AlgorithmType_AC3 = @as(u32, 1);
pub const PBDA_Encoder_Video_MPEG2PartII = @as(u32, 0);
pub const PBDA_Encoder_Video_MPEG4Part10 = @as(u32, 1);
pub const PBDA_Encoder_Video_AVC = @as(u32, 1);
pub const PBDA_Encoder_Video_H264 = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Constant = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Variable = @as(u32, 2);
pub const PBDA_Encoder_BitrateMode_Average = @as(u32, 3);
pub const CLSID_PBDA_FDC_DATA_TYPE = Guid.initString("e7dbf9a0-22ab-4047-8e67-ef9ad504e729");
pub const CLSID_PBDA_GDDS_DATA_TYPE = Guid.initString("c80c0df3-6052-4c16-9f56-c44c21f73c45");
pub const LIBID_QuartzNetTypeLib = Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const LIBID_QuartzTypeLib = Guid.initString("56a868b0-0ad4-11ce-b03a-0020af0ba770");
pub const CLSID_AMMultiMediaStream = Guid.initString("49c47ce5-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMDirectDrawStream = Guid.initString("49c47ce4-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioStream = Guid.initString("8496e040-af4c-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioData = Guid.initString("f2468580-af8a-11d0-8212-00c04fc32c45");
pub const CLSID_AMMediaTypeStream = Guid.initString("cf0f2f7c-f7bf-11d0-900d-00c04fd9189d");
pub const AMDDS_NONE = @as(u32, 0);
pub const AMDDS_DCIPS = @as(u32, 1);
pub const AMDDS_PS = @as(u32, 2);
pub const AMDDS_RGBOVR = @as(u32, 4);
pub const AMDDS_YUVOVR = @as(u32, 8);
pub const AMDDS_RGBOFF = @as(u32, 16);
pub const AMDDS_YUVOFF = @as(u32, 32);
pub const AMDDS_RGBFLP = @as(u32, 64);
pub const AMDDS_YUVFLP = @as(u32, 128);
pub const AMDDS_ALL = @as(u32, 255);
pub const AMDDS_DEFAULT = @as(u32, 255);
pub const iPALETTE_COLORS = @as(u32, 256);
pub const iEGA_COLORS = @as(u32, 16);
pub const iMASK_COLORS = @as(u32, 3);
pub const iTRUECOLOR = @as(u32, 16);
pub const iRED = @as(u32, 0);
pub const iGREEN = @as(u32, 1);
pub const iBLUE = @as(u32, 2);
pub const iPALETTE = @as(u32, 8);
pub const iMAXBITS = @as(u32, 8);
pub const MAX_SIZE_MPEG1_SEQUENCE_INFO = @as(u32, 140);
pub const CLSID_DMOWrapperFilter = Guid.initString("94297043-bd82-4dfd-b0de-8177739c6d20");
pub const CLSID_DMOFilterCategory = Guid.initString("bcd5796c-bd52-4d30-ab76-70f975b89199");
pub const AM_MPEG_AUDIO_DUAL_MERGE = @as(u32, 0);
pub const AM_MPEG_AUDIO_DUAL_LEFT = @as(u32, 1);
pub const AM_MPEG_AUDIO_DUAL_RIGHT = @as(u32, 2);
pub const VFW_FIRST_CODE = @as(u32, 512);
pub const MAX_ERROR_TEXT_LEN = @as(u32, 160);
pub const MPBOOL_TRUE = @as(u32, 1);
pub const MPBOOL_FALSE = @as(u32, 0);
pub const DWORD_ALLPARAMS = @as(i32, -1);
pub const GUID_TIME_REFERENCE = Guid.initString("93ad712b-daa0-4ffe-bc81-b0ce500fcdd9");
pub const GUID_TIME_MUSIC = Guid.initString("0574c49d-5b04-4b15-a542-ae282030117b");
pub const GUID_TIME_SAMPLES = Guid.initString("a8593d05-0c43-4984-9a63-97af9e02c4c0");
pub const MPF_ENVLP_STANDARD = @as(u32, 0);
pub const MPF_ENVLP_BEGIN_CURRENTVAL = @as(u32, 1);
pub const MPF_ENVLP_BEGIN_NEUTRALVAL = @as(u32, 2);
pub const MPF_PUNCHIN_REFTIME = @as(u32, 0);
pub const MPF_PUNCHIN_NOW = @as(u32, 1);
pub const MPF_PUNCHIN_STOPPED = @as(u32, 2);
pub const MSPID_PrimaryVideo = Guid.initString("a35ff56a-9fda-11d0-8fdf-00c04fd9189d");
pub const MSPID_PrimaryAudio = Guid.initString("a35ff56b-9fda-11d0-8fdf-00c04fd9189d");
pub const VFW_E_INVALIDMEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const VFW_E_INVALIDSUBTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const VFW_E_NEED_OWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const VFW_E_ENUM_OUT_OF_SYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const VFW_E_ALREADY_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const VFW_E_FILTER_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const VFW_E_NO_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const VFW_E_NO_ACCEPTABLE_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const VFW_E_INVALID_DIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const VFW_E_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const VFW_E_NO_ALLOCATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const VFW_E_RUNTIME_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const VFW_E_BUFFER_NOTSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const VFW_E_BUFFER_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const VFW_E_BADALIGN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const VFW_E_ALREADY_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const VFW_E_BUFFERS_OUTSTANDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const VFW_E_NOT_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const VFW_E_SIZENOTSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const VFW_E_NO_CLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const VFW_E_NO_SINK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const VFW_E_NO_INTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const VFW_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const VFW_E_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const VFW_E_CANNOT_RENDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const VFW_E_CHANGING_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const VFW_E_NO_COLOR_KEY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const VFW_E_NOT_OVERLAY_CONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const VFW_E_NOT_SAMPLE_CONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const VFW_E_PALETTE_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const VFW_E_COLOR_KEY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const VFW_E_NO_COLOR_KEY_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const VFW_E_NO_PALETTE_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const VFW_E_NO_DISPLAY_PALETTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const VFW_E_TOO_MANY_COLORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const VFW_E_STATE_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const VFW_E_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const VFW_E_NOT_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const VFW_E_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const VFW_E_WRONG_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const VFW_E_START_TIME_AFTER_END = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const VFW_E_INVALID_RECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const VFW_E_TYPE_NOT_ACCEPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const VFW_E_SAMPLE_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const VFW_E_SAMPLE_REJECTED_EOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const VFW_E_DUPLICATE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const VFW_S_DUPLICATE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262701));
pub const VFW_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));
pub const VFW_E_INVALID_FILE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220945));
pub const VFW_E_ENUM_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220944));
pub const VFW_E_CIRCULAR_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220943));
pub const VFW_E_NOT_ALLOWED_TO_SAVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220942));
pub const VFW_E_TIME_ALREADY_PASSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220941));
pub const VFW_E_ALREADY_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220940));
pub const VFW_E_CORRUPT_GRAPH_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220939));
pub const VFW_E_ADVISE_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220938));
pub const VFW_S_STATE_INTERMEDIATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262711));
pub const VFW_E_NO_MODEX_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220936));
pub const VFW_E_NO_ADVISE_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220935));
pub const VFW_E_NO_FULLSCREEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220934));
pub const VFW_E_IN_FULLSCREEN_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220933));
pub const VFW_E_UNKNOWN_FILE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220928));
pub const VFW_E_CANNOT_LOAD_SOURCE_FILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220927));
pub const VFW_S_PARTIAL_RENDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262722));
pub const VFW_E_FILE_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220925));
pub const VFW_E_INVALID_FILE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220924));
pub const VFW_S_SOME_DATA_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262725));
pub const VFW_S_CONNECTIONS_DEFERRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262726));
pub const VFW_E_INVALID_CLSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220921));
pub const VFW_E_INVALID_MEDIA_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220920));
pub const VFW_E_BAD_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220494));
pub const VFW_S_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262403));
pub const VFW_E_SAMPLE_TIME_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220919));
pub const VFW_S_RESOURCE_NOT_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262736));
pub const VFW_E_MEDIA_TIME_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220911));
pub const VFW_E_NO_TIME_FORMAT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220910));
pub const VFW_E_MONO_AUDIO_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220909));
pub const VFW_S_MEDIA_TYPE_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262740));
pub const VFW_E_NO_DECOMPRESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220907));
pub const VFW_E_NO_AUDIO_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220906));
pub const VFW_S_VIDEO_NOT_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262743));
pub const VFW_S_AUDIO_NOT_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262744));
pub const VFW_E_RPZA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220903));
pub const VFW_S_RPZA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262746));
pub const VFW_E_PROCESSOR_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220901));
pub const VFW_E_UNSUPPORTED_AUDIO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220900));
pub const VFW_E_UNSUPPORTED_VIDEO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220899));
pub const VFW_E_MPEG_NOT_CONSTRAINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220898));
pub const VFW_E_NOT_IN_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220897));
pub const VFW_S_ESTIMATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262752));
pub const VFW_E_NO_TIME_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220895));
pub const VFW_E_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220894));
pub const VFW_S_RESERVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262755));
pub const VFW_E_BUFFER_UNDERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220892));
pub const VFW_E_UNSUPPORTED_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220891));
pub const VFW_E_NO_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220890));
pub const VFW_S_STREAM_OFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262759));
pub const VFW_S_CANT_CUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262760));
pub const VFW_E_BAD_VIDEOCD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220887));
pub const VFW_S_NO_STOP_TIME = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262768));
pub const VFW_E_OUT_OF_VIDEO_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220879));
pub const VFW_E_VP_NEGOTIATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220878));
pub const VFW_E_DDRAW_CAPS_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220877));
pub const VFW_E_NO_VP_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220876));
pub const VFW_E_NO_CAPTURE_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220875));
pub const VFW_E_DVD_OPERATION_INHIBITED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220874));
pub const VFW_E_DVD_INVALIDDOMAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220873));
pub const VFW_E_DVD_NO_BUTTON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220872));
pub const VFW_E_DVD_GRAPHNOTREADY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220871));
pub const VFW_E_DVD_RENDERFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220870));
pub const VFW_E_DVD_DECNOTENOUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220869));
pub const VFW_E_DDRAW_VERSION_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220868));
pub const VFW_E_COPYPROT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220867));
pub const VFW_S_NOPREVIEWPIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262782));
pub const VFW_E_TIME_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220865));
pub const VFW_S_DVD_NON_ONE_SEQUENTIAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262784));
pub const VFW_E_DVD_WRONG_SPEED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220863));
pub const VFW_E_DVD_MENU_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220862));
pub const VFW_E_DVD_CMD_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220861));
pub const VFW_E_DVD_STATE_WRONG_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220860));
pub const VFW_E_DVD_STATE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220859));
pub const VFW_E_DVD_STATE_WRONG_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220858));
pub const VFW_E_DVD_INCOMPATIBLE_REGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220857));
pub const VFW_E_DVD_NO_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220856));
pub const VFW_E_DVD_NO_GOUP_PGC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220855));
pub const VFW_E_DVD_LOW_PARENTAL_LEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220854));
pub const VFW_E_DVD_NOT_IN_KARAOKE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220853));
pub const VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262796));
pub const VFW_S_DVD_NOT_ACCURATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262797));
pub const VFW_E_FRAME_STEP_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220850));
pub const VFW_E_DVD_STREAM_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220849));
pub const VFW_E_DVD_TITLE_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220848));
pub const VFW_E_DVD_INVALID_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220847));
pub const VFW_E_DVD_NO_RESUME_INFORMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220846));
pub const VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220845));
pub const VFW_E_PIN_ALREADY_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220844));
pub const VFW_E_CERTIFICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220843));
pub const VFW_E_VMR_NOT_IN_MIXER_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220842));
pub const VFW_E_VMR_NO_AP_SUPPLIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220841));
pub const VFW_E_VMR_NO_DEINTERLACE_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220840));
pub const VFW_E_VMR_NO_PROCAMP_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220839));
pub const VFW_E_DVD_VMR9_INCOMPATIBLEDEC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220838));
pub const VFW_E_NO_COPP_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220837));
pub const VFW_E_DVD_NONBLOCKING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220836));
pub const VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220835));
pub const VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220834));
pub const VFW_E_DVD_RESOLUTION_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220833));
pub const E_PROP_SET_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147023726));
pub const E_PROP_ID_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147023728));
pub const VFW_E_CODECAPI_LINEAR_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220720));
pub const VFW_E_CODECAPI_ENUMERATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220719));
pub const VFW_E_CODECAPI_NO_DEFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220717));
pub const VFW_E_CODECAPI_NO_CURRENT_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220716));
pub const VFW_E_DVD_CHAPTER_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220715));
pub const VFW_S_DVD_RENDER_STATUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262944));
pub const CFSTR_VFW_FILTERLIST = "Video for Windows 4 Filters";
pub const DXVA_ModeNone = Guid.initString("1b81be00-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_A = Guid.initString("1b81be01-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_B = Guid.initString("1b81be02-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_A = Guid.initString("1b81be03-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_B = Guid.initString("1b81be04-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_C = Guid.initString("1b81be05-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_D = Guid.initString("1b81be06-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_E = Guid.initString("1b81be07-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_F = Guid.initString("1b81be08-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_A = Guid.initString("1b81be09-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_VLD = Guid.initString("6f3ec719-3735-42cc-8063-65cc3cb36616");
pub const DXVA_ModeMPEG2_A = Guid.initString("1b81be0a-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_B = Guid.initString("1b81be0b-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_C = Guid.initString("1b81be0c-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_D = Guid.initString("1b81be0d-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2and1_VLD = Guid.initString("86695f12-340e-4f04-9fd3-9253dd327460");
pub const DXVA_ModeH264_A = Guid.initString("1b81be64-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_B = Guid.initString("1b81be65-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_C = Guid.initString("1b81be66-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_D = Guid.initString("1b81be67-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_E = Guid.initString("1b81be68-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_F = Guid.initString("1b81be69-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_VLD_WithFMOASO_NoFGT = Guid.initString("d5f04ff9-3418-45d8-9561-32a76aae2ddd");
pub const DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT = Guid.initString("d79be8da-0cf1-4c81-b82a-69a4e236f43d");
pub const DXVA_ModeH264_VLD_Stereo_NoFGT = Guid.initString("f9aaccbb-c2b6-4cfc-8779-5707b1760552");
pub const DXVA_ModeH264_VLD_Multiview_NoFGT = Guid.initString("705b9d82-76cf-49d6-b7e6-ac8872db013c");
pub const DXVA_ModeWMV8_A = Guid.initString("1b81be80-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV8_B = Guid.initString("1b81be81-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_A = Guid.initString("1b81be90-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_B = Guid.initString("1b81be91-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_C = Guid.initString("1b81be94-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_A = Guid.initString("1b81bea0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_B = Guid.initString("1b81bea1-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_C = Guid.initString("1b81bea2-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D = Guid.initString("1b81bea3-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D2010 = Guid.initString("1b81bea4-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG4pt2_VLD_Simple = Guid.initString("efd64d74-c9e8-41d7-a5e9-e9b0e39fa319");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC = Guid.initString("ed418a9f-010d-4eda-9ae3-9a65358d8d2e");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC = Guid.initString("ab998b5b-4258-44a9-9feb-94e597a6baae");
pub const DXVA_ModeHEVC_VLD_Main = Guid.initString("5b11d51b-2f4c-4452-bcc3-09f2a1160cc0");
pub const DXVA_ModeHEVC_VLD_Main10 = Guid.initString("107af0e0-ef1a-4d19-aba8-67a163073d13");
pub const DXVA_ModeVP9_VLD_Profile0 = Guid.initString("463707f8-a1d0-4585-876d-83aa6d60b89e");
pub const DXVA_ModeVP9_VLD_10bit_Profile2 = Guid.initString("a4c749ef-6ecf-48aa-8448-50a7a1165ff7");
pub const DXVA_ModeVP8_VLD = Guid.initString("90b899ea-3a62-4705-88b3-8df04b2744e7");
pub const DXVA_ModeAV1_VLD_Profile0 = Guid.initString("b8be4ccb-cf53-46ba-8d59-d6b8a6da5d2a");
pub const DXVA_ModeAV1_VLD_Profile1 = Guid.initString("6936ff0f-45b1-4163-9cc1-646ef6946108");
pub const DXVA_ModeAV1_VLD_Profile2 = Guid.initString("0c5f2aa1-e541-4089-bb7b-98110a19d7c8");
pub const DXVA_ModeAV1_VLD_12bit_Profile2 = Guid.initString("17127009-a00f-4ce1-994e-bf4081f6f3f0");
pub const DXVA_ModeAV1_VLD_12bit_Profile2_420 = Guid.initString("2d80bed6-9cac-4835-9e91-327bbc4f9ee8");
pub const DXVA_NoEncrypt = Guid.initString("1b81bed0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_RESTRICTED_MODE_UNRESTRICTED = @as(u32, 65535);
pub const DXVA_RESTRICTED_MODE_H261_A = @as(u32, 1);
pub const DXVA_RESTRICTED_MODE_H261_B = @as(u32, 2);
pub const DXVA_RESTRICTED_MODE_H263_A = @as(u32, 3);
pub const DXVA_RESTRICTED_MODE_H263_B = @as(u32, 4);
pub const DXVA_RESTRICTED_MODE_H263_C = @as(u32, 5);
pub const DXVA_RESTRICTED_MODE_H263_D = @as(u32, 6);
pub const DXVA_RESTRICTED_MODE_H263_E = @as(u32, 7);
pub const DXVA_RESTRICTED_MODE_H263_F = @as(u32, 8);
pub const DXVA_RESTRICTED_MODE_MPEG1_A = @as(u32, 9);
pub const DXVA_RESTRICTED_MODE_MPEG2_A = @as(u32, 10);
pub const DXVA_RESTRICTED_MODE_MPEG2_B = @as(u32, 11);
pub const DXVA_RESTRICTED_MODE_MPEG2_C = @as(u32, 12);
pub const DXVA_RESTRICTED_MODE_MPEG2_D = @as(u32, 13);
pub const DXVA_RESTRICTED_MODE_MPEG1_VLD = @as(u32, 16);
pub const DXVA_RESTRICTED_MODE_MPEG2and1_VLD = @as(u32, 17);
pub const DXVA_RESTRICTED_MODE_H264_A = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_B = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_C = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_D = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_E = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_F = @as(u32, 105);
pub const DXVA_RESTRICTED_MODE_H264_VLD_WITHFMOASO_NOFGT = @as(u32, 112);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_PROGRESSIVE_NOFGT = @as(u32, 113);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_NOFGT = @as(u32, 114);
pub const DXVA_RESTRICTED_MODE_H264_VLD_MULTIVIEW_NOFGT = @as(u32, 115);
pub const DXVA_RESTRICTED_MODE_WMV8_A = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_B = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_A = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_B = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_C = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_A = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_B = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_C = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_D = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_VC1_D2010 = @as(u32, 164);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_SIMPLE = @as(u32, 176);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_NOGMC = @as(u32, 177);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_GMC = @as(u32, 178);
pub const DXVA_RESTRICTED_MODE_WMV8_POSTPROC = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_MOCOMP = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_POSTPROC = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_MOCOMP = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_IDCT = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_POSTPROC = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_MOCOMP = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_IDCT = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_VLD = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_FGT = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_VLD_NOFGT = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_VLD_FGT = @as(u32, 105);
pub const DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED = @as(u32, 0);
pub const DXVA_PICTURE_DECODE_BUFFER = @as(u32, 1);
pub const DXVA_MACROBLOCK_CONTROL_BUFFER = @as(u32, 2);
pub const DXVA_RESIDUAL_DIFFERENCE_BUFFER = @as(u32, 3);
pub const DXVA_DEBLOCKING_CONTROL_BUFFER = @as(u32, 4);
pub const DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER = @as(u32, 5);
pub const DXVA_SLICE_CONTROL_BUFFER = @as(u32, 6);
pub const DXVA_BITSTREAM_DATA_BUFFER = @as(u32, 7);
pub const DXVA_AYUV_BUFFER = @as(u32, 8);
pub const DXVA_IA44_SURFACE_BUFFER = @as(u32, 9);
pub const DXVA_DPXD_SURFACE_BUFFER = @as(u32, 10);
pub const DXVA_HIGHLIGHT_BUFFER = @as(u32, 11);
pub const DXVA_DCCMD_SURFACE_BUFFER = @as(u32, 12);
pub const DXVA_ALPHA_BLEND_COMBINATION_BUFFER = @as(u32, 13);
pub const DXVA_PICTURE_RESAMPLE_BUFFER = @as(u32, 14);
pub const DXVA_READ_BACK_BUFFER = @as(u32, 15);
pub const DXVA_MOTION_VECTOR_BUFFER = @as(u32, 16);
pub const DXVA_FILM_GRAIN_BUFFER = @as(u32, 17);
pub const DXVA_NUM_TYPES_COMP_BUFFERS = @as(u32, 18);
pub const DXVA_PICTURE_DECODING_FUNCTION = @as(u32, 1);
pub const DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION = @as(u32, 2);
pub const DXVA_ALPHA_BLEND_COMBINATION_FUNCTION = @as(u32, 3);
pub const DXVA_PICTURE_RESAMPLE_FUNCTION = @as(u32, 4);
pub const DXVA_DEBLOCKING_FILTER_FUNCTION = @as(u32, 5);
pub const DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION = @as(u32, 6);
pub const DXVA_STATUS_REPORTING_FUNCTION = @as(u32, 7);
pub const DXVA_EXECUTE_RETURN_OK = @as(u32, 0);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR = @as(u32, 1);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF = @as(u32, 2);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE = @as(u32, 3);
pub const DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE = @as(u32, 4);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY = @as(u32, 16777201);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY = @as(u32, 16777205);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY = @as(u32, 16777208);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS = @as(u32, 16777209);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY = @as(u32, 16777212);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS = @as(u32, 16777211);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS = @as(u32, 16777215);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST = @as(u32, 16776960);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL = @as(u32, 16776968);
pub const DXVA_CHROMA_FORMAT_420 = @as(u32, 1);
pub const DXVA_CHROMA_FORMAT_422 = @as(u32, 2);
pub const DXVA_CHROMA_FORMAT_444 = @as(u32, 3);
pub const DXVA_PICTURE_STRUCTURE_TOP_FIELD = @as(u32, 1);
pub const DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD = @as(u32, 2);
pub const DXVA_PICTURE_STRUCTURE_FRAME = @as(u32, 3);
pub const DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND = @as(u32, 0);
pub const DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2 = @as(u32, 0);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263 = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261 = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ZIG_ZAG = @as(u32, 0);
pub const DXVA_SCAN_METHOD_ALTERNATE_VERTICAL = @as(u32, 1);
pub const DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ARBITRARY = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_MILD = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD = @as(u32, 3);
pub const DXVA_USUAL_BLOCK_WIDTH = @as(u32, 8);
pub const DXVA_USUAL_BLOCK_HEIGHT = @as(u32, 8);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_off = @as(u32, 4);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_on = @as(u32, 5);
pub const DXVA_NumMV_OBMC_on__BinPB_off = @as(u32, 10);
pub const DXVA_NumMV_OBMC_on__BinPB_on = @as(u32, 11);
pub const DXVA_CONFIG_DATA_TYPE_IA44 = @as(u32, 0);
pub const DXVA_CONFIG_DATA_TYPE_AI44 = @as(u32, 1);
pub const DXVA_CONFIG_DATA_TYPE_DPXD = @as(u32, 2);
pub const DXVA_CONFIG_DATA_TYPE_AYUV = @as(u32, 3);
pub const DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER = @as(u32, 0);
pub const DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE = @as(u32, 1);
pub const DXVA_ExtColorData_ShiftBase = @as(u32, 8);
pub const DXVA_DeinterlaceBobDevice = Guid.initString("335aa36e-7884-43a4-9c91-7f87faf3e37e");
pub const DXVA_DeinterlaceContainerDevice = Guid.initString("0e85cb93-3046-4ff0-aecc-d58cb5f035fd");
pub const MAX_DEINTERLACE_SURFACES = @as(u32, 32);
pub const DXVA_DeinterlaceBltFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceBltExFnCode = @as(u32, 2);
pub const MAX_DEINTERLACE_DEVICE_GUIDS = @as(u32, 32);
pub const DXVA_DeinterlaceQueryAvailableModesFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceQueryModeCapsFnCode = @as(u32, 2);
pub const DXVA_ProcAmpControlDevice = Guid.initString("9f200913-2ffd-4056-9f1e-e1b508f22dcf");
pub const DXVA_ProcAmpControlQueryCapsFnCode = @as(u32, 3);
pub const DXVA_ProcAmpControlQueryRangeFnCode = @as(u32, 4);
pub const DXVA_ProcAmpControlBltFnCode = @as(u32, 1);
pub const DXVA_COPPDevice = Guid.initString("d2457add-8999-45ed-8a8a-d1aa047ba4d5");
pub const DXVA_COPPGetCertificateLengthFnCode = @as(u32, 1);
pub const DXVA_COPPKeyExchangeFnCode = @as(u32, 2);
pub const DXVA_COPPSequenceStartFnCode = @as(u32, 3);
pub const DXVA_COPPCommandFnCode = @as(u32, 4);
pub const DXVA_COPPSetProtectionLevel = Guid.initString("9bb9327c-4eb5-4727-9f00-b42b0919c0da");
pub const COPP_NoProtectionLevelAvailable = @as(i32, -1);
pub const COPP_DefaultProtectionLevel = @as(u32, 0);
pub const DXVA_COPPSetSignaling = Guid.initString("09a631a5-d684-4c60-8e4d-d3bb0f0be3ee");
pub const COPP_ImageAspectRatio_EN300294_Mask = @as(u32, 7);
pub const DXVA_COPPQueryStatusFnCode = @as(u32, 5);
pub const DXVA_COPPQueryConnectorType = Guid.initString("81d0bfd5-6afe-48c2-99c0-95a08f97c5da");
pub const DXVA_COPPQueryProtectionType = Guid.initString("38f2a801-9a6c-48bb-9107-b6696e6f1797");
pub const DXVA_COPPQueryLocalProtectionLevel = Guid.initString("b2075857-3eda-4d5d-88db-748f8c1a0549");
pub const DXVA_COPPQueryGlobalProtectionLevel = Guid.initString("1957210a-7766-452a-b99a-d27aed54f03a");
pub const DXVA_COPPQueryDisplayData = Guid.initString("d7bf1ba3-ad13-4f8e-af98-0dcb3ca204cc");
pub const DXVA_COPPQueryHDCPKeyData = Guid.initString("0db59d74-a992-492e-a0bd-c23fda564e00");
pub const DXVA_COPPQueryBusData = Guid.initString("c6f4d673-6174-4184-8e35-f6db5200bcba");
pub const DXVA_COPPQuerySignaling = Guid.initString("6629a591-3b79-4cf3-924a-11e8e7811671");
pub const DXVA2Trace_Control = Guid.initString("a0386e75-f70c-464c-a9ce-33c44e091623");
pub const DXVA2Trace_DecodeDevCreated = Guid.initString("b4de17a1-c5b2-44fe-86d5-d97a648114ff");
pub const DXVA2Trace_DecodeDevDestroyed = Guid.initString("853ebdf2-4160-421d-8893-63dcea4f18bb");
pub const DXVA2Trace_DecodeDevBeginFrame = Guid.initString("9fd1acf6-44cb-4637-bc62-2c11a9608f90");
pub const DXVA2Trace_DecodeDevExecute = Guid.initString("850aeb4c-d19a-4609-b3b4-bcbf0e22121e");
pub const DXVA2Trace_DecodeDevGetBuffer = Guid.initString("57b128fb-72cb-4137-a575-d91fa3160897");
pub const DXVA2Trace_DecodeDevEndFrame = Guid.initString("9fb3cb33-47dc-4899-98c8-c0c6cd7cd3cb");
pub const DXVA2Trace_VideoProcessDevCreated = Guid.initString("895508c6-540d-4c87-98f8-8dcbf2dabb2a");
pub const DXVA2Trace_VideoProcessDevDestroyed = Guid.initString("f97f30b1-fb49-42c7-8ee8-88bdfa92d4e2");
pub const DXVA2Trace_VideoProcessBlt = Guid.initString("69089cc0-71ab-42d0-953a-2887bf05a8af");
pub const DTV_CardStatus_Inserted = @as(u32, 0);
pub const DTV_CardStatus_Removed = @as(u32, 1);
pub const DTV_CardStatus_Error = @as(u32, 2);
pub const DTV_CardStatus_FirmwareDownload = @as(u32, 3);
pub const OCUR_PAIRING_PROTOCOL_VERSION = @as(u32, 2);
pub const PBDA_PAIRING_PROTOCOL_VERSION = @as(u32, 3);
pub const DTV_MMIMessage_Open = @as(u32, 0);
pub const DTV_MMIMessage_Close = @as(u32, 1);
pub const DTV_Entitlement_CanDecrypt = @as(u32, 0);
pub const DTV_Entitlement_NotEntitled = @as(u32, 1);
pub const DTV_Entitlement_TechnicalFailure = @as(u32, 2);
pub const AudioType_Standard = @as(u32, 0);
pub const AudioType_Music_And_Effects = @as(u32, 1);
pub const AudioType_Visually_Impaired = @as(u32, 2);
pub const AudioType_Hearing_Impaired = @as(u32, 3);
pub const AudioType_Dialogue = @as(u32, 4);
pub const AudioType_Commentary = @as(u32, 5);
pub const AudioType_Emergency = @as(u32, 6);
pub const AudioType_Voiceover = @as(u32, 7);
pub const AudioType_Reserved = @as(i32, -1);
pub const MAX_COUNTRY_CODE_STRING = @as(u32, 3);
pub const PARENTAL_CONTROL_TIME_RANGE = @as(u32, 1);
pub const REQUIRED_PARENTAL_CONTROL_TIME_RANGE = @as(u32, 2);
pub const PARENTAL_CONTROL_CONTENT_RATING = @as(u32, 256);
pub const PARENTAL_CONTROL_ATTRIB_VIOLENCE = @as(u32, 512);
pub const PARENTAL_CONTROL_ATTRIB_LANGUAGE = @as(u32, 513);
pub const PARENTAL_CONTROL_ATTRIB_SEXUAL = @as(u32, 514);
pub const PARENTAL_CONTROL_ATTRIB_DIALOGUE = @as(u32, 515);
pub const PARENTAL_CONTROL_ATTRIB_FANTASY = @as(u32, 516);
pub const PARENTAL_CONTROL_VALUE_UNDEFINED = @as(u32, 0);
pub const MPEG2_FILTER_VERSION_1_SIZE = @as(u32, 124);
pub const MPEG2_FILTER_VERSION_2_SIZE = @as(u32, 133);
pub const SID_MSVidCtl_CurrentAudioEndpoint = Guid.initString("cf9a88f4-abcf-4ed8-9b74-7db33445459e");
pub const STREAMBUFFER_EC_BASE = @as(u32, 806);
pub const EVENTID_SBE2RecControlStarted = Guid.initString("8966a89e-f83e-4c0e-bc3b-bfa7649e04cb");
pub const EVENTID_SBE2RecControlStopped = Guid.initString("454b1ec8-0c9b-4caa-b1a1-1e7a2666f6c3");
pub const SBE2_STREAM_DESC_EVENT = Guid.initString("2313a4ed-bf2d-454f-ad8a-d95ba7f91fee");
pub const SBE2_V1_STREAMS_CREATION_EVENT = Guid.initString("000fcf09-97f5-46ac-9769-7a83b35384fb");
pub const SBE2_V2_STREAMS_CREATION_EVENT = Guid.initString("a72530a3-0344-4cab-a2d0-fe937dbdcab3");
pub const SBE2_STREAM_DESC_VERSION = @as(u32, 1);
pub const SID_DRMSecureServiceChannel = Guid.initString("c4c4c4c4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterEncProperties = Guid.initString("c4c4c481-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterTagProperties = Guid.initString("c4c4c491-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_PTFilter = Guid.initString("9cd31617-b303-4f96-8330-2eb173ea4dc6");
pub const CLSID_DTFilterEncProperties = Guid.initString("c4c4c482-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilterTagProperties = Guid.initString("c4c4c492-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecProperties = Guid.initString("c4c4c483-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecTagProperties = Guid.initString("c4c4c493-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CPCAFiltersCategory = Guid.initString("c4c4c4fc-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSRating = Guid.initString("c4c4c4e0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecDuplicateXDSRating = Guid.initString("c4c4c4df-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSPacket = Guid.initString("c4c4c4e1-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingChange = Guid.initString("c4c4c4e2-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsBlock = Guid.initString("c4c4c4e3-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsUnblock = Guid.initString("c4c4c4e4-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterXDSPacket = Guid.initString("c4c4c4e5-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOn = Guid.initString("c4c4c4e6-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOff = Guid.initString("c4c4c4e7-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPUnblock = Guid.initString("c4c4c4e8-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_EncDecFilterError = Guid.initString("c4c4c4e9-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPBlock = Guid.initString("c4c4c4ea-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyOnce = Guid.initString("c4c4c4eb-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyNever = Guid.initString("c4c4c4f0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatOK = Guid.initString("c4c4c4ec-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatFailure = Guid.initString("c4c4c4ed-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseOK = Guid.initString("c4c4c4ee-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseFailure = Guid.initString("c4c4c4ef-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d0-0049-4e2b-98fb-9537f6ce516d");
pub const FORMATTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_CPFilters_Processed = Guid.initString("46adbd28-6fd0-4796-93b2-155c51dc048d");
pub const FORMATTYPE_CPFilters_Processed = Guid.initString("6739b36f-1d5f-4ac2-8192-28bb0e73d16a");
pub const EVENTID_EncDecFilterEvent = Guid.initString("4a1b465b-0fb9-4159-afbd-e33006a0f9f4");
pub const EVENTID_FormatNotSupportedEvent = Guid.initString("24b2280a-b2aa-4777-bf65-63f35e7b024a");
pub const EVENTID_DemultiplexerFilterDiscontinuity = Guid.initString("16155770-aed5-475c-bb98-95a33070df0c");
pub const DSATTRIB_WMDRMProtectionInfo = Guid.initString("40749583-6b9d-4eec-b43c-67a1801e1a9b");
pub const DSATTRIB_BadSampleInfo = Guid.initString("e4846dda-5838-42b4-b897-6f7e5faa2f2f");
pub const MPEG_PAT_PID = @as(u32, 0);
pub const MPEG_PAT_TID = @as(u32, 0);
pub const MPEG_CAT_PID = @as(u32, 1);
pub const MPEG_CAT_TID = @as(u32, 1);
pub const MPEG_PMT_TID = @as(u32, 2);
pub const MPEG_TSDT_PID = @as(u32, 2);
pub const MPEG_TSDT_TID = @as(u32, 3);
pub const ATSC_MGT_PID = @as(u32, 8187);
pub const ATSC_MGT_TID = @as(u32, 199);
pub const ATSC_VCT_PID = @as(u32, 8187);
pub const ATSC_VCT_TERR_TID = @as(u32, 200);
pub const ATSC_VCT_CABL_TID = @as(u32, 201);
pub const ATSC_EIT_TID = @as(u32, 203);
pub const ATSC_ETT_TID = @as(u32, 204);
pub const ATSC_RRT_TID = @as(u32, 202);
pub const ATSC_RRT_PID = @as(u32, 8187);
pub const ATSC_STT_PID = @as(u32, 8187);
pub const ATSC_STT_TID = @as(u32, 205);
pub const ATSC_PIT_TID = @as(u32, 208);
pub const DVB_NIT_PID = @as(u32, 16);
pub const DVB_NIT_ACTUAL_TID = @as(u32, 64);
pub const DVB_NIT_OTHER_TID = @as(u32, 65);
pub const DVB_SDT_PID = @as(u32, 17);
pub const DVB_SDT_ACTUAL_TID = @as(u32, 66);
pub const DVB_SDT_OTHER_TID = @as(u32, 70);
pub const DVB_BAT_PID = @as(u32, 17);
pub const DVB_BAT_TID = @as(u32, 74);
pub const DVB_EIT_PID = @as(u32, 18);
pub const DVB_EIT_ACTUAL_TID = @as(u32, 78);
pub const DVB_EIT_OTHER_TID = @as(u32, 79);
pub const DVB_RST_PID = @as(u32, 19);
pub const DVB_RST_TID = @as(u32, 113);
pub const DVB_TDT_PID = @as(u32, 20);
pub const DVB_TDT_TID = @as(u32, 112);
pub const DVB_ST_PID_16 = @as(u32, 16);
pub const DVB_ST_PID_17 = @as(u32, 17);
pub const DVB_ST_PID_18 = @as(u32, 18);
pub const DVB_ST_PID_19 = @as(u32, 19);
pub const DVB_ST_PID_20 = @as(u32, 20);
pub const DVB_ST_TID = @as(u32, 114);
pub const ISDB_ST_TID = @as(u32, 114);
pub const DVB_TOT_PID = @as(u32, 20);
pub const DVB_TOT_TID = @as(u32, 115);
pub const DVB_DIT_PID = @as(u32, 30);
pub const DVB_DIT_TID = @as(u32, 126);
pub const DVB_SIT_PID = @as(u32, 31);
pub const DVB_SIT_TID = @as(u32, 127);
pub const ISDB_EMM_TID = @as(u32, 133);
pub const ISDB_BIT_PID = @as(u32, 36);
pub const ISDB_BIT_TID = @as(u32, 196);
pub const ISDB_NBIT_PID = @as(u32, 37);
pub const ISDB_NBIT_MSG_TID = @as(u32, 197);
pub const ISDB_NBIT_REF_TID = @as(u32, 198);
pub const ISDB_LDT_PID = @as(u32, 37);
pub const ISDB_LDT_TID = @as(u32, 199);
pub const ISDB_SDTT_PID = @as(u32, 35);
pub const ISDB_SDTT_ALT_PID = @as(u32, 40);
pub const ISDB_SDTT_TID = @as(u32, 195);
pub const ISDB_CDT_PID = @as(u32, 41);
pub const ISDB_CDT_TID = @as(u32, 200);
pub const SCTE_EAS_TID = @as(u32, 216);
pub const SCTE_EAS_IB_PID = @as(u32, 8187);
pub const SCTE_EAS_OOB_PID = @as(u32, 8188);
pub const CLSID_Mpeg2TableFilter = Guid.initString("752845f1-758f-4c83-a043-4270c593308e");
pub const ATSC_ETM_LOCATION_NOT_PRESENT = @as(u32, 0);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_PSIP = @as(u32, 1);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_EVENT = @as(u32, 2);
pub const ATSC_ETM_LOCATION_RESERVED = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_HEADER = @as(u32, 1);
pub const SAMPLE_SEQ_GOP_HEADER = @as(u32, 2);
pub const SAMPLE_SEQ_PICTURE_HEADER = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_START = @as(u32, 1);
pub const SAMPLE_SEQ_SEEK_POINT = @as(u32, 2);
pub const SAMPLE_SEQ_FRAME_START = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_UNKNOWN = @as(u32, 0);
pub const SAMPLE_SEQ_CONTENT_I_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_P_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_B_FRAME = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_STANDALONE_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_REF_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_NONREF_FRAME = @as(u32, 3);
pub const COMPONENT_TAG_CAPTION_MIN = @as(u32, 48);
pub const COMPONENT_TAG_CAPTION_MAX = @as(u32, 55);
pub const COMPONENT_TAG_SUPERIMPOSE_MIN = @as(u32, 56);
pub const COMPONENT_TAG_SUPERIMPOSE_MAX = @as(u32, 63);
pub const DVBS_SCAN_TABLE_MAX_SIZE = @as(u32, 400);
pub const g_wszExcludeScriptStreamDeliverySynchronization = "ExcludeScriptStreamDeliverySynchronization";
pub const MPEG2_BASE = @as(u32, 512);
pub const MPEG2_S_MORE_DATA_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const MPEG2_S_NO_MORE_DATA_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const MPEG2_S_SG_INFO_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const MPEG2_S_SG_INFO_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262659));
pub const MPEG2_S_MPE_INFO_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262660));
pub const MPEG2_S_MPE_INFO_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262661));
pub const MPEG2_S_NEW_MODULE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262662));
pub const MPEG2_E_UNINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const MPEG2_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const MPEG2_E_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const MPEG2_E_MALFORMED_TABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const MPEG2_E_UNDEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const MPEG2_E_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const MPEG2_E_SECTION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const MPEG2_E_TX_STREAM_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const MPEG2_E_SERVICE_ID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const MPEG2_E_SERVICE_PMT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const MPEG2_E_DSI_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const MPEG2_E_SERVER_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const MPEG2_E_INVALID_CAROUSEL_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const MPEG2_E_MALFORMED_DSMCC_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const MPEG2_E_INVALID_SG_OBJECT_KIND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const MPEG2_E_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const MPEG2_E_OBJECT_KIND_NOT_A_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const MPEG2_E_OBJECT_KIND_NOT_A_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const MPEG2_E_FILE_OFFSET_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const MPEG2_E_STREAM_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const MPEG2_E_REGISTRY_ACCESS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const MPEG2_E_INVALID_UDP_PORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const MPEG2_E_DATA_SOURCE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const MPEG2_E_DII_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const MPEG2_E_DSHOW_PIN_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const MPEG2_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const MPEG2_E_MISSING_SECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const MPEG2_E_TOO_MANY_SECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const MPEG2_E_NEXT_TABLE_OPS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const MPEG2_E_INCORRECT_DESCRIPTOR_TAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const MSDRI_S_MMI_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2));
pub const MSDRI_S_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1));
pub const BDA_E_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479679));
pub const BDA_E_NOT_IMPLEMENTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479678));
pub const BDA_E_NO_SUCH_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479677));
pub const BDA_E_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479676));
pub const BDA_E_INVALID_SCHEMA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479675));
pub const BDA_E_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479674));
pub const BDA_E_INVALID_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479673));
pub const BDA_E_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479672));
pub const BDA_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479671));
pub const BDA_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479670));
pub const BDA_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479669));
pub const BDA_E_OUT_OF_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479668));
pub const BDA_E_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479667));
pub const BDA_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479666));
pub const BDA_E_NO_HANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479665));
pub const BDA_E_INVALID_LANGUAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479664));
pub const BDA_E_TIMEOUT_ELAPSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479663));
pub const BDA_E_NO_MORE_EVENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073475583));
pub const BDA_E_NO_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073475582));
pub const BDA_E_TUNER_INITIALIZING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467391));
pub const BDA_E_TUNER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467390));
pub const BDA_E_TUNER_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467389));
pub const BDA_E_INVALID_TUNE_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467388));
pub const BDA_E_INVALID_ENTITLEMENT_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463295));
pub const BDA_E_INVALID_CAPTURE_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463294));
pub const BDA_E_WOULD_DISRUPT_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463293));
pub const BDA_E_INVALID_PURCHASE_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463292));
pub const BDA_E_IPNETWORK_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459199));
pub const BDA_E_IPNETWORK_ADDRESS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459198));
pub const BDA_E_IPNETWORK_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459197));
pub const BDA_E_IPNETWORK_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459196));
pub const BDA_E_TUNE_FAILED_SDV01 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455103));
pub const BDA_E_TUNE_FAILED_SDV02 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455102));
pub const BDA_E_TUNE_FAILED_SDV03 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455101));
pub const BDA_E_TUNE_FAILED_SDV04 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455100));
pub const BDA_E_TUNE_FAILED_SDV05 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455099));
pub const BDA_E_TUNE_FAILED_SDV06 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455098));
pub const BDA_E_TUNE_FAILED_SDV07 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455097));
pub const BDA_E_TUNE_FAILED_SDV08 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455096));
pub const BDA_E_TUNE_FAILED_SDVFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073454849));
pub const BDA_E_WMDRM_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418239));
pub const BDA_E_WMDRM_INVALID_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418238));
pub const BDA_E_WMDRM_INVALID_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418236));
pub const BDA_E_WMDRM_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418235));
pub const BDA_E_WMDRM_INVALID_PROXIMITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418234));
pub const BDA_E_WMDRM_KEY_ID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418232));
pub const SPECIFYPAGES_STATISTICS = Guid.initString("4c437b92-6e9e-11d1-a704-006097c4e476");
pub const g_wszStreamBufferRecordingDuration = "Duration";
pub const g_wszStreamBufferRecordingBitrate = "Bitrate";
pub const g_wszStreamBufferRecordingSeekable = "Seekable";
pub const g_wszStreamBufferRecordingStridable = "Stridable";
pub const g_wszStreamBufferRecordingBroadcast = "Broadcast";
pub const g_wszStreamBufferRecordingProtected = "Is_Protected";
pub const g_wszStreamBufferRecordingTrusted = "Is_Trusted";
pub const g_wszStreamBufferRecordingSignature_Name = "Signature_Name";
pub const g_wszStreamBufferRecordingHasAudio = "HasAudio";
pub const g_wszStreamBufferRecordingHasImage = "HasImage";
pub const g_wszStreamBufferRecordingHasScript = "HasScript";
pub const g_wszStreamBufferRecordingHasVideo = "HasVideo";
pub const g_wszStreamBufferRecordingCurrentBitrate = "CurrentBitrate";
pub const g_wszStreamBufferRecordingOptimalBitrate = "OptimalBitrate";
pub const g_wszStreamBufferRecordingHasAttachedImages = "HasAttachedImages";
pub const g_wszStreamBufferRecordingSkipBackward = "Can_Skip_Backward";
pub const g_wszStreamBufferRecordingSkipForward = "Can_Skip_Forward";
pub const g_wszStreamBufferRecordingNumberOfFrames = "NumberOfFrames";
pub const g_wszStreamBufferRecordingFileSize = "FileSize";
pub const g_wszStreamBufferRecordingHasArbitraryDataStream = "HasArbitraryDataStream";
pub const g_wszStreamBufferRecordingHasFileTransferStream = "HasFileTransferStream";
pub const g_wszStreamBufferRecordingTitle = "Title";
pub const g_wszStreamBufferRecordingAuthor = "Author";
pub const g_wszStreamBufferRecordingDescription = "Description";
pub const g_wszStreamBufferRecordingRating = "Rating";
pub const g_wszStreamBufferRecordingCopyright = "Copyright";
pub const g_wszStreamBufferRecordingUse_DRM = "Use_DRM";
pub const g_wszStreamBufferRecordingDRM_Flags = "DRM_Flags";
pub const g_wszStreamBufferRecordingDRM_Level = "DRM_Level";
pub const g_wszStreamBufferRecordingAlbumTitle = "WM/AlbumTitle";
pub const g_wszStreamBufferRecordingTrack = "WM/Track";
pub const g_wszStreamBufferRecordingPromotionURL = "WM/PromotionURL";
pub const g_wszStreamBufferRecordingAlbumCoverURL = "WM/AlbumCoverURL";
pub const g_wszStreamBufferRecordingGenre = "WM/Genre";
pub const g_wszStreamBufferRecordingYear = "WM/Year";
pub const g_wszStreamBufferRecordingGenreID = "WM/GenreID";
pub const g_wszStreamBufferRecordingMCDI = "WM/MCDI";
pub const g_wszStreamBufferRecordingComposer = "WM/Composer";
pub const g_wszStreamBufferRecordingLyrics = "WM/Lyrics";
pub const g_wszStreamBufferRecordingTrackNumber = "WM/TrackNumber";
pub const g_wszStreamBufferRecordingToolName = "WM/ToolName";
pub const g_wszStreamBufferRecordingToolVersion = "WM/ToolVersion";
pub const g_wszStreamBufferRecordingIsVBR = "IsVBR";
pub const g_wszStreamBufferRecordingAlbumArtist = "WM/AlbumArtist";
pub const g_wszStreamBufferRecordingBannerImageType = "BannerImageType";
pub const g_wszStreamBufferRecordingBannerImageData = "BannerImageData";
pub const g_wszStreamBufferRecordingBannerImageURL = "BannerImageURL";
pub const g_wszStreamBufferRecordingCopyrightURL = "CopyrightURL";
pub const g_wszStreamBufferRecordingAspectRatioX = "AspectRatioX";
pub const g_wszStreamBufferRecordingAspectRatioY = "AspectRatioY";
pub const g_wszStreamBufferRecordingNSCName = "NSC_Name";
pub const g_wszStreamBufferRecordingNSCAddress = "NSC_Address";
pub const g_wszStreamBufferRecordingNSCPhone = "NSC_Phone";
pub const g_wszStreamBufferRecordingNSCEmail = "NSC_Email";
pub const g_wszStreamBufferRecordingNSCDescription = "NSC_Description";
pub const STREAMBUFFER_EC_TIMEHOLE = @as(i32, 806);
pub const STREAMBUFFER_EC_STALE_DATA_READ = @as(i32, 807);
pub const STREAMBUFFER_EC_STALE_FILE_DELETED = @as(i32, 808);
pub const STREAMBUFFER_EC_CONTENT_BECOMING_STALE = @as(i32, 809);
pub const STREAMBUFFER_EC_WRITE_FAILURE = @as(i32, 810);
pub const STREAMBUFFER_EC_WRITE_FAILURE_CLEAR = @as(i32, 811);
pub const STREAMBUFFER_EC_READ_FAILURE = @as(i32, 812);
pub const STREAMBUFFER_EC_RATE_CHANGED = @as(i32, 813);
pub const STREAMBUFFER_EC_PRIMARY_AUDIO = @as(i32, 814);
pub const STREAMBUFFER_EC_RATE_CHANGING_FOR_SETPOSITIONS = @as(i32, 815);
pub const STREAMBUFFER_EC_SETPOSITIONS_EVENTS_DONE = @as(i32, 816);

//--------------------------------------------------------------------------------
// Section: Types (1474)
//--------------------------------------------------------------------------------
pub const OA_BOOL = enum(i32) {
    TRUE = -1,
    FALSE = 0,
};
pub const OATRUE = OA_BOOL.TRUE;
pub const OAFALSE = OA_BOOL.FALSE;

pub const MPEG2VIDEOINFO_FLAGS = enum(u32) {
    DoPanScan = 1,
    DVDLine21Field1 = 2,
    DVDLine21Field2 = 4,
    SourceIsLetterboxed = 8,
    FilmCameraMode = 16,
    LetterboxAnalogOut = 32,
    DSS_UserData = 64,
    DVB_UserData = 128,
    @"27MhzTimebase" = 256,
    WidescreenAnalogOut = 512,
    _,
    pub fn initFlags(o: struct {
        DoPanScan: u1 = 0,
        DVDLine21Field1: u1 = 0,
        DVDLine21Field2: u1 = 0,
        SourceIsLetterboxed: u1 = 0,
        FilmCameraMode: u1 = 0,
        LetterboxAnalogOut: u1 = 0,
        DSS_UserData: u1 = 0,
        DVB_UserData: u1 = 0,
        @"27MhzTimebase": u1 = 0,
        WidescreenAnalogOut: u1 = 0,
    }) MPEG2VIDEOINFO_FLAGS {
        return @as(MPEG2VIDEOINFO_FLAGS, @enumFromInt((if (o.DoPanScan == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.DoPanScan) else 0) | (if (o.DVDLine21Field1 == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.DVDLine21Field1) else 0) | (if (o.DVDLine21Field2 == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.DVDLine21Field2) else 0) | (if (o.SourceIsLetterboxed == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.SourceIsLetterboxed) else 0) | (if (o.FilmCameraMode == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.FilmCameraMode) else 0) | (if (o.LetterboxAnalogOut == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.LetterboxAnalogOut) else 0) | (if (o.DSS_UserData == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.DSS_UserData) else 0) | (if (o.DVB_UserData == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.DVB_UserData) else 0) | (if (o.@"27MhzTimebase" == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.@"27MhzTimebase") else 0) | (if (o.WidescreenAnalogOut == 1) @intFromEnum(MPEG2VIDEOINFO_FLAGS.WidescreenAnalogOut) else 0)));
    }
};
pub const AMMPEG2_DoPanScan = MPEG2VIDEOINFO_FLAGS.DoPanScan;
pub const AMMPEG2_DVDLine21Field1 = MPEG2VIDEOINFO_FLAGS.DVDLine21Field1;
pub const AMMPEG2_DVDLine21Field2 = MPEG2VIDEOINFO_FLAGS.DVDLine21Field2;
pub const AMMPEG2_SourceIsLetterboxed = MPEG2VIDEOINFO_FLAGS.SourceIsLetterboxed;
pub const AMMPEG2_FilmCameraMode = MPEG2VIDEOINFO_FLAGS.FilmCameraMode;
pub const AMMPEG2_LetterboxAnalogOut = MPEG2VIDEOINFO_FLAGS.LetterboxAnalogOut;
pub const AMMPEG2_DSS_UserData = MPEG2VIDEOINFO_FLAGS.DSS_UserData;
pub const AMMPEG2_DVB_UserData = MPEG2VIDEOINFO_FLAGS.DVB_UserData;
pub const AMMPEG2_27MhzTimebase = MPEG2VIDEOINFO_FLAGS.@"27MhzTimebase";
pub const AMMPEG2_WidescreenAnalogOut = MPEG2VIDEOINFO_FLAGS.WidescreenAnalogOut;

pub const MPEGLAYER3WAVEFORMAT_FLAGS = enum(u32) {
    ISO = 0,
    ON = 1,
    OFF = 2,
};
pub const MPEGLAYER3_FLAG_PADDING_ISO = MPEGLAYER3WAVEFORMAT_FLAGS.ISO;
pub const MPEGLAYER3_FLAG_PADDING_ON = MPEGLAYER3WAVEFORMAT_FLAGS.ON;
pub const MPEGLAYER3_FLAG_PADDING_OFF = MPEGLAYER3WAVEFORMAT_FLAGS.OFF;

pub const AMVP_SELECT_FORMAT_BY = enum(i32) {
    DO_NOT_CARE = 0,
    BEST_BANDWIDTH = 1,
    INPUT_SAME_AS_OUTPUT = 2,
};
pub const AMVP_DO_NOT_CARE = AMVP_SELECT_FORMAT_BY.DO_NOT_CARE;
pub const AMVP_BEST_BANDWIDTH = AMVP_SELECT_FORMAT_BY.BEST_BANDWIDTH;
pub const AMVP_INPUT_SAME_AS_OUTPUT = AMVP_SELECT_FORMAT_BY.INPUT_SAME_AS_OUTPUT;

pub const AMVP_MODE = enum(i32) {
    WEAVE = 0,
    BOBINTERLEAVED = 1,
    BOBNONINTERLEAVED = 2,
    SKIPEVEN = 3,
    SKIPODD = 4,
};
pub const AMVP_MODE_WEAVE = AMVP_MODE.WEAVE;
pub const AMVP_MODE_BOBINTERLEAVED = AMVP_MODE.BOBINTERLEAVED;
pub const AMVP_MODE_BOBNONINTERLEAVED = AMVP_MODE.BOBNONINTERLEAVED;
pub const AMVP_MODE_SKIPEVEN = AMVP_MODE.SKIPEVEN;
pub const AMVP_MODE_SKIPODD = AMVP_MODE.SKIPODD;

pub const AMVPSIZE = extern struct {
    dwWidth: u32,
    dwHeight: u32,
};

pub const AMVPDIMINFO = extern struct {
    dwFieldWidth: u32,
    dwFieldHeight: u32,
    dwVBIWidth: u32,
    dwVBIHeight: u32,
    rcValidRegion: RECT,
};

pub const AMVPDATAINFO = extern struct {
    dwSize: u32,
    dwMicrosecondsPerField: u32,
    amvpDimInfo: AMVPDIMINFO,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    bEnableDoubleClock: BOOL,
    bEnableVACT: BOOL,
    bDataIsInterlaced: BOOL,
    lHalfLinesOdd: i32,
    bFieldPolarityInverted: BOOL,
    dwNumLinesInVREF: u32,
    lHalfLinesEven: i32,
    dwReserved1: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICreateDevEnum_Value = Guid.initString("29840822-5b84-11d0-bd3b-00a0c911ce86");
pub const IID_ICreateDevEnum = &IID_ICreateDevEnum_Value;
pub const ICreateDevEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateClassEnumerator: *const fn (
            self: *const ICreateDevEnum,
            clsid_device_class: ?*const Guid,
            pp_enum_moniker: ?*?*IEnumMoniker,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createClassEnumerator(self: *const T, clsid_device_class_: ?*const Guid, pp_enum_moniker_: ?*?*IEnumMoniker, dw_flags_: u32) HRESULT {
                return @as(*const ICreateDevEnum.VTable, @ptrCast(self.vtable)).CreateClassEnumerator(@as(*const ICreateDevEnum, @ptrCast(self)), clsid_device_class_, pp_enum_moniker_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MEDIA_TYPE = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
    pUnk: ?*IUnknown,
    cbFormat: u32,
    pbFormat: ?*u8,
};

pub const PIN_DIRECTION = enum(i32) {
    INPUT = 0,
    OUTPUT = 1,
};
pub const PINDIR_INPUT = PIN_DIRECTION.INPUT;
pub const PINDIR_OUTPUT = PIN_DIRECTION.OUTPUT;

pub const ALLOCATOR_PROPERTIES = extern struct {
    cBuffers: i32,
    cbBuffer: i32,
    cbAlign: i32,
    cbPrefix: i32,
};

pub const PIN_INFO = extern struct {
    pFilter: ?*IBaseFilter,
    dir: PIN_DIRECTION,
    achName: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPin_Value = Guid.initString("56a86891-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPin = &IID_IPin_Value;
pub const IPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: *const fn (
            self: *const IPin,
            p_receive_pin: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveConnection: *const fn (
            self: *const IPin,
            p_connector: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectedTo: *const fn (
            self: *const IPin,
            p_pin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionMediaType: *const fn (
            self: *const IPin,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPinInfo: *const fn (
            self: *const IPin,
            p_info: ?*PIN_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDirection: *const fn (
            self: *const IPin,
            p_pin_dir: ?*PIN_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryId: *const fn (
            self: *const IPin,
            id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAccept: *const fn (
            self: *const IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaTypes: *const fn (
            self: *const IPin,
            pp_enum: ?*?*IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInternalConnections: *const fn (
            self: *const IPin,
            ap_pin: ?[*]?*IPin,
            n_pin: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOfStream: *const fn (
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFlush: *const fn (
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFlush: *const fn (
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewSegment: *const fn (
            self: *const IPin,
            t_start: i64,
            t_stop: i64,
            d_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn connect(self: *const T, p_receive_pin_: ?*IPin, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).Connect(@as(*const IPin, @ptrCast(self)), p_receive_pin_, pmt_);
            }
            pub inline fn receiveConnection(self: *const T, p_connector_: ?*IPin, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).ReceiveConnection(@as(*const IPin, @ptrCast(self)), p_connector_, pmt_);
            }
            pub inline fn disconnect(self: *const T) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IPin, @ptrCast(self)));
            }
            pub inline fn connectedTo(self: *const T, p_pin_: ?*?*IPin) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).ConnectedTo(@as(*const IPin, @ptrCast(self)), p_pin_);
            }
            pub inline fn connectionMediaType(self: *const T, pmt_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).ConnectionMediaType(@as(*const IPin, @ptrCast(self)), pmt_);
            }
            pub inline fn queryPinInfo(self: *const T, p_info_: ?*PIN_INFO) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryPinInfo(@as(*const IPin, @ptrCast(self)), p_info_);
            }
            pub inline fn queryDirection(self: *const T, p_pin_dir_: ?*PIN_DIRECTION) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryDirection(@as(*const IPin, @ptrCast(self)), p_pin_dir_);
            }
            pub inline fn queryId(self: *const T, id_: ?*?PWSTR) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryId(@as(*const IPin, @ptrCast(self)), id_);
            }
            pub inline fn queryAccept(self: *const T, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryAccept(@as(*const IPin, @ptrCast(self)), pmt_);
            }
            pub inline fn enumMediaTypes(self: *const T, pp_enum_: ?*?*IEnumMediaTypes) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).EnumMediaTypes(@as(*const IPin, @ptrCast(self)), pp_enum_);
            }
            pub inline fn queryInternalConnections(self: *const T, ap_pin_: ?[*]?*IPin, n_pin_: ?*u32) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryInternalConnections(@as(*const IPin, @ptrCast(self)), ap_pin_, n_pin_);
            }
            pub inline fn endOfStream(self: *const T) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).EndOfStream(@as(*const IPin, @ptrCast(self)));
            }
            pub inline fn beginFlush(self: *const T) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).BeginFlush(@as(*const IPin, @ptrCast(self)));
            }
            pub inline fn endFlush(self: *const T) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).EndFlush(@as(*const IPin, @ptrCast(self)));
            }
            pub inline fn newSegment(self: *const T, t_start_: i64, t_stop_: i64, d_rate_: f64) HRESULT {
                return @as(*const IPin.VTable, @ptrCast(self.vtable)).NewSegment(@as(*const IPin, @ptrCast(self)), t_start_, t_stop_, d_rate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPins_Value = Guid.initString("56a86892-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumPins = &IID_IEnumPins_Value;
pub const IEnumPins = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumPins,
            c_pins: u32,
            pp_pins: [*]?*IPin,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumPins,
            c_pins: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumPins,
            pp_enum: ?*?*IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_pins_: u32, pp_pins_: [*]?*IPin, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPins, @ptrCast(self)), c_pins_, pp_pins_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_pins_: u32) HRESULT {
                return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPins, @ptrCast(self)), c_pins_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPins, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumPins) HRESULT {
                return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPins, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMediaTypes_Value = Guid.initString("89c31040-846b-11ce-97d3-00aa0055595a");
pub const IID_IEnumMediaTypes = &IID_IEnumMediaTypes_Value;
pub const IEnumMediaTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMediaTypes,
            c_media_types: u32,
            pp_media_types: [*]?*AM_MEDIA_TYPE,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMediaTypes,
            c_media_types: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMediaTypes,
            pp_enum: ?*?*IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_media_types_: u32, pp_media_types_: [*]?*AM_MEDIA_TYPE, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMediaTypes, @ptrCast(self)), c_media_types_, pp_media_types_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_media_types_: u32) HRESULT {
                return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMediaTypes, @ptrCast(self)), c_media_types_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMediaTypes, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumMediaTypes) HRESULT {
                return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMediaTypes, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph_Value = Guid.initString("56a8689f-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterGraph = &IID_IFilterGraph_Value;
pub const IFilterGraph = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFilter: *const fn (
            self: *const IFilterGraph,
            p_filter: ?*IBaseFilter,
            p_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilter: *const fn (
            self: *const IFilterGraph,
            p_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFilters: *const fn (
            self: *const IFilterGraph,
            pp_enum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFilterByName: *const fn (
            self: *const IFilterGraph,
            p_name: ?[*:0]const u16,
            pp_filter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDirect: *const fn (
            self: *const IFilterGraph,
            ppin_out: ?*IPin,
            ppin_in: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconnect: *const fn (
            self: *const IFilterGraph,
            ppin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IFilterGraph,
            ppin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSyncSource: *const fn (
            self: *const IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addFilter(self: *const T, p_filter_: ?*IBaseFilter, p_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).AddFilter(@as(*const IFilterGraph, @ptrCast(self)), p_filter_, p_name_);
            }
            pub inline fn removeFilter(self: *const T, p_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).RemoveFilter(@as(*const IFilterGraph, @ptrCast(self)), p_filter_);
            }
            pub inline fn enumFilters(self: *const T, pp_enum_: ?*?*IEnumFilters) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).EnumFilters(@as(*const IFilterGraph, @ptrCast(self)), pp_enum_);
            }
            pub inline fn findFilterByName(self: *const T, p_name_: ?[*:0]const u16, pp_filter_: ?*?*IBaseFilter) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).FindFilterByName(@as(*const IFilterGraph, @ptrCast(self)), p_name_, pp_filter_);
            }
            pub inline fn connectDirect(self: *const T, ppin_out_: ?*IPin, ppin_in_: ?*IPin, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).ConnectDirect(@as(*const IFilterGraph, @ptrCast(self)), ppin_out_, ppin_in_, pmt_);
            }
            pub inline fn reconnect(self: *const T, ppin_: ?*IPin) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).Reconnect(@as(*const IFilterGraph, @ptrCast(self)), ppin_);
            }
            pub inline fn disconnect(self: *const T, ppin_: ?*IPin) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IFilterGraph, @ptrCast(self)), ppin_);
            }
            pub inline fn setDefaultSyncSource(self: *const T) HRESULT {
                return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).SetDefaultSyncSource(@as(*const IFilterGraph, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFilters_Value = Guid.initString("56a86893-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumFilters = &IID_IEnumFilters_Value;
pub const IEnumFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumFilters,
            c_filters: u32,
            pp_filter: [*]?*IBaseFilter,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumFilters,
            c_filters: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumFilters,
            pp_enum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_filters_: u32, pp_filter_: [*]?*IBaseFilter, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFilters, @ptrCast(self)), c_filters_, pp_filter_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_filters_: u32) HRESULT {
                return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFilters, @ptrCast(self)), c_filters_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFilters, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumFilters) HRESULT {
                return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFilters, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_STATE = enum(i32) {
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const State_Stopped = FILTER_STATE.Stopped;
pub const State_Paused = FILTER_STATE.Paused;
pub const State_Running = FILTER_STATE.Running;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaFilter_Value = Guid.initString("56a86899-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaFilter = &IID_IMediaFilter_Value;
pub const IMediaFilter = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        Stop: *const fn (
            self: *const IMediaFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IMediaFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: *const fn (
            self: *const IMediaFilter,
            t_start: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IMediaFilter,
            dw_milli_secs_timeout: u32,
            state: ?*FILTER_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncSource: *const fn (
            self: *const IMediaFilter,
            p_clock: ?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSyncSource: *const fn (
            self: *const IMediaFilter,
            p_clock: ?*?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMediaFilter, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMediaFilter, @ptrCast(self)));
            }
            pub inline fn run(self: *const T, t_start_: i64) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Run(@as(*const IMediaFilter, @ptrCast(self)), t_start_);
            }
            pub inline fn getState(self: *const T, dw_milli_secs_timeout_: u32, state_: ?*FILTER_STATE) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMediaFilter, @ptrCast(self)), dw_milli_secs_timeout_, state_);
            }
            pub inline fn setSyncSource(self: *const T, p_clock_: ?*IReferenceClock) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).SetSyncSource(@as(*const IMediaFilter, @ptrCast(self)), p_clock_);
            }
            pub inline fn getSyncSource(self: *const T, p_clock_: ?*?*IReferenceClock) HRESULT {
                return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).GetSyncSource(@as(*const IMediaFilter, @ptrCast(self)), p_clock_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_INFO = extern struct {
    achName: [128]u16,
    pGraph: ?*IFilterGraph,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBaseFilter_Value = Guid.initString("56a86895-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBaseFilter = &IID_IBaseFilter_Value;
pub const IBaseFilter = extern struct {
    pub const VTable = extern struct {
        base: IMediaFilter.VTable,
        EnumPins: *const fn (
            self: *const IBaseFilter,
            pp_enum: ?*?*IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPin: *const fn (
            self: *const IBaseFilter,
            id: ?[*:0]const u16,
            pp_pin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryFilterInfo: *const fn (
            self: *const IBaseFilter,
            p_info: ?*FILTER_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilterGraph: *const fn (
            self: *const IBaseFilter,
            p_graph: ?*IFilterGraph,
            p_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVendorInfo: *const fn (
            self: *const IBaseFilter,
            p_vendor_info: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaFilter.MethodMixin(T);
            pub inline fn enumPins(self: *const T, pp_enum_: ?*?*IEnumPins) HRESULT {
                return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).EnumPins(@as(*const IBaseFilter, @ptrCast(self)), pp_enum_);
            }
            pub inline fn findPin(self: *const T, id_: ?[*:0]const u16, pp_pin_: ?*?*IPin) HRESULT {
                return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).FindPin(@as(*const IBaseFilter, @ptrCast(self)), id_, pp_pin_);
            }
            pub inline fn queryFilterInfo(self: *const T, p_info_: ?*FILTER_INFO) HRESULT {
                return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).QueryFilterInfo(@as(*const IBaseFilter, @ptrCast(self)), p_info_);
            }
            pub inline fn joinFilterGraph(self: *const T, p_graph_: ?*IFilterGraph, p_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).JoinFilterGraph(@as(*const IBaseFilter, @ptrCast(self)), p_graph_, p_name_);
            }
            pub inline fn queryVendorInfo(self: *const T, p_vendor_info_: ?*?PWSTR) HRESULT {
                return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).QueryVendorInfo(@as(*const IBaseFilter, @ptrCast(self)), p_vendor_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample_Value = Guid.initString("56a8689a-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaSample = &IID_IMediaSample_Value;
pub const IMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPointer: *const fn (
            self: *const IMediaSample,
            pp_buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetTime: *const fn (
            self: *const IMediaSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTime: *const fn (
            self: *const IMediaSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSyncPoint: *const fn (
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncPoint: *const fn (
            self: *const IMediaSample,
            b_is_sync_point: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreroll: *const fn (
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreroll: *const fn (
            self: *const IMediaSample,
            b_is_preroll: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDataLength: *const fn (
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        SetActualDataLength: *const fn (
            self: *const IMediaSample,
            ___m_i_d_l___i_media_sample0000: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: *const fn (
            self: *const IMediaSample,
            pp_media_type: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: *const fn (
            self: *const IMediaSample,
            p_media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDiscontinuity: *const fn (
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDiscontinuity: *const fn (
            self: *const IMediaSample,
            b_discontinuity: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTime: *const fn (
            self: *const IMediaSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaTime: *const fn (
            self: *const IMediaSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPointer(self: *const T, pp_buffer_: ?*?*u8) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetPointer(@as(*const IMediaSample, @ptrCast(self)), pp_buffer_);
            }
            pub inline fn getSize(self: *const T) i32 {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IMediaSample, @ptrCast(self)));
            }
            pub inline fn getTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IMediaSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn setTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetTime(@as(*const IMediaSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn isSyncPoint(self: *const T) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsSyncPoint(@as(*const IMediaSample, @ptrCast(self)));
            }
            pub inline fn setSyncPoint(self: *const T, b_is_sync_point_: BOOL) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetSyncPoint(@as(*const IMediaSample, @ptrCast(self)), b_is_sync_point_);
            }
            pub inline fn isPreroll(self: *const T) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsPreroll(@as(*const IMediaSample, @ptrCast(self)));
            }
            pub inline fn setPreroll(self: *const T, b_is_preroll_: BOOL) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetPreroll(@as(*const IMediaSample, @ptrCast(self)), b_is_preroll_);
            }
            pub inline fn getActualDataLength(self: *const T) i32 {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetActualDataLength(@as(*const IMediaSample, @ptrCast(self)));
            }
            pub inline fn setActualDataLength(self: *const T, ___m_i_d_l___i_media_sample0000_: i32) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetActualDataLength(@as(*const IMediaSample, @ptrCast(self)), ___m_i_d_l___i_media_sample0000_);
            }
            pub inline fn getMediaType(self: *const T, pp_media_type_: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IMediaSample, @ptrCast(self)), pp_media_type_);
            }
            pub inline fn setMediaType(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IMediaSample, @ptrCast(self)), p_media_type_);
            }
            pub inline fn isDiscontinuity(self: *const T) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsDiscontinuity(@as(*const IMediaSample, @ptrCast(self)));
            }
            pub inline fn setDiscontinuity(self: *const T, b_discontinuity_: BOOL) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetDiscontinuity(@as(*const IMediaSample, @ptrCast(self)), b_discontinuity_);
            }
            pub inline fn getMediaTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetMediaTime(@as(*const IMediaSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn setMediaTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetMediaTime(@as(*const IMediaSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SAMPLE_PROPERTY_FLAGS = enum(i32) {
    AMPLE_SPLICEPOINT = 1,
    AMPLE_PREROLL = 2,
    AMPLE_DATADISCONTINUITY = 4,
    AMPLE_TYPECHANGED = 8,
    AMPLE_TIMEVALID = 16,
    AMPLE_TIMEDISCONTINUITY = 64,
    AMPLE_FLUSH_ON_PAUSE = 128,
    AMPLE_STOPVALID = 256,
    AMPLE_ENDOFSTREAM = 512,
    TREAM_MEDIA = 0,
    // TREAM_CONTROL = 1, this enum value conflicts with AMPLE_SPLICEPOINT
};
pub const AM_SAMPLE_SPLICEPOINT = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;
pub const AM_SAMPLE_PREROLL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_PREROLL;
pub const AM_SAMPLE_DATADISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_DATADISCONTINUITY;
pub const AM_SAMPLE_TYPECHANGED = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TYPECHANGED;
pub const AM_SAMPLE_TIMEVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEVALID;
pub const AM_SAMPLE_TIMEDISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEDISCONTINUITY;
pub const AM_SAMPLE_FLUSH_ON_PAUSE = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_FLUSH_ON_PAUSE;
pub const AM_SAMPLE_STOPVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_STOPVALID;
pub const AM_SAMPLE_ENDOFSTREAM = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_ENDOFSTREAM;
pub const AM_STREAM_MEDIA = AM_SAMPLE_PROPERTY_FLAGS.TREAM_MEDIA;
pub const AM_STREAM_CONTROL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;

pub const AM_SAMPLE2_PROPERTIES = extern struct {
    cbData: u32,
    dwTypeSpecificFlags: u32,
    dwSampleFlags: u32,
    lActual: i32,
    tStart: i64,
    tStop: i64,
    dwStreamId: u32,
    pMediaType: ?*AM_MEDIA_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample2_Value = Guid.initString("36b73884-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSample2 = &IID_IMediaSample2_Value;
pub const IMediaSample2 = extern struct {
    pub const VTable = extern struct {
        base: IMediaSample.VTable,
        GetProperties: *const fn (
            self: *const IMediaSample2,
            cb_properties: u32,
            // TODO: what to do with BytesParamIndex 0?
            pb_properties: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: *const fn (
            self: *const IMediaSample2,
            cb_properties: u32,
            // TODO: what to do with BytesParamIndex 0?
            pb_properties: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaSample.MethodMixin(T);
            pub inline fn getProperties(self: *const T, cb_properties_: u32, pb_properties_: ?*u8) HRESULT {
                return @as(*const IMediaSample2.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IMediaSample2, @ptrCast(self)), cb_properties_, pb_properties_);
            }
            pub inline fn setProperties(self: *const T, cb_properties_: u32, pb_properties_: ?*const u8) HRESULT {
                return @as(*const IMediaSample2.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IMediaSample2, @ptrCast(self)), cb_properties_, pb_properties_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMediaSample2Config_Value = Guid.initString("68961e68-832b-41ea-bc91-63593f3e70e3");
pub const IID_IMediaSample2Config = &IID_IMediaSample2Config_Value;
pub const IMediaSample2Config = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurface: *const fn (
            self: *const IMediaSample2Config,
            pp_direct3_d_surface9: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSurface(self: *const T, pp_direct3_d_surface9_: ?*?*IUnknown) HRESULT {
                return @as(*const IMediaSample2Config.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IMediaSample2Config, @ptrCast(self)), pp_direct3_d_surface9_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocator_Value = Guid.initString("56a8689c-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemAllocator = &IID_IMemAllocator_Value;
pub const IMemAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperties: *const fn (
            self: *const IMemAllocator,
            p_request: ?*ALLOCATOR_PROPERTIES,
            p_actual: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: *const fn (
            self: *const IMemAllocator,
            p_props: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn (
            self: *const IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decommit: *const fn (
            self: *const IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: *const fn (
            self: *const IMemAllocator,
            pp_buffer: ?*?*IMediaSample,
            p_start_time: ?*i64,
            p_end_time: ?*i64,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: *const fn (
            self: *const IMemAllocator,
            p_buffer: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setProperties(self: *const T, p_request_: ?*ALLOCATOR_PROPERTIES, p_actual_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IMemAllocator, @ptrCast(self)), p_request_, p_actual_);
            }
            pub inline fn getProperties(self: *const T, p_props_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IMemAllocator, @ptrCast(self)), p_props_);
            }
            pub inline fn commit(self: *const T) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).Commit(@as(*const IMemAllocator, @ptrCast(self)));
            }
            pub inline fn decommit(self: *const T) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).Decommit(@as(*const IMemAllocator, @ptrCast(self)));
            }
            pub inline fn getBuffer(self: *const T, pp_buffer_: ?*?*IMediaSample, p_start_time_: ?*i64, p_end_time_: ?*i64, dw_flags_: u32) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IMemAllocator, @ptrCast(self)), pp_buffer_, p_start_time_, p_end_time_, dw_flags_);
            }
            pub inline fn releaseBuffer(self: *const T, p_buffer_: ?*IMediaSample) HRESULT {
                return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IMemAllocator, @ptrCast(self)), p_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorCallbackTemp_Value = Guid.initString("379a0cf0-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorCallbackTemp = &IID_IMemAllocatorCallbackTemp_Value;
pub const IMemAllocatorCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IMemAllocator.VTable,
        SetNotify: *const fn (
            self: *const IMemAllocatorCallbackTemp,
            p_notify: ?*IMemAllocatorNotifyCallbackTemp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFreeCount: *const fn (
            self: *const IMemAllocatorCallbackTemp,
            pl_buffers_free: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMemAllocator.MethodMixin(T);
            pub inline fn setNotify(self: *const T, p_notify_: ?*IMemAllocatorNotifyCallbackTemp) HRESULT {
                return @as(*const IMemAllocatorCallbackTemp.VTable, @ptrCast(self.vtable)).SetNotify(@as(*const IMemAllocatorCallbackTemp, @ptrCast(self)), p_notify_);
            }
            pub inline fn getFreeCount(self: *const T, pl_buffers_free_: ?*i32) HRESULT {
                return @as(*const IMemAllocatorCallbackTemp.VTable, @ptrCast(self.vtable)).GetFreeCount(@as(*const IMemAllocatorCallbackTemp, @ptrCast(self)), pl_buffers_free_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorNotifyCallbackTemp_Value = Guid.initString("92980b30-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorNotifyCallbackTemp = &IID_IMemAllocatorNotifyCallbackTemp_Value;
pub const IMemAllocatorNotifyCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRelease: *const fn (
            self: *const IMemAllocatorNotifyCallbackTemp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn notifyRelease(self: *const T) HRESULT {
                return @as(*const IMemAllocatorNotifyCallbackTemp.VTable, @ptrCast(self.vtable)).NotifyRelease(@as(*const IMemAllocatorNotifyCallbackTemp, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemInputPin_Value = Guid.initString("56a8689d-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemInputPin = &IID_IMemInputPin_Value;
pub const IMemInputPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAllocator: *const fn (
            self: *const IMemInputPin,
            pp_allocator: ?*?*IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAllocator: *const fn (
            self: *const IMemInputPin,
            p_allocator: ?*IMemAllocator,
            b_read_only: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatorRequirements: *const fn (
            self: *const IMemInputPin,
            p_props: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: *const fn (
            self: *const IMemInputPin,
            p_sample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveMultiple: *const fn (
            self: *const IMemInputPin,
            p_samples: [*]?*IMediaSample,
            n_samples: i32,
            n_samples_processed: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveCanBlock: *const fn (
            self: *const IMemInputPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAllocator(self: *const T, pp_allocator_: ?*?*IMemAllocator) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).GetAllocator(@as(*const IMemInputPin, @ptrCast(self)), pp_allocator_);
            }
            pub inline fn notifyAllocator(self: *const T, p_allocator_: ?*IMemAllocator, b_read_only_: BOOL) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).NotifyAllocator(@as(*const IMemInputPin, @ptrCast(self)), p_allocator_, b_read_only_);
            }
            pub inline fn getAllocatorRequirements(self: *const T, p_props_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).GetAllocatorRequirements(@as(*const IMemInputPin, @ptrCast(self)), p_props_);
            }
            pub inline fn receive(self: *const T, p_sample_: ?*IMediaSample) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).Receive(@as(*const IMemInputPin, @ptrCast(self)), p_sample_);
            }
            pub inline fn receiveMultiple(self: *const T, p_samples_: [*]?*IMediaSample, n_samples_: i32, n_samples_processed_: ?*i32) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).ReceiveMultiple(@as(*const IMemInputPin, @ptrCast(self)), p_samples_, n_samples_, n_samples_processed_);
            }
            pub inline fn receiveCanBlock(self: *const T) HRESULT {
                return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).ReceiveCanBlock(@as(*const IMemInputPin, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMovieSetup_Value = Guid.initString("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20");
pub const IID_IAMovieSetup = &IID_IAMovieSetup_Value;
pub const IAMovieSetup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const IAMovieSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: *const fn (
            self: *const IAMovieSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T) HRESULT {
                return @as(*const IAMovieSetup.VTable, @ptrCast(self.vtable)).Register(@as(*const IAMovieSetup, @ptrCast(self)));
            }
            pub inline fn unregister(self: *const T) HRESULT {
                return @as(*const IAMovieSetup.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IAMovieSetup, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SEEKING_SeekingFlags = enum(i32) {
    NoPositioning = 0,
    AbsolutePositioning = 1,
    RelativePositioning = 2,
    IncrementalPositioning = 3,
    // PositioningBitsMask = 3, this enum value conflicts with IncrementalPositioning
    SeekToKeyFrame = 4,
    ReturnTime = 8,
    Segment = 16,
    NoFlush = 32,
};
pub const AM_SEEKING_NoPositioning = AM_SEEKING_SeekingFlags.NoPositioning;
pub const AM_SEEKING_AbsolutePositioning = AM_SEEKING_SeekingFlags.AbsolutePositioning;
pub const AM_SEEKING_RelativePositioning = AM_SEEKING_SeekingFlags.RelativePositioning;
pub const AM_SEEKING_IncrementalPositioning = AM_SEEKING_SeekingFlags.IncrementalPositioning;
pub const AM_SEEKING_PositioningBitsMask = AM_SEEKING_SeekingFlags.IncrementalPositioning;
pub const AM_SEEKING_SeekToKeyFrame = AM_SEEKING_SeekingFlags.SeekToKeyFrame;
pub const AM_SEEKING_ReturnTime = AM_SEEKING_SeekingFlags.ReturnTime;
pub const AM_SEEKING_Segment = AM_SEEKING_SeekingFlags.Segment;
pub const AM_SEEKING_NoFlush = AM_SEEKING_SeekingFlags.NoFlush;

pub const AM_SEEKING_SEEKING_CAPABILITIES = enum(i32) {
    CanSeekAbsolute = 1,
    CanSeekForwards = 2,
    CanSeekBackwards = 4,
    CanGetCurrentPos = 8,
    CanGetStopPos = 16,
    CanGetDuration = 32,
    CanPlayBackwards = 64,
    CanDoSegments = 128,
    Source = 256,
};
pub const AM_SEEKING_CanSeekAbsolute = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekAbsolute;
pub const AM_SEEKING_CanSeekForwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekForwards;
pub const AM_SEEKING_CanSeekBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekBackwards;
pub const AM_SEEKING_CanGetCurrentPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetCurrentPos;
pub const AM_SEEKING_CanGetStopPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetStopPos;
pub const AM_SEEKING_CanGetDuration = AM_SEEKING_SEEKING_CAPABILITIES.CanGetDuration;
pub const AM_SEEKING_CanPlayBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanPlayBackwards;
pub const AM_SEEKING_CanDoSegments = AM_SEEKING_SEEKING_CAPABILITIES.CanDoSegments;
pub const AM_SEEKING_Source = AM_SEEKING_SEEKING_CAPABILITIES.Source;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSeeking_Value = Guid.initString("36b73880-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSeeking = &IID_IMediaSeeking_Value;
pub const IMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: *const fn (
            self: *const IMediaSeeking,
            p_capabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCapabilities: *const fn (
            self: *const IMediaSeeking,
            p_capabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFormatSupported: *const fn (
            self: *const IMediaSeeking,
            p_format: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPreferredFormat: *const fn (
            self: *const IMediaSeeking,
            p_format: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeFormat: *const fn (
            self: *const IMediaSeeking,
            p_format: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingTimeFormat: *const fn (
            self: *const IMediaSeeking,
            p_format: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimeFormat: *const fn (
            self: *const IMediaSeeking,
            p_format: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: *const fn (
            self: *const IMediaSeeking,
            p_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStopPosition: *const fn (
            self: *const IMediaSeeking,
            p_stop: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPosition: *const fn (
            self: *const IMediaSeeking,
            p_current: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertTimeFormat: *const fn (
            self: *const IMediaSeeking,
            p_target: ?*i64,
            p_target_format: ?*const Guid,
            source: i64,
            p_source_format: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositions: *const fn (
            self: *const IMediaSeeking,
            p_current: ?*i64,
            dw_current_flags: u32,
            p_stop: ?*i64,
            dw_stop_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositions: *const fn (
            self: *const IMediaSeeking,
            p_current: ?*i64,
            p_stop: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailable: *const fn (
            self: *const IMediaSeeking,
            p_earliest: ?*i64,
            p_latest: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRate: *const fn (
            self: *const IMediaSeeking,
            d_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRate: *const fn (
            self: *const IMediaSeeking,
            pd_rate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreroll: *const fn (
            self: *const IMediaSeeking,
            pll_preroll: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCapabilities(self: *const T, p_capabilities_: ?*u32) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMediaSeeking, @ptrCast(self)), p_capabilities_);
            }
            pub inline fn checkCapabilities(self: *const T, p_capabilities_: ?*u32) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).CheckCapabilities(@as(*const IMediaSeeking, @ptrCast(self)), p_capabilities_);
            }
            pub inline fn isFormatSupported(self: *const T, p_format_: ?*const Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).IsFormatSupported(@as(*const IMediaSeeking, @ptrCast(self)), p_format_);
            }
            pub inline fn queryPreferredFormat(self: *const T, p_format_: ?*Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).QueryPreferredFormat(@as(*const IMediaSeeking, @ptrCast(self)), p_format_);
            }
            pub inline fn getTimeFormat(self: *const T, p_format_: ?*Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), p_format_);
            }
            pub inline fn isUsingTimeFormat(self: *const T, p_format_: ?*const Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).IsUsingTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), p_format_);
            }
            pub inline fn setTimeFormat(self: *const T, p_format_: ?*const Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), p_format_);
            }
            pub inline fn getDuration(self: *const T, p_duration_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMediaSeeking, @ptrCast(self)), p_duration_);
            }
            pub inline fn getStopPosition(self: *const T, p_stop_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetStopPosition(@as(*const IMediaSeeking, @ptrCast(self)), p_stop_);
            }
            pub inline fn getCurrentPosition(self: *const T, p_current_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IMediaSeeking, @ptrCast(self)), p_current_);
            }
            pub inline fn convertTimeFormat(self: *const T, p_target_: ?*i64, p_target_format_: ?*const Guid, source_: i64, p_source_format_: ?*const Guid) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).ConvertTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), p_target_, p_target_format_, source_, p_source_format_);
            }
            pub inline fn setPositions(self: *const T, p_current_: ?*i64, dw_current_flags_: u32, p_stop_: ?*i64, dw_stop_flags_: u32) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetPositions(@as(*const IMediaSeeking, @ptrCast(self)), p_current_, dw_current_flags_, p_stop_, dw_stop_flags_);
            }
            pub inline fn getPositions(self: *const T, p_current_: ?*i64, p_stop_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetPositions(@as(*const IMediaSeeking, @ptrCast(self)), p_current_, p_stop_);
            }
            pub inline fn getAvailable(self: *const T, p_earliest_: ?*i64, p_latest_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetAvailable(@as(*const IMediaSeeking, @ptrCast(self)), p_earliest_, p_latest_);
            }
            pub inline fn setRate(self: *const T, d_rate_: f64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetRate(@as(*const IMediaSeeking, @ptrCast(self)), d_rate_);
            }
            pub inline fn getRate(self: *const T, pd_rate_: ?*f64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetRate(@as(*const IMediaSeeking, @ptrCast(self)), pd_rate_);
            }
            pub inline fn getPreroll(self: *const T, pll_preroll_: ?*i64) HRESULT {
                return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetPreroll(@as(*const IMediaSeeking, @ptrCast(self)), pll_preroll_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MEDIAEVENT_FLAGS = enum(i32) {
    Y = 1,
};
pub const AM_MEDIAEVENT_NONOTIFY = AM_MEDIAEVENT_FLAGS.Y;

pub const REGFILTER = extern struct {
    Clsid: Guid,
    Name: ?PWSTR,
};

const IID_IEnumRegFilters_Value = Guid.initString("56a868a4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumRegFilters = &IID_IEnumRegFilters_Value;
pub const IEnumRegFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumRegFilters,
            c_filters: u32,
            ap_reg_filter: [*]?*REGFILTER,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumRegFilters,
            c_filters: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumRegFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumRegFilters,
            pp_enum: ?*?*IEnumRegFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_filters_: u32, ap_reg_filter_: [*]?*REGFILTER, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegFilters, @ptrCast(self)), c_filters_, ap_reg_filter_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_filters_: u32) HRESULT {
                return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegFilters, @ptrCast(self)), c_filters_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegFilters, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumRegFilters) HRESULT {
                return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegFilters, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IFILTERMAPPER_MERIT = enum(i32) {
    PREFERRED = 8388608,
    NORMAL = 6291456,
    UNLIKELY = 4194304,
    DO_NOT_USE = 2097152,
    SW_COMPRESSOR = 1048576,
    HW_COMPRESSOR = 1048656,
};
pub const MERIT_PREFERRED = IFILTERMAPPER_MERIT.PREFERRED;
pub const MERIT_NORMAL = IFILTERMAPPER_MERIT.NORMAL;
pub const MERIT_UNLIKELY = IFILTERMAPPER_MERIT.UNLIKELY;
pub const MERIT_DO_NOT_USE = IFILTERMAPPER_MERIT.DO_NOT_USE;
pub const MERIT_SW_COMPRESSOR = IFILTERMAPPER_MERIT.SW_COMPRESSOR;
pub const MERIT_HW_COMPRESSOR = IFILTERMAPPER_MERIT.HW_COMPRESSOR;

const IID_IFilterMapper_Value = Guid.initString("56a868a3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterMapper = &IID_IFilterMapper_Value;
pub const IFilterMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterFilter: *const fn (
            self: *const IFilterMapper,
            clsid: Guid,
            name: ?[*:0]const u16,
            dw_merit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterFilterInstance: *const fn (
            self: *const IFilterMapper,
            clsid: Guid,
            name: ?[*:0]const u16,
            m_r_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPin: *const fn (
            self: *const IFilterMapper,
            filter: Guid,
            name: ?[*:0]const u16,
            b_rendered: BOOL,
            b_output: BOOL,
            b_zero: BOOL,
            b_many: BOOL,
            connects_to_filter: Guid,
            connects_to_pin: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPinType: *const fn (
            self: *const IFilterMapper,
            cls_filter: Guid,
            str_name: ?[*:0]const u16,
            cls_major_type: Guid,
            cls_sub_type: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilter: *const fn (
            self: *const IFilterMapper,
            filter: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilterInstance: *const fn (
            self: *const IFilterMapper,
            m_r_id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterPin: *const fn (
            self: *const IFilterMapper,
            filter: Guid,
            name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMatchingFilters: *const fn (
            self: *const IFilterMapper,
            pp_enum: ?*?*IEnumRegFilters,
            dw_merit: u32,
            b_input_needed: BOOL,
            cls_in_maj: Guid,
            cls_in_sub: Guid,
            b_render: BOOL,
            b_outut_needed: BOOL,
            cls_out_maj: Guid,
            cls_out_sub: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerFilter(self: *const T, clsid_: Guid, name_: ?[*:0]const u16, dw_merit_: u32) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterFilter(@as(*const IFilterMapper, @ptrCast(self)), clsid_, name_, dw_merit_);
            }
            pub inline fn registerFilterInstance(self: *const T, clsid_: Guid, name_: ?[*:0]const u16, m_r_id_: ?*Guid) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterFilterInstance(@as(*const IFilterMapper, @ptrCast(self)), clsid_, name_, m_r_id_);
            }
            pub inline fn registerPin(self: *const T, filter_: Guid, name_: ?[*:0]const u16, b_rendered_: BOOL, b_output_: BOOL, b_zero_: BOOL, b_many_: BOOL, connects_to_filter_: Guid, connects_to_pin_: ?[*:0]const u16) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterPin(@as(*const IFilterMapper, @ptrCast(self)), filter_, name_, b_rendered_, b_output_, b_zero_, b_many_, connects_to_filter_, connects_to_pin_);
            }
            pub inline fn registerPinType(self: *const T, cls_filter_: Guid, str_name_: ?[*:0]const u16, cls_major_type_: Guid, cls_sub_type_: Guid) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterPinType(@as(*const IFilterMapper, @ptrCast(self)), cls_filter_, str_name_, cls_major_type_, cls_sub_type_);
            }
            pub inline fn unregisterFilter(self: *const T, filter_: Guid) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterFilter(@as(*const IFilterMapper, @ptrCast(self)), filter_);
            }
            pub inline fn unregisterFilterInstance(self: *const T, m_r_id_: Guid) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterFilterInstance(@as(*const IFilterMapper, @ptrCast(self)), m_r_id_);
            }
            pub inline fn unregisterPin(self: *const T, filter_: Guid, name_: ?[*:0]const u16) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterPin(@as(*const IFilterMapper, @ptrCast(self)), filter_, name_);
            }
            pub inline fn enumMatchingFilters(self: *const T, pp_enum_: ?*?*IEnumRegFilters, dw_merit_: u32, b_input_needed_: BOOL, cls_in_maj_: Guid, cls_in_sub_: Guid, b_render_: BOOL, b_outut_needed_: BOOL, cls_out_maj_: Guid, cls_out_sub_: Guid) HRESULT {
                return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).EnumMatchingFilters(@as(*const IFilterMapper, @ptrCast(self)), pp_enum_, dw_merit_, b_input_needed_, cls_in_maj_, cls_in_sub_, b_render_, b_outut_needed_, cls_out_maj_, cls_out_sub_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const REGPINTYPES = extern struct {
    clsMajorType: ?*const Guid,
    clsMinorType: ?*const Guid,
};

pub const REGFILTERPINS = extern struct {
    strName: ?PWSTR,
    bRendered: BOOL,
    bOutput: BOOL,
    bZero: BOOL,
    bMany: BOOL,
    clsConnectsToFilter: ?*const Guid,
    strConnectsToPin: ?[*:0]const u16,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
};

pub const REGPINMEDIUM = extern struct {
    clsMedium: Guid,
    dw1: u32,
    dw2: u32,
};

pub const REG_PINFLAG = enum(u32) {
    ZERO = 1,
    RENDERER = 2,
    MANY = 4,
    OUTPUT = 8,
    _,
    pub fn initFlags(o: struct {
        ZERO: u1 = 0,
        RENDERER: u1 = 0,
        MANY: u1 = 0,
        OUTPUT: u1 = 0,
    }) REG_PINFLAG {
        return @as(REG_PINFLAG, @enumFromInt((if (o.ZERO == 1) @intFromEnum(REG_PINFLAG.ZERO) else 0) | (if (o.RENDERER == 1) @intFromEnum(REG_PINFLAG.RENDERER) else 0) | (if (o.MANY == 1) @intFromEnum(REG_PINFLAG.MANY) else 0) | (if (o.OUTPUT == 1) @intFromEnum(REG_PINFLAG.OUTPUT) else 0)));
    }
};
pub const REG_PINFLAG_B_ZERO = REG_PINFLAG.ZERO;
pub const REG_PINFLAG_B_RENDERER = REG_PINFLAG.RENDERER;
pub const REG_PINFLAG_B_MANY = REG_PINFLAG.MANY;
pub const REG_PINFLAG_B_OUTPUT = REG_PINFLAG.OUTPUT;

pub const REGFILTERPINS2 = extern struct {
    dwFlags: u32,
    cInstances: u32,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
    nMediums: u32,
    lpMedium: ?*const REGPINMEDIUM,
    clsPinCategory: ?*const Guid,
};

pub const REGFILTER2 = extern struct {
    dwVersion: u32,
    dwMerit: u32,
    Anonymous: extern union {
        Anonymous1: extern struct {
            cPins: u32,
            rgPins: ?*const REGFILTERPINS,
        },
        Anonymous2: extern struct {
            cPins2: u32,
            rgPins2: ?*const REGFILTERPINS2,
        },
    },
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterMapper2_Value = Guid.initString("b79bb0b0-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper2 = &IID_IFilterMapper2_Value;
pub const IFilterMapper2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCategory: *const fn (
            self: *const IFilterMapper2,
            clsid_category: ?*const Guid,
            dw_category_merit: u32,
            description: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilter: *const fn (
            self: *const IFilterMapper2,
            pclsid_category: ?*const Guid,
            sz_instance: ?[*:0]const u16,
            filter: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterFilter: *const fn (
            self: *const IFilterMapper2,
            clsid_filter: ?*const Guid,
            name: ?[*:0]const u16,
            pp_moniker: ?*?*IMoniker,
            pclsid_category: ?*const Guid,
            sz_instance: ?[*:0]const u16,
            prf2: ?*const REGFILTER2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMatchingFilters: *const fn (
            self: *const IFilterMapper2,
            pp_enum: ?*?*IEnumMoniker,
            dw_flags: u32,
            b_exact_match: BOOL,
            dw_merit: u32,
            b_input_needed: BOOL,
            c_input_types: u32,
            p_input_types: ?*const Guid,
            p_med_in: ?*const REGPINMEDIUM,
            p_pin_category_in: ?*const Guid,
            b_render: BOOL,
            b_output_needed: BOOL,
            c_output_types: u32,
            p_output_types: ?*const Guid,
            p_med_out: ?*const REGPINMEDIUM,
            p_pin_category_out: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createCategory(self: *const T, clsid_category_: ?*const Guid, dw_category_merit_: u32, description_: ?[*:0]const u16) HRESULT {
                return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).CreateCategory(@as(*const IFilterMapper2, @ptrCast(self)), clsid_category_, dw_category_merit_, description_);
            }
            pub inline fn unregisterFilter(self: *const T, pclsid_category_: ?*const Guid, sz_instance_: ?[*:0]const u16, filter_: ?*const Guid) HRESULT {
                return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).UnregisterFilter(@as(*const IFilterMapper2, @ptrCast(self)), pclsid_category_, sz_instance_, filter_);
            }
            pub inline fn registerFilter(self: *const T, clsid_filter_: ?*const Guid, name_: ?[*:0]const u16, pp_moniker_: ?*?*IMoniker, pclsid_category_: ?*const Guid, sz_instance_: ?[*:0]const u16, prf2_: ?*const REGFILTER2) HRESULT {
                return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).RegisterFilter(@as(*const IFilterMapper2, @ptrCast(self)), clsid_filter_, name_, pp_moniker_, pclsid_category_, sz_instance_, prf2_);
            }
            pub inline fn enumMatchingFilters(self: *const T, pp_enum_: ?*?*IEnumMoniker, dw_flags_: u32, b_exact_match_: BOOL, dw_merit_: u32, b_input_needed_: BOOL, c_input_types_: u32, p_input_types_: ?*const Guid, p_med_in_: ?*const REGPINMEDIUM, p_pin_category_in_: ?*const Guid, b_render_: BOOL, b_output_needed_: BOOL, c_output_types_: u32, p_output_types_: ?*const Guid, p_med_out_: ?*const REGPINMEDIUM, p_pin_category_out_: ?*const Guid) HRESULT {
                return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).EnumMatchingFilters(@as(*const IFilterMapper2, @ptrCast(self)), pp_enum_, dw_flags_, b_exact_match_, dw_merit_, b_input_needed_, c_input_types_, p_input_types_, p_med_in_, p_pin_category_in_, b_render_, b_output_needed_, c_output_types_, p_output_types_, p_med_out_, p_pin_category_out_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterMapper3_Value = Guid.initString("b79bb0b1-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper3 = &IID_IFilterMapper3_Value;
pub const IFilterMapper3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterMapper2.VTable,
        GetICreateDevEnum: *const fn (
            self: *const IFilterMapper3,
            pp_enum: ?*?*ICreateDevEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFilterMapper2.MethodMixin(T);
            pub inline fn getICreateDevEnum(self: *const T, pp_enum_: ?*?*ICreateDevEnum) HRESULT {
                return @as(*const IFilterMapper3.VTable, @ptrCast(self.vtable)).GetICreateDevEnum(@as(*const IFilterMapper3, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const QualityMessageType = enum(i32) {
    amine = 0,
    lood = 1,
};
pub const Famine = QualityMessageType.amine;
pub const Flood = QualityMessageType.lood;

pub const Quality = extern struct {
    Type: QualityMessageType,
    Proportion: i32,
    Late: i64,
    TimeStamp: i64,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQualityControl_Value = Guid.initString("56a868a5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQualityControl = &IID_IQualityControl_Value;
pub const IQualityControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: *const fn (
            self: *const IQualityControl,
            p_self: ?*IBaseFilter,
            q: Quality,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSink: *const fn (
            self: *const IQualityControl,
            piqc: ?*IQualityControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn notify(self: *const T, p_self_: ?*IBaseFilter, q_: Quality) HRESULT {
                return @as(*const IQualityControl.VTable, @ptrCast(self.vtable)).Notify(@as(*const IQualityControl, @ptrCast(self)), p_self_, q_);
            }
            pub inline fn setSink(self: *const T, piqc_: ?*IQualityControl) HRESULT {
                return @as(*const IQualityControl.VTable, @ptrCast(self.vtable)).SetSink(@as(*const IQualityControl, @ptrCast(self)), piqc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COLORKEY_TYPE = enum(i32) {
    NOCOLORKEY = 0,
    INDEX = 1,
    RGB = 2,
};
pub const CK_NOCOLORKEY = COLORKEY_TYPE.NOCOLORKEY;
pub const CK_INDEX = COLORKEY_TYPE.INDEX;
pub const CK_RGB = COLORKEY_TYPE.RGB;

pub const COLORKEY = extern struct {
    KeyType: u32,
    PaletteIndex: u32,
    LowColorValue: u32,
    HighColorValue: u32,
};

pub const ADVISE_TYPE = enum(u32) {
    NONE = 0,
    CLIPPING = 1,
    PALETTE = 2,
    COLORKEY = 4,
    POSITION = 8,
    DISPLAY_CHANGE = 16,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CLIPPING: u1 = 0,
        PALETTE: u1 = 0,
        COLORKEY: u1 = 0,
        POSITION: u1 = 0,
        DISPLAY_CHANGE: u1 = 0,
    }) ADVISE_TYPE {
        return @as(ADVISE_TYPE, @enumFromInt((if (o.NONE == 1) @intFromEnum(ADVISE_TYPE.NONE) else 0) | (if (o.CLIPPING == 1) @intFromEnum(ADVISE_TYPE.CLIPPING) else 0) | (if (o.PALETTE == 1) @intFromEnum(ADVISE_TYPE.PALETTE) else 0) | (if (o.COLORKEY == 1) @intFromEnum(ADVISE_TYPE.COLORKEY) else 0) | (if (o.POSITION == 1) @intFromEnum(ADVISE_TYPE.POSITION) else 0) | (if (o.DISPLAY_CHANGE == 1) @intFromEnum(ADVISE_TYPE.DISPLAY_CHANGE) else 0)));
    }
};
pub const ADVISE_NONE = ADVISE_TYPE.NONE;
pub const ADVISE_CLIPPING = ADVISE_TYPE.CLIPPING;
pub const ADVISE_PALETTE = ADVISE_TYPE.PALETTE;
pub const ADVISE_COLORKEY = ADVISE_TYPE.COLORKEY;
pub const ADVISE_POSITION = ADVISE_TYPE.POSITION;
pub const ADVISE_DISPLAY_CHANGE = ADVISE_TYPE.DISPLAY_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify_Value = Guid.initString("56a868a0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlayNotify = &IID_IOverlayNotify_Value;
pub const IOverlayNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaletteChange: *const fn (
            self: *const IOverlayNotify,
            dw_colors: u32,
            p_palette: ?*const PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClipChange: *const fn (
            self: *const IOverlayNotify,
            p_source_rect: ?*const RECT,
            p_destination_rect: ?*const RECT,
            p_rgn_data: ?*const RGNDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnColorKeyChange: *const fn (
            self: *const IOverlayNotify,
            p_color_key: ?*const COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPositionChange: *const fn (
            self: *const IOverlayNotify,
            p_source_rect: ?*const RECT,
            p_destination_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onPaletteChange(self: *const T, dw_colors_: u32, p_palette_: ?*const PALETTEENTRY) HRESULT {
                return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnPaletteChange(@as(*const IOverlayNotify, @ptrCast(self)), dw_colors_, p_palette_);
            }
            pub inline fn onClipChange(self: *const T, p_source_rect_: ?*const RECT, p_destination_rect_: ?*const RECT, p_rgn_data_: ?*const RGNDATA) HRESULT {
                return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnClipChange(@as(*const IOverlayNotify, @ptrCast(self)), p_source_rect_, p_destination_rect_, p_rgn_data_);
            }
            pub inline fn onColorKeyChange(self: *const T, p_color_key_: ?*const COLORKEY) HRESULT {
                return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnColorKeyChange(@as(*const IOverlayNotify, @ptrCast(self)), p_color_key_);
            }
            pub inline fn onPositionChange(self: *const T, p_source_rect_: ?*const RECT, p_destination_rect_: ?*const RECT) HRESULT {
                return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnPositionChange(@as(*const IOverlayNotify, @ptrCast(self)), p_source_rect_, p_destination_rect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify2_Value = Guid.initString("680efa10-d535-11d1-87c8-00a0c9223196");
pub const IID_IOverlayNotify2 = &IID_IOverlayNotify2_Value;
pub const IOverlayNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IOverlayNotify.VTable,
        OnDisplayChange: *const fn (
            self: *const IOverlayNotify2,
            h_monitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOverlayNotify.MethodMixin(T);
            pub inline fn onDisplayChange(self: *const T, h_monitor_: ?HMONITOR) HRESULT {
                return @as(*const IOverlayNotify2.VTable, @ptrCast(self.vtable)).OnDisplayChange(@as(*const IOverlayNotify2, @ptrCast(self)), h_monitor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlay_Value = Guid.initString("56a868a1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlay = &IID_IOverlay_Value;
pub const IOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPalette: *const fn (
            self: *const IOverlay,
            pdw_colors: ?*u32,
            pp_palette: [*]?*PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPalette: *const fn (
            self: *const IOverlay,
            dw_colors: u32,
            p_palette: [*]PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultColorKey: *const fn (
            self: *const IOverlay,
            p_color_key: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: *const fn (
            self: *const IOverlay,
            p_color_key: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: *const fn (
            self: *const IOverlay,
            p_color_key: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowHandle: *const fn (
            self: *const IOverlay,
            p_hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipList: *const fn (
            self: *const IOverlay,
            p_source_rect: ?*RECT,
            p_destination_rect: ?*RECT,
            pp_rgn_data: ?*?*RGNDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: *const fn (
            self: *const IOverlay,
            p_source_rect: ?*RECT,
            p_destination_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn (
            self: *const IOverlay,
            p_overlay_notify: ?*IOverlayNotify,
            dw_interests: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn (
            self: *const IOverlay,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPalette(self: *const T, pdw_colors_: ?*u32, pp_palette_: [*]?*PALETTEENTRY) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetPalette(@as(*const IOverlay, @ptrCast(self)), pdw_colors_, pp_palette_);
            }
            pub inline fn setPalette(self: *const T, dw_colors_: u32, p_palette_: [*]PALETTEENTRY) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).SetPalette(@as(*const IOverlay, @ptrCast(self)), dw_colors_, p_palette_);
            }
            pub inline fn getDefaultColorKey(self: *const T, p_color_key_: ?*COLORKEY) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetDefaultColorKey(@as(*const IOverlay, @ptrCast(self)), p_color_key_);
            }
            pub inline fn getColorKey(self: *const T, p_color_key_: ?*COLORKEY) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IOverlay, @ptrCast(self)), p_color_key_);
            }
            pub inline fn setColorKey(self: *const T, p_color_key_: ?*COLORKEY) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IOverlay, @ptrCast(self)), p_color_key_);
            }
            pub inline fn getWindowHandle(self: *const T, p_hwnd_: ?*?HWND) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetWindowHandle(@as(*const IOverlay, @ptrCast(self)), p_hwnd_);
            }
            pub inline fn getClipList(self: *const T, p_source_rect_: ?*RECT, p_destination_rect_: ?*RECT, pp_rgn_data_: ?*?*RGNDATA) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetClipList(@as(*const IOverlay, @ptrCast(self)), p_source_rect_, p_destination_rect_, pp_rgn_data_);
            }
            pub inline fn getVideoPosition(self: *const T, p_source_rect_: ?*RECT, p_destination_rect_: ?*RECT) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IOverlay, @ptrCast(self)), p_source_rect_, p_destination_rect_);
            }
            pub inline fn advise(self: *const T, p_overlay_notify_: ?*IOverlayNotify, dw_interests_: u32) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).Advise(@as(*const IOverlay, @ptrCast(self)), p_overlay_notify_, dw_interests_);
            }
            pub inline fn unadvise(self: *const T) HRESULT {
                return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IOverlay, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventSink_Value = Guid.initString("56a868a2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventSink = &IID_IMediaEventSink_Value;
pub const IMediaEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: *const fn (
            self: *const IMediaEventSink,
            event_code: i32,
            event_param1: isize,
            event_param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn notify(self: *const T, event_code_: i32, event_param1_: isize, event_param2_: isize) HRESULT {
                return @as(*const IMediaEventSink.VTable, @ptrCast(self.vtable)).Notify(@as(*const IMediaEventSink, @ptrCast(self)), event_code_, event_param1_, event_param2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSourceFilter_Value = Guid.initString("56a868a6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFileSourceFilter = &IID_IFileSourceFilter_Value;
pub const IFileSourceFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Load: *const fn (
            self: *const IFileSourceFilter,
            psz_file_name: ?[*:0]const u16,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: *const fn (
            self: *const IFileSourceFilter,
            ppsz_file_name: ?*?PWSTR,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn load(self: *const T, psz_file_name_: ?[*:0]const u16, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFileSourceFilter.VTable, @ptrCast(self.vtable)).Load(@as(*const IFileSourceFilter, @ptrCast(self)), psz_file_name_, pmt_);
            }
            pub inline fn getCurFile(self: *const T, ppsz_file_name_: ?*?PWSTR, pmt_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFileSourceFilter.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IFileSourceFilter, @ptrCast(self)), ppsz_file_name_, pmt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter_Value = Guid.initString("a2104830-7c70-11cf-8bce-00aa00a3f1a6");
pub const IID_IFileSinkFilter = &IID_IFileSinkFilter_Value;
pub const IFileSinkFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFileName: *const fn (
            self: *const IFileSinkFilter,
            psz_file_name: ?[*:0]const u16,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: *const fn (
            self: *const IFileSinkFilter,
            ppsz_file_name: ?*?PWSTR,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setFileName(self: *const T, psz_file_name_: ?[*:0]const u16, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFileSinkFilter.VTable, @ptrCast(self.vtable)).SetFileName(@as(*const IFileSinkFilter, @ptrCast(self)), psz_file_name_, pmt_);
            }
            pub inline fn getCurFile(self: *const T, ppsz_file_name_: ?*?PWSTR, pmt_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFileSinkFilter.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IFileSinkFilter, @ptrCast(self)), ppsz_file_name_, pmt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter2_Value = Guid.initString("00855b90-ce1b-11d0-bd4f-00a0c911ce86");
pub const IID_IFileSinkFilter2 = &IID_IFileSinkFilter2_Value;
pub const IFileSinkFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSinkFilter.VTable,
        SetMode: *const fn (
            self: *const IFileSinkFilter2,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMode: *const fn (
            self: *const IFileSinkFilter2,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileSinkFilter.MethodMixin(T);
            pub inline fn setMode(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IFileSinkFilter2.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IFileSinkFilter2, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getMode(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IFileSinkFilter2.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IFileSinkFilter2, @ptrCast(self)), pdw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_FILESINK_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILE_OVERWRITE = AM_FILESINK_FLAGS.E;

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphBuilder_Value = Guid.initString("56a868a9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphBuilder = &IID_IGraphBuilder_Value;
pub const IGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph.VTable,
        Connect: *const fn (
            self: *const IGraphBuilder,
            ppin_out: ?*IPin,
            ppin_in: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: *const fn (
            self: *const IGraphBuilder,
            ppin_out: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderFile: *const fn (
            self: *const IGraphBuilder,
            lpcwstr_file: ?[*:0]const u16,
            lpcwstr_play_list: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSourceFilter: *const fn (
            self: *const IGraphBuilder,
            lpcwstr_file_name: ?[*:0]const u16,
            lpcwstr_filter_name: ?[*:0]const u16,
            pp_filter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogFile: *const fn (
            self: *const IGraphBuilder,
            h_file: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: *const fn (
            self: *const IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShouldOperationContinue: *const fn (
            self: *const IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFilterGraph.MethodMixin(T);
            pub inline fn connect(self: *const T, ppin_out_: ?*IPin, ppin_in_: ?*IPin) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Connect(@as(*const IGraphBuilder, @ptrCast(self)), ppin_out_, ppin_in_);
            }
            pub inline fn render(self: *const T, ppin_out_: ?*IPin) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Render(@as(*const IGraphBuilder, @ptrCast(self)), ppin_out_);
            }
            pub inline fn renderFile(self: *const T, lpcwstr_file_: ?[*:0]const u16, lpcwstr_play_list_: ?[*:0]const u16) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).RenderFile(@as(*const IGraphBuilder, @ptrCast(self)), lpcwstr_file_, lpcwstr_play_list_);
            }
            pub inline fn addSourceFilter(self: *const T, lpcwstr_file_name_: ?[*:0]const u16, lpcwstr_filter_name_: ?[*:0]const u16, pp_filter_: ?*?*IBaseFilter) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).AddSourceFilter(@as(*const IGraphBuilder, @ptrCast(self)), lpcwstr_file_name_, lpcwstr_filter_name_, pp_filter_);
            }
            pub inline fn setLogFile(self: *const T, h_file_: usize) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).SetLogFile(@as(*const IGraphBuilder, @ptrCast(self)), h_file_);
            }
            pub inline fn abort(self: *const T) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Abort(@as(*const IGraphBuilder, @ptrCast(self)));
            }
            pub inline fn shouldOperationContinue(self: *const T) HRESULT {
                return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).ShouldOperationContinue(@as(*const IGraphBuilder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptureGraphBuilder_Value = Guid.initString("bf87b6e0-8c27-11d0-b3f0-00aa003761c5");
pub const IID_ICaptureGraphBuilder = &IID_ICaptureGraphBuilder_Value;
pub const ICaptureGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: *const fn (
            self: *const ICaptureGraphBuilder,
            pfg: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiltergraph: *const fn (
            self: *const ICaptureGraphBuilder,
            ppfg: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFileName: *const fn (
            self: *const ICaptureGraphBuilder,
            p_type: ?*const Guid,
            lpstr_file: ?[*:0]const u16,
            ppf: ?*?*IBaseFilter,
            pp_sink: ?*?*IFileSinkFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindInterface: *const fn (
            self: *const ICaptureGraphBuilder,
            p_category: ?*const Guid,
            pf: ?*IBaseFilter,
            riid: ?*const Guid,
            ppint: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderStream: *const fn (
            self: *const ICaptureGraphBuilder,
            p_category: ?*const Guid,
            p_source: ?*IUnknown,
            pf_compressor: ?*IBaseFilter,
            pf_renderer: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlStream: *const fn (
            self: *const ICaptureGraphBuilder,
            p_category: ?*const Guid,
            p_filter: ?*IBaseFilter,
            pstart: ?*i64,
            pstop: ?*i64,
            w_start_cookie: u16,
            w_stop_cookie: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocCapFile: *const fn (
            self: *const ICaptureGraphBuilder,
            lpstr: ?[*:0]const u16,
            dwl_size: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyCaptureFile: *const fn (
            self: *const ICaptureGraphBuilder,
            lpwstr_old: ?PWSTR,
            lpwstr_new: ?PWSTR,
            f_allow_esc_abort: i32,
            p_callback: ?*IAMCopyCaptureFileProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setFiltergraph(self: *const T, pfg_: ?*IGraphBuilder) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).SetFiltergraph(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pfg_);
            }
            pub inline fn getFiltergraph(self: *const T, ppfg_: ?*?*IGraphBuilder) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const ICaptureGraphBuilder, @ptrCast(self)), ppfg_);
            }
            pub inline fn setOutputFileName(self: *const T, p_type_: ?*const Guid, lpstr_file_: ?[*:0]const u16, ppf_: ?*?*IBaseFilter, pp_sink_: ?*?*IFileSinkFilter) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const ICaptureGraphBuilder, @ptrCast(self)), p_type_, lpstr_file_, ppf_, pp_sink_);
            }
            pub inline fn findInterface(self: *const T, p_category_: ?*const Guid, pf_: ?*IBaseFilter, riid_: ?*const Guid, ppint_: ?*?*anyopaque) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).FindInterface(@as(*const ICaptureGraphBuilder, @ptrCast(self)), p_category_, pf_, riid_, ppint_);
            }
            pub inline fn renderStream(self: *const T, p_category_: ?*const Guid, p_source_: ?*IUnknown, pf_compressor_: ?*IBaseFilter, pf_renderer_: ?*IBaseFilter) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).RenderStream(@as(*const ICaptureGraphBuilder, @ptrCast(self)), p_category_, p_source_, pf_compressor_, pf_renderer_);
            }
            pub inline fn controlStream(self: *const T, p_category_: ?*const Guid, p_filter_: ?*IBaseFilter, pstart_: ?*i64, pstop_: ?*i64, w_start_cookie_: u16, w_stop_cookie_: u16) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).ControlStream(@as(*const ICaptureGraphBuilder, @ptrCast(self)), p_category_, p_filter_, pstart_, pstop_, w_start_cookie_, w_stop_cookie_);
            }
            pub inline fn allocCapFile(self: *const T, lpstr_: ?[*:0]const u16, dwl_size_: u64) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).AllocCapFile(@as(*const ICaptureGraphBuilder, @ptrCast(self)), lpstr_, dwl_size_);
            }
            pub inline fn copyCaptureFile(self: *const T, lpwstr_old_: ?PWSTR, lpwstr_new_: ?PWSTR, f_allow_esc_abort_: i32, p_callback_: ?*IAMCopyCaptureFileProgress) HRESULT {
                return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).CopyCaptureFile(@as(*const ICaptureGraphBuilder, @ptrCast(self)), lpwstr_old_, lpwstr_new_, f_allow_esc_abort_, p_callback_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCopyCaptureFileProgress_Value = Guid.initString("670d1d20-a068-11d0-b3f0-00aa003761c5");
pub const IID_IAMCopyCaptureFileProgress = &IID_IAMCopyCaptureFileProgress_Value;
pub const IAMCopyCaptureFileProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: *const fn (
            self: *const IAMCopyCaptureFileProgress,
            i_progress: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn progress(self: *const T, i_progress_: i32) HRESULT {
                return @as(*const IAMCopyCaptureFileProgress.VTable, @ptrCast(self.vtable)).Progress(@as(*const IAMCopyCaptureFileProgress, @ptrCast(self)), i_progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICaptureGraphBuilder2_Value = Guid.initString("93e5a4e0-2d50-11d2-abfa-00a0c9c6e38d");
pub const IID_ICaptureGraphBuilder2 = &IID_ICaptureGraphBuilder2_Value;
pub const ICaptureGraphBuilder2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: *const fn (
            self: *const ICaptureGraphBuilder2,
            pfg: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiltergraph: *const fn (
            self: *const ICaptureGraphBuilder2,
            ppfg: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFileName: *const fn (
            self: *const ICaptureGraphBuilder2,
            p_type: ?*const Guid,
            lpstr_file: ?[*:0]const u16,
            ppf: ?*?*IBaseFilter,
            pp_sink: ?*?*IFileSinkFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindInterface: *const fn (
            self: *const ICaptureGraphBuilder2,
            p_category: ?*const Guid,
            p_type: ?*const Guid,
            pf: ?*IBaseFilter,
            riid: ?*const Guid,
            ppint: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderStream: *const fn (
            self: *const ICaptureGraphBuilder2,
            p_category: ?*const Guid,
            p_type: ?*const Guid,
            p_source: ?*IUnknown,
            pf_compressor: ?*IBaseFilter,
            pf_renderer: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlStream: *const fn (
            self: *const ICaptureGraphBuilder2,
            p_category: ?*const Guid,
            p_type: ?*const Guid,
            p_filter: ?*IBaseFilter,
            pstart: ?*i64,
            pstop: ?*i64,
            w_start_cookie: u16,
            w_stop_cookie: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocCapFile: *const fn (
            self: *const ICaptureGraphBuilder2,
            lpstr: ?[*:0]const u16,
            dwl_size: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyCaptureFile: *const fn (
            self: *const ICaptureGraphBuilder2,
            lpwstr_old: ?PWSTR,
            lpwstr_new: ?PWSTR,
            f_allow_esc_abort: i32,
            p_callback: ?*IAMCopyCaptureFileProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPin: *const fn (
            self: *const ICaptureGraphBuilder2,
            p_source: ?*IUnknown,
            pindir: PIN_DIRECTION,
            p_category: ?*const Guid,
            p_type: ?*const Guid,
            f_unconnected: BOOL,
            num: i32,
            pp_pin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setFiltergraph(self: *const T, pfg_: ?*IGraphBuilder) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).SetFiltergraph(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pfg_);
            }
            pub inline fn getFiltergraph(self: *const T, ppfg_: ?*?*IGraphBuilder) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), ppfg_);
            }
            pub inline fn setOutputFileName(self: *const T, p_type_: ?*const Guid, lpstr_file_: ?[*:0]const u16, ppf_: ?*?*IBaseFilter, pp_sink_: ?*?*IFileSinkFilter) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), p_type_, lpstr_file_, ppf_, pp_sink_);
            }
            pub inline fn findInterface(self: *const T, p_category_: ?*const Guid, p_type_: ?*const Guid, pf_: ?*IBaseFilter, riid_: ?*const Guid, ppint_: ?*?*anyopaque) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).FindInterface(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), p_category_, p_type_, pf_, riid_, ppint_);
            }
            pub inline fn renderStream(self: *const T, p_category_: ?*const Guid, p_type_: ?*const Guid, p_source_: ?*IUnknown, pf_compressor_: ?*IBaseFilter, pf_renderer_: ?*IBaseFilter) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).RenderStream(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), p_category_, p_type_, p_source_, pf_compressor_, pf_renderer_);
            }
            pub inline fn controlStream(self: *const T, p_category_: ?*const Guid, p_type_: ?*const Guid, p_filter_: ?*IBaseFilter, pstart_: ?*i64, pstop_: ?*i64, w_start_cookie_: u16, w_stop_cookie_: u16) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).ControlStream(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), p_category_, p_type_, p_filter_, pstart_, pstop_, w_start_cookie_, w_stop_cookie_);
            }
            pub inline fn allocCapFile(self: *const T, lpstr_: ?[*:0]const u16, dwl_size_: u64) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).AllocCapFile(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), lpstr_, dwl_size_);
            }
            pub inline fn copyCaptureFile(self: *const T, lpwstr_old_: ?PWSTR, lpwstr_new_: ?PWSTR, f_allow_esc_abort_: i32, p_callback_: ?*IAMCopyCaptureFileProgress) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).CopyCaptureFile(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), lpwstr_old_, lpwstr_new_, f_allow_esc_abort_, p_callback_);
            }
            pub inline fn findPin(self: *const T, p_source_: ?*IUnknown, pindir_: PIN_DIRECTION, p_category_: ?*const Guid, p_type_: ?*const Guid, f_unconnected_: BOOL, num_: i32, pp_pin_: ?*?*IPin) HRESULT {
                return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).FindPin(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), p_source_, pindir_, p_category_, p_type_, f_unconnected_, num_, pp_pin_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_RENSDEREXFLAGS = enum(i32) {
    S = 1,
};
pub const AM_RENDEREX_RENDERTOEXISTINGRENDERERS = _AM_RENSDEREXFLAGS.S;

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph2_Value = Guid.initString("36b73882-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IFilterGraph2 = &IID_IFilterGraph2_Value;
pub const IFilterGraph2 = extern struct {
    pub const VTable = extern struct {
        base: IGraphBuilder.VTable,
        AddSourceFilterForMoniker: *const fn (
            self: *const IFilterGraph2,
            p_moniker: ?*IMoniker,
            p_ctx: ?*IBindCtx,
            lpcwstr_filter_name: ?[*:0]const u16,
            pp_filter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReconnectEx: *const fn (
            self: *const IFilterGraph2,
            ppin: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderEx: *const fn (
            self: *const IFilterGraph2,
            p_pin_out: ?*IPin,
            dw_flags: u32,
            pv_context: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IGraphBuilder.MethodMixin(T);
            pub inline fn addSourceFilterForMoniker(self: *const T, p_moniker_: ?*IMoniker, p_ctx_: ?*IBindCtx, lpcwstr_filter_name_: ?[*:0]const u16, pp_filter_: ?*?*IBaseFilter) HRESULT {
                return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).AddSourceFilterForMoniker(@as(*const IFilterGraph2, @ptrCast(self)), p_moniker_, p_ctx_, lpcwstr_filter_name_, pp_filter_);
            }
            pub inline fn reconnectEx(self: *const T, ppin_: ?*IPin, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).ReconnectEx(@as(*const IFilterGraph2, @ptrCast(self)), ppin_, pmt_);
            }
            pub inline fn renderEx(self: *const T, p_pin_out_: ?*IPin, dw_flags_: u32, pv_context_: ?*u32) HRESULT {
                return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).RenderEx(@as(*const IFilterGraph2, @ptrCast(self)), p_pin_out_, dw_flags_, pv_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFilterGraph3_Value = Guid.initString("aaf38154-b80b-422f-91e6-b66467509a07");
pub const IID_IFilterGraph3 = &IID_IFilterGraph3_Value;
pub const IFilterGraph3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph2.VTable,
        SetSyncSourceEx: *const fn (
            self: *const IFilterGraph3,
            p_clock_for_most_of_filter_graph: ?*IReferenceClock,
            p_clock_for_filter: ?*IReferenceClock,
            p_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFilterGraph2.MethodMixin(T);
            pub inline fn setSyncSourceEx(self: *const T, p_clock_for_most_of_filter_graph_: ?*IReferenceClock, p_clock_for_filter_: ?*IReferenceClock, p_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterGraph3.VTable, @ptrCast(self.vtable)).SetSyncSourceEx(@as(*const IFilterGraph3, @ptrCast(self)), p_clock_for_most_of_filter_graph_, p_clock_for_filter_, p_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStreamBuilder_Value = Guid.initString("56a868bf-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IStreamBuilder = &IID_IStreamBuilder_Value;
pub const IStreamBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Render: *const fn (
            self: *const IStreamBuilder,
            ppin_out: ?*IPin,
            p_graph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backout: *const fn (
            self: *const IStreamBuilder,
            ppin_out: ?*IPin,
            p_graph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn render(self: *const T, ppin_out_: ?*IPin, p_graph_: ?*IGraphBuilder) HRESULT {
                return @as(*const IStreamBuilder.VTable, @ptrCast(self.vtable)).Render(@as(*const IStreamBuilder, @ptrCast(self)), ppin_out_, p_graph_);
            }
            pub inline fn backout(self: *const T, ppin_out_: ?*IPin, p_graph_: ?*IGraphBuilder) HRESULT {
                return @as(*const IStreamBuilder.VTable, @ptrCast(self.vtable)).Backout(@as(*const IStreamBuilder, @ptrCast(self)), ppin_out_, p_graph_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAsyncReader_Value = Guid.initString("56a868aa-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAsyncReader = &IID_IAsyncReader_Value;
pub const IAsyncReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestAllocator: *const fn (
            self: *const IAsyncReader,
            p_preferred: ?*IMemAllocator,
            p_props: ?*ALLOCATOR_PROPERTIES,
            pp_actual: ?*?*IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Request: *const fn (
            self: *const IAsyncReader,
            p_sample: ?*IMediaSample,
            dw_user: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForNext: *const fn (
            self: *const IAsyncReader,
            dw_timeout: u32,
            pp_sample: ?*?*IMediaSample,
            pdw_user: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncReadAligned: *const fn (
            self: *const IAsyncReader,
            p_sample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncRead: *const fn (
            self: *const IAsyncReader,
            ll_position: i64,
            l_length: i32,
            // TODO: what to do with BytesParamIndex 1?
            p_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Length: *const fn (
            self: *const IAsyncReader,
            p_total: ?*i64,
            p_available: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFlush: *const fn (
            self: *const IAsyncReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFlush: *const fn (
            self: *const IAsyncReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn requestAllocator(self: *const T, p_preferred_: ?*IMemAllocator, p_props_: ?*ALLOCATOR_PROPERTIES, pp_actual_: ?*?*IMemAllocator) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).RequestAllocator(@as(*const IAsyncReader, @ptrCast(self)), p_preferred_, p_props_, pp_actual_);
            }
            pub inline fn request(self: *const T, p_sample_: ?*IMediaSample, dw_user_: usize) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).Request(@as(*const IAsyncReader, @ptrCast(self)), p_sample_, dw_user_);
            }
            pub inline fn waitForNext(self: *const T, dw_timeout_: u32, pp_sample_: ?*?*IMediaSample, pdw_user_: ?*usize) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).WaitForNext(@as(*const IAsyncReader, @ptrCast(self)), dw_timeout_, pp_sample_, pdw_user_);
            }
            pub inline fn syncReadAligned(self: *const T, p_sample_: ?*IMediaSample) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).SyncReadAligned(@as(*const IAsyncReader, @ptrCast(self)), p_sample_);
            }
            pub inline fn syncRead(self: *const T, ll_position_: i64, l_length_: i32, p_buffer_: ?*u8) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).SyncRead(@as(*const IAsyncReader, @ptrCast(self)), ll_position_, l_length_, p_buffer_);
            }
            pub inline fn length(self: *const T, p_total_: ?*i64, p_available_: ?*i64) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).Length(@as(*const IAsyncReader, @ptrCast(self)), p_total_, p_available_);
            }
            pub inline fn beginFlush(self: *const T) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).BeginFlush(@as(*const IAsyncReader, @ptrCast(self)));
            }
            pub inline fn endFlush(self: *const T) HRESULT {
                return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).EndFlush(@as(*const IAsyncReader, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphVersion_Value = Guid.initString("56a868ab-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphVersion = &IID_IGraphVersion_Value;
pub const IGraphVersion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryVersion: *const fn (
            self: *const IGraphVersion,
            p_version: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryVersion(self: *const T, p_version_: ?*i32) HRESULT {
                return @as(*const IGraphVersion.VTable, @ptrCast(self.vtable)).QueryVersion(@as(*const IGraphVersion, @ptrCast(self)), p_version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceConsumer_Value = Guid.initString("56a868ad-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceConsumer = &IID_IResourceConsumer_Value;
pub const IResourceConsumer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireResource: *const fn (
            self: *const IResourceConsumer,
            id_resource: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseResource: *const fn (
            self: *const IResourceConsumer,
            id_resource: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn acquireResource(self: *const T, id_resource_: i32) HRESULT {
                return @as(*const IResourceConsumer.VTable, @ptrCast(self.vtable)).AcquireResource(@as(*const IResourceConsumer, @ptrCast(self)), id_resource_);
            }
            pub inline fn releaseResource(self: *const T, id_resource_: i32) HRESULT {
                return @as(*const IResourceConsumer.VTable, @ptrCast(self.vtable)).ReleaseResource(@as(*const IResourceConsumer, @ptrCast(self)), id_resource_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceManager_Value = Guid.initString("56a868ac-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceManager = &IID_IResourceManager_Value;
pub const IResourceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const IResourceManager,
            p_name: ?[*:0]const u16,
            c_resource: i32,
            pl_token: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGroup: *const fn (
            self: *const IResourceManager,
            p_name: ?[*:0]const u16,
            c_resource: i32,
            pal_tokens: [*]i32,
            pl_token: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestResource: *const fn (
            self: *const IResourceManager,
            id_resource: i32,
            p_focus_object: ?*IUnknown,
            p_consumer: ?*IResourceConsumer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAcquire: *const fn (
            self: *const IResourceManager,
            id_resource: i32,
            p_consumer: ?*IResourceConsumer,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyRelease: *const fn (
            self: *const IResourceManager,
            id_resource: i32,
            p_consumer: ?*IResourceConsumer,
            b_still_want: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelRequest: *const fn (
            self: *const IResourceManager,
            id_resource: i32,
            p_consumer: ?*IResourceConsumer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: *const fn (
            self: *const IResourceManager,
            p_focus_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFocus: *const fn (
            self: *const IResourceManager,
            p_focus_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T, p_name_: ?[*:0]const u16, c_resource_: i32, pl_token_: ?*i32) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).Register(@as(*const IResourceManager, @ptrCast(self)), p_name_, c_resource_, pl_token_);
            }
            pub inline fn registerGroup(self: *const T, p_name_: ?[*:0]const u16, c_resource_: i32, pal_tokens_: [*]i32, pl_token_: ?*i32) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).RegisterGroup(@as(*const IResourceManager, @ptrCast(self)), p_name_, c_resource_, pal_tokens_, pl_token_);
            }
            pub inline fn requestResource(self: *const T, id_resource_: i32, p_focus_object_: ?*IUnknown, p_consumer_: ?*IResourceConsumer) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).RequestResource(@as(*const IResourceManager, @ptrCast(self)), id_resource_, p_focus_object_, p_consumer_);
            }
            pub inline fn notifyAcquire(self: *const T, id_resource_: i32, p_consumer_: ?*IResourceConsumer, hr_: HRESULT) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).NotifyAcquire(@as(*const IResourceManager, @ptrCast(self)), id_resource_, p_consumer_, hr_);
            }
            pub inline fn notifyRelease(self: *const T, id_resource_: i32, p_consumer_: ?*IResourceConsumer, b_still_want_: BOOL) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).NotifyRelease(@as(*const IResourceManager, @ptrCast(self)), id_resource_, p_consumer_, b_still_want_);
            }
            pub inline fn cancelRequest(self: *const T, id_resource_: i32, p_consumer_: ?*IResourceConsumer) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).CancelRequest(@as(*const IResourceManager, @ptrCast(self)), id_resource_, p_consumer_);
            }
            pub inline fn setFocus(self: *const T, p_focus_object_: ?*IUnknown) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const IResourceManager, @ptrCast(self)), p_focus_object_);
            }
            pub inline fn releaseFocus(self: *const T, p_focus_object_: ?*IUnknown) HRESULT {
                return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).ReleaseFocus(@as(*const IResourceManager, @ptrCast(self)), p_focus_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDistributorNotify_Value = Guid.initString("56a868af-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDistributorNotify = &IID_IDistributorNotify_Value;
pub const IDistributorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Stop: *const fn (
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: *const fn (
            self: *const IDistributorNotify,
            t_start: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncSource: *const fn (
            self: *const IDistributorNotify,
            p_clock: ?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyGraphChange: *const fn (
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Stop(@as(*const IDistributorNotify, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Pause(@as(*const IDistributorNotify, @ptrCast(self)));
            }
            pub inline fn run(self: *const T, t_start_: i64) HRESULT {
                return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Run(@as(*const IDistributorNotify, @ptrCast(self)), t_start_);
            }
            pub inline fn setSyncSource(self: *const T, p_clock_: ?*IReferenceClock) HRESULT {
                return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).SetSyncSource(@as(*const IDistributorNotify, @ptrCast(self)), p_clock_);
            }
            pub inline fn notifyGraphChange(self: *const T) HRESULT {
                return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).NotifyGraphChange(@as(*const IDistributorNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_STREAM_INFO_FLAGS = enum(i32) {
    START_DEFINED = 1,
    STOP_DEFINED = 2,
    DISCARDING = 4,
    STOP_SEND_EXTRA = 16,
};
pub const AM_STREAM_INFO_START_DEFINED = AM_STREAM_INFO_FLAGS.START_DEFINED;
pub const AM_STREAM_INFO_STOP_DEFINED = AM_STREAM_INFO_FLAGS.STOP_DEFINED;
pub const AM_STREAM_INFO_DISCARDING = AM_STREAM_INFO_FLAGS.DISCARDING;
pub const AM_STREAM_INFO_STOP_SEND_EXTRA = AM_STREAM_INFO_FLAGS.STOP_SEND_EXTRA;

pub const AM_STREAM_INFO = extern struct {
    tStart: i64,
    tStop: i64,
    dwStartCookie: u32,
    dwStopCookie: u32,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamControl_Value = Guid.initString("36b73881-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IAMStreamControl = &IID_IAMStreamControl_Value;
pub const IAMStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartAt: *const fn (
            self: *const IAMStreamControl,
            pt_start: ?*const i64,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopAt: *const fn (
            self: *const IAMStreamControl,
            pt_stop: ?*const i64,
            b_send_extra: BOOL,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: *const fn (
            self: *const IAMStreamControl,
            p_info: ?*AM_STREAM_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startAt(self: *const T, pt_start_: ?*const i64, dw_cookie_: u32) HRESULT {
                return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).StartAt(@as(*const IAMStreamControl, @ptrCast(self)), pt_start_, dw_cookie_);
            }
            pub inline fn stopAt(self: *const T, pt_stop_: ?*const i64, b_send_extra_: BOOL, dw_cookie_: u32) HRESULT {
                return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).StopAt(@as(*const IAMStreamControl, @ptrCast(self)), pt_stop_, b_send_extra_, dw_cookie_);
            }
            pub inline fn getInfo(self: *const T, p_info_: ?*AM_STREAM_INFO) HRESULT {
                return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMStreamControl, @ptrCast(self)), p_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISeekingPassThru_Value = Guid.initString("36b73883-c2c8-11cf-8b46-00805f6cef60");
pub const IID_ISeekingPassThru = &IID_ISeekingPassThru_Value;
pub const ISeekingPassThru = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const ISeekingPassThru,
            b_support_rendering: BOOL,
            p_pin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, b_support_rendering_: BOOL, p_pin_: ?*IPin) HRESULT {
                return @as(*const ISeekingPassThru.VTable, @ptrCast(self.vtable)).Init(@as(*const ISeekingPassThru, @ptrCast(self)), b_support_rendering_, p_pin_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VIDEO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    VideoStandard: u32,
    InputSize: SIZE,
    MinCroppingSize: SIZE,
    MaxCroppingSize: SIZE,
    CropGranularityX: i32,
    CropGranularityY: i32,
    CropAlignX: i32,
    CropAlignY: i32,
    MinOutputSize: SIZE,
    MaxOutputSize: SIZE,
    OutputGranularityX: i32,
    OutputGranularityY: i32,
    StretchTapsX: i32,
    StretchTapsY: i32,
    ShrinkTapsX: i32,
    ShrinkTapsY: i32,
    MinFrameInterval: i64,
    MaxFrameInterval: i64,
    MinBitsPerSecond: i32,
    MaxBitsPerSecond: i32,
};

pub const AUDIO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    MinimumChannels: u32,
    MaximumChannels: u32,
    ChannelsGranularity: u32,
    MinimumBitsPerSample: u32,
    MaximumBitsPerSample: u32,
    BitsPerSampleGranularity: u32,
    MinimumSampleFrequency: u32,
    MaximumSampleFrequency: u32,
    SampleFrequencyGranularity: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamConfig_Value = Guid.initString("c6e13340-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMStreamConfig = &IID_IAMStreamConfig_Value;
pub const IAMStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFormat: *const fn (
            self: *const IAMStreamConfig,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: *const fn (
            self: *const IAMStreamConfig,
            ppmt: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfCapabilities: *const fn (
            self: *const IAMStreamConfig,
            pi_count: ?*i32,
            pi_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamCaps: *const fn (
            self: *const IAMStreamConfig,
            i_index: i32,
            ppmt: ?*?*AM_MEDIA_TYPE,
            p_s_c_c: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setFormat(self: *const T, pmt_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAMStreamConfig, @ptrCast(self)), pmt_);
            }
            pub inline fn getFormat(self: *const T, ppmt_: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAMStreamConfig, @ptrCast(self)), ppmt_);
            }
            pub inline fn getNumberOfCapabilities(self: *const T, pi_count_: ?*i32, pi_size_: ?*i32) HRESULT {
                return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetNumberOfCapabilities(@as(*const IAMStreamConfig, @ptrCast(self)), pi_count_, pi_size_);
            }
            pub inline fn getStreamCaps(self: *const T, i_index_: i32, ppmt_: ?*?*AM_MEDIA_TYPE, p_s_c_c_: ?*u8) HRESULT {
                return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamCaps(@as(*const IAMStreamConfig, @ptrCast(self)), i_index_, ppmt_, p_s_c_c_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const InterleavingMode = enum(i32) {
    NONE = 0,
    CAPTURE = 1,
    FULL = 2,
    NONE_BUFFERED = 3,
};
pub const INTERLEAVE_NONE = InterleavingMode.NONE;
pub const INTERLEAVE_CAPTURE = InterleavingMode.CAPTURE;
pub const INTERLEAVE_FULL = InterleavingMode.FULL;
pub const INTERLEAVE_NONE_BUFFERED = InterleavingMode.NONE_BUFFERED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigInterleaving_Value = Guid.initString("bee3d220-157b-11d0-bd23-00a0c911ce86");
pub const IID_IConfigInterleaving = &IID_IConfigInterleaving_Value;
pub const IConfigInterleaving = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IConfigInterleaving,
            mode: InterleavingMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IConfigInterleaving,
            p_mode: ?*InterleavingMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interleaving: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IConfigInterleaving,
            prt_interleave: ?*const i64,
            prt_preroll: ?*const i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interleaving: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IConfigInterleaving,
            prt_interleave: ?*i64,
            prt_preroll: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putMode(self: *const T, mode_: InterleavingMode) HRESULT {
                return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IConfigInterleaving, @ptrCast(self)), mode_);
            }
            pub inline fn getMode(self: *const T, p_mode_: ?*InterleavingMode) HRESULT {
                return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IConfigInterleaving, @ptrCast(self)), p_mode_);
            }
            pub inline fn putInterleaving(self: *const T, prt_interleave_: ?*const i64, prt_preroll_: ?*const i64) HRESULT {
                return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).put_Interleaving(@as(*const IConfigInterleaving, @ptrCast(self)), prt_interleave_, prt_preroll_);
            }
            pub inline fn getInterleaving(self: *const T, prt_interleave_: ?*i64, prt_preroll_: ?*i64) HRESULT {
                return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).get_Interleaving(@as(*const IConfigInterleaving, @ptrCast(self)), prt_interleave_, prt_preroll_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigAviMux_Value = Guid.initString("5acd6aa0-f482-11ce-8b67-00aa00a3f1a6");
pub const IID_IConfigAviMux = &IID_IConfigAviMux_Value;
pub const IConfigAviMux = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterStream: *const fn (
            self: *const IConfigAviMux,
            i_stream: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterStream: *const fn (
            self: *const IConfigAviMux,
            p_stream: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCompatibilityIndex: *const fn (
            self: *const IConfigAviMux,
            f_old_index: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCompatibilityIndex: *const fn (
            self: *const IConfigAviMux,
            pf_old_index: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMasterStream(self: *const T, i_stream_: i32) HRESULT {
                return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).SetMasterStream(@as(*const IConfigAviMux, @ptrCast(self)), i_stream_);
            }
            pub inline fn getMasterStream(self: *const T, p_stream_: ?*i32) HRESULT {
                return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).GetMasterStream(@as(*const IConfigAviMux, @ptrCast(self)), p_stream_);
            }
            pub inline fn setOutputCompatibilityIndex(self: *const T, f_old_index_: BOOL) HRESULT {
                return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).SetOutputCompatibilityIndex(@as(*const IConfigAviMux, @ptrCast(self)), f_old_index_);
            }
            pub inline fn getOutputCompatibilityIndex(self: *const T, pf_old_index_: ?*BOOL) HRESULT {
                return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).GetOutputCompatibilityIndex(@as(*const IConfigAviMux, @ptrCast(self)), pf_old_index_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CompressionCaps = enum(i32) {
    Quality = 1,
    Crunch = 2,
    KeyFrame = 4,
    BFrame = 8,
    Window = 16,
};
pub const CompressionCaps_CanQuality = CompressionCaps.Quality;
pub const CompressionCaps_CanCrunch = CompressionCaps.Crunch;
pub const CompressionCaps_CanKeyFrame = CompressionCaps.KeyFrame;
pub const CompressionCaps_CanBFrame = CompressionCaps.BFrame;
pub const CompressionCaps_CanWindow = CompressionCaps.Window;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoCompression_Value = Guid.initString("c6e13343-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoCompression = &IID_IAMVideoCompression_Value;
pub const IAMVideoCompression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyFrameRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            key_frame_rate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyFrameRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            p_key_frame_rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PFramesPerKeyFrame: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            p_frames_per_key_frame: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PFramesPerKeyFrame: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            p_p_frames_per_key_frame: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Quality: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            quality: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Quality: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            p_quality: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            window_size: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMVideoCompression,
            p_window_size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: *const fn (
            self: *const IAMVideoCompression,
            // TODO: what to do with BytesParamIndex 1?
            psz_version: ?PWSTR,
            pcb_version: ?*i32,
            // TODO: what to do with BytesParamIndex 3?
            psz_description: ?PWSTR,
            pcb_description: ?*i32,
            p_default_key_frame_rate: ?*i32,
            p_default_p_frames_per_key: ?*i32,
            p_default_quality: ?*f64,
            p_capabilities: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverrideKeyFrame: *const fn (
            self: *const IAMVideoCompression,
            frame_number: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverrideFrameSize: *const fn (
            self: *const IAMVideoCompression,
            frame_number: i32,
            size: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putKeyFrameRate(self: *const T, key_frame_rate_: i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_KeyFrameRate(@as(*const IAMVideoCompression, @ptrCast(self)), key_frame_rate_);
            }
            pub inline fn getKeyFrameRate(self: *const T, p_key_frame_rate_: ?*i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_KeyFrameRate(@as(*const IAMVideoCompression, @ptrCast(self)), p_key_frame_rate_);
            }
            pub inline fn putPFramesPerKeyFrame(self: *const T, p_frames_per_key_frame_: i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_PFramesPerKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), p_frames_per_key_frame_);
            }
            pub inline fn getPFramesPerKeyFrame(self: *const T, p_p_frames_per_key_frame_: ?*i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_PFramesPerKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), p_p_frames_per_key_frame_);
            }
            pub inline fn putQuality(self: *const T, quality_: f64) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_Quality(@as(*const IAMVideoCompression, @ptrCast(self)), quality_);
            }
            pub inline fn getQuality(self: *const T, p_quality_: ?*f64) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_Quality(@as(*const IAMVideoCompression, @ptrCast(self)), p_quality_);
            }
            pub inline fn putWindowSize(self: *const T, window_size_: u64) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_WindowSize(@as(*const IAMVideoCompression, @ptrCast(self)), window_size_);
            }
            pub inline fn getWindowSize(self: *const T, p_window_size_: ?*u64) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_WindowSize(@as(*const IAMVideoCompression, @ptrCast(self)), p_window_size_);
            }
            pub inline fn getInfo(self: *const T, psz_version_: ?PWSTR, pcb_version_: ?*i32, psz_description_: ?PWSTR, pcb_description_: ?*i32, p_default_key_frame_rate_: ?*i32, p_default_p_frames_per_key_: ?*i32, p_default_quality_: ?*f64, p_capabilities_: ?*i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMVideoCompression, @ptrCast(self)), psz_version_, pcb_version_, psz_description_, pcb_description_, p_default_key_frame_rate_, p_default_p_frames_per_key_, p_default_quality_, p_capabilities_);
            }
            pub inline fn overrideKeyFrame(self: *const T, frame_number_: i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).OverrideKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), frame_number_);
            }
            pub inline fn overrideFrameSize(self: *const T, frame_number_: i32, size_: i32) HRESULT {
                return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).OverrideFrameSize(@as(*const IAMVideoCompression, @ptrCast(self)), frame_number_, size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VfwCaptureDialogs = enum(i32) {
    Source = 1,
    Format = 2,
    Display = 4,
};
pub const VfwCaptureDialog_Source = VfwCaptureDialogs.Source;
pub const VfwCaptureDialog_Format = VfwCaptureDialogs.Format;
pub const VfwCaptureDialog_Display = VfwCaptureDialogs.Display;

pub const VfwCompressDialogs = enum(i32) {
    Config = 1,
    About = 2,
    QueryConfig = 4,
    QueryAbout = 8,
};
pub const VfwCompressDialog_Config = VfwCompressDialogs.Config;
pub const VfwCompressDialog_About = VfwCompressDialogs.About;
pub const VfwCompressDialog_QueryConfig = VfwCompressDialogs.QueryConfig;
pub const VfwCompressDialog_QueryAbout = VfwCompressDialogs.QueryAbout;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCaptureDialogs_Value = Guid.initString("d8d715a0-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCaptureDialogs = &IID_IAMVfwCaptureDialogs_Value;
pub const IAMVfwCaptureDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasDialog: *const fn (
            self: *const IAMVfwCaptureDialogs,
            i_dialog: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowDialog: *const fn (
            self: *const IAMVfwCaptureDialogs,
            i_dialog: i32,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDriverMessage: *const fn (
            self: *const IAMVfwCaptureDialogs,
            i_dialog: i32,
            u_msg: i32,
            dw1: i32,
            dw2: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn hasDialog(self: *const T, i_dialog_: i32) HRESULT {
                return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).HasDialog(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), i_dialog_);
            }
            pub inline fn showDialog(self: *const T, i_dialog_: i32, hwnd_: ?HWND) HRESULT {
                return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).ShowDialog(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), i_dialog_, hwnd_);
            }
            pub inline fn sendDriverMessage(self: *const T, i_dialog_: i32, u_msg_: i32, dw1_: i32, dw2_: i32) HRESULT {
                return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).SendDriverMessage(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), i_dialog_, u_msg_, dw1_, dw2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCompressDialogs_Value = Guid.initString("d8d715a3-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCompressDialogs = &IID_IAMVfwCompressDialogs_Value;
pub const IAMVfwCompressDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDialog: *const fn (
            self: *const IAMVfwCompressDialogs,
            i_dialog: i32,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IAMVfwCompressDialogs,
            // TODO: what to do with BytesParamIndex 1?
            p_state: ?*anyopaque,
            pcb_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: *const fn (
            self: *const IAMVfwCompressDialogs,
            // TODO: what to do with BytesParamIndex 1?
            p_state: ?*anyopaque,
            cb_state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDriverMessage: *const fn (
            self: *const IAMVfwCompressDialogs,
            u_msg: i32,
            dw1: i32,
            dw2: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn showDialog(self: *const T, i_dialog_: i32, hwnd_: ?HWND) HRESULT {
                return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).ShowDialog(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), i_dialog_, hwnd_);
            }
            pub inline fn getState(self: *const T, p_state_: ?*anyopaque, pcb_state_: ?*i32) HRESULT {
                return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), p_state_, pcb_state_);
            }
            pub inline fn setState(self: *const T, p_state_: ?*anyopaque, cb_state_: i32) HRESULT {
                return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).SetState(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), p_state_, cb_state_);
            }
            pub inline fn sendDriverMessage(self: *const T, u_msg_: i32, dw1_: i32, dw2_: i32) HRESULT {
                return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).SendDriverMessage(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), u_msg_, dw1_, dw2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDroppedFrames_Value = Guid.initString("c6e13344-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMDroppedFrames = &IID_IAMDroppedFrames_Value;
pub const IAMDroppedFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumDropped: *const fn (
            self: *const IAMDroppedFrames,
            pl_dropped: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumNotDropped: *const fn (
            self: *const IAMDroppedFrames,
            pl_not_dropped: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDroppedInfo: *const fn (
            self: *const IAMDroppedFrames,
            l_size: i32,
            pl_array: ?*i32,
            pl_num_copied: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAverageFrameSize: *const fn (
            self: *const IAMDroppedFrames,
            pl_average_size: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumDropped(self: *const T, pl_dropped_: ?*i32) HRESULT {
                return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetNumDropped(@as(*const IAMDroppedFrames, @ptrCast(self)), pl_dropped_);
            }
            pub inline fn getNumNotDropped(self: *const T, pl_not_dropped_: ?*i32) HRESULT {
                return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetNumNotDropped(@as(*const IAMDroppedFrames, @ptrCast(self)), pl_not_dropped_);
            }
            pub inline fn getDroppedInfo(self: *const T, l_size_: i32, pl_array_: ?*i32, pl_num_copied_: ?*i32) HRESULT {
                return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetDroppedInfo(@as(*const IAMDroppedFrames, @ptrCast(self)), l_size_, pl_array_, pl_num_copied_);
            }
            pub inline fn getAverageFrameSize(self: *const T, pl_average_size_: ?*i32) HRESULT {
                return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetAverageFrameSize(@as(*const IAMDroppedFrames, @ptrCast(self)), pl_average_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAudioInputMixer_Value = Guid.initString("54c39221-8380-11d0-b3f0-00aa003761c5");
pub const IID_IAMAudioInputMixer = &IID_IAMAudioInputMixer_Value;
pub const IAMAudioInputMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            f_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            pf_enable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mono: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            f_mono: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mono: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            pf_mono: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            level: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_level: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            pan: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_pan: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Loudness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            f_loudness: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Loudness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            pf_loudness: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Treble: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            treble: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Treble: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_treble: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrebleRange: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_range: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            bass: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_bass: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BassRange: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAudioInputMixer,
            p_range: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putEnable(self: *const T, f_enable_: BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Enable(@as(*const IAMAudioInputMixer, @ptrCast(self)), f_enable_);
            }
            pub inline fn getEnable(self: *const T, pf_enable_: ?*BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Enable(@as(*const IAMAudioInputMixer, @ptrCast(self)), pf_enable_);
            }
            pub inline fn putMono(self: *const T, f_mono_: BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Mono(@as(*const IAMAudioInputMixer, @ptrCast(self)), f_mono_);
            }
            pub inline fn getMono(self: *const T, pf_mono_: ?*BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Mono(@as(*const IAMAudioInputMixer, @ptrCast(self)), pf_mono_);
            }
            pub inline fn putMixLevel(self: *const T, level_: f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_MixLevel(@as(*const IAMAudioInputMixer, @ptrCast(self)), level_);
            }
            pub inline fn getMixLevel(self: *const T, p_level_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_MixLevel(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_level_);
            }
            pub inline fn putPan(self: *const T, pan_: f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Pan(@as(*const IAMAudioInputMixer, @ptrCast(self)), pan_);
            }
            pub inline fn getPan(self: *const T, p_pan_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Pan(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_pan_);
            }
            pub inline fn putLoudness(self: *const T, f_loudness_: BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Loudness(@as(*const IAMAudioInputMixer, @ptrCast(self)), f_loudness_);
            }
            pub inline fn getLoudness(self: *const T, pf_loudness_: ?*BOOL) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Loudness(@as(*const IAMAudioInputMixer, @ptrCast(self)), pf_loudness_);
            }
            pub inline fn putTreble(self: *const T, treble_: f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Treble(@as(*const IAMAudioInputMixer, @ptrCast(self)), treble_);
            }
            pub inline fn getTreble(self: *const T, p_treble_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Treble(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_treble_);
            }
            pub inline fn getTrebleRange(self: *const T, p_range_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_TrebleRange(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_range_);
            }
            pub inline fn putBass(self: *const T, bass_: f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Bass(@as(*const IAMAudioInputMixer, @ptrCast(self)), bass_);
            }
            pub inline fn getBass(self: *const T, p_bass_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Bass(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_bass_);
            }
            pub inline fn getBassRange(self: *const T, p_range_: ?*f64) HRESULT {
                return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_BassRange(@as(*const IAMAudioInputMixer, @ptrCast(self)), p_range_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMBufferNegotiation_Value = Guid.initString("56ed71a0-af5f-11d0-b3f0-00aa003761c5");
pub const IID_IAMBufferNegotiation = &IID_IAMBufferNegotiation_Value;
pub const IAMBufferNegotiation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuggestAllocatorProperties: *const fn (
            self: *const IAMBufferNegotiation,
            pprop: ?*const ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatorProperties: *const fn (
            self: *const IAMBufferNegotiation,
            pprop: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn suggestAllocatorProperties(self: *const T, pprop_: ?*const ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IAMBufferNegotiation.VTable, @ptrCast(self.vtable)).SuggestAllocatorProperties(@as(*const IAMBufferNegotiation, @ptrCast(self)), pprop_);
            }
            pub inline fn getAllocatorProperties(self: *const T, pprop_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IAMBufferNegotiation.VTable, @ptrCast(self.vtable)).GetAllocatorProperties(@as(*const IAMBufferNegotiation, @ptrCast(self)), pprop_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AnalogVideoStandard = enum(i32) {
    _None = 0,
    _NTSC_M = 1,
    _NTSC_M_J = 2,
    _NTSC_433 = 4,
    _PAL_B = 16,
    _PAL_D = 32,
    _PAL_G = 64,
    _PAL_H = 128,
    _PAL_I = 256,
    _PAL_M = 512,
    _PAL_N = 1024,
    _PAL_60 = 2048,
    _SECAM_B = 4096,
    _SECAM_D = 8192,
    _SECAM_G = 16384,
    _SECAM_H = 32768,
    _SECAM_K = 65536,
    _SECAM_K1 = 131072,
    _SECAM_L = 262144,
    _SECAM_L1 = 524288,
    _PAL_N_COMBO = 1048576,
    Mask_MCE_NTSC = 1052167,
    Mask_MCE_PAL = 496,
    Mask_MCE_SECAM = 1044480,
};
pub const AnalogVideo_None = AnalogVideoStandard._None;
pub const AnalogVideo_NTSC_M = AnalogVideoStandard._NTSC_M;
pub const AnalogVideo_NTSC_M_J = AnalogVideoStandard._NTSC_M_J;
pub const AnalogVideo_NTSC_433 = AnalogVideoStandard._NTSC_433;
pub const AnalogVideo_PAL_B = AnalogVideoStandard._PAL_B;
pub const AnalogVideo_PAL_D = AnalogVideoStandard._PAL_D;
pub const AnalogVideo_PAL_G = AnalogVideoStandard._PAL_G;
pub const AnalogVideo_PAL_H = AnalogVideoStandard._PAL_H;
pub const AnalogVideo_PAL_I = AnalogVideoStandard._PAL_I;
pub const AnalogVideo_PAL_M = AnalogVideoStandard._PAL_M;
pub const AnalogVideo_PAL_N = AnalogVideoStandard._PAL_N;
pub const AnalogVideo_PAL_60 = AnalogVideoStandard._PAL_60;
pub const AnalogVideo_SECAM_B = AnalogVideoStandard._SECAM_B;
pub const AnalogVideo_SECAM_D = AnalogVideoStandard._SECAM_D;
pub const AnalogVideo_SECAM_G = AnalogVideoStandard._SECAM_G;
pub const AnalogVideo_SECAM_H = AnalogVideoStandard._SECAM_H;
pub const AnalogVideo_SECAM_K = AnalogVideoStandard._SECAM_K;
pub const AnalogVideo_SECAM_K1 = AnalogVideoStandard._SECAM_K1;
pub const AnalogVideo_SECAM_L = AnalogVideoStandard._SECAM_L;
pub const AnalogVideo_SECAM_L1 = AnalogVideoStandard._SECAM_L1;
pub const AnalogVideo_PAL_N_COMBO = AnalogVideoStandard._PAL_N_COMBO;
pub const AnalogVideoMask_MCE_NTSC = AnalogVideoStandard.Mask_MCE_NTSC;
pub const AnalogVideoMask_MCE_PAL = AnalogVideoStandard.Mask_MCE_PAL;
pub const AnalogVideoMask_MCE_SECAM = AnalogVideoStandard.Mask_MCE_SECAM;

pub const TunerInputType = enum(i32) {
    Cable = 0,
    Antenna = 1,
};
pub const TunerInputCable = TunerInputType.Cable;
pub const TunerInputAntenna = TunerInputType.Antenna;

pub const VideoCopyProtectionType = enum(i32) {
    Basic = 0,
    CBI = 1,
};
pub const VideoCopyProtectionMacrovisionBasic = VideoCopyProtectionType.Basic;
pub const VideoCopyProtectionMacrovisionCBI = VideoCopyProtectionType.CBI;

pub const PhysicalConnectorType = enum(i32) {
    Video_Tuner = 1,
    Video_Composite = 2,
    Video_SVideo = 3,
    Video_RGB = 4,
    Video_YRYBY = 5,
    Video_SerialDigital = 6,
    Video_ParallelDigital = 7,
    Video_SCSI = 8,
    Video_AUX = 9,
    Video_1394 = 10,
    Video_USB = 11,
    Video_VideoDecoder = 12,
    Video_VideoEncoder = 13,
    Video_SCART = 14,
    Video_Black = 15,
    Audio_Tuner = 4096,
    Audio_Line = 4097,
    Audio_Mic = 4098,
    Audio_AESDigital = 4099,
    Audio_SPDIFDigital = 4100,
    Audio_SCSI = 4101,
    Audio_AUX = 4102,
    Audio_1394 = 4103,
    Audio_USB = 4104,
    Audio_AudioDecoder = 4105,
};
pub const PhysConn_Video_Tuner = PhysicalConnectorType.Video_Tuner;
pub const PhysConn_Video_Composite = PhysicalConnectorType.Video_Composite;
pub const PhysConn_Video_SVideo = PhysicalConnectorType.Video_SVideo;
pub const PhysConn_Video_RGB = PhysicalConnectorType.Video_RGB;
pub const PhysConn_Video_YRYBY = PhysicalConnectorType.Video_YRYBY;
pub const PhysConn_Video_SerialDigital = PhysicalConnectorType.Video_SerialDigital;
pub const PhysConn_Video_ParallelDigital = PhysicalConnectorType.Video_ParallelDigital;
pub const PhysConn_Video_SCSI = PhysicalConnectorType.Video_SCSI;
pub const PhysConn_Video_AUX = PhysicalConnectorType.Video_AUX;
pub const PhysConn_Video_1394 = PhysicalConnectorType.Video_1394;
pub const PhysConn_Video_USB = PhysicalConnectorType.Video_USB;
pub const PhysConn_Video_VideoDecoder = PhysicalConnectorType.Video_VideoDecoder;
pub const PhysConn_Video_VideoEncoder = PhysicalConnectorType.Video_VideoEncoder;
pub const PhysConn_Video_SCART = PhysicalConnectorType.Video_SCART;
pub const PhysConn_Video_Black = PhysicalConnectorType.Video_Black;
pub const PhysConn_Audio_Tuner = PhysicalConnectorType.Audio_Tuner;
pub const PhysConn_Audio_Line = PhysicalConnectorType.Audio_Line;
pub const PhysConn_Audio_Mic = PhysicalConnectorType.Audio_Mic;
pub const PhysConn_Audio_AESDigital = PhysicalConnectorType.Audio_AESDigital;
pub const PhysConn_Audio_SPDIFDigital = PhysicalConnectorType.Audio_SPDIFDigital;
pub const PhysConn_Audio_SCSI = PhysicalConnectorType.Audio_SCSI;
pub const PhysConn_Audio_AUX = PhysicalConnectorType.Audio_AUX;
pub const PhysConn_Audio_1394 = PhysicalConnectorType.Audio_1394;
pub const PhysConn_Audio_USB = PhysicalConnectorType.Audio_USB;
pub const PhysConn_Audio_AudioDecoder = PhysicalConnectorType.Audio_AudioDecoder;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAnalogVideoDecoder_Value = Guid.initString("c6e13350-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoDecoder = &IID_IAMAnalogVideoDecoder_Value;
pub const IAMAnalogVideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            l_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            l_analog_video_standard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            pl_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalLocked: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            pl_locked: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VCRHorizontalLocking: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            l_v_c_r_horizontal_locking: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VCRHorizontalLocking: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            pl_v_c_r_horizontal_locking: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfLines: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            pl_number_of_lines: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            l_output_enable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoDecoder,
            pl_output_enable: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAvailableTVFormats(self: *const T, l_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), l_analog_video_standard_);
            }
            pub inline fn putTVFormat(self: *const T, l_analog_video_standard_: i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_TVFormat(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), l_analog_video_standard_);
            }
            pub inline fn getTVFormat(self: *const T, pl_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), pl_analog_video_standard_);
            }
            pub inline fn getHorizontalLocked(self: *const T, pl_locked_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_HorizontalLocked(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), pl_locked_);
            }
            pub inline fn putVCRHorizontalLocking(self: *const T, l_v_c_r_horizontal_locking_: i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_VCRHorizontalLocking(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), l_v_c_r_horizontal_locking_);
            }
            pub inline fn getVCRHorizontalLocking(self: *const T, pl_v_c_r_horizontal_locking_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_VCRHorizontalLocking(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), pl_v_c_r_horizontal_locking_);
            }
            pub inline fn getNumberOfLines(self: *const T, pl_number_of_lines_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_NumberOfLines(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), pl_number_of_lines_);
            }
            pub inline fn putOutputEnable(self: *const T, l_output_enable_: i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_OutputEnable(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), l_output_enable_);
            }
            pub inline fn getOutputEnable(self: *const T, pl_output_enable_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_OutputEnable(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), pl_output_enable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VideoProcAmpProperty = enum(i32) {
    Brightness = 0,
    Contrast = 1,
    Hue = 2,
    Saturation = 3,
    Sharpness = 4,
    Gamma = 5,
    ColorEnable = 6,
    WhiteBalance = 7,
    BacklightCompensation = 8,
    Gain = 9,
};
pub const VideoProcAmp_Brightness = VideoProcAmpProperty.Brightness;
pub const VideoProcAmp_Contrast = VideoProcAmpProperty.Contrast;
pub const VideoProcAmp_Hue = VideoProcAmpProperty.Hue;
pub const VideoProcAmp_Saturation = VideoProcAmpProperty.Saturation;
pub const VideoProcAmp_Sharpness = VideoProcAmpProperty.Sharpness;
pub const VideoProcAmp_Gamma = VideoProcAmpProperty.Gamma;
pub const VideoProcAmp_ColorEnable = VideoProcAmpProperty.ColorEnable;
pub const VideoProcAmp_WhiteBalance = VideoProcAmpProperty.WhiteBalance;
pub const VideoProcAmp_BacklightCompensation = VideoProcAmpProperty.BacklightCompensation;
pub const VideoProcAmp_Gain = VideoProcAmpProperty.Gain;

pub const VideoProcAmpFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const VideoProcAmp_Flags_Auto = VideoProcAmpFlags.Auto;
pub const VideoProcAmp_Flags_Manual = VideoProcAmpFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoProcAmp_Value = Guid.initString("c6e13360-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoProcAmp = &IID_IAMVideoProcAmp_Value;
pub const IAMVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: *const fn (
            self: *const IAMVideoProcAmp,
            property: i32,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: *const fn (
            self: *const IAMVideoProcAmp,
            property: i32,
            l_value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: *const fn (
            self: *const IAMVideoProcAmp,
            property: i32,
            l_value: ?*i32,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRange(self: *const T, property_: i32, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flags_: ?*i32) HRESULT {
                return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IAMVideoProcAmp, @ptrCast(self)), property_, p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flags_);
            }
            pub inline fn set(self: *const T, property_: i32, l_value_: i32, flags_: i32) HRESULT {
                return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).Set(@as(*const IAMVideoProcAmp, @ptrCast(self)), property_, l_value_, flags_);
            }
            pub inline fn get(self: *const T, property_: i32, l_value_: ?*i32, flags_: ?*i32) HRESULT {
                return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).Get(@as(*const IAMVideoProcAmp, @ptrCast(self)), property_, l_value_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CameraControlProperty = enum(i32) {
    Pan = 0,
    Tilt = 1,
    Roll = 2,
    Zoom = 3,
    Exposure = 4,
    Iris = 5,
    Focus = 6,
};
pub const CameraControl_Pan = CameraControlProperty.Pan;
pub const CameraControl_Tilt = CameraControlProperty.Tilt;
pub const CameraControl_Roll = CameraControlProperty.Roll;
pub const CameraControl_Zoom = CameraControlProperty.Zoom;
pub const CameraControl_Exposure = CameraControlProperty.Exposure;
pub const CameraControl_Iris = CameraControlProperty.Iris;
pub const CameraControl_Focus = CameraControlProperty.Focus;

pub const CameraControlFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const CameraControl_Flags_Auto = CameraControlFlags.Auto;
pub const CameraControl_Flags_Manual = CameraControlFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCameraControl_Value = Guid.initString("c6e13370-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCameraControl = &IID_IAMCameraControl_Value;
pub const IAMCameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: *const fn (
            self: *const IAMCameraControl,
            property: i32,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: *const fn (
            self: *const IAMCameraControl,
            property: i32,
            l_value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: *const fn (
            self: *const IAMCameraControl,
            property: i32,
            l_value: ?*i32,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRange(self: *const T, property_: i32, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flags_: ?*i32) HRESULT {
                return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IAMCameraControl, @ptrCast(self)), property_, p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flags_);
            }
            pub inline fn set(self: *const T, property_: i32, l_value_: i32, flags_: i32) HRESULT {
                return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).Set(@as(*const IAMCameraControl, @ptrCast(self)), property_, l_value_, flags_);
            }
            pub inline fn get(self: *const T, property_: i32, l_value_: ?*i32, flags_: ?*i32) HRESULT {
                return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).Get(@as(*const IAMCameraControl, @ptrCast(self)), property_, l_value_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VideoControlFlags = enum(i32) {
    FlipHorizontal = 1,
    FlipVertical = 2,
    ExternalTriggerEnable = 4,
    Trigger = 8,
};
pub const VideoControlFlag_FlipHorizontal = VideoControlFlags.FlipHorizontal;
pub const VideoControlFlag_FlipVertical = VideoControlFlags.FlipVertical;
pub const VideoControlFlag_ExternalTriggerEnable = VideoControlFlags.ExternalTriggerEnable;
pub const VideoControlFlag_Trigger = VideoControlFlags.Trigger;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoControl_Value = Guid.initString("6a2e0670-28e4-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoControl = &IID_IAMVideoControl_Value;
pub const IAMVideoControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaps: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            p_caps_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMode: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMode: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentActualFrameRate: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            actual_frame_rate: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxAvailableFrameRate: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            i_index: i32,
            dimensions: SIZE,
            max_available_frame_rate: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameRateList: *const fn (
            self: *const IAMVideoControl,
            p_pin: ?*IPin,
            i_index: i32,
            dimensions: SIZE,
            list_size: ?*i32,
            frame_rates: ?*?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCaps(self: *const T, p_pin_: ?*IPin, p_caps_flags_: ?*i32) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, p_caps_flags_);
            }
            pub inline fn setMode(self: *const T, p_pin_: ?*IPin, mode_: i32) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, mode_);
            }
            pub inline fn getMode(self: *const T, p_pin_: ?*IPin, mode_: ?*i32) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, mode_);
            }
            pub inline fn getCurrentActualFrameRate(self: *const T, p_pin_: ?*IPin, actual_frame_rate_: ?*i64) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetCurrentActualFrameRate(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, actual_frame_rate_);
            }
            pub inline fn getMaxAvailableFrameRate(self: *const T, p_pin_: ?*IPin, i_index_: i32, dimensions_: SIZE, max_available_frame_rate_: ?*i64) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetMaxAvailableFrameRate(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, i_index_, dimensions_, max_available_frame_rate_);
            }
            pub inline fn getFrameRateList(self: *const T, p_pin_: ?*IPin, i_index_: i32, dimensions_: SIZE, list_size_: ?*i32, frame_rates_: ?*?*i64) HRESULT {
                return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetFrameRateList(@as(*const IAMVideoControl, @ptrCast(self)), p_pin_, i_index_, dimensions_, list_size_, frame_rates_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCrossbar_Value = Guid.initString("c6e13380-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCrossbar = &IID_IAMCrossbar_Value;
pub const IAMCrossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PinCounts: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMCrossbar,
            output_pin_count: ?*i32,
            input_pin_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanRoute: *const fn (
            self: *const IAMCrossbar,
            output_pin_index: i32,
            input_pin_index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Route: *const fn (
            self: *const IAMCrossbar,
            output_pin_index: i32,
            input_pin_index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRoutedTo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMCrossbar,
            output_pin_index: i32,
            input_pin_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CrossbarPinInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMCrossbar,
            is_input_pin: BOOL,
            pin_index: i32,
            pin_index_related: ?*i32,
            physical_type: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPinCounts(self: *const T, output_pin_count_: ?*i32, input_pin_count_: ?*i32) HRESULT {
                return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_PinCounts(@as(*const IAMCrossbar, @ptrCast(self)), output_pin_count_, input_pin_count_);
            }
            pub inline fn canRoute(self: *const T, output_pin_index_: i32, input_pin_index_: i32) HRESULT {
                return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).CanRoute(@as(*const IAMCrossbar, @ptrCast(self)), output_pin_index_, input_pin_index_);
            }
            pub inline fn route(self: *const T, output_pin_index_: i32, input_pin_index_: i32) HRESULT {
                return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).Route(@as(*const IAMCrossbar, @ptrCast(self)), output_pin_index_, input_pin_index_);
            }
            pub inline fn getIsRoutedTo(self: *const T, output_pin_index_: i32, input_pin_index_: ?*i32) HRESULT {
                return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_IsRoutedTo(@as(*const IAMCrossbar, @ptrCast(self)), output_pin_index_, input_pin_index_);
            }
            pub inline fn getCrossbarPinInfo(self: *const T, is_input_pin_: BOOL, pin_index_: i32, pin_index_related_: ?*i32, physical_type_: ?*i32) HRESULT {
                return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_CrossbarPinInfo(@as(*const IAMCrossbar, @ptrCast(self)), is_input_pin_, pin_index_, pin_index_related_, physical_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMTunerSubChannel = enum(i32) {
    NO_TUNE = -2,
    DEFAULT = -1,
};
pub const AMTUNER_SUBCHAN_NO_TUNE = AMTunerSubChannel.NO_TUNE;
pub const AMTUNER_SUBCHAN_DEFAULT = AMTunerSubChannel.DEFAULT;

pub const AMTunerSignalStrength = enum(i32) {
    HASNOSIGNALSTRENGTH = -1,
    NOSIGNAL = 0,
    SIGNALPRESENT = 1,
};
pub const AMTUNER_HASNOSIGNALSTRENGTH = AMTunerSignalStrength.HASNOSIGNALSTRENGTH;
pub const AMTUNER_NOSIGNAL = AMTunerSignalStrength.NOSIGNAL;
pub const AMTUNER_SIGNALPRESENT = AMTunerSignalStrength.SIGNALPRESENT;

pub const AMTunerModeType = enum(i32) {
    DEFAULT = 0,
    TV = 1,
    FM_RADIO = 2,
    AM_RADIO = 4,
    DSS = 8,
};
pub const AMTUNER_MODE_DEFAULT = AMTunerModeType.DEFAULT;
pub const AMTUNER_MODE_TV = AMTunerModeType.TV;
pub const AMTUNER_MODE_FM_RADIO = AMTunerModeType.FM_RADIO;
pub const AMTUNER_MODE_AM_RADIO = AMTunerModeType.AM_RADIO;
pub const AMTUNER_MODE_DSS = AMTunerModeType.DSS;

pub const AMTunerEventType = enum(i32) {
    D = 1,
};
pub const AMTUNER_EVENT_CHANGED = AMTunerEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTuner_Value = Guid.initString("211a8761-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTuner = &IID_IAMTuner_Value;
pub const IAMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            l_channel: i32,
            l_video_sub_channel: i32,
            l_audio_sub_channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            pl_channel: ?*i32,
            pl_video_sub_channel: ?*i32,
            pl_audio_sub_channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChannelMinMax: *const fn (
            self: *const IAMTuner,
            l_channel_min: ?*i32,
            l_channel_max: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            l_country_code: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            pl_country_code: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            l_tuning_space: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            pl_tuning_space: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logon: *const fn (
            self: *const IAMTuner,
            h_current_user: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logout: *const fn (
            self: *const IAMTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SignalPresent: *const fn (
            self: *const IAMTuner,
            pl_signal_strength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            l_mode: AMTunerModeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTuner,
            pl_mode: ?*AMTunerModeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableModes: *const fn (
            self: *const IAMTuner,
            pl_modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotificationCallBack: *const fn (
            self: *const IAMTuner,
            p_notify: ?*IAMTunerNotification,
            l_events: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterNotificationCallBack: *const fn (
            self: *const IAMTuner,
            p_notify: ?*IAMTunerNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putChannel(self: *const T, l_channel_: i32, l_video_sub_channel_: i32, l_audio_sub_channel_: i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IAMTuner, @ptrCast(self)), l_channel_, l_video_sub_channel_, l_audio_sub_channel_);
            }
            pub inline fn getChannel(self: *const T, pl_channel_: ?*i32, pl_video_sub_channel_: ?*i32, pl_audio_sub_channel_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IAMTuner, @ptrCast(self)), pl_channel_, pl_video_sub_channel_, pl_audio_sub_channel_);
            }
            pub inline fn channelMinMax(self: *const T, l_channel_min_: ?*i32, l_channel_max_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).ChannelMinMax(@as(*const IAMTuner, @ptrCast(self)), l_channel_min_, l_channel_max_);
            }
            pub inline fn putCountryCode(self: *const T, l_country_code_: i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAMTuner, @ptrCast(self)), l_country_code_);
            }
            pub inline fn getCountryCode(self: *const T, pl_country_code_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAMTuner, @ptrCast(self)), pl_country_code_);
            }
            pub inline fn putTuningSpace(self: *const T, l_tuning_space_: i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const IAMTuner, @ptrCast(self)), l_tuning_space_);
            }
            pub inline fn getTuningSpace(self: *const T, pl_tuning_space_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const IAMTuner, @ptrCast(self)), pl_tuning_space_);
            }
            pub inline fn logon(self: *const T, h_current_user_: ?HANDLE) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).Logon(@as(*const IAMTuner, @ptrCast(self)), h_current_user_);
            }
            pub inline fn logout(self: *const T) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).Logout(@as(*const IAMTuner, @ptrCast(self)));
            }
            pub inline fn signalPresent(self: *const T, pl_signal_strength_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).SignalPresent(@as(*const IAMTuner, @ptrCast(self)), pl_signal_strength_);
            }
            pub inline fn putMode(self: *const T, l_mode_: AMTunerModeType) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IAMTuner, @ptrCast(self)), l_mode_);
            }
            pub inline fn getMode(self: *const T, pl_mode_: ?*AMTunerModeType) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IAMTuner, @ptrCast(self)), pl_mode_);
            }
            pub inline fn getAvailableModes(self: *const T, pl_modes_: ?*i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).GetAvailableModes(@as(*const IAMTuner, @ptrCast(self)), pl_modes_);
            }
            pub inline fn registerNotificationCallBack(self: *const T, p_notify_: ?*IAMTunerNotification, l_events_: i32) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).RegisterNotificationCallBack(@as(*const IAMTuner, @ptrCast(self)), p_notify_, l_events_);
            }
            pub inline fn unRegisterNotificationCallBack(self: *const T, p_notify_: ?*IAMTunerNotification) HRESULT {
                return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).UnRegisterNotificationCallBack(@as(*const IAMTuner, @ptrCast(self)), p_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTunerNotification_Value = Guid.initString("211a8760-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTunerNotification = &IID_IAMTunerNotification_Value;
pub const IAMTunerNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: *const fn (
            self: *const IAMTunerNotification,
            event: AMTunerEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onEvent(self: *const T, event_: AMTunerEventType) HRESULT {
                return @as(*const IAMTunerNotification.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IAMTunerNotification, @ptrCast(self)), event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVTuner_Value = Guid.initString("211a8766-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTVTuner = &IID_IAMTVTuner_Value;
pub const IAMTVTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            pl_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoTune: *const fn (
            self: *const IAMTVTuner,
            l_channel: i32,
            pl_found_signal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoreAutoTune: *const fn (
            self: *const IAMTVTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumInputConnections: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            pl_num_input_connections: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_index: i32,
            input_type: TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_index: i32,
            p_input_type: ?*TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectInput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectInput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            pl_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_freq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVTuner,
            l_freq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAMTuner.MethodMixin(T);
            pub inline fn getAvailableTVFormats(self: *const T, l_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMTVTuner, @ptrCast(self)), l_analog_video_standard_);
            }
            pub inline fn getTVFormat(self: *const T, pl_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMTVTuner, @ptrCast(self)), pl_analog_video_standard_);
            }
            pub inline fn autoTune(self: *const T, l_channel_: i32, pl_found_signal_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).AutoTune(@as(*const IAMTVTuner, @ptrCast(self)), l_channel_, pl_found_signal_);
            }
            pub inline fn storeAutoTune(self: *const T) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).StoreAutoTune(@as(*const IAMTVTuner, @ptrCast(self)));
            }
            pub inline fn getNumInputConnections(self: *const T, pl_num_input_connections_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_NumInputConnections(@as(*const IAMTVTuner, @ptrCast(self)), pl_num_input_connections_);
            }
            pub inline fn putInputType(self: *const T, l_index_: i32, input_type_: TunerInputType) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).put_InputType(@as(*const IAMTVTuner, @ptrCast(self)), l_index_, input_type_);
            }
            pub inline fn getInputType(self: *const T, l_index_: i32, p_input_type_: ?*TunerInputType) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_InputType(@as(*const IAMTVTuner, @ptrCast(self)), l_index_, p_input_type_);
            }
            pub inline fn putConnectInput(self: *const T, l_index_: i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).put_ConnectInput(@as(*const IAMTVTuner, @ptrCast(self)), l_index_);
            }
            pub inline fn getConnectInput(self: *const T, pl_index_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_ConnectInput(@as(*const IAMTVTuner, @ptrCast(self)), pl_index_);
            }
            pub inline fn getVideoFrequency(self: *const T, l_freq_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_VideoFrequency(@as(*const IAMTVTuner, @ptrCast(self)), l_freq_);
            }
            pub inline fn getAudioFrequency(self: *const T, l_freq_: ?*i32) HRESULT {
                return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_AudioFrequency(@as(*const IAMTVTuner, @ptrCast(self)), l_freq_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBPCSatelliteTuner_Value = Guid.initString("211a8765-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IBPCSatelliteTuner = &IID_IBPCSatelliteTuner_Value;
pub const IBPCSatelliteTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubChannelTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBPCSatelliteTuner,
            pl_default_video_type: ?*i32,
            pl_default_audio_type: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultSubChannelTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBPCSatelliteTuner,
            l_default_video_type: i32,
            l_default_audio_type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTapingPermitted: *const fn (
            self: *const IBPCSatelliteTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAMTuner.MethodMixin(T);
            pub inline fn getDefaultSubChannelTypes(self: *const T, pl_default_video_type_: ?*i32, pl_default_audio_type_: ?*i32) HRESULT {
                return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).get_DefaultSubChannelTypes(@as(*const IBPCSatelliteTuner, @ptrCast(self)), pl_default_video_type_, pl_default_audio_type_);
            }
            pub inline fn putDefaultSubChannelTypes(self: *const T, l_default_video_type_: i32, l_default_audio_type_: i32) HRESULT {
                return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).put_DefaultSubChannelTypes(@as(*const IBPCSatelliteTuner, @ptrCast(self)), l_default_video_type_, l_default_audio_type_);
            }
            pub inline fn isTapingPermitted(self: *const T) HRESULT {
                return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).IsTapingPermitted(@as(*const IBPCSatelliteTuner, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TVAudioMode = enum(i32) {
    MODE_MONO = 1,
    MODE_STEREO = 2,
    MODE_LANG_A = 16,
    MODE_LANG_B = 32,
    MODE_LANG_C = 64,
    PRESET_STEREO = 512,
    PRESET_LANG_A = 4096,
    PRESET_LANG_B = 8192,
    PRESET_LANG_C = 16384,
};
pub const AMTVAUDIO_MODE_MONO = TVAudioMode.MODE_MONO;
pub const AMTVAUDIO_MODE_STEREO = TVAudioMode.MODE_STEREO;
pub const AMTVAUDIO_MODE_LANG_A = TVAudioMode.MODE_LANG_A;
pub const AMTVAUDIO_MODE_LANG_B = TVAudioMode.MODE_LANG_B;
pub const AMTVAUDIO_MODE_LANG_C = TVAudioMode.MODE_LANG_C;
pub const AMTVAUDIO_PRESET_STEREO = TVAudioMode.PRESET_STEREO;
pub const AMTVAUDIO_PRESET_LANG_A = TVAudioMode.PRESET_LANG_A;
pub const AMTVAUDIO_PRESET_LANG_B = TVAudioMode.PRESET_LANG_B;
pub const AMTVAUDIO_PRESET_LANG_C = TVAudioMode.PRESET_LANG_C;

pub const AMTVAudioEventType = enum(i32) {
    D = 1,
};
pub const AMTVAUDIO_EVENT_CHANGED = AMTVAudioEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVAudio_Value = Guid.initString("83ec1c30-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudio = &IID_IAMTVAudio_Value;
pub const IAMTVAudio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHardwareSupportedTVAudioModes: *const fn (
            self: *const IAMTVAudio,
            pl_modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableTVAudioModes: *const fn (
            self: *const IAMTVAudio,
            pl_modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVAudioMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVAudio,
            pl_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVAudioMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTVAudio,
            l_mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotificationCallBack: *const fn (
            self: *const IAMTVAudio,
            p_notify: ?*IAMTunerNotification,
            l_events: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterNotificationCallBack: *const fn (
            self: *const IAMTVAudio,
            p_notify: ?*IAMTunerNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getHardwareSupportedTVAudioModes(self: *const T, pl_modes_: ?*i32) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).GetHardwareSupportedTVAudioModes(@as(*const IAMTVAudio, @ptrCast(self)), pl_modes_);
            }
            pub inline fn getAvailableTVAudioModes(self: *const T, pl_modes_: ?*i32) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).GetAvailableTVAudioModes(@as(*const IAMTVAudio, @ptrCast(self)), pl_modes_);
            }
            pub inline fn getTVAudioMode(self: *const T, pl_mode_: ?*i32) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).get_TVAudioMode(@as(*const IAMTVAudio, @ptrCast(self)), pl_mode_);
            }
            pub inline fn putTVAudioMode(self: *const T, l_mode_: i32) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).put_TVAudioMode(@as(*const IAMTVAudio, @ptrCast(self)), l_mode_);
            }
            pub inline fn registerNotificationCallBack(self: *const T, p_notify_: ?*IAMTunerNotification, l_events_: i32) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).RegisterNotificationCallBack(@as(*const IAMTVAudio, @ptrCast(self)), p_notify_, l_events_);
            }
            pub inline fn unRegisterNotificationCallBack(self: *const T, p_notify_: ?*IAMTunerNotification) HRESULT {
                return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).UnRegisterNotificationCallBack(@as(*const IAMTVAudio, @ptrCast(self)), p_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTVAudioNotification_Value = Guid.initString("83ec1c33-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudioNotification = &IID_IAMTVAudioNotification_Value;
pub const IAMTVAudioNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: *const fn (
            self: *const IAMTVAudioNotification,
            event: AMTVAudioEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onEvent(self: *const T, event_: AMTVAudioEventType) HRESULT {
                return @as(*const IAMTVAudioNotification.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IAMTVAudioNotification, @ptrCast(self)), event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMAnalogVideoEncoder_Value = Guid.initString("c6e133b0-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoEncoder = &IID_IAMAnalogVideoEncoder_Value;
pub const IAMAnalogVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_analog_video_standard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            pl_analog_video_standard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CopyProtection: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_video_copy_protection: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CopyProtection: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_video_copy_protection: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_c_c_enable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMAnalogVideoEncoder,
            l_c_c_enable: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAvailableTVFormats(self: *const T, l_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_analog_video_standard_);
            }
            pub inline fn putTVFormat(self: *const T, l_analog_video_standard_: i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_TVFormat(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_analog_video_standard_);
            }
            pub inline fn getTVFormat(self: *const T, pl_analog_video_standard_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), pl_analog_video_standard_);
            }
            pub inline fn putCopyProtection(self: *const T, l_video_copy_protection_: i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_CopyProtection(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_video_copy_protection_);
            }
            pub inline fn getCopyProtection(self: *const T, l_video_copy_protection_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_CopyProtection(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_video_copy_protection_);
            }
            pub inline fn putCCEnable(self: *const T, l_c_c_enable_: i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_CCEnable(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_c_c_enable_);
            }
            pub inline fn getCCEnable(self: *const T, l_c_c_enable_: ?*i32) HRESULT {
                return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_CCEnable(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), l_c_c_enable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMPROPERTY_PIN = enum(i32) {
    CATEGORY = 0,
    MEDIUM = 1,
};
pub const AMPROPERTY_PIN_CATEGORY = AMPROPERTY_PIN.CATEGORY;
pub const AMPROPERTY_PIN_MEDIUM = AMPROPERTY_PIN.MEDIUM;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPropertyBag_Value = Guid.initString("6025a880-c0d5-11d0-bd4e-00a0c911ce86");
pub const IID_IMediaPropertyBag = &IID_IMediaPropertyBag_Value;
pub const IMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
        EnumProperty: *const fn (
            self: *const IMediaPropertyBag,
            i_property: u32,
            pvar_property_name: ?*VARIANT,
            pvar_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPropertyBag.MethodMixin(T);
            pub inline fn enumProperty(self: *const T, i_property_: u32, pvar_property_name_: ?*VARIANT, pvar_property_value_: ?*VARIANT) HRESULT {
                return @as(*const IMediaPropertyBag.VTable, @ptrCast(self.vtable)).EnumProperty(@as(*const IMediaPropertyBag, @ptrCast(self)), i_property_, pvar_property_name_, pvar_property_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistMediaPropertyBag_Value = Guid.initString("5738e040-b67f-11d0-bd4d-00a0c911ce86");
pub const IID_IPersistMediaPropertyBag = &IID_IPersistMediaPropertyBag_Value;
pub const IPersistMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: *const fn (
            self: *const IPersistMediaPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistMediaPropertyBag,
            p_prop_bag: ?*IMediaPropertyBag,
            p_error_log: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistMediaPropertyBag,
            p_prop_bag: ?*IMediaPropertyBag,
            f_clear_dirty: BOOL,
            f_save_all_properties: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn initNew(self: *const T) HRESULT {
                return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistMediaPropertyBag, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, p_prop_bag_: ?*IMediaPropertyBag, p_error_log_: ?*IErrorLog) HRESULT {
                return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistMediaPropertyBag, @ptrCast(self)), p_prop_bag_, p_error_log_);
            }
            pub inline fn save(self: *const T, p_prop_bag_: ?*IMediaPropertyBag, f_clear_dirty_: BOOL, f_save_all_properties_: BOOL) HRESULT {
                return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistMediaPropertyBag, @ptrCast(self)), p_prop_bag_, f_clear_dirty_, f_save_all_properties_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMPhysicalPinInfo_Value = Guid.initString("f938c991-3029-11cf-8c44-00aa006b6814");
pub const IID_IAMPhysicalPinInfo = &IID_IAMPhysicalPinInfo_Value;
pub const IAMPhysicalPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPhysicalType: *const fn (
            self: *const IAMPhysicalPinInfo,
            p_type: ?*i32,
            ppsz_type: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPhysicalType(self: *const T, p_type_: ?*i32, ppsz_type_: ?*?PWSTR) HRESULT {
                return @as(*const IAMPhysicalPinInfo.VTable, @ptrCast(self.vtable)).GetPhysicalType(@as(*const IAMPhysicalPinInfo, @ptrCast(self)), p_type_, ppsz_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtDevice_Value = Guid.initString("b5730a90-1a2c-11cf-8c23-00aa006b6814");
pub const IID_IAMExtDevice = &IID_IAMExtDevice_Value;
pub const IAMExtDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: *const fn (
            self: *const IAMExtDevice,
            capability: i32,
            p_value: ?*i32,
            pdbl_value: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            ppsz_data: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceVersion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            ppsz_data: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePower: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            power_mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePower: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            p_power_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Calibrate: *const fn (
            self: *const IAMExtDevice,
            h_event: usize,
            mode: i32,
            p_status: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            device_port: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtDevice,
            p_device_port: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCapability(self: *const T, capability_: i32, p_value_: ?*i32, pdbl_value_: ?*f64) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).GetCapability(@as(*const IAMExtDevice, @ptrCast(self)), capability_, p_value_, pdbl_value_);
            }
            pub inline fn getExternalDeviceID(self: *const T, ppsz_data_: ?*?PWSTR) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_ExternalDeviceID(@as(*const IAMExtDevice, @ptrCast(self)), ppsz_data_);
            }
            pub inline fn getExternalDeviceVersion(self: *const T, ppsz_data_: ?*?PWSTR) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_ExternalDeviceVersion(@as(*const IAMExtDevice, @ptrCast(self)), ppsz_data_);
            }
            pub inline fn putDevicePower(self: *const T, power_mode_: i32) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).put_DevicePower(@as(*const IAMExtDevice, @ptrCast(self)), power_mode_);
            }
            pub inline fn getDevicePower(self: *const T, p_power_mode_: ?*i32) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_DevicePower(@as(*const IAMExtDevice, @ptrCast(self)), p_power_mode_);
            }
            pub inline fn calibrate(self: *const T, h_event_: usize, mode_: i32, p_status_: ?*i32) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).Calibrate(@as(*const IAMExtDevice, @ptrCast(self)), h_event_, mode_, p_status_);
            }
            pub inline fn putDevicePort(self: *const T, device_port_: i32) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).put_DevicePort(@as(*const IAMExtDevice, @ptrCast(self)), device_port_);
            }
            pub inline fn getDevicePort(self: *const T, p_device_port_: ?*i32) HRESULT {
                return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_DevicePort(@as(*const IAMExtDevice, @ptrCast(self)), p_device_port_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtTransport_Value = Guid.initString("a03cd5f0-3045-11cf-8c44-00aa006b6814");
pub const IID_IAMExtTransport = &IID_IAMExtTransport_Value;
pub const IAMExtTransport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: *const fn (
            self: *const IAMExtTransport,
            capability: i32,
            p_value: ?*i32,
            pdbl_value: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            p_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalControl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalControl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            p_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IAMExtTransport,
            status_item: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportBasicParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            p_value: ?*i32,
            ppsz_data: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportBasicParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            value: i32,
            psz_data: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportVideoParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportVideoParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportAudioParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportAudioParameters: *const fn (
            self: *const IAMExtTransport,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            p_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            dbl_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            pdbl_rate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChase: *const fn (
            self: *const IAMExtTransport,
            p_enabled: ?*i32,
            p_offset: ?*i32,
            ph_event: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChase: *const fn (
            self: *const IAMExtTransport,
            enable: i32,
            offset: i32,
            h_event: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBump: *const fn (
            self: *const IAMExtTransport,
            p_speed: ?*i32,
            p_duration: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBump: *const fn (
            self: *const IAMExtTransport,
            speed: i32,
            duration: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntiClogControl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            p_enabled: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AntiClogControl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            enable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEditPropertySet: *const fn (
            self: *const IAMExtTransport,
            edit_i_d: i32,
            p_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEditPropertySet: *const fn (
            self: *const IAMExtTransport,
            p_edit_i_d: ?*i32,
            state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEditProperty: *const fn (
            self: *const IAMExtTransport,
            edit_i_d: i32,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEditProperty: *const fn (
            self: *const IAMExtTransport,
            edit_i_d: i32,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EditStart: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EditStart: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtTransport,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCapability(self: *const T, capability_: i32, p_value_: ?*i32, pdbl_value_: ?*f64) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetCapability(@as(*const IAMExtTransport, @ptrCast(self)), capability_, p_value_, pdbl_value_);
            }
            pub inline fn putMediaState(self: *const T, state_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_MediaState(@as(*const IAMExtTransport, @ptrCast(self)), state_);
            }
            pub inline fn getMediaState(self: *const T, p_state_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_MediaState(@as(*const IAMExtTransport, @ptrCast(self)), p_state_);
            }
            pub inline fn putLocalControl(self: *const T, state_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_LocalControl(@as(*const IAMExtTransport, @ptrCast(self)), state_);
            }
            pub inline fn getLocalControl(self: *const T, p_state_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_LocalControl(@as(*const IAMExtTransport, @ptrCast(self)), p_state_);
            }
            pub inline fn getStatus(self: *const T, status_item_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IAMExtTransport, @ptrCast(self)), status_item_, p_value_);
            }
            pub inline fn getTransportBasicParameters(self: *const T, param_: i32, p_value_: ?*i32, ppsz_data_: ?*?PWSTR) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportBasicParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, p_value_, ppsz_data_);
            }
            pub inline fn setTransportBasicParameters(self: *const T, param_: i32, value_: i32, psz_data_: ?[*:0]const u16) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportBasicParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, value_, psz_data_);
            }
            pub inline fn getTransportVideoParameters(self: *const T, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportVideoParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, p_value_);
            }
            pub inline fn setTransportVideoParameters(self: *const T, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportVideoParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, value_);
            }
            pub inline fn getTransportAudioParameters(self: *const T, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportAudioParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, p_value_);
            }
            pub inline fn setTransportAudioParameters(self: *const T, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportAudioParameters(@as(*const IAMExtTransport, @ptrCast(self)), param_, value_);
            }
            pub inline fn putMode(self: *const T, mode_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IAMExtTransport, @ptrCast(self)), mode_);
            }
            pub inline fn getMode(self: *const T, p_mode_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IAMExtTransport, @ptrCast(self)), p_mode_);
            }
            pub inline fn putRate(self: *const T, dbl_rate_: f64) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IAMExtTransport, @ptrCast(self)), dbl_rate_);
            }
            pub inline fn getRate(self: *const T, pdbl_rate_: ?*f64) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IAMExtTransport, @ptrCast(self)), pdbl_rate_);
            }
            pub inline fn getChase(self: *const T, p_enabled_: ?*i32, p_offset_: ?*i32, ph_event_: ?*usize) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetChase(@as(*const IAMExtTransport, @ptrCast(self)), p_enabled_, p_offset_, ph_event_);
            }
            pub inline fn setChase(self: *const T, enable_: i32, offset_: i32, h_event_: usize) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetChase(@as(*const IAMExtTransport, @ptrCast(self)), enable_, offset_, h_event_);
            }
            pub inline fn getBump(self: *const T, p_speed_: ?*i32, p_duration_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetBump(@as(*const IAMExtTransport, @ptrCast(self)), p_speed_, p_duration_);
            }
            pub inline fn setBump(self: *const T, speed_: i32, duration_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetBump(@as(*const IAMExtTransport, @ptrCast(self)), speed_, duration_);
            }
            pub inline fn getAntiClogControl(self: *const T, p_enabled_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_AntiClogControl(@as(*const IAMExtTransport, @ptrCast(self)), p_enabled_);
            }
            pub inline fn putAntiClogControl(self: *const T, enable_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_AntiClogControl(@as(*const IAMExtTransport, @ptrCast(self)), enable_);
            }
            pub inline fn getEditPropertySet(self: *const T, edit_i_d_: i32, p_state_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetEditPropertySet(@as(*const IAMExtTransport, @ptrCast(self)), edit_i_d_, p_state_);
            }
            pub inline fn setEditPropertySet(self: *const T, p_edit_i_d_: ?*i32, state_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetEditPropertySet(@as(*const IAMExtTransport, @ptrCast(self)), p_edit_i_d_, state_);
            }
            pub inline fn getEditProperty(self: *const T, edit_i_d_: i32, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetEditProperty(@as(*const IAMExtTransport, @ptrCast(self)), edit_i_d_, param_, p_value_);
            }
            pub inline fn setEditProperty(self: *const T, edit_i_d_: i32, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetEditProperty(@as(*const IAMExtTransport, @ptrCast(self)), edit_i_d_, param_, value_);
            }
            pub inline fn getEditStart(self: *const T, p_value_: ?*i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_EditStart(@as(*const IAMExtTransport, @ptrCast(self)), p_value_);
            }
            pub inline fn putEditStart(self: *const T, value_: i32) HRESULT {
                return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_EditStart(@as(*const IAMExtTransport, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeReader_Value = Guid.initString("9b496ce1-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeReader = &IID_IAMTimecodeReader_Value;
pub const IAMTimecodeReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCRMode: *const fn (
            self: *const IAMTimecodeReader,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCRMode: *const fn (
            self: *const IAMTimecodeReader,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTimecodeReader,
            line: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTimecodeReader,
            p_line: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimecode: *const fn (
            self: *const IAMTimecodeReader,
            p_timecode_sample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTCRMode(self: *const T, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).GetTCRMode(@as(*const IAMTimecodeReader, @ptrCast(self)), param_, p_value_);
            }
            pub inline fn setTCRMode(self: *const T, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).SetTCRMode(@as(*const IAMTimecodeReader, @ptrCast(self)), param_, value_);
            }
            pub inline fn putVITCLine(self: *const T, line_: i32) HRESULT {
                return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).put_VITCLine(@as(*const IAMTimecodeReader, @ptrCast(self)), line_);
            }
            pub inline fn getVITCLine(self: *const T, p_line_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).get_VITCLine(@as(*const IAMTimecodeReader, @ptrCast(self)), p_line_);
            }
            pub inline fn getTimecode(self: *const T, p_timecode_sample_: ?*TIMECODE_SAMPLE) HRESULT {
                return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).GetTimecode(@as(*const IAMTimecodeReader, @ptrCast(self)), p_timecode_sample_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeGenerator_Value = Guid.initString("9b496ce0-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeGenerator = &IID_IAMTimecodeGenerator_Value;
pub const IAMTimecodeGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCGMode: *const fn (
            self: *const IAMTimecodeGenerator,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCGMode: *const fn (
            self: *const IAMTimecodeGenerator,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTimecodeGenerator,
            line: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMTimecodeGenerator,
            p_line: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimecode: *const fn (
            self: *const IAMTimecodeGenerator,
            p_timecode_sample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimecode: *const fn (
            self: *const IAMTimecodeGenerator,
            p_timecode_sample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTCGMode(self: *const T, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).GetTCGMode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), param_, p_value_);
            }
            pub inline fn setTCGMode(self: *const T, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).SetTCGMode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), param_, value_);
            }
            pub inline fn putVITCLine(self: *const T, line_: i32) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).put_VITCLine(@as(*const IAMTimecodeGenerator, @ptrCast(self)), line_);
            }
            pub inline fn getVITCLine(self: *const T, p_line_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).get_VITCLine(@as(*const IAMTimecodeGenerator, @ptrCast(self)), p_line_);
            }
            pub inline fn setTimecode(self: *const T, p_timecode_sample_: ?*TIMECODE_SAMPLE) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).SetTimecode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), p_timecode_sample_);
            }
            pub inline fn getTimecode(self: *const T, p_timecode_sample_: ?*TIMECODE_SAMPLE) HRESULT {
                return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).GetTimecode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), p_timecode_sample_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeDisplay_Value = Guid.initString("9b496ce2-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeDisplay = &IID_IAMTimecodeDisplay_Value;
pub const IAMTimecodeDisplay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCDisplayEnable: *const fn (
            self: *const IAMTimecodeDisplay,
            p_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCDisplayEnable: *const fn (
            self: *const IAMTimecodeDisplay,
            state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTCDisplay: *const fn (
            self: *const IAMTimecodeDisplay,
            param: i32,
            p_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCDisplay: *const fn (
            self: *const IAMTimecodeDisplay,
            param: i32,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTCDisplayEnable(self: *const T, p_state_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).GetTCDisplayEnable(@as(*const IAMTimecodeDisplay, @ptrCast(self)), p_state_);
            }
            pub inline fn setTCDisplayEnable(self: *const T, state_: i32) HRESULT {
                return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).SetTCDisplayEnable(@as(*const IAMTimecodeDisplay, @ptrCast(self)), state_);
            }
            pub inline fn getTCDisplay(self: *const T, param_: i32, p_value_: ?*i32) HRESULT {
                return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).GetTCDisplay(@as(*const IAMTimecodeDisplay, @ptrCast(self)), param_, p_value_);
            }
            pub inline fn setTCDisplay(self: *const T, param_: i32, value_: i32) HRESULT {
                return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).SetTCDisplay(@as(*const IAMTimecodeDisplay, @ptrCast(self)), param_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryAllocator_Value = Guid.initString("c6545bf0-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryAllocator = &IID_IAMDevMemoryAllocator_Value;
pub const IAMDevMemoryAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: *const fn (
            self: *const IAMDevMemoryAllocator,
            pdwcb_total_free: ?*u32,
            pdwcb_largest_free: ?*u32,
            pdwcb_total_memory: ?*u32,
            pdwcb_minimum_chunk: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckMemory: *const fn (
            self: *const IAMDevMemoryAllocator,
            p_buffer: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Alloc: *const fn (
            self: *const IAMDevMemoryAllocator,
            pp_buffer: ?*?*u8,
            pdwcb_buffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: *const fn (
            self: *const IAMDevMemoryAllocator,
            p_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevMemoryObject: *const fn (
            self: *const IAMDevMemoryAllocator,
            pp_unk_innner: ?*?*IUnknown,
            p_unk_outer: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInfo(self: *const T, pdwcb_total_free_: ?*u32, pdwcb_largest_free_: ?*u32, pdwcb_total_memory_: ?*u32, pdwcb_minimum_chunk_: ?*u32) HRESULT {
                return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pdwcb_total_free_, pdwcb_largest_free_, pdwcb_total_memory_, pdwcb_minimum_chunk_);
            }
            pub inline fn checkMemory(self: *const T, p_buffer_: ?*const u8) HRESULT {
                return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).CheckMemory(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), p_buffer_);
            }
            pub inline fn alloc(self: *const T, pp_buffer_: ?*?*u8, pdwcb_buffer_: ?*u32) HRESULT {
                return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pp_buffer_, pdwcb_buffer_);
            }
            pub inline fn free(self: *const T, p_buffer_: ?*u8) HRESULT {
                return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).Free(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), p_buffer_);
            }
            pub inline fn getDevMemoryObject(self: *const T, pp_unk_innner_: ?*?*IUnknown, p_unk_outer_: ?*IUnknown) HRESULT {
                return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).GetDevMemoryObject(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pp_unk_innner_, p_unk_outer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryControl_Value = Guid.initString("c6545bf1-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryControl = &IID_IAMDevMemoryControl_Value;
pub const IAMDevMemoryControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryWriteSync: *const fn (
            self: *const IAMDevMemoryControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSync: *const fn (
            self: *const IAMDevMemoryControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevId: *const fn (
            self: *const IAMDevMemoryControl,
            pdw_dev_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryWriteSync(self: *const T) HRESULT {
                return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).QueryWriteSync(@as(*const IAMDevMemoryControl, @ptrCast(self)));
            }
            pub inline fn writeSync(self: *const T) HRESULT {
                return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).WriteSync(@as(*const IAMDevMemoryControl, @ptrCast(self)));
            }
            pub inline fn getDevId(self: *const T, pdw_dev_id_: ?*u32) HRESULT {
                return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).GetDevId(@as(*const IAMDevMemoryControl, @ptrCast(self)), pdw_dev_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AMSTREAMSELECTINFOFLAGS = enum(i32) {
    NABLED = 1,
    XCLUSIVE = 2,
};
pub const AMSTREAMSELECTINFO_ENABLED = _AMSTREAMSELECTINFOFLAGS.NABLED;
pub const AMSTREAMSELECTINFO_EXCLUSIVE = _AMSTREAMSELECTINFOFLAGS.XCLUSIVE;

pub const _AMSTREAMSELECTENABLEFLAGS = enum(i32) {
    E = 1,
    ALL = 2,
};
pub const AMSTREAMSELECTENABLE_ENABLE = _AMSTREAMSELECTENABLEFLAGS.E;
pub const AMSTREAMSELECTENABLE_ENABLEALL = _AMSTREAMSELECTENABLEFLAGS.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamSelect_Value = Guid.initString("c1960960-17f5-11d1-abe1-00a0c905f375");
pub const IID_IAMStreamSelect = &IID_IAMStreamSelect_Value;
pub const IAMStreamSelect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Count: *const fn (
            self: *const IAMStreamSelect,
            pc_streams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Info: *const fn (
            self: *const IAMStreamSelect,
            l_index: i32,
            ppmt: ?*?*AM_MEDIA_TYPE,
            pdw_flags: ?*u32,
            plcid: ?*u32,
            pdw_group: ?*u32,
            ppsz_name: ?*?PWSTR,
            pp_object: ?*?*IUnknown,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: *const fn (
            self: *const IAMStreamSelect,
            l_index: i32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn count(self: *const T, pc_streams_: ?*u32) HRESULT {
                return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Count(@as(*const IAMStreamSelect, @ptrCast(self)), pc_streams_);
            }
            pub inline fn info(self: *const T, l_index_: i32, ppmt_: ?*?*AM_MEDIA_TYPE, pdw_flags_: ?*u32, plcid_: ?*u32, pdw_group_: ?*u32, ppsz_name_: ?*?PWSTR, pp_object_: ?*?*IUnknown, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Info(@as(*const IAMStreamSelect, @ptrCast(self)), l_index_, ppmt_, pdw_flags_, plcid_, pdw_group_, ppsz_name_, pp_object_, pp_unk_);
            }
            pub inline fn enable(self: *const T, l_index_: i32, dw_flags_: u32) HRESULT {
                return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Enable(@as(*const IAMStreamSelect, @ptrCast(self)), l_index_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AMRESCTL_RESERVEFLAGS = enum(i32) {
    RESERVE = 0,
    UNRESERVE = 1,
};
pub const AMRESCTL_RESERVEFLAGS_RESERVE = _AMRESCTL_RESERVEFLAGS.RESERVE;
pub const AMRESCTL_RESERVEFLAGS_UNRESERVE = _AMRESCTL_RESERVEFLAGS.UNRESERVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMResourceControl_Value = Guid.initString("8389d2d0-77d7-11d1-abe6-00a0c905f375");
pub const IID_IAMResourceControl = &IID_IAMResourceControl_Value;
pub const IAMResourceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reserve: *const fn (
            self: *const IAMResourceControl,
            dw_flags: u32,
            pv_reserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reserve(self: *const T, dw_flags_: u32, pv_reserved_: ?*anyopaque) HRESULT {
                return @as(*const IAMResourceControl.VTable, @ptrCast(self.vtable)).Reserve(@as(*const IAMResourceControl, @ptrCast(self)), dw_flags_, pv_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMClockAdjust_Value = Guid.initString("4d5466b0-a49c-11d1-abe8-00a0c905f375");
pub const IID_IAMClockAdjust = &IID_IAMClockAdjust_Value;
pub const IAMClockAdjust = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClockDelta: *const fn (
            self: *const IAMClockAdjust,
            rt_delta: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setClockDelta(self: *const T, rt_delta_: i64) HRESULT {
                return @as(*const IAMClockAdjust.VTable, @ptrCast(self.vtable)).SetClockDelta(@as(*const IAMClockAdjust, @ptrCast(self)), rt_delta_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_FILTER_MISC_FLAGS = enum(i32) {
    RENDERER = 1,
    SOURCE = 2,
};
pub const AM_FILTER_MISC_FLAGS_IS_RENDERER = _AM_FILTER_MISC_FLAGS.RENDERER;
pub const AM_FILTER_MISC_FLAGS_IS_SOURCE = _AM_FILTER_MISC_FLAGS.SOURCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterMiscFlags_Value = Guid.initString("2dd74950-a890-11d1-abe8-00a0c905f375");
pub const IID_IAMFilterMiscFlags = &IID_IAMFilterMiscFlags_Value;
pub const IAMFilterMiscFlags = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMiscFlags: *const fn (
            self: *const IAMFilterMiscFlags,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMiscFlags(self: *const T) u32 {
                return @as(*const IAMFilterMiscFlags.VTable, @ptrCast(self.vtable)).GetMiscFlags(@as(*const IAMFilterMiscFlags, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDrawVideoImage_Value = Guid.initString("48efb120-ab49-11d2-aed2-00a0c995e8d5");
pub const IID_IDrawVideoImage = &IID_IDrawVideoImage_Value;
pub const IDrawVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DrawVideoImageBegin: *const fn (
            self: *const IDrawVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawVideoImageEnd: *const fn (
            self: *const IDrawVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawVideoImageDraw: *const fn (
            self: *const IDrawVideoImage,
            hdc: ?HDC,
            lprc_src: ?*RECT,
            lprc_dst: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn drawVideoImageBegin(self: *const T) HRESULT {
                return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageBegin(@as(*const IDrawVideoImage, @ptrCast(self)));
            }
            pub inline fn drawVideoImageEnd(self: *const T) HRESULT {
                return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageEnd(@as(*const IDrawVideoImage, @ptrCast(self)));
            }
            pub inline fn drawVideoImageDraw(self: *const T, hdc_: ?HDC, lprc_src_: ?*RECT, lprc_dst_: ?*RECT) HRESULT {
                return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageDraw(@as(*const IDrawVideoImage, @ptrCast(self)), hdc_, lprc_src_, lprc_dst_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDecimateVideoImage_Value = Guid.initString("2e5ea3e0-e924-11d2-b6da-00a0c995e8df");
pub const IID_IDecimateVideoImage = &IID_IDecimateVideoImage_Value;
pub const IDecimateVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDecimationImageSize: *const fn (
            self: *const IDecimateVideoImage,
            l_width: i32,
            l_height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetDecimationImageSize: *const fn (
            self: *const IDecimateVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDecimationImageSize(self: *const T, l_width_: i32, l_height_: i32) HRESULT {
                return @as(*const IDecimateVideoImage.VTable, @ptrCast(self.vtable)).SetDecimationImageSize(@as(*const IDecimateVideoImage, @ptrCast(self)), l_width_, l_height_);
            }
            pub inline fn resetDecimationImageSize(self: *const T) HRESULT {
                return @as(*const IDecimateVideoImage.VTable, @ptrCast(self.vtable)).ResetDecimationImageSize(@as(*const IDecimateVideoImage, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DECIMATION_USAGE = enum(i32) {
    LEGACY = 0,
    USE_DECODER_ONLY = 1,
    USE_VIDEOPORT_ONLY = 2,
    USE_OVERLAY_ONLY = 3,
    DEFAULT = 4,
};
pub const DECIMATION_LEGACY = DECIMATION_USAGE.LEGACY;
pub const DECIMATION_USE_DECODER_ONLY = DECIMATION_USAGE.USE_DECODER_ONLY;
pub const DECIMATION_USE_VIDEOPORT_ONLY = DECIMATION_USAGE.USE_VIDEOPORT_ONLY;
pub const DECIMATION_USE_OVERLAY_ONLY = DECIMATION_USAGE.USE_OVERLAY_ONLY;
pub const DECIMATION_DEFAULT = DECIMATION_USAGE.DEFAULT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMVideoDecimationProperties_Value = Guid.initString("60d32930-13da-11d3-9ec6-c4fcaef5c7be");
pub const IID_IAMVideoDecimationProperties = &IID_IAMVideoDecimationProperties_Value;
pub const IAMVideoDecimationProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryDecimationUsage: *const fn (
            self: *const IAMVideoDecimationProperties,
            lp_usage: ?*DECIMATION_USAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDecimationUsage: *const fn (
            self: *const IAMVideoDecimationProperties,
            usage: DECIMATION_USAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryDecimationUsage(self: *const T, lp_usage_: ?*DECIMATION_USAGE) HRESULT {
                return @as(*const IAMVideoDecimationProperties.VTable, @ptrCast(self.vtable)).QueryDecimationUsage(@as(*const IAMVideoDecimationProperties, @ptrCast(self)), lp_usage_);
            }
            pub inline fn setDecimationUsage(self: *const T, usage_: DECIMATION_USAGE) HRESULT {
                return @as(*const IAMVideoDecimationProperties.VTable, @ptrCast(self.vtable)).SetDecimationUsage(@as(*const IAMVideoDecimationProperties, @ptrCast(self)), usage_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoFrameStep_Value = Guid.initString("e46a9787-2b71-444d-a4b5-1fab7b708d6a");
pub const IID_IVideoFrameStep = &IID_IVideoFrameStep_Value;
pub const IVideoFrameStep = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Step: *const fn (
            self: *const IVideoFrameStep,
            dw_frames: u32,
            p_step_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanStep: *const fn (
            self: *const IVideoFrameStep,
            b_multiple: i32,
            p_step_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelStep: *const fn (
            self: *const IVideoFrameStep,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn step(self: *const T, dw_frames_: u32, p_step_object_: ?*IUnknown) HRESULT {
                return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).Step(@as(*const IVideoFrameStep, @ptrCast(self)), dw_frames_, p_step_object_);
            }
            pub inline fn canStep(self: *const T, b_multiple_: i32, p_step_object_: ?*IUnknown) HRESULT {
                return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).CanStep(@as(*const IVideoFrameStep, @ptrCast(self)), b_multiple_, p_step_object_);
            }
            pub inline fn cancelStep(self: *const T) HRESULT {
                return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).CancelStep(@as(*const IVideoFrameStep, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PUSHSOURCE_FLAGS = enum(i32) {
    CAPS_INTERNAL_RM = 1,
    CAPS_NOT_LIVE = 2,
    CAPS_PRIVATE_CLOCK = 4,
    REQS_USE_STREAM_CLOCK = 65536,
    REQS_USE_CLOCK_CHAIN = 131072,
};
pub const AM_PUSHSOURCECAPS_INTERNAL_RM = _AM_PUSHSOURCE_FLAGS.CAPS_INTERNAL_RM;
pub const AM_PUSHSOURCECAPS_NOT_LIVE = _AM_PUSHSOURCE_FLAGS.CAPS_NOT_LIVE;
pub const AM_PUSHSOURCECAPS_PRIVATE_CLOCK = _AM_PUSHSOURCE_FLAGS.CAPS_PRIVATE_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_STREAM_CLOCK = _AM_PUSHSOURCE_FLAGS.REQS_USE_STREAM_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN = _AM_PUSHSOURCE_FLAGS.REQS_USE_CLOCK_CHAIN;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMLatency_Value = Guid.initString("62ea93ba-ec62-11d2-b770-00c04fb6bd3d");
pub const IID_IAMLatency = &IID_IAMLatency_Value;
pub const IAMLatency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLatency: *const fn (
            self: *const IAMLatency,
            prt_latency: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLatency(self: *const T, prt_latency_: ?*i64) HRESULT {
                return @as(*const IAMLatency.VTable, @ptrCast(self.vtable)).GetLatency(@as(*const IAMLatency, @ptrCast(self)), prt_latency_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMPushSource_Value = Guid.initString("f185fe76-e64e-11d2-b76e-00c04fb6bd3d");
pub const IID_IAMPushSource = &IID_IAMPushSource_Value;
pub const IAMPushSource = extern struct {
    pub const VTable = extern struct {
        base: IAMLatency.VTable,
        GetPushSourceFlags: *const fn (
            self: *const IAMPushSource,
            p_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPushSourceFlags: *const fn (
            self: *const IAMPushSource,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamOffset: *const fn (
            self: *const IAMPushSource,
            rt_offset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamOffset: *const fn (
            self: *const IAMPushSource,
            prt_offset: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxStreamOffset: *const fn (
            self: *const IAMPushSource,
            prt_max_offset: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxStreamOffset: *const fn (
            self: *const IAMPushSource,
            rt_max_offset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAMLatency.MethodMixin(T);
            pub inline fn getPushSourceFlags(self: *const T, p_flags_: ?*u32) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetPushSourceFlags(@as(*const IAMPushSource, @ptrCast(self)), p_flags_);
            }
            pub inline fn setPushSourceFlags(self: *const T, flags_: u32) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetPushSourceFlags(@as(*const IAMPushSource, @ptrCast(self)), flags_);
            }
            pub inline fn setStreamOffset(self: *const T, rt_offset_: i64) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), rt_offset_);
            }
            pub inline fn getStreamOffset(self: *const T, prt_offset_: ?*i64) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), prt_offset_);
            }
            pub inline fn getMaxStreamOffset(self: *const T, prt_max_offset_: ?*i64) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetMaxStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), prt_max_offset_);
            }
            pub inline fn setMaxStreamOffset(self: *const T, rt_max_offset_: i64) HRESULT {
                return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetMaxStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), rt_max_offset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDeviceRemoval_Value = Guid.initString("f90a6130-b658-11d2-ae49-0000f8754b99");
pub const IID_IAMDeviceRemoval = &IID_IAMDeviceRemoval_Value;
pub const IAMDeviceRemoval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeviceInfo: *const fn (
            self: *const IAMDeviceRemoval,
            pclsid_interface_class: ?*Guid,
            pwsz_symbolic_link: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reassociate: *const fn (
            self: *const IAMDeviceRemoval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassociate: *const fn (
            self: *const IAMDeviceRemoval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn deviceInfo(self: *const T, pclsid_interface_class_: ?*Guid, pwsz_symbolic_link_: ?*?PWSTR) HRESULT {
                return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).DeviceInfo(@as(*const IAMDeviceRemoval, @ptrCast(self)), pclsid_interface_class_, pwsz_symbolic_link_);
            }
            pub inline fn reassociate(self: *const T) HRESULT {
                return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).Reassociate(@as(*const IAMDeviceRemoval, @ptrCast(self)));
            }
            pub inline fn disassociate(self: *const T) HRESULT {
                return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).Disassociate(@as(*const IAMDeviceRemoval, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVINFO = extern struct {
    dwDVAAuxSrc: u32,
    dwDVAAuxCtl: u32,
    dwDVAAuxSrc1: u32,
    dwDVAAuxCtl1: u32,
    dwDVVAuxSrc: u32,
    dwDVVAuxCtl: u32,
    dwDVReserved: [2]u32,
};

pub const _DVENCODERRESOLUTION = enum(i32) {
    @"720x480" = 2012,
    @"360x240" = 2013,
    @"180x120" = 2014,
    @"88x60" = 2015,
};
pub const DVENCODERRESOLUTION_720x480 = _DVENCODERRESOLUTION.@"720x480";
pub const DVENCODERRESOLUTION_360x240 = _DVENCODERRESOLUTION.@"360x240";
pub const DVENCODERRESOLUTION_180x120 = _DVENCODERRESOLUTION.@"180x120";
pub const DVENCODERRESOLUTION_88x60 = _DVENCODERRESOLUTION.@"88x60";

pub const _DVENCODERVIDEOFORMAT = enum(i32) {
    NTSC = 2000,
    PAL = 2001,
};
pub const DVENCODERVIDEOFORMAT_NTSC = _DVENCODERVIDEOFORMAT.NTSC;
pub const DVENCODERVIDEOFORMAT_PAL = _DVENCODERVIDEOFORMAT.PAL;

pub const _DVENCODERFORMAT = enum(i32) {
    SD = 2007,
    HD = 2008,
    SL = 2009,
};
pub const DVENCODERFORMAT_DVSD = _DVENCODERFORMAT.SD;
pub const DVENCODERFORMAT_DVHD = _DVENCODERFORMAT.HD;
pub const DVENCODERFORMAT_DVSL = _DVENCODERFORMAT.SL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDVEnc_Value = Guid.initString("d18e17a0-aacb-11d0-afb0-00aa00b67a42");
pub const IID_IDVEnc = &IID_IDVEnc_Value;
pub const IDVEnc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IFormatResolution: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVEnc,
            video_format: ?*i32,
            d_v_format: ?*i32,
            resolution: ?*i32,
            f_d_v_info: u8,
            s_d_v_info: ?*DVINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IFormatResolution: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVEnc,
            video_format: i32,
            d_v_format: i32,
            resolution: i32,
            f_d_v_info: u8,
            s_d_v_info: ?*DVINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIFormatResolution(self: *const T, video_format_: ?*i32, d_v_format_: ?*i32, resolution_: ?*i32, f_d_v_info_: u8, s_d_v_info_: ?*DVINFO) HRESULT {
                return @as(*const IDVEnc.VTable, @ptrCast(self.vtable)).get_IFormatResolution(@as(*const IDVEnc, @ptrCast(self)), video_format_, d_v_format_, resolution_, f_d_v_info_, s_d_v_info_);
            }
            pub inline fn putIFormatResolution(self: *const T, video_format_: i32, d_v_format_: i32, resolution_: i32, f_d_v_info_: u8, s_d_v_info_: ?*DVINFO) HRESULT {
                return @as(*const IDVEnc.VTable, @ptrCast(self.vtable)).put_IFormatResolution(@as(*const IDVEnc, @ptrCast(self)), video_format_, d_v_format_, resolution_, f_d_v_info_, s_d_v_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _DVDECODERRESOLUTION = enum(i32) {
    @"720x480" = 1000,
    @"360x240" = 1001,
    @"180x120" = 1002,
    @"88x60" = 1003,
};
pub const DVDECODERRESOLUTION_720x480 = _DVDECODERRESOLUTION.@"720x480";
pub const DVDECODERRESOLUTION_360x240 = _DVDECODERRESOLUTION.@"360x240";
pub const DVDECODERRESOLUTION_180x120 = _DVDECODERRESOLUTION.@"180x120";
pub const DVDECODERRESOLUTION_88x60 = _DVDECODERRESOLUTION.@"88x60";

pub const _DVRESOLUTION = enum(i32) {
    FULL = 1000,
    HALF = 1001,
    QUARTER = 1002,
    DC = 1003,
};
pub const DVRESOLUTION_FULL = _DVRESOLUTION.FULL;
pub const DVRESOLUTION_HALF = _DVRESOLUTION.HALF;
pub const DVRESOLUTION_QUARTER = _DVRESOLUTION.QUARTER;
pub const DVRESOLUTION_DC = _DVRESOLUTION.DC;

// TODO: this type is limited to platform 'windows5.0'
const IID_IIPDVDec_Value = Guid.initString("b8e8bd60-0bfe-11d0-af91-00aa00b67a42");
pub const IID_IIPDVDec = &IID_IIPDVDec_Value;
pub const IIPDVDec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPDisplay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IIPDVDec,
            display_pix: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IPDisplay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IIPDVDec,
            display_pix: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIPDisplay(self: *const T, display_pix_: ?*i32) HRESULT {
                return @as(*const IIPDVDec.VTable, @ptrCast(self.vtable)).get_IPDisplay(@as(*const IIPDVDec, @ptrCast(self)), display_pix_);
            }
            pub inline fn putIPDisplay(self: *const T, display_pix_: i32) HRESULT {
                return @as(*const IIPDVDec.VTable, @ptrCast(self.vtable)).put_IPDisplay(@as(*const IIPDVDec, @ptrCast(self)), display_pix_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVRGB219_Value = Guid.initString("58473a19-2bc8-4663-8012-25f81babddd1");
pub const IID_IDVRGB219 = &IID_IDVRGB219_Value;
pub const IDVRGB219 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRGB219: *const fn (
            self: *const IDVRGB219,
            b_state: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setRGB219(self: *const T, b_state_: BOOL) HRESULT {
                return @as(*const IDVRGB219.VTable, @ptrCast(self.vtable)).SetRGB219(@as(*const IDVRGB219, @ptrCast(self)), b_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVSplitter_Value = Guid.initString("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02");
pub const IID_IDVSplitter = &IID_IDVSplitter_Value;
pub const IDVSplitter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DiscardAlternateVideoFrames: *const fn (
            self: *const IDVSplitter,
            n_discard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn discardAlternateVideoFrames(self: *const T, n_discard_: i32) HRESULT {
                return @as(*const IDVSplitter.VTable, @ptrCast(self.vtable)).DiscardAlternateVideoFrames(@as(*const IDVSplitter, @ptrCast(self)), n_discard_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_AUDIO_RENDERER_STAT_PARAM = enum(i32) {
    BREAK_COUNT = 1,
    SLAVE_MODE = 2,
    SILENCE_DUR = 3,
    LAST_BUFFER_DUR = 4,
    DISCONTINUITIES = 5,
    SLAVE_RATE = 6,
    SLAVE_DROPWRITE_DUR = 7,
    SLAVE_HIGHLOWERROR = 8,
    SLAVE_LASTHIGHLOWERROR = 9,
    SLAVE_ACCUMERROR = 10,
    BUFFERFULLNESS = 11,
    JITTER = 12,
};
pub const AM_AUDREND_STAT_PARAM_BREAK_COUNT = _AM_AUDIO_RENDERER_STAT_PARAM.BREAK_COUNT;
pub const AM_AUDREND_STAT_PARAM_SLAVE_MODE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_MODE;
pub const AM_AUDREND_STAT_PARAM_SILENCE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SILENCE_DUR;
pub const AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.LAST_BUFFER_DUR;
pub const AM_AUDREND_STAT_PARAM_DISCONTINUITIES = _AM_AUDIO_RENDERER_STAT_PARAM.DISCONTINUITIES;
pub const AM_AUDREND_STAT_PARAM_SLAVE_RATE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_RATE;
pub const AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_DROPWRITE_DUR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_HIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_LASTHIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_ACCUMERROR;
pub const AM_AUDREND_STAT_PARAM_BUFFERFULLNESS = _AM_AUDIO_RENDERER_STAT_PARAM.BUFFERFULLNESS;
pub const AM_AUDREND_STAT_PARAM_JITTER = _AM_AUDIO_RENDERER_STAT_PARAM.JITTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMAudioRendererStats_Value = Guid.initString("22320cb2-d41a-11d2-bf7c-d7cb9df0bf93");
pub const IID_IAMAudioRendererStats = &IID_IAMAudioRendererStats_Value;
pub const IAMAudioRendererStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatParam: *const fn (
            self: *const IAMAudioRendererStats,
            dw_param: u32,
            pdw_param1: ?*u32,
            pdw_param2: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatParam(self: *const T, dw_param_: u32, pdw_param1_: ?*u32, pdw_param2_: ?*u32) HRESULT {
                return @as(*const IAMAudioRendererStats.VTable, @ptrCast(self.vtable)).GetStatParam(@as(*const IAMAudioRendererStats, @ptrCast(self)), dw_param_, pdw_param1_, pdw_param2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_INTF_SEARCH_FLAGS = enum(i32) {
    INPUT_PIN = 1,
    OUTPUT_PIN = 2,
    FILTER = 4,
};
pub const AM_INTF_SEARCH_INPUT_PIN = _AM_INTF_SEARCH_FLAGS.INPUT_PIN;
pub const AM_INTF_SEARCH_OUTPUT_PIN = _AM_INTF_SEARCH_FLAGS.OUTPUT_PIN;
pub const AM_INTF_SEARCH_FILTER = _AM_INTF_SEARCH_FLAGS.FILTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMGraphStreams_Value = Guid.initString("632105fa-072e-11d3-8af9-00c04fb6bd3d");
pub const IID_IAMGraphStreams = &IID_IAMGraphStreams_Value;
pub const IAMGraphStreams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindUpstreamInterface: *const fn (
            self: *const IAMGraphStreams,
            p_pin: ?*IPin,
            riid: ?*const Guid,
            ppv_interface: ?*?*anyopaque,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncUsingStreamOffset: *const fn (
            self: *const IAMGraphStreams,
            b_use_stream_offset: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxGraphLatency: *const fn (
            self: *const IAMGraphStreams,
            rt_max_graph_latency: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn findUpstreamInterface(self: *const T, p_pin_: ?*IPin, riid_: ?*const Guid, ppv_interface_: ?*?*anyopaque, dw_flags_: u32) HRESULT {
                return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).FindUpstreamInterface(@as(*const IAMGraphStreams, @ptrCast(self)), p_pin_, riid_, ppv_interface_, dw_flags_);
            }
            pub inline fn syncUsingStreamOffset(self: *const T, b_use_stream_offset_: BOOL) HRESULT {
                return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).SyncUsingStreamOffset(@as(*const IAMGraphStreams, @ptrCast(self)), b_use_stream_offset_);
            }
            pub inline fn setMaxGraphLatency(self: *const T, rt_max_graph_latency_: i64) HRESULT {
                return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).SetMaxGraphLatency(@as(*const IAMGraphStreams, @ptrCast(self)), rt_max_graph_latency_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMOVERLAYFX = enum(i32) {
    NOFX = 0,
    MIRRORLEFTRIGHT = 2,
    MIRRORUPDOWN = 4,
    DEINTERLACE = 8,
};
pub const AMOVERFX_NOFX = AMOVERLAYFX.NOFX;
pub const AMOVERFX_MIRRORLEFTRIGHT = AMOVERLAYFX.MIRRORLEFTRIGHT;
pub const AMOVERFX_MIRRORUPDOWN = AMOVERLAYFX.MIRRORUPDOWN;
pub const AMOVERFX_DEINTERLACE = AMOVERLAYFX.DEINTERLACE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMOverlayFX_Value = Guid.initString("62fae250-7e65-4460-bfc9-6398b322073c");
pub const IID_IAMOverlayFX = &IID_IAMOverlayFX_Value;
pub const IAMOverlayFX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOverlayFXCaps: *const fn (
            self: *const IAMOverlayFX,
            lpdw_overlay_f_x_caps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayFX: *const fn (
            self: *const IAMOverlayFX,
            dw_overlay_f_x: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayFX: *const fn (
            self: *const IAMOverlayFX,
            lpdw_overlay_f_x: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryOverlayFXCaps(self: *const T, lpdw_overlay_f_x_caps_: ?*u32) HRESULT {
                return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).QueryOverlayFXCaps(@as(*const IAMOverlayFX, @ptrCast(self)), lpdw_overlay_f_x_caps_);
            }
            pub inline fn setOverlayFX(self: *const T, dw_overlay_f_x_: u32) HRESULT {
                return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).SetOverlayFX(@as(*const IAMOverlayFX, @ptrCast(self)), dw_overlay_f_x_);
            }
            pub inline fn getOverlayFX(self: *const T, lpdw_overlay_f_x_: ?*u32) HRESULT {
                return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).GetOverlayFX(@as(*const IAMOverlayFX, @ptrCast(self)), lpdw_overlay_f_x_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMOpenProgress_Value = Guid.initString("8e1c39a1-de53-11cf-aa63-0080c744528d");
pub const IID_IAMOpenProgress = &IID_IAMOpenProgress_Value;
pub const IAMOpenProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryProgress: *const fn (
            self: *const IAMOpenProgress,
            pll_total: ?*i64,
            pll_current: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortOperation: *const fn (
            self: *const IAMOpenProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryProgress(self: *const T, pll_total_: ?*i64, pll_current_: ?*i64) HRESULT {
                return @as(*const IAMOpenProgress.VTable, @ptrCast(self.vtable)).QueryProgress(@as(*const IAMOpenProgress, @ptrCast(self)), pll_total_, pll_current_);
            }
            pub inline fn abortOperation(self: *const T) HRESULT {
                return @as(*const IAMOpenProgress.VTable, @ptrCast(self.vtable)).AbortOperation(@as(*const IAMOpenProgress, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMpeg2Demultiplexer_Value = Guid.initString("436eee9c-264f-4242-90e1-4e330c107512");
pub const IID_IMpeg2Demultiplexer = &IID_IMpeg2Demultiplexer_Value;
pub const IMpeg2Demultiplexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateOutputPin: *const fn (
            self: *const IMpeg2Demultiplexer,
            p_media_type: ?*AM_MEDIA_TYPE,
            psz_pin_name: ?PWSTR,
            pp_i_pin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputPinMediaType: *const fn (
            self: *const IMpeg2Demultiplexer,
            psz_pin_name: ?PWSTR,
            p_media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteOutputPin: *const fn (
            self: *const IMpeg2Demultiplexer,
            psz_pin_name: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createOutputPin(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE, psz_pin_name_: ?PWSTR, pp_i_pin_: ?*?*IPin) HRESULT {
                return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).CreateOutputPin(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), p_media_type_, psz_pin_name_, pp_i_pin_);
            }
            pub inline fn setOutputPinMediaType(self: *const T, psz_pin_name_: ?PWSTR, p_media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).SetOutputPinMediaType(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), psz_pin_name_, p_media_type_);
            }
            pub inline fn deleteOutputPin(self: *const T, psz_pin_name_: ?PWSTR) HRESULT {
                return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).DeleteOutputPin(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), psz_pin_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_ID_MAP = extern struct {
    stream_id: u32,
    dwMediaSampleContent: u32,
    ulSubstreamFilterValue: u32,
    iDataOffset: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamIdMap_Value = Guid.initString("945c1566-6202-46fc-96c7-d87f289c6534");
pub const IID_IEnumStreamIdMap = &IID_IEnumStreamIdMap_Value;
pub const IEnumStreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumStreamIdMap,
            c_request: u32,
            p_stream_id_map: [*]STREAM_ID_MAP,
            pc_received: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumStreamIdMap,
            c_records: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumStreamIdMap,
            pp_i_enum_stream_id_map: ?*?*IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_request_: u32, p_stream_id_map_: [*]STREAM_ID_MAP, pc_received_: ?*u32) HRESULT {
                return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumStreamIdMap, @ptrCast(self)), c_request_, p_stream_id_map_, pc_received_);
            }
            pub inline fn skip(self: *const T, c_records_: u32) HRESULT {
                return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumStreamIdMap, @ptrCast(self)), c_records_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumStreamIdMap, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_i_enum_stream_id_map_: ?*?*IEnumStreamIdMap) HRESULT {
                return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumStreamIdMap, @ptrCast(self)), pp_i_enum_stream_id_map_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2StreamIdMap_Value = Guid.initString("d0e04c47-25b8-4369-925a-362a01d95444");
pub const IID_IMPEG2StreamIdMap = &IID_IMPEG2StreamIdMap_Value;
pub const IMPEG2StreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStreamId: *const fn (
            self: *const IMPEG2StreamIdMap,
            ul_stream_id: u32,
            media_sample_content: u32,
            ul_substream_filter_value: u32,
            i_data_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapStreamId: *const fn (
            self: *const IMPEG2StreamIdMap,
            cul_stream_id: u32,
            pul_stream_id: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStreamIdMap: *const fn (
            self: *const IMPEG2StreamIdMap,
            pp_i_enum_stream_id_map: ?*?*IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn mapStreamId(self: *const T, ul_stream_id_: u32, media_sample_content_: u32, ul_substream_filter_value_: u32, i_data_offset_: i32) HRESULT {
                return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).MapStreamId(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), ul_stream_id_, media_sample_content_, ul_substream_filter_value_, i_data_offset_);
            }
            pub inline fn unmapStreamId(self: *const T, cul_stream_id_: u32, pul_stream_id_: [*]u32) HRESULT {
                return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).UnmapStreamId(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), cul_stream_id_, pul_stream_id_);
            }
            pub inline fn enumStreamIdMap(self: *const T, pp_i_enum_stream_id_map_: ?*?*IEnumStreamIdMap) HRESULT {
                return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).EnumStreamIdMap(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), pp_i_enum_stream_id_map_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRegisterServiceProvider_Value = Guid.initString("7b3a2f01-0751-48dd-b556-004785171c54");
pub const IID_IRegisterServiceProvider = &IID_IRegisterServiceProvider_Value;
pub const IRegisterServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterService: *const fn (
            self: *const IRegisterServiceProvider,
            guid_service: ?*const Guid,
            p_unk_object: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerService(self: *const T, guid_service_: ?*const Guid, p_unk_object_: ?*IUnknown) HRESULT {
                return @as(*const IRegisterServiceProvider.VTable, @ptrCast(self.vtable)).RegisterService(@as(*const IRegisterServiceProvider, @ptrCast(self)), guid_service_, p_unk_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMClockSlave_Value = Guid.initString("9fd52741-176d-4b36-8f51-ca8f933223be");
pub const IID_IAMClockSlave = &IID_IAMClockSlave_Value;
pub const IAMClockSlave = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetErrorTolerance: *const fn (
            self: *const IAMClockSlave,
            dw_tolerance: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorTolerance: *const fn (
            self: *const IAMClockSlave,
            pdw_tolerance: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setErrorTolerance(self: *const T, dw_tolerance_: u32) HRESULT {
                return @as(*const IAMClockSlave.VTable, @ptrCast(self.vtable)).SetErrorTolerance(@as(*const IAMClockSlave, @ptrCast(self)), dw_tolerance_);
            }
            pub inline fn getErrorTolerance(self: *const T, pdw_tolerance_: ?*u32) HRESULT {
                return @as(*const IAMClockSlave.VTable, @ptrCast(self.vtable)).GetErrorTolerance(@as(*const IAMClockSlave, @ptrCast(self)), pdw_tolerance_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMGraphBuilderCallback_Value = Guid.initString("4995f511-9ddb-4f12-bd3b-f04611807b79");
pub const IID_IAMGraphBuilderCallback = &IID_IAMGraphBuilderCallback_Value;
pub const IAMGraphBuilderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SelectedFilter: *const fn (
            self: *const IAMGraphBuilderCallback,
            p_mon: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatedFilter: *const fn (
            self: *const IAMGraphBuilderCallback,
            p_fil: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn selectedFilter(self: *const T, p_mon_: ?*IMoniker) HRESULT {
                return @as(*const IAMGraphBuilderCallback.VTable, @ptrCast(self.vtable)).SelectedFilter(@as(*const IAMGraphBuilderCallback, @ptrCast(self)), p_mon_);
            }
            pub inline fn createdFilter(self: *const T, p_fil_: ?*IBaseFilter) HRESULT {
                return @as(*const IAMGraphBuilderCallback.VTable, @ptrCast(self.vtable)).CreatedFilter(@as(*const IAMGraphBuilderCallback, @ptrCast(self)), p_fil_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterGraphCallback_Value = Guid.initString("56a868fd-0ad4-11ce-b0a3-0020af0ba770");
pub const IID_IAMFilterGraphCallback = &IID_IAMFilterGraphCallback_Value;
pub const IAMFilterGraphCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UnableToRender: *const fn (
            self: *const IAMFilterGraphCallback,
            p_pin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn unableToRender(self: *const T, p_pin_: ?*IPin) HRESULT {
                return @as(*const IAMFilterGraphCallback.VTable, @ptrCast(self.vtable)).UnableToRender(@as(*const IAMFilterGraphCallback, @ptrCast(self)), p_pin_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGetCapabilitiesKey_Value = Guid.initString("a8809222-07bb-48ea-951c-33158100625b");
pub const IID_IGetCapabilitiesKey = &IID_IGetCapabilitiesKey_Value;
pub const IGetCapabilitiesKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilitiesKey: *const fn (
            self: *const IGetCapabilitiesKey,
            p_h_key: ?*?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCapabilitiesKey(self: *const T, p_h_key_: ?*?HKEY) HRESULT {
                return @as(*const IGetCapabilitiesKey.VTable, @ptrCast(self.vtable)).GetCapabilitiesKey(@as(*const IGetCapabilitiesKey, @ptrCast(self)), p_h_key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEncoderAPI_Value = Guid.initString("70423839-6acc-4b23-b079-21dbf08156a5");
pub const IID_IEncoderAPI = &IID_IEncoderAPI_Value;
pub const IEncoderAPI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSupported: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAvailable: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterRange: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
            value_min: ?*VARIANT,
            value_max: ?*VARIANT,
            stepping_delta: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterValues: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
            values: [*]?*VARIANT,
            values_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultValue: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: *const fn (
            self: *const IEncoderAPI,
            api: ?*const Guid,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isSupported(self: *const T, api_: ?*const Guid) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const IEncoderAPI, @ptrCast(self)), api_);
            }
            pub inline fn isAvailable(self: *const T, api_: ?*const Guid) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).IsAvailable(@as(*const IEncoderAPI, @ptrCast(self)), api_);
            }
            pub inline fn getParameterRange(self: *const T, api_: ?*const Guid, value_min_: ?*VARIANT, value_max_: ?*VARIANT, stepping_delta_: ?*VARIANT) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetParameterRange(@as(*const IEncoderAPI, @ptrCast(self)), api_, value_min_, value_max_, stepping_delta_);
            }
            pub inline fn getParameterValues(self: *const T, api_: ?*const Guid, values_: [*]?*VARIANT, values_count_: ?*u32) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetParameterValues(@as(*const IEncoderAPI, @ptrCast(self)), api_, values_, values_count_);
            }
            pub inline fn getDefaultValue(self: *const T, api_: ?*const Guid, value_: ?*VARIANT) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetDefaultValue(@as(*const IEncoderAPI, @ptrCast(self)), api_, value_);
            }
            pub inline fn getValue(self: *const T, api_: ?*const Guid, value_: ?*VARIANT) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IEncoderAPI, @ptrCast(self)), api_, value_);
            }
            pub inline fn setValue(self: *const T, api_: ?*const Guid, value_: ?*VARIANT) HRESULT {
                return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IEncoderAPI, @ptrCast(self)), api_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IVideoEncoder_Value = Guid.initString("02997c3b-8e1b-460e-9270-545e0de9563e");
pub const IID_IVideoEncoder = &IID_IVideoEncoder_Value;
pub const IVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IEncoderAPI.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEncoderAPI.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMDecoderCaps_Value = Guid.initString("c0dff467-d499-4986-972b-e1d9090fa941");
pub const IID_IAMDecoderCaps = &IID_IAMDecoderCaps_Value;
pub const IAMDecoderCaps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderCaps: *const fn (
            self: *const IAMDecoderCaps,
            dw_cap_index: u32,
            lpdw_cap: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDecoderCaps(self: *const T, dw_cap_index_: u32, lpdw_cap_: ?*u32) HRESULT {
                return @as(*const IAMDecoderCaps.VTable, @ptrCast(self.vtable)).GetDecoderCaps(@as(*const IAMDecoderCaps, @ptrCast(self)), dw_cap_index_, lpdw_cap_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMCOPPSignature = extern struct {
    Signature: [256]u8,
};

pub const AMCOPPCommand = extern struct {
    macKDI: Guid,
    guidCommandID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    CommandData: [4056]u8,
};

pub const AMCOPPStatusInput = extern struct {
    rApp: Guid,
    guidStatusRequestID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    StatusData: [4056]u8,
};

pub const AMCOPPStatusOutput = extern struct {
    macKDI: Guid,
    cbSizeData: u32,
    COPPStatus: [4076]u8,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMCertifiedOutputProtection_Value = Guid.initString("6feded3e-0ff1-4901-a2f1-43f7012c8515");
pub const IID_IAMCertifiedOutputProtection = &IID_IAMCertifiedOutputProtection_Value;
pub const IAMCertifiedOutputProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyExchange: *const fn (
            self: *const IAMCertifiedOutputProtection,
            p_random: ?*Guid,
            var_len_cert_g_h: ?*?*u8,
            pdw_length_cert_g_h: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionSequenceStart: *const fn (
            self: *const IAMCertifiedOutputProtection,
            p_sig: ?*AMCOPPSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProtectionCommand: *const fn (
            self: *const IAMCertifiedOutputProtection,
            cmd: ?*const AMCOPPCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProtectionStatus: *const fn (
            self: *const IAMCertifiedOutputProtection,
            p_status_input: ?*const AMCOPPStatusInput,
            p_status_output: ?*AMCOPPStatusOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn keyExchange(self: *const T, p_random_: ?*Guid, var_len_cert_g_h_: ?*?*u8, pdw_length_cert_g_h_: ?*u32) HRESULT {
                return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).KeyExchange(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), p_random_, var_len_cert_g_h_, pdw_length_cert_g_h_);
            }
            pub inline fn sessionSequenceStart(self: *const T, p_sig_: ?*AMCOPPSignature) HRESULT {
                return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).SessionSequenceStart(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), p_sig_);
            }
            pub inline fn protectionCommand(self: *const T, cmd_: ?*const AMCOPPCommand) HRESULT {
                return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).ProtectionCommand(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), cmd_);
            }
            pub inline fn protectionStatus(self: *const T, p_status_input_: ?*const AMCOPPStatusInput, p_status_output_: ?*AMCOPPStatusOutput) HRESULT {
                return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).ProtectionStatus(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), p_status_input_, p_status_output_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMAsyncReaderTimestampScaling_Value = Guid.initString("cf7b26fc-9a00-485b-8147-3e789d5e8f67");
pub const IID_IAMAsyncReaderTimestampScaling = &IID_IAMAsyncReaderTimestampScaling_Value;
pub const IAMAsyncReaderTimestampScaling = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestampMode: *const fn (
            self: *const IAMAsyncReaderTimestampScaling,
            pf_raw: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimestampMode: *const fn (
            self: *const IAMAsyncReaderTimestampScaling,
            f_raw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTimestampMode(self: *const T, pf_raw_: ?*BOOL) HRESULT {
                return @as(*const IAMAsyncReaderTimestampScaling.VTable, @ptrCast(self.vtable)).GetTimestampMode(@as(*const IAMAsyncReaderTimestampScaling, @ptrCast(self)), pf_raw_);
            }
            pub inline fn setTimestampMode(self: *const T, f_raw_: BOOL) HRESULT {
                return @as(*const IAMAsyncReaderTimestampScaling.VTable, @ptrCast(self.vtable)).SetTimestampMode(@as(*const IAMAsyncReaderTimestampScaling, @ptrCast(self)), f_raw_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMPluginControl_Value = Guid.initString("0e26a181-f40c-4635-8786-976284b52981");
pub const IID_IAMPluginControl = &IID_IAMPluginControl_Value;
pub const IAMPluginControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreferredClsid: *const fn (
            self: *const IAMPluginControl,
            sub_type: ?*const Guid,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredClsidByIndex: *const fn (
            self: *const IAMPluginControl,
            index: u32,
            sub_type: ?*Guid,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreferredClsid: *const fn (
            self: *const IAMPluginControl,
            sub_type: ?*const Guid,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDisabled: *const fn (
            self: *const IAMPluginControl,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisabledByIndex: *const fn (
            self: *const IAMPluginControl,
            index: u32,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisabled: *const fn (
            self: *const IAMPluginControl,
            clsid: ?*const Guid,
            disabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLegacyDisabled: *const fn (
            self: *const IAMPluginControl,
            dll_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPreferredClsid(self: *const T, sub_type_: ?*const Guid, clsid_: ?*Guid) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsid(@as(*const IAMPluginControl, @ptrCast(self)), sub_type_, clsid_);
            }
            pub inline fn getPreferredClsidByIndex(self: *const T, index_: u32, sub_type_: ?*Guid, clsid_: ?*Guid) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsidByIndex(@as(*const IAMPluginControl, @ptrCast(self)), index_, sub_type_, clsid_);
            }
            pub inline fn setPreferredClsid(self: *const T, sub_type_: ?*const Guid, clsid_: ?*const Guid) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).SetPreferredClsid(@as(*const IAMPluginControl, @ptrCast(self)), sub_type_, clsid_);
            }
            pub inline fn isDisabled(self: *const T, clsid_: ?*const Guid) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).IsDisabled(@as(*const IAMPluginControl, @ptrCast(self)), clsid_);
            }
            pub inline fn getDisabledByIndex(self: *const T, index_: u32, clsid_: ?*Guid) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetDisabledByIndex(@as(*const IAMPluginControl, @ptrCast(self)), index_, clsid_);
            }
            pub inline fn setDisabled(self: *const T, clsid_: ?*const Guid, disabled_: BOOL) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).SetDisabled(@as(*const IAMPluginControl, @ptrCast(self)), clsid_, disabled_);
            }
            pub inline fn isLegacyDisabled(self: *const T, dll_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).IsLegacyDisabled(@as(*const IAMPluginControl, @ptrCast(self)), dll_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinConnection_Value = Guid.initString("4a9a62d3-27d4-403d-91e9-89f540e55534");
pub const IID_IPinConnection = &IID_IPinConnection_Value;
pub const IPinConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DynamicQueryAccept: *const fn (
            self: *const IPinConnection,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEndOfStream: *const fn (
            self: *const IPinConnection,
            h_notify_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEndPin: *const fn (
            self: *const IPinConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DynamicDisconnect: *const fn (
            self: *const IPinConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn dynamicQueryAccept(self: *const T, pmt_: ?*const AM_MEDIA_TYPE) HRESULT {
                return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).DynamicQueryAccept(@as(*const IPinConnection, @ptrCast(self)), pmt_);
            }
            pub inline fn notifyEndOfStream(self: *const T, h_notify_event_: ?HANDLE) HRESULT {
                return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).NotifyEndOfStream(@as(*const IPinConnection, @ptrCast(self)), h_notify_event_);
            }
            pub inline fn isEndPin(self: *const T) HRESULT {
                return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).IsEndPin(@as(*const IPinConnection, @ptrCast(self)));
            }
            pub inline fn dynamicDisconnect(self: *const T) HRESULT {
                return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).DynamicDisconnect(@as(*const IPinConnection, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinFlowControl_Value = Guid.initString("c56e9858-dbf3-4f6b-8119-384af2060deb");
pub const IID_IPinFlowControl = &IID_IPinFlowControl_Value;
pub const IPinFlowControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Block: *const fn (
            self: *const IPinFlowControl,
            dw_block_flags: u32,
            h_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn block(self: *const T, dw_block_flags_: u32, h_event_: ?HANDLE) HRESULT {
                return @as(*const IPinFlowControl.VTable, @ptrCast(self.vtable)).Block(@as(*const IPinFlowControl, @ptrCast(self)), dw_block_flags_, h_event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS = enum(i32) {
    K = 1,
};
pub const AM_PIN_FLOW_CONTROL_BLOCK = _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS.K;

pub const AM_GRAPH_CONFIG_RECONNECT_FLAGS = enum(i32) {
    DIRECTCONNECT = 1,
    CACHE_REMOVED_FILTERS = 2,
    USE_ONLY_CACHED_FILTERS = 4,
};
pub const AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT = AM_GRAPH_CONFIG_RECONNECT_FLAGS.DIRECTCONNECT;
pub const AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.CACHE_REMOVED_FILTERS;
pub const AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.USE_ONLY_CACHED_FILTERS;

pub const _REM_FILTER_FLAGS = enum(i32) {
    D = 1,
};
pub const REMFILTERF_LEAVECONNECTED = _REM_FILTER_FLAGS.D;

pub const AM_FILTER_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILTER_FLAGS_REMOVABLE = AM_FILTER_FLAGS.E;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfig_Value = Guid.initString("03a1eb8e-32bf-4245-8502-114d08a9cb88");
pub const IID_IGraphConfig = &IID_IGraphConfig_Value;
pub const IGraphConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconnect: *const fn (
            self: *const IGraphConfig,
            p_output_pin: ?*IPin,
            p_input_pin: ?*IPin,
            pmt_first_connection: ?*const AM_MEDIA_TYPE,
            p_using_filter: ?*IBaseFilter,
            h_abort_event: ?HANDLE,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconfigure: *const fn (
            self: *const IGraphConfig,
            p_callback: ?*IGraphConfigCallback,
            pv_context: ?*anyopaque,
            dw_flags: u32,
            h_abort_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilterToCache: *const fn (
            self: *const IGraphConfig,
            p_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCacheFilter: *const fn (
            self: *const IGraphConfig,
            p_enum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilterFromCache: *const fn (
            self: *const IGraphConfig,
            p_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartTime: *const fn (
            self: *const IGraphConfig,
            prt_start: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushThroughData: *const fn (
            self: *const IGraphConfig,
            p_output_pin: ?*IPin,
            p_connection: ?*IPinConnection,
            h_event_abort: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilterFlags: *const fn (
            self: *const IGraphConfig,
            p_filter: ?*IBaseFilter,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterFlags: *const fn (
            self: *const IGraphConfig,
            p_filter: ?*IBaseFilter,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilterEx: *const fn (
            self: *const IGraphConfig,
            p_filter: ?*IBaseFilter,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reconnect(self: *const T, p_output_pin_: ?*IPin, p_input_pin_: ?*IPin, pmt_first_connection_: ?*const AM_MEDIA_TYPE, p_using_filter_: ?*IBaseFilter, h_abort_event_: ?HANDLE, dw_flags_: u32) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).Reconnect(@as(*const IGraphConfig, @ptrCast(self)), p_output_pin_, p_input_pin_, pmt_first_connection_, p_using_filter_, h_abort_event_, dw_flags_);
            }
            pub inline fn reconfigure(self: *const T, p_callback_: ?*IGraphConfigCallback, pv_context_: ?*anyopaque, dw_flags_: u32, h_abort_event_: ?HANDLE) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).Reconfigure(@as(*const IGraphConfig, @ptrCast(self)), p_callback_, pv_context_, dw_flags_, h_abort_event_);
            }
            pub inline fn addFilterToCache(self: *const T, p_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).AddFilterToCache(@as(*const IGraphConfig, @ptrCast(self)), p_filter_);
            }
            pub inline fn enumCacheFilter(self: *const T, p_enum_: ?*?*IEnumFilters) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).EnumCacheFilter(@as(*const IGraphConfig, @ptrCast(self)), p_enum_);
            }
            pub inline fn removeFilterFromCache(self: *const T, p_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).RemoveFilterFromCache(@as(*const IGraphConfig, @ptrCast(self)), p_filter_);
            }
            pub inline fn getStartTime(self: *const T, prt_start_: ?*i64) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const IGraphConfig, @ptrCast(self)), prt_start_);
            }
            pub inline fn pushThroughData(self: *const T, p_output_pin_: ?*IPin, p_connection_: ?*IPinConnection, h_event_abort_: ?HANDLE) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).PushThroughData(@as(*const IGraphConfig, @ptrCast(self)), p_output_pin_, p_connection_, h_event_abort_);
            }
            pub inline fn setFilterFlags(self: *const T, p_filter_: ?*IBaseFilter, dw_flags_: u32) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).SetFilterFlags(@as(*const IGraphConfig, @ptrCast(self)), p_filter_, dw_flags_);
            }
            pub inline fn getFilterFlags(self: *const T, p_filter_: ?*IBaseFilter, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).GetFilterFlags(@as(*const IGraphConfig, @ptrCast(self)), p_filter_, pdw_flags_);
            }
            pub inline fn removeFilterEx(self: *const T, p_filter_: ?*IBaseFilter, flags_: u32) HRESULT {
                return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).RemoveFilterEx(@as(*const IGraphConfig, @ptrCast(self)), p_filter_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfigCallback_Value = Guid.initString("ade0fd60-d19d-11d2-abf6-00a0c905f375");
pub const IID_IGraphConfigCallback = &IID_IGraphConfigCallback_Value;
pub const IGraphConfigCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconfigure: *const fn (
            self: *const IGraphConfigCallback,
            pv_context: ?*anyopaque,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reconfigure(self: *const T, pv_context_: ?*anyopaque, dw_flags_: u32) HRESULT {
                return @as(*const IGraphConfigCallback.VTable, @ptrCast(self.vtable)).Reconfigure(@as(*const IGraphConfigCallback, @ptrCast(self)), pv_context_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterChain_Value = Guid.initString("dcfbdcf6-0dc2-45f5-9ab2-7c330ea09c29");
pub const IID_IFilterChain = &IID_IFilterChain_Value;
pub const IFilterChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChain: *const fn (
            self: *const IFilterChain,
            p_start_filter: ?*IBaseFilter,
            p_end_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseChain: *const fn (
            self: *const IFilterChain,
            p_start_filter: ?*IBaseFilter,
            p_end_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopChain: *const fn (
            self: *const IFilterChain,
            p_start_filter: ?*IBaseFilter,
            p_end_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveChain: *const fn (
            self: *const IFilterChain,
            p_start_filter: ?*IBaseFilter,
            p_end_filter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startChain(self: *const T, p_start_filter_: ?*IBaseFilter, p_end_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).StartChain(@as(*const IFilterChain, @ptrCast(self)), p_start_filter_, p_end_filter_);
            }
            pub inline fn pauseChain(self: *const T, p_start_filter_: ?*IBaseFilter, p_end_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).PauseChain(@as(*const IFilterChain, @ptrCast(self)), p_start_filter_, p_end_filter_);
            }
            pub inline fn stopChain(self: *const T, p_start_filter_: ?*IBaseFilter, p_end_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).StopChain(@as(*const IFilterChain, @ptrCast(self)), p_start_filter_, p_end_filter_);
            }
            pub inline fn removeChain(self: *const T, p_start_filter_: ?*IBaseFilter, p_end_filter_: ?*IBaseFilter) HRESULT {
                return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).RemoveChain(@as(*const IFilterChain, @ptrCast(self)), p_start_filter_, p_end_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRPresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMRSample_SyncPoint = VMRPresentationFlags.SyncPoint;
pub const VMRSample_Preroll = VMRPresentationFlags.Preroll;
pub const VMRSample_Discontinuity = VMRPresentationFlags.Discontinuity;
pub const VMRSample_TimeValid = VMRPresentationFlags.TimeValid;
pub const VMRSample_SrcDstRectsValid = VMRPresentationFlags.SrcDstRectsValid;

pub const VMRPRESENTATIONINFO = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirectDrawSurface7,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwTypeSpecificFlags: u32,
    dwInterlaceFlags: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter_Value = Guid.initString("ce704fe7-e71e-41fb-baa2-c4403e1182f5");
pub const IID_IVMRImagePresenter = &IID_IVMRImagePresenter_Value;
pub const IVMRImagePresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: *const fn (
            self: *const IVMRImagePresenter,
            dw_user_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopPresenting: *const fn (
            self: *const IVMRImagePresenter,
            dw_user_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PresentImage: *const fn (
            self: *const IVMRImagePresenter,
            dw_user_i_d: usize,
            lp_pres_info: ?*VMRPRESENTATIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startPresenting(self: *const T, dw_user_i_d_: usize) HRESULT {
                return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).StartPresenting(@as(*const IVMRImagePresenter, @ptrCast(self)), dw_user_i_d_);
            }
            pub inline fn stopPresenting(self: *const T, dw_user_i_d_: usize) HRESULT {
                return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).StopPresenting(@as(*const IVMRImagePresenter, @ptrCast(self)), dw_user_i_d_);
            }
            pub inline fn presentImage(self: *const T, dw_user_i_d_: usize, lp_pres_info_: ?*VMRPRESENTATIONINFO) HRESULT {
                return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).PresentImage(@as(*const IVMRImagePresenter, @ptrCast(self)), dw_user_i_d_, lp_pres_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRSurfaceAllocationFlags = enum(i32) {
    PIXELFORMAT_VALID = 1,
    @"3D_TARGET" = 2,
    ALLOW_SYSMEM = 4,
    FORCE_SYSMEM = 8,
    DIRECTED_FLIP = 16,
    DXVA_TARGET = 32,
};
pub const AMAP_PIXELFORMAT_VALID = VMRSurfaceAllocationFlags.PIXELFORMAT_VALID;
pub const AMAP_3D_TARGET = VMRSurfaceAllocationFlags.@"3D_TARGET";
pub const AMAP_ALLOW_SYSMEM = VMRSurfaceAllocationFlags.ALLOW_SYSMEM;
pub const AMAP_FORCE_SYSMEM = VMRSurfaceAllocationFlags.FORCE_SYSMEM;
pub const AMAP_DIRECTED_FLIP = VMRSurfaceAllocationFlags.DIRECTED_FLIP;
pub const AMAP_DXVA_TARGET = VMRSurfaceAllocationFlags.DXVA_TARGET;

pub const VMRALLOCATIONINFO = extern struct {
    dwFlags: u32,
    lpHdr: ?*BITMAPINFOHEADER,
    lpPixFmt: ?*DDPIXELFORMAT,
    szAspectRatio: SIZE,
    dwMinBuffers: u32,
    dwMaxBuffers: u32,
    dwInterlaceFlags: u32,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator_Value = Guid.initString("31ce832e-4484-458b-8cca-f4d7e3db0b52");
pub const IID_IVMRSurfaceAllocator = &IID_IVMRSurfaceAllocator_Value;
pub const IVMRSurfaceAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllocateSurface: *const fn (
            self: *const IVMRSurfaceAllocator,
            dw_user_i_d: usize,
            lp_alloc_info: ?*VMRALLOCATIONINFO,
            lpdw_actual_buffers: ?*u32,
            lplp_surface: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeSurface: *const fn (
            self: *const IVMRSurfaceAllocator,
            dw_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareSurface: *const fn (
            self: *const IVMRSurfaceAllocator,
            dw_user_i_d: usize,
            lp_surface: ?*IDirectDrawSurface7,
            dw_surface_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseNotify: *const fn (
            self: *const IVMRSurfaceAllocator,
            lp_i_v_m_r_surf_alloc_notify: ?*IVMRSurfaceAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn allocateSurface(self: *const T, dw_user_i_d_: usize, lp_alloc_info_: ?*VMRALLOCATIONINFO, lpdw_actual_buffers_: ?*u32, lplp_surface_: ?*?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).AllocateSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dw_user_i_d_, lp_alloc_info_, lpdw_actual_buffers_, lplp_surface_);
            }
            pub inline fn freeSurface(self: *const T, dw_i_d_: usize) HRESULT {
                return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).FreeSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dw_i_d_);
            }
            pub inline fn prepareSurface(self: *const T, dw_user_i_d_: usize, lp_surface_: ?*IDirectDrawSurface7, dw_surface_flags_: u32) HRESULT {
                return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).PrepareSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dw_user_i_d_, lp_surface_, dw_surface_flags_);
            }
            pub inline fn adviseNotify(self: *const T, lp_i_v_m_r_surf_alloc_notify_: ?*IVMRSurfaceAllocatorNotify) HRESULT {
                return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).AdviseNotify(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), lp_i_v_m_r_surf_alloc_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify_Value = Guid.initString("aada05a8-5a4e-4729-af0b-cea27aed51e2");
pub const IID_IVMRSurfaceAllocatorNotify = &IID_IVMRSurfaceAllocatorNotify_Value;
pub const IVMRSurfaceAllocatorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
            dw_user_i_d: usize,
            lp_i_v_r_m_surface_allocator: ?*IVMRSurfaceAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDrawDevice: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
            lp_d_draw_device: ?*IDirectDraw7,
            h_monitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDDrawDevice: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
            lp_d_draw_device: ?*IDirectDraw7,
            h_monitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDDrawSurfaces: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEvent: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
            event_code: i32,
            param1: isize,
            param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: *const fn (
            self: *const IVMRSurfaceAllocatorNotify,
            clr_border: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSurfaceAllocator(self: *const T, dw_user_i_d_: usize, lp_i_v_r_m_surface_allocator_: ?*IVMRSurfaceAllocator) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).AdviseSurfaceAllocator(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), dw_user_i_d_, lp_i_v_r_m_surface_allocator_);
            }
            pub inline fn setDDrawDevice(self: *const T, lp_d_draw_device_: ?*IDirectDraw7, h_monitor_: ?HMONITOR) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).SetDDrawDevice(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), lp_d_draw_device_, h_monitor_);
            }
            pub inline fn changeDDrawDevice(self: *const T, lp_d_draw_device_: ?*IDirectDraw7, h_monitor_: ?HMONITOR) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).ChangeDDrawDevice(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), lp_d_draw_device_, h_monitor_);
            }
            pub inline fn restoreDDrawSurfaces(self: *const T) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).RestoreDDrawSurfaces(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)));
            }
            pub inline fn notifyEvent(self: *const T, event_code_: i32, param1_: isize, param2_: isize) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).NotifyEvent(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), event_code_, param1_, param2_);
            }
            pub inline fn setBorderColor(self: *const T, clr_border_: u32) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), clr_border_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR_ASPECT_RATIO_MODE = enum(i32) {
    NONE = 0,
    LETTER_BOX = 1,
};
pub const VMR_ARMODE_NONE = VMR_ASPECT_RATIO_MODE.NONE;
pub const VMR_ARMODE_LETTER_BOX = VMR_ASPECT_RATIO_MODE.LETTER_BOX;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl_Value = Guid.initString("0eb1088c-4dcd-46f0-878f-39dae86a51b7");
pub const IID_IVMRWindowlessControl = &IID_IVMRWindowlessControl_Value;
pub const IVMRWindowlessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: *const fn (
            self: *const IVMRWindowlessControl,
            lp_width: ?*i32,
            lp_height: ?*i32,
            lp_a_r_width: ?*i32,
            lp_a_r_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealVideoSize: *const fn (
            self: *const IVMRWindowlessControl,
            lp_width: ?*i32,
            lp_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealVideoSize: *const fn (
            self: *const IVMRWindowlessControl,
            lp_width: ?*i32,
            lp_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPosition: *const fn (
            self: *const IVMRWindowlessControl,
            lp_s_r_c_rect: ?*const RECT,
            lp_d_s_t_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: *const fn (
            self: *const IVMRWindowlessControl,
            lp_s_r_c_rect: ?*RECT,
            lp_d_s_t_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: *const fn (
            self: *const IVMRWindowlessControl,
            lp_aspect_ratio_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: *const fn (
            self: *const IVMRWindowlessControl,
            aspect_ratio_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoClippingWindow: *const fn (
            self: *const IVMRWindowlessControl,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RepaintVideo: *const fn (
            self: *const IVMRWindowlessControl,
            hwnd: ?HWND,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayModeChanged: *const fn (
            self: *const IVMRWindowlessControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: *const fn (
            self: *const IVMRWindowlessControl,
            lp_dib: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: *const fn (
            self: *const IVMRWindowlessControl,
            clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: *const fn (
            self: *const IVMRWindowlessControl,
            lp_clr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: *const fn (
            self: *const IVMRWindowlessControl,
            clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: *const fn (
            self: *const IVMRWindowlessControl,
            lp_clr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNativeVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32, lp_a_r_width_: ?*i32, lp_a_r_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_width_, lp_height_, lp_a_r_width_, lp_a_r_height_);
            }
            pub inline fn getMinIdealVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetMinIdealVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_width_, lp_height_);
            }
            pub inline fn getMaxIdealVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetMaxIdealVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_width_, lp_height_);
            }
            pub inline fn setVideoPosition(self: *const T, lp_s_r_c_rect_: ?*const RECT, lp_d_s_t_rect_: ?*const RECT) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetVideoPosition(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_s_r_c_rect_, lp_d_s_t_rect_);
            }
            pub inline fn getVideoPosition(self: *const T, lp_s_r_c_rect_: ?*RECT, lp_d_s_t_rect_: ?*RECT) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_s_r_c_rect_, lp_d_s_t_rect_);
            }
            pub inline fn getAspectRatioMode(self: *const T, lp_aspect_ratio_mode_: ?*u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_aspect_ratio_mode_);
            }
            pub inline fn setAspectRatioMode(self: *const T, aspect_ratio_mode_: u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRWindowlessControl, @ptrCast(self)), aspect_ratio_mode_);
            }
            pub inline fn setVideoClippingWindow(self: *const T, hwnd_: ?HWND) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetVideoClippingWindow(@as(*const IVMRWindowlessControl, @ptrCast(self)), hwnd_);
            }
            pub inline fn repaintVideo(self: *const T, hwnd_: ?HWND, hdc_: ?HDC) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).RepaintVideo(@as(*const IVMRWindowlessControl, @ptrCast(self)), hwnd_, hdc_);
            }
            pub inline fn displayModeChanged(self: *const T) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).DisplayModeChanged(@as(*const IVMRWindowlessControl, @ptrCast(self)));
            }
            pub inline fn getCurrentImage(self: *const T, lp_dib_: ?*?*u8) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_dib_);
            }
            pub inline fn setBorderColor(self: *const T, clr_: u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRWindowlessControl, @ptrCast(self)), clr_);
            }
            pub inline fn getBorderColor(self: *const T, lp_clr_: ?*u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_clr_);
            }
            pub inline fn setColorKey(self: *const T, clr_: u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IVMRWindowlessControl, @ptrCast(self)), clr_);
            }
            pub inline fn getColorKey(self: *const T, lp_clr_: ?*u32) HRESULT {
                return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IVMRWindowlessControl, @ptrCast(self)), lp_clr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRMixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    DecimationReserved = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    FilteringMask = 240,
    RenderTargetRGB = 256,
    RenderTargetYUV = 4096,
    RenderTargetYUV420 = 512,
    RenderTargetYUV422 = 1024,
    RenderTargetYUV444 = 2048,
    RenderTargetReserved = 57344,
    RenderTargetMask = 65280,
    DynamicSwitchToBOB = 65536,
    DynamicDecimateBy2 = 131072,
    DynamicReserved = 786432,
    DynamicMask = 983040,
};
pub const MixerPref_NoDecimation = VMRMixerPrefs.NoDecimation;
pub const MixerPref_DecimateOutput = VMRMixerPrefs.DecimateOutput;
pub const MixerPref_ARAdjustXorY = VMRMixerPrefs.ARAdjustXorY;
pub const MixerPref_DecimationReserved = VMRMixerPrefs.DecimationReserved;
pub const MixerPref_DecimateMask = VMRMixerPrefs.DecimateMask;
pub const MixerPref_BiLinearFiltering = VMRMixerPrefs.BiLinearFiltering;
pub const MixerPref_PointFiltering = VMRMixerPrefs.PointFiltering;
pub const MixerPref_FilteringMask = VMRMixerPrefs.FilteringMask;
pub const MixerPref_RenderTargetRGB = VMRMixerPrefs.RenderTargetRGB;
pub const MixerPref_RenderTargetYUV = VMRMixerPrefs.RenderTargetYUV;
pub const MixerPref_RenderTargetYUV420 = VMRMixerPrefs.RenderTargetYUV420;
pub const MixerPref_RenderTargetYUV422 = VMRMixerPrefs.RenderTargetYUV422;
pub const MixerPref_RenderTargetYUV444 = VMRMixerPrefs.RenderTargetYUV444;
pub const MixerPref_RenderTargetReserved = VMRMixerPrefs.RenderTargetReserved;
pub const MixerPref_RenderTargetMask = VMRMixerPrefs.RenderTargetMask;
pub const MixerPref_DynamicSwitchToBOB = VMRMixerPrefs.DynamicSwitchToBOB;
pub const MixerPref_DynamicDecimateBy2 = VMRMixerPrefs.DynamicDecimateBy2;
pub const MixerPref_DynamicReserved = VMRMixerPrefs.DynamicReserved;
pub const MixerPref_DynamicMask = VMRMixerPrefs.DynamicMask;

pub const NORMALIZEDRECT = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl_Value = Guid.initString("1c1a17b0-bed0-415d-974b-dc6696131599");
pub const IID_IVMRMixerControl = &IID_IVMRMixerControl_Value;
pub const IVMRMixerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            alpha: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlpha: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            p_alpha: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            dw_z: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            p_z: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputRect: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            p_rect: ?*const NORMALIZEDRECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputRect: *const fn (
            self: *const IVMRMixerControl,
            dw_stream_i_d: u32,
            p_rect: ?*NORMALIZEDRECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundClr: *const fn (
            self: *const IVMRMixerControl,
            clr_bkg: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundClr: *const fn (
            self: *const IVMRMixerControl,
            lp_clr_bkg: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMixingPrefs: *const fn (
            self: *const IVMRMixerControl,
            dw_mixer_prefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixingPrefs: *const fn (
            self: *const IVMRMixerControl,
            pdw_mixer_prefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAlpha(self: *const T, dw_stream_i_d_: u32, alpha_: f32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetAlpha(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, alpha_);
            }
            pub inline fn getAlpha(self: *const T, dw_stream_i_d_: u32, p_alpha_: ?*f32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetAlpha(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, p_alpha_);
            }
            pub inline fn setZOrder(self: *const T, dw_stream_i_d_: u32, dw_z_: u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, dw_z_);
            }
            pub inline fn getZOrder(self: *const T, dw_stream_i_d_: u32, p_z_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, p_z_);
            }
            pub inline fn setOutputRect(self: *const T, dw_stream_i_d_: u32, p_rect_: ?*const NORMALIZEDRECT) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetOutputRect(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, p_rect_);
            }
            pub inline fn getOutputRect(self: *const T, dw_stream_i_d_: u32, p_rect_: ?*NORMALIZEDRECT) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetOutputRect(@as(*const IVMRMixerControl, @ptrCast(self)), dw_stream_i_d_, p_rect_);
            }
            pub inline fn setBackgroundClr(self: *const T, clr_bkg_: u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetBackgroundClr(@as(*const IVMRMixerControl, @ptrCast(self)), clr_bkg_);
            }
            pub inline fn getBackgroundClr(self: *const T, lp_clr_bkg_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetBackgroundClr(@as(*const IVMRMixerControl, @ptrCast(self)), lp_clr_bkg_);
            }
            pub inline fn setMixingPrefs(self: *const T, dw_mixer_prefs_: u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetMixingPrefs(@as(*const IVMRMixerControl, @ptrCast(self)), dw_mixer_prefs_);
            }
            pub inline fn getMixingPrefs(self: *const T, pdw_mixer_prefs_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetMixingPrefs(@as(*const IVMRMixerControl, @ptrCast(self)), pdw_mixer_prefs_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRGUID = extern struct {
    pGUID: ?*Guid,
    GUID: Guid,
};

pub const VMRMONITORINFO = extern struct {
    guid: VMRGUID,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [256]u16,
    liDriverVersion: LARGE_INTEGER,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig_Value = Guid.initString("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce");
pub const IID_IVMRMonitorConfig = &IID_IVMRMonitorConfig_Value;
pub const IVMRMonitorConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: *const fn (
            self: *const IVMRMonitorConfig,
            p_g_u_i_d: ?*const VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: *const fn (
            self: *const IVMRMonitorConfig,
            p_g_u_i_d: ?*VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultMonitor: *const fn (
            self: *const IVMRMonitorConfig,
            p_g_u_i_d: ?*const VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMonitor: *const fn (
            self: *const IVMRMonitorConfig,
            p_g_u_i_d: ?*VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableMonitors: *const fn (
            self: *const IVMRMonitorConfig,
            p_info: ?*VMRMONITORINFO,
            dw_max_info_array_size: u32,
            pdw_num_devices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMonitor(self: *const T, p_g_u_i_d_: ?*const VMRGUID) HRESULT {
                return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), p_g_u_i_d_);
            }
            pub inline fn getMonitor(self: *const T, p_g_u_i_d_: ?*VMRGUID) HRESULT {
                return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), p_g_u_i_d_);
            }
            pub inline fn setDefaultMonitor(self: *const T, p_g_u_i_d_: ?*const VMRGUID) HRESULT {
                return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).SetDefaultMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), p_g_u_i_d_);
            }
            pub inline fn getDefaultMonitor(self: *const T, p_g_u_i_d_: ?*VMRGUID) HRESULT {
                return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetDefaultMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), p_g_u_i_d_);
            }
            pub inline fn getAvailableMonitors(self: *const T, p_info_: ?*VMRMONITORINFO, dw_max_info_array_size_: u32, pdw_num_devices_: ?*u32) HRESULT {
                return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetAvailableMonitors(@as(*const IVMRMonitorConfig, @ptrCast(self)), p_info_, dw_max_info_array_size_, pdw_num_devices_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRRenderPrefs = enum(i32) {
    RestrictToInitialMonitor = 0,
    ForceOffscreen = 1,
    ForceOverlays = 2,
    // AllowOverlays = 0, this enum value conflicts with RestrictToInitialMonitor
    // AllowOffscreen = 0, this enum value conflicts with RestrictToInitialMonitor
    DoNotRenderColorKeyAndBorder = 8,
    Reserved = 16,
    PreferAGPMemWhenMixing = 32,
    Mask = 63,
};
pub const RenderPrefs_RestrictToInitialMonitor = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_ForceOffscreen = VMRRenderPrefs.ForceOffscreen;
pub const RenderPrefs_ForceOverlays = VMRRenderPrefs.ForceOverlays;
pub const RenderPrefs_AllowOverlays = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_AllowOffscreen = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_DoNotRenderColorKeyAndBorder = VMRRenderPrefs.DoNotRenderColorKeyAndBorder;
pub const RenderPrefs_Reserved = VMRRenderPrefs.Reserved;
pub const RenderPrefs_PreferAGPMemWhenMixing = VMRRenderPrefs.PreferAGPMemWhenMixing;
pub const RenderPrefs_Mask = VMRRenderPrefs.Mask;

pub const VMRMode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMRMode_Windowed = VMRMode.Windowed;
pub const VMRMode_Windowless = VMRMode.Windowless;
pub const VMRMode_Renderless = VMRMode.Renderless;
pub const VMRMode_Mask = VMRMode.Mask;

pub const STREAMIF_CONSTANTS = enum(i32) {
    S = 16,
};
pub const MAX_NUMBER_OF_STREAMS = STREAMIF_CONSTANTS.S;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig_Value = Guid.initString("9e5530c5-7034-48b4-bb46-0b8a6efc8e36");
pub const IID_IVMRFilterConfig = &IID_IVMRFilterConfig_Value;
pub const IVMRFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: *const fn (
            self: *const IVMRFilterConfig,
            lp_v_m_r_img_compositor: ?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNumberOfStreams: *const fn (
            self: *const IVMRFilterConfig,
            dw_max_streams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: *const fn (
            self: *const IVMRFilterConfig,
            pdw_max_streams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingPrefs: *const fn (
            self: *const IVMRFilterConfig,
            dw_render_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: *const fn (
            self: *const IVMRFilterConfig,
            pdw_render_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingMode: *const fn (
            self: *const IVMRFilterConfig,
            mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingMode: *const fn (
            self: *const IVMRFilterConfig,
            p_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setImageCompositor(self: *const T, lp_v_m_r_img_compositor_: ?*IVMRImageCompositor) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetImageCompositor(@as(*const IVMRFilterConfig, @ptrCast(self)), lp_v_m_r_img_compositor_);
            }
            pub inline fn setNumberOfStreams(self: *const T, dw_max_streams_: u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetNumberOfStreams(@as(*const IVMRFilterConfig, @ptrCast(self)), dw_max_streams_);
            }
            pub inline fn getNumberOfStreams(self: *const T, pdw_max_streams_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IVMRFilterConfig, @ptrCast(self)), pdw_max_streams_);
            }
            pub inline fn setRenderingPrefs(self: *const T, dw_render_flags_: u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRFilterConfig, @ptrCast(self)), dw_render_flags_);
            }
            pub inline fn getRenderingPrefs(self: *const T, pdw_render_flags_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRFilterConfig, @ptrCast(self)), pdw_render_flags_);
            }
            pub inline fn setRenderingMode(self: *const T, mode_: u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetRenderingMode(@as(*const IVMRFilterConfig, @ptrCast(self)), mode_);
            }
            pub inline fn getRenderingMode(self: *const T, p_mode_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetRenderingMode(@as(*const IVMRFilterConfig, @ptrCast(self)), p_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl_Value = Guid.initString("ede80b5c-bad6-4623-b537-65586c9f8dfd");
pub const IID_IVMRAspectRatioControl = &IID_IVMRAspectRatioControl_Value;
pub const IVMRAspectRatioControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: *const fn (
            self: *const IVMRAspectRatioControl,
            lpdw_a_r_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: *const fn (
            self: *const IVMRAspectRatioControl,
            dw_a_r_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAspectRatioMode(self: *const T, lpdw_a_r_mode_: ?*u32) HRESULT {
                return @as(*const IVMRAspectRatioControl.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRAspectRatioControl, @ptrCast(self)), lpdw_a_r_mode_);
            }
            pub inline fn setAspectRatioMode(self: *const T, dw_a_r_mode_: u32) HRESULT {
                return @as(*const IVMRAspectRatioControl.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRAspectRatioControl, @ptrCast(self)), dw_a_r_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRDeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref_NextBest = VMRDeinterlacePrefs.NextBest;
pub const DeinterlacePref_BOB = VMRDeinterlacePrefs.BOB;
pub const DeinterlacePref_Weave = VMRDeinterlacePrefs.Weave;
pub const DeinterlacePref_Mask = VMRDeinterlacePrefs.Mask;

pub const VMRDeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech_Unknown = VMRDeinterlaceTech.Unknown;
pub const DeinterlaceTech_BOBLineReplicate = VMRDeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech_BOBVerticalStretch = VMRDeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech_MedianFiltering = VMRDeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech_EdgeFiltering = VMRDeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech_FieldAdaptive = VMRDeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech_PixelAdaptive = VMRDeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech_MotionVectorSteered = VMRDeinterlaceTech.MotionVectorSteered;

pub const VMRFrequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMRVideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SingleFieldPerSample: BOOL,
    dwFourCC: u32,
    InputSampleFreq: VMRFrequency,
    OutputFrameFreq: VMRFrequency,
};

pub const VMRDeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMRDeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl_Value = Guid.initString("bb057577-0db8-4e6a-87a7-1a8c9a505a0f");
pub const IID_IVMRDeinterlaceControl = &IID_IVMRDeinterlaceControl_Value;
pub const IVMRDeinterlaceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: *const fn (
            self: *const IVMRDeinterlaceControl,
            lp_video_description: ?*VMRVideoDesc,
            lpdw_num_deinterlace_modes: ?*u32,
            lp_deinterlace_modes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceModeCaps: *const fn (
            self: *const IVMRDeinterlaceControl,
            lp_deinterlace_mode: ?*Guid,
            lp_video_description: ?*VMRVideoDesc,
            lp_deinterlace_caps: ?*VMRDeinterlaceCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlacePrefs: *const fn (
            self: *const IVMRDeinterlaceControl,
            lpdw_deinterlace_prefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlacePrefs: *const fn (
            self: *const IVMRDeinterlaceControl,
            dw_deinterlace_prefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumberOfDeinterlaceModes(self: *const T, lp_video_description_: ?*VMRVideoDesc, lpdw_num_deinterlace_modes_: ?*u32, lp_deinterlace_modes_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetNumberOfDeinterlaceModes(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lp_video_description_, lpdw_num_deinterlace_modes_, lp_deinterlace_modes_);
            }
            pub inline fn getDeinterlaceModeCaps(self: *const T, lp_deinterlace_mode_: ?*Guid, lp_video_description_: ?*VMRVideoDesc, lp_deinterlace_caps_: ?*VMRDeinterlaceCaps) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlaceModeCaps(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lp_deinterlace_mode_, lp_video_description_, lp_deinterlace_caps_);
            }
            pub inline fn getDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
            pub inline fn setDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
            pub inline fn getDeinterlacePrefs(self: *const T, lpdw_deinterlace_prefs_: ?*u32) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lpdw_deinterlace_prefs_);
            }
            pub inline fn setDeinterlacePrefs(self: *const T, dw_deinterlace_prefs_: u32) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).SetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dw_deinterlace_prefs_);
            }
            pub inline fn getActualDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetActualDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRALPHABITMAP = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirectDrawSurface7,
    rSrc: RECT,
    rDest: NORMALIZEDRECT,
    fAlpha: f32,
    clrSrcKey: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap_Value = Guid.initString("1e673275-0257-40aa-af20-7c608d4a0428");
pub const IID_IVMRMixerBitmap = &IID_IVMRMixerBitmap_Value;
pub const IVMRMixerBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: *const fn (
            self: *const IVMRMixerBitmap,
            p_bmp_parms: ?*const VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAlphaBitmapParameters: *const fn (
            self: *const IVMRMixerBitmap,
            p_bmp_parms: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlphaBitmapParameters: *const fn (
            self: *const IVMRMixerBitmap,
            p_bmp_parms: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAlphaBitmap(self: *const T, p_bmp_parms_: ?*const VMRALPHABITMAP) HRESULT {
                return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).SetAlphaBitmap(@as(*const IVMRMixerBitmap, @ptrCast(self)), p_bmp_parms_);
            }
            pub inline fn updateAlphaBitmapParameters(self: *const T, p_bmp_parms_: ?*VMRALPHABITMAP) HRESULT {
                return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).UpdateAlphaBitmapParameters(@as(*const IVMRMixerBitmap, @ptrCast(self)), p_bmp_parms_);
            }
            pub inline fn getAlphaBitmapParameters(self: *const T, p_bmp_parms_: ?*VMRALPHABITMAP) HRESULT {
                return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).GetAlphaBitmapParameters(@as(*const IVMRMixerBitmap, @ptrCast(self)), p_bmp_parms_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMRVIDEOSTREAMINFO = extern struct {
    pddsVideoSurface: ?*IDirectDrawSurface7,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    ddClrKey: DDCOLORKEY,
    rNormal: NORMALIZEDRECT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor_Value = Guid.initString("7a4fb5af-479f-4074-bb40-ce6722e43c82");
pub const IID_IVMRImageCompositor = &IID_IVMRImageCompositor_Value;
pub const IVMRImageCompositor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionTarget: *const fn (
            self: *const IVMRImageCompositor,
            p_d3_d_device: ?*IUnknown,
            pdds_render_target: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TermCompositionTarget: *const fn (
            self: *const IVMRImageCompositor,
            p_d3_d_device: ?*IUnknown,
            pdds_render_target: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamMediaType: *const fn (
            self: *const IVMRImageCompositor,
            dw_strm_i_d: u32,
            pmt: ?*AM_MEDIA_TYPE,
            f_texture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompositeImage: *const fn (
            self: *const IVMRImageCompositor,
            p_d3_d_device: ?*IUnknown,
            pdds_render_target: ?*IDirectDrawSurface7,
            pmt_render_target: ?*AM_MEDIA_TYPE,
            rt_start: i64,
            rt_end: i64,
            dw_clr_bk_gnd: u32,
            p_video_stream_info: ?*VMRVIDEOSTREAMINFO,
            c_streams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initCompositionTarget(self: *const T, p_d3_d_device_: ?*IUnknown, pdds_render_target_: ?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).InitCompositionTarget(@as(*const IVMRImageCompositor, @ptrCast(self)), p_d3_d_device_, pdds_render_target_);
            }
            pub inline fn termCompositionTarget(self: *const T, p_d3_d_device_: ?*IUnknown, pdds_render_target_: ?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).TermCompositionTarget(@as(*const IVMRImageCompositor, @ptrCast(self)), p_d3_d_device_, pdds_render_target_);
            }
            pub inline fn setStreamMediaType(self: *const T, dw_strm_i_d_: u32, pmt_: ?*AM_MEDIA_TYPE, f_texture_: BOOL) HRESULT {
                return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).SetStreamMediaType(@as(*const IVMRImageCompositor, @ptrCast(self)), dw_strm_i_d_, pmt_, f_texture_);
            }
            pub inline fn compositeImage(self: *const T, p_d3_d_device_: ?*IUnknown, pdds_render_target_: ?*IDirectDrawSurface7, pmt_render_target_: ?*AM_MEDIA_TYPE, rt_start_: i64, rt_end_: i64, dw_clr_bk_gnd_: u32, p_video_stream_info_: ?*VMRVIDEOSTREAMINFO, c_streams_: u32) HRESULT {
                return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).CompositeImage(@as(*const IVMRImageCompositor, @ptrCast(self)), p_d3_d_device_, pdds_render_target_, pmt_render_target_, rt_start_, rt_end_, dw_clr_bk_gnd_, p_video_stream_info_, c_streams_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl_Value = Guid.initString("058d1f11-2a54-4bef-bd54-df706626b727");
pub const IID_IVMRVideoStreamControl = &IID_IVMRVideoStreamControl_Value;
pub const IVMRVideoStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColorKey: *const fn (
            self: *const IVMRVideoStreamControl,
            lp_clr_key: ?*DDCOLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: *const fn (
            self: *const IVMRVideoStreamControl,
            lp_clr_key: ?*DDCOLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamActiveState: *const fn (
            self: *const IVMRVideoStreamControl,
            f_active: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamActiveState: *const fn (
            self: *const IVMRVideoStreamControl,
            lpf_active: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setColorKey(self: *const T, lp_clr_key_: ?*DDCOLORKEY) HRESULT {
                return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lp_clr_key_);
            }
            pub inline fn getColorKey(self: *const T, lp_clr_key_: ?*DDCOLORKEY) HRESULT {
                return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lp_clr_key_);
            }
            pub inline fn setStreamActiveState(self: *const T, f_active_: BOOL) HRESULT {
                return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).SetStreamActiveState(@as(*const IVMRVideoStreamControl, @ptrCast(self)), f_active_);
            }
            pub inline fn getStreamActiveState(self: *const T, lpf_active_: ?*BOOL) HRESULT {
                return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).GetStreamActiveState(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lpf_active_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface_Value = Guid.initString("a9849bbe-9ec8-4263-b764-62730f0d15d0");
pub const IID_IVMRSurface = &IID_IVMRSurface_Value;
pub const IVMRSurface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: *const fn (
            self: *const IVMRSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockSurface: *const fn (
            self: *const IVMRSurface,
            lp_surface: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockSurface: *const fn (
            self: *const IVMRSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: *const fn (
            self: *const IVMRSurface,
            lplp_surface: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isSurfaceLocked(self: *const T) HRESULT {
                return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).IsSurfaceLocked(@as(*const IVMRSurface, @ptrCast(self)));
            }
            pub inline fn lockSurface(self: *const T, lp_surface_: ?*?*u8) HRESULT {
                return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).LockSurface(@as(*const IVMRSurface, @ptrCast(self)), lp_surface_);
            }
            pub inline fn unlockSurface(self: *const T) HRESULT {
                return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).UnlockSurface(@as(*const IVMRSurface, @ptrCast(self)));
            }
            pub inline fn getSurface(self: *const T, lplp_surface_: ?*?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurface, @ptrCast(self)), lplp_surface_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig_Value = Guid.initString("9f3a1c85-8555-49ba-935f-be5b5b29d178");
pub const IID_IVMRImagePresenterConfig = &IID_IVMRImagePresenterConfig_Value;
pub const IVMRImagePresenterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: *const fn (
            self: *const IVMRImagePresenterConfig,
            dw_render_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: *const fn (
            self: *const IVMRImagePresenterConfig,
            dw_render_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setRenderingPrefs(self: *const T, dw_render_flags_: u32) HRESULT {
                return @as(*const IVMRImagePresenterConfig.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRImagePresenterConfig, @ptrCast(self)), dw_render_flags_);
            }
            pub inline fn getRenderingPrefs(self: *const T, dw_render_flags_: ?*u32) HRESULT {
                return @as(*const IVMRImagePresenterConfig.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRImagePresenterConfig, @ptrCast(self)), dw_render_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterExclModeConfig_Value = Guid.initString("e6f7ce40-4673-44f1-8f77-5499d68cb4ea");
pub const IID_IVMRImagePresenterExclModeConfig = &IID_IVMRImagePresenterExclModeConfig_Value;
pub const IVMRImagePresenterExclModeConfig = extern struct {
    pub const VTable = extern struct {
        base: IVMRImagePresenterConfig.VTable,
        SetXlcModeDDObjAndPrimarySurface: *const fn (
            self: *const IVMRImagePresenterExclModeConfig,
            lp_d_d_obj: ?*IDirectDraw7,
            lp_primary_surf: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXlcModeDDObjAndPrimarySurface: *const fn (
            self: *const IVMRImagePresenterExclModeConfig,
            lp_d_d_obj: ?*?*IDirectDraw7,
            lp_primary_surf: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVMRImagePresenterConfig.MethodMixin(T);
            pub inline fn setXlcModeDDObjAndPrimarySurface(self: *const T, lp_d_d_obj_: ?*IDirectDraw7, lp_primary_surf_: ?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRImagePresenterExclModeConfig.VTable, @ptrCast(self.vtable)).SetXlcModeDDObjAndPrimarySurface(@as(*const IVMRImagePresenterExclModeConfig, @ptrCast(self)), lp_d_d_obj_, lp_primary_surf_);
            }
            pub inline fn getXlcModeDDObjAndPrimarySurface(self: *const T, lp_d_d_obj_: ?*?*IDirectDraw7, lp_primary_surf_: ?*?*IDirectDrawSurface7) HRESULT {
                return @as(*const IVMRImagePresenterExclModeConfig.VTable, @ptrCast(self.vtable)).GetXlcModeDDObjAndPrimarySurface(@as(*const IVMRImagePresenterExclModeConfig, @ptrCast(self)), lp_d_d_obj_, lp_primary_surf_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVPManager_Value = Guid.initString("aac18c18-e186-46d2-825d-a1f8dc8e395a");
pub const IID_IVPManager = &IID_IVPManager_Value;
pub const IVPManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVideoPortIndex: *const fn (
            self: *const IVPManager,
            dw_video_port_index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPortIndex: *const fn (
            self: *const IVPManager,
            pdw_video_port_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setVideoPortIndex(self: *const T, dw_video_port_index_: u32) HRESULT {
                return @as(*const IVPManager.VTable, @ptrCast(self.vtable)).SetVideoPortIndex(@as(*const IVPManager, @ptrCast(self)), dw_video_port_index_);
            }
            pub inline fn getVideoPortIndex(self: *const T, pdw_video_port_index_: ?*u32) HRESULT {
                return @as(*const IVPManager.VTable, @ptrCast(self.vtable)).GetVideoPortIndex(@as(*const IVPManager, @ptrCast(self)), pdw_video_port_index_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_DOMAIN = enum(i32) {
    FirstPlay = 1,
    VideoManagerMenu = 2,
    VideoTitleSetMenu = 3,
    Title = 4,
    Stop = 5,
};
pub const DVD_DOMAIN_FirstPlay = DVD_DOMAIN.FirstPlay;
pub const DVD_DOMAIN_VideoManagerMenu = DVD_DOMAIN.VideoManagerMenu;
pub const DVD_DOMAIN_VideoTitleSetMenu = DVD_DOMAIN.VideoTitleSetMenu;
pub const DVD_DOMAIN_Title = DVD_DOMAIN.Title;
pub const DVD_DOMAIN_Stop = DVD_DOMAIN.Stop;

pub const DVD_MENU_ID = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const DVD_MENU_Title = DVD_MENU_ID.Title;
pub const DVD_MENU_Root = DVD_MENU_ID.Root;
pub const DVD_MENU_Subpicture = DVD_MENU_ID.Subpicture;
pub const DVD_MENU_Audio = DVD_MENU_ID.Audio;
pub const DVD_MENU_Angle = DVD_MENU_ID.Angle;
pub const DVD_MENU_Chapter = DVD_MENU_ID.Chapter;

pub const DVD_DISC_SIDE = enum(i32) {
    A = 1,
    B = 2,
};
pub const DVD_SIDE_A = DVD_DISC_SIDE.A;
pub const DVD_SIDE_B = DVD_DISC_SIDE.B;

pub const DVD_PREFERRED_DISPLAY_MODE = enum(i32) {
    CONTENT_DEFAULT = 0,
    @"16x9" = 1,
    @"4x3_PANSCAN_PREFERRED" = 2,
    @"4x3_LETTERBOX_PREFERRED" = 3,
};
pub const DISPLAY_CONTENT_DEFAULT = DVD_PREFERRED_DISPLAY_MODE.CONTENT_DEFAULT;
pub const DISPLAY_16x9 = DVD_PREFERRED_DISPLAY_MODE.@"16x9";
pub const DISPLAY_4x3_PANSCAN_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_PANSCAN_PREFERRED";
pub const DISPLAY_4x3_LETTERBOX_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_LETTERBOX_PREFERRED";

pub const DVD_ATR = extern struct {
    ulCAT: u32,
    pbATRI: [768]u8,
};

pub const DVD_FRAMERATE = enum(i32) {
    @"25" = 1,
    @"30NonDrop" = 3,
};
pub const DVD_FPS_25 = DVD_FRAMERATE.@"25";
pub const DVD_FPS_30NonDrop = DVD_FRAMERATE.@"30NonDrop";

pub const DVD_TIMECODE = extern struct {
    _bitfield: u32,
};

pub const DVD_NavCmdType = enum(i32) {
    Pre = 1,
    Post = 2,
    Cell = 3,
    Button = 4,
};
pub const DVD_NavCmdType_Pre = DVD_NavCmdType.Pre;
pub const DVD_NavCmdType_Post = DVD_NavCmdType.Post;
pub const DVD_NavCmdType_Cell = DVD_NavCmdType.Cell;
pub const DVD_NavCmdType_Button = DVD_NavCmdType.Button;

pub const DVD_TIMECODE_FLAGS = enum(i32) {
    @"25fps" = 1,
    @"30fps" = 2,
    DropFrame = 4,
    Interpolated = 8,
};
pub const DVD_TC_FLAG_25fps = DVD_TIMECODE_FLAGS.@"25fps";
pub const DVD_TC_FLAG_30fps = DVD_TIMECODE_FLAGS.@"30fps";
pub const DVD_TC_FLAG_DropFrame = DVD_TIMECODE_FLAGS.DropFrame;
pub const DVD_TC_FLAG_Interpolated = DVD_TIMECODE_FLAGS.Interpolated;

pub const DVD_HMSF_TIMECODE = extern struct {
    bHours: u8,
    bMinutes: u8,
    bSeconds: u8,
    bFrames: u8,
};

pub const DVD_PLAYBACK_LOCATION2 = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: DVD_HMSF_TIMECODE,
    TimeCodeFlags: u32,
};

pub const DVD_PLAYBACK_LOCATION = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: u32,
};

pub const VALID_UOP_FLAG = enum(i32) {
    Play_Title_Or_AtTime = 1,
    Play_Chapter = 2,
    Play_Title = 4,
    Stop = 8,
    ReturnFromSubMenu = 16,
    Play_Chapter_Or_AtTime = 32,
    PlayPrev_Or_Replay_Chapter = 64,
    PlayNext_Chapter = 128,
    Play_Forwards = 256,
    Play_Backwards = 512,
    ShowMenu_Title = 1024,
    ShowMenu_Root = 2048,
    ShowMenu_SubPic = 4096,
    ShowMenu_Audio = 8192,
    ShowMenu_Angle = 16384,
    ShowMenu_Chapter = 32768,
    Resume = 65536,
    Select_Or_Activate_Button = 131072,
    Still_Off = 262144,
    Pause_On = 524288,
    Select_Audio_Stream = 1048576,
    Select_SubPic_Stream = 2097152,
    Select_Angle = 4194304,
    Select_Karaoke_Audio_Presentation_Mode = 8388608,
    Select_Video_Mode_Preference = 16777216,
};
pub const UOP_FLAG_Play_Title_Or_AtTime = VALID_UOP_FLAG.Play_Title_Or_AtTime;
pub const UOP_FLAG_Play_Chapter = VALID_UOP_FLAG.Play_Chapter;
pub const UOP_FLAG_Play_Title = VALID_UOP_FLAG.Play_Title;
pub const UOP_FLAG_Stop = VALID_UOP_FLAG.Stop;
pub const UOP_FLAG_ReturnFromSubMenu = VALID_UOP_FLAG.ReturnFromSubMenu;
pub const UOP_FLAG_Play_Chapter_Or_AtTime = VALID_UOP_FLAG.Play_Chapter_Or_AtTime;
pub const UOP_FLAG_PlayPrev_Or_Replay_Chapter = VALID_UOP_FLAG.PlayPrev_Or_Replay_Chapter;
pub const UOP_FLAG_PlayNext_Chapter = VALID_UOP_FLAG.PlayNext_Chapter;
pub const UOP_FLAG_Play_Forwards = VALID_UOP_FLAG.Play_Forwards;
pub const UOP_FLAG_Play_Backwards = VALID_UOP_FLAG.Play_Backwards;
pub const UOP_FLAG_ShowMenu_Title = VALID_UOP_FLAG.ShowMenu_Title;
pub const UOP_FLAG_ShowMenu_Root = VALID_UOP_FLAG.ShowMenu_Root;
pub const UOP_FLAG_ShowMenu_SubPic = VALID_UOP_FLAG.ShowMenu_SubPic;
pub const UOP_FLAG_ShowMenu_Audio = VALID_UOP_FLAG.ShowMenu_Audio;
pub const UOP_FLAG_ShowMenu_Angle = VALID_UOP_FLAG.ShowMenu_Angle;
pub const UOP_FLAG_ShowMenu_Chapter = VALID_UOP_FLAG.ShowMenu_Chapter;
pub const UOP_FLAG_Resume = VALID_UOP_FLAG.Resume;
pub const UOP_FLAG_Select_Or_Activate_Button = VALID_UOP_FLAG.Select_Or_Activate_Button;
pub const UOP_FLAG_Still_Off = VALID_UOP_FLAG.Still_Off;
pub const UOP_FLAG_Pause_On = VALID_UOP_FLAG.Pause_On;
pub const UOP_FLAG_Select_Audio_Stream = VALID_UOP_FLAG.Select_Audio_Stream;
pub const UOP_FLAG_Select_SubPic_Stream = VALID_UOP_FLAG.Select_SubPic_Stream;
pub const UOP_FLAG_Select_Angle = VALID_UOP_FLAG.Select_Angle;
pub const UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode = VALID_UOP_FLAG.Select_Karaoke_Audio_Presentation_Mode;
pub const UOP_FLAG_Select_Video_Mode_Preference = VALID_UOP_FLAG.Select_Video_Mode_Preference;

pub const DVD_CMD_FLAGS = enum(i32) {
    None = 0,
    Flush = 1,
    SendEvents = 2,
    Block = 4,
    StartWhenRendered = 8,
    EndAfterRendered = 16,
};
pub const DVD_CMD_FLAG_None = DVD_CMD_FLAGS.None;
pub const DVD_CMD_FLAG_Flush = DVD_CMD_FLAGS.Flush;
pub const DVD_CMD_FLAG_SendEvents = DVD_CMD_FLAGS.SendEvents;
pub const DVD_CMD_FLAG_Block = DVD_CMD_FLAGS.Block;
pub const DVD_CMD_FLAG_StartWhenRendered = DVD_CMD_FLAGS.StartWhenRendered;
pub const DVD_CMD_FLAG_EndAfterRendered = DVD_CMD_FLAGS.EndAfterRendered;

pub const DVD_OPTION_FLAG = enum(i32) {
    ResetOnStop = 1,
    NotifyParentalLevelChange = 2,
    HMSF_TimeCodeEvents = 3,
    AudioDuringFFwdRew = 4,
    EnableNonblockingAPIs = 5,
    CacheSizeInMB = 6,
    EnablePortableBookmarks = 7,
    EnableExtendedCopyProtectErrors = 8,
    NotifyPositionChange = 9,
    IncreaseOutputControl = 10,
    EnableStreaming = 11,
    EnableESOutput = 12,
    EnableTitleLength = 13,
    DisableStillThrottle = 14,
    EnableLoggingEvents = 15,
    MaxReadBurstInKB = 16,
    ReadBurstPeriodInMS = 17,
    RestartDisc = 18,
    EnableCC = 19,
};
pub const DVD_ResetOnStop = DVD_OPTION_FLAG.ResetOnStop;
pub const DVD_NotifyParentalLevelChange = DVD_OPTION_FLAG.NotifyParentalLevelChange;
pub const DVD_HMSF_TimeCodeEvents = DVD_OPTION_FLAG.HMSF_TimeCodeEvents;
pub const DVD_AudioDuringFFwdRew = DVD_OPTION_FLAG.AudioDuringFFwdRew;
pub const DVD_EnableNonblockingAPIs = DVD_OPTION_FLAG.EnableNonblockingAPIs;
pub const DVD_CacheSizeInMB = DVD_OPTION_FLAG.CacheSizeInMB;
pub const DVD_EnablePortableBookmarks = DVD_OPTION_FLAG.EnablePortableBookmarks;
pub const DVD_EnableExtendedCopyProtectErrors = DVD_OPTION_FLAG.EnableExtendedCopyProtectErrors;
pub const DVD_NotifyPositionChange = DVD_OPTION_FLAG.NotifyPositionChange;
pub const DVD_IncreaseOutputControl = DVD_OPTION_FLAG.IncreaseOutputControl;
pub const DVD_EnableStreaming = DVD_OPTION_FLAG.EnableStreaming;
pub const DVD_EnableESOutput = DVD_OPTION_FLAG.EnableESOutput;
pub const DVD_EnableTitleLength = DVD_OPTION_FLAG.EnableTitleLength;
pub const DVD_DisableStillThrottle = DVD_OPTION_FLAG.DisableStillThrottle;
pub const DVD_EnableLoggingEvents = DVD_OPTION_FLAG.EnableLoggingEvents;
pub const DVD_MaxReadBurstInKB = DVD_OPTION_FLAG.MaxReadBurstInKB;
pub const DVD_ReadBurstPeriodInMS = DVD_OPTION_FLAG.ReadBurstPeriodInMS;
pub const DVD_RestartDisc = DVD_OPTION_FLAG.RestartDisc;
pub const DVD_EnableCC = DVD_OPTION_FLAG.EnableCC;

pub const DVD_RELATIVE_BUTTON = enum(i32) {
    Upper = 1,
    Lower = 2,
    Left = 3,
    Right = 4,
};
pub const DVD_Relative_Upper = DVD_RELATIVE_BUTTON.Upper;
pub const DVD_Relative_Lower = DVD_RELATIVE_BUTTON.Lower;
pub const DVD_Relative_Left = DVD_RELATIVE_BUTTON.Left;
pub const DVD_Relative_Right = DVD_RELATIVE_BUTTON.Right;

pub const DVD_PARENTAL_LEVEL = enum(i32) {
    @"8" = 32768,
    @"7" = 16384,
    @"6" = 8192,
    @"5" = 4096,
    @"4" = 2048,
    @"3" = 1024,
    @"2" = 512,
    @"1" = 256,
};
pub const DVD_PARENTAL_LEVEL_8 = DVD_PARENTAL_LEVEL.@"8";
pub const DVD_PARENTAL_LEVEL_7 = DVD_PARENTAL_LEVEL.@"7";
pub const DVD_PARENTAL_LEVEL_6 = DVD_PARENTAL_LEVEL.@"6";
pub const DVD_PARENTAL_LEVEL_5 = DVD_PARENTAL_LEVEL.@"5";
pub const DVD_PARENTAL_LEVEL_4 = DVD_PARENTAL_LEVEL.@"4";
pub const DVD_PARENTAL_LEVEL_3 = DVD_PARENTAL_LEVEL.@"3";
pub const DVD_PARENTAL_LEVEL_2 = DVD_PARENTAL_LEVEL.@"2";
pub const DVD_PARENTAL_LEVEL_1 = DVD_PARENTAL_LEVEL.@"1";

pub const DVD_AUDIO_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Captions = 1,
    VisuallyImpaired = 2,
    DirectorComments1 = 3,
    DirectorComments2 = 4,
};
pub const DVD_AUD_EXT_NotSpecified = DVD_AUDIO_LANG_EXT.NotSpecified;
pub const DVD_AUD_EXT_Captions = DVD_AUDIO_LANG_EXT.Captions;
pub const DVD_AUD_EXT_VisuallyImpaired = DVD_AUDIO_LANG_EXT.VisuallyImpaired;
pub const DVD_AUD_EXT_DirectorComments1 = DVD_AUDIO_LANG_EXT.DirectorComments1;
pub const DVD_AUD_EXT_DirectorComments2 = DVD_AUDIO_LANG_EXT.DirectorComments2;

pub const DVD_SUBPICTURE_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const DVD_SP_EXT_NotSpecified = DVD_SUBPICTURE_LANG_EXT.NotSpecified;
pub const DVD_SP_EXT_Caption_Normal = DVD_SUBPICTURE_LANG_EXT.Caption_Normal;
pub const DVD_SP_EXT_Caption_Big = DVD_SUBPICTURE_LANG_EXT.Caption_Big;
pub const DVD_SP_EXT_Caption_Children = DVD_SUBPICTURE_LANG_EXT.Caption_Children;
pub const DVD_SP_EXT_CC_Normal = DVD_SUBPICTURE_LANG_EXT.CC_Normal;
pub const DVD_SP_EXT_CC_Big = DVD_SUBPICTURE_LANG_EXT.CC_Big;
pub const DVD_SP_EXT_CC_Children = DVD_SUBPICTURE_LANG_EXT.CC_Children;
pub const DVD_SP_EXT_Forced = DVD_SUBPICTURE_LANG_EXT.Forced;
pub const DVD_SP_EXT_DirectorComments_Normal = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Normal;
pub const DVD_SP_EXT_DirectorComments_Big = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Big;
pub const DVD_SP_EXT_DirectorComments_Children = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Children;

pub const DVD_AUDIO_APPMODE = enum(i32) {
    None = 0,
    Karaoke = 1,
    Surround = 2,
    Other = 3,
};
pub const DVD_AudioMode_None = DVD_AUDIO_APPMODE.None;
pub const DVD_AudioMode_Karaoke = DVD_AUDIO_APPMODE.Karaoke;
pub const DVD_AudioMode_Surround = DVD_AUDIO_APPMODE.Surround;
pub const DVD_AudioMode_Other = DVD_AUDIO_APPMODE.Other;

pub const DVD_AUDIO_FORMAT = enum(i32) {
    AC3 = 0,
    MPEG1 = 1,
    MPEG1_DRC = 2,
    MPEG2 = 3,
    MPEG2_DRC = 4,
    LPCM = 5,
    DTS = 6,
    SDDS = 7,
    Other = 8,
};
pub const DVD_AudioFormat_AC3 = DVD_AUDIO_FORMAT.AC3;
pub const DVD_AudioFormat_MPEG1 = DVD_AUDIO_FORMAT.MPEG1;
pub const DVD_AudioFormat_MPEG1_DRC = DVD_AUDIO_FORMAT.MPEG1_DRC;
pub const DVD_AudioFormat_MPEG2 = DVD_AUDIO_FORMAT.MPEG2;
pub const DVD_AudioFormat_MPEG2_DRC = DVD_AUDIO_FORMAT.MPEG2_DRC;
pub const DVD_AudioFormat_LPCM = DVD_AUDIO_FORMAT.LPCM;
pub const DVD_AudioFormat_DTS = DVD_AUDIO_FORMAT.DTS;
pub const DVD_AudioFormat_SDDS = DVD_AUDIO_FORMAT.SDDS;
pub const DVD_AudioFormat_Other = DVD_AUDIO_FORMAT.Other;

pub const DVD_KARAOKE_DOWNMIX = enum(i32) {
    @"0to0" = 1,
    @"1to0" = 2,
    @"2to0" = 4,
    @"3to0" = 8,
    @"4to0" = 16,
    Lto0 = 32,
    Rto0 = 64,
    @"0to1" = 256,
    @"1to1" = 512,
    @"2to1" = 1024,
    @"3to1" = 2048,
    @"4to1" = 4096,
    Lto1 = 8192,
    Rto1 = 16384,
};
pub const DVD_Mix_0to0 = DVD_KARAOKE_DOWNMIX.@"0to0";
pub const DVD_Mix_1to0 = DVD_KARAOKE_DOWNMIX.@"1to0";
pub const DVD_Mix_2to0 = DVD_KARAOKE_DOWNMIX.@"2to0";
pub const DVD_Mix_3to0 = DVD_KARAOKE_DOWNMIX.@"3to0";
pub const DVD_Mix_4to0 = DVD_KARAOKE_DOWNMIX.@"4to0";
pub const DVD_Mix_Lto0 = DVD_KARAOKE_DOWNMIX.Lto0;
pub const DVD_Mix_Rto0 = DVD_KARAOKE_DOWNMIX.Rto0;
pub const DVD_Mix_0to1 = DVD_KARAOKE_DOWNMIX.@"0to1";
pub const DVD_Mix_1to1 = DVD_KARAOKE_DOWNMIX.@"1to1";
pub const DVD_Mix_2to1 = DVD_KARAOKE_DOWNMIX.@"2to1";
pub const DVD_Mix_3to1 = DVD_KARAOKE_DOWNMIX.@"3to1";
pub const DVD_Mix_4to1 = DVD_KARAOKE_DOWNMIX.@"4to1";
pub const DVD_Mix_Lto1 = DVD_KARAOKE_DOWNMIX.Lto1;
pub const DVD_Mix_Rto1 = DVD_KARAOKE_DOWNMIX.Rto1;

pub const DVD_AudioAttributes = extern struct {
    AppMode: DVD_AUDIO_APPMODE,
    AppModeData: u8,
    AudioFormat: DVD_AUDIO_FORMAT,
    Language: u32,
    LanguageExtension: DVD_AUDIO_LANG_EXT,
    fHasMultichannelInfo: BOOL,
    dwFrequency: u32,
    bQuantization: u8,
    bNumberOfChannels: u8,
    dwReserved: [2]u32,
};

pub const DVD_MUA_MixingInfo = extern struct {
    fMixTo0: BOOL,
    fMixTo1: BOOL,
    fMix0InPhase: BOOL,
    fMix1InPhase: BOOL,
    dwSpeakerPosition: u32,
};

pub const DVD_MUA_Coeff = extern struct {
    log2_alpha: f64,
    log2_beta: f64,
};

pub const DVD_MultichannelAudioAttributes = extern struct {
    Info: [8]DVD_MUA_MixingInfo,
    Coeff: [8]DVD_MUA_Coeff,
};

pub const DVD_KARAOKE_CONTENTS = enum(i32) {
    GuideVocal1 = 1,
    GuideVocal2 = 2,
    GuideMelody1 = 4,
    GuideMelody2 = 8,
    GuideMelodyA = 16,
    GuideMelodyB = 32,
    SoundEffectA = 64,
    SoundEffectB = 128,
};
pub const DVD_Karaoke_GuideVocal1 = DVD_KARAOKE_CONTENTS.GuideVocal1;
pub const DVD_Karaoke_GuideVocal2 = DVD_KARAOKE_CONTENTS.GuideVocal2;
pub const DVD_Karaoke_GuideMelody1 = DVD_KARAOKE_CONTENTS.GuideMelody1;
pub const DVD_Karaoke_GuideMelody2 = DVD_KARAOKE_CONTENTS.GuideMelody2;
pub const DVD_Karaoke_GuideMelodyA = DVD_KARAOKE_CONTENTS.GuideMelodyA;
pub const DVD_Karaoke_GuideMelodyB = DVD_KARAOKE_CONTENTS.GuideMelodyB;
pub const DVD_Karaoke_SoundEffectA = DVD_KARAOKE_CONTENTS.SoundEffectA;
pub const DVD_Karaoke_SoundEffectB = DVD_KARAOKE_CONTENTS.SoundEffectB;

pub const DVD_KARAOKE_ASSIGNMENT = enum(i32) {
    reserved0 = 0,
    reserved1 = 1,
    LR = 2,
    LRM = 3,
    LR1 = 4,
    LRM1 = 5,
    LR12 = 6,
    LRM12 = 7,
};
pub const DVD_Assignment_reserved0 = DVD_KARAOKE_ASSIGNMENT.reserved0;
pub const DVD_Assignment_reserved1 = DVD_KARAOKE_ASSIGNMENT.reserved1;
pub const DVD_Assignment_LR = DVD_KARAOKE_ASSIGNMENT.LR;
pub const DVD_Assignment_LRM = DVD_KARAOKE_ASSIGNMENT.LRM;
pub const DVD_Assignment_LR1 = DVD_KARAOKE_ASSIGNMENT.LR1;
pub const DVD_Assignment_LRM1 = DVD_KARAOKE_ASSIGNMENT.LRM1;
pub const DVD_Assignment_LR12 = DVD_KARAOKE_ASSIGNMENT.LR12;
pub const DVD_Assignment_LRM12 = DVD_KARAOKE_ASSIGNMENT.LRM12;

pub const DVD_KaraokeAttributes = extern struct {
    bVersion: u8,
    fMasterOfCeremoniesInGuideVocal1: BOOL,
    fDuet: BOOL,
    ChannelAssignment: DVD_KARAOKE_ASSIGNMENT,
    wChannelContents: [8]u16,
};

pub const DVD_VIDEO_COMPRESSION = enum(i32) {
    Other = 0,
    MPEG1 = 1,
    MPEG2 = 2,
};
pub const DVD_VideoCompression_Other = DVD_VIDEO_COMPRESSION.Other;
pub const DVD_VideoCompression_MPEG1 = DVD_VIDEO_COMPRESSION.MPEG1;
pub const DVD_VideoCompression_MPEG2 = DVD_VIDEO_COMPRESSION.MPEG2;

pub const DVD_VideoAttributes = extern struct {
    fPanscanPermitted: BOOL,
    fLetterboxPermitted: BOOL,
    ulAspectX: u32,
    ulAspectY: u32,
    ulFrameRate: u32,
    ulFrameHeight: u32,
    Compression: DVD_VIDEO_COMPRESSION,
    fLine21Field1InGOP: BOOL,
    fLine21Field2InGOP: BOOL,
    ulSourceResolutionX: u32,
    ulSourceResolutionY: u32,
    fIsSourceLetterboxed: BOOL,
    fIsFilmMode: BOOL,
};

pub const DVD_SUBPICTURE_TYPE = enum(i32) {
    NotSpecified = 0,
    Language = 1,
    Other = 2,
};
pub const DVD_SPType_NotSpecified = DVD_SUBPICTURE_TYPE.NotSpecified;
pub const DVD_SPType_Language = DVD_SUBPICTURE_TYPE.Language;
pub const DVD_SPType_Other = DVD_SUBPICTURE_TYPE.Other;

pub const DVD_SUBPICTURE_CODING = enum(i32) {
    RunLength = 0,
    Extended = 1,
    Other = 2,
};
pub const DVD_SPCoding_RunLength = DVD_SUBPICTURE_CODING.RunLength;
pub const DVD_SPCoding_Extended = DVD_SUBPICTURE_CODING.Extended;
pub const DVD_SPCoding_Other = DVD_SUBPICTURE_CODING.Other;

pub const DVD_SubpictureAttributes = extern struct {
    Type: DVD_SUBPICTURE_TYPE,
    CodingMode: DVD_SUBPICTURE_CODING,
    Language: u32,
    LanguageExtension: DVD_SUBPICTURE_LANG_EXT,
};

pub const DVD_TITLE_APPMODE = enum(i32) {
    Not_Specified = 0,
    Karaoke = 1,
    Other = 3,
};
pub const DVD_AppMode_Not_Specified = DVD_TITLE_APPMODE.Not_Specified;
pub const DVD_AppMode_Karaoke = DVD_TITLE_APPMODE.Karaoke;
pub const DVD_AppMode_Other = DVD_TITLE_APPMODE.Other;

pub const DVD_TitleAttributes = extern struct {
    Anonymous: extern union {
        AppMode: DVD_TITLE_APPMODE,
        TitleLength: DVD_HMSF_TIMECODE,
    },
    VideoAttributes: DVD_VideoAttributes,
    ulNumberOfAudioStreams: u32,
    AudioAttributes: [8]DVD_AudioAttributes,
    MultichannelAudioAttributes: [8]DVD_MultichannelAudioAttributes,
    ulNumberOfSubpictureStreams: u32,
    SubpictureAttributes: [32]DVD_SubpictureAttributes,
};

pub const DVD_MenuAttributes = extern struct {
    fCompatibleRegion: [8]BOOL,
    VideoAttributes: DVD_VideoAttributes,
    fAudioPresent: BOOL,
    AudioAttributes: DVD_AudioAttributes,
    fSubpicturePresent: BOOL,
    SubpictureAttributes: DVD_SubpictureAttributes,
};

const IID_IDvdControl_Value = Guid.initString("a70efe61-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdControl = &IID_IDvdControl_Value;
pub const IDvdControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TitlePlay: *const fn (
            self: *const IDvdControl,
            ul_title: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterPlay: *const fn (
            self: *const IDvdControl,
            ul_title: u32,
            ul_chapter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimePlay: *const fn (
            self: *const IDvdControl,
            ul_title: u32,
            bcd_time: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopForResume: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoUp: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeSearch: *const fn (
            self: *const IDvdControl,
            bcd_time: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterSearch: *const fn (
            self: *const IDvdControl,
            ul_chapter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrevPGSearch: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TopPGSearch: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextPGSearch: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForwardScan: *const fn (
            self: *const IDvdControl,
            dw_speed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BackwardScan: *const fn (
            self: *const IDvdControl,
            dw_speed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MenuCall: *const fn (
            self: *const IDvdControl,
            menu_i_d: DVD_MENU_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpperButtonSelect: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LowerButtonSelect: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LeftButtonSelect: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RightButtonSelect: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ButtonActivate: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ButtonSelectAndActivate: *const fn (
            self: *const IDvdControl,
            ul_button: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOn: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOff: *const fn (
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MenuLanguageSelect: *const fn (
            self: *const IDvdControl,
            language: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AudioStreamChange: *const fn (
            self: *const IDvdControl,
            ul_audio: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubpictureStreamChange: *const fn (
            self: *const IDvdControl,
            ul_sub_picture: u32,
            b_display: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AngleChange: *const fn (
            self: *const IDvdControl,
            ul_angle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParentalLevelSelect: *const fn (
            self: *const IDvdControl,
            ul_parental_level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParentalCountrySelect: *const fn (
            self: *const IDvdControl,
            w_country: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KaraokeAudioPresentationModeChange: *const fn (
            self: *const IDvdControl,
            ul_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoModePreferrence: *const fn (
            self: *const IDvdControl,
            ul_preferred_display_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRoot: *const fn (
            self: *const IDvdControl,
            psz_path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseActivate: *const fn (
            self: *const IDvdControl,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseSelect: *const fn (
            self: *const IDvdControl,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterPlayAutoStop: *const fn (
            self: *const IDvdControl,
            ul_title: u32,
            ul_chapter: u32,
            ul_chapters_to_play: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn titlePlay(self: *const T, ul_title_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TitlePlay(@as(*const IDvdControl, @ptrCast(self)), ul_title_);
            }
            pub inline fn chapterPlay(self: *const T, ul_title_: u32, ul_chapter_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterPlay(@as(*const IDvdControl, @ptrCast(self)), ul_title_, ul_chapter_);
            }
            pub inline fn timePlay(self: *const T, ul_title_: u32, bcd_time_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TimePlay(@as(*const IDvdControl, @ptrCast(self)), ul_title_, bcd_time_);
            }
            pub inline fn stopForResume(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).StopForResume(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn goUp(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).GoUp(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn timeSearch(self: *const T, bcd_time_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TimeSearch(@as(*const IDvdControl, @ptrCast(self)), bcd_time_);
            }
            pub inline fn chapterSearch(self: *const T, ul_chapter_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterSearch(@as(*const IDvdControl, @ptrCast(self)), ul_chapter_);
            }
            pub inline fn prevPGSearch(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PrevPGSearch(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn topPGSearch(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TopPGSearch(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn nextPGSearch(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).NextPGSearch(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn forwardScan(self: *const T, dw_speed_: f64) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ForwardScan(@as(*const IDvdControl, @ptrCast(self)), dw_speed_);
            }
            pub inline fn backwardScan(self: *const T, dw_speed_: f64) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).BackwardScan(@as(*const IDvdControl, @ptrCast(self)), dw_speed_);
            }
            pub inline fn menuCall(self: *const T, menu_i_d_: DVD_MENU_ID) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MenuCall(@as(*const IDvdControl, @ptrCast(self)), menu_i_d_);
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).Resume(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn upperButtonSelect(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).UpperButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn lowerButtonSelect(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).LowerButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn leftButtonSelect(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).LeftButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn rightButtonSelect(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).RightButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn buttonActivate(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ButtonActivate(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn buttonSelectAndActivate(self: *const T, ul_button_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ButtonSelectAndActivate(@as(*const IDvdControl, @ptrCast(self)), ul_button_);
            }
            pub inline fn stillOff(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn pauseOn(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PauseOn(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn pauseOff(self: *const T) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PauseOff(@as(*const IDvdControl, @ptrCast(self)));
            }
            pub inline fn menuLanguageSelect(self: *const T, language_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MenuLanguageSelect(@as(*const IDvdControl, @ptrCast(self)), language_);
            }
            pub inline fn audioStreamChange(self: *const T, ul_audio_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).AudioStreamChange(@as(*const IDvdControl, @ptrCast(self)), ul_audio_);
            }
            pub inline fn subpictureStreamChange(self: *const T, ul_sub_picture_: u32, b_display_: BOOL) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).SubpictureStreamChange(@as(*const IDvdControl, @ptrCast(self)), ul_sub_picture_, b_display_);
            }
            pub inline fn angleChange(self: *const T, ul_angle_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).AngleChange(@as(*const IDvdControl, @ptrCast(self)), ul_angle_);
            }
            pub inline fn parentalLevelSelect(self: *const T, ul_parental_level_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ParentalLevelSelect(@as(*const IDvdControl, @ptrCast(self)), ul_parental_level_);
            }
            pub inline fn parentalCountrySelect(self: *const T, w_country_: u16) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ParentalCountrySelect(@as(*const IDvdControl, @ptrCast(self)), w_country_);
            }
            pub inline fn karaokeAudioPresentationModeChange(self: *const T, ul_mode_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).KaraokeAudioPresentationModeChange(@as(*const IDvdControl, @ptrCast(self)), ul_mode_);
            }
            pub inline fn videoModePreferrence(self: *const T, ul_preferred_display_mode_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).VideoModePreferrence(@as(*const IDvdControl, @ptrCast(self)), ul_preferred_display_mode_);
            }
            pub inline fn setRoot(self: *const T, psz_path_: ?[*:0]const u16) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).SetRoot(@as(*const IDvdControl, @ptrCast(self)), psz_path_);
            }
            pub inline fn mouseActivate(self: *const T, point_: POINT) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MouseActivate(@as(*const IDvdControl, @ptrCast(self)), point_);
            }
            pub inline fn mouseSelect(self: *const T, point_: POINT) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MouseSelect(@as(*const IDvdControl, @ptrCast(self)), point_);
            }
            pub inline fn chapterPlayAutoStop(self: *const T, ul_title_: u32, ul_chapter_: u32, ul_chapters_to_play_: u32) HRESULT {
                return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterPlayAutoStop(@as(*const IDvdControl, @ptrCast(self)), ul_title_, ul_chapter_, ul_chapters_to_play_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvdInfo_Value = Guid.initString("a70efe60-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdInfo = &IID_IDvdInfo_Value;
pub const IDvdInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: *const fn (
            self: *const IDvdInfo,
            p_domain: ?*DVD_DOMAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLocation: *const fn (
            self: *const IDvdInfo,
            p_location: ?*DVD_PLAYBACK_LOCATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalTitleTime: *const fn (
            self: *const IDvdInfo,
            pul_total_time: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentButton: *const fn (
            self: *const IDvdInfo,
            pul_buttons_available: ?*u32,
            pul_current_button: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAngle: *const fn (
            self: *const IDvdInfo,
            pul_angles_available: ?*u32,
            pul_current_angle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudio: *const fn (
            self: *const IDvdInfo,
            pul_streams_available: ?*u32,
            pul_current_stream: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpicture: *const fn (
            self: *const IDvdInfo,
            pul_streams_available: ?*u32,
            pul_current_stream: ?*u32,
            p_is_disabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentUOPS: *const fn (
            self: *const IDvdInfo,
            p_u_o_p: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllSPRMs: *const fn (
            self: *const IDvdInfo,
            p_register_array: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllGPRMs: *const fn (
            self: *const IDvdInfo,
            p_register_array: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioLanguage: *const fn (
            self: *const IDvdInfo,
            ul_stream: u32,
            p_language: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureLanguage: *const fn (
            self: *const IDvdInfo,
            ul_stream: u32,
            p_language: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleAttributes: *const fn (
            self: *const IDvdInfo,
            ul_title: u32,
            p_a_t_r: ?*DVD_ATR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVMGAttributes: *const fn (
            self: *const IDvdInfo,
            p_a_t_r: ?*DVD_ATR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVideoAttributes: *const fn (
            self: *const IDvdInfo,
            p_a_t_r: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudioAttributes: *const fn (
            self: *const IDvdInfo,
            p_a_t_r: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpictureAttributes: *const fn (
            self: *const IDvdInfo,
            p_a_t_r: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVolumeInfo: *const fn (
            self: *const IDvdInfo,
            pul_num_of_vol: ?*u32,
            pul_this_vol_num: ?*u32,
            p_side: ?*DVD_DISC_SIDE,
            pul_num_of_titles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextInfo: *const fn (
            self: *const IDvdInfo,
            // TODO: what to do with BytesParamIndex 1?
            p_text_manager: ?*u8,
            ul_buf_size: u32,
            pul_actual_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlayerParentalLevel: *const fn (
            self: *const IDvdInfo,
            pul_parental_level: ?*u32,
            pul_country_code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfChapters: *const fn (
            self: *const IDvdInfo,
            ul_title: u32,
            pul_number_of_chapters: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleParentalLevels: *const fn (
            self: *const IDvdInfo,
            ul_title: u32,
            pul_parental_levels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRoot: *const fn (
            self: *const IDvdInfo,
            p_root: [*:0]u8,
            ul_buf_size: u32,
            pul_actual_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrentDomain(self: *const T, p_domain_: ?*DVD_DOMAIN) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentDomain(@as(*const IDvdInfo, @ptrCast(self)), p_domain_);
            }
            pub inline fn getCurrentLocation(self: *const T, p_location_: ?*DVD_PLAYBACK_LOCATION) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentLocation(@as(*const IDvdInfo, @ptrCast(self)), p_location_);
            }
            pub inline fn getTotalTitleTime(self: *const T, pul_total_time_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTotalTitleTime(@as(*const IDvdInfo, @ptrCast(self)), pul_total_time_);
            }
            pub inline fn getCurrentButton(self: *const T, pul_buttons_available_: ?*u32, pul_current_button_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentButton(@as(*const IDvdInfo, @ptrCast(self)), pul_buttons_available_, pul_current_button_);
            }
            pub inline fn getCurrentAngle(self: *const T, pul_angles_available_: ?*u32, pul_current_angle_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAngle(@as(*const IDvdInfo, @ptrCast(self)), pul_angles_available_, pul_current_angle_);
            }
            pub inline fn getCurrentAudio(self: *const T, pul_streams_available_: ?*u32, pul_current_stream_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAudio(@as(*const IDvdInfo, @ptrCast(self)), pul_streams_available_, pul_current_stream_);
            }
            pub inline fn getCurrentSubpicture(self: *const T, pul_streams_available_: ?*u32, pul_current_stream_: ?*u32, p_is_disabled_: ?*BOOL) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentSubpicture(@as(*const IDvdInfo, @ptrCast(self)), pul_streams_available_, pul_current_stream_, p_is_disabled_);
            }
            pub inline fn getCurrentUOPS(self: *const T, p_u_o_p_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentUOPS(@as(*const IDvdInfo, @ptrCast(self)), p_u_o_p_);
            }
            pub inline fn getAllSPRMs(self: *const T, p_register_array_: ?*?*u16) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAllSPRMs(@as(*const IDvdInfo, @ptrCast(self)), p_register_array_);
            }
            pub inline fn getAllGPRMs(self: *const T, p_register_array_: ?*?*u16) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAllGPRMs(@as(*const IDvdInfo, @ptrCast(self)), p_register_array_);
            }
            pub inline fn getAudioLanguage(self: *const T, ul_stream_: u32, p_language_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAudioLanguage(@as(*const IDvdInfo, @ptrCast(self)), ul_stream_, p_language_);
            }
            pub inline fn getSubpictureLanguage(self: *const T, ul_stream_: u32, p_language_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetSubpictureLanguage(@as(*const IDvdInfo, @ptrCast(self)), ul_stream_, p_language_);
            }
            pub inline fn getTitleAttributes(self: *const T, ul_title_: u32, p_a_t_r_: ?*DVD_ATR) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTitleAttributes(@as(*const IDvdInfo, @ptrCast(self)), ul_title_, p_a_t_r_);
            }
            pub inline fn getVMGAttributes(self: *const T, p_a_t_r_: ?*DVD_ATR) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetVMGAttributes(@as(*const IDvdInfo, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getCurrentVideoAttributes(self: *const T, p_a_t_r_: ?*?*u8) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentVideoAttributes(@as(*const IDvdInfo, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getCurrentAudioAttributes(self: *const T, p_a_t_r_: ?*?*u8) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAudioAttributes(@as(*const IDvdInfo, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getCurrentSubpictureAttributes(self: *const T, p_a_t_r_: ?*?*u8) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentSubpictureAttributes(@as(*const IDvdInfo, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getCurrentVolumeInfo(self: *const T, pul_num_of_vol_: ?*u32, pul_this_vol_num_: ?*u32, p_side_: ?*DVD_DISC_SIDE, pul_num_of_titles_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentVolumeInfo(@as(*const IDvdInfo, @ptrCast(self)), pul_num_of_vol_, pul_this_vol_num_, p_side_, pul_num_of_titles_);
            }
            pub inline fn getDVDTextInfo(self: *const T, p_text_manager_: ?*u8, ul_buf_size_: u32, pul_actual_size_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetDVDTextInfo(@as(*const IDvdInfo, @ptrCast(self)), p_text_manager_, ul_buf_size_, pul_actual_size_);
            }
            pub inline fn getPlayerParentalLevel(self: *const T, pul_parental_level_: ?*u32, pul_country_code_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetPlayerParentalLevel(@as(*const IDvdInfo, @ptrCast(self)), pul_parental_level_, pul_country_code_);
            }
            pub inline fn getNumberOfChapters(self: *const T, ul_title_: u32, pul_number_of_chapters_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetNumberOfChapters(@as(*const IDvdInfo, @ptrCast(self)), ul_title_, pul_number_of_chapters_);
            }
            pub inline fn getTitleParentalLevels(self: *const T, ul_title_: u32, pul_parental_levels_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTitleParentalLevels(@as(*const IDvdInfo, @ptrCast(self)), ul_title_, pul_parental_levels_);
            }
            pub inline fn getRoot(self: *const T, p_root_: [*:0]u8, ul_buf_size_: u32, pul_actual_size_: ?*u32) HRESULT {
                return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetRoot(@as(*const IDvdInfo, @ptrCast(self)), p_root_, ul_buf_size_, pul_actual_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdCmd_Value = Guid.initString("5a4a97e4-94ee-4a55-9751-74b5643aa27d");
pub const IID_IDvdCmd = &IID_IDvdCmd_Value;
pub const IDvdCmd = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForStart: *const fn (
            self: *const IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEnd: *const fn (
            self: *const IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn waitForStart(self: *const T) HRESULT {
                return @as(*const IDvdCmd.VTable, @ptrCast(self.vtable)).WaitForStart(@as(*const IDvdCmd, @ptrCast(self)));
            }
            pub inline fn waitForEnd(self: *const T) HRESULT {
                return @as(*const IDvdCmd.VTable, @ptrCast(self.vtable)).WaitForEnd(@as(*const IDvdCmd, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdState_Value = Guid.initString("86303d6d-1c4a-4087-ab42-f711167048ef");
pub const IID_IDvdState = &IID_IDvdState_Value;
pub const IDvdState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiscID: *const fn (
            self: *const IDvdState,
            pull_unique_i_d: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalLevel: *const fn (
            self: *const IDvdState,
            pul_parental_level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDiscID(self: *const T, pull_unique_i_d_: ?*u64) HRESULT {
                return @as(*const IDvdState.VTable, @ptrCast(self.vtable)).GetDiscID(@as(*const IDvdState, @ptrCast(self)), pull_unique_i_d_);
            }
            pub inline fn getParentalLevel(self: *const T, pul_parental_level_: ?*u32) HRESULT {
                return @as(*const IDvdState.VTable, @ptrCast(self.vtable)).GetParentalLevel(@as(*const IDvdState, @ptrCast(self)), pul_parental_level_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdControl2_Value = Guid.initString("33bc7430-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdControl2 = &IID_IDvdControl2_Value;
pub const IDvdControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PlayTitle: *const fn (
            self: *const IDvdControl2,
            ul_title: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: *const fn (
            self: *const IDvdControl2,
            ul_title: u32,
            ul_chapter: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: *const fn (
            self: *const IDvdControl2,
            ul_title: u32,
            p_start_time: ?*DVD_HMSF_TIMECODE,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: *const fn (
            self: *const IDvdControl2,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: *const fn (
            self: *const IDvdControl2,
            p_time: ?*DVD_HMSF_TIMECODE,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: *const fn (
            self: *const IDvdControl2,
            ul_chapter: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: *const fn (
            self: *const IDvdControl2,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: *const fn (
            self: *const IDvdControl2,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: *const fn (
            self: *const IDvdControl2,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayForwards: *const fn (
            self: *const IDvdControl2,
            d_speed: f64,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayBackwards: *const fn (
            self: *const IDvdControl2,
            d_speed: f64,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: *const fn (
            self: *const IDvdControl2,
            menu_i_d: DVD_MENU_ID,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IDvdControl2,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRelativeButton: *const fn (
            self: *const IDvdControl2,
            button_dir: DVD_RELATIVE_BUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateButton: *const fn (
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectButton: *const fn (
            self: *const IDvdControl2,
            ul_button: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndActivateButton: *const fn (
            self: *const IDvdControl2,
            ul_button: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: *const fn (
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IDvdControl2,
            b_state: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAudioStream: *const fn (
            self: *const IDvdControl2,
            ul_audio: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectSubpictureStream: *const fn (
            self: *const IDvdControl2,
            ul_sub_picture: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubpictureState: *const fn (
            self: *const IDvdControl2,
            b_state: BOOL,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAngle: *const fn (
            self: *const IDvdControl2,
            ul_angle: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalLevel: *const fn (
            self: *const IDvdControl2,
            ul_parental_level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalCountry: *const fn (
            self: *const IDvdControl2,
            b_country: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectKaraokeAudioPresentationMode: *const fn (
            self: *const IDvdControl2,
            ul_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectVideoModePreference: *const fn (
            self: *const IDvdControl2,
            ul_preferred_display_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDVDDirectory: *const fn (
            self: *const IDvdControl2,
            pszw_path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAtPosition: *const fn (
            self: *const IDvdControl2,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAtPosition: *const fn (
            self: *const IDvdControl2,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChaptersAutoStop: *const fn (
            self: *const IDvdControl2,
            ul_title: u32,
            ul_chapter: u32,
            ul_chapters_to_play: u32,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcceptParentalLevelChange: *const fn (
            self: *const IDvdControl2,
            b_accept: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: *const fn (
            self: *const IDvdControl2,
            flag: DVD_OPTION_FLAG,
            f_state: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: *const fn (
            self: *const IDvdControl2,
            p_state: ?*IDvdState,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPeriodInTitleAutoStop: *const fn (
            self: *const IDvdControl2,
            ul_title: u32,
            p_start_time: ?*DVD_HMSF_TIMECODE,
            p_end_time: ?*DVD_HMSF_TIMECODE,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGPRM: *const fn (
            self: *const IDvdControl2,
            ul_index: u32,
            w_value: u16,
            dw_flags: u32,
            pp_cmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultMenuLanguage: *const fn (
            self: *const IDvdControl2,
            language: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultAudioLanguage: *const fn (
            self: *const IDvdControl2,
            language: u32,
            audio_extension: DVD_AUDIO_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultSubpictureLanguage: *const fn (
            self: *const IDvdControl2,
            language: u32,
            subpicture_extension: DVD_SUBPICTURE_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn playTitle(self: *const T, ul_title_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IDvdControl2, @ptrCast(self)), ul_title_, dw_flags_, pp_cmd_);
            }
            pub inline fn playChapterInTitle(self: *const T, ul_title_: u32, ul_chapter_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IDvdControl2, @ptrCast(self)), ul_title_, ul_chapter_, dw_flags_, pp_cmd_);
            }
            pub inline fn playAtTimeInTitle(self: *const T, ul_title_: u32, p_start_time_: ?*DVD_HMSF_TIMECODE, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IDvdControl2, @ptrCast(self)), ul_title_, p_start_time_, dw_flags_, pp_cmd_);
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Stop(@as(*const IDvdControl2, @ptrCast(self)));
            }
            pub inline fn returnFromSubmenu(self: *const T, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IDvdControl2, @ptrCast(self)), dw_flags_, pp_cmd_);
            }
            pub inline fn playAtTime(self: *const T, p_time_: ?*DVD_HMSF_TIMECODE, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IDvdControl2, @ptrCast(self)), p_time_, dw_flags_, pp_cmd_);
            }
            pub inline fn playChapter(self: *const T, ul_chapter_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IDvdControl2, @ptrCast(self)), ul_chapter_, dw_flags_, pp_cmd_);
            }
            pub inline fn playPrevChapter(self: *const T, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IDvdControl2, @ptrCast(self)), dw_flags_, pp_cmd_);
            }
            pub inline fn replayChapter(self: *const T, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IDvdControl2, @ptrCast(self)), dw_flags_, pp_cmd_);
            }
            pub inline fn playNextChapter(self: *const T, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IDvdControl2, @ptrCast(self)), dw_flags_, pp_cmd_);
            }
            pub inline fn playForwards(self: *const T, d_speed_: f64, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayForwards(@as(*const IDvdControl2, @ptrCast(self)), d_speed_, dw_flags_, pp_cmd_);
            }
            pub inline fn playBackwards(self: *const T, d_speed_: f64, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayBackwards(@as(*const IDvdControl2, @ptrCast(self)), d_speed_, dw_flags_, pp_cmd_);
            }
            pub inline fn showMenu(self: *const T, menu_i_d_: DVD_MENU_ID, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IDvdControl2, @ptrCast(self)), menu_i_d_, dw_flags_, pp_cmd_);
            }
            pub inline fn @"resume"(self: *const T, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Resume(@as(*const IDvdControl2, @ptrCast(self)), dw_flags_, pp_cmd_);
            }
            pub inline fn selectRelativeButton(self: *const T, button_dir_: DVD_RELATIVE_BUTTON) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectRelativeButton(@as(*const IDvdControl2, @ptrCast(self)), button_dir_);
            }
            pub inline fn activateButton(self: *const T) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ActivateButton(@as(*const IDvdControl2, @ptrCast(self)));
            }
            pub inline fn selectButton(self: *const T, ul_button_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectButton(@as(*const IDvdControl2, @ptrCast(self)), ul_button_);
            }
            pub inline fn selectAndActivateButton(self: *const T, ul_button_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAndActivateButton(@as(*const IDvdControl2, @ptrCast(self)), ul_button_);
            }
            pub inline fn stillOff(self: *const T) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IDvdControl2, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T, b_state_: BOOL) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Pause(@as(*const IDvdControl2, @ptrCast(self)), b_state_);
            }
            pub inline fn selectAudioStream(self: *const T, ul_audio_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAudioStream(@as(*const IDvdControl2, @ptrCast(self)), ul_audio_, dw_flags_, pp_cmd_);
            }
            pub inline fn selectSubpictureStream(self: *const T, ul_sub_picture_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectSubpictureStream(@as(*const IDvdControl2, @ptrCast(self)), ul_sub_picture_, dw_flags_, pp_cmd_);
            }
            pub inline fn setSubpictureState(self: *const T, b_state_: BOOL, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetSubpictureState(@as(*const IDvdControl2, @ptrCast(self)), b_state_, dw_flags_, pp_cmd_);
            }
            pub inline fn selectAngle(self: *const T, ul_angle_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAngle(@as(*const IDvdControl2, @ptrCast(self)), ul_angle_, dw_flags_, pp_cmd_);
            }
            pub inline fn selectParentalLevel(self: *const T, ul_parental_level_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectParentalLevel(@as(*const IDvdControl2, @ptrCast(self)), ul_parental_level_);
            }
            pub inline fn selectParentalCountry(self: *const T, b_country_: ?*u8) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectParentalCountry(@as(*const IDvdControl2, @ptrCast(self)), b_country_);
            }
            pub inline fn selectKaraokeAudioPresentationMode(self: *const T, ul_mode_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectKaraokeAudioPresentationMode(@as(*const IDvdControl2, @ptrCast(self)), ul_mode_);
            }
            pub inline fn selectVideoModePreference(self: *const T, ul_preferred_display_mode_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectVideoModePreference(@as(*const IDvdControl2, @ptrCast(self)), ul_preferred_display_mode_);
            }
            pub inline fn setDVDDirectory(self: *const T, pszw_path_: ?[*:0]const u16) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetDVDDirectory(@as(*const IDvdControl2, @ptrCast(self)), pszw_path_);
            }
            pub inline fn activateAtPosition(self: *const T, point_: POINT) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ActivateAtPosition(@as(*const IDvdControl2, @ptrCast(self)), point_);
            }
            pub inline fn selectAtPosition(self: *const T, point_: POINT) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAtPosition(@as(*const IDvdControl2, @ptrCast(self)), point_);
            }
            pub inline fn playChaptersAutoStop(self: *const T, ul_title_: u32, ul_chapter_: u32, ul_chapters_to_play_: u32, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChaptersAutoStop(@as(*const IDvdControl2, @ptrCast(self)), ul_title_, ul_chapter_, ul_chapters_to_play_, dw_flags_, pp_cmd_);
            }
            pub inline fn acceptParentalLevelChange(self: *const T, b_accept_: BOOL) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).AcceptParentalLevelChange(@as(*const IDvdControl2, @ptrCast(self)), b_accept_);
            }
            pub inline fn setOption(self: *const T, flag_: DVD_OPTION_FLAG, f_state_: BOOL) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IDvdControl2, @ptrCast(self)), flag_, f_state_);
            }
            pub inline fn setState(self: *const T, p_state_: ?*IDvdState, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetState(@as(*const IDvdControl2, @ptrCast(self)), p_state_, dw_flags_, pp_cmd_);
            }
            pub inline fn playPeriodInTitleAutoStop(self: *const T, ul_title_: u32, p_start_time_: ?*DVD_HMSF_TIMECODE, p_end_time_: ?*DVD_HMSF_TIMECODE, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayPeriodInTitleAutoStop(@as(*const IDvdControl2, @ptrCast(self)), ul_title_, p_start_time_, p_end_time_, dw_flags_, pp_cmd_);
            }
            pub inline fn setGPRM(self: *const T, ul_index_: u32, w_value_: u16, dw_flags_: u32, pp_cmd_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetGPRM(@as(*const IDvdControl2, @ptrCast(self)), ul_index_, w_value_, dw_flags_, pp_cmd_);
            }
            pub inline fn selectDefaultMenuLanguage(self: *const T, language_: u32) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultMenuLanguage(@as(*const IDvdControl2, @ptrCast(self)), language_);
            }
            pub inline fn selectDefaultAudioLanguage(self: *const T, language_: u32, audio_extension_: DVD_AUDIO_LANG_EXT) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultAudioLanguage(@as(*const IDvdControl2, @ptrCast(self)), language_, audio_extension_);
            }
            pub inline fn selectDefaultSubpictureLanguage(self: *const T, language_: u32, subpicture_extension_: DVD_SUBPICTURE_LANG_EXT) HRESULT {
                return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultSubpictureLanguage(@as(*const IDvdControl2, @ptrCast(self)), language_, subpicture_extension_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_TextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const DVD_Struct_Volume = DVD_TextStringType.Struct_Volume;
pub const DVD_Struct_Title = DVD_TextStringType.Struct_Title;
pub const DVD_Struct_ParentalID = DVD_TextStringType.Struct_ParentalID;
pub const DVD_Struct_PartOfTitle = DVD_TextStringType.Struct_PartOfTitle;
pub const DVD_Struct_Cell = DVD_TextStringType.Struct_Cell;
pub const DVD_Stream_Audio = DVD_TextStringType.Stream_Audio;
pub const DVD_Stream_Subpicture = DVD_TextStringType.Stream_Subpicture;
pub const DVD_Stream_Angle = DVD_TextStringType.Stream_Angle;
pub const DVD_Channel_Audio = DVD_TextStringType.Channel_Audio;
pub const DVD_General_Name = DVD_TextStringType.General_Name;
pub const DVD_General_Comments = DVD_TextStringType.General_Comments;
pub const DVD_Title_Series = DVD_TextStringType.Title_Series;
pub const DVD_Title_Movie = DVD_TextStringType.Title_Movie;
pub const DVD_Title_Video = DVD_TextStringType.Title_Video;
pub const DVD_Title_Album = DVD_TextStringType.Title_Album;
pub const DVD_Title_Song = DVD_TextStringType.Title_Song;
pub const DVD_Title_Other = DVD_TextStringType.Title_Other;
pub const DVD_Title_Sub_Series = DVD_TextStringType.Title_Sub_Series;
pub const DVD_Title_Sub_Movie = DVD_TextStringType.Title_Sub_Movie;
pub const DVD_Title_Sub_Video = DVD_TextStringType.Title_Sub_Video;
pub const DVD_Title_Sub_Album = DVD_TextStringType.Title_Sub_Album;
pub const DVD_Title_Sub_Song = DVD_TextStringType.Title_Sub_Song;
pub const DVD_Title_Sub_Other = DVD_TextStringType.Title_Sub_Other;
pub const DVD_Title_Orig_Series = DVD_TextStringType.Title_Orig_Series;
pub const DVD_Title_Orig_Movie = DVD_TextStringType.Title_Orig_Movie;
pub const DVD_Title_Orig_Video = DVD_TextStringType.Title_Orig_Video;
pub const DVD_Title_Orig_Album = DVD_TextStringType.Title_Orig_Album;
pub const DVD_Title_Orig_Song = DVD_TextStringType.Title_Orig_Song;
pub const DVD_Title_Orig_Other = DVD_TextStringType.Title_Orig_Other;
pub const DVD_Other_Scene = DVD_TextStringType.Other_Scene;
pub const DVD_Other_Cut = DVD_TextStringType.Other_Cut;
pub const DVD_Other_Take = DVD_TextStringType.Other_Take;

pub const DVD_TextCharSet = enum(i32) {
    Unicode = 0,
    ISO646 = 1,
    JIS_Roman_Kanji = 2,
    ISO8859_1 = 3,
    ShiftJIS_Kanji_Roman_Katakana = 4,
};
pub const DVD_CharSet_Unicode = DVD_TextCharSet.Unicode;
pub const DVD_CharSet_ISO646 = DVD_TextCharSet.ISO646;
pub const DVD_CharSet_JIS_Roman_Kanji = DVD_TextCharSet.JIS_Roman_Kanji;
pub const DVD_CharSet_ISO8859_1 = DVD_TextCharSet.ISO8859_1;
pub const DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana = DVD_TextCharSet.ShiftJIS_Kanji_Roman_Katakana;

pub const DVD_DECODER_CAPS = extern struct {
    dwSize: u32,
    dwAudioCaps: u32,
    dFwdMaxRateVideo: f64,
    dFwdMaxRateAudio: f64,
    dFwdMaxRateSP: f64,
    dBwdMaxRateVideo: f64,
    dBwdMaxRateAudio: f64,
    dBwdMaxRateSP: f64,
    dwRes1: u32,
    dwRes2: u32,
    dwRes3: u32,
    dwRes4: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdInfo2_Value = Guid.initString("34151510-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdInfo2 = &IID_IDvdInfo2_Value;
pub const IDvdInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: *const fn (
            self: *const IDvdInfo2,
            p_domain: ?*DVD_DOMAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLocation: *const fn (
            self: *const IDvdInfo2,
            p_location: ?*DVD_PLAYBACK_LOCATION2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalTitleTime: *const fn (
            self: *const IDvdInfo2,
            p_total_time: ?*DVD_HMSF_TIMECODE,
            ul_time_code_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentButton: *const fn (
            self: *const IDvdInfo2,
            pul_buttons_available: ?*u32,
            pul_current_button: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAngle: *const fn (
            self: *const IDvdInfo2,
            pul_angles_available: ?*u32,
            pul_current_angle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudio: *const fn (
            self: *const IDvdInfo2,
            pul_streams_available: ?*u32,
            pul_current_stream: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpicture: *const fn (
            self: *const IDvdInfo2,
            pul_streams_available: ?*u32,
            pul_current_stream: ?*u32,
            pb_is_disabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentUOPS: *const fn (
            self: *const IDvdInfo2,
            pul_u_o_ps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllSPRMs: *const fn (
            self: *const IDvdInfo2,
            p_register_array: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllGPRMs: *const fn (
            self: *const IDvdInfo2,
            p_register_array: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioLanguage: *const fn (
            self: *const IDvdInfo2,
            ul_stream: u32,
            p_language: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureLanguage: *const fn (
            self: *const IDvdInfo2,
            ul_stream: u32,
            p_language: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleAttributes: *const fn (
            self: *const IDvdInfo2,
            ul_title: u32,
            p_menu: ?*DVD_MenuAttributes,
            p_title: ?*DVD_TitleAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVMGAttributes: *const fn (
            self: *const IDvdInfo2,
            p_a_t_r: ?*DVD_MenuAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVideoAttributes: *const fn (
            self: *const IDvdInfo2,
            p_a_t_r: ?*DVD_VideoAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioAttributes: *const fn (
            self: *const IDvdInfo2,
            ul_stream: u32,
            p_a_t_r: ?*DVD_AudioAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKaraokeAttributes: *const fn (
            self: *const IDvdInfo2,
            ul_stream: u32,
            p_attributes: ?*DVD_KaraokeAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureAttributes: *const fn (
            self: *const IDvdInfo2,
            ul_stream: u32,
            p_a_t_r: ?*DVD_SubpictureAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDVolumeInfo: *const fn (
            self: *const IDvdInfo2,
            pul_num_of_volumes: ?*u32,
            pul_volume: ?*u32,
            p_side: ?*DVD_DISC_SIDE,
            pul_num_of_titles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextNumberOfLanguages: *const fn (
            self: *const IDvdInfo2,
            pul_num_of_langs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextLanguageInfo: *const fn (
            self: *const IDvdInfo2,
            ul_lang_index: u32,
            pul_num_of_strings: ?*u32,
            p_lang_code: ?*u32,
            pb_character_set: ?*DVD_TextCharSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextStringAsNative: *const fn (
            self: *const IDvdInfo2,
            ul_lang_index: u32,
            ul_string_index: u32,
            pb_buffer: ?*u8,
            ul_max_buffer_size: u32,
            pul_actual_size: ?*u32,
            p_type: ?*DVD_TextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextStringAsUnicode: *const fn (
            self: *const IDvdInfo2,
            ul_lang_index: u32,
            ul_string_index: u32,
            pchw_buffer: ?PWSTR,
            ul_max_buffer_size: u32,
            pul_actual_size: ?*u32,
            p_type: ?*DVD_TextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlayerParentalLevel: *const fn (
            self: *const IDvdInfo2,
            pul_parental_level: ?*u32,
            pb_country_code: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfChapters: *const fn (
            self: *const IDvdInfo2,
            ul_title: u32,
            pul_num_of_chapters: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleParentalLevels: *const fn (
            self: *const IDvdInfo2,
            ul_title: u32,
            pul_parental_levels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDDirectory: *const fn (
            self: *const IDvdInfo2,
            pszw_path: [*:0]u16,
            ul_max_size: u32,
            pul_actual_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioStreamEnabled: *const fn (
            self: *const IDvdInfo2,
            ul_stream_num: u32,
            pb_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiscID: *const fn (
            self: *const IDvdInfo2,
            pszw_path: ?[*:0]const u16,
            pull_disc_i_d: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IDvdInfo2,
            p_state_data: ?*?*IDvdState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMenuLanguages: *const fn (
            self: *const IDvdInfo2,
            p_languages: ?*u32,
            ul_max_languages: u32,
            pul_actual_languages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetButtonAtPosition: *const fn (
            self: *const IDvdInfo2,
            point: POINT,
            pul_button_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCmdFromEvent: *const fn (
            self: *const IDvdInfo2,
            l_param1: isize,
            p_cmd_obj: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMenuLanguage: *const fn (
            self: *const IDvdInfo2,
            p_language: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAudioLanguage: *const fn (
            self: *const IDvdInfo2,
            p_language: ?*u32,
            p_audio_extension: ?*DVD_AUDIO_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSubpictureLanguage: *const fn (
            self: *const IDvdInfo2,
            p_language: ?*u32,
            p_subpicture_extension: ?*DVD_SUBPICTURE_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDecoderCaps: *const fn (
            self: *const IDvdInfo2,
            p_caps: ?*DVD_DECODER_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetButtonRect: *const fn (
            self: *const IDvdInfo2,
            ul_button: u32,
            p_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubpictureStreamEnabled: *const fn (
            self: *const IDvdInfo2,
            ul_stream_num: u32,
            pb_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrentDomain(self: *const T, p_domain_: ?*DVD_DOMAIN) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentDomain(@as(*const IDvdInfo2, @ptrCast(self)), p_domain_);
            }
            pub inline fn getCurrentLocation(self: *const T, p_location_: ?*DVD_PLAYBACK_LOCATION2) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentLocation(@as(*const IDvdInfo2, @ptrCast(self)), p_location_);
            }
            pub inline fn getTotalTitleTime(self: *const T, p_total_time_: ?*DVD_HMSF_TIMECODE, ul_time_code_flags_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTotalTitleTime(@as(*const IDvdInfo2, @ptrCast(self)), p_total_time_, ul_time_code_flags_);
            }
            pub inline fn getCurrentButton(self: *const T, pul_buttons_available_: ?*u32, pul_current_button_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentButton(@as(*const IDvdInfo2, @ptrCast(self)), pul_buttons_available_, pul_current_button_);
            }
            pub inline fn getCurrentAngle(self: *const T, pul_angles_available_: ?*u32, pul_current_angle_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentAngle(@as(*const IDvdInfo2, @ptrCast(self)), pul_angles_available_, pul_current_angle_);
            }
            pub inline fn getCurrentAudio(self: *const T, pul_streams_available_: ?*u32, pul_current_stream_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentAudio(@as(*const IDvdInfo2, @ptrCast(self)), pul_streams_available_, pul_current_stream_);
            }
            pub inline fn getCurrentSubpicture(self: *const T, pul_streams_available_: ?*u32, pul_current_stream_: ?*u32, pb_is_disabled_: ?*BOOL) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentSubpicture(@as(*const IDvdInfo2, @ptrCast(self)), pul_streams_available_, pul_current_stream_, pb_is_disabled_);
            }
            pub inline fn getCurrentUOPS(self: *const T, pul_u_o_ps_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentUOPS(@as(*const IDvdInfo2, @ptrCast(self)), pul_u_o_ps_);
            }
            pub inline fn getAllSPRMs(self: *const T, p_register_array_: ?*?*u16) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAllSPRMs(@as(*const IDvdInfo2, @ptrCast(self)), p_register_array_);
            }
            pub inline fn getAllGPRMs(self: *const T, p_register_array_: ?*?*u16) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAllGPRMs(@as(*const IDvdInfo2, @ptrCast(self)), p_register_array_);
            }
            pub inline fn getAudioLanguage(self: *const T, ul_stream_: u32, p_language_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAudioLanguage(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_, p_language_);
            }
            pub inline fn getSubpictureLanguage(self: *const T, ul_stream_: u32, p_language_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetSubpictureLanguage(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_, p_language_);
            }
            pub inline fn getTitleAttributes(self: *const T, ul_title_: u32, p_menu_: ?*DVD_MenuAttributes, p_title_: ?*DVD_TitleAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTitleAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ul_title_, p_menu_, p_title_);
            }
            pub inline fn getVMGAttributes(self: *const T, p_a_t_r_: ?*DVD_MenuAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetVMGAttributes(@as(*const IDvdInfo2, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getCurrentVideoAttributes(self: *const T, p_a_t_r_: ?*DVD_VideoAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentVideoAttributes(@as(*const IDvdInfo2, @ptrCast(self)), p_a_t_r_);
            }
            pub inline fn getAudioAttributes(self: *const T, ul_stream_: u32, p_a_t_r_: ?*DVD_AudioAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAudioAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_, p_a_t_r_);
            }
            pub inline fn getKaraokeAttributes(self: *const T, ul_stream_: u32, p_attributes_: ?*DVD_KaraokeAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetKaraokeAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_, p_attributes_);
            }
            pub inline fn getSubpictureAttributes(self: *const T, ul_stream_: u32, p_a_t_r_: ?*DVD_SubpictureAttributes) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetSubpictureAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_, p_a_t_r_);
            }
            pub inline fn getDVDVolumeInfo(self: *const T, pul_num_of_volumes_: ?*u32, pul_volume_: ?*u32, p_side_: ?*DVD_DISC_SIDE, pul_num_of_titles_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDVolumeInfo(@as(*const IDvdInfo2, @ptrCast(self)), pul_num_of_volumes_, pul_volume_, p_side_, pul_num_of_titles_);
            }
            pub inline fn getDVDTextNumberOfLanguages(self: *const T, pul_num_of_langs_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextNumberOfLanguages(@as(*const IDvdInfo2, @ptrCast(self)), pul_num_of_langs_);
            }
            pub inline fn getDVDTextLanguageInfo(self: *const T, ul_lang_index_: u32, pul_num_of_strings_: ?*u32, p_lang_code_: ?*u32, pb_character_set_: ?*DVD_TextCharSet) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextLanguageInfo(@as(*const IDvdInfo2, @ptrCast(self)), ul_lang_index_, pul_num_of_strings_, p_lang_code_, pb_character_set_);
            }
            pub inline fn getDVDTextStringAsNative(self: *const T, ul_lang_index_: u32, ul_string_index_: u32, pb_buffer_: ?*u8, ul_max_buffer_size_: u32, pul_actual_size_: ?*u32, p_type_: ?*DVD_TextStringType) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextStringAsNative(@as(*const IDvdInfo2, @ptrCast(self)), ul_lang_index_, ul_string_index_, pb_buffer_, ul_max_buffer_size_, pul_actual_size_, p_type_);
            }
            pub inline fn getDVDTextStringAsUnicode(self: *const T, ul_lang_index_: u32, ul_string_index_: u32, pchw_buffer_: ?PWSTR, ul_max_buffer_size_: u32, pul_actual_size_: ?*u32, p_type_: ?*DVD_TextStringType) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextStringAsUnicode(@as(*const IDvdInfo2, @ptrCast(self)), ul_lang_index_, ul_string_index_, pchw_buffer_, ul_max_buffer_size_, pul_actual_size_, p_type_);
            }
            pub inline fn getPlayerParentalLevel(self: *const T, pul_parental_level_: ?*u32, pb_country_code_: ?*u8) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetPlayerParentalLevel(@as(*const IDvdInfo2, @ptrCast(self)), pul_parental_level_, pb_country_code_);
            }
            pub inline fn getNumberOfChapters(self: *const T, ul_title_: u32, pul_num_of_chapters_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetNumberOfChapters(@as(*const IDvdInfo2, @ptrCast(self)), ul_title_, pul_num_of_chapters_);
            }
            pub inline fn getTitleParentalLevels(self: *const T, ul_title_: u32, pul_parental_levels_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTitleParentalLevels(@as(*const IDvdInfo2, @ptrCast(self)), ul_title_, pul_parental_levels_);
            }
            pub inline fn getDVDDirectory(self: *const T, pszw_path_: [*:0]u16, ul_max_size_: u32, pul_actual_size_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDDirectory(@as(*const IDvdInfo2, @ptrCast(self)), pszw_path_, ul_max_size_, pul_actual_size_);
            }
            pub inline fn isAudioStreamEnabled(self: *const T, ul_stream_num_: u32, pb_enabled_: ?*BOOL) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).IsAudioStreamEnabled(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_num_, pb_enabled_);
            }
            pub inline fn getDiscID(self: *const T, pszw_path_: ?[*:0]const u16, pull_disc_i_d_: ?*u64) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDiscID(@as(*const IDvdInfo2, @ptrCast(self)), pszw_path_, pull_disc_i_d_);
            }
            pub inline fn getState(self: *const T, p_state_data_: ?*?*IDvdState) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetState(@as(*const IDvdInfo2, @ptrCast(self)), p_state_data_);
            }
            pub inline fn getMenuLanguages(self: *const T, p_languages_: ?*u32, ul_max_languages_: u32, pul_actual_languages_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetMenuLanguages(@as(*const IDvdInfo2, @ptrCast(self)), p_languages_, ul_max_languages_, pul_actual_languages_);
            }
            pub inline fn getButtonAtPosition(self: *const T, point_: POINT, pul_button_index_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetButtonAtPosition(@as(*const IDvdInfo2, @ptrCast(self)), point_, pul_button_index_);
            }
            pub inline fn getCmdFromEvent(self: *const T, l_param1_: isize, p_cmd_obj_: ?*?*IDvdCmd) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCmdFromEvent(@as(*const IDvdInfo2, @ptrCast(self)), l_param1_, p_cmd_obj_);
            }
            pub inline fn getDefaultMenuLanguage(self: *const T, p_language_: ?*u32) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultMenuLanguage(@as(*const IDvdInfo2, @ptrCast(self)), p_language_);
            }
            pub inline fn getDefaultAudioLanguage(self: *const T, p_language_: ?*u32, p_audio_extension_: ?*DVD_AUDIO_LANG_EXT) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultAudioLanguage(@as(*const IDvdInfo2, @ptrCast(self)), p_language_, p_audio_extension_);
            }
            pub inline fn getDefaultSubpictureLanguage(self: *const T, p_language_: ?*u32, p_subpicture_extension_: ?*DVD_SUBPICTURE_LANG_EXT) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultSubpictureLanguage(@as(*const IDvdInfo2, @ptrCast(self)), p_language_, p_subpicture_extension_);
            }
            pub inline fn getDecoderCaps(self: *const T, p_caps_: ?*DVD_DECODER_CAPS) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDecoderCaps(@as(*const IDvdInfo2, @ptrCast(self)), p_caps_);
            }
            pub inline fn getButtonRect(self: *const T, ul_button_: u32, p_rect_: ?*RECT) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetButtonRect(@as(*const IDvdInfo2, @ptrCast(self)), ul_button_, p_rect_);
            }
            pub inline fn isSubpictureStreamEnabled(self: *const T, ul_stream_num_: u32, pb_enabled_: ?*BOOL) HRESULT {
                return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).IsSubpictureStreamEnabled(@as(*const IDvdInfo2, @ptrCast(self)), ul_stream_num_, pb_enabled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_DVD_GRAPH_FLAGS = enum(i32) {
    HWDEC_PREFER = 1,
    HWDEC_ONLY = 2,
    SWDEC_PREFER = 4,
    SWDEC_ONLY = 8,
    NOVPE = 256,
    DO_NOT_CLEAR = 512,
    VMR9_ONLY = 2048,
    EVR_ONLY = 4096,
    EVR_QOS = 8192,
    ADAPT_GRAPH = 16384,
    MASK = 65535,
};
pub const AM_DVD_HWDEC_PREFER = AM_DVD_GRAPH_FLAGS.HWDEC_PREFER;
pub const AM_DVD_HWDEC_ONLY = AM_DVD_GRAPH_FLAGS.HWDEC_ONLY;
pub const AM_DVD_SWDEC_PREFER = AM_DVD_GRAPH_FLAGS.SWDEC_PREFER;
pub const AM_DVD_SWDEC_ONLY = AM_DVD_GRAPH_FLAGS.SWDEC_ONLY;
pub const AM_DVD_NOVPE = AM_DVD_GRAPH_FLAGS.NOVPE;
pub const AM_DVD_DO_NOT_CLEAR = AM_DVD_GRAPH_FLAGS.DO_NOT_CLEAR;
pub const AM_DVD_VMR9_ONLY = AM_DVD_GRAPH_FLAGS.VMR9_ONLY;
pub const AM_DVD_EVR_ONLY = AM_DVD_GRAPH_FLAGS.EVR_ONLY;
pub const AM_DVD_EVR_QOS = AM_DVD_GRAPH_FLAGS.EVR_QOS;
pub const AM_DVD_ADAPT_GRAPH = AM_DVD_GRAPH_FLAGS.ADAPT_GRAPH;
pub const AM_DVD_MASK = AM_DVD_GRAPH_FLAGS.MASK;

pub const AM_DVD_STREAM_FLAGS = enum(i32) {
    VIDEO = 1,
    AUDIO = 2,
    SUBPIC = 4,
};
pub const AM_DVD_STREAM_VIDEO = AM_DVD_STREAM_FLAGS.VIDEO;
pub const AM_DVD_STREAM_AUDIO = AM_DVD_STREAM_FLAGS.AUDIO;
pub const AM_DVD_STREAM_SUBPIC = AM_DVD_STREAM_FLAGS.SUBPIC;

pub const AM_DVD_RENDERSTATUS = extern struct {
    hrVPEStatus: HRESULT,
    bDvdVolInvalid: BOOL,
    bDvdVolUnknown: BOOL,
    bNoLine21In: BOOL,
    bNoLine21Out: BOOL,
    iNumStreams: i32,
    iNumStreamsFailed: i32,
    dwFailedStreamsFlag: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDvdGraphBuilder_Value = Guid.initString("fcc152b6-f372-11d0-8e00-00c04fd7c08b");
pub const IID_IDvdGraphBuilder = &IID_IDvdGraphBuilder_Value;
pub const IDvdGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFiltergraph: *const fn (
            self: *const IDvdGraphBuilder,
            pp_g_b: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDvdInterface: *const fn (
            self: *const IDvdGraphBuilder,
            riid: ?*const Guid,
            ppv_i_f: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderDvdVideoVolume: *const fn (
            self: *const IDvdGraphBuilder,
            lpcwsz_path_name: ?[*:0]const u16,
            dw_flags: u32,
            p_status: ?*AM_DVD_RENDERSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFiltergraph(self: *const T, pp_g_b_: ?*?*IGraphBuilder) HRESULT {
                return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const IDvdGraphBuilder, @ptrCast(self)), pp_g_b_);
            }
            pub inline fn getDvdInterface(self: *const T, riid_: ?*const Guid, ppv_i_f_: ?*?*anyopaque) HRESULT {
                return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).GetDvdInterface(@as(*const IDvdGraphBuilder, @ptrCast(self)), riid_, ppv_i_f_);
            }
            pub inline fn renderDvdVideoVolume(self: *const T, lpcwsz_path_name_: ?[*:0]const u16, dw_flags_: u32, p_status_: ?*AM_DVD_RENDERSTATUS) HRESULT {
                return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).RenderDvdVideoVolume(@as(*const IDvdGraphBuilder, @ptrCast(self)), lpcwsz_path_name_, dw_flags_, p_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideo_Value = Guid.initString("153acc21-d83b-11d1-82bf-00a0c9696c8f");
pub const IID_IDDrawExclModeVideo = &IID_IDDrawExclModeVideo_Value;
pub const IDDrawExclModeVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDDrawObject: *const fn (
            self: *const IDDrawExclModeVideo,
            p_d_draw_object: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDDrawObject: *const fn (
            self: *const IDDrawExclModeVideo,
            pp_d_draw_object: ?*?*IDirectDraw,
            pb_using_external: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDrawSurface: *const fn (
            self: *const IDDrawExclModeVideo,
            p_d_draw_surface: ?*IDirectDrawSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDDrawSurface: *const fn (
            self: *const IDDrawExclModeVideo,
            pp_d_draw_surface: ?*?*IDirectDrawSurface,
            pb_using_external: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawParameters: *const fn (
            self: *const IDDrawExclModeVideo,
            prc_source: ?*const RECT,
            prc_target: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeVideoProps: *const fn (
            self: *const IDDrawExclModeVideo,
            pdw_video_width: ?*u32,
            pdw_video_height: ?*u32,
            pdw_pict_aspect_ratio_x: ?*u32,
            pdw_pict_aspect_ratio_y: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallbackInterface: *const fn (
            self: *const IDDrawExclModeVideo,
            p_callback: ?*IDDrawExclModeVideoCallback,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDDrawObject(self: *const T, p_d_draw_object_: ?*IDirectDraw) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDDrawObject(@as(*const IDDrawExclModeVideo, @ptrCast(self)), p_d_draw_object_);
            }
            pub inline fn getDDrawObject(self: *const T, pp_d_draw_object_: ?*?*IDirectDraw, pb_using_external_: ?*BOOL) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetDDrawObject(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pp_d_draw_object_, pb_using_external_);
            }
            pub inline fn setDDrawSurface(self: *const T, p_d_draw_surface_: ?*IDirectDrawSurface) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDDrawSurface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), p_d_draw_surface_);
            }
            pub inline fn getDDrawSurface(self: *const T, pp_d_draw_surface_: ?*?*IDirectDrawSurface, pb_using_external_: ?*BOOL) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetDDrawSurface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pp_d_draw_surface_, pb_using_external_);
            }
            pub inline fn setDrawParameters(self: *const T, prc_source_: ?*const RECT, prc_target_: ?*const RECT) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDrawParameters(@as(*const IDDrawExclModeVideo, @ptrCast(self)), prc_source_, prc_target_);
            }
            pub inline fn getNativeVideoProps(self: *const T, pdw_video_width_: ?*u32, pdw_video_height_: ?*u32, pdw_pict_aspect_ratio_x_: ?*u32, pdw_pict_aspect_ratio_y_: ?*u32) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetNativeVideoProps(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pdw_video_width_, pdw_video_height_, pdw_pict_aspect_ratio_x_, pdw_pict_aspect_ratio_y_);
            }
            pub inline fn setCallbackInterface(self: *const T, p_callback_: ?*IDDrawExclModeVideoCallback, dw_flags_: u32) HRESULT {
                return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetCallbackInterface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), p_callback_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_OVERLAY_NOTIFY_FLAGS = enum(i32) {
    VISIBLE_CHANGE = 1,
    SOURCE_CHANGE = 2,
    DEST_CHANGE = 4,
};
pub const AM_OVERLAY_NOTIFY_VISIBLE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.VISIBLE_CHANGE;
pub const AM_OVERLAY_NOTIFY_SOURCE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.SOURCE_CHANGE;
pub const AM_OVERLAY_NOTIFY_DEST_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.DEST_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideoCallback_Value = Guid.initString("913c24a0-20ab-11d2-9038-00a0c9697298");
pub const IID_IDDrawExclModeVideoCallback = &IID_IDDrawExclModeVideoCallback_Value;
pub const IDDrawExclModeVideoCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateOverlay: *const fn (
            self: *const IDDrawExclModeVideoCallback,
            b_before: BOOL,
            dw_flags: u32,
            b_old_visible: BOOL,
            prc_old_src: ?*const RECT,
            prc_old_dest: ?*const RECT,
            b_new_visible: BOOL,
            prc_new_src: ?*const RECT,
            prc_new_dest: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateColorKey: *const fn (
            self: *const IDDrawExclModeVideoCallback,
            p_key: ?*const COLORKEY,
            dw_color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateSize: *const fn (
            self: *const IDDrawExclModeVideoCallback,
            dw_width: u32,
            dw_height: u32,
            dw_a_r_width: u32,
            dw_a_r_height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUpdateOverlay(self: *const T, b_before_: BOOL, dw_flags_: u32, b_old_visible_: BOOL, prc_old_src_: ?*const RECT, prc_old_dest_: ?*const RECT, b_new_visible_: BOOL, prc_new_src_: ?*const RECT, prc_new_dest_: ?*const RECT) HRESULT {
                return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateOverlay(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), b_before_, dw_flags_, b_old_visible_, prc_old_src_, prc_old_dest_, b_new_visible_, prc_new_src_, prc_new_dest_);
            }
            pub inline fn onUpdateColorKey(self: *const T, p_key_: ?*const COLORKEY, dw_color_: u32) HRESULT {
                return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateColorKey(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), p_key_, dw_color_);
            }
            pub inline fn onUpdateSize(self: *const T, dw_width_: u32, dw_height_: u32, dw_a_r_width_: u32, dw_a_r_height_: u32) HRESULT {
                return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateSize(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), dw_width_, dw_height_, dw_a_r_width_, dw_a_r_height_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BDA_TEMPLATE_CONNECTION = extern struct {
    FromNodeType: u32,
    FromNodePinType: u32,
    ToNodeType: u32,
    ToNodePinType: u32,
};

pub const BDA_TEMPLATE_PIN_JOINT = extern struct {
    uliTemplateConnection: u32,
    ulcInstancesMax: u32,
};

pub const BDA_EVENT_ID = enum(i32) {
    SIGNAL_LOSS = 0,
    SIGNAL_LOCK = 1,
    DATA_START = 2,
    DATA_STOP = 3,
    CHANNEL_ACQUIRED = 4,
    CHANNEL_LOST = 5,
    CHANNEL_SOURCE_CHANGED = 6,
    CHANNEL_ACTIVATED = 7,
    CHANNEL_DEACTIVATED = 8,
    SUBCHANNEL_ACQUIRED = 9,
    SUBCHANNEL_LOST = 10,
    SUBCHANNEL_SOURCE_CHANGED = 11,
    SUBCHANNEL_ACTIVATED = 12,
    SUBCHANNEL_DEACTIVATED = 13,
    ACCESS_GRANTED = 14,
    ACCESS_DENIED = 15,
    OFFER_EXTENDED = 16,
    PURCHASE_COMPLETED = 17,
    SMART_CARD_INSERTED = 18,
    SMART_CARD_REMOVED = 19,
};
pub const BDA_EVENT_SIGNAL_LOSS = BDA_EVENT_ID.SIGNAL_LOSS;
pub const BDA_EVENT_SIGNAL_LOCK = BDA_EVENT_ID.SIGNAL_LOCK;
pub const BDA_EVENT_DATA_START = BDA_EVENT_ID.DATA_START;
pub const BDA_EVENT_DATA_STOP = BDA_EVENT_ID.DATA_STOP;
pub const BDA_EVENT_CHANNEL_ACQUIRED = BDA_EVENT_ID.CHANNEL_ACQUIRED;
pub const BDA_EVENT_CHANNEL_LOST = BDA_EVENT_ID.CHANNEL_LOST;
pub const BDA_EVENT_CHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.CHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_CHANNEL_ACTIVATED = BDA_EVENT_ID.CHANNEL_ACTIVATED;
pub const BDA_EVENT_CHANNEL_DEACTIVATED = BDA_EVENT_ID.CHANNEL_DEACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_ACQUIRED = BDA_EVENT_ID.SUBCHANNEL_ACQUIRED;
pub const BDA_EVENT_SUBCHANNEL_LOST = BDA_EVENT_ID.SUBCHANNEL_LOST;
pub const BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.SUBCHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_SUBCHANNEL_ACTIVATED = BDA_EVENT_ID.SUBCHANNEL_ACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_DEACTIVATED = BDA_EVENT_ID.SUBCHANNEL_DEACTIVATED;
pub const BDA_EVENT_ACCESS_GRANTED = BDA_EVENT_ID.ACCESS_GRANTED;
pub const BDA_EVENT_ACCESS_DENIED = BDA_EVENT_ID.ACCESS_DENIED;
pub const BDA_EVENT_OFFER_EXTENDED = BDA_EVENT_ID.OFFER_EXTENDED;
pub const BDA_EVENT_PURCHASE_COMPLETED = BDA_EVENT_ID.PURCHASE_COMPLETED;
pub const BDA_EVENT_SMART_CARD_INSERTED = BDA_EVENT_ID.SMART_CARD_INSERTED;
pub const BDA_EVENT_SMART_CARD_REMOVED = BDA_EVENT_ID.SMART_CARD_REMOVED;

pub const KS_BDA_FRAME_INFO = extern struct {
    ExtendedHeaderSize: u32,
    dwFrameFlags: u32,
    ulEvent: u32,
    ulChannelNumber: u32,
    ulSubchannelNumber: u32,
    ulReason: u32,
};

pub const BDA_ETHERNET_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_ETHERNET_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_ETHERNET_ADDRESS,
};

pub const BDA_MULTICAST_MODE = enum(i32) {
    PROMISCUOUS_MULTICAST = 0,
    FILTERED_MULTICAST = 1,
    NO_MULTICAST = 2,
};
pub const BDA_PROMISCUOUS_MULTICAST = BDA_MULTICAST_MODE.PROMISCUOUS_MULTICAST;
pub const BDA_FILTERED_MULTICAST = BDA_MULTICAST_MODE.FILTERED_MULTICAST;
pub const BDA_NO_MULTICAST = BDA_MULTICAST_MODE.NO_MULTICAST;

pub const BDA_IPv4_ADDRESS = extern struct {
    rgbAddress: [4]u8,
};

pub const BDA_IPv4_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv4_ADDRESS,
};

pub const BDA_IPv6_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_IPv6_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv6_ADDRESS,
};

pub const BDA_SIGNAL_STATE = enum(i32) {
    UNAVAILABLE = 0,
    INACTIVE = 1,
    ACTIVE = 2,
};
pub const BDA_SIGNAL_UNAVAILABLE = BDA_SIGNAL_STATE.UNAVAILABLE;
pub const BDA_SIGNAL_INACTIVE = BDA_SIGNAL_STATE.INACTIVE;
pub const BDA_SIGNAL_ACTIVE = BDA_SIGNAL_STATE.ACTIVE;

pub const BDA_CHANGE_STATE = enum(i32) {
    COMPLETE = 0,
    PENDING = 1,
};
pub const BDA_CHANGES_COMPLETE = BDA_CHANGE_STATE.COMPLETE;
pub const BDA_CHANGES_PENDING = BDA_CHANGE_STATE.PENDING;

pub const BDANODE_DESCRIPTOR = extern struct {
    ulBdaNodeType: u32,
    guidFunction: Guid,
    guidName: Guid,
};

pub const BDA_TABLE_SECTION = extern struct {
    ulPrimarySectionId: u32,
    ulSecondarySectionId: u32,
    ulcbSectionLength: u32,
    argbSectionData: [1]u32,
};

pub const BDA_DISEQC_SEND = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const BDA_DISEQC_RESPONSE = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const MEDIA_SAMPLE_CONTENT = enum(i32) {
    TRANSPORT_PACKET = 0,
    ELEMENTARY_STREAM = 1,
    MPEG2_PSI = 2,
    TRANSPORT_PAYLOAD = 3,
};
pub const MEDIA_TRANSPORT_PACKET = MEDIA_SAMPLE_CONTENT.TRANSPORT_PACKET;
pub const MEDIA_ELEMENTARY_STREAM = MEDIA_SAMPLE_CONTENT.ELEMENTARY_STREAM;
pub const MEDIA_MPEG2_PSI = MEDIA_SAMPLE_CONTENT.MPEG2_PSI;
pub const MEDIA_TRANSPORT_PAYLOAD = MEDIA_SAMPLE_CONTENT.TRANSPORT_PAYLOAD;

pub const PID_MAP = extern struct {
    ulPID: u32,
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
};

pub const BDA_PID_MAP = extern struct {
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_PID_UNMAP = extern struct {
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_CA_MODULE_UI = extern struct {
    ulFormat: u32,
    ulbcDesc: u32,
    ulDesc: [1]u32,
};

pub const BDA_PROGRAM_PID_LIST = extern struct {
    ulProgramNumber: u32,
    ulcPIDs: u32,
    ulPID: [1]u32,
};

pub const BDA_DRM_DRMSTATUS = extern struct {
    lResult: i32,
    DRMuuid: Guid,
    ulDrmUuidListStringSize: u32,
    argbDrmUuidListString: [1]Guid,
};

pub const BDA_WMDRM_STATUS = extern struct {
    lResult: i32,
    ulMaxCaptureTokenSize: u32,
    uMaxStreamingPid: u32,
    ulMaxLicense: u32,
    ulMinSecurityLevel: u32,
    ulRevInfoSequenceNumber: u32,
    ulRevInfoIssuedTime: u64,
    ulRevListVersion: u32,
    ulRevInfoTTL: u32,
    ulState: u32,
};

pub const BDA_WMDRM_KEYINFOLIST = extern struct {
    lResult: i32,
    ulKeyuuidBufferLen: u32,
    argKeyuuidBuffer: [1]Guid,
};

pub const BDA_BUFFER = extern struct {
    lResult: i32,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const BDA_WMDRM_RENEWLICENSE = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulXmrLicenseOutputLength: u32,
    argbXmrLicenceOutputBuffer: [1]u8,
};

pub const BDA_WMDRMTUNER_PIDPROTECTION = extern struct {
    lResult: i32,
    uuidKeyID: Guid,
};

pub const BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulCaptureTokenLength: u32,
    argbCaptureTokenBuffer: [1]u8,
};

pub const BDA_TUNER_TUNERSTATE = extern struct {
    lResult: i32,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const BDA_TUNER_DIAGNOSTICS = extern struct {
    lResult: i32,
    ulSignalLevel: u32,
    ulSignalLevelQuality: u32,
    ulSignalNoiseRatio: u32,
};

pub const BDA_STRING = extern struct {
    lResult: i32,
    ulStringSize: u32,
    argbString: [1]u8,
};

pub const BDA_SCAN_CAPABILTIES = extern struct {
    lResult: i32,
    ul64AnalogStandardsSupported: u64,
};

pub const BDA_SCAN_STATE = extern struct {
    lResult: i32,
    ulSignalLock: u32,
    ulSecondsLeft: u32,
    ulCurrentFrequency: u32,
};

pub const BDA_SCAN_START = extern struct {
    lResult: i32,
    LowerFrequency: u32,
    HigerFrequency: u32,
};

pub const BDA_GDDS_DATATYPE = extern struct {
    lResult: i32,
    uuidDataType: Guid,
};

pub const BDA_GDDS_DATA = extern struct {
    lResult: i32,
    ulDataLength: u32,
    ulPercentageProgress: u32,
    argbData: [1]u8,
};

pub const BDA_USERACTIVITY_INTERVAL = extern struct {
    lResult: i32,
    ulActivityInterval: u32,
};

pub const BDA_CAS_CHECK_ENTITLEMENTTOKEN = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
};

pub const BDA_CAS_CLOSE_MMIDIALOG = extern struct {
    lResult: i32,
    SessionResult: u32,
};

pub const BDA_CAS_REQUESTTUNERDATA = extern struct {
    ucRequestPriority: u8,
    ucRequestReason: u8,
    ucRequestConsequences: u8,
    ulEstimatedTime: u32,
};

pub const BDA_CAS_OPENMMIDATA = extern struct {
    ulDialogNumber: u32,
    ulDialogRequest: u32,
    uuidDialogType: Guid,
    usDialogDataLength: u16,
    argbDialogData: [1]u8,
};

pub const BDA_CAS_CLOSEMMIDATA = extern struct {
    ulDialogNumber: u32,
};

pub const ISDBCAS_REQUEST_ID = enum(i32) {
    G = 56,
    D = 58,
};
pub const ISDBCAS_REQUEST_ID_EMG = ISDBCAS_REQUEST_ID.G;
pub const ISDBCAS_REQUEST_ID_EMD = ISDBCAS_REQUEST_ID.D;

pub const BDA_ISDBCAS_REQUESTHEADER = extern struct {
    bInstruction: u8 align(1),
    bReserved: [3]u8 align(1),
    ulDataLength: u32 align(1),
    argbIsdbCommand: [1]u8 align(1),
};

pub const BDA_ISDBCAS_RESPONSEDATA = extern struct {
    lResult: i32 align(1),
    ulRequestID: u32 align(1),
    ulIsdbStatus: u32 align(1),
    ulIsdbDataSize: u32 align(1),
    argbIsdbCommandData: [1]u8 align(1),
};

pub const BDA_ISDBCAS_EMG_REQ = extern struct {
    bCLA: u8,
    bINS: u8,
    bP1: u8,
    bP2: u8,
    bLC: u8,
    bCardId: [6]u8,
    bProtocol: u8,
    bCABroadcasterGroupId: u8,
    bMessageControl: u8,
    bMessageCode: [1]u8,
};

pub const MUX_PID_TYPE = enum(i32) {
    OTHER = -1,
    ELEMENTARY_STREAM = 0,
    MPEG2_SECTION_PSI_SI = 1,
};
pub const PID_OTHER = MUX_PID_TYPE.OTHER;
pub const PID_ELEMENTARY_STREAM = MUX_PID_TYPE.ELEMENTARY_STREAM;
pub const PID_MPEG2_SECTION_PSI_SI = MUX_PID_TYPE.MPEG2_SECTION_PSI_SI;

pub const BDA_MUX_PIDLISTITEM = extern struct {
    usPIDNumber: u16 align(2),
    usProgramNumber: u16 align(2),
    ePIDType: MUX_PID_TYPE align(2),
};

pub const BDA_TS_SELECTORINFO = extern struct {
    bTSInfolength: u8 align(1),
    bReserved: [2]u8 align(1),
    guidNetworkType: Guid align(1),
    bTSIDCount: u8 align(1),
    usTSID: [1]u16 align(1),
};

pub const BDA_TS_SELECTORINFO_ISDBS_EXT = extern struct {
    bTMCC: [48]u8,
};

pub const BDA_DVBT2_L1_SIGNALLING_DATA = extern struct {
    L1Pre_TYPE: u8,
    L1Pre_BWT_S1_S2: u8,
    L1Pre_REPETITION_GUARD_PAPR: u8,
    L1Pre_MOD_COD_FEC: u8,
    L1Pre_POSTSIZE_INFO_PILOT: [5]u8,
    L1Pre_TX_ID_AVAIL: u8,
    L1Pre_CELL_ID: [2]u8,
    L1Pre_NETWORK_ID: [2]u8,
    L1Pre_T2SYSTEM_ID: [2]u8,
    L1Pre_NUM_T2_FRAMES: u8,
    L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT: [2]u8,
    L1Pre_NUMRF_CURRENTRF_RESERVED: [2]u8,
    L1Pre_CRC32: [4]u8,
    L1PostData: [1]u8,
};

pub const BDA_RATING_PINRESET = extern struct {
    bPinLength: u8,
    argbNewPin: [1]u8,
};

pub const DVBSystemType = enum(i32) {
    DVB_Cable = 0,
    DVB_Terrestrial = 1,
    DVB_Satellite = 2,
    ISDB_Terrestrial = 3,
    ISDB_Satellite = 4,
};
pub const DVB_Cable = DVBSystemType.DVB_Cable;
pub const DVB_Terrestrial = DVBSystemType.DVB_Terrestrial;
pub const DVB_Satellite = DVBSystemType.DVB_Satellite;
pub const ISDB_Terrestrial = DVBSystemType.ISDB_Terrestrial;
pub const ISDB_Satellite = DVBSystemType.ISDB_Satellite;

pub const BDA_Channel = enum(i32) {
    L = -1,
};
pub const BDA_UNDEFINED_CHANNEL = BDA_Channel.L;

pub const ComponentCategory = enum(i32) {
    ategoryNotSet = -1,
    ategoryOther = 0,
    ategoryVideo = 1,
    ategoryAudio = 2,
    ategoryText = 3,
    ategorySubtitles = 4,
    ategoryCaptions = 5,
    ategorySuperimpose = 6,
    ategoryData = 7,
    ATEGORY_COUNT = 8,
};
pub const CategoryNotSet = ComponentCategory.ategoryNotSet;
pub const CategoryOther = ComponentCategory.ategoryOther;
pub const CategoryVideo = ComponentCategory.ategoryVideo;
pub const CategoryAudio = ComponentCategory.ategoryAudio;
pub const CategoryText = ComponentCategory.ategoryText;
pub const CategorySubtitles = ComponentCategory.ategorySubtitles;
pub const CategoryCaptions = ComponentCategory.ategoryCaptions;
pub const CategorySuperimpose = ComponentCategory.ategorySuperimpose;
pub const CategoryData = ComponentCategory.ategoryData;
pub const CATEGORY_COUNT = ComponentCategory.ATEGORY_COUNT;

pub const ComponentStatus = enum(i32) {
    Active = 0,
    Inactive = 1,
    Unavailable = 2,
};
pub const StatusActive = ComponentStatus.Active;
pub const StatusInactive = ComponentStatus.Inactive;
pub const StatusUnavailable = ComponentStatus.Unavailable;

pub const MPEG2StreamType = enum(i32) {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0,
    ISO_IEC_11172_2_VIDEO = 1,
    ISO_IEC_13818_2_VIDEO = 2,
    ISO_IEC_11172_3_AUDIO = 3,
    ISO_IEC_13818_3_AUDIO = 4,
    ISO_IEC_13818_1_PRIVATE_SECTION = 5,
    ISO_IEC_13818_1_PES = 6,
    ISO_IEC_13522_MHEG = 7,
    ANNEX_A_DSM_CC = 8,
    ITU_T_REC_H_222_1 = 9,
    ISO_IEC_13818_6_TYPE_A = 10,
    ISO_IEC_13818_6_TYPE_B = 11,
    ISO_IEC_13818_6_TYPE_C = 12,
    ISO_IEC_13818_6_TYPE_D = 13,
    ISO_IEC_13818_1_AUXILIARY = 14,
    ISO_IEC_13818_7_AUDIO = 15,
    ISO_IEC_14496_2_VISUAL = 16,
    ISO_IEC_14496_3_AUDIO = 17,
    ISO_IEC_14496_1_IN_PES = 18,
    ISO_IEC_14496_1_IN_SECTION = 19,
    ISO_IEC_13818_6_DOWNLOAD = 20,
    METADATA_IN_PES = 21,
    METADATA_IN_SECTION = 22,
    METADATA_IN_DATA_CAROUSEL = 23,
    METADATA_IN_OBJECT_CAROUSEL = 24,
    METADATA_IN_DOWNLOAD_PROTOCOL = 25,
    IRPM_STREAMM = 26,
    ITU_T_H264 = 27,
    ISO_IEC_13818_1_RESERVED = 28,
    // USER_PRIVATE = 16, this enum value conflicts with ISO_IEC_14496_2_VISUAL
    HEVC_VIDEO_OR_TEMPORAL_VIDEO = 36,
    HEVC_TEMPORAL_VIDEO_SUBSET = 37,
    ISO_IEC_USER_PRIVATE = 128,
    DOLBY_AC3_AUDIO = 129,
    DOLBY_DIGITAL_PLUS_AUDIO_ATSC = 135,
};
pub const BDA_UNITIALIZED_MPEG2STREAMTYPE = MPEG2StreamType.BDA_UNITIALIZED_MPEG2STREAMTYPE;
pub const Reserved1 = MPEG2StreamType.Reserved1;
pub const ISO_IEC_11172_2_VIDEO = MPEG2StreamType.ISO_IEC_11172_2_VIDEO;
pub const ISO_IEC_13818_2_VIDEO = MPEG2StreamType.ISO_IEC_13818_2_VIDEO;
pub const ISO_IEC_11172_3_AUDIO = MPEG2StreamType.ISO_IEC_11172_3_AUDIO;
pub const ISO_IEC_13818_3_AUDIO = MPEG2StreamType.ISO_IEC_13818_3_AUDIO;
pub const ISO_IEC_13818_1_PRIVATE_SECTION = MPEG2StreamType.ISO_IEC_13818_1_PRIVATE_SECTION;
pub const ISO_IEC_13818_1_PES = MPEG2StreamType.ISO_IEC_13818_1_PES;
pub const ISO_IEC_13522_MHEG = MPEG2StreamType.ISO_IEC_13522_MHEG;
pub const ANNEX_A_DSM_CC = MPEG2StreamType.ANNEX_A_DSM_CC;
pub const ITU_T_REC_H_222_1 = MPEG2StreamType.ITU_T_REC_H_222_1;
pub const ISO_IEC_13818_6_TYPE_A = MPEG2StreamType.ISO_IEC_13818_6_TYPE_A;
pub const ISO_IEC_13818_6_TYPE_B = MPEG2StreamType.ISO_IEC_13818_6_TYPE_B;
pub const ISO_IEC_13818_6_TYPE_C = MPEG2StreamType.ISO_IEC_13818_6_TYPE_C;
pub const ISO_IEC_13818_6_TYPE_D = MPEG2StreamType.ISO_IEC_13818_6_TYPE_D;
pub const ISO_IEC_13818_1_AUXILIARY = MPEG2StreamType.ISO_IEC_13818_1_AUXILIARY;
pub const ISO_IEC_13818_7_AUDIO = MPEG2StreamType.ISO_IEC_13818_7_AUDIO;
pub const ISO_IEC_14496_2_VISUAL = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const ISO_IEC_14496_3_AUDIO = MPEG2StreamType.ISO_IEC_14496_3_AUDIO;
pub const ISO_IEC_14496_1_IN_PES = MPEG2StreamType.ISO_IEC_14496_1_IN_PES;
pub const ISO_IEC_14496_1_IN_SECTION = MPEG2StreamType.ISO_IEC_14496_1_IN_SECTION;
pub const ISO_IEC_13818_6_DOWNLOAD = MPEG2StreamType.ISO_IEC_13818_6_DOWNLOAD;
pub const METADATA_IN_PES = MPEG2StreamType.METADATA_IN_PES;
pub const METADATA_IN_SECTION = MPEG2StreamType.METADATA_IN_SECTION;
pub const METADATA_IN_DATA_CAROUSEL = MPEG2StreamType.METADATA_IN_DATA_CAROUSEL;
pub const METADATA_IN_OBJECT_CAROUSEL = MPEG2StreamType.METADATA_IN_OBJECT_CAROUSEL;
pub const METADATA_IN_DOWNLOAD_PROTOCOL = MPEG2StreamType.METADATA_IN_DOWNLOAD_PROTOCOL;
pub const IRPM_STREAMM = MPEG2StreamType.IRPM_STREAMM;
pub const ITU_T_H264 = MPEG2StreamType.ITU_T_H264;
pub const ISO_IEC_13818_1_RESERVED = MPEG2StreamType.ISO_IEC_13818_1_RESERVED;
pub const USER_PRIVATE = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const HEVC_VIDEO_OR_TEMPORAL_VIDEO = MPEG2StreamType.HEVC_VIDEO_OR_TEMPORAL_VIDEO;
pub const HEVC_TEMPORAL_VIDEO_SUBSET = MPEG2StreamType.HEVC_TEMPORAL_VIDEO_SUBSET;
pub const ISO_IEC_USER_PRIVATE = MPEG2StreamType.ISO_IEC_USER_PRIVATE;
pub const DOLBY_AC3_AUDIO = MPEG2StreamType.DOLBY_AC3_AUDIO;
pub const DOLBY_DIGITAL_PLUS_AUDIO_ATSC = MPEG2StreamType.DOLBY_DIGITAL_PLUS_AUDIO_ATSC;

pub const MPEG2_TRANSPORT_STRIDE = extern struct {
    dwOffset: u32,
    dwPacketLength: u32,
    dwStride: u32,
};

pub const ATSCComponentTypeFlags = enum(i32) {
    @"3" = 1,
};
pub const ATSCCT_AC3 = ATSCComponentTypeFlags.@"3";

pub const BinaryConvolutionCodeRate = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_2" = 1,
    @"2_3" = 2,
    @"3_4" = 3,
    @"3_5" = 4,
    @"4_5" = 5,
    @"5_6" = 6,
    @"5_11" = 7,
    @"7_8" = 8,
    @"1_4" = 9,
    @"1_3" = 10,
    @"2_5" = 11,
    @"6_7" = 12,
    @"8_9" = 13,
    @"9_10" = 14,
    MAX = 15,
};
pub const BDA_BCC_RATE_NOT_SET = BinaryConvolutionCodeRate.NOT_SET;
pub const BDA_BCC_RATE_NOT_DEFINED = BinaryConvolutionCodeRate.NOT_DEFINED;
pub const BDA_BCC_RATE_1_2 = BinaryConvolutionCodeRate.@"1_2";
pub const BDA_BCC_RATE_2_3 = BinaryConvolutionCodeRate.@"2_3";
pub const BDA_BCC_RATE_3_4 = BinaryConvolutionCodeRate.@"3_4";
pub const BDA_BCC_RATE_3_5 = BinaryConvolutionCodeRate.@"3_5";
pub const BDA_BCC_RATE_4_5 = BinaryConvolutionCodeRate.@"4_5";
pub const BDA_BCC_RATE_5_6 = BinaryConvolutionCodeRate.@"5_6";
pub const BDA_BCC_RATE_5_11 = BinaryConvolutionCodeRate.@"5_11";
pub const BDA_BCC_RATE_7_8 = BinaryConvolutionCodeRate.@"7_8";
pub const BDA_BCC_RATE_1_4 = BinaryConvolutionCodeRate.@"1_4";
pub const BDA_BCC_RATE_1_3 = BinaryConvolutionCodeRate.@"1_3";
pub const BDA_BCC_RATE_2_5 = BinaryConvolutionCodeRate.@"2_5";
pub const BDA_BCC_RATE_6_7 = BinaryConvolutionCodeRate.@"6_7";
pub const BDA_BCC_RATE_8_9 = BinaryConvolutionCodeRate.@"8_9";
pub const BDA_BCC_RATE_9_10 = BinaryConvolutionCodeRate.@"9_10";
pub const BDA_BCC_RATE_MAX = BinaryConvolutionCodeRate.MAX;

pub const FECMethod = enum(i32) {
    METHOD_NOT_SET = -1,
    METHOD_NOT_DEFINED = 0,
    VITERBI = 1,
    RS_204_188 = 2,
    LDPC = 3,
    BCH = 4,
    RS_147_130 = 5,
    MAX = 6,
};
pub const BDA_FEC_METHOD_NOT_SET = FECMethod.METHOD_NOT_SET;
pub const BDA_FEC_METHOD_NOT_DEFINED = FECMethod.METHOD_NOT_DEFINED;
pub const BDA_FEC_VITERBI = FECMethod.VITERBI;
pub const BDA_FEC_RS_204_188 = FECMethod.RS_204_188;
pub const BDA_FEC_LDPC = FECMethod.LDPC;
pub const BDA_FEC_BCH = FECMethod.BCH;
pub const BDA_FEC_RS_147_130 = FECMethod.RS_147_130;
pub const BDA_FEC_MAX = FECMethod.MAX;

pub const ModulationType = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"16QAM" = 1,
    @"32QAM" = 2,
    @"64QAM" = 3,
    @"80QAM" = 4,
    @"96QAM" = 5,
    @"112QAM" = 6,
    @"128QAM" = 7,
    @"160QAM" = 8,
    @"192QAM" = 9,
    @"224QAM" = 10,
    @"256QAM" = 11,
    @"320QAM" = 12,
    @"384QAM" = 13,
    @"448QAM" = 14,
    @"512QAM" = 15,
    @"640QAM" = 16,
    @"768QAM" = 17,
    @"896QAM" = 18,
    @"1024QAM" = 19,
    QPSK = 20,
    BPSK = 21,
    OQPSK = 22,
    @"8VSB" = 23,
    @"16VSB" = 24,
    ANALOG_AMPLITUDE = 25,
    ANALOG_FREQUENCY = 26,
    @"8PSK" = 27,
    RF = 28,
    @"16APSK" = 29,
    @"32APSK" = 30,
    NBC_QPSK = 31,
    NBC_8PSK = 32,
    DIRECTV = 33,
    ISDB_T_TMCC = 34,
    ISDB_S_TMCC = 35,
    MAX = 36,
};
pub const BDA_MOD_NOT_SET = ModulationType.NOT_SET;
pub const BDA_MOD_NOT_DEFINED = ModulationType.NOT_DEFINED;
pub const BDA_MOD_16QAM = ModulationType.@"16QAM";
pub const BDA_MOD_32QAM = ModulationType.@"32QAM";
pub const BDA_MOD_64QAM = ModulationType.@"64QAM";
pub const BDA_MOD_80QAM = ModulationType.@"80QAM";
pub const BDA_MOD_96QAM = ModulationType.@"96QAM";
pub const BDA_MOD_112QAM = ModulationType.@"112QAM";
pub const BDA_MOD_128QAM = ModulationType.@"128QAM";
pub const BDA_MOD_160QAM = ModulationType.@"160QAM";
pub const BDA_MOD_192QAM = ModulationType.@"192QAM";
pub const BDA_MOD_224QAM = ModulationType.@"224QAM";
pub const BDA_MOD_256QAM = ModulationType.@"256QAM";
pub const BDA_MOD_320QAM = ModulationType.@"320QAM";
pub const BDA_MOD_384QAM = ModulationType.@"384QAM";
pub const BDA_MOD_448QAM = ModulationType.@"448QAM";
pub const BDA_MOD_512QAM = ModulationType.@"512QAM";
pub const BDA_MOD_640QAM = ModulationType.@"640QAM";
pub const BDA_MOD_768QAM = ModulationType.@"768QAM";
pub const BDA_MOD_896QAM = ModulationType.@"896QAM";
pub const BDA_MOD_1024QAM = ModulationType.@"1024QAM";
pub const BDA_MOD_QPSK = ModulationType.QPSK;
pub const BDA_MOD_BPSK = ModulationType.BPSK;
pub const BDA_MOD_OQPSK = ModulationType.OQPSK;
pub const BDA_MOD_8VSB = ModulationType.@"8VSB";
pub const BDA_MOD_16VSB = ModulationType.@"16VSB";
pub const BDA_MOD_ANALOG_AMPLITUDE = ModulationType.ANALOG_AMPLITUDE;
pub const BDA_MOD_ANALOG_FREQUENCY = ModulationType.ANALOG_FREQUENCY;
pub const BDA_MOD_8PSK = ModulationType.@"8PSK";
pub const BDA_MOD_RF = ModulationType.RF;
pub const BDA_MOD_16APSK = ModulationType.@"16APSK";
pub const BDA_MOD_32APSK = ModulationType.@"32APSK";
pub const BDA_MOD_NBC_QPSK = ModulationType.NBC_QPSK;
pub const BDA_MOD_NBC_8PSK = ModulationType.NBC_8PSK;
pub const BDA_MOD_DIRECTV = ModulationType.DIRECTV;
pub const BDA_MOD_ISDB_T_TMCC = ModulationType.ISDB_T_TMCC;
pub const BDA_MOD_ISDB_S_TMCC = ModulationType.ISDB_S_TMCC;
pub const BDA_MOD_MAX = ModulationType.MAX;

pub const ScanModulationTypes = enum(i32) {
    BDA_SCAN_MOD_16QAM = 1,
    BDA_SCAN_MOD_32QAM = 2,
    BDA_SCAN_MOD_64QAM = 4,
    BDA_SCAN_MOD_80QAM = 8,
    BDA_SCAN_MOD_96QAM = 16,
    BDA_SCAN_MOD_112QAM = 32,
    BDA_SCAN_MOD_128QAM = 64,
    BDA_SCAN_MOD_160QAM = 128,
    BDA_SCAN_MOD_192QAM = 256,
    BDA_SCAN_MOD_224QAM = 512,
    BDA_SCAN_MOD_256QAM = 1024,
    BDA_SCAN_MOD_320QAM = 2048,
    BDA_SCAN_MOD_384QAM = 4096,
    BDA_SCAN_MOD_448QAM = 8192,
    BDA_SCAN_MOD_512QAM = 16384,
    BDA_SCAN_MOD_640QAM = 32768,
    BDA_SCAN_MOD_768QAM = 65536,
    BDA_SCAN_MOD_896QAM = 131072,
    BDA_SCAN_MOD_1024QAM = 262144,
    BDA_SCAN_MOD_QPSK = 524288,
    BDA_SCAN_MOD_BPSK = 1048576,
    BDA_SCAN_MOD_OQPSK = 2097152,
    BDA_SCAN_MOD_8VSB = 4194304,
    BDA_SCAN_MOD_16VSB = 8388608,
    BDA_SCAN_MOD_AM_RADIO = 16777216,
    BDA_SCAN_MOD_FM_RADIO = 33554432,
    BDA_SCAN_MOD_8PSK = 67108864,
    BDA_SCAN_MOD_RF = 134217728,
    ScanModulationTypesMask_MCE_DigitalCable = 11,
    ScanModulationTypesMask_MCE_TerrestrialATSC = 23,
    ScanModulationTypesMask_MCE_AnalogTv = 28,
    ScanModulationTypesMask_MCE_All_TV = -1,
    ScanModulationTypesMask_DVBC = 75,
    BDA_SCAN_MOD_16APSK = 268435456,
    BDA_SCAN_MOD_32APSK = 536870912,
};
pub const BDA_SCAN_MOD_16QAM = ScanModulationTypes.BDA_SCAN_MOD_16QAM;
pub const BDA_SCAN_MOD_32QAM = ScanModulationTypes.BDA_SCAN_MOD_32QAM;
pub const BDA_SCAN_MOD_64QAM = ScanModulationTypes.BDA_SCAN_MOD_64QAM;
pub const BDA_SCAN_MOD_80QAM = ScanModulationTypes.BDA_SCAN_MOD_80QAM;
pub const BDA_SCAN_MOD_96QAM = ScanModulationTypes.BDA_SCAN_MOD_96QAM;
pub const BDA_SCAN_MOD_112QAM = ScanModulationTypes.BDA_SCAN_MOD_112QAM;
pub const BDA_SCAN_MOD_128QAM = ScanModulationTypes.BDA_SCAN_MOD_128QAM;
pub const BDA_SCAN_MOD_160QAM = ScanModulationTypes.BDA_SCAN_MOD_160QAM;
pub const BDA_SCAN_MOD_192QAM = ScanModulationTypes.BDA_SCAN_MOD_192QAM;
pub const BDA_SCAN_MOD_224QAM = ScanModulationTypes.BDA_SCAN_MOD_224QAM;
pub const BDA_SCAN_MOD_256QAM = ScanModulationTypes.BDA_SCAN_MOD_256QAM;
pub const BDA_SCAN_MOD_320QAM = ScanModulationTypes.BDA_SCAN_MOD_320QAM;
pub const BDA_SCAN_MOD_384QAM = ScanModulationTypes.BDA_SCAN_MOD_384QAM;
pub const BDA_SCAN_MOD_448QAM = ScanModulationTypes.BDA_SCAN_MOD_448QAM;
pub const BDA_SCAN_MOD_512QAM = ScanModulationTypes.BDA_SCAN_MOD_512QAM;
pub const BDA_SCAN_MOD_640QAM = ScanModulationTypes.BDA_SCAN_MOD_640QAM;
pub const BDA_SCAN_MOD_768QAM = ScanModulationTypes.BDA_SCAN_MOD_768QAM;
pub const BDA_SCAN_MOD_896QAM = ScanModulationTypes.BDA_SCAN_MOD_896QAM;
pub const BDA_SCAN_MOD_1024QAM = ScanModulationTypes.BDA_SCAN_MOD_1024QAM;
pub const BDA_SCAN_MOD_QPSK = ScanModulationTypes.BDA_SCAN_MOD_QPSK;
pub const BDA_SCAN_MOD_BPSK = ScanModulationTypes.BDA_SCAN_MOD_BPSK;
pub const BDA_SCAN_MOD_OQPSK = ScanModulationTypes.BDA_SCAN_MOD_OQPSK;
pub const BDA_SCAN_MOD_8VSB = ScanModulationTypes.BDA_SCAN_MOD_8VSB;
pub const BDA_SCAN_MOD_16VSB = ScanModulationTypes.BDA_SCAN_MOD_16VSB;
pub const BDA_SCAN_MOD_AM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_AM_RADIO;
pub const BDA_SCAN_MOD_FM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_FM_RADIO;
pub const BDA_SCAN_MOD_8PSK = ScanModulationTypes.BDA_SCAN_MOD_8PSK;
pub const BDA_SCAN_MOD_RF = ScanModulationTypes.BDA_SCAN_MOD_RF;
pub const ScanModulationTypesMask_MCE_DigitalCable = ScanModulationTypes.ScanModulationTypesMask_MCE_DigitalCable;
pub const ScanModulationTypesMask_MCE_TerrestrialATSC = ScanModulationTypes.ScanModulationTypesMask_MCE_TerrestrialATSC;
pub const ScanModulationTypesMask_MCE_AnalogTv = ScanModulationTypes.ScanModulationTypesMask_MCE_AnalogTv;
pub const ScanModulationTypesMask_MCE_All_TV = ScanModulationTypes.ScanModulationTypesMask_MCE_All_TV;
pub const ScanModulationTypesMask_DVBC = ScanModulationTypes.ScanModulationTypesMask_DVBC;
pub const BDA_SCAN_MOD_16APSK = ScanModulationTypes.BDA_SCAN_MOD_16APSK;
pub const BDA_SCAN_MOD_32APSK = ScanModulationTypes.BDA_SCAN_MOD_32APSK;

pub const SpectralInversion = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    AUTOMATIC = 1,
    NORMAL = 2,
    INVERTED = 3,
    MAX = 4,
};
pub const BDA_SPECTRAL_INVERSION_NOT_SET = SpectralInversion.NOT_SET;
pub const BDA_SPECTRAL_INVERSION_NOT_DEFINED = SpectralInversion.NOT_DEFINED;
pub const BDA_SPECTRAL_INVERSION_AUTOMATIC = SpectralInversion.AUTOMATIC;
pub const BDA_SPECTRAL_INVERSION_NORMAL = SpectralInversion.NORMAL;
pub const BDA_SPECTRAL_INVERSION_INVERTED = SpectralInversion.INVERTED;
pub const BDA_SPECTRAL_INVERSION_MAX = SpectralInversion.MAX;

pub const Polarisation = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    LINEAR_H = 1,
    LINEAR_V = 2,
    CIRCULAR_L = 3,
    CIRCULAR_R = 4,
    MAX = 5,
};
pub const BDA_POLARISATION_NOT_SET = Polarisation.NOT_SET;
pub const BDA_POLARISATION_NOT_DEFINED = Polarisation.NOT_DEFINED;
pub const BDA_POLARISATION_LINEAR_H = Polarisation.LINEAR_H;
pub const BDA_POLARISATION_LINEAR_V = Polarisation.LINEAR_V;
pub const BDA_POLARISATION_CIRCULAR_L = Polarisation.CIRCULAR_L;
pub const BDA_POLARISATION_CIRCULAR_R = Polarisation.CIRCULAR_R;
pub const BDA_POLARISATION_MAX = Polarisation.MAX;

pub const LNB_Source = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    MAX = 5,
};
pub const BDA_LNB_SOURCE_NOT_SET = LNB_Source.NOT_SET;
pub const BDA_LNB_SOURCE_NOT_DEFINED = LNB_Source.NOT_DEFINED;
pub const BDA_LNB_SOURCE_A = LNB_Source.A;
pub const BDA_LNB_SOURCE_B = LNB_Source.B;
pub const BDA_LNB_SOURCE_C = LNB_Source.C;
pub const BDA_LNB_SOURCE_D = LNB_Source.D;
pub const BDA_LNB_SOURCE_MAX = LNB_Source.MAX;

pub const GuardInterval = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_32" = 1,
    @"1_16" = 2,
    @"1_8" = 3,
    @"1_4" = 4,
    @"1_128" = 5,
    @"19_128" = 6,
    @"19_256" = 7,
    MAX = 8,
};
pub const BDA_GUARD_NOT_SET = GuardInterval.NOT_SET;
pub const BDA_GUARD_NOT_DEFINED = GuardInterval.NOT_DEFINED;
pub const BDA_GUARD_1_32 = GuardInterval.@"1_32";
pub const BDA_GUARD_1_16 = GuardInterval.@"1_16";
pub const BDA_GUARD_1_8 = GuardInterval.@"1_8";
pub const BDA_GUARD_1_4 = GuardInterval.@"1_4";
pub const BDA_GUARD_1_128 = GuardInterval.@"1_128";
pub const BDA_GUARD_19_128 = GuardInterval.@"19_128";
pub const BDA_GUARD_19_256 = GuardInterval.@"19_256";
pub const BDA_GUARD_MAX = GuardInterval.MAX;

pub const HierarchyAlpha = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1" = 1,
    @"2" = 2,
    @"4" = 3,
    MAX = 4,
};
pub const BDA_HALPHA_NOT_SET = HierarchyAlpha.NOT_SET;
pub const BDA_HALPHA_NOT_DEFINED = HierarchyAlpha.NOT_DEFINED;
pub const BDA_HALPHA_1 = HierarchyAlpha.@"1";
pub const BDA_HALPHA_2 = HierarchyAlpha.@"2";
pub const BDA_HALPHA_4 = HierarchyAlpha.@"4";
pub const BDA_HALPHA_MAX = HierarchyAlpha.MAX;

pub const TransmissionMode = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"2K" = 1,
    @"8K" = 2,
    @"4K" = 3,
    @"2K_INTERLEAVED" = 4,
    @"4K_INTERLEAVED" = 5,
    @"1K" = 6,
    @"16K" = 7,
    @"32K" = 8,
    MAX = 9,
};
pub const BDA_XMIT_MODE_NOT_SET = TransmissionMode.NOT_SET;
pub const BDA_XMIT_MODE_NOT_DEFINED = TransmissionMode.NOT_DEFINED;
pub const BDA_XMIT_MODE_2K = TransmissionMode.@"2K";
pub const BDA_XMIT_MODE_8K = TransmissionMode.@"8K";
pub const BDA_XMIT_MODE_4K = TransmissionMode.@"4K";
pub const BDA_XMIT_MODE_2K_INTERLEAVED = TransmissionMode.@"2K_INTERLEAVED";
pub const BDA_XMIT_MODE_4K_INTERLEAVED = TransmissionMode.@"4K_INTERLEAVED";
pub const BDA_XMIT_MODE_1K = TransmissionMode.@"1K";
pub const BDA_XMIT_MODE_16K = TransmissionMode.@"16K";
pub const BDA_XMIT_MODE_32K = TransmissionMode.@"32K";
pub const BDA_XMIT_MODE_MAX = TransmissionMode.MAX;

pub const RollOff = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"20" = 1,
    @"25" = 2,
    @"35" = 3,
    MAX = 4,
};
pub const BDA_ROLL_OFF_NOT_SET = RollOff.NOT_SET;
pub const BDA_ROLL_OFF_NOT_DEFINED = RollOff.NOT_DEFINED;
pub const BDA_ROLL_OFF_20 = RollOff.@"20";
pub const BDA_ROLL_OFF_25 = RollOff.@"25";
pub const BDA_ROLL_OFF_35 = RollOff.@"35";
pub const BDA_ROLL_OFF_MAX = RollOff.MAX;

pub const Pilot = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    OFF = 1,
    ON = 2,
    MAX = 3,
};
pub const BDA_PILOT_NOT_SET = Pilot.NOT_SET;
pub const BDA_PILOT_NOT_DEFINED = Pilot.NOT_DEFINED;
pub const BDA_PILOT_OFF = Pilot.OFF;
pub const BDA_PILOT_ON = Pilot.ON;
pub const BDA_PILOT_MAX = Pilot.MAX;

pub const BDA_SIGNAL_TIMEOUTS = extern struct {
    ulCarrierTimeoutMs: u32,
    ulScanningTimeoutMs: u32,
    ulTuningTimeoutMs: u32,
};

pub const BDA_Frequency = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_NOT_SET = BDA_Frequency.SET;
pub const BDA_FREQUENCY_NOT_DEFINED = BDA_Frequency.DEFINED;

pub const BDA_Range = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_RANGE_NOT_SET = BDA_Range.SET;
pub const BDA_RANGE_NOT_DEFINED = BDA_Range.DEFINED;

pub const BDA_Channel_Bandwidth = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_CHAN_BANDWITH_NOT_SET = BDA_Channel_Bandwidth.SET;
pub const BDA_CHAN_BANDWITH_NOT_DEFINED = BDA_Channel_Bandwidth.DEFINED;

pub const BDA_Frequency_Multiplier = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_MULTIPLIER_NOT_SET = BDA_Frequency_Multiplier.SET;
pub const BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED = BDA_Frequency_Multiplier.DEFINED;

pub const BDA_Comp_Flags = enum(i32) {
    NOT_DEFINED = 0,
    EXCLUDE_TS_FROM_TR = 1,
    INCLUDE_LOCATOR_IN_TR = 2,
    INCLUDE_COMPONENTS_IN_TR = 4,
};
pub const BDACOMP_NOT_DEFINED = BDA_Comp_Flags.NOT_DEFINED;
pub const BDACOMP_EXCLUDE_TS_FROM_TR = BDA_Comp_Flags.EXCLUDE_TS_FROM_TR;
pub const BDACOMP_INCLUDE_LOCATOR_IN_TR = BDA_Comp_Flags.INCLUDE_LOCATOR_IN_TR;
pub const BDACOMP_INCLUDE_COMPONENTS_IN_TR = BDA_Comp_Flags.INCLUDE_COMPONENTS_IN_TR;

pub const ApplicationTypeType = enum(i32) {
    ConditionalAccess = 0,
    POD_Host_Binding_Information = 1,
    IPService = 2,
    NetworkInterface_SCTE55_2 = 3,
    NetworkInterface_SCTE55_1 = 4,
    CopyProtection = 5,
    Diagnostic = 6,
    Undesignated = 7,
    Reserved = 8,
};
pub const SCTE28_ConditionalAccess = ApplicationTypeType.ConditionalAccess;
pub const SCTE28_POD_Host_Binding_Information = ApplicationTypeType.POD_Host_Binding_Information;
pub const SCTE28_IPService = ApplicationTypeType.IPService;
pub const SCTE28_NetworkInterface_SCTE55_2 = ApplicationTypeType.NetworkInterface_SCTE55_2;
pub const SCTE28_NetworkInterface_SCTE55_1 = ApplicationTypeType.NetworkInterface_SCTE55_1;
pub const SCTE28_CopyProtection = ApplicationTypeType.CopyProtection;
pub const SCTE28_Diagnostic = ApplicationTypeType.Diagnostic;
pub const SCTE28_Undesignated = ApplicationTypeType.Undesignated;
pub const SCTE28_Reserved = ApplicationTypeType.Reserved;

pub const BDA_CONDITIONALACCESS_REQUESTTYPE = enum(i32) {
    UNSPECIFIED = 0,
    NOT_POSSIBLE = 1,
    POSSIBLE = 2,
    POSSIBLE_NO_STREAMING_DISRUPTION = 3,
};
pub const CONDITIONALACCESS_ACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_REQUESTTYPE.UNSPECIFIED;
pub const CONDITIONALACCESS_ACCESS_NOT_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.NOT_POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE_NO_STREAMING_DISRUPTION = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE_NO_STREAMING_DISRUPTION;

pub const BDA_CONDITIONALACCESS_MMICLOSEREASON = enum(i32) {
    UNSPECIFIED = 0,
    CLOSED_ITSELF = 1,
    TUNER_REQUESTED_CLOSE = 2,
    DIALOG_TIMEOUT = 3,
    DIALOG_FOCUS_CHANGE = 4,
    DIALOG_USER_DISMISSED = 5,
    DIALOG_USER_NOT_AVAILABLE = 6,
};
pub const CONDITIONALACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_MMICLOSEREASON.UNSPECIFIED;
pub const CONDITIONALACCESS_CLOSED_ITSELF = BDA_CONDITIONALACCESS_MMICLOSEREASON.CLOSED_ITSELF;
pub const CONDITIONALACCESS_TUNER_REQUESTED_CLOSE = BDA_CONDITIONALACCESS_MMICLOSEREASON.TUNER_REQUESTED_CLOSE;
pub const CONDITIONALACCESS_DIALOG_TIMEOUT = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_TIMEOUT;
pub const CONDITIONALACCESS_DIALOG_FOCUS_CHANGE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_FOCUS_CHANGE;
pub const CONDITIONALACCESS_DIALOG_USER_DISMISSED = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_DISMISSED;
pub const CONDITIONALACCESS_DIALOG_USER_NOT_AVAILABLE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_NOT_AVAILABLE;

pub const BDA_CONDITIONALACCESS_SESSION_RESULT = enum(i32) {
    SUCCESSFULL = 0,
    ENDED_NOCHANGE = 1,
    ABORTED = 2,
};
pub const CONDITIONALACCESS_SUCCESSFULL = BDA_CONDITIONALACCESS_SESSION_RESULT.SUCCESSFULL;
pub const CONDITIONALACCESS_ENDED_NOCHANGE = BDA_CONDITIONALACCESS_SESSION_RESULT.ENDED_NOCHANGE;
pub const CONDITIONALACCESS_ABORTED = BDA_CONDITIONALACCESS_SESSION_RESULT.ABORTED;

pub const BDA_DISCOVERY_STATE = enum(i32) {
    UNSPECIFIED = 0,
    REQUIRED = 1,
    COMPLETE = 2,
};
pub const BDA_DISCOVERY_UNSPECIFIED = BDA_DISCOVERY_STATE.UNSPECIFIED;
pub const BDA_DISCOVERY_REQUIRED = BDA_DISCOVERY_STATE.REQUIRED;
pub const BDA_DISCOVERY_COMPLETE = BDA_DISCOVERY_STATE.COMPLETE;

pub const SmartCardStatusType = enum(i32) {
    Inserted = 0,
    Removed = 1,
    Error = 2,
    DataChanged = 3,
    FirmwareUpgrade = 4,
};
pub const CardInserted = SmartCardStatusType.Inserted;
pub const CardRemoved = SmartCardStatusType.Removed;
pub const CardError = SmartCardStatusType.Error;
pub const CardDataChanged = SmartCardStatusType.DataChanged;
pub const CardFirmwareUpgrade = SmartCardStatusType.FirmwareUpgrade;

pub const SmartCardAssociationType = enum(i32) {
    NotAssociated = 0,
    Associated = 1,
    AssociationUnknown = 2,
};
pub const NotAssociated = SmartCardAssociationType.NotAssociated;
pub const Associated = SmartCardAssociationType.Associated;
pub const AssociationUnknown = SmartCardAssociationType.AssociationUnknown;

pub const LocationCodeSchemeType = enum(i32) {
    @"8" = 0,
};
pub const SCTE_18 = LocationCodeSchemeType.@"8";

pub const EALocationCodeType = extern struct {
    LocationCodeScheme: LocationCodeSchemeType,
    state_code: u8,
    county_subdivision: u8,
    county_code: u16,
};

pub const EntitlementType = enum(i32) {
    Entitled = 0,
    NotEntitled = 1,
    TechnicalFailure = 2,
};
pub const Entitled = EntitlementType.Entitled;
pub const NotEntitled = EntitlementType.NotEntitled;
pub const TechnicalFailure = EntitlementType.TechnicalFailure;

pub const UICloseReasonType = enum(i32) {
    NotReady = 0,
    UserClosed = 1,
    SystemClosed = 2,
    DeviceClosed = 3,
    ErrorClosed = 4,
};
pub const NotReady = UICloseReasonType.NotReady;
pub const UserClosed = UICloseReasonType.UserClosed;
pub const SystemClosed = UICloseReasonType.SystemClosed;
pub const DeviceClosed = UICloseReasonType.DeviceClosed;
pub const ErrorClosed = UICloseReasonType.ErrorClosed;

pub const SmartCardApplication = extern struct {
    ApplicationType: ApplicationTypeType,
    ApplicationVersion: u16,
    pbstrApplicationName: ?BSTR,
    pbstrApplicationURL: ?BSTR,
};

pub const BDA_DrmPairingError = enum(i32) {
    Succeeded = 0,
    HardwareFailure = 1,
    NeedRevocationData = 2,
    NeedIndiv = 3,
    Other = 4,
    DrmInitFailed = 5,
    DrmNotPaired = 6,
    DrmRePairSoon = 7,
    Aborted = 8,
    NeedSDKUpdate = 9,
};
pub const BDA_DrmPairing_Succeeded = BDA_DrmPairingError.Succeeded;
pub const BDA_DrmPairing_HardwareFailure = BDA_DrmPairingError.HardwareFailure;
pub const BDA_DrmPairing_NeedRevocationData = BDA_DrmPairingError.NeedRevocationData;
pub const BDA_DrmPairing_NeedIndiv = BDA_DrmPairingError.NeedIndiv;
pub const BDA_DrmPairing_Other = BDA_DrmPairingError.Other;
pub const BDA_DrmPairing_DrmInitFailed = BDA_DrmPairingError.DrmInitFailed;
pub const BDA_DrmPairing_DrmNotPaired = BDA_DrmPairingError.DrmNotPaired;
pub const BDA_DrmPairing_DrmRePairSoon = BDA_DrmPairingError.DrmRePairSoon;
pub const BDA_DrmPairing_Aborted = BDA_DrmPairingError.Aborted;
pub const BDA_DrmPairing_NeedSDKUpdate = BDA_DrmPairingError.NeedSDKUpdate;

const IID_IBDA_NetworkProvider_Value = Guid.initString("fd501041-8ebe-11ce-8183-00aa00577da2");
pub const IID_IBDA_NetworkProvider = &IID_IBDA_NetworkProvider_Value;
pub const IBDA_NetworkProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutSignalSource: *const fn (
            self: *const IBDA_NetworkProvider,
            ul_signal_source: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalSource: *const fn (
            self: *const IBDA_NetworkProvider,
            pul_signal_source: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkType: *const fn (
            self: *const IBDA_NetworkProvider,
            pguid_network_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutTuningSpace: *const fn (
            self: *const IBDA_NetworkProvider,
            guid_tuning_space: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuningSpace: *const fn (
            self: *const IBDA_NetworkProvider,
            pguid_tuing_space: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDeviceFilter: *const fn (
            self: *const IBDA_NetworkProvider,
            p_unk_filter_control: ?*IUnknown,
            ppv_regisitration_context: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterDeviceFilter: *const fn (
            self: *const IBDA_NetworkProvider,
            pv_registration_context: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putSignalSource(self: *const T, ul_signal_source_: u32) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).PutSignalSource(@as(*const IBDA_NetworkProvider, @ptrCast(self)), ul_signal_source_);
            }
            pub inline fn getSignalSource(self: *const T, pul_signal_source_: ?*u32) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetSignalSource(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pul_signal_source_);
            }
            pub inline fn getNetworkType(self: *const T, pguid_network_type_: ?*Guid) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetNetworkType(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pguid_network_type_);
            }
            pub inline fn putTuningSpace(self: *const T, guid_tuning_space_: ?*const Guid) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).PutTuningSpace(@as(*const IBDA_NetworkProvider, @ptrCast(self)), guid_tuning_space_);
            }
            pub inline fn getTuningSpace(self: *const T, pguid_tuing_space_: ?*Guid) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetTuningSpace(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pguid_tuing_space_);
            }
            pub inline fn registerDeviceFilter(self: *const T, p_unk_filter_control_: ?*IUnknown, ppv_regisitration_context_: ?*u32) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).RegisterDeviceFilter(@as(*const IBDA_NetworkProvider, @ptrCast(self)), p_unk_filter_control_, ppv_regisitration_context_);
            }
            pub inline fn unRegisterDeviceFilter(self: *const T, pv_registration_context_: u32) HRESULT {
                return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).UnRegisterDeviceFilter(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pv_registration_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_EthernetFilter_Value = Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_EthernetFilter = &IID_IBDA_EthernetFilter_Value;
pub const IBDA_EthernetFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: *const fn (
            self: *const IBDA_EthernetFilter,
            pulcb_addresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: *const fn (
            self: *const IBDA_EthernetFilter,
            ulcb_addresses: u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: *const fn (
            self: *const IBDA_EthernetFilter,
            pulcb_addresses: ?*u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: *const fn (
            self: *const IBDA_EthernetFilter,
            ul_mode_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: *const fn (
            self: *const IBDA_EthernetFilter,
            pul_mode_mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMulticastListSize(self: *const T, pulcb_addresses_: ?*u32) HRESULT {
                return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pulcb_addresses_);
            }
            pub inline fn putMulticastList(self: *const T, ulcb_addresses_: u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_EthernetFilter, @ptrCast(self)), ulcb_addresses_, p_address_list_);
            }
            pub inline fn getMulticastList(self: *const T, pulcb_addresses_: ?*u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pulcb_addresses_, p_address_list_);
            }
            pub inline fn putMulticastMode(self: *const T, ul_mode_mask_: u32) HRESULT {
                return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_EthernetFilter, @ptrCast(self)), ul_mode_mask_);
            }
            pub inline fn getMulticastMode(self: *const T, pul_mode_mask_: ?*u32) HRESULT {
                return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pul_mode_mask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV4Filter_Value = Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_IPV4Filter = &IID_IBDA_IPV4Filter_Value;
pub const IBDA_IPV4Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: *const fn (
            self: *const IBDA_IPV4Filter,
            pulcb_addresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: *const fn (
            self: *const IBDA_IPV4Filter,
            ulcb_addresses: u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: *const fn (
            self: *const IBDA_IPV4Filter,
            pulcb_addresses: ?*u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: *const fn (
            self: *const IBDA_IPV4Filter,
            ul_mode_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: *const fn (
            self: *const IBDA_IPV4Filter,
            pul_mode_mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMulticastListSize(self: *const T, pulcb_addresses_: ?*u32) HRESULT {
                return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pulcb_addresses_);
            }
            pub inline fn putMulticastList(self: *const T, ulcb_addresses_: u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_IPV4Filter, @ptrCast(self)), ulcb_addresses_, p_address_list_);
            }
            pub inline fn getMulticastList(self: *const T, pulcb_addresses_: ?*u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pulcb_addresses_, p_address_list_);
            }
            pub inline fn putMulticastMode(self: *const T, ul_mode_mask_: u32) HRESULT {
                return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_IPV4Filter, @ptrCast(self)), ul_mode_mask_);
            }
            pub inline fn getMulticastMode(self: *const T, pul_mode_mask_: ?*u32) HRESULT {
                return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pul_mode_mask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV6Filter_Value = Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const IID_IBDA_IPV6Filter = &IID_IBDA_IPV6Filter_Value;
pub const IBDA_IPV6Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: *const fn (
            self: *const IBDA_IPV6Filter,
            pulcb_addresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: *const fn (
            self: *const IBDA_IPV6Filter,
            ulcb_addresses: u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: *const fn (
            self: *const IBDA_IPV6Filter,
            pulcb_addresses: ?*u32,
            p_address_list: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: *const fn (
            self: *const IBDA_IPV6Filter,
            ul_mode_mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: *const fn (
            self: *const IBDA_IPV6Filter,
            pul_mode_mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMulticastListSize(self: *const T, pulcb_addresses_: ?*u32) HRESULT {
                return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pulcb_addresses_);
            }
            pub inline fn putMulticastList(self: *const T, ulcb_addresses_: u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_IPV6Filter, @ptrCast(self)), ulcb_addresses_, p_address_list_);
            }
            pub inline fn getMulticastList(self: *const T, pulcb_addresses_: ?*u32, p_address_list_: [*:0]u8) HRESULT {
                return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pulcb_addresses_, p_address_list_);
            }
            pub inline fn putMulticastMode(self: *const T, ul_mode_mask_: u32) HRESULT {
                return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_IPV6Filter, @ptrCast(self)), ul_mode_mask_);
            }
            pub inline fn getMulticastMode(self: *const T, pul_mode_mask_: ?*u32) HRESULT {
                return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pul_mode_mask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DeviceControl_Value = Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const IID_IBDA_DeviceControl = &IID_IBDA_DeviceControl_Value;
pub const IBDA_DeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChanges: *const fn (
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckChanges: *const fn (
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitChanges: *const fn (
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChangeState: *const fn (
            self: *const IBDA_DeviceControl,
            p_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startChanges(self: *const T) HRESULT {
                return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).StartChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
            }
            pub inline fn checkChanges(self: *const T) HRESULT {
                return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).CheckChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
            }
            pub inline fn commitChanges(self: *const T) HRESULT {
                return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).CommitChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
            }
            pub inline fn getChangeState(self: *const T, p_state_: ?*u32) HRESULT {
                return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).GetChangeState(@as(*const IBDA_DeviceControl, @ptrCast(self)), p_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_PinControl_Value = Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const IID_IBDA_PinControl = &IID_IBDA_PinControl_Value;
pub const IBDA_PinControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPinID: *const fn (
            self: *const IBDA_PinControl,
            pul_pin_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPinType: *const fn (
            self: *const IBDA_PinControl,
            pul_pin_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegistrationContext: *const fn (
            self: *const IBDA_PinControl,
            pul_registration_ctx: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPinID(self: *const T, pul_pin_i_d_: ?*u32) HRESULT {
                return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).GetPinID(@as(*const IBDA_PinControl, @ptrCast(self)), pul_pin_i_d_);
            }
            pub inline fn getPinType(self: *const T, pul_pin_type_: ?*u32) HRESULT {
                return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).GetPinType(@as(*const IBDA_PinControl, @ptrCast(self)), pul_pin_type_);
            }
            pub inline fn registrationContext(self: *const T, pul_registration_ctx_: ?*u32) HRESULT {
                return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).RegistrationContext(@as(*const IBDA_PinControl, @ptrCast(self)), pul_registration_ctx_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalProperties_Value = Guid.initString("d2f1644b-b409-11d2-bc69-00a0c9ee9e16");
pub const IID_IBDA_SignalProperties = &IID_IBDA_SignalProperties_Value;
pub const IBDA_SignalProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutNetworkType: *const fn (
            self: *const IBDA_SignalProperties,
            guid_network_type: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkType: *const fn (
            self: *const IBDA_SignalProperties,
            pguid_network_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutSignalSource: *const fn (
            self: *const IBDA_SignalProperties,
            ul_signal_source: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalSource: *const fn (
            self: *const IBDA_SignalProperties,
            pul_signal_source: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutTuningSpace: *const fn (
            self: *const IBDA_SignalProperties,
            guid_tuning_space: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuningSpace: *const fn (
            self: *const IBDA_SignalProperties,
            pguid_tuing_space: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putNetworkType(self: *const T, guid_network_type_: ?*const Guid) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutNetworkType(@as(*const IBDA_SignalProperties, @ptrCast(self)), guid_network_type_);
            }
            pub inline fn getNetworkType(self: *const T, pguid_network_type_: ?*Guid) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetNetworkType(@as(*const IBDA_SignalProperties, @ptrCast(self)), pguid_network_type_);
            }
            pub inline fn putSignalSource(self: *const T, ul_signal_source_: u32) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutSignalSource(@as(*const IBDA_SignalProperties, @ptrCast(self)), ul_signal_source_);
            }
            pub inline fn getSignalSource(self: *const T, pul_signal_source_: ?*u32) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetSignalSource(@as(*const IBDA_SignalProperties, @ptrCast(self)), pul_signal_source_);
            }
            pub inline fn putTuningSpace(self: *const T, guid_tuning_space_: ?*const Guid) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutTuningSpace(@as(*const IBDA_SignalProperties, @ptrCast(self)), guid_tuning_space_);
            }
            pub inline fn getTuningSpace(self: *const T, pguid_tuing_space_: ?*Guid) HRESULT {
                return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetTuningSpace(@as(*const IBDA_SignalProperties, @ptrCast(self)), pguid_tuing_space_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalStatistics_Value = Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const IID_IBDA_SignalStatistics = &IID_IBDA_SignalStatistics_Value;
pub const IBDA_SignalStatistics = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalStrength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            l_db_strength: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            pl_db_strength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalQuality: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            l_percent_quality: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalQuality: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            pl_percent_quality: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPresent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            f_present: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPresent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            pf_present: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalLocked: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            f_locked: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalLocked: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            pf_locked: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SampleTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            lms_sample_time: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SampleTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_SignalStatistics,
            plms_sample_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putSignalStrength(self: *const T, l_db_strength_: i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalStrength(@as(*const IBDA_SignalStatistics, @ptrCast(self)), l_db_strength_);
            }
            pub inline fn getSignalStrength(self: *const T, pl_db_strength_: ?*i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalStrength(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pl_db_strength_);
            }
            pub inline fn putSignalQuality(self: *const T, l_percent_quality_: i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalQuality(@as(*const IBDA_SignalStatistics, @ptrCast(self)), l_percent_quality_);
            }
            pub inline fn getSignalQuality(self: *const T, pl_percent_quality_: ?*i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalQuality(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pl_percent_quality_);
            }
            pub inline fn putSignalPresent(self: *const T, f_present_: BOOLEAN) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalPresent(@as(*const IBDA_SignalStatistics, @ptrCast(self)), f_present_);
            }
            pub inline fn getSignalPresent(self: *const T, pf_present_: ?*u8) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalPresent(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pf_present_);
            }
            pub inline fn putSignalLocked(self: *const T, f_locked_: BOOLEAN) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalLocked(@as(*const IBDA_SignalStatistics, @ptrCast(self)), f_locked_);
            }
            pub inline fn getSignalLocked(self: *const T, pf_locked_: ?*u8) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalLocked(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pf_locked_);
            }
            pub inline fn putSampleTime(self: *const T, lms_sample_time_: i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SampleTime(@as(*const IBDA_SignalStatistics, @ptrCast(self)), lms_sample_time_);
            }
            pub inline fn getSampleTime(self: *const T, plms_sample_time_: ?*i32) HRESULT {
                return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SampleTime(@as(*const IBDA_SignalStatistics, @ptrCast(self)), plms_sample_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_Topology_Value = Guid.initString("79b56888-7fea-4690-b45d-38fd3c7849be");
pub const IID_IBDA_Topology = &IID_IBDA_Topology_Value;
pub const IBDA_Topology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNodeTypes: *const fn (
            self: *const IBDA_Topology,
            pulc_node_types: ?*u32,
            ulc_node_types_max: u32,
            rgul_node_types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeDescriptors: *const fn (
            self: *const IBDA_Topology,
            ulc_node_descriptors: ?*u32,
            ulc_node_descriptors_max: u32,
            rg_node_descriptors: [*]BDANODE_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeInterfaces: *const fn (
            self: *const IBDA_Topology,
            ul_node_type: u32,
            pulc_interfaces: ?*u32,
            ulc_interfaces_max: u32,
            rgguid_interfaces: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPinTypes: *const fn (
            self: *const IBDA_Topology,
            pulc_pin_types: ?*u32,
            ulc_pin_types_max: u32,
            rgul_pin_types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTemplateConnections: *const fn (
            self: *const IBDA_Topology,
            pulc_connections: ?*u32,
            ulc_connections_max: u32,
            rg_connections: [*]BDA_TEMPLATE_CONNECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePin: *const fn (
            self: *const IBDA_Topology,
            ul_pin_type: u32,
            pul_pin_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePin: *const fn (
            self: *const IBDA_Topology,
            ul_pin_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: *const fn (
            self: *const IBDA_Topology,
            ul_pin_id: u32,
            p_media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMedium: *const fn (
            self: *const IBDA_Topology,
            ul_pin_id: u32,
            p_medium: ?*REGPINMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTopology: *const fn (
            self: *const IBDA_Topology,
            ul_input_pin_id: u32,
            ul_output_pin_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlNode: *const fn (
            self: *const IBDA_Topology,
            ul_input_pin_id: u32,
            ul_output_pin_id: u32,
            ul_node_type: u32,
            pp_control_node: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNodeTypes(self: *const T, pulc_node_types_: ?*u32, ulc_node_types_max_: u32, rgul_node_types_: [*]u32) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeTypes(@as(*const IBDA_Topology, @ptrCast(self)), pulc_node_types_, ulc_node_types_max_, rgul_node_types_);
            }
            pub inline fn getNodeDescriptors(self: *const T, ulc_node_descriptors_: ?*u32, ulc_node_descriptors_max_: u32, rg_node_descriptors_: [*]BDANODE_DESCRIPTOR) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeDescriptors(@as(*const IBDA_Topology, @ptrCast(self)), ulc_node_descriptors_, ulc_node_descriptors_max_, rg_node_descriptors_);
            }
            pub inline fn getNodeInterfaces(self: *const T, ul_node_type_: u32, pulc_interfaces_: ?*u32, ulc_interfaces_max_: u32, rgguid_interfaces_: [*]Guid) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeInterfaces(@as(*const IBDA_Topology, @ptrCast(self)), ul_node_type_, pulc_interfaces_, ulc_interfaces_max_, rgguid_interfaces_);
            }
            pub inline fn getPinTypes(self: *const T, pulc_pin_types_: ?*u32, ulc_pin_types_max_: u32, rgul_pin_types_: [*]u32) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetPinTypes(@as(*const IBDA_Topology, @ptrCast(self)), pulc_pin_types_, ulc_pin_types_max_, rgul_pin_types_);
            }
            pub inline fn getTemplateConnections(self: *const T, pulc_connections_: ?*u32, ulc_connections_max_: u32, rg_connections_: [*]BDA_TEMPLATE_CONNECTION) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetTemplateConnections(@as(*const IBDA_Topology, @ptrCast(self)), pulc_connections_, ulc_connections_max_, rg_connections_);
            }
            pub inline fn createPin(self: *const T, ul_pin_type_: u32, pul_pin_id_: ?*u32) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).CreatePin(@as(*const IBDA_Topology, @ptrCast(self)), ul_pin_type_, pul_pin_id_);
            }
            pub inline fn deletePin(self: *const T, ul_pin_id_: u32) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).DeletePin(@as(*const IBDA_Topology, @ptrCast(self)), ul_pin_id_);
            }
            pub inline fn setMediaType(self: *const T, ul_pin_id_: u32, p_media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IBDA_Topology, @ptrCast(self)), ul_pin_id_, p_media_type_);
            }
            pub inline fn setMedium(self: *const T, ul_pin_id_: u32, p_medium_: ?*REGPINMEDIUM) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).SetMedium(@as(*const IBDA_Topology, @ptrCast(self)), ul_pin_id_, p_medium_);
            }
            pub inline fn createTopology(self: *const T, ul_input_pin_id_: u32, ul_output_pin_id_: u32) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).CreateTopology(@as(*const IBDA_Topology, @ptrCast(self)), ul_input_pin_id_, ul_output_pin_id_);
            }
            pub inline fn getControlNode(self: *const T, ul_input_pin_id_: u32, ul_output_pin_id_: u32, ul_node_type_: u32, pp_control_node_: ?*?*IUnknown) HRESULT {
                return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetControlNode(@as(*const IBDA_Topology, @ptrCast(self)), ul_input_pin_id_, ul_output_pin_id_, ul_node_type_, pp_control_node_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_VoidTransform_Value = Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_VoidTransform = &IID_IBDA_VoidTransform_Value;
pub const IBDA_VoidTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: *const fn (
            self: *const IBDA_VoidTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IBDA_VoidTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const IBDA_VoidTransform.VTable, @ptrCast(self.vtable)).Start(@as(*const IBDA_VoidTransform, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IBDA_VoidTransform.VTable, @ptrCast(self.vtable)).Stop(@as(*const IBDA_VoidTransform, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NullTransform_Value = Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_NullTransform = &IID_IBDA_NullTransform_Value;
pub const IBDA_NullTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: *const fn (
            self: *const IBDA_NullTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IBDA_NullTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn start(self: *const T) HRESULT {
                return @as(*const IBDA_NullTransform.VTable, @ptrCast(self.vtable)).Start(@as(*const IBDA_NullTransform, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IBDA_NullTransform.VTable, @ptrCast(self.vtable)).Stop(@as(*const IBDA_NullTransform, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_FrequencyFilter_Value = Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_FrequencyFilter = &IID_IBDA_FrequencyFilter_Value;
pub const IBDA_FrequencyFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Autotune: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            ul_transponder: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Autotune: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            pul_transponder: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Frequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            ul_frequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            pul_frequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Polarity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            polarity: Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Polarity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            p_polarity: ?*Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Range: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            ul_range: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Range: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            pul_range: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            ul_bandwidth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            pul_bandwidth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMultiplier: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            ul_multiplier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMultiplier: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_FrequencyFilter,
            pul_multiplier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putAutotune(self: *const T, ul_transponder_: u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Autotune(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ul_transponder_);
            }
            pub inline fn getAutotune(self: *const T, pul_transponder_: ?*u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Autotune(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pul_transponder_);
            }
            pub inline fn putFrequency(self: *const T, ul_frequency_: u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Frequency(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ul_frequency_);
            }
            pub inline fn getFrequency(self: *const T, pul_frequency_: ?*u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Frequency(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pul_frequency_);
            }
            pub inline fn putPolarity(self: *const T, polarity_: Polarisation) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Polarity(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), polarity_);
            }
            pub inline fn getPolarity(self: *const T, p_polarity_: ?*Polarisation) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Polarity(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), p_polarity_);
            }
            pub inline fn putRange(self: *const T, ul_range_: u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Range(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ul_range_);
            }
            pub inline fn getRange(self: *const T, pul_range_: ?*u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Range(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pul_range_);
            }
            pub inline fn putBandwidth(self: *const T, ul_bandwidth_: u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Bandwidth(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ul_bandwidth_);
            }
            pub inline fn getBandwidth(self: *const T, pul_bandwidth_: ?*u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pul_bandwidth_);
            }
            pub inline fn putFrequencyMultiplier(self: *const T, ul_multiplier_: u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_FrequencyMultiplier(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ul_multiplier_);
            }
            pub inline fn getFrequencyMultiplier(self: *const T, pul_multiplier_: ?*u32) HRESULT {
                return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_FrequencyMultiplier(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pul_multiplier_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_LNBInfo_Value = Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const IID_IBDA_LNBInfo = &IID_IBDA_LNBInfo_Value;
pub const IBDA_LNBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyLowBand: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            ul_l_o_f_low: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyLowBand: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            pul_l_o_f_low: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyHighBand: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            ul_l_o_f_high: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyHighBand: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            pul_l_o_f_high: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighLowSwitchFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            ul_switch_frequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighLowSwitchFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_LNBInfo,
            pul_switch_frequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putLocalOscilatorFrequencyLowBand(self: *const T, ul_l_o_f_low_: u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_LocalOscilatorFrequencyLowBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), ul_l_o_f_low_);
            }
            pub inline fn getLocalOscilatorFrequencyLowBand(self: *const T, pul_l_o_f_low_: ?*u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_LocalOscilatorFrequencyLowBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), pul_l_o_f_low_);
            }
            pub inline fn putLocalOscilatorFrequencyHighBand(self: *const T, ul_l_o_f_high_: u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_LocalOscilatorFrequencyHighBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), ul_l_o_f_high_);
            }
            pub inline fn getLocalOscilatorFrequencyHighBand(self: *const T, pul_l_o_f_high_: ?*u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_LocalOscilatorFrequencyHighBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), pul_l_o_f_high_);
            }
            pub inline fn putHighLowSwitchFrequency(self: *const T, ul_switch_frequency_: u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_HighLowSwitchFrequency(@as(*const IBDA_LNBInfo, @ptrCast(self)), ul_switch_frequency_);
            }
            pub inline fn getHighLowSwitchFrequency(self: *const T, pul_switch_frequency_: ?*u32) HRESULT {
                return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_HighLowSwitchFrequency(@as(*const IBDA_LNBInfo, @ptrCast(self)), pul_switch_frequency_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiseqCommand_Value = Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const IID_IBDA_DiseqCommand = &IID_IBDA_DiseqCommand_Value;
pub const IBDA_DiseqCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableDiseqCommands: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            b_enable: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            ul_l_n_b_source: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqUseToneBurst: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            b_use_tone_burst: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqRepeats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            ul_repeats: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqSendCommand: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            ul_request_id: u32,
            ulcb_command_len: u32,
            pb_command: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiseqResponse: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DiseqCommand,
            ul_request_id: u32,
            pulcb_response_len: ?*u32,
            pb_response: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putEnableDiseqCommands(self: *const T, b_enable_: BOOLEAN) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_EnableDiseqCommands(@as(*const IBDA_DiseqCommand, @ptrCast(self)), b_enable_);
            }
            pub inline fn putDiseqLNBSource(self: *const T, ul_l_n_b_source_: u32) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqLNBSource(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ul_l_n_b_source_);
            }
            pub inline fn putDiseqUseToneBurst(self: *const T, b_use_tone_burst_: BOOLEAN) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqUseToneBurst(@as(*const IBDA_DiseqCommand, @ptrCast(self)), b_use_tone_burst_);
            }
            pub inline fn putDiseqRepeats(self: *const T, ul_repeats_: u32) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqRepeats(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ul_repeats_);
            }
            pub inline fn putDiseqSendCommand(self: *const T, ul_request_id_: u32, ulcb_command_len_: u32, pb_command_: [*:0]u8) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqSendCommand(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ul_request_id_, ulcb_command_len_, pb_command_);
            }
            pub inline fn getDiseqResponse(self: *const T, ul_request_id_: u32, pulcb_response_len_: ?*u32, pb_response_: [*:0]u8) HRESULT {
                return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).get_DiseqResponse(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ul_request_id_, pulcb_response_len_, pb_response_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AutoDemodulate_Value = Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_AutoDemodulate = &IID_IBDA_AutoDemodulate_Value;
pub const IBDA_AutoDemodulate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoDemodulate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_AutoDemodulate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putAutoDemodulate(self: *const T) HRESULT {
                return @as(*const IBDA_AutoDemodulate.VTable, @ptrCast(self.vtable)).put_AutoDemodulate(@as(*const IBDA_AutoDemodulate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_AutoDemodulateEx_Value = Guid.initString("34518d13-1182-48e6-b28f-b24987787326");
pub const IID_IBDA_AutoDemodulateEx = &IID_IBDA_AutoDemodulateEx_Value;
pub const IBDA_AutoDemodulateEx = extern struct {
    pub const VTable = extern struct {
        base: IBDA_AutoDemodulate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedDeviceNodeTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_AutoDemodulateEx,
            ulc_device_node_types_max: u32,
            pulc_device_node_types: ?*u32,
            pguid_device_node_types: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedVideoFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_AutoDemodulateEx,
            pul_a_m_tuner_mode_type: ?*u32,
            pul_analog_video_standard: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuxInputCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_AutoDemodulateEx,
            pul_composite_count: ?*u32,
            pul_svideo_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBDA_AutoDemodulate.MethodMixin(T);
            pub inline fn getSupportedDeviceNodeTypes(self: *const T, ulc_device_node_types_max_: u32, pulc_device_node_types_: ?*u32, pguid_device_node_types_: ?*Guid) HRESULT {
                return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_SupportedDeviceNodeTypes(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), ulc_device_node_types_max_, pulc_device_node_types_, pguid_device_node_types_);
            }
            pub inline fn getSupportedVideoFormats(self: *const T, pul_a_m_tuner_mode_type_: ?*u32, pul_analog_video_standard_: ?*u32) HRESULT {
                return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_SupportedVideoFormats(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), pul_a_m_tuner_mode_type_, pul_analog_video_standard_);
            }
            pub inline fn getAuxInputCount(self: *const T, pul_composite_count_: ?*u32, pul_svideo_count_: ?*u32) HRESULT {
                return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_AuxInputCount(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), pul_composite_count_, pul_svideo_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator_Value = Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const IID_IBDA_DigitalDemodulator = &IID_IBDA_DigitalDemodulator_Value;
pub const IBDA_DigitalDemodulator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModulationType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_modulation_type: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModulationType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_modulation_type: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECMethod: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_method: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECMethod: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_method: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_rate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_rate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECMethod: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_method: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECMethod: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_method: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_rate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_f_e_c_rate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_symbol_rate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_symbol_rate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_spectral_inversion: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator,
            p_spectral_inversion: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putModulationType(self: *const T, p_modulation_type_: ?*ModulationType) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_ModulationType(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_modulation_type_);
            }
            pub inline fn getModulationType(self: *const T, p_modulation_type_: ?*ModulationType) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_ModulationType(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_modulation_type_);
            }
            pub inline fn putInnerFECMethod(self: *const T, p_f_e_c_method_: ?*FECMethod) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_InnerFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_method_);
            }
            pub inline fn getInnerFECMethod(self: *const T, p_f_e_c_method_: ?*FECMethod) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_InnerFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_method_);
            }
            pub inline fn putInnerFECRate(self: *const T, p_f_e_c_rate_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_InnerFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_rate_);
            }
            pub inline fn getInnerFECRate(self: *const T, p_f_e_c_rate_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_InnerFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_rate_);
            }
            pub inline fn putOuterFECMethod(self: *const T, p_f_e_c_method_: ?*FECMethod) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_OuterFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_method_);
            }
            pub inline fn getOuterFECMethod(self: *const T, p_f_e_c_method_: ?*FECMethod) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_OuterFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_method_);
            }
            pub inline fn putOuterFECRate(self: *const T, p_f_e_c_rate_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_OuterFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_rate_);
            }
            pub inline fn getOuterFECRate(self: *const T, p_f_e_c_rate_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_OuterFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_f_e_c_rate_);
            }
            pub inline fn putSymbolRate(self: *const T, p_symbol_rate_: ?*u32) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_SymbolRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_symbol_rate_);
            }
            pub inline fn getSymbolRate(self: *const T, p_symbol_rate_: ?*u32) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_SymbolRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_symbol_rate_);
            }
            pub inline fn putSpectralInversion(self: *const T, p_spectral_inversion_: ?*SpectralInversion) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_SpectralInversion(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_spectral_inversion_);
            }
            pub inline fn getSpectralInversion(self: *const T, p_spectral_inversion_: ?*SpectralInversion) HRESULT {
                return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_SpectralInversion(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), p_spectral_inversion_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator2_Value = Guid.initString("525ed3ee-5cf3-4e1e-9a06-5368a84f9a6e");
pub const IID_IBDA_DigitalDemodulator2 = &IID_IBDA_DigitalDemodulator2_Value;
pub const IBDA_DigitalDemodulator2 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GuardInterval: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_guard_interval: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GuardInterval: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_guard_interval: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransmissionMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_transmission_mode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransmissionMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_transmission_mode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RollOff: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_roll_off: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RollOff: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_roll_off: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pilot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_pilot: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pilot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator2,
            p_pilot: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBDA_DigitalDemodulator.MethodMixin(T);
            pub inline fn putGuardInterval(self: *const T, p_guard_interval_: ?*GuardInterval) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_GuardInterval(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_guard_interval_);
            }
            pub inline fn getGuardInterval(self: *const T, p_guard_interval_: ?*GuardInterval) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_GuardInterval(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_guard_interval_);
            }
            pub inline fn putTransmissionMode(self: *const T, p_transmission_mode_: ?*TransmissionMode) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_TransmissionMode(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_transmission_mode_);
            }
            pub inline fn getTransmissionMode(self: *const T, p_transmission_mode_: ?*TransmissionMode) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_TransmissionMode(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_transmission_mode_);
            }
            pub inline fn putRollOff(self: *const T, p_roll_off_: ?*RollOff) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_RollOff(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_roll_off_);
            }
            pub inline fn getRollOff(self: *const T, p_roll_off_: ?*RollOff) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_RollOff(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_roll_off_);
            }
            pub inline fn putPilot(self: *const T, p_pilot_: ?*Pilot) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_Pilot(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_pilot_);
            }
            pub inline fn getPilot(self: *const T, p_pilot_: ?*Pilot) HRESULT {
                return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_Pilot(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), p_pilot_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator3_Value = Guid.initString("13f19604-7d32-4359-93a2-a05205d90ac9");
pub const IID_IBDA_DigitalDemodulator3 = &IID_IBDA_DigitalDemodulator3_Value;
pub const IBDA_DigitalDemodulator3 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalTimeouts: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator3,
            p_signal_timeouts: ?*BDA_SIGNAL_TIMEOUTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalTimeouts: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator3,
            p_signal_timeouts: ?*BDA_SIGNAL_TIMEOUTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PLPNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator3,
            p_p_l_p_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PLPNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_DigitalDemodulator3,
            p_p_l_p_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBDA_DigitalDemodulator2.MethodMixin(T);
            pub inline fn putSignalTimeouts(self: *const T, p_signal_timeouts_: ?*BDA_SIGNAL_TIMEOUTS) HRESULT {
                return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).put_SignalTimeouts(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), p_signal_timeouts_);
            }
            pub inline fn getSignalTimeouts(self: *const T, p_signal_timeouts_: ?*BDA_SIGNAL_TIMEOUTS) HRESULT {
                return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).get_SignalTimeouts(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), p_signal_timeouts_);
            }
            pub inline fn putPLPNumber(self: *const T, p_p_l_p_number_: ?*u32) HRESULT {
                return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).put_PLPNumber(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), p_p_l_p_number_);
            }
            pub inline fn getPLPNumber(self: *const T, p_p_l_p_number_: ?*u32) HRESULT {
                return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).get_PLPNumber(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), p_p_l_p_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KSPROPERTY_IPSINK = enum(u32) {
    MULTICASTLIST = 0,
    ADAPTER_DESCRIPTION = 1,
    ADAPTER_ADDRESS = 2,
    _,
    pub fn initFlags(o: struct {
        MULTICASTLIST: u1 = 0,
        ADAPTER_DESCRIPTION: u1 = 0,
        ADAPTER_ADDRESS: u1 = 0,
    }) KSPROPERTY_IPSINK {
        return @as(KSPROPERTY_IPSINK, @enumFromInt((if (o.MULTICASTLIST == 1) @intFromEnum(KSPROPERTY_IPSINK.MULTICASTLIST) else 0) | (if (o.ADAPTER_DESCRIPTION == 1) @intFromEnum(KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION) else 0) | (if (o.ADAPTER_ADDRESS == 1) @intFromEnum(KSPROPERTY_IPSINK.ADAPTER_ADDRESS) else 0)));
    }
};
pub const KSPROPERTY_IPSINK_MULTICASTLIST = KSPROPERTY_IPSINK.MULTICASTLIST;
pub const KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION = KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION;
pub const KSPROPERTY_IPSINK_ADAPTER_ADDRESS = KSPROPERTY_IPSINK.ADAPTER_ADDRESS;

const IID_ICCSubStreamFiltering_Value = Guid.initString("4b2bd7ea-8347-467b-8dbf-62f784929cc3");
pub const IID_ICCSubStreamFiltering = &IID_ICCSubStreamFiltering_Value;
pub const ICCSubStreamFiltering = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubstreamTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICCSubStreamFiltering,
            p_types: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubstreamTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICCSubStreamFiltering,
            types: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSubstreamTypes(self: *const T, p_types_: ?*i32) HRESULT {
                return @as(*const ICCSubStreamFiltering.VTable, @ptrCast(self.vtable)).get_SubstreamTypes(@as(*const ICCSubStreamFiltering, @ptrCast(self)), p_types_);
            }
            pub inline fn putSubstreamTypes(self: *const T, types_: i32) HRESULT {
                return @as(*const ICCSubStreamFiltering.VTable, @ptrCast(self.vtable)).put_SubstreamTypes(@as(*const ICCSubStreamFiltering, @ptrCast(self)), types_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkControl_Value = Guid.initString("3f4dc8e2-4050-11d3-8f4b-00c04f7971e2");
pub const IID_IBDA_IPSinkControl = &IID_IBDA_IPSinkControl_Value;
pub const IBDA_IPSinkControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastList: *const fn (
            self: *const IBDA_IPSinkControl,
            pulcb_size: ?*u32,
            pb_buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterIPAddress: *const fn (
            self: *const IBDA_IPSinkControl,
            pulcb_size: ?*u32,
            pb_buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMulticastList(self: *const T, pulcb_size_: ?*u32, pb_buffer_: ?*?*u8) HRESULT {
                return @as(*const IBDA_IPSinkControl.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPSinkControl, @ptrCast(self)), pulcb_size_, pb_buffer_);
            }
            pub inline fn getAdapterIPAddress(self: *const T, pulcb_size_: ?*u32, pb_buffer_: ?*?*u8) HRESULT {
                return @as(*const IBDA_IPSinkControl.VTable, @ptrCast(self.vtable)).GetAdapterIPAddress(@as(*const IBDA_IPSinkControl, @ptrCast(self)), pulcb_size_, pb_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkInfo_Value = Guid.initString("a750108f-492e-4d51-95f7-649b23ff7ad7");
pub const IID_IBDA_IPSinkInfo = &IID_IBDA_IPSinkInfo_Value;
pub const IBDA_IPSinkInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MulticastList: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_IPSinkInfo,
            pulcb_addresses: ?*u32,
            ppb_address_list: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterIPAddress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_IPSinkInfo,
            pbstr_buffer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterDescription: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_IPSinkInfo,
            pbstr_buffer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMulticastList(self: *const T, pulcb_addresses_: ?*u32, ppb_address_list_: [*]?*u8) HRESULT {
                return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_MulticastList(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pulcb_addresses_, ppb_address_list_);
            }
            pub inline fn getAdapterIPAddress(self: *const T, pbstr_buffer_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_AdapterIPAddress(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pbstr_buffer_);
            }
            pub inline fn getAdapterDescription(self: *const T, pbstr_buffer_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_AdapterDescription(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pbstr_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPIDMap_Value = Guid.initString("afb6c2a2-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IEnumPIDMap = &IID_IEnumPIDMap_Value;
pub const IEnumPIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumPIDMap,
            c_request: u32,
            p_p_i_d_map: [*]PID_MAP,
            pc_received: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumPIDMap,
            c_records: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumPIDMap,
            pp_i_enum_p_i_d_map: ?*?*IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_request_: u32, p_p_i_d_map_: [*]PID_MAP, pc_received_: ?*u32) HRESULT {
                return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPIDMap, @ptrCast(self)), c_request_, p_p_i_d_map_, pc_received_);
            }
            pub inline fn skip(self: *const T, c_records_: u32) HRESULT {
                return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPIDMap, @ptrCast(self)), c_records_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPIDMap, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_i_enum_p_i_d_map_: ?*?*IEnumPIDMap) HRESULT {
                return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPIDMap, @ptrCast(self)), pp_i_enum_p_i_d_map_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2PIDMap_Value = Guid.initString("afb6c2a1-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IMPEG2PIDMap = &IID_IMPEG2PIDMap_Value;
pub const IMPEG2PIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapPID: *const fn (
            self: *const IMPEG2PIDMap,
            cul_p_i_d: u32,
            pul_p_i_d: ?*u32,
            media_sample_content: MEDIA_SAMPLE_CONTENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapPID: *const fn (
            self: *const IMPEG2PIDMap,
            cul_p_i_d: u32,
            pul_p_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPIDMap: *const fn (
            self: *const IMPEG2PIDMap,
            p_i_enum_p_i_d_map: ?*?*IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn mapPID(self: *const T, cul_p_i_d_: u32, pul_p_i_d_: ?*u32, media_sample_content_: MEDIA_SAMPLE_CONTENT) HRESULT {
                return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).MapPID(@as(*const IMPEG2PIDMap, @ptrCast(self)), cul_p_i_d_, pul_p_i_d_, media_sample_content_);
            }
            pub inline fn unmapPID(self: *const T, cul_p_i_d_: u32, pul_p_i_d_: ?*u32) HRESULT {
                return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).UnmapPID(@as(*const IMPEG2PIDMap, @ptrCast(self)), cul_p_i_d_, pul_p_i_d_);
            }
            pub inline fn enumPIDMap(self: *const T, p_i_enum_p_i_d_map_: ?*?*IEnumPIDMap) HRESULT {
                return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).EnumPIDMap(@as(*const IMPEG2PIDMap, @ptrCast(self)), p_i_enum_p_i_d_map_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFrequencyMap_Value = Guid.initString("06fb45c1-693c-4ea7-b79f-7a6a54d8def2");
pub const IID_IFrequencyMap = &IID_IFrequencyMap_Value;
pub const IFrequencyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMapping: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            ul_count: ?*u32,
            ppul_list: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMapping: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            ul_count: u32,
            p_list: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            pul_country_code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            ul_country_code: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultFrequencyMapping: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            ul_country_code: u32,
            pul_count: ?*u32,
            ppul_list: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCodeList: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFrequencyMap,
            pul_count: ?*u32,
            ppul_list: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFrequencyMapping(self: *const T, ul_count_: ?*u32, ppul_list_: ?*?*u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_FrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ul_count_, ppul_list_);
            }
            pub inline fn putFrequencyMapping(self: *const T, ul_count_: u32, p_list_: [*]u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).put_FrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ul_count_, p_list_);
            }
            pub inline fn getCountryCode(self: *const T, pul_country_code_: ?*u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IFrequencyMap, @ptrCast(self)), pul_country_code_);
            }
            pub inline fn putCountryCode(self: *const T, ul_country_code_: u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IFrequencyMap, @ptrCast(self)), ul_country_code_);
            }
            pub inline fn getDefaultFrequencyMapping(self: *const T, ul_country_code_: u32, pul_count_: ?*u32, ppul_list_: ?*?*u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_DefaultFrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ul_country_code_, pul_count_, ppul_list_);
            }
            pub inline fn getCountryCodeList(self: *const T, pul_count_: ?*u32, ppul_list_: ?*?*u32) HRESULT {
                return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_CountryCodeList(@as(*const IFrequencyMap, @ptrCast(self)), pul_count_, ppul_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_EasMessage_Value = Guid.initString("d806973d-3ebe-46de-8fbb-6358fe784208");
pub const IID_IBDA_EasMessage = &IID_IBDA_EasMessage_Value;
pub const IBDA_EasMessage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EasMessage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_EasMessage,
            ul_event_i_d: u32,
            pp_e_a_s_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEasMessage(self: *const T, ul_event_i_d_: u32, pp_e_a_s_object_: ?*?*IUnknown) HRESULT {
                return @as(*const IBDA_EasMessage.VTable, @ptrCast(self.vtable)).get_EasMessage(@as(*const IBDA_EasMessage, @ptrCast(self)), ul_event_i_d_, pp_e_a_s_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamInfo_Value = Guid.initString("8e882535-5f86-47ab-86cf-c281a72a0549");
pub const IID_IBDA_TransportStreamInfo = &IID_IBDA_TransportStreamInfo_Value;
pub const IBDA_TransportStreamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatTableTickCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_TransportStreamInfo,
            p_pat_tick_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPatTableTickCount(self: *const T, p_pat_tick_count_: ?*u32) HRESULT {
                return @as(*const IBDA_TransportStreamInfo.VTable, @ptrCast(self.vtable)).get_PatTableTickCount(@as(*const IBDA_TransportStreamInfo, @ptrCast(self)), p_pat_tick_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_ConditionalAccess_Value = Guid.initString("cd51f1e0-7be9-4123-8482-a2a796c0a6b0");
pub const IID_IBDA_ConditionalAccess = &IID_IBDA_ConditionalAccess_Value;
pub const IBDA_ConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardStatus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_ConditionalAccess,
            p_card_status: ?*SmartCardStatusType,
            p_card_association: ?*SmartCardAssociationType,
            pbstr_card_error: ?*?BSTR,
            pf_o_o_b_locked: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_ConditionalAccess,
            pbstr_card_name: ?*?BSTR,
            pbstr_card_manufacturer: ?*?BSTR,
            pf_daylight_savings: ?*i16,
            pby_rating_region: ?*u8,
            pl_time_zone_offset_minutes: ?*i32,
            pbstr_language: ?*?BSTR,
            p_e_a_location_code: ?*EALocationCodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardApplications: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_ConditionalAccess,
            pulc_applications: ?*u32,
            ulc_applications_max: u32,
            rg_applications: [*]SmartCardApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Entitlement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBDA_ConditionalAccess,
            us_virtual_channel: u16,
            p_entitlement: ?*EntitlementType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuneByChannel: *const fn (
            self: *const IBDA_ConditionalAccess,
            us_virtual_channel: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgram: *const fn (
            self: *const IBDA_ConditionalAccess,
            us_program_number: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProgram: *const fn (
            self: *const IBDA_ConditionalAccess,
            us_program_number: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProgram: *const fn (
            self: *const IBDA_ConditionalAccess,
            us_program_number: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleUI: *const fn (
            self: *const IBDA_ConditionalAccess,
            by_dialog_number: u8,
            pbstr_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InformUIClosed: *const fn (
            self: *const IBDA_ConditionalAccess,
            by_dialog_number: u8,
            close_reason: UICloseReasonType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSmartCardStatus(self: *const T, p_card_status_: ?*SmartCardStatusType, p_card_association_: ?*SmartCardAssociationType, pbstr_card_error_: ?*?BSTR, pf_o_o_b_locked_: ?*i16) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardStatus(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), p_card_status_, p_card_association_, pbstr_card_error_, pf_o_o_b_locked_);
            }
            pub inline fn getSmartCardInfo(self: *const T, pbstr_card_name_: ?*?BSTR, pbstr_card_manufacturer_: ?*?BSTR, pf_daylight_savings_: ?*i16, pby_rating_region_: ?*u8, pl_time_zone_offset_minutes_: ?*i32, pbstr_language_: ?*?BSTR, p_e_a_location_code_: ?*EALocationCodeType) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardInfo(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), pbstr_card_name_, pbstr_card_manufacturer_, pf_daylight_savings_, pby_rating_region_, pl_time_zone_offset_minutes_, pbstr_language_, p_e_a_location_code_);
            }
            pub inline fn getSmartCardApplications(self: *const T, pulc_applications_: ?*u32, ulc_applications_max_: u32, rg_applications_: [*]SmartCardApplication) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardApplications(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), pulc_applications_, ulc_applications_max_, rg_applications_);
            }
            pub inline fn getEntitlement(self: *const T, us_virtual_channel_: u16, p_entitlement_: ?*EntitlementType) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_Entitlement(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), us_virtual_channel_, p_entitlement_);
            }
            pub inline fn tuneByChannel(self: *const T, us_virtual_channel_: u16) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).TuneByChannel(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), us_virtual_channel_);
            }
            pub inline fn setProgram(self: *const T, us_program_number_: u16) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).SetProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), us_program_number_);
            }
            pub inline fn addProgram(self: *const T, us_program_number_: u16) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).AddProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), us_program_number_);
            }
            pub inline fn removeProgram(self: *const T, us_program_number_: u16) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).RemoveProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), us_program_number_);
            }
            pub inline fn getModuleUI(self: *const T, by_dialog_number_: u8, pbstr_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).GetModuleUI(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), by_dialog_number_, pbstr_u_r_l_);
            }
            pub inline fn informUIClosed(self: *const T, by_dialog_number_: u8, close_reason_: UICloseReasonType) HRESULT {
                return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).InformUIClosed(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), by_dialog_number_, close_reason_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiagnosticProperties_Value = Guid.initString("20e80cb5-c543-4c1b-8eb3-49e719eee7d4");
pub const IID_IBDA_DiagnosticProperties = &IID_IBDA_DiagnosticProperties_Value;
pub const IBDA_DiagnosticProperties = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPropertyBag.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_DRM_Value = Guid.initString("f98d88b0-1992-4cd6-a6d9-b9afab99330d");
pub const IID_IBDA_DRM = &IID_IBDA_DRM_Value;
pub const IBDA_DRM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDRMPairingStatus: *const fn (
            self: *const IBDA_DRM,
            pdw_status: ?*u32,
            ph_error: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformDRMPairing: *const fn (
            self: *const IBDA_DRM,
            f_sync: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDRMPairingStatus(self: *const T, pdw_status_: ?*u32, ph_error_: ?*HRESULT) HRESULT {
                return @as(*const IBDA_DRM.VTable, @ptrCast(self.vtable)).GetDRMPairingStatus(@as(*const IBDA_DRM, @ptrCast(self)), pdw_status_, ph_error_);
            }
            pub inline fn performDRMPairing(self: *const T, f_sync_: BOOL) HRESULT {
                return @as(*const IBDA_DRM.VTable, @ptrCast(self.vtable)).PerformDRMPairing(@as(*const IBDA_DRM, @ptrCast(self)), f_sync_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NameValueService_Value = Guid.initString("7f0b3150-7b81-4ad4-98e3-7e9097094301");
pub const IID_IBDA_NameValueService = &IID_IBDA_NameValueService_Value;
pub const IBDA_NameValueService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueNameByIndex: *const fn (
            self: *const IBDA_NameValueService,
            ul_index: u32,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: *const fn (
            self: *const IBDA_NameValueService,
            bstr_name: ?BSTR,
            bstr_language: ?BSTR,
            pbstr_value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: *const fn (
            self: *const IBDA_NameValueService,
            ul_dialog_request: u32,
            bstr_language: ?BSTR,
            bstr_name: ?BSTR,
            bstr_value: ?BSTR,
            ul_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getValueNameByIndex(self: *const T, ul_index_: u32, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).GetValueNameByIndex(@as(*const IBDA_NameValueService, @ptrCast(self)), ul_index_, pbstr_name_);
            }
            pub inline fn getValue(self: *const T, bstr_name_: ?BSTR, bstr_language_: ?BSTR, pbstr_value_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IBDA_NameValueService, @ptrCast(self)), bstr_name_, bstr_language_, pbstr_value_);
            }
            pub inline fn setValue(self: *const T, ul_dialog_request_: u32, bstr_language_: ?BSTR, bstr_name_: ?BSTR, bstr_value_: ?BSTR, ul_reserved_: u32) HRESULT {
                return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IBDA_NameValueService, @ptrCast(self)), ul_dialog_request_, bstr_language_, bstr_name_, bstr_value_, ul_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ConditionalAccessEx_Value = Guid.initString("497c3418-23cb-44ba-bb62-769f506fcea7");
pub const IID_IBDA_ConditionalAccessEx = &IID_IBDA_ConditionalAccessEx_Value;
pub const IBDA_ConditionalAccessEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckEntitlementToken: *const fn (
            self: *const IBDA_ConditionalAccessEx,
            ul_dialog_request: u32,
            bstr_language: ?BSTR,
            request_type: BDA_CONDITIONALACCESS_REQUESTTYPE,
            ulcb_entitlement_token_len: u32,
            pb_entitlement_token: [*:0]u8,
            pul_descramble_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaptureToken: *const fn (
            self: *const IBDA_ConditionalAccessEx,
            ulcb_capture_token_len: u32,
            pb_capture_token: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenBroadcastMmi: *const fn (
            self: *const IBDA_ConditionalAccessEx,
            ul_dialog_request: u32,
            bstr_language: ?BSTR,
            event_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseMmiDialog: *const fn (
            self: *const IBDA_ConditionalAccessEx,
            ul_dialog_request: u32,
            bstr_language: ?BSTR,
            ul_dialog_number: u32,
            reason_code: BDA_CONDITIONALACCESS_MMICLOSEREASON,
            pul_session_result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDialogRequestNumber: *const fn (
            self: *const IBDA_ConditionalAccessEx,
            pul_dialog_request_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn checkEntitlementToken(self: *const T, ul_dialog_request_: u32, bstr_language_: ?BSTR, request_type_: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcb_entitlement_token_len_: u32, pb_entitlement_token_: [*:0]u8, pul_descramble_status_: ?*u32) HRESULT {
                return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CheckEntitlementToken(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ul_dialog_request_, bstr_language_, request_type_, ulcb_entitlement_token_len_, pb_entitlement_token_, pul_descramble_status_);
            }
            pub inline fn setCaptureToken(self: *const T, ulcb_capture_token_len_: u32, pb_capture_token_: [*:0]u8) HRESULT {
                return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).SetCaptureToken(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ulcb_capture_token_len_, pb_capture_token_);
            }
            pub inline fn openBroadcastMmi(self: *const T, ul_dialog_request_: u32, bstr_language_: ?BSTR, event_id_: u32) HRESULT {
                return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).OpenBroadcastMmi(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ul_dialog_request_, bstr_language_, event_id_);
            }
            pub inline fn closeMmiDialog(self: *const T, ul_dialog_request_: u32, bstr_language_: ?BSTR, ul_dialog_number_: u32, reason_code_: BDA_CONDITIONALACCESS_MMICLOSEREASON, pul_session_result_: ?*u32) HRESULT {
                return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CloseMmiDialog(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ul_dialog_request_, bstr_language_, ul_dialog_number_, reason_code_, pul_session_result_);
            }
            pub inline fn createDialogRequestNumber(self: *const T, pul_dialog_request_number_: ?*u32) HRESULT {
                return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CreateDialogRequestNumber(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), pul_dialog_request_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ISDBConditionalAccess_Value = Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const IID_IBDA_ISDBConditionalAccess = &IID_IBDA_ISDBConditionalAccess_Value;
pub const IBDA_ISDBConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIsdbCasRequest: *const fn (
            self: *const IBDA_ISDBConditionalAccess,
            ul_request_id: u32,
            ulcb_request_buffer_len: u32,
            pb_request_buffer: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setIsdbCasRequest(self: *const T, ul_request_id_: u32, ulcb_request_buffer_len_: u32, pb_request_buffer_: [*:0]u8) HRESULT {
                return @as(*const IBDA_ISDBConditionalAccess.VTable, @ptrCast(self.vtable)).SetIsdbCasRequest(@as(*const IBDA_ISDBConditionalAccess, @ptrCast(self)), ul_request_id_, ulcb_request_buffer_len_, pb_request_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_EventingService_Value = Guid.initString("207c413f-00dc-4c61-bad6-6fee1ff07064");
pub const IID_IBDA_EventingService = &IID_IBDA_EventingService_Value;
pub const IBDA_EventingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteEvent: *const fn (
            self: *const IBDA_EventingService,
            ul_event_i_d: u32,
            ul_event_result: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn completeEvent(self: *const T, ul_event_i_d_: u32, ul_event_result_: u32) HRESULT {
                return @as(*const IBDA_EventingService.VTable, @ptrCast(self.vtable)).CompleteEvent(@as(*const IBDA_EventingService, @ptrCast(self)), ul_event_i_d_, ul_event_result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AUX_Value = Guid.initString("7def4c09-6e66-4567-a819-f0e17f4a81ab");
pub const IID_IBDA_AUX = &IID_IBDA_AUX_Value;
pub const IBDA_AUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: *const fn (
            self: *const IBDA_AUX,
            pdw_num_aux_inputs_b_s_t_r: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCapability: *const fn (
            self: *const IBDA_AUX,
            dw_index: u32,
            dw_input_i_d: ?*u32,
            p_connector_type: ?*Guid,
            conn_type_num: ?*u32,
            num_video_stds: ?*u32,
            analog_stds: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryCapabilities(self: *const T, pdw_num_aux_inputs_b_s_t_r_: ?*u32) HRESULT {
                return @as(*const IBDA_AUX.VTable, @ptrCast(self.vtable)).QueryCapabilities(@as(*const IBDA_AUX, @ptrCast(self)), pdw_num_aux_inputs_b_s_t_r_);
            }
            pub inline fn enumCapability(self: *const T, dw_index_: u32, dw_input_i_d_: ?*u32, p_connector_type_: ?*Guid, conn_type_num_: ?*u32, num_video_stds_: ?*u32, analog_stds_: ?*u64) HRESULT {
                return @as(*const IBDA_AUX.VTable, @ptrCast(self.vtable)).EnumCapability(@as(*const IBDA_AUX, @ptrCast(self)), dw_index_, dw_input_i_d_, p_connector_type_, conn_type_num_, num_video_stds_, analog_stds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_Encoder_Value = Guid.initString("3a8bad59-59fe-4559-a0ba-396cfaa98ae3");
pub const IID_IBDA_Encoder = &IID_IBDA_Encoder_Value;
pub const IBDA_Encoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: *const fn (
            self: *const IBDA_Encoder,
            num_audio_fmts: ?*u32,
            num_video_fmts: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAudioCapability: *const fn (
            self: *const IBDA_Encoder,
            fmt_index: u32,
            method_i_d: ?*u32,
            algorithm_type: ?*u32,
            sampling_rate: ?*u32,
            bit_depth: ?*u32,
            num_channels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumVideoCapability: *const fn (
            self: *const IBDA_Encoder,
            fmt_index: u32,
            method_i_d: ?*u32,
            algorithm_type: ?*u32,
            vertical_size: ?*u32,
            horizontal_size: ?*u32,
            aspect_ratio: ?*u32,
            frame_rate_code: ?*u32,
            progressive_sequence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameters: *const fn (
            self: *const IBDA_Encoder,
            audio_bitrate_mode: u32,
            audio_bitrate: u32,
            audio_method_i_d: u32,
            audio_program: u32,
            video_bitrate_mode: u32,
            video_bitrate: u32,
            video_method_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IBDA_Encoder,
            audio_bitrate_max: ?*u32,
            audio_bitrate_min: ?*u32,
            audio_bitrate_mode: ?*u32,
            audio_bitrate_stepping: ?*u32,
            audio_bitrate: ?*u32,
            audio_method_i_d: ?*u32,
            available_audio_programs: ?*u32,
            audio_program: ?*u32,
            video_bitrate_max: ?*u32,
            video_bitrate_min: ?*u32,
            video_bitrate_mode: ?*u32,
            video_bitrate: ?*u32,
            video_bitrate_stepping: ?*u32,
            video_method_i_d: ?*u32,
            signal_source_i_d: ?*u32,
            signal_format: ?*u64,
            signal_lock: ?*BOOL,
            signal_level: ?*i32,
            signal_to_noise_ratio: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryCapabilities(self: *const T, num_audio_fmts_: ?*u32, num_video_fmts_: ?*u32) HRESULT {
                return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).QueryCapabilities(@as(*const IBDA_Encoder, @ptrCast(self)), num_audio_fmts_, num_video_fmts_);
            }
            pub inline fn enumAudioCapability(self: *const T, fmt_index_: u32, method_i_d_: ?*u32, algorithm_type_: ?*u32, sampling_rate_: ?*u32, bit_depth_: ?*u32, num_channels_: ?*u32) HRESULT {
                return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).EnumAudioCapability(@as(*const IBDA_Encoder, @ptrCast(self)), fmt_index_, method_i_d_, algorithm_type_, sampling_rate_, bit_depth_, num_channels_);
            }
            pub inline fn enumVideoCapability(self: *const T, fmt_index_: u32, method_i_d_: ?*u32, algorithm_type_: ?*u32, vertical_size_: ?*u32, horizontal_size_: ?*u32, aspect_ratio_: ?*u32, frame_rate_code_: ?*u32, progressive_sequence_: ?*u32) HRESULT {
                return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).EnumVideoCapability(@as(*const IBDA_Encoder, @ptrCast(self)), fmt_index_, method_i_d_, algorithm_type_, vertical_size_, horizontal_size_, aspect_ratio_, frame_rate_code_, progressive_sequence_);
            }
            pub inline fn setParameters(self: *const T, audio_bitrate_mode_: u32, audio_bitrate_: u32, audio_method_i_d_: u32, audio_program_: u32, video_bitrate_mode_: u32, video_bitrate_: u32, video_method_i_d_: u32) HRESULT {
                return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).SetParameters(@as(*const IBDA_Encoder, @ptrCast(self)), audio_bitrate_mode_, audio_bitrate_, audio_method_i_d_, audio_program_, video_bitrate_mode_, video_bitrate_, video_method_i_d_);
            }
            pub inline fn getState(self: *const T, audio_bitrate_max_: ?*u32, audio_bitrate_min_: ?*u32, audio_bitrate_mode_: ?*u32, audio_bitrate_stepping_: ?*u32, audio_bitrate_: ?*u32, audio_method_i_d_: ?*u32, available_audio_programs_: ?*u32, audio_program_: ?*u32, video_bitrate_max_: ?*u32, video_bitrate_min_: ?*u32, video_bitrate_mode_: ?*u32, video_bitrate_: ?*u32, video_bitrate_stepping_: ?*u32, video_method_i_d_: ?*u32, signal_source_i_d_: ?*u32, signal_format_: ?*u64, signal_lock_: ?*BOOL, signal_level_: ?*i32, signal_to_noise_ratio_: ?*u32) HRESULT {
                return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).GetState(@as(*const IBDA_Encoder, @ptrCast(self)), audio_bitrate_max_, audio_bitrate_min_, audio_bitrate_mode_, audio_bitrate_stepping_, audio_bitrate_, audio_method_i_d_, available_audio_programs_, audio_program_, video_bitrate_max_, video_bitrate_min_, video_bitrate_mode_, video_bitrate_, video_bitrate_stepping_, video_method_i_d_, signal_source_i_d_, signal_format_, signal_lock_, signal_level_, signal_to_noise_ratio_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_FDC_Value = Guid.initString("138adc7e-58ae-437f-b0b4-c9fe19d5b4ac");
pub const IID_IBDA_FDC = &IID_IBDA_FDC_Value;
pub const IBDA_FDC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IBDA_FDC,
            current_bitrate: ?*u32,
            carrier_lock: ?*BOOL,
            current_frequency: ?*u32,
            current_spectrum_inversion: ?*BOOL,
            current_p_i_d_list: ?*?BSTR,
            current_t_i_d_list: ?*?BSTR,
            overflow: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestTables: *const fn (
            self: *const IBDA_FDC,
            table_i_ds: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPid: *const fn (
            self: *const IBDA_FDC,
            pids_to_add: ?BSTR,
            remaining_filter_entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePid: *const fn (
            self: *const IBDA_FDC,
            pids_to_remove: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTid: *const fn (
            self: *const IBDA_FDC,
            tids_to_add: ?BSTR,
            current_tid_list: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTid: *const fn (
            self: *const IBDA_FDC,
            tids_to_remove: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableSection: *const fn (
            self: *const IBDA_FDC,
            pid: ?*u32,
            max_buffer_size: u32,
            actual_size: ?*u32,
            sec_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, current_bitrate_: ?*u32, carrier_lock_: ?*BOOL, current_frequency_: ?*u32, current_spectrum_inversion_: ?*BOOL, current_p_i_d_list_: ?*?BSTR, current_t_i_d_list_: ?*?BSTR, overflow_: ?*BOOL) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IBDA_FDC, @ptrCast(self)), current_bitrate_, carrier_lock_, current_frequency_, current_spectrum_inversion_, current_p_i_d_list_, current_t_i_d_list_, overflow_);
            }
            pub inline fn requestTables(self: *const T, table_i_ds_: ?BSTR) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RequestTables(@as(*const IBDA_FDC, @ptrCast(self)), table_i_ds_);
            }
            pub inline fn addPid(self: *const T, pids_to_add_: ?BSTR, remaining_filter_entries_: ?*u32) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).AddPid(@as(*const IBDA_FDC, @ptrCast(self)), pids_to_add_, remaining_filter_entries_);
            }
            pub inline fn removePid(self: *const T, pids_to_remove_: ?BSTR) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RemovePid(@as(*const IBDA_FDC, @ptrCast(self)), pids_to_remove_);
            }
            pub inline fn addTid(self: *const T, tids_to_add_: ?BSTR, current_tid_list_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).AddTid(@as(*const IBDA_FDC, @ptrCast(self)), tids_to_add_, current_tid_list_);
            }
            pub inline fn removeTid(self: *const T, tids_to_remove_: ?BSTR) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RemoveTid(@as(*const IBDA_FDC, @ptrCast(self)), tids_to_remove_);
            }
            pub inline fn getTableSection(self: *const T, pid_: ?*u32, max_buffer_size_: u32, actual_size_: ?*u32, sec_buffer_: ?*u8) HRESULT {
                return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).GetTableSection(@as(*const IBDA_FDC, @ptrCast(self)), pid_, max_buffer_size_, actual_size_, sec_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_GuideDataDeliveryService_Value = Guid.initString("c0afcb73-23e7-4bc6-bafa-fdc167b4719f");
pub const IID_IBDA_GuideDataDeliveryService = &IID_IBDA_GuideDataDeliveryService_Value;
pub const IBDA_GuideDataDeliveryService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuideDataType: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
            pguid_data_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideData: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
            pulcb_buffer_len: ?*u32,
            pb_buffer: ?*u8,
            pul_guide_data_percentage_progress: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestGuideDataUpdate: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuneXmlFromServiceIdx: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
            ul64_service_idx: u64,
            pbstr_tune_xml: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServices: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
            pulcb_buffer_len: ?*u32,
            pb_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceInfoFromTuneXml: *const fn (
            self: *const IBDA_GuideDataDeliveryService,
            bstr_tune_xml: ?BSTR,
            pbstr_service_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getGuideDataType(self: *const T, pguid_data_type_: ?*Guid) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetGuideDataType(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pguid_data_type_);
            }
            pub inline fn getGuideData(self: *const T, pulcb_buffer_len_: ?*u32, pb_buffer_: ?*u8, pul_guide_data_percentage_progress_: ?*u32) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetGuideData(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pulcb_buffer_len_, pb_buffer_, pul_guide_data_percentage_progress_);
            }
            pub inline fn requestGuideDataUpdate(self: *const T) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).RequestGuideDataUpdate(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)));
            }
            pub inline fn getTuneXmlFromServiceIdx(self: *const T, ul64_service_idx_: u64, pbstr_tune_xml_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetTuneXmlFromServiceIdx(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), ul64_service_idx_, pbstr_tune_xml_);
            }
            pub inline fn getServices(self: *const T, pulcb_buffer_len_: ?*u32, pb_buffer_: ?*u8) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pulcb_buffer_len_, pb_buffer_);
            }
            pub inline fn getServiceInfoFromTuneXml(self: *const T, bstr_tune_xml_: ?BSTR, pbstr_service_description_: ?*?BSTR) HRESULT {
                return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetServiceInfoFromTuneXml(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), bstr_tune_xml_, pbstr_service_description_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRMService_Value = Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const IID_IBDA_DRMService = &IID_IBDA_DRMService_Value;
pub const IBDA_DRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: *const fn (
            self: *const IBDA_DRMService,
            puuid_new_drm: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDRMStatus: *const fn (
            self: *const IBDA_DRMService,
            pbstr_drm_uuid_list: ?*?BSTR,
            drm_uuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDRM(self: *const T, puuid_new_drm_: ?*Guid) HRESULT {
                return @as(*const IBDA_DRMService.VTable, @ptrCast(self.vtable)).SetDRM(@as(*const IBDA_DRMService, @ptrCast(self)), puuid_new_drm_);
            }
            pub inline fn getDRMStatus(self: *const T, pbstr_drm_uuid_list_: ?*?BSTR, drm_uuid_: ?*Guid) HRESULT {
                return @as(*const IBDA_DRMService.VTable, @ptrCast(self.vtable)).GetDRMStatus(@as(*const IBDA_DRMService, @ptrCast(self)), pbstr_drm_uuid_list_, drm_uuid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMSession_Value = Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const IID_IBDA_WMDRMSession = &IID_IBDA_WMDRMSession_Value;
pub const IBDA_WMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IBDA_WMDRMSession,
            max_capture_token: ?*u32,
            max_streaming_pid: ?*u32,
            max_license: ?*u32,
            min_security_level: ?*u32,
            rev_info_sequence_number: ?*u32,
            rev_info_issued_time: ?*u64,
            rev_info_t_t_l: ?*u32,
            rev_list_version: ?*u32,
            ul_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRevInfo: *const fn (
            self: *const IBDA_WMDRMSession,
            ul_rev_info_len: u32,
            pb_rev_info: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCrl: *const fn (
            self: *const IBDA_WMDRMSession,
            ul_crl_len: u32,
            pb_crl_len: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransactMessage: *const fn (
            self: *const IBDA_WMDRMSession,
            ulcb_request: u32,
            pb_request: [*:0]u8,
            pulcb_response: ?*u32,
            pb_response: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicense: *const fn (
            self: *const IBDA_WMDRMSession,
            uuid_key: ?*Guid,
            pul_package_len: ?*u32,
            pb_package: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReissueLicense: *const fn (
            self: *const IBDA_WMDRMSession,
            uuid_key: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenewLicense: *const fn (
            self: *const IBDA_WMDRMSession,
            ul_in_xmr_license_len: u32,
            pb_in_xmr_license: [*:0]u8,
            ul_entitlement_token_len: u32,
            pb_entitlement_token: [*:0]u8,
            pul_descramble_status: ?*u32,
            pul_out_xmr_license_len: ?*u32,
            pb_out_xmr_license: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyInfo: *const fn (
            self: *const IBDA_WMDRMSession,
            pul_key_info_len: ?*u32,
            pb_key_info: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, max_capture_token_: ?*u32, max_streaming_pid_: ?*u32, max_license_: ?*u32, min_security_level_: ?*u32, rev_info_sequence_number_: ?*u32, rev_info_issued_time_: ?*u64, rev_info_t_t_l_: ?*u32, rev_list_version_: ?*u32, ul_state_: ?*u32) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IBDA_WMDRMSession, @ptrCast(self)), max_capture_token_, max_streaming_pid_, max_license_, min_security_level_, rev_info_sequence_number_, rev_info_issued_time_, rev_info_t_t_l_, rev_list_version_, ul_state_);
            }
            pub inline fn setRevInfo(self: *const T, ul_rev_info_len_: u32, pb_rev_info_: [*:0]u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).SetRevInfo(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ul_rev_info_len_, pb_rev_info_);
            }
            pub inline fn setCrl(self: *const T, ul_crl_len_: u32, pb_crl_len_: [*:0]u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).SetCrl(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ul_crl_len_, pb_crl_len_);
            }
            pub inline fn transactMessage(self: *const T, ulcb_request_: u32, pb_request_: [*:0]u8, pulcb_response_: ?*u32, pb_response_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).TransactMessage(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ulcb_request_, pb_request_, pulcb_response_, pb_response_);
            }
            pub inline fn getLicense(self: *const T, uuid_key_: ?*Guid, pul_package_len_: ?*u32, pb_package_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), uuid_key_, pul_package_len_, pb_package_);
            }
            pub inline fn reissueLicense(self: *const T, uuid_key_: ?*Guid) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).ReissueLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), uuid_key_);
            }
            pub inline fn renewLicense(self: *const T, ul_in_xmr_license_len_: u32, pb_in_xmr_license_: [*:0]u8, ul_entitlement_token_len_: u32, pb_entitlement_token_: [*:0]u8, pul_descramble_status_: ?*u32, pul_out_xmr_license_len_: ?*u32, pb_out_xmr_license_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).RenewLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ul_in_xmr_license_len_, pb_in_xmr_license_, ul_entitlement_token_len_, pb_entitlement_token_, pul_descramble_status_, pul_out_xmr_license_len_, pb_out_xmr_license_);
            }
            pub inline fn getKeyInfo(self: *const T, pul_key_info_len_: ?*u32, pb_key_info_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetKeyInfo(@as(*const IBDA_WMDRMSession, @ptrCast(self)), pul_key_info_len_, pb_key_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMTuner_Value = Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const IID_IBDA_WMDRMTuner = &IID_IBDA_WMDRMTuner_Value;
pub const IBDA_WMDRMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PurchaseEntitlement: *const fn (
            self: *const IBDA_WMDRMTuner,
            ul_dialog_request: u32,
            bstr_language: ?BSTR,
            ul_purchase_token_len: u32,
            pb_purchase_token: [*:0]u8,
            pul_descramble_status: ?*u32,
            pul_capture_token_len: ?*u32,
            pb_capture_token: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelCaptureToken: *const fn (
            self: *const IBDA_WMDRMTuner,
            ul_capture_token_len: u32,
            pb_capture_token: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPidProtection: *const fn (
            self: *const IBDA_WMDRMTuner,
            ul_pid: u32,
            uuid_key: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidProtection: *const fn (
            self: *const IBDA_WMDRMTuner,
            pul_pid: u32,
            uuid_key: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncValue: *const fn (
            self: *const IBDA_WMDRMTuner,
            ul_sync_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartCodeProfile: *const fn (
            self: *const IBDA_WMDRMTuner,
            pul_start_code_profile_len: ?*u32,
            pb_start_code_profile: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn purchaseEntitlement(self: *const T, ul_dialog_request_: u32, bstr_language_: ?BSTR, ul_purchase_token_len_: u32, pb_purchase_token_: [*:0]u8, pul_descramble_status_: ?*u32, pul_capture_token_len_: ?*u32, pb_capture_token_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).PurchaseEntitlement(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ul_dialog_request_, bstr_language_, ul_purchase_token_len_, pb_purchase_token_, pul_descramble_status_, pul_capture_token_len_, pb_capture_token_);
            }
            pub inline fn cancelCaptureToken(self: *const T, ul_capture_token_len_: u32, pb_capture_token_: [*:0]u8) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).CancelCaptureToken(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ul_capture_token_len_, pb_capture_token_);
            }
            pub inline fn setPidProtection(self: *const T, ul_pid_: u32, uuid_key_: ?*Guid) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).SetPidProtection(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ul_pid_, uuid_key_);
            }
            pub inline fn getPidProtection(self: *const T, pul_pid_: u32, uuid_key_: ?*Guid) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).GetPidProtection(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), pul_pid_, uuid_key_);
            }
            pub inline fn setSyncValue(self: *const T, ul_sync_value_: u32) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).SetSyncValue(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ul_sync_value_);
            }
            pub inline fn getStartCodeProfile(self: *const T, pul_start_code_profile_len_: ?*u32, pb_start_code_profile_: ?*u8) HRESULT {
                return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).GetStartCodeProfile(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), pul_start_code_profile_len_, pb_start_code_profile_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_DRIDRMService_Value = Guid.initString("1f9bc2a5-44a3-4c52-aab1-0bbce5a1381d");
pub const IID_IBDA_DRIDRMService = &IID_IBDA_DRIDRMService_Value;
pub const IBDA_DRIDRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: *const fn (
            self: *const IBDA_DRIDRMService,
            bstr_new_drm: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDRMStatus: *const fn (
            self: *const IBDA_DRIDRMService,
            pbstr_drm_uuid_list: ?*?BSTR,
            drm_uuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPairingStatus: *const fn (
            self: *const IBDA_DRIDRMService,
            penum_pairing_status: ?*BDA_DrmPairingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDRM(self: *const T, bstr_new_drm_: ?BSTR) HRESULT {
                return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).SetDRM(@as(*const IBDA_DRIDRMService, @ptrCast(self)), bstr_new_drm_);
            }
            pub inline fn getDRMStatus(self: *const T, pbstr_drm_uuid_list_: ?*?BSTR, drm_uuid_: ?*Guid) HRESULT {
                return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).GetDRMStatus(@as(*const IBDA_DRIDRMService, @ptrCast(self)), pbstr_drm_uuid_list_, drm_uuid_);
            }
            pub inline fn getPairingStatus(self: *const T, penum_pairing_status_: ?*BDA_DrmPairingError) HRESULT {
                return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).GetPairingStatus(@as(*const IBDA_DRIDRMService, @ptrCast(self)), penum_pairing_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRIWMDRMSession_Value = Guid.initString("05c690f8-56db-4bb2-b053-79c12098bb26");
pub const IID_IBDA_DRIWMDRMSession = &IID_IBDA_DRIWMDRMSession_Value;
pub const IBDA_DRIWMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcknowledgeLicense: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            hr_license_ack: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessLicenseChallenge: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            dwcb_license_message: u32,
            pb_license_message: [*:0]u8,
            pdwcb_license_response: ?*u32,
            ppb_license_response: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessRegistrationChallenge: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            dwcb_registration_message: u32,
            pb_registration_message: [*:0]u8,
            pdwcb_registration_response: ?*u32,
            ppb_registration_response: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRevInfo: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            dw_rev_info_len: u32,
            pb_rev_info: [*:0]u8,
            pdw_response: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCrl: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            dw_crl_len: u32,
            pb_crl_len: [*:0]u8,
            pdw_response: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHMSAssociationData: *const fn (
            self: *const IBDA_DRIWMDRMSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastCardeaError: *const fn (
            self: *const IBDA_DRIWMDRMSession,
            pdw_error: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn acknowledgeLicense(self: *const T, hr_license_ack_: HRESULT) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).AcknowledgeLicense(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), hr_license_ack_);
            }
            pub inline fn processLicenseChallenge(self: *const T, dwcb_license_message_: u32, pb_license_message_: [*:0]u8, pdwcb_license_response_: ?*u32, ppb_license_response_: ?*?*u8) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).ProcessLicenseChallenge(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwcb_license_message_, pb_license_message_, pdwcb_license_response_, ppb_license_response_);
            }
            pub inline fn processRegistrationChallenge(self: *const T, dwcb_registration_message_: u32, pb_registration_message_: [*:0]u8, pdwcb_registration_response_: ?*u32, ppb_registration_response_: ?*?*u8) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).ProcessRegistrationChallenge(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwcb_registration_message_, pb_registration_message_, pdwcb_registration_response_, ppb_registration_response_);
            }
            pub inline fn setRevInfo(self: *const T, dw_rev_info_len_: u32, pb_rev_info_: [*:0]u8, pdw_response_: ?*u32) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).SetRevInfo(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dw_rev_info_len_, pb_rev_info_, pdw_response_);
            }
            pub inline fn setCrl(self: *const T, dw_crl_len_: u32, pb_crl_len_: [*:0]u8, pdw_response_: ?*u32) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).SetCrl(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dw_crl_len_, pb_crl_len_, pdw_response_);
            }
            pub inline fn getHMSAssociationData(self: *const T) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).GetHMSAssociationData(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)));
            }
            pub inline fn getLastCardeaError(self: *const T, pdw_error_: ?*u32) HRESULT {
                return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).GetLastCardeaError(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), pdw_error_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_MUX_Value = Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const IID_IBDA_MUX = &IID_IBDA_MUX_Value;
pub const IBDA_MUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPidList: *const fn (
            self: *const IBDA_MUX,
            ul_pid_list_count: u32,
            pb_pid_list_buffer: [*]BDA_MUX_PIDLISTITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidList: *const fn (
            self: *const IBDA_MUX,
            pul_pid_list_count: ?*u32,
            pb_pid_list_buffer: ?*BDA_MUX_PIDLISTITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setPidList(self: *const T, ul_pid_list_count_: u32, pb_pid_list_buffer_: [*]BDA_MUX_PIDLISTITEM) HRESULT {
                return @as(*const IBDA_MUX.VTable, @ptrCast(self.vtable)).SetPidList(@as(*const IBDA_MUX, @ptrCast(self)), ul_pid_list_count_, pb_pid_list_buffer_);
            }
            pub inline fn getPidList(self: *const T, pul_pid_list_count_: ?*u32, pb_pid_list_buffer_: ?*BDA_MUX_PIDLISTITEM) HRESULT {
                return @as(*const IBDA_MUX.VTable, @ptrCast(self.vtable)).GetPidList(@as(*const IBDA_MUX, @ptrCast(self)), pul_pid_list_count_, pb_pid_list_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamSelector_Value = Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const IID_IBDA_TransportStreamSelector = &IID_IBDA_TransportStreamSelector_Value;
pub const IBDA_TransportStreamSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTSID: *const fn (
            self: *const IBDA_TransportStreamSelector,
            us_t_s_i_d: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSInformation: *const fn (
            self: *const IBDA_TransportStreamSelector,
            pul_t_s_information_buffer_len: ?*u32,
            pb_t_s_information_buffer: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setTSID(self: *const T, us_t_s_i_d_: u16) HRESULT {
                return @as(*const IBDA_TransportStreamSelector.VTable, @ptrCast(self.vtable)).SetTSID(@as(*const IBDA_TransportStreamSelector, @ptrCast(self)), us_t_s_i_d_);
            }
            pub inline fn getTSInformation(self: *const T, pul_t_s_information_buffer_len_: ?*u32, pb_t_s_information_buffer_: [*:0]u8) HRESULT {
                return @as(*const IBDA_TransportStreamSelector.VTable, @ptrCast(self.vtable)).GetTSInformation(@as(*const IBDA_TransportStreamSelector, @ptrCast(self)), pul_t_s_information_buffer_len_, pb_t_s_information_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_UserActivityService_Value = Guid.initString("53b14189-e478-4b7a-a1ff-506db4b99dfe");
pub const IID_IBDA_UserActivityService = &IID_IBDA_UserActivityService_Value;
pub const IBDA_UserActivityService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCurrentTunerUseReason: *const fn (
            self: *const IBDA_UserActivityService,
            dw_use_reason: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserActivityInterval: *const fn (
            self: *const IBDA_UserActivityService,
            pdw_activity_interval: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UserActivityDetected: *const fn (
            self: *const IBDA_UserActivityService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setCurrentTunerUseReason(self: *const T, dw_use_reason_: u32) HRESULT {
                return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).SetCurrentTunerUseReason(@as(*const IBDA_UserActivityService, @ptrCast(self)), dw_use_reason_);
            }
            pub inline fn getUserActivityInterval(self: *const T, pdw_activity_interval_: ?*u32) HRESULT {
                return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).GetUserActivityInterval(@as(*const IBDA_UserActivityService, @ptrCast(self)), pdw_activity_interval_);
            }
            pub inline fn userActivityDetected(self: *const T) HRESULT {
                return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).UserActivityDetected(@as(*const IBDA_UserActivityService, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvent_Value = Guid.initString("1f0e5357-af43-44e6-8547-654c645145d2");
pub const IID_IESEvent = &IID_IESEvent_Value;
pub const IESEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventId: *const fn (
            self: *const IESEvent,
            pdw_event_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventType: *const fn (
            self: *const IESEvent,
            pguid_event_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompletionStatus: *const fn (
            self: *const IESEvent,
            dw_result: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const IESEvent,
            pb_data: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringData: *const fn (
            self: *const IESEvent,
            pbstr_data: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEventId(self: *const T, pdw_event_id_: ?*u32) HRESULT {
                return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetEventId(@as(*const IESEvent, @ptrCast(self)), pdw_event_id_);
            }
            pub inline fn getEventType(self: *const T, pguid_event_type_: ?*Guid) HRESULT {
                return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetEventType(@as(*const IESEvent, @ptrCast(self)), pguid_event_type_);
            }
            pub inline fn setCompletionStatus(self: *const T, dw_result_: u32) HRESULT {
                return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).SetCompletionStatus(@as(*const IESEvent, @ptrCast(self)), dw_result_);
            }
            pub inline fn getData(self: *const T, pb_data_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetData(@as(*const IESEvent, @ptrCast(self)), pb_data_);
            }
            pub inline fn getStringData(self: *const T, pbstr_data_: ?*?BSTR) HRESULT {
                return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetStringData(@as(*const IESEvent, @ptrCast(self)), pbstr_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvents_Value = Guid.initString("abd414bf-cfe5-4e5e-af5b-4b4e49c5bfeb");
pub const IID_IESEvents = &IID_IESEvents_Value;
pub const IESEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnESEventReceived: *const fn (
            self: *const IESEvents,
            guid_event_type: Guid,
            p_e_s_event: ?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onESEventReceived(self: *const T, guid_event_type_: Guid, p_e_s_event_: ?*IESEvent) HRESULT {
                return @as(*const IESEvents.VTable, @ptrCast(self.vtable)).OnESEventReceived(@as(*const IESEvents, @ptrCast(self)), guid_event_type_, p_e_s_event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBroadcastEvent_Value = Guid.initString("3b21263f-26e8-489d-aac4-924f7efd9511");
pub const IID_IBroadcastEvent = &IID_IBroadcastEvent_Value;
pub const IBroadcastEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Fire: *const fn (
            self: *const IBroadcastEvent,
            event_i_d: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn fire(self: *const T, event_i_d_: Guid) HRESULT {
                return @as(*const IBroadcastEvent.VTable, @ptrCast(self.vtable)).Fire(@as(*const IBroadcastEvent, @ptrCast(self)), event_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBroadcastEventEx_Value = Guid.initString("3d9e3887-1929-423f-8021-43682de95448");
pub const IID_IBroadcastEventEx = &IID_IBroadcastEventEx_Value;
pub const IBroadcastEventEx = extern struct {
    pub const VTable = extern struct {
        base: IBroadcastEvent.VTable,
        FireEx: *const fn (
            self: *const IBroadcastEventEx,
            event_i_d: Guid,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBroadcastEvent.MethodMixin(T);
            pub inline fn fireEx(self: *const T, event_i_d_: Guid, param1_: u32, param2_: u32, param3_: u32, param4_: u32) HRESULT {
                return @as(*const IBroadcastEventEx.VTable, @ptrCast(self.vtable)).FireEx(@as(*const IBroadcastEventEx, @ptrCast(self)), event_i_d_, param1_, param2_, param3_, param4_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowConfig_Value = Guid.initString("fa2aa8f1-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowConfig = &IID_IAMNetShowConfig_Value;
pub const IAMNetShowConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_buffering_time: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferingTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            buffering_time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseFixedUDPPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_use_fixed_u_d_p_port: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseFixedUDPPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            use_fixed_u_d_p_port: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FixedUDPPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_fixed_u_d_p_port: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FixedUDPPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            fixed_u_d_p_port: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseHTTPProxy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_use_h_t_t_p_proxy: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseHTTPProxy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            use_h_t_t_p_proxy: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableAutoProxy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_enable_auto_proxy: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableAutoProxy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            enable_auto_proxy: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyHost: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            pbstr_h_t_t_p_proxy_host: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyHost: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            bstr_h_t_t_p_proxy_host: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_h_t_t_p_proxy_port: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyPort: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            h_t_t_p_proxy_port: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableMulticast: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_enable_multicast: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableMulticast: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            enable_multicast: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableUDP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_enable_u_d_p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableUDP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            enable_u_d_p: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableTCP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_enable_t_c_p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableTCP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            enable_t_c_p: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableHTTP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            p_enable_h_t_t_p: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableHTTP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowConfig,
            enable_h_t_t_p: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getBufferingTime(self: *const T, p_buffering_time_: ?*f64) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_BufferingTime(@as(*const IAMNetShowConfig, @ptrCast(self)), p_buffering_time_);
            }
            pub inline fn putBufferingTime(self: *const T, buffering_time_: f64) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_BufferingTime(@as(*const IAMNetShowConfig, @ptrCast(self)), buffering_time_);
            }
            pub inline fn getUseFixedUDPPort(self: *const T, p_use_fixed_u_d_p_port_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_UseFixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), p_use_fixed_u_d_p_port_);
            }
            pub inline fn putUseFixedUDPPort(self: *const T, use_fixed_u_d_p_port_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_UseFixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), use_fixed_u_d_p_port_);
            }
            pub inline fn getFixedUDPPort(self: *const T, p_fixed_u_d_p_port_: ?*i32) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_FixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), p_fixed_u_d_p_port_);
            }
            pub inline fn putFixedUDPPort(self: *const T, fixed_u_d_p_port_: i32) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_FixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), fixed_u_d_p_port_);
            }
            pub inline fn getUseHTTPProxy(self: *const T, p_use_h_t_t_p_proxy_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_UseHTTPProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), p_use_h_t_t_p_proxy_);
            }
            pub inline fn putUseHTTPProxy(self: *const T, use_h_t_t_p_proxy_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_UseHTTPProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), use_h_t_t_p_proxy_);
            }
            pub inline fn getEnableAutoProxy(self: *const T, p_enable_auto_proxy_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableAutoProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), p_enable_auto_proxy_);
            }
            pub inline fn putEnableAutoProxy(self: *const T, enable_auto_proxy_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableAutoProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), enable_auto_proxy_);
            }
            pub inline fn getHTTPProxyHost(self: *const T, pbstr_h_t_t_p_proxy_host_: ?*?BSTR) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_HTTPProxyHost(@as(*const IAMNetShowConfig, @ptrCast(self)), pbstr_h_t_t_p_proxy_host_);
            }
            pub inline fn putHTTPProxyHost(self: *const T, bstr_h_t_t_p_proxy_host_: ?BSTR) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_HTTPProxyHost(@as(*const IAMNetShowConfig, @ptrCast(self)), bstr_h_t_t_p_proxy_host_);
            }
            pub inline fn getHTTPProxyPort(self: *const T, p_h_t_t_p_proxy_port_: ?*i32) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_HTTPProxyPort(@as(*const IAMNetShowConfig, @ptrCast(self)), p_h_t_t_p_proxy_port_);
            }
            pub inline fn putHTTPProxyPort(self: *const T, h_t_t_p_proxy_port_: i32) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_HTTPProxyPort(@as(*const IAMNetShowConfig, @ptrCast(self)), h_t_t_p_proxy_port_);
            }
            pub inline fn getEnableMulticast(self: *const T, p_enable_multicast_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableMulticast(@as(*const IAMNetShowConfig, @ptrCast(self)), p_enable_multicast_);
            }
            pub inline fn putEnableMulticast(self: *const T, enable_multicast_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableMulticast(@as(*const IAMNetShowConfig, @ptrCast(self)), enable_multicast_);
            }
            pub inline fn getEnableUDP(self: *const T, p_enable_u_d_p_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableUDP(@as(*const IAMNetShowConfig, @ptrCast(self)), p_enable_u_d_p_);
            }
            pub inline fn putEnableUDP(self: *const T, enable_u_d_p_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableUDP(@as(*const IAMNetShowConfig, @ptrCast(self)), enable_u_d_p_);
            }
            pub inline fn getEnableTCP(self: *const T, p_enable_t_c_p_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableTCP(@as(*const IAMNetShowConfig, @ptrCast(self)), p_enable_t_c_p_);
            }
            pub inline fn putEnableTCP(self: *const T, enable_t_c_p_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableTCP(@as(*const IAMNetShowConfig, @ptrCast(self)), enable_t_c_p_);
            }
            pub inline fn getEnableHTTP(self: *const T, p_enable_h_t_t_p_: ?*i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableHTTP(@as(*const IAMNetShowConfig, @ptrCast(self)), p_enable_h_t_t_p_);
            }
            pub inline fn putEnableHTTP(self: *const T, enable_h_t_t_p_: i16) HRESULT {
                return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableHTTP(@as(*const IAMNetShowConfig, @ptrCast(self)), enable_h_t_t_p_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMChannelInfo_Value = Guid.initString("fa2aa8f2-8b62-11d0-a520-000000000000");
pub const IID_IAMChannelInfo = &IID_IAMChannelInfo_Value;
pub const IAMChannelInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_channel_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelDescription: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_channel_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_channel_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactAddress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_contact_address: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactPhone: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_contact_phone: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactEmail: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMChannelInfo,
            pbstr_contact_email: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getChannelName(self: *const T, pbstr_channel_name_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelName(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_channel_name_);
            }
            pub inline fn getChannelDescription(self: *const T, pbstr_channel_description_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelDescription(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_channel_description_);
            }
            pub inline fn getChannelURL(self: *const T, pbstr_channel_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelURL(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_channel_u_r_l_);
            }
            pub inline fn getContactAddress(self: *const T, pbstr_contact_address_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactAddress(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_contact_address_);
            }
            pub inline fn getContactPhone(self: *const T, pbstr_contact_phone_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactPhone(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_contact_phone_);
            }
            pub inline fn getContactEmail(self: *const T, pbstr_contact_email_: ?*?BSTR) HRESULT {
                return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactEmail(@as(*const IAMChannelInfo, @ptrCast(self)), pbstr_contact_email_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetworkStatus_Value = Guid.initString("fa2aa8f3-8b62-11d0-a520-000000000000");
pub const IID_IAMNetworkStatus = &IID_IAMNetworkStatus_Value;
pub const IAMNetworkStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceivedPackets: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_received_packets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoveredPackets: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_recovered_packets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LostPackets: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_lost_packets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceptionQuality: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_reception_quality: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_buffering_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBroadcast: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_is_broadcast: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingProgress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetworkStatus,
            p_buffering_progress: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getReceivedPackets(self: *const T, p_received_packets_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_ReceivedPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), p_received_packets_);
            }
            pub inline fn getRecoveredPackets(self: *const T, p_recovered_packets_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_RecoveredPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), p_recovered_packets_);
            }
            pub inline fn getLostPackets(self: *const T, p_lost_packets_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_LostPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), p_lost_packets_);
            }
            pub inline fn getReceptionQuality(self: *const T, p_reception_quality_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_ReceptionQuality(@as(*const IAMNetworkStatus, @ptrCast(self)), p_reception_quality_);
            }
            pub inline fn getBufferingCount(self: *const T, p_buffering_count_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_BufferingCount(@as(*const IAMNetworkStatus, @ptrCast(self)), p_buffering_count_);
            }
            pub inline fn getIsBroadcast(self: *const T, p_is_broadcast_: ?*i16) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_IsBroadcast(@as(*const IAMNetworkStatus, @ptrCast(self)), p_is_broadcast_);
            }
            pub inline fn getBufferingProgress(self: *const T, p_buffering_progress_: ?*i32) HRESULT {
                return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_BufferingProgress(@as(*const IAMNetworkStatus, @ptrCast(self)), p_buffering_progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMExtendedSeekingCapabilities = enum(i32) {
    CANSEEK = 1,
    CANSCAN = 2,
    MARKERSEEK = 4,
    SCANWITHOUTCLOCK = 8,
    NOSTANDARDREPAINT = 16,
    BUFFERING = 32,
    SENDS_VIDEOFRAMEREADY = 64,
};
pub const AM_EXSEEK_CANSEEK = AMExtendedSeekingCapabilities.CANSEEK;
pub const AM_EXSEEK_CANSCAN = AMExtendedSeekingCapabilities.CANSCAN;
pub const AM_EXSEEK_MARKERSEEK = AMExtendedSeekingCapabilities.MARKERSEEK;
pub const AM_EXSEEK_SCANWITHOUTCLOCK = AMExtendedSeekingCapabilities.SCANWITHOUTCLOCK;
pub const AM_EXSEEK_NOSTANDARDREPAINT = AMExtendedSeekingCapabilities.NOSTANDARDREPAINT;
pub const AM_EXSEEK_BUFFERING = AMExtendedSeekingCapabilities.BUFFERING;
pub const AM_EXSEEK_SENDS_VIDEOFRAMEREADY = AMExtendedSeekingCapabilities.SENDS_VIDEOFRAMEREADY;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedSeeking_Value = Guid.initString("fa2aa8f9-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedSeeking = &IID_IAMExtendedSeeking_Value;
pub const IAMExtendedSeeking = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExSeekCapabilities: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedSeeking,
            p_ex_capabilities: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarkerCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedSeeking,
            p_marker_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMarker: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedSeeking,
            p_current_marker: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkerTime: *const fn (
            self: *const IAMExtendedSeeking,
            marker_num: i32,
            p_marker_time: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkerName: *const fn (
            self: *const IAMExtendedSeeking,
            marker_num: i32,
            pbstr_marker_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlaybackSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedSeeking,
            speed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaybackSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedSeeking,
            p_speed: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getExSeekCapabilities(self: *const T, p_ex_capabilities_: ?*i32) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_ExSeekCapabilities(@as(*const IAMExtendedSeeking, @ptrCast(self)), p_ex_capabilities_);
            }
            pub inline fn getMarkerCount(self: *const T, p_marker_count_: ?*i32) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_MarkerCount(@as(*const IAMExtendedSeeking, @ptrCast(self)), p_marker_count_);
            }
            pub inline fn getCurrentMarker(self: *const T, p_current_marker_: ?*i32) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_CurrentMarker(@as(*const IAMExtendedSeeking, @ptrCast(self)), p_current_marker_);
            }
            pub inline fn getMarkerTime(self: *const T, marker_num_: i32, p_marker_time_: ?*f64) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).GetMarkerTime(@as(*const IAMExtendedSeeking, @ptrCast(self)), marker_num_, p_marker_time_);
            }
            pub inline fn getMarkerName(self: *const T, marker_num_: i32, pbstr_marker_name_: ?*?BSTR) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).GetMarkerName(@as(*const IAMExtendedSeeking, @ptrCast(self)), marker_num_, pbstr_marker_name_);
            }
            pub inline fn putPlaybackSpeed(self: *const T, speed_: f64) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).put_PlaybackSpeed(@as(*const IAMExtendedSeeking, @ptrCast(self)), speed_);
            }
            pub inline fn getPlaybackSpeed(self: *const T, p_speed_: ?*f64) HRESULT {
                return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_PlaybackSpeed(@as(*const IAMExtendedSeeking, @ptrCast(self)), p_speed_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowExProps_Value = Guid.initString("fa2aa8f5-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowExProps = &IID_IAMNetShowExProps_Value;
pub const IAMNetShowExProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceProtocol: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            p_source_protocol: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            p_bandwidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCorrection: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            pbstr_error_correction: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CodecCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            p_codec_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecInstalled: *const fn (
            self: *const IAMNetShowExProps,
            codec_num: i32,
            p_codec_installed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecDescription: *const fn (
            self: *const IAMNetShowExProps,
            codec_num: i32,
            pbstr_codec_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecURL: *const fn (
            self: *const IAMNetShowExProps,
            codec_num: i32,
            pbstr_codec_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationDate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            p_creation_date: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLink: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowExProps,
            pbstr_source_link: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getSourceProtocol(self: *const T, p_source_protocol_: ?*i32) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_SourceProtocol(@as(*const IAMNetShowExProps, @ptrCast(self)), p_source_protocol_);
            }
            pub inline fn getBandwidth(self: *const T, p_bandwidth_: ?*i32) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IAMNetShowExProps, @ptrCast(self)), p_bandwidth_);
            }
            pub inline fn getErrorCorrection(self: *const T, pbstr_error_correction_: ?*?BSTR) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_ErrorCorrection(@as(*const IAMNetShowExProps, @ptrCast(self)), pbstr_error_correction_);
            }
            pub inline fn getCodecCount(self: *const T, p_codec_count_: ?*i32) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_CodecCount(@as(*const IAMNetShowExProps, @ptrCast(self)), p_codec_count_);
            }
            pub inline fn getCodecInstalled(self: *const T, codec_num_: i32, p_codec_installed_: ?*i16) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecInstalled(@as(*const IAMNetShowExProps, @ptrCast(self)), codec_num_, p_codec_installed_);
            }
            pub inline fn getCodecDescription(self: *const T, codec_num_: i32, pbstr_codec_description_: ?*?BSTR) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecDescription(@as(*const IAMNetShowExProps, @ptrCast(self)), codec_num_, pbstr_codec_description_);
            }
            pub inline fn getCodecURL(self: *const T, codec_num_: i32, pbstr_codec_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecURL(@as(*const IAMNetShowExProps, @ptrCast(self)), codec_num_, pbstr_codec_u_r_l_);
            }
            pub inline fn getCreationDate(self: *const T, p_creation_date_: ?*f64) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_CreationDate(@as(*const IAMNetShowExProps, @ptrCast(self)), p_creation_date_);
            }
            pub inline fn getSourceLink(self: *const T, pbstr_source_link_: ?*?BSTR) HRESULT {
                return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_SourceLink(@as(*const IAMNetShowExProps, @ptrCast(self)), pbstr_source_link_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedErrorInfo_Value = Guid.initString("fa2aa8f6-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedErrorInfo = &IID_IAMExtendedErrorInfo_Value;
pub const IAMExtendedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HasError: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedErrorInfo,
            p_has_error: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorDescription: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedErrorInfo,
            pbstr_error_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMExtendedErrorInfo,
            p_error_code: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getHasError(self: *const T, p_has_error_: ?*i16) HRESULT {
                return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_HasError(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), p_has_error_);
            }
            pub inline fn getErrorDescription(self: *const T, pbstr_error_description_: ?*?BSTR) HRESULT {
                return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_ErrorDescription(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), pbstr_error_description_);
            }
            pub inline fn getErrorCode(self: *const T, p_error_code_: ?*i32) HRESULT {
                return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_ErrorCode(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), p_error_code_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent_Value = Guid.initString("fa2aa8f4-8b62-11d0-a520-000000000000");
pub const IID_IAMMediaContent = &IID_IAMMediaContent_Value;
pub const IAMMediaContent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_author_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_title: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rating: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_rating: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Copyright: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_copyright: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_base_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_logo_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoIconURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_logo_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WatermarkURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_watermark_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_more_info_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerImage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_more_info_banner_image: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerURL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_more_info_banner_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoText: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent,
            pbstr_more_info_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAuthorName(self: *const T, pbstr_author_name_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_AuthorName(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_author_name_);
            }
            pub inline fn getTitle(self: *const T, pbstr_title_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_title_);
            }
            pub inline fn getRating(self: *const T, pbstr_rating_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Rating(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_rating_);
            }
            pub inline fn getDescription(self: *const T, pbstr_description_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_description_);
            }
            pub inline fn getCopyright(self: *const T, pbstr_copyright_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Copyright(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_copyright_);
            }
            pub inline fn getBaseURL(self: *const T, pbstr_base_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_BaseURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_base_u_r_l_);
            }
            pub inline fn getLogoURL(self: *const T, pbstr_logo_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_LogoURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_logo_u_r_l_);
            }
            pub inline fn getLogoIconURL(self: *const T, pbstr_logo_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_LogoIconURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_logo_u_r_l_);
            }
            pub inline fn getWatermarkURL(self: *const T, pbstr_watermark_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_WatermarkURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_watermark_u_r_l_);
            }
            pub inline fn getMoreInfoURL(self: *const T, pbstr_more_info_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_more_info_u_r_l_);
            }
            pub inline fn getMoreInfoBannerImage(self: *const T, pbstr_more_info_banner_image_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoBannerImage(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_more_info_banner_image_);
            }
            pub inline fn getMoreInfoBannerURL(self: *const T, pbstr_more_info_banner_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoBannerURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_more_info_banner_u_r_l_);
            }
            pub inline fn getMoreInfoText(self: *const T, pbstr_more_info_text_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoText(@as(*const IAMMediaContent, @ptrCast(self)), pbstr_more_info_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent2_Value = Guid.initString("ce8f78c1-74d9-11d2-b09d-00a0c9a81117");
pub const IID_IAMMediaContent2 = &IID_IAMMediaContent2_Value;
pub const IAMMediaContent2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaParameter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent2,
            entry_num: i32,
            bstr_name: ?BSTR,
            pbstr_value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaParameterName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent2,
            entry_num: i32,
            index: i32,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaylistCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMMediaContent2,
            p_number_entries: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getMediaParameter(self: *const T, entry_num_: i32, bstr_name_: ?BSTR, pbstr_value_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_MediaParameter(@as(*const IAMMediaContent2, @ptrCast(self)), entry_num_, bstr_name_, pbstr_value_);
            }
            pub inline fn getMediaParameterName(self: *const T, entry_num_: i32, index_: i32, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_MediaParameterName(@as(*const IAMMediaContent2, @ptrCast(self)), entry_num_, index_, pbstr_name_);
            }
            pub inline fn getPlaylistCount(self: *const T, p_number_entries_: ?*i32) HRESULT {
                return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_PlaylistCount(@as(*const IAMMediaContent2, @ptrCast(self)), p_number_entries_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowPreroll_Value = Guid.initString("aae7e4e2-6388-11d1-8d93-006097c9a2b2");
pub const IID_IAMNetShowPreroll = &IID_IAMNetShowPreroll_Value;
pub const IAMNetShowPreroll = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Preroll: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowPreroll,
            f_preroll: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Preroll: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMNetShowPreroll,
            pf_preroll: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putPreroll(self: *const T, f_preroll_: i16) HRESULT {
                return @as(*const IAMNetShowPreroll.VTable, @ptrCast(self.vtable)).put_Preroll(@as(*const IAMNetShowPreroll, @ptrCast(self)), f_preroll_);
            }
            pub inline fn getPreroll(self: *const T, pf_preroll_: ?*i16) HRESULT {
                return @as(*const IAMNetShowPreroll.VTable, @ptrCast(self.vtable)).get_Preroll(@as(*const IAMNetShowPreroll, @ptrCast(self)), pf_preroll_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDShowPlugin_Value = Guid.initString("4746b7c8-700e-11d1-becc-00c04fb6e937");
pub const IID_IDShowPlugin = &IID_IDShowPlugin_Value;
pub const IDShowPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDShowPlugin,
            p_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDShowPlugin,
            p_user_agent: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getURL(self: *const T, p_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IDShowPlugin.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IDShowPlugin, @ptrCast(self)), p_u_r_l_);
            }
            pub inline fn getUserAgent(self: *const T, p_user_agent_: ?*?BSTR) HRESULT {
                return @as(*const IDShowPlugin.VTable, @ptrCast(self.vtable)).get_UserAgent(@as(*const IDShowPlugin, @ptrCast(self)), p_user_agent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAMDirectSound = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectSoundInterface: *const fn (
            self: *const IAMDirectSound,
            lplpds: ?*?*IDirectSound,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrimaryBufferInterface: *const fn (
            self: *const IAMDirectSound,
            lplpdsb: ?*?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecondaryBufferInterface: *const fn (
            self: *const IAMDirectSound,
            lplpdsb: ?*?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDirectSoundInterface: *const fn (
            self: *const IAMDirectSound,
            lpds: ?*IDirectSound,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleasePrimaryBufferInterface: *const fn (
            self: *const IAMDirectSound,
            lpdsb: ?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSecondaryBufferInterface: *const fn (
            self: *const IAMDirectSound,
            lpdsb: ?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocusWindow: *const fn (
            self: *const IAMDirectSound,
            param0: ?HWND,
            param1: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocusWindow: *const fn (
            self: *const IAMDirectSound,
            param0: ?*?HWND,
            param1: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDirectSoundInterface(self: *const T, lplpds_: ?*?*IDirectSound) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetDirectSoundInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpds_);
            }
            pub inline fn getPrimaryBufferInterface(self: *const T, lplpdsb_: ?*?*IDirectSoundBuffer) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetPrimaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpdsb_);
            }
            pub inline fn getSecondaryBufferInterface(self: *const T, lplpdsb_: ?*?*IDirectSoundBuffer) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetSecondaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpdsb_);
            }
            pub inline fn releaseDirectSoundInterface(self: *const T, lpds_: ?*IDirectSound) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleaseDirectSoundInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpds_);
            }
            pub inline fn releasePrimaryBufferInterface(self: *const T, lpdsb_: ?*IDirectSoundBuffer) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleasePrimaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpdsb_);
            }
            pub inline fn releaseSecondaryBufferInterface(self: *const T, lpdsb_: ?*IDirectSoundBuffer) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleaseSecondaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpdsb_);
            }
            pub inline fn setFocusWindow(self: *const T, param0_: ?HWND, param1_: BOOL) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).SetFocusWindow(@as(*const IAMDirectSound, @ptrCast(self)), param0_, param1_);
            }
            pub inline fn getFocusWindow(self: *const T, param0_: ?*?HWND, param1_: ?*BOOL) HRESULT {
                return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetFocusWindow(@as(*const IAMDirectSound, @ptrCast(self)), param0_, param1_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_LINE21_CCLEVEL = enum(i32) {
    @"2" = 0,
};
pub const AM_L21_CCLEVEL_TC2 = AM_LINE21_CCLEVEL.@"2";

pub const AM_LINE21_CCSERVICE = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
    DefChannel = 10,
    Invalid = 11,
};
pub const AM_L21_CCSERVICE_None = AM_LINE21_CCSERVICE.None;
pub const AM_L21_CCSERVICE_Caption1 = AM_LINE21_CCSERVICE.Caption1;
pub const AM_L21_CCSERVICE_Caption2 = AM_LINE21_CCSERVICE.Caption2;
pub const AM_L21_CCSERVICE_Text1 = AM_LINE21_CCSERVICE.Text1;
pub const AM_L21_CCSERVICE_Text2 = AM_LINE21_CCSERVICE.Text2;
pub const AM_L21_CCSERVICE_XDS = AM_LINE21_CCSERVICE.XDS;
pub const AM_L21_CCSERVICE_DefChannel = AM_LINE21_CCSERVICE.DefChannel;
pub const AM_L21_CCSERVICE_Invalid = AM_LINE21_CCSERVICE.Invalid;

pub const AM_LINE21_CCSTATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_L21_CCSTATE_Off = AM_LINE21_CCSTATE.ff;
pub const AM_L21_CCSTATE_On = AM_LINE21_CCSTATE.n;

pub const AM_LINE21_CCSTYLE = enum(i32) {
    None = 0,
    PopOn = 1,
    PaintOn = 2,
    RollUp = 3,
};
pub const AM_L21_CCSTYLE_None = AM_LINE21_CCSTYLE.None;
pub const AM_L21_CCSTYLE_PopOn = AM_LINE21_CCSTYLE.PopOn;
pub const AM_L21_CCSTYLE_PaintOn = AM_LINE21_CCSTYLE.PaintOn;
pub const AM_L21_CCSTYLE_RollUp = AM_LINE21_CCSTYLE.RollUp;

pub const AM_LINE21_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_L21_DRAWBGMODE_Opaque = AM_LINE21_DRAWBGMODE.Opaque;
pub const AM_L21_DRAWBGMODE_Transparent = AM_LINE21_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.0'
pub const IAMLine21Decoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: *const fn (
            self: *const IAMLine21Decoder,
            lp_level: ?*AM_LINE21_CCLEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentService: *const fn (
            self: *const IAMLine21Decoder,
            lp_service: ?*AM_LINE21_CCSERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentService: *const fn (
            self: *const IAMLine21Decoder,
            service: AM_LINE21_CCSERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceState: *const fn (
            self: *const IAMLine21Decoder,
            lp_state: ?*AM_LINE21_CCSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServiceState: *const fn (
            self: *const IAMLine21Decoder,
            state: AM_LINE21_CCSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFormat: *const fn (
            self: *const IAMLine21Decoder,
            lpbmih: ?*BITMAPINFOHEADER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFormat: *const fn (
            self: *const IAMLine21Decoder,
            lpbmi: ?*BITMAPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: *const fn (
            self: *const IAMLine21Decoder,
            pdw_phys_color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: *const fn (
            self: *const IAMLine21Decoder,
            dw_phys_color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedrawAlways: *const fn (
            self: *const IAMLine21Decoder,
            lpb_option: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedrawAlways: *const fn (
            self: *const IAMLine21Decoder,
            b_option: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawBackgroundMode: *const fn (
            self: *const IAMLine21Decoder,
            lp_mode: ?*AM_LINE21_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawBackgroundMode: *const fn (
            self: *const IAMLine21Decoder,
            mode: AM_LINE21_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDecoderLevel(self: *const T, lp_level_: ?*AM_LINE21_CCLEVEL) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetDecoderLevel(@as(*const IAMLine21Decoder, @ptrCast(self)), lp_level_);
            }
            pub inline fn getCurrentService(self: *const T, lp_service_: ?*AM_LINE21_CCSERVICE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetCurrentService(@as(*const IAMLine21Decoder, @ptrCast(self)), lp_service_);
            }
            pub inline fn setCurrentService(self: *const T, service_: AM_LINE21_CCSERVICE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetCurrentService(@as(*const IAMLine21Decoder, @ptrCast(self)), service_);
            }
            pub inline fn getServiceState(self: *const T, lp_state_: ?*AM_LINE21_CCSTATE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetServiceState(@as(*const IAMLine21Decoder, @ptrCast(self)), lp_state_);
            }
            pub inline fn setServiceState(self: *const T, state_: AM_LINE21_CCSTATE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetServiceState(@as(*const IAMLine21Decoder, @ptrCast(self)), state_);
            }
            pub inline fn getOutputFormat(self: *const T, lpbmih_: ?*BITMAPINFOHEADER) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IAMLine21Decoder, @ptrCast(self)), lpbmih_);
            }
            pub inline fn setOutputFormat(self: *const T, lpbmi_: ?*BITMAPINFO) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetOutputFormat(@as(*const IAMLine21Decoder, @ptrCast(self)), lpbmi_);
            }
            pub inline fn getBackgroundColor(self: *const T, pdw_phys_color_: ?*u32) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IAMLine21Decoder, @ptrCast(self)), pdw_phys_color_);
            }
            pub inline fn setBackgroundColor(self: *const T, dw_phys_color_: u32) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IAMLine21Decoder, @ptrCast(self)), dw_phys_color_);
            }
            pub inline fn getRedrawAlways(self: *const T, lpb_option_: ?*i32) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetRedrawAlways(@as(*const IAMLine21Decoder, @ptrCast(self)), lpb_option_);
            }
            pub inline fn setRedrawAlways(self: *const T, b_option_: BOOL) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetRedrawAlways(@as(*const IAMLine21Decoder, @ptrCast(self)), b_option_);
            }
            pub inline fn getDrawBackgroundMode(self: *const T, lp_mode_: ?*AM_LINE21_DRAWBGMODE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetDrawBackgroundMode(@as(*const IAMLine21Decoder, @ptrCast(self)), lp_mode_);
            }
            pub inline fn setDrawBackgroundMode(self: *const T, mode_: AM_LINE21_DRAWBGMODE) HRESULT {
                return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetDrawBackgroundMode(@as(*const IAMLine21Decoder, @ptrCast(self)), mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMParse_Value = Guid.initString("c47a3420-005c-11d2-9038-00a0c9697298");
pub const IID_IAMParse = &IID_IAMParse_Value;
pub const IAMParse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParseTime: *const fn (
            self: *const IAMParse,
            prt_current: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParseTime: *const fn (
            self: *const IAMParse,
            rt_current: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: *const fn (
            self: *const IAMParse,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getParseTime(self: *const T, prt_current_: ?*i64) HRESULT {
                return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).GetParseTime(@as(*const IAMParse, @ptrCast(self)), prt_current_);
            }
            pub inline fn setParseTime(self: *const T, rt_current_: i64) HRESULT {
                return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).SetParseTime(@as(*const IAMParse, @ptrCast(self)), rt_current_);
            }
            pub inline fn flush(self: *const T) HRESULT {
                return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).Flush(@as(*const IAMParse, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FilgraphManager_Value = Guid.initString("e436ebb3-524f-11ce-9f53-0020af0ba770");
pub const CLSID_FilgraphManager = &CLSID_FilgraphManager_Value;

const IID_IAMCollection_Value = Guid.initString("56a868b9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMCollection = &IID_IAMCollection_Value;
pub const IAMCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMCollection,
            pl_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: *const fn (
            self: *const IAMCollection,
            l_item: i32,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMCollection,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, pl_count_: ?*i32) HRESULT {
                return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IAMCollection, @ptrCast(self)), pl_count_);
            }
            pub inline fn item(self: *const T, l_item_: i32, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).Item(@as(*const IAMCollection, @ptrCast(self)), l_item_, pp_unk_);
            }
            pub inline fn getNewEnum(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IAMCollection, @ptrCast(self)), pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaControl_Value = Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaControl = &IID_IMediaControl_Value;
pub const IMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Run: *const fn (
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IMediaControl,
            ms_timeout: i32,
            pfs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderFile: *const fn (
            self: *const IMediaControl,
            str_filename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSourceFilter: *const fn (
            self: *const IMediaControl,
            str_filename: ?BSTR,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterCollection: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaControl,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegFilterCollection: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaControl,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopWhenReady: *const fn (
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn run(self: *const T) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Run(@as(*const IMediaControl, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMediaControl, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMediaControl, @ptrCast(self)));
            }
            pub inline fn getState(self: *const T, ms_timeout_: i32, pfs_: ?*i32) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMediaControl, @ptrCast(self)), ms_timeout_, pfs_);
            }
            pub inline fn renderFile(self: *const T, str_filename_: ?BSTR) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).RenderFile(@as(*const IMediaControl, @ptrCast(self)), str_filename_);
            }
            pub inline fn addSourceFilter(self: *const T, str_filename_: ?BSTR, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).AddSourceFilter(@as(*const IMediaControl, @ptrCast(self)), str_filename_, pp_unk_);
            }
            pub inline fn getFilterCollection(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).get_FilterCollection(@as(*const IMediaControl, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getRegFilterCollection(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).get_RegFilterCollection(@as(*const IMediaControl, @ptrCast(self)), pp_unk_);
            }
            pub inline fn stopWhenReady(self: *const T) HRESULT {
                return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).StopWhenReady(@as(*const IMediaControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEvent_Value = Guid.initString("56a868b6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEvent = &IID_IMediaEvent_Value;
pub const IMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetEventHandle: *const fn (
            self: *const IMediaEvent,
            h_event: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvent: *const fn (
            self: *const IMediaEvent,
            l_event_code: ?*i32,
            l_param1: ?*isize,
            l_param2: ?*isize,
            ms_timeout: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: *const fn (
            self: *const IMediaEvent,
            ms_timeout: i32,
            p_ev_code: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelDefaultHandling: *const fn (
            self: *const IMediaEvent,
            l_ev_code: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDefaultHandling: *const fn (
            self: *const IMediaEvent,
            l_ev_code: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeEventParams: *const fn (
            self: *const IMediaEvent,
            l_ev_code: i32,
            l_param1: isize,
            l_param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getEventHandle(self: *const T, h_event_: ?*isize) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).GetEventHandle(@as(*const IMediaEvent, @ptrCast(self)), h_event_);
            }
            pub inline fn getEvent(self: *const T, l_event_code_: ?*i32, l_param1_: ?*isize, l_param2_: ?*isize, ms_timeout_: i32) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const IMediaEvent, @ptrCast(self)), l_event_code_, l_param1_, l_param2_, ms_timeout_);
            }
            pub inline fn waitForCompletion(self: *const T, ms_timeout_: i32, p_ev_code_: ?*i32) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).WaitForCompletion(@as(*const IMediaEvent, @ptrCast(self)), ms_timeout_, p_ev_code_);
            }
            pub inline fn cancelDefaultHandling(self: *const T, l_ev_code_: i32) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).CancelDefaultHandling(@as(*const IMediaEvent, @ptrCast(self)), l_ev_code_);
            }
            pub inline fn restoreDefaultHandling(self: *const T, l_ev_code_: i32) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).RestoreDefaultHandling(@as(*const IMediaEvent, @ptrCast(self)), l_ev_code_);
            }
            pub inline fn freeEventParams(self: *const T, l_ev_code_: i32, l_param1_: isize, l_param2_: isize) HRESULT {
                return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).FreeEventParams(@as(*const IMediaEvent, @ptrCast(self)), l_ev_code_, l_param1_, l_param2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventEx_Value = Guid.initString("56a868c0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventEx = &IID_IMediaEventEx_Value;
pub const IMediaEventEx = extern struct {
    pub const VTable = extern struct {
        base: IMediaEvent.VTable,
        SetNotifyWindow: *const fn (
            self: *const IMediaEventEx,
            hwnd: isize,
            l_msg: i32,
            l_instance_data: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyFlags: *const fn (
            self: *const IMediaEventEx,
            l_no_notify_flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyFlags: *const fn (
            self: *const IMediaEventEx,
            lpl_no_notify_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaEvent.MethodMixin(T);
            pub inline fn setNotifyWindow(self: *const T, hwnd_: isize, l_msg_: i32, l_instance_data_: isize) HRESULT {
                return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).SetNotifyWindow(@as(*const IMediaEventEx, @ptrCast(self)), hwnd_, l_msg_, l_instance_data_);
            }
            pub inline fn setNotifyFlags(self: *const T, l_no_notify_flags_: i32) HRESULT {
                return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).SetNotifyFlags(@as(*const IMediaEventEx, @ptrCast(self)), l_no_notify_flags_);
            }
            pub inline fn getNotifyFlags(self: *const T, lpl_no_notify_flags_: ?*i32) HRESULT {
                return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).GetNotifyFlags(@as(*const IMediaEventEx, @ptrCast(self)), lpl_no_notify_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPosition_Value = Guid.initString("56a868b2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaPosition = &IID_IMediaPosition_Value;
pub const IMediaPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            plength: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            ll_time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            pll_time: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            pll_time: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            ll_time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrerollTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            pll_time: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrerollTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            ll_time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            d_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaPosition,
            pd_rate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanSeekForward: *const fn (
            self: *const IMediaPosition,
            p_can_seek_forward: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanSeekBackward: *const fn (
            self: *const IMediaPosition,
            p_can_seek_backward: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getDuration(self: *const T, plength_: ?*f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_Duration(@as(*const IMediaPosition, @ptrCast(self)), plength_);
            }
            pub inline fn putCurrentPosition(self: *const T, ll_time_: f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_CurrentPosition(@as(*const IMediaPosition, @ptrCast(self)), ll_time_);
            }
            pub inline fn getCurrentPosition(self: *const T, pll_time_: ?*f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_CurrentPosition(@as(*const IMediaPosition, @ptrCast(self)), pll_time_);
            }
            pub inline fn getStopTime(self: *const T, pll_time_: ?*f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_StopTime(@as(*const IMediaPosition, @ptrCast(self)), pll_time_);
            }
            pub inline fn putStopTime(self: *const T, ll_time_: f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_StopTime(@as(*const IMediaPosition, @ptrCast(self)), ll_time_);
            }
            pub inline fn getPrerollTime(self: *const T, pll_time_: ?*f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_PrerollTime(@as(*const IMediaPosition, @ptrCast(self)), pll_time_);
            }
            pub inline fn putPrerollTime(self: *const T, ll_time_: f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_PrerollTime(@as(*const IMediaPosition, @ptrCast(self)), ll_time_);
            }
            pub inline fn putRate(self: *const T, d_rate_: f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IMediaPosition, @ptrCast(self)), d_rate_);
            }
            pub inline fn getRate(self: *const T, pd_rate_: ?*f64) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IMediaPosition, @ptrCast(self)), pd_rate_);
            }
            pub inline fn canSeekForward(self: *const T, p_can_seek_forward_: ?*i32) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).CanSeekForward(@as(*const IMediaPosition, @ptrCast(self)), p_can_seek_forward_);
            }
            pub inline fn canSeekBackward(self: *const T, p_can_seek_backward_: ?*i32) HRESULT {
                return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).CanSeekBackward(@as(*const IMediaPosition, @ptrCast(self)), p_can_seek_backward_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicAudio_Value = Guid.initString("56a868b3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicAudio = &IID_IBasicAudio_Value;
pub const IBasicAudio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicAudio,
            l_volume: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicAudio,
            pl_volume: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicAudio,
            l_balance: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicAudio,
            pl_balance: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putVolume(self: *const T, l_volume_: i32) HRESULT {
                return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const IBasicAudio, @ptrCast(self)), l_volume_);
            }
            pub inline fn getVolume(self: *const T, pl_volume_: ?*i32) HRESULT {
                return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const IBasicAudio, @ptrCast(self)), pl_volume_);
            }
            pub inline fn putBalance(self: *const T, l_balance_: i32) HRESULT {
                return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).put_Balance(@as(*const IBasicAudio, @ptrCast(self)), l_balance_);
            }
            pub inline fn getBalance(self: *const T, pl_balance_: ?*i32) HRESULT {
                return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).get_Balance(@as(*const IBasicAudio, @ptrCast(self)), pl_balance_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVideoWindow_Value = Guid.initString("56a868b4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IVideoWindow = &IID_IVideoWindow_Value;
pub const IVideoWindow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Caption: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            str_caption: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Caption: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            str_caption: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_style: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_style: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyleEx: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_style_ex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyleEx: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_style_ex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoShow: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            auto_show: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoShow: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            auto_show: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            window_state: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackgroundPalette: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            background_palette: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundPalette: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_background_palette: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            visible: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_visible: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_left: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_top: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            owner: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            owner: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageDrain: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            drain: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageDrain: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            drain: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            color: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            color: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreenMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            full_screen_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreenMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoWindow,
            full_screen_mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWindowForeground: *const fn (
            self: *const IVideoWindow,
            focus: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyOwnerMessage: *const fn (
            self: *const IVideoWindow,
            hwnd: isize,
            u_msg: i32,
            w_param: isize,
            l_param: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWindowPosition: *const fn (
            self: *const IVideoWindow,
            left: i32,
            top: i32,
            width: i32,
            height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowPosition: *const fn (
            self: *const IVideoWindow,
            p_left: ?*i32,
            p_top: ?*i32,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealImageSize: *const fn (
            self: *const IVideoWindow,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealImageSize: *const fn (
            self: *const IVideoWindow,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestorePosition: *const fn (
            self: *const IVideoWindow,
            p_left: ?*i32,
            p_top: ?*i32,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HideCursor: *const fn (
            self: *const IVideoWindow,
            hide_cursor: OA_BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCursorHidden: *const fn (
            self: *const IVideoWindow,
            cursor_hidden: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn putCaption(self: *const T, str_caption_: ?BSTR) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Caption(@as(*const IVideoWindow, @ptrCast(self)), str_caption_);
            }
            pub inline fn getCaption(self: *const T, str_caption_: ?*?BSTR) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Caption(@as(*const IVideoWindow, @ptrCast(self)), str_caption_);
            }
            pub inline fn putWindowStyle(self: *const T, window_style_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowStyle(@as(*const IVideoWindow, @ptrCast(self)), window_style_);
            }
            pub inline fn getWindowStyle(self: *const T, window_style_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowStyle(@as(*const IVideoWindow, @ptrCast(self)), window_style_);
            }
            pub inline fn putWindowStyleEx(self: *const T, window_style_ex_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowStyleEx(@as(*const IVideoWindow, @ptrCast(self)), window_style_ex_);
            }
            pub inline fn getWindowStyleEx(self: *const T, window_style_ex_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowStyleEx(@as(*const IVideoWindow, @ptrCast(self)), window_style_ex_);
            }
            pub inline fn putAutoShow(self: *const T, auto_show_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_AutoShow(@as(*const IVideoWindow, @ptrCast(self)), auto_show_);
            }
            pub inline fn getAutoShow(self: *const T, auto_show_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_AutoShow(@as(*const IVideoWindow, @ptrCast(self)), auto_show_);
            }
            pub inline fn putWindowState(self: *const T, window_state_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowState(@as(*const IVideoWindow, @ptrCast(self)), window_state_);
            }
            pub inline fn getWindowState(self: *const T, window_state_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowState(@as(*const IVideoWindow, @ptrCast(self)), window_state_);
            }
            pub inline fn putBackgroundPalette(self: *const T, background_palette_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_BackgroundPalette(@as(*const IVideoWindow, @ptrCast(self)), background_palette_);
            }
            pub inline fn getBackgroundPalette(self: *const T, p_background_palette_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_BackgroundPalette(@as(*const IVideoWindow, @ptrCast(self)), p_background_palette_);
            }
            pub inline fn putVisible(self: *const T, visible_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IVideoWindow, @ptrCast(self)), visible_);
            }
            pub inline fn getVisible(self: *const T, p_visible_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IVideoWindow, @ptrCast(self)), p_visible_);
            }
            pub inline fn putLeft(self: *const T, left_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IVideoWindow, @ptrCast(self)), left_);
            }
            pub inline fn getLeft(self: *const T, p_left_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IVideoWindow, @ptrCast(self)), p_left_);
            }
            pub inline fn putWidth(self: *const T, width_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IVideoWindow, @ptrCast(self)), width_);
            }
            pub inline fn getWidth(self: *const T, p_width_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IVideoWindow, @ptrCast(self)), p_width_);
            }
            pub inline fn putTop(self: *const T, top_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IVideoWindow, @ptrCast(self)), top_);
            }
            pub inline fn getTop(self: *const T, p_top_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IVideoWindow, @ptrCast(self)), p_top_);
            }
            pub inline fn putHeight(self: *const T, height_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IVideoWindow, @ptrCast(self)), height_);
            }
            pub inline fn getHeight(self: *const T, p_height_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IVideoWindow, @ptrCast(self)), p_height_);
            }
            pub inline fn putOwner(self: *const T, owner_: isize) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Owner(@as(*const IVideoWindow, @ptrCast(self)), owner_);
            }
            pub inline fn getOwner(self: *const T, owner_: ?*isize) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Owner(@as(*const IVideoWindow, @ptrCast(self)), owner_);
            }
            pub inline fn putMessageDrain(self: *const T, drain_: isize) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_MessageDrain(@as(*const IVideoWindow, @ptrCast(self)), drain_);
            }
            pub inline fn getMessageDrain(self: *const T, drain_: ?*isize) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_MessageDrain(@as(*const IVideoWindow, @ptrCast(self)), drain_);
            }
            pub inline fn getBorderColor(self: *const T, color_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_BorderColor(@as(*const IVideoWindow, @ptrCast(self)), color_);
            }
            pub inline fn putBorderColor(self: *const T, color_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_BorderColor(@as(*const IVideoWindow, @ptrCast(self)), color_);
            }
            pub inline fn getFullScreenMode(self: *const T, full_screen_mode_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_FullScreenMode(@as(*const IVideoWindow, @ptrCast(self)), full_screen_mode_);
            }
            pub inline fn putFullScreenMode(self: *const T, full_screen_mode_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_FullScreenMode(@as(*const IVideoWindow, @ptrCast(self)), full_screen_mode_);
            }
            pub inline fn setWindowForeground(self: *const T, focus_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).SetWindowForeground(@as(*const IVideoWindow, @ptrCast(self)), focus_);
            }
            pub inline fn notifyOwnerMessage(self: *const T, hwnd_: isize, u_msg_: i32, w_param_: isize, l_param_: isize) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).NotifyOwnerMessage(@as(*const IVideoWindow, @ptrCast(self)), hwnd_, u_msg_, w_param_, l_param_);
            }
            pub inline fn setWindowPosition(self: *const T, left_: i32, top_: i32, width_: i32, height_: i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).SetWindowPosition(@as(*const IVideoWindow, @ptrCast(self)), left_, top_, width_, height_);
            }
            pub inline fn getWindowPosition(self: *const T, p_left_: ?*i32, p_top_: ?*i32, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetWindowPosition(@as(*const IVideoWindow, @ptrCast(self)), p_left_, p_top_, p_width_, p_height_);
            }
            pub inline fn getMinIdealImageSize(self: *const T, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetMinIdealImageSize(@as(*const IVideoWindow, @ptrCast(self)), p_width_, p_height_);
            }
            pub inline fn getMaxIdealImageSize(self: *const T, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetMaxIdealImageSize(@as(*const IVideoWindow, @ptrCast(self)), p_width_, p_height_);
            }
            pub inline fn getRestorePosition(self: *const T, p_left_: ?*i32, p_top_: ?*i32, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetRestorePosition(@as(*const IVideoWindow, @ptrCast(self)), p_left_, p_top_, p_width_, p_height_);
            }
            pub inline fn hideCursor(self: *const T, hide_cursor_: OA_BOOL) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).HideCursor(@as(*const IVideoWindow, @ptrCast(self)), hide_cursor_);
            }
            pub inline fn isCursorHidden(self: *const T, cursor_hidden_: ?*i32) HRESULT {
                return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).IsCursorHidden(@as(*const IVideoWindow, @ptrCast(self)), cursor_hidden_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo_Value = Guid.initString("56a868b5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicVideo = &IID_IBasicVideo_Value;
pub const IBasicVideo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgTimePerFrame: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_avg_time_per_frame: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_bit_rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitErrorRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_bit_error_rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoWidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_video_width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoHeight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_video_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            source_left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_source_left: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceWidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            source_width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceWidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_source_width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            source_top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_source_top: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceHeight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            source_height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceHeight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_source_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            destination_left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationLeft: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_destination_left: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationWidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            destination_width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationWidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_destination_width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            destination_top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationTop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_destination_top: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationHeight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            destination_height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationHeight: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBasicVideo,
            p_destination_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePosition: *const fn (
            self: *const IBasicVideo,
            left: i32,
            top: i32,
            width: i32,
            height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePosition: *const fn (
            self: *const IBasicVideo,
            p_left: ?*i32,
            p_top: ?*i32,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSourcePosition: *const fn (
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestinationPosition: *const fn (
            self: *const IBasicVideo,
            left: i32,
            top: i32,
            width: i32,
            height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestinationPosition: *const fn (
            self: *const IBasicVideo,
            p_left: ?*i32,
            p_top: ?*i32,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDestinationPosition: *const fn (
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSize: *const fn (
            self: *const IBasicVideo,
            p_width: ?*i32,
            p_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPaletteEntries: *const fn (
            self: *const IBasicVideo,
            start_index: i32,
            entries: i32,
            p_retrieved: ?*i32,
            p_palette: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: *const fn (
            self: *const IBasicVideo,
            p_buffer_size: ?*i32,
            p_d_i_b_image: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingDefaultSource: *const fn (
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingDefaultDestination: *const fn (
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAvgTimePerFrame(self: *const T, p_avg_time_per_frame_: ?*f64) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_AvgTimePerFrame(@as(*const IBasicVideo, @ptrCast(self)), p_avg_time_per_frame_);
            }
            pub inline fn getBitRate(self: *const T, p_bit_rate_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_BitRate(@as(*const IBasicVideo, @ptrCast(self)), p_bit_rate_);
            }
            pub inline fn getBitErrorRate(self: *const T, p_bit_error_rate_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_BitErrorRate(@as(*const IBasicVideo, @ptrCast(self)), p_bit_error_rate_);
            }
            pub inline fn getVideoWidth(self: *const T, p_video_width_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_VideoWidth(@as(*const IBasicVideo, @ptrCast(self)), p_video_width_);
            }
            pub inline fn getVideoHeight(self: *const T, p_video_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_VideoHeight(@as(*const IBasicVideo, @ptrCast(self)), p_video_height_);
            }
            pub inline fn putSourceLeft(self: *const T, source_left_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceLeft(@as(*const IBasicVideo, @ptrCast(self)), source_left_);
            }
            pub inline fn getSourceLeft(self: *const T, p_source_left_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceLeft(@as(*const IBasicVideo, @ptrCast(self)), p_source_left_);
            }
            pub inline fn putSourceWidth(self: *const T, source_width_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceWidth(@as(*const IBasicVideo, @ptrCast(self)), source_width_);
            }
            pub inline fn getSourceWidth(self: *const T, p_source_width_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceWidth(@as(*const IBasicVideo, @ptrCast(self)), p_source_width_);
            }
            pub inline fn putSourceTop(self: *const T, source_top_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceTop(@as(*const IBasicVideo, @ptrCast(self)), source_top_);
            }
            pub inline fn getSourceTop(self: *const T, p_source_top_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceTop(@as(*const IBasicVideo, @ptrCast(self)), p_source_top_);
            }
            pub inline fn putSourceHeight(self: *const T, source_height_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceHeight(@as(*const IBasicVideo, @ptrCast(self)), source_height_);
            }
            pub inline fn getSourceHeight(self: *const T, p_source_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceHeight(@as(*const IBasicVideo, @ptrCast(self)), p_source_height_);
            }
            pub inline fn putDestinationLeft(self: *const T, destination_left_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationLeft(@as(*const IBasicVideo, @ptrCast(self)), destination_left_);
            }
            pub inline fn getDestinationLeft(self: *const T, p_destination_left_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationLeft(@as(*const IBasicVideo, @ptrCast(self)), p_destination_left_);
            }
            pub inline fn putDestinationWidth(self: *const T, destination_width_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationWidth(@as(*const IBasicVideo, @ptrCast(self)), destination_width_);
            }
            pub inline fn getDestinationWidth(self: *const T, p_destination_width_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationWidth(@as(*const IBasicVideo, @ptrCast(self)), p_destination_width_);
            }
            pub inline fn putDestinationTop(self: *const T, destination_top_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationTop(@as(*const IBasicVideo, @ptrCast(self)), destination_top_);
            }
            pub inline fn getDestinationTop(self: *const T, p_destination_top_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationTop(@as(*const IBasicVideo, @ptrCast(self)), p_destination_top_);
            }
            pub inline fn putDestinationHeight(self: *const T, destination_height_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationHeight(@as(*const IBasicVideo, @ptrCast(self)), destination_height_);
            }
            pub inline fn getDestinationHeight(self: *const T, p_destination_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationHeight(@as(*const IBasicVideo, @ptrCast(self)), p_destination_height_);
            }
            pub inline fn setSourcePosition(self: *const T, left_: i32, top_: i32, width_: i32, height_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetSourcePosition(@as(*const IBasicVideo, @ptrCast(self)), left_, top_, width_, height_);
            }
            pub inline fn getSourcePosition(self: *const T, p_left_: ?*i32, p_top_: ?*i32, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetSourcePosition(@as(*const IBasicVideo, @ptrCast(self)), p_left_, p_top_, p_width_, p_height_);
            }
            pub inline fn setDefaultSourcePosition(self: *const T) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDefaultSourcePosition(@as(*const IBasicVideo, @ptrCast(self)));
            }
            pub inline fn setDestinationPosition(self: *const T, left_: i32, top_: i32, width_: i32, height_: i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)), left_, top_, width_, height_);
            }
            pub inline fn getDestinationPosition(self: *const T, p_left_: ?*i32, p_top_: ?*i32, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)), p_left_, p_top_, p_width_, p_height_);
            }
            pub inline fn setDefaultDestinationPosition(self: *const T) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDefaultDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)));
            }
            pub inline fn getVideoSize(self: *const T, p_width_: ?*i32, p_height_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetVideoSize(@as(*const IBasicVideo, @ptrCast(self)), p_width_, p_height_);
            }
            pub inline fn getVideoPaletteEntries(self: *const T, start_index_: i32, entries_: i32, p_retrieved_: ?*i32, p_palette_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetVideoPaletteEntries(@as(*const IBasicVideo, @ptrCast(self)), start_index_, entries_, p_retrieved_, p_palette_);
            }
            pub inline fn getCurrentImage(self: *const T, p_buffer_size_: ?*i32, p_d_i_b_image_: ?*i32) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IBasicVideo, @ptrCast(self)), p_buffer_size_, p_d_i_b_image_);
            }
            pub inline fn isUsingDefaultSource(self: *const T) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).IsUsingDefaultSource(@as(*const IBasicVideo, @ptrCast(self)));
            }
            pub inline fn isUsingDefaultDestination(self: *const T) HRESULT {
                return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).IsUsingDefaultDestination(@as(*const IBasicVideo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo2_Value = Guid.initString("329bb360-f6ea-11d1-9038-00a0c9697298");
pub const IID_IBasicVideo2 = &IID_IBasicVideo2_Value;
pub const IBasicVideo2 = extern struct {
    pub const VTable = extern struct {
        base: IBasicVideo.VTable,
        GetPreferredAspectRatio: *const fn (
            self: *const IBasicVideo2,
            pl_aspect_x: ?*i32,
            pl_aspect_y: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBasicVideo.MethodMixin(T);
            pub inline fn getPreferredAspectRatio(self: *const T, pl_aspect_x_: ?*i32, pl_aspect_y_: ?*i32) HRESULT {
                return @as(*const IBasicVideo2.VTable, @ptrCast(self.vtable)).GetPreferredAspectRatio(@as(*const IBasicVideo2, @ptrCast(self)), pl_aspect_x_, pl_aspect_y_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeferredCommand_Value = Guid.initString("56a868b8-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDeferredCommand = &IID_IDeferredCommand_Value;
pub const IDeferredCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: *const fn (
            self: *const IDeferredCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Confidence: *const fn (
            self: *const IDeferredCommand,
            p_confidence: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Postpone: *const fn (
            self: *const IDeferredCommand,
            newtime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHResult: *const fn (
            self: *const IDeferredCommand,
            phr_result: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn cancel(self: *const T) HRESULT {
                return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IDeferredCommand, @ptrCast(self)));
            }
            pub inline fn confidence(self: *const T, p_confidence_: ?*i32) HRESULT {
                return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Confidence(@as(*const IDeferredCommand, @ptrCast(self)), p_confidence_);
            }
            pub inline fn postpone(self: *const T, newtime_: f64) HRESULT {
                return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Postpone(@as(*const IDeferredCommand, @ptrCast(self)), newtime_);
            }
            pub inline fn getHResult(self: *const T, phr_result_: ?*HRESULT) HRESULT {
                return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).GetHResult(@as(*const IDeferredCommand, @ptrCast(self)), phr_result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueueCommand_Value = Guid.initString("56a868b7-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQueueCommand = &IID_IQueueCommand_Value;
pub const IQueueCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeAtStreamTime: *const fn (
            self: *const IQueueCommand,
            p_cmd: ?*?*IDeferredCommand,
            time: f64,
            iid: ?*Guid,
            dispid_method: i32,
            w_flags: i16,
            c_args: i32,
            p_disp_params: ?*VARIANT,
            pvar_result: ?*VARIANT,
            pu_arg_err: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeAtPresentationTime: *const fn (
            self: *const IQueueCommand,
            p_cmd: ?*?*IDeferredCommand,
            time: f64,
            iid: ?*Guid,
            dispid_method: i32,
            w_flags: i16,
            c_args: i32,
            p_disp_params: ?*VARIANT,
            pvar_result: ?*VARIANT,
            pu_arg_err: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn invokeAtStreamTime(self: *const T, p_cmd_: ?*?*IDeferredCommand, time_: f64, iid_: ?*Guid, dispid_method_: i32, w_flags_: i16, c_args_: i32, p_disp_params_: ?*VARIANT, pvar_result_: ?*VARIANT, pu_arg_err_: ?*i16) HRESULT {
                return @as(*const IQueueCommand.VTable, @ptrCast(self.vtable)).InvokeAtStreamTime(@as(*const IQueueCommand, @ptrCast(self)), p_cmd_, time_, iid_, dispid_method_, w_flags_, c_args_, p_disp_params_, pvar_result_, pu_arg_err_);
            }
            pub inline fn invokeAtPresentationTime(self: *const T, p_cmd_: ?*?*IDeferredCommand, time_: f64, iid_: ?*Guid, dispid_method_: i32, w_flags_: i16, c_args_: i32, p_disp_params_: ?*VARIANT, pvar_result_: ?*VARIANT, pu_arg_err_: ?*i16) HRESULT {
                return @as(*const IQueueCommand.VTable, @ptrCast(self.vtable)).InvokeAtPresentationTime(@as(*const IQueueCommand, @ptrCast(self)), p_cmd_, time_, iid_, dispid_method_, w_flags_, c_args_, p_disp_params_, pvar_result_, pu_arg_err_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterInfo_Value = Guid.initString("56a868ba-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterInfo = &IID_IFilterInfo_Value;
pub const IFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FindPin: *const fn (
            self: *const IFilterInfo,
            str_pin_i_d: ?BSTR,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            str_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            str_vendor_info: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pins: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFileSource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            pb_is_source: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filename: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            pstr_filename: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Filename: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFilterInfo,
            str_filename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn findPin(self: *const T, str_pin_i_d_: ?BSTR, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).FindPin(@as(*const IFilterInfo, @ptrCast(self)), str_pin_i_d_, pp_unk_);
            }
            pub inline fn getName(self: *const T, str_name_: ?*?BSTR) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFilterInfo, @ptrCast(self)), str_name_);
            }
            pub inline fn getVendorInfo(self: *const T, str_vendor_info_: ?*?BSTR) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_VendorInfo(@as(*const IFilterInfo, @ptrCast(self)), str_vendor_info_);
            }
            pub inline fn getFilter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Filter(@as(*const IFilterInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getPins(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Pins(@as(*const IFilterInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getIsFileSource(self: *const T, pb_is_source_: ?*i32) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_IsFileSource(@as(*const IFilterInfo, @ptrCast(self)), pb_is_source_);
            }
            pub inline fn getFilename(self: *const T, pstr_filename_: ?*?BSTR) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Filename(@as(*const IFilterInfo, @ptrCast(self)), pstr_filename_);
            }
            pub inline fn putFilename(self: *const T, str_filename_: ?BSTR) HRESULT {
                return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).put_Filename(@as(*const IFilterInfo, @ptrCast(self)), str_filename_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegFilterInfo_Value = Guid.initString("56a868bb-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IRegFilterInfo = &IID_IRegFilterInfo_Value;
pub const IRegFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRegFilterInfo,
            str_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Filter: *const fn (
            self: *const IRegFilterInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, str_name_: ?*?BSTR) HRESULT {
                return @as(*const IRegFilterInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRegFilterInfo, @ptrCast(self)), str_name_);
            }
            pub inline fn filter(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IRegFilterInfo.VTable, @ptrCast(self.vtable)).Filter(@as(*const IRegFilterInfo, @ptrCast(self)), pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaTypeInfo_Value = Guid.initString("56a868bc-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaTypeInfo = &IID_IMediaTypeInfo_Value;
pub const IMediaTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaTypeInfo,
            str_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subtype: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMediaTypeInfo,
            str_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, str_type_: ?*?BSTR) HRESULT {
                return @as(*const IMediaTypeInfo.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IMediaTypeInfo, @ptrCast(self)), str_type_);
            }
            pub inline fn getSubtype(self: *const T, str_type_: ?*?BSTR) HRESULT {
                return @as(*const IMediaTypeInfo.VTable, @ptrCast(self.vtable)).get_Subtype(@as(*const IMediaTypeInfo, @ptrCast(self)), str_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPinInfo_Value = Guid.initString("56a868bd-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPinInfo = &IID_IPinInfo_Value;
pub const IPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pin: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectedTo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionMediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_direction: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PinID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            str_pin_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IPinInfo,
            pp_unk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: *const fn (
            self: *const IPinInfo,
            p_pin: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDirect: *const fn (
            self: *const IPinInfo,
            p_pin: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectWithType: *const fn (
            self: *const IPinInfo,
            p_pin: ?*IUnknown,
            p_media_type: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: *const fn (
            self: *const IPinInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: *const fn (
            self: *const IPinInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getPin(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Pin(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getConnectedTo(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_ConnectedTo(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getConnectionMediaType(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_ConnectionMediaType(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getFilterInfo(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_FilterInfo(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getName(self: *const T, pp_unk_: ?*?BSTR) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getDirection(self: *const T, pp_direction_: ?*i32) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const IPinInfo, @ptrCast(self)), pp_direction_);
            }
            pub inline fn getPinID(self: *const T, str_pin_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_PinID(@as(*const IPinInfo, @ptrCast(self)), str_pin_i_d_);
            }
            pub inline fn getMediaTypes(self: *const T, pp_unk_: ?*?*IDispatch) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_MediaTypes(@as(*const IPinInfo, @ptrCast(self)), pp_unk_);
            }
            pub inline fn connect(self: *const T, p_pin_: ?*IUnknown) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Connect(@as(*const IPinInfo, @ptrCast(self)), p_pin_);
            }
            pub inline fn connectDirect(self: *const T, p_pin_: ?*IUnknown) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).ConnectDirect(@as(*const IPinInfo, @ptrCast(self)), p_pin_);
            }
            pub inline fn connectWithType(self: *const T, p_pin_: ?*IUnknown, p_media_type_: ?*IDispatch) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).ConnectWithType(@as(*const IPinInfo, @ptrCast(self)), p_pin_, p_media_type_);
            }
            pub inline fn disconnect(self: *const T) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IPinInfo, @ptrCast(self)));
            }
            pub inline fn render(self: *const T) HRESULT {
                return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Render(@as(*const IPinInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMStats_Value = Guid.initString("bc9bcf80-dcd2-11d2-abf6-00a0c905f375");
pub const IID_IAMStats = &IID_IAMStats_Value;
pub const IAMStats = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Reset: *const fn (
            self: *const IAMStats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAMStats,
            pl_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueByIndex: *const fn (
            self: *const IAMStats,
            l_index: i32,
            sz_name: ?*?BSTR,
            l_count: ?*i32,
            d_last: ?*f64,
            d_average: ?*f64,
            d_std_dev: ?*f64,
            d_min: ?*f64,
            d_max: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueByName: *const fn (
            self: *const IAMStats,
            sz_name: ?BSTR,
            l_index: ?*i32,
            l_count: ?*i32,
            d_last: ?*f64,
            d_average: ?*f64,
            d_std_dev: ?*f64,
            d_min: ?*f64,
            d_max: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: *const fn (
            self: *const IAMStats,
            sz_name: ?BSTR,
            l_create: i32,
            pl_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddValue: *const fn (
            self: *const IAMStats,
            l_index: i32,
            d_value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAMStats, @ptrCast(self)));
            }
            pub inline fn getCount(self: *const T, pl_count_: ?*i32) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IAMStats, @ptrCast(self)), pl_count_);
            }
            pub inline fn getValueByIndex(self: *const T, l_index_: i32, sz_name_: ?*?BSTR, l_count_: ?*i32, d_last_: ?*f64, d_average_: ?*f64, d_std_dev_: ?*f64, d_min_: ?*f64, d_max_: ?*f64) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetValueByIndex(@as(*const IAMStats, @ptrCast(self)), l_index_, sz_name_, l_count_, d_last_, d_average_, d_std_dev_, d_min_, d_max_);
            }
            pub inline fn getValueByName(self: *const T, sz_name_: ?BSTR, l_index_: ?*i32, l_count_: ?*i32, d_last_: ?*f64, d_average_: ?*f64, d_std_dev_: ?*f64, d_min_: ?*f64, d_max_: ?*f64) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetValueByName(@as(*const IAMStats, @ptrCast(self)), sz_name_, l_index_, l_count_, d_last_, d_average_, d_std_dev_, d_min_, d_max_);
            }
            pub inline fn getIndex(self: *const T, sz_name_: ?BSTR, l_create_: i32, pl_index_: ?*i32) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const IAMStats, @ptrCast(self)), sz_name_, l_create_, pl_index_);
            }
            pub inline fn addValue(self: *const T, l_index_: i32, d_value_: f64) HRESULT {
                return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).AddValue(@as(*const IAMStats, @ptrCast(self)), l_index_, d_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMVAUncompBufferInfo = extern struct {
    dwMinNumSurfaces: u32,
    dwMaxNumSurfaces: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAUncompDataInfo = extern struct {
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAInternalMemInfo = extern struct {
    dwScratchMemAlloc: u32,
};

pub const AMVACompBufferInfo = extern struct {
    dwNumCompBuffers: u32,
    dwWidthToCreate: u32,
    dwHeightToCreate: u32,
    dwBytesToAllocate: u32,
    ddCompCaps: DDSCAPS2,
    ddPixelFormat: DDPIXELFORMAT,
};

pub const AMVABeginFrameInfo = extern struct {
    dwDestSurfaceIndex: u32,
    pInputData: ?*anyopaque,
    dwSizeInputData: u32,
    pOutputData: ?*anyopaque,
    dwSizeOutputData: u32,
};

pub const AMVAEndFrameInfo = extern struct {
    dwSizeMiscData: u32,
    pMiscData: ?*anyopaque,
};

pub const AMVABUFFERINFO = extern struct {
    dwTypeIndex: u32,
    dwBufferIndex: u32,
    dwDataOffset: u32,
    dwDataSize: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAcceleratorNotify_Value = Guid.initString("256a6a21-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAcceleratorNotify = &IID_IAMVideoAcceleratorNotify_Value;
pub const IAMVideoAcceleratorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUncompSurfacesInfo: *const fn (
            self: *const IAMVideoAcceleratorNotify,
            p_guid: ?*const Guid,
            p_uncomp_buffer_info: ?*AMVAUncompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUncompSurfacesInfo: *const fn (
            self: *const IAMVideoAcceleratorNotify,
            dw_actual_uncomp_surfaces_allocated: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreateVideoAcceleratorData: *const fn (
            self: *const IAMVideoAcceleratorNotify,
            p_guid: ?*const Guid,
            pdw_size_misc_data: ?*u32,
            pp_misc_data: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getUncompSurfacesInfo(self: *const T, p_guid_: ?*const Guid, p_uncomp_buffer_info_: ?*AMVAUncompBufferInfo) HRESULT {
                return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).GetUncompSurfacesInfo(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), p_guid_, p_uncomp_buffer_info_);
            }
            pub inline fn setUncompSurfacesInfo(self: *const T, dw_actual_uncomp_surfaces_allocated_: u32) HRESULT {
                return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).SetUncompSurfacesInfo(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), dw_actual_uncomp_surfaces_allocated_);
            }
            pub inline fn getCreateVideoAcceleratorData(self: *const T, p_guid_: ?*const Guid, pdw_size_misc_data_: ?*u32, pp_misc_data_: ?*?*anyopaque) HRESULT {
                return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).GetCreateVideoAcceleratorData(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), p_guid_, pdw_size_misc_data_, pp_misc_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAccelerator_Value = Guid.initString("256a6a22-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAccelerator = &IID_IAMVideoAccelerator_Value;
pub const IAMVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoAcceleratorGUIDs: *const fn (
            self: *const IAMVideoAccelerator,
            pdw_num_guids_supported: ?*u32,
            p_guids_supported: ?[*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUncompFormatsSupported: *const fn (
            self: *const IAMVideoAccelerator,
            p_guid: ?*const Guid,
            pdw_num_formats_supported: ?*u32,
            p_formats_supported: ?[*]DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInternalMemInfo: *const fn (
            self: *const IAMVideoAccelerator,
            p_guid: ?*const Guid,
            pamva_uncomp_data_info: ?*const AMVAUncompDataInfo,
            pamva_internal_mem_info: ?*AMVAInternalMemInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompBufferInfo: *const fn (
            self: *const IAMVideoAccelerator,
            p_guid: ?*const Guid,
            pamva_uncomp_data_info: ?*const AMVAUncompDataInfo,
            pdw_num_types_comp_buffers: ?*u32,
            pamva_comp_buffer_info: ?[*]AMVACompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInternalCompBufferInfo: *const fn (
            self: *const IAMVideoAccelerator,
            pdw_num_types_comp_buffers: ?*u32,
            pamva_comp_buffer_info: ?[*]AMVACompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFrame: *const fn (
            self: *const IAMVideoAccelerator,
            amva_begin_frame_info: ?*const AMVABeginFrameInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFrame: *const fn (
            self: *const IAMVideoAccelerator,
            p_end_frame_info: ?*const AMVAEndFrameInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: *const fn (
            self: *const IAMVideoAccelerator,
            dw_type_index: u32,
            dw_buffer_index: u32,
            b_read_only: BOOL,
            pp_buffer: ?*?*anyopaque,
            lp_stride: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: *const fn (
            self: *const IAMVideoAccelerator,
            dw_type_index: u32,
            dw_buffer_index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: *const fn (
            self: *const IAMVideoAccelerator,
            dw_function: u32,
            lp_private_input_data: ?*anyopaque,
            cb_private_input_data: u32,
            lp_private_output_dat: ?*anyopaque,
            cb_private_output_data: u32,
            dw_num_buffers: u32,
            pamva_buffer_info: [*]const AMVABUFFERINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRenderStatus: *const fn (
            self: *const IAMVideoAccelerator,
            dw_type_index: u32,
            dw_buffer_index: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayFrame: *const fn (
            self: *const IAMVideoAccelerator,
            dw_flip_to_index: u32,
            p_media_sample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getVideoAcceleratorGUIDs(self: *const T, pdw_num_guids_supported_: ?*u32, p_guids_supported_: ?[*]Guid) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetVideoAcceleratorGUIDs(@as(*const IAMVideoAccelerator, @ptrCast(self)), pdw_num_guids_supported_, p_guids_supported_);
            }
            pub inline fn getUncompFormatsSupported(self: *const T, p_guid_: ?*const Guid, pdw_num_formats_supported_: ?*u32, p_formats_supported_: ?[*]DDPIXELFORMAT) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetUncompFormatsSupported(@as(*const IAMVideoAccelerator, @ptrCast(self)), p_guid_, pdw_num_formats_supported_, p_formats_supported_);
            }
            pub inline fn getInternalMemInfo(self: *const T, p_guid_: ?*const Guid, pamva_uncomp_data_info_: ?*const AMVAUncompDataInfo, pamva_internal_mem_info_: ?*AMVAInternalMemInfo) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetInternalMemInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), p_guid_, pamva_uncomp_data_info_, pamva_internal_mem_info_);
            }
            pub inline fn getCompBufferInfo(self: *const T, p_guid_: ?*const Guid, pamva_uncomp_data_info_: ?*const AMVAUncompDataInfo, pdw_num_types_comp_buffers_: ?*u32, pamva_comp_buffer_info_: ?[*]AMVACompBufferInfo) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetCompBufferInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), p_guid_, pamva_uncomp_data_info_, pdw_num_types_comp_buffers_, pamva_comp_buffer_info_);
            }
            pub inline fn getInternalCompBufferInfo(self: *const T, pdw_num_types_comp_buffers_: ?*u32, pamva_comp_buffer_info_: ?[*]AMVACompBufferInfo) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetInternalCompBufferInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), pdw_num_types_comp_buffers_, pamva_comp_buffer_info_);
            }
            pub inline fn beginFrame(self: *const T, amva_begin_frame_info_: ?*const AMVABeginFrameInfo) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).BeginFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), amva_begin_frame_info_);
            }
            pub inline fn endFrame(self: *const T, p_end_frame_info_: ?*const AMVAEndFrameInfo) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).EndFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), p_end_frame_info_);
            }
            pub inline fn getBuffer(self: *const T, dw_type_index_: u32, dw_buffer_index_: u32, b_read_only_: BOOL, pp_buffer_: ?*?*anyopaque, lp_stride_: ?*i32) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAMVideoAccelerator, @ptrCast(self)), dw_type_index_, dw_buffer_index_, b_read_only_, pp_buffer_, lp_stride_);
            }
            pub inline fn releaseBuffer(self: *const T, dw_type_index_: u32, dw_buffer_index_: u32) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAMVideoAccelerator, @ptrCast(self)), dw_type_index_, dw_buffer_index_);
            }
            pub inline fn execute(self: *const T, dw_function_: u32, lp_private_input_data_: ?*anyopaque, cb_private_input_data_: u32, lp_private_output_dat_: ?*anyopaque, cb_private_output_data_: u32, dw_num_buffers_: u32, pamva_buffer_info_: [*]const AMVABUFFERINFO) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).Execute(@as(*const IAMVideoAccelerator, @ptrCast(self)), dw_function_, lp_private_input_data_, cb_private_input_data_, lp_private_output_dat_, cb_private_output_data_, dw_num_buffers_, pamva_buffer_info_);
            }
            pub inline fn queryRenderStatus(self: *const T, dw_type_index_: u32, dw_buffer_index_: u32, dw_flags_: u32) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).QueryRenderStatus(@as(*const IAMVideoAccelerator, @ptrCast(self)), dw_type_index_, dw_buffer_index_, dw_flags_);
            }
            pub inline fn displayFrame(self: *const T, dw_flip_to_index_: u32, p_media_sample_: ?*IMediaSample) HRESULT {
                return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).DisplayFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), dw_flip_to_index_, p_media_sample_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_WST_PAGE = extern struct {
    dwPageNr: u32,
    dwSubPageNr: u32,
    pucPageData: ?*u8,
};

pub const AM_WST_LEVEL = enum(i32) {
    @"5" = 0,
};
pub const AM_WST_LEVEL_1_5 = AM_WST_LEVEL.@"5";

pub const AM_WST_SERVICE = enum(i32) {
    None = 0,
    Text = 1,
    IDS = 2,
    Invalid = 3,
};
pub const AM_WST_SERVICE_None = AM_WST_SERVICE.None;
pub const AM_WST_SERVICE_Text = AM_WST_SERVICE.Text;
pub const AM_WST_SERVICE_IDS = AM_WST_SERVICE.IDS;
pub const AM_WST_SERVICE_Invalid = AM_WST_SERVICE.Invalid;

pub const AM_WST_STATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_WST_STATE_Off = AM_WST_STATE.ff;
pub const AM_WST_STATE_On = AM_WST_STATE.n;

pub const AM_WST_STYLE = enum(i32) {
    None = 0,
    Invers = 1,
};
pub const AM_WST_STYLE_None = AM_WST_STYLE.None;
pub const AM_WST_STYLE_Invers = AM_WST_STYLE.Invers;

pub const AM_WST_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_WST_DRAWBGMODE_Opaque = AM_WST_DRAWBGMODE.Opaque;
pub const AM_WST_DRAWBGMODE_Transparent = AM_WST_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.1.2600'
pub const IAMWstDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: *const fn (
            self: *const IAMWstDecoder,
            lp_level: ?*AM_WST_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentService: *const fn (
            self: *const IAMWstDecoder,
            lp_service: ?*AM_WST_SERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceState: *const fn (
            self: *const IAMWstDecoder,
            lp_state: ?*AM_WST_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServiceState: *const fn (
            self: *const IAMWstDecoder,
            state: AM_WST_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFormat: *const fn (
            self: *const IAMWstDecoder,
            lpbmih: ?*BITMAPINFOHEADER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFormat: *const fn (
            self: *const IAMWstDecoder,
            lpbmi: ?*BITMAPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: *const fn (
            self: *const IAMWstDecoder,
            pdw_phys_color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: *const fn (
            self: *const IAMWstDecoder,
            dw_phys_color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedrawAlways: *const fn (
            self: *const IAMWstDecoder,
            lpb_option: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedrawAlways: *const fn (
            self: *const IAMWstDecoder,
            b_option: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawBackgroundMode: *const fn (
            self: *const IAMWstDecoder,
            lp_mode: ?*AM_WST_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawBackgroundMode: *const fn (
            self: *const IAMWstDecoder,
            mode: AM_WST_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnswerMode: *const fn (
            self: *const IAMWstDecoder,
            b_answer: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnswerMode: *const fn (
            self: *const IAMWstDecoder,
            pb_answer: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHoldPage: *const fn (
            self: *const IAMWstDecoder,
            b_hold_page: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHoldPage: *const fn (
            self: *const IAMWstDecoder,
            pb_hold_page: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPage: *const fn (
            self: *const IAMWstDecoder,
            p_wst_page: ?*AM_WST_PAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentPage: *const fn (
            self: *const IAMWstDecoder,
            wst_page: AM_WST_PAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDecoderLevel(self: *const T, lp_level_: ?*AM_WST_LEVEL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetDecoderLevel(@as(*const IAMWstDecoder, @ptrCast(self)), lp_level_);
            }
            pub inline fn getCurrentService(self: *const T, lp_service_: ?*AM_WST_SERVICE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetCurrentService(@as(*const IAMWstDecoder, @ptrCast(self)), lp_service_);
            }
            pub inline fn getServiceState(self: *const T, lp_state_: ?*AM_WST_STATE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetServiceState(@as(*const IAMWstDecoder, @ptrCast(self)), lp_state_);
            }
            pub inline fn setServiceState(self: *const T, state_: AM_WST_STATE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetServiceState(@as(*const IAMWstDecoder, @ptrCast(self)), state_);
            }
            pub inline fn getOutputFormat(self: *const T, lpbmih_: ?*BITMAPINFOHEADER) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IAMWstDecoder, @ptrCast(self)), lpbmih_);
            }
            pub inline fn setOutputFormat(self: *const T, lpbmi_: ?*BITMAPINFO) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetOutputFormat(@as(*const IAMWstDecoder, @ptrCast(self)), lpbmi_);
            }
            pub inline fn getBackgroundColor(self: *const T, pdw_phys_color_: ?*u32) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IAMWstDecoder, @ptrCast(self)), pdw_phys_color_);
            }
            pub inline fn setBackgroundColor(self: *const T, dw_phys_color_: u32) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IAMWstDecoder, @ptrCast(self)), dw_phys_color_);
            }
            pub inline fn getRedrawAlways(self: *const T, lpb_option_: ?*i32) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetRedrawAlways(@as(*const IAMWstDecoder, @ptrCast(self)), lpb_option_);
            }
            pub inline fn setRedrawAlways(self: *const T, b_option_: BOOL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetRedrawAlways(@as(*const IAMWstDecoder, @ptrCast(self)), b_option_);
            }
            pub inline fn getDrawBackgroundMode(self: *const T, lp_mode_: ?*AM_WST_DRAWBGMODE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetDrawBackgroundMode(@as(*const IAMWstDecoder, @ptrCast(self)), lp_mode_);
            }
            pub inline fn setDrawBackgroundMode(self: *const T, mode_: AM_WST_DRAWBGMODE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetDrawBackgroundMode(@as(*const IAMWstDecoder, @ptrCast(self)), mode_);
            }
            pub inline fn setAnswerMode(self: *const T, b_answer_: BOOL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetAnswerMode(@as(*const IAMWstDecoder, @ptrCast(self)), b_answer_);
            }
            pub inline fn getAnswerMode(self: *const T, pb_answer_: ?*BOOL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetAnswerMode(@as(*const IAMWstDecoder, @ptrCast(self)), pb_answer_);
            }
            pub inline fn setHoldPage(self: *const T, b_hold_page_: BOOL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetHoldPage(@as(*const IAMWstDecoder, @ptrCast(self)), b_hold_page_);
            }
            pub inline fn getHoldPage(self: *const T, pb_hold_page_: ?*BOOL) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetHoldPage(@as(*const IAMWstDecoder, @ptrCast(self)), pb_hold_page_);
            }
            pub inline fn getCurrentPage(self: *const T, p_wst_page_: ?*AM_WST_PAGE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetCurrentPage(@as(*const IAMWstDecoder, @ptrCast(self)), p_wst_page_);
            }
            pub inline fn setCurrentPage(self: *const T, wst_page_: AM_WST_PAGE) HRESULT {
                return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetCurrentPage(@as(*const IAMWstDecoder, @ptrCast(self)), wst_page_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IKsTopologyInfo_Value = Guid.initString("720d4ac0-7533-11d0-a5d6-28db04c10000");
pub const IID_IKsTopologyInfo = &IID_IKsTopologyInfo_Value;
pub const IKsTopologyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumCategories: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            pdw_num_categories: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            dw_index: u32,
            p_category: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumConnections: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            pdw_num_connections: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            dw_index: u32,
            p_connection_info: ?*KSTOPOLOGY_CONNECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NodeName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            dw_node_id: u32,
            // TODO: what to do with BytesParamIndex 2?
            pwch_node_name: ?PWSTR,
            dw_buf_size: u32,
            pdw_name_len: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumNodes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            pdw_num_nodes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NodeType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsTopologyInfo,
            dw_node_id: u32,
            p_node_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNodeInstance: *const fn (
            self: *const IKsTopologyInfo,
            dw_node_id: u32,
            iid: ?*const Guid,
            ppv_object: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumCategories(self: *const T, pdw_num_categories_: ?*u32) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_NumCategories(@as(*const IKsTopologyInfo, @ptrCast(self)), pdw_num_categories_);
            }
            pub inline fn getCategory(self: *const T, dw_index_: u32, p_category_: ?*Guid) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IKsTopologyInfo, @ptrCast(self)), dw_index_, p_category_);
            }
            pub inline fn getNumConnections(self: *const T, pdw_num_connections_: ?*u32) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_NumConnections(@as(*const IKsTopologyInfo, @ptrCast(self)), pdw_num_connections_);
            }
            pub inline fn getConnectionInfo(self: *const T, dw_index_: u32, p_connection_info_: ?*KSTOPOLOGY_CONNECTION) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_ConnectionInfo(@as(*const IKsTopologyInfo, @ptrCast(self)), dw_index_, p_connection_info_);
            }
            pub inline fn getNodeName(self: *const T, dw_node_id_: u32, pwch_node_name_: ?PWSTR, dw_buf_size_: u32, pdw_name_len_: ?*u32) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_NodeName(@as(*const IKsTopologyInfo, @ptrCast(self)), dw_node_id_, pwch_node_name_, dw_buf_size_, pdw_name_len_);
            }
            pub inline fn getNumNodes(self: *const T, pdw_num_nodes_: ?*u32) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_NumNodes(@as(*const IKsTopologyInfo, @ptrCast(self)), pdw_num_nodes_);
            }
            pub inline fn getNodeType(self: *const T, dw_node_id_: u32, p_node_type_: ?*Guid) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).get_NodeType(@as(*const IKsTopologyInfo, @ptrCast(self)), dw_node_id_, p_node_type_);
            }
            pub inline fn createNodeInstance(self: *const T, dw_node_id_: u32, iid_: ?*const Guid, ppv_object_: ?*?*anyopaque) HRESULT {
                return @as(*const IKsTopologyInfo.VTable, @ptrCast(self.vtable)).CreateNodeInstance(@as(*const IKsTopologyInfo, @ptrCast(self)), dw_node_id_, iid_, ppv_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISelector_Value = Guid.initString("1abdaeca-68b6-4f83-9371-b413907c7b9f");
pub const IID_ISelector = &IID_ISelector_Value;
pub const ISelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumSources: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISelector,
            pdw_num_sources: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceNodeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISelector,
            pdw_pin_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceNodeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISelector,
            dw_pin_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumSources(self: *const T, pdw_num_sources_: ?*u32) HRESULT {
                return @as(*const ISelector.VTable, @ptrCast(self.vtable)).get_NumSources(@as(*const ISelector, @ptrCast(self)), pdw_num_sources_);
            }
            pub inline fn getSourceNodeId(self: *const T, pdw_pin_id_: ?*u32) HRESULT {
                return @as(*const ISelector.VTable, @ptrCast(self.vtable)).get_SourceNodeId(@as(*const ISelector, @ptrCast(self)), pdw_pin_id_);
            }
            pub inline fn putSourceNodeId(self: *const T, dw_pin_id_: u32) HRESULT {
                return @as(*const ISelector.VTable, @ptrCast(self.vtable)).put_SourceNodeId(@as(*const ISelector, @ptrCast(self)), dw_pin_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICameraControl_Value = Guid.initString("2ba1785d-4d1b-44ef-85e8-c7f1d3f20184");
pub const IID_ICameraControl = &IID_ICameraControl_Value;
pub const ICameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Exposure: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Exposure: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Exposure: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Focus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Focus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Focus: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Iris: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Iris: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Iris: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Zoom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Zoom: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Zoom: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocalLengths: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            pl_ocular_focal_length: ?*i32,
            pl_objective_focal_length_min: ?*i32,
            pl_objective_focal_length_max: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Pan: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tilt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Tilt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Tilt: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanTilt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_pan_value: ?*i32,
            p_tilt_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanTilt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            pan_value: i32,
            tilt_value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Roll: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Roll: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Roll: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExposureRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExposureRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ExposureRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocusRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FocusRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_FocusRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IrisRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IrisRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_IrisRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ZoomRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ZoomRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ZoomRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TiltRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TiltRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_TiltRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanTiltRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_pan_value: ?*i32,
            p_tilt_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanTiltRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            pan_value: i32,
            tilt_value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_PanRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RollRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RollRelative: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_RollRelative: *const fn (
            self: *const ICameraControl,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScanMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScanMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivacyMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrivacyMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICameraControl,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getExposure(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Exposure(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putExposure(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Exposure(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeExposure(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Exposure(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getFocus(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Focus(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putFocus(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Focus(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeFocus(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Focus(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getIris(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Iris(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putIris(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Iris(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeIris(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Iris(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getZoom(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Zoom(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putZoom(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Zoom(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeZoom(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Zoom(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getFocalLengths(self: *const T, pl_ocular_focal_length_: ?*i32, pl_objective_focal_length_min_: ?*i32, pl_objective_focal_length_max_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_FocalLengths(@as(*const ICameraControl, @ptrCast(self)), pl_ocular_focal_length_, pl_objective_focal_length_min_, pl_objective_focal_length_max_);
            }
            pub inline fn getPan(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Pan(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putPan(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Pan(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangePan(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Pan(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getTilt(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Tilt(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putTilt(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Tilt(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeTilt(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Tilt(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getPanTilt(self: *const T, p_pan_value_: ?*i32, p_tilt_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanTilt(@as(*const ICameraControl, @ptrCast(self)), p_pan_value_, p_tilt_value_, p_flags_);
            }
            pub inline fn putPanTilt(self: *const T, pan_value_: i32, tilt_value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanTilt(@as(*const ICameraControl, @ptrCast(self)), pan_value_, tilt_value_, flags_);
            }
            pub inline fn getRoll(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Roll(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putRoll(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Roll(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeRoll(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Roll(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getExposureRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putExposureRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeExposureRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getFocusRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putFocusRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeFocusRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getIrisRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putIrisRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeIrisRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getZoomRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putZoomRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeZoomRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getPanRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putPanRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getTiltRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putTiltRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeTiltRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getPanTiltRelative(self: *const T, p_pan_value_: ?*i32, p_tilt_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanTiltRelative(@as(*const ICameraControl, @ptrCast(self)), p_pan_value_, p_tilt_value_, p_flags_);
            }
            pub inline fn putPanTiltRelative(self: *const T, pan_value_: i32, tilt_value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanTiltRelative(@as(*const ICameraControl, @ptrCast(self)), pan_value_, tilt_value_, flags_);
            }
            pub inline fn getRangePanRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_PanRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getRollRelative(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_RollRelative(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putRollRelative(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_RollRelative(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeRollRelative(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_RollRelative(@as(*const ICameraControl, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getScanMode(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ScanMode(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putScanMode(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ScanMode(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getPrivacyMode(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PrivacyMode(@as(*const ICameraControl, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putPrivacyMode(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PrivacyMode(@as(*const ICameraControl, @ptrCast(self)), value_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoProcAmp_Value = Guid.initString("4050560e-42a7-413a-85c2-09269a2d0f44");
pub const IID_IVideoProcAmp = &IID_IVideoProcAmp_Value;
pub const IVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BacklightCompensation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BacklightCompensation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_BacklightCompensation: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Brightness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Brightness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Brightness: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorEnable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ColorEnable: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Contrast: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Contrast: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Contrast: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Gamma: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Gamma: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Gamma: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Saturation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Saturation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Saturation: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Sharpness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Sharpness: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Sharpness: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WhiteBalance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WhiteBalance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_WhiteBalance: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Gain: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Gain: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Gain: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hue: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hue: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Hue: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitalMultiplier: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DigitalMultiplier: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_DigitalMultiplier: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PowerlineFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PowerlineFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_PowerlineFrequency: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WhiteBalanceComponent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            p_value1: ?*i32,
            p_value2: ?*i32,
            p_flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WhiteBalanceComponent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IVideoProcAmp,
            value1: i32,
            value2: i32,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_WhiteBalanceComponent: *const fn (
            self: *const IVideoProcAmp,
            p_min: ?*i32,
            p_max: ?*i32,
            p_stepping_delta: ?*i32,
            p_default: ?*i32,
            p_caps_flag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBacklightCompensation(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putBacklightCompensation(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeBacklightCompensation(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getBrightness(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putBrightness(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeBrightness(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getColorEnable(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putColorEnable(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeColorEnable(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getContrast(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putContrast(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeContrast(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getGamma(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putGamma(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeGamma(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getSaturation(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putSaturation(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeSaturation(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getSharpness(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putSharpness(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeSharpness(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getWhiteBalance(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putWhiteBalance(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeWhiteBalance(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getGain(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putGain(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeGain(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getHue(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putHue(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeHue(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getDigitalMultiplier(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putDigitalMultiplier(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangeDigitalMultiplier(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getPowerlineFrequency(self: *const T, p_value_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), p_value_, p_flags_);
            }
            pub inline fn putPowerlineFrequency(self: *const T, value_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), value_, flags_);
            }
            pub inline fn getRangePowerlineFrequency(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
            pub inline fn getWhiteBalanceComponent(self: *const T, p_value1_: ?*i32, p_value2_: ?*i32, p_flags_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), p_value1_, p_value2_, p_flags_);
            }
            pub inline fn putWhiteBalanceComponent(self: *const T, value1_: i32, value2_: i32, flags_: i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), value1_, value2_, flags_);
            }
            pub inline fn getRangeWhiteBalanceComponent(self: *const T, p_min_: ?*i32, p_max_: ?*i32, p_stepping_delta_: ?*i32, p_default_: ?*i32, p_caps_flag_: ?*i32) HRESULT {
                return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), p_min_, p_max_, p_stepping_delta_, p_default_, p_caps_flag_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IKsNodeControl_Value = Guid.initString("11737c14-24a7-4bb5-81a0-0d003813b0c4");
pub const IID_IKsNodeControl = &IID_IKsNodeControl_Value;
pub const IKsNodeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NodeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsNodeControl,
            dw_node_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KsControl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IKsNodeControl,
            p_ks_control: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putNodeId(self: *const T, dw_node_id_: u32) HRESULT {
                return @as(*const IKsNodeControl.VTable, @ptrCast(self.vtable)).put_NodeId(@as(*const IKsNodeControl, @ptrCast(self)), dw_node_id_);
            }
            pub inline fn putKsControl(self: *const T, p_ks_control_: ?*anyopaque) HRESULT {
                return @as(*const IKsNodeControl.VTable, @ptrCast(self.vtable)).put_KsControl(@as(*const IKsNodeControl, @ptrCast(self)), p_ks_control_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter_Value = Guid.initString("45086030-f7e4-486a-b504-826bb5792a3b");
pub const IID_IConfigAsfWriter = &IID_IConfigAsfWriter_Value;
pub const IConfigAsfWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConfigureFilterUsingProfileId: *const fn (
            self: *const IConfigAsfWriter,
            dw_profile_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfileId: *const fn (
            self: *const IConfigAsfWriter,
            pdw_profile_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureFilterUsingProfileGuid: *const fn (
            self: *const IConfigAsfWriter,
            guid_profile: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfileGuid: *const fn (
            self: *const IConfigAsfWriter,
            p_profile_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureFilterUsingProfile: *const fn (
            self: *const IConfigAsfWriter,
            p_profile: ?*IWMProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfile: *const fn (
            self: *const IConfigAsfWriter,
            pp_profile: ?*?*IWMProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndexMode: *const fn (
            self: *const IConfigAsfWriter,
            b_index_file: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexMode: *const fn (
            self: *const IConfigAsfWriter,
            pb_index_file: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn configureFilterUsingProfileId(self: *const T, dw_profile_id_: u32) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfileId(@as(*const IConfigAsfWriter, @ptrCast(self)), dw_profile_id_);
            }
            pub inline fn getCurrentProfileId(self: *const T, pdw_profile_id_: ?*u32) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfileId(@as(*const IConfigAsfWriter, @ptrCast(self)), pdw_profile_id_);
            }
            pub inline fn configureFilterUsingProfileGuid(self: *const T, guid_profile_: ?*const Guid) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfileGuid(@as(*const IConfigAsfWriter, @ptrCast(self)), guid_profile_);
            }
            pub inline fn getCurrentProfileGuid(self: *const T, p_profile_guid_: ?*Guid) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfileGuid(@as(*const IConfigAsfWriter, @ptrCast(self)), p_profile_guid_);
            }
            pub inline fn configureFilterUsingProfile(self: *const T, p_profile_: ?*IWMProfile) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfile(@as(*const IConfigAsfWriter, @ptrCast(self)), p_profile_);
            }
            pub inline fn getCurrentProfile(self: *const T, pp_profile_: ?*?*IWMProfile) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfile(@as(*const IConfigAsfWriter, @ptrCast(self)), pp_profile_);
            }
            pub inline fn setIndexMode(self: *const T, b_index_file_: BOOL) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).SetIndexMode(@as(*const IConfigAsfWriter, @ptrCast(self)), b_index_file_);
            }
            pub inline fn getIndexMode(self: *const T, pb_index_file_: ?*BOOL) HRESULT {
                return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetIndexMode(@as(*const IConfigAsfWriter, @ptrCast(self)), pb_index_file_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter2_Value = Guid.initString("7989ccaa-53f0-44f0-884a-f3b03f6ae066");
pub const IID_IConfigAsfWriter2 = &IID_IConfigAsfWriter2_Value;
pub const IConfigAsfWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IConfigAsfWriter.VTable,
        StreamNumFromPin: *const fn (
            self: *const IConfigAsfWriter2,
            p_pin: ?*IPin,
            pw_stream_num: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: *const fn (
            self: *const IConfigAsfWriter2,
            dw_param: u32,
            dw_param1: u32,
            dw_param2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParam: *const fn (
            self: *const IConfigAsfWriter2,
            dw_param: u32,
            pdw_param1: ?*u32,
            pdw_param2: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetMultiPassState: *const fn (
            self: *const IConfigAsfWriter2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConfigAsfWriter.MethodMixin(T);
            pub inline fn streamNumFromPin(self: *const T, p_pin_: ?*IPin, pw_stream_num_: ?*u16) HRESULT {
                return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).StreamNumFromPin(@as(*const IConfigAsfWriter2, @ptrCast(self)), p_pin_, pw_stream_num_);
            }
            pub inline fn setParam(self: *const T, dw_param_: u32, dw_param1_: u32, dw_param2_: u32) HRESULT {
                return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).SetParam(@as(*const IConfigAsfWriter2, @ptrCast(self)), dw_param_, dw_param1_, dw_param2_);
            }
            pub inline fn getParam(self: *const T, dw_param_: u32, pdw_param1_: ?*u32, pdw_param2_: ?*u32) HRESULT {
                return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).GetParam(@as(*const IConfigAsfWriter2, @ptrCast(self)), dw_param_, pdw_param1_, pdw_param2_);
            }
            pub inline fn resetMultiPassState(self: *const T) HRESULT {
                return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).ResetMultiPassState(@as(*const IConfigAsfWriter2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_TYPE = enum(i32) {
    READ = 0,
    WRITE = 1,
    TRANSFORM = 2,
};
pub const STREAMTYPE_READ = STREAM_TYPE.READ;
pub const STREAMTYPE_WRITE = STREAM_TYPE.WRITE;
pub const STREAMTYPE_TRANSFORM = STREAM_TYPE.TRANSFORM;

pub const STREAM_STATE = enum(i32) {
    STOP = 0,
    RUN = 1,
};
pub const STREAMSTATE_STOP = STREAM_STATE.STOP;
pub const STREAMSTATE_RUN = STREAM_STATE.RUN;

pub const COMPLETION_STATUS_FLAGS = enum(i32) {
    NOUPDATEOK = 1,
    WAIT = 2,
    ABORT = 4,
};
pub const COMPSTAT_NOUPDATEOK = COMPLETION_STATUS_FLAGS.NOUPDATEOK;
pub const COMPSTAT_WAIT = COMPLETION_STATUS_FLAGS.WAIT;
pub const COMPSTAT_ABORT = COMPLETION_STATUS_FLAGS.ABORT;

pub const MMSSF_GET_INFORMATION_FLAGS = enum(u32) {
    HASCLOCK = 1,
    SUPPORTSEEK = 2,
    ASYNCHRONOUS = 4,
    _,
    pub fn initFlags(o: struct {
        HASCLOCK: u1 = 0,
        SUPPORTSEEK: u1 = 0,
        ASYNCHRONOUS: u1 = 0,
    }) MMSSF_GET_INFORMATION_FLAGS {
        return @as(MMSSF_GET_INFORMATION_FLAGS, @enumFromInt((if (o.HASCLOCK == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.HASCLOCK) else 0) | (if (o.SUPPORTSEEK == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK) else 0) | (if (o.ASYNCHRONOUS == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS) else 0)));
    }
};
pub const MMSSF_HASCLOCK = MMSSF_GET_INFORMATION_FLAGS.HASCLOCK;
pub const MMSSF_SUPPORTSEEK = MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK;
pub const MMSSF_ASYNCHRONOUS = MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS;

pub const SSUPDATE_TYPE = enum(i32) {
    ASYNC = 1,
    CONTINUOUS = 2,
};
pub const SSUPDATE_ASYNC = SSUPDATE_TYPE.ASYNC;
pub const SSUPDATE_CONTINUOUS = SSUPDATE_TYPE.CONTINUOUS;

const IID_IMultiMediaStream_Value = Guid.initString("b502d1bc-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMultiMediaStream = &IID_IMultiMediaStream_Value;
pub const IMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInformation: *const fn (
            self: *const IMultiMediaStream,
            pdw_flags: ?*MMSSF_GET_INFORMATION_FLAGS,
            p_stream_type: ?*STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaStream: *const fn (
            self: *const IMultiMediaStream,
            id_purpose: ?*Guid,
            pp_media_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaStreams: *const fn (
            self: *const IMultiMediaStream,
            index: i32,
            pp_media_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IMultiMediaStream,
            p_current_state: ?*STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: *const fn (
            self: *const IMultiMediaStream,
            new_state: STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTime: *const fn (
            self: *const IMultiMediaStream,
            p_current_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: *const fn (
            self: *const IMultiMediaStream,
            p_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: *const fn (
            self: *const IMultiMediaStream,
            seek_time: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndOfStreamEventHandle: *const fn (
            self: *const IMultiMediaStream,
            ph_e_o_s: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getInformation(self: *const T, pdw_flags_: ?*MMSSF_GET_INFORMATION_FLAGS, p_stream_type_: ?*STREAM_TYPE) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetInformation(@as(*const IMultiMediaStream, @ptrCast(self)), pdw_flags_, p_stream_type_);
            }
            pub inline fn getMediaStream(self: *const T, id_purpose_: ?*Guid, pp_media_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IMultiMediaStream, @ptrCast(self)), id_purpose_, pp_media_stream_);
            }
            pub inline fn enumMediaStreams(self: *const T, index_: i32, pp_media_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).EnumMediaStreams(@as(*const IMultiMediaStream, @ptrCast(self)), index_, pp_media_stream_);
            }
            pub inline fn getState(self: *const T, p_current_state_: ?*STREAM_STATE) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMultiMediaStream, @ptrCast(self)), p_current_state_);
            }
            pub inline fn setState(self: *const T, new_state_: STREAM_STATE) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).SetState(@as(*const IMultiMediaStream, @ptrCast(self)), new_state_);
            }
            pub inline fn getTime(self: *const T, p_current_time_: ?*i64) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IMultiMediaStream, @ptrCast(self)), p_current_time_);
            }
            pub inline fn getDuration(self: *const T, p_duration_: ?*i64) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMultiMediaStream, @ptrCast(self)), p_duration_);
            }
            pub inline fn seek(self: *const T, seek_time_: i64) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const IMultiMediaStream, @ptrCast(self)), seek_time_);
            }
            pub inline fn getEndOfStreamEventHandle(self: *const T, ph_e_o_s_: ?*?HANDLE) HRESULT {
                return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetEndOfStreamEventHandle(@as(*const IMultiMediaStream, @ptrCast(self)), ph_e_o_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStream_Value = Guid.initString("b502d1bd-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStream = &IID_IMediaStream_Value;
pub const IMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMultiMediaStream: *const fn (
            self: *const IMediaStream,
            pp_multi_media_stream: ?*?*IMultiMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInformation: *const fn (
            self: *const IMediaStream,
            p_purpose_id: ?*Guid,
            p_type: ?*STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSameFormat: *const fn (
            self: *const IMediaStream,
            p_stream_that_has_desired_format: ?*IMediaStream,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateSample: *const fn (
            self: *const IMediaStream,
            dw_flags: u32,
            pp_sample: ?*?*IStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSharedSample: *const fn (
            self: *const IMediaStream,
            p_existing_sample: ?*IStreamSample,
            dw_flags: u32,
            pp_new_sample: ?*?*IStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendEndOfStream: *const fn (
            self: *const IMediaStream,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMultiMediaStream(self: *const T, pp_multi_media_stream_: ?*?*IMultiMediaStream) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).GetMultiMediaStream(@as(*const IMediaStream, @ptrCast(self)), pp_multi_media_stream_);
            }
            pub inline fn getInformation(self: *const T, p_purpose_id_: ?*Guid, p_type_: ?*STREAM_TYPE) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).GetInformation(@as(*const IMediaStream, @ptrCast(self)), p_purpose_id_, p_type_);
            }
            pub inline fn setSameFormat(self: *const T, p_stream_that_has_desired_format_: ?*IMediaStream, dw_flags_: u32) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).SetSameFormat(@as(*const IMediaStream, @ptrCast(self)), p_stream_that_has_desired_format_, dw_flags_);
            }
            pub inline fn allocateSample(self: *const T, dw_flags_: u32, pp_sample_: ?*?*IStreamSample) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).AllocateSample(@as(*const IMediaStream, @ptrCast(self)), dw_flags_, pp_sample_);
            }
            pub inline fn createSharedSample(self: *const T, p_existing_sample_: ?*IStreamSample, dw_flags_: u32, pp_new_sample_: ?*?*IStreamSample) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).CreateSharedSample(@as(*const IMediaStream, @ptrCast(self)), p_existing_sample_, dw_flags_, pp_new_sample_);
            }
            pub inline fn sendEndOfStream(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).SendEndOfStream(@as(*const IMediaStream, @ptrCast(self)), dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStreamSample_Value = Guid.initString("b502d1be-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IStreamSample = &IID_IStreamSample_Value;
pub const IStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaStream: *const fn (
            self: *const IStreamSample,
            pp_media_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSampleTimes: *const fn (
            self: *const IStreamSample,
            p_start_time: ?*i64,
            p_end_time: ?*i64,
            p_current_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleTimes: *const fn (
            self: *const IStreamSample,
            p_start_time: ?*const i64,
            p_end_time: ?*const i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: *const fn (
            self: *const IStreamSample,
            dw_flags: u32,
            h_event: ?HANDLE,
            pfn_a_p_c: ?PAPCFUNC,
            dw_a_p_c_data: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompletionStatus: *const fn (
            self: *const IStreamSample,
            dw_flags: u32,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMediaStream(self: *const T, pp_media_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IStreamSample, @ptrCast(self)), pp_media_stream_);
            }
            pub inline fn getSampleTimes(self: *const T, p_start_time_: ?*i64, p_end_time_: ?*i64, p_current_time_: ?*i64) HRESULT {
                return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).GetSampleTimes(@as(*const IStreamSample, @ptrCast(self)), p_start_time_, p_end_time_, p_current_time_);
            }
            pub inline fn setSampleTimes(self: *const T, p_start_time_: ?*const i64, p_end_time_: ?*const i64) HRESULT {
                return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).SetSampleTimes(@as(*const IStreamSample, @ptrCast(self)), p_start_time_, p_end_time_);
            }
            pub inline fn update(self: *const T, dw_flags_: u32, h_event_: ?HANDLE, pfn_a_p_c_: ?PAPCFUNC, dw_a_p_c_data_: usize) HRESULT {
                return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).Update(@as(*const IStreamSample, @ptrCast(self)), dw_flags_, h_event_, pfn_a_p_c_, dw_a_p_c_data_);
            }
            pub inline fn completionStatus(self: *const T, dw_flags_: u32, dw_milliseconds_: u32) HRESULT {
                return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).CompletionStatus(@as(*const IStreamSample, @ptrCast(self)), dw_flags_, dw_milliseconds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DDSFF_FLAGS = enum(u32) {
    R = 1,
    _,
    pub fn initFlags(o: struct {
        R: u1 = 0,
    }) DDSFF_FLAGS {
        return @as(DDSFF_FLAGS, @enumFromInt((if (o.R == 1) @intFromEnum(DDSFF_FLAGS.R) else 0)));
    }
};
pub const DDSFF_PROGRESSIVERENDER = DDSFF_FLAGS.R;

const IID_IDirectDrawMediaStream_Value = Guid.initString("f4104fce-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawMediaStream = &IID_IDirectDrawMediaStream_Value;
pub const IDirectDrawMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: *const fn (
            self: *const IDirectDrawMediaStream,
            p_d_d_s_d_current: ?*DDSURFACEDESC,
            pp_direct_draw_palette: ?*?*IDirectDrawPalette,
            p_d_d_s_d_desired: ?*DDSURFACEDESC,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const IDirectDrawMediaStream,
            p_d_d_surface_desc: ?*const DDSURFACEDESC,
            p_direct_draw_palette: ?*IDirectDrawPalette,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectDraw: *const fn (
            self: *const IDirectDrawMediaStream,
            pp_direct_draw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDraw: *const fn (
            self: *const IDirectDrawMediaStream,
            p_direct_draw: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: *const fn (
            self: *const IDirectDrawMediaStream,
            p_surface: ?*IDirectDrawSurface,
            p_rect: ?*const RECT,
            dw_flags: u32,
            pp_sample: ?*?*IDirectDrawStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimePerFrame: *const fn (
            self: *const IDirectDrawMediaStream,
            p_frame_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaStream.MethodMixin(T);
            pub inline fn getFormat(self: *const T, p_d_d_s_d_current_: ?*DDSURFACEDESC, pp_direct_draw_palette_: ?*?*IDirectDrawPalette, p_d_d_s_d_desired_: ?*DDSURFACEDESC, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IDirectDrawMediaStream, @ptrCast(self)), p_d_d_s_d_current_, pp_direct_draw_palette_, p_d_d_s_d_desired_, pdw_flags_);
            }
            pub inline fn setFormat(self: *const T, p_d_d_surface_desc_: ?*const DDSURFACEDESC, p_direct_draw_palette_: ?*IDirectDrawPalette) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IDirectDrawMediaStream, @ptrCast(self)), p_d_d_surface_desc_, p_direct_draw_palette_);
            }
            pub inline fn getDirectDraw(self: *const T, pp_direct_draw_: ?*?*IDirectDraw) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pp_direct_draw_);
            }
            pub inline fn setDirectDraw(self: *const T, p_direct_draw_: ?*IDirectDraw) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).SetDirectDraw(@as(*const IDirectDrawMediaStream, @ptrCast(self)), p_direct_draw_);
            }
            pub inline fn createSample(self: *const T, p_surface_: ?*IDirectDrawSurface, p_rect_: ?*const RECT, dw_flags_: u32, pp_sample_: ?*?*IDirectDrawStreamSample) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IDirectDrawMediaStream, @ptrCast(self)), p_surface_, p_rect_, dw_flags_, pp_sample_);
            }
            pub inline fn getTimePerFrame(self: *const T, p_frame_time_: ?*i64) HRESULT {
                return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetTimePerFrame(@as(*const IDirectDrawMediaStream, @ptrCast(self)), p_frame_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectDrawStreamSample_Value = Guid.initString("f4104fcf-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawStreamSample = &IID_IDirectDrawStreamSample_Value;
pub const IDirectDrawStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetSurface: *const fn (
            self: *const IDirectDrawStreamSample,
            pp_direct_draw_surface: ?*?*IDirectDrawSurface,
            p_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRect: *const fn (
            self: *const IDirectDrawStreamSample,
            p_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamSample.MethodMixin(T);
            pub inline fn getSurface(self: *const T, pp_direct_draw_surface_: ?*?*IDirectDrawSurface, p_rect_: ?*RECT) HRESULT {
                return @as(*const IDirectDrawStreamSample.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IDirectDrawStreamSample, @ptrCast(self)), pp_direct_draw_surface_, p_rect_);
            }
            pub inline fn setRect(self: *const T, p_rect_: ?*const RECT) HRESULT {
                return @as(*const IDirectDrawStreamSample.VTable, @ptrCast(self.vtable)).SetRect(@as(*const IDirectDrawStreamSample, @ptrCast(self)), p_rect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioMediaStream_Value = Guid.initString("f7537560-a3be-11d0-8212-00c04fc32c45");
pub const IID_IAudioMediaStream = &IID_IAudioMediaStream_Value;
pub const IAudioMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: *const fn (
            self: *const IAudioMediaStream,
            p_wave_format_current: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const IAudioMediaStream,
            lp_wave_format: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: *const fn (
            self: *const IAudioMediaStream,
            p_audio_data: ?*IAudioData,
            dw_flags: u32,
            pp_sample: ?*?*IAudioStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaStream.MethodMixin(T);
            pub inline fn getFormat(self: *const T, p_wave_format_current_: ?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioMediaStream, @ptrCast(self)), p_wave_format_current_);
            }
            pub inline fn setFormat(self: *const T, lp_wave_format_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAudioMediaStream, @ptrCast(self)), lp_wave_format_);
            }
            pub inline fn createSample(self: *const T, p_audio_data_: ?*IAudioData, dw_flags_: u32, pp_sample_: ?*?*IAudioStreamSample) HRESULT {
                return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IAudioMediaStream, @ptrCast(self)), p_audio_data_, dw_flags_, pp_sample_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioStreamSample_Value = Guid.initString("345fee00-aba5-11d0-8212-00c04fc32c45");
pub const IID_IAudioStreamSample = &IID_IAudioStreamSample_Value;
pub const IAudioStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetAudioData: *const fn (
            self: *const IAudioStreamSample,
            pp_audio: ?*?*IAudioData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamSample.MethodMixin(T);
            pub inline fn getAudioData(self: *const T, pp_audio_: ?*?*IAudioData) HRESULT {
                return @as(*const IAudioStreamSample.VTable, @ptrCast(self.vtable)).GetAudioData(@as(*const IAudioStreamSample, @ptrCast(self)), pp_audio_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMemoryData_Value = Guid.initString("327fc560-af60-11d0-8212-00c04fc32c45");
pub const IID_IMemoryData = &IID_IMemoryData_Value;
pub const IMemoryData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBuffer: *const fn (
            self: *const IMemoryData,
            cb_size: u32,
            pb_data: ?*u8,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: *const fn (
            self: *const IMemoryData,
            pdw_length: ?*u32,
            ppb_data: ?*?*u8,
            pcb_actual_data: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActual: *const fn (
            self: *const IMemoryData,
            cb_data_valid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setBuffer(self: *const T, cb_size_: u32, pb_data_: ?*u8, dw_flags_: u32) HRESULT {
                return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).SetBuffer(@as(*const IMemoryData, @ptrCast(self)), cb_size_, pb_data_, dw_flags_);
            }
            pub inline fn getInfo(self: *const T, pdw_length_: ?*u32, ppb_data_: ?*?*u8, pcb_actual_data_: ?*u32) HRESULT {
                return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IMemoryData, @ptrCast(self)), pdw_length_, ppb_data_, pcb_actual_data_);
            }
            pub inline fn setActual(self: *const T, cb_data_valid_: u32) HRESULT {
                return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).SetActual(@as(*const IMemoryData, @ptrCast(self)), cb_data_valid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioData_Value = Guid.initString("54c719c0-af60-11d0-8212-00c04fc32c45");
pub const IID_IAudioData = &IID_IAudioData_Value;
pub const IAudioData = extern struct {
    pub const VTable = extern struct {
        base: IMemoryData.VTable,
        GetFormat: *const fn (
            self: *const IAudioData,
            p_wave_format_current: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const IAudioData,
            lp_wave_format: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMemoryData.MethodMixin(T);
            pub inline fn getFormat(self: *const T, p_wave_format_current_: ?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioData.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioData, @ptrCast(self)), p_wave_format_current_);
            }
            pub inline fn setFormat(self: *const T, lp_wave_format_: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const IAudioData.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAudioData, @ptrCast(self)), lp_wave_format_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMMSF_MMS_INIT_FLAGS = enum(u32) {
    D = 1,
    _,
    pub fn initFlags(o: struct {
        D: u1 = 0,
    }) AMMSF_MMS_INIT_FLAGS {
        return @as(AMMSF_MMS_INIT_FLAGS, @enumFromInt((if (o.D == 1) @intFromEnum(AMMSF_MMS_INIT_FLAGS.D) else 0)));
    }
};
pub const AMMSF_NOGRAPHTHREAD = AMMSF_MMS_INIT_FLAGS.D;

pub const AMMSF_MS_FLAGS = enum(u32) {
    ADDDEFAULTRENDERER = 1,
    CREATEPEER = 2,
    STOPIFNOSAMPLES = 4,
    NOSTALL = 8,
    _,
    pub fn initFlags(o: struct {
        ADDDEFAULTRENDERER: u1 = 0,
        CREATEPEER: u1 = 0,
        STOPIFNOSAMPLES: u1 = 0,
        NOSTALL: u1 = 0,
    }) AMMSF_MS_FLAGS {
        return @as(AMMSF_MS_FLAGS, @enumFromInt((if (o.ADDDEFAULTRENDERER == 1) @intFromEnum(AMMSF_MS_FLAGS.ADDDEFAULTRENDERER) else 0) | (if (o.CREATEPEER == 1) @intFromEnum(AMMSF_MS_FLAGS.CREATEPEER) else 0) | (if (o.STOPIFNOSAMPLES == 1) @intFromEnum(AMMSF_MS_FLAGS.STOPIFNOSAMPLES) else 0) | (if (o.NOSTALL == 1) @intFromEnum(AMMSF_MS_FLAGS.NOSTALL) else 0)));
    }
};
pub const AMMSF_ADDDEFAULTRENDERER = AMMSF_MS_FLAGS.ADDDEFAULTRENDERER;
pub const AMMSF_CREATEPEER = AMMSF_MS_FLAGS.CREATEPEER;
pub const AMMSF_STOPIFNOSAMPLES = AMMSF_MS_FLAGS.STOPIFNOSAMPLES;
pub const AMMSF_NOSTALL = AMMSF_MS_FLAGS.NOSTALL;

pub const AMMSF_RENDER_FLAGS = enum(u32) {
    RENDERTYPEMASK = 3,
    RENDERTOEXISTING = 0,
    RENDERALLSTREAMS = 1,
    NORENDER = 2,
    NOCLOCK = 4,
    RUN = 8,
    _,
    pub fn initFlags(o: struct {
        RENDERTYPEMASK: u1 = 0,
        RENDERTOEXISTING: u1 = 0,
        RENDERALLSTREAMS: u1 = 0,
        NORENDER: u1 = 0,
        NOCLOCK: u1 = 0,
        RUN: u1 = 0,
    }) AMMSF_RENDER_FLAGS {
        return @as(AMMSF_RENDER_FLAGS, @enumFromInt((if (o.RENDERTYPEMASK == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERTYPEMASK) else 0) | (if (o.RENDERTOEXISTING == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERTOEXISTING) else 0) | (if (o.RENDERALLSTREAMS == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERALLSTREAMS) else 0) | (if (o.NORENDER == 1) @intFromEnum(AMMSF_RENDER_FLAGS.NORENDER) else 0) | (if (o.NOCLOCK == 1) @intFromEnum(AMMSF_RENDER_FLAGS.NOCLOCK) else 0) | (if (o.RUN == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RUN) else 0)));
    }
};
pub const AMMSF_RENDERTYPEMASK = AMMSF_RENDER_FLAGS.RENDERTYPEMASK;
pub const AMMSF_RENDERTOEXISTING = AMMSF_RENDER_FLAGS.RENDERTOEXISTING;
pub const AMMSF_RENDERALLSTREAMS = AMMSF_RENDER_FLAGS.RENDERALLSTREAMS;
pub const AMMSF_NORENDER = AMMSF_RENDER_FLAGS.NORENDER;
pub const AMMSF_NOCLOCK = AMMSF_RENDER_FLAGS.NOCLOCK;
pub const AMMSF_RUN = AMMSF_RENDER_FLAGS.RUN;

pub const OUTPUT_STATE = enum(u32) {
    Disabled = 0,
    ReadData = 1,
    RenderData = 2,
    _,
    pub fn initFlags(o: struct {
        Disabled: u1 = 0,
        ReadData: u1 = 0,
        RenderData: u1 = 0,
    }) OUTPUT_STATE {
        return @as(OUTPUT_STATE, @enumFromInt((if (o.Disabled == 1) @intFromEnum(OUTPUT_STATE.Disabled) else 0) | (if (o.ReadData == 1) @intFromEnum(OUTPUT_STATE.ReadData) else 0) | (if (o.RenderData == 1) @intFromEnum(OUTPUT_STATE.RenderData) else 0)));
    }
};
pub const Disabled = OUTPUT_STATE.Disabled;
pub const ReadData = OUTPUT_STATE.ReadData;
pub const RenderData = OUTPUT_STATE.RenderData;

const IID_IAMMultiMediaStream_Value = Guid.initString("bebe595c-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMultiMediaStream = &IID_IAMMultiMediaStream_Value;
pub const IAMMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMultiMediaStream.VTable,
        Initialize: *const fn (
            self: *const IAMMultiMediaStream,
            stream_type: STREAM_TYPE,
            dw_flags: AMMSF_MMS_INIT_FLAGS,
            p_filter_graph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterGraph: *const fn (
            self: *const IAMMultiMediaStream,
            pp_graph_builder: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilter: *const fn (
            self: *const IAMMultiMediaStream,
            pp_filter: ?*?*IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMediaStream: *const fn (
            self: *const IAMMultiMediaStream,
            p_stream_object: ?*IUnknown,
            purpose_id: ?*const Guid,
            dw_flags: AMMSF_MS_FLAGS,
            pp_new_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFile: *const fn (
            self: *const IAMMultiMediaStream,
            psz_file_name: ?[*:0]const u16,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenMoniker: *const fn (
            self: *const IAMMultiMediaStream,
            p_ctx: ?*IBindCtx,
            p_moniker: ?*IMoniker,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: *const fn (
            self: *const IAMMultiMediaStream,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMultiMediaStream.MethodMixin(T);
            pub inline fn initialize(self: *const T, stream_type_: STREAM_TYPE, dw_flags_: AMMSF_MMS_INIT_FLAGS, p_filter_graph_: ?*IGraphBuilder) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAMMultiMediaStream, @ptrCast(self)), stream_type_, dw_flags_, p_filter_graph_);
            }
            pub inline fn getFilterGraph(self: *const T, pp_graph_builder_: ?*?*IGraphBuilder) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).GetFilterGraph(@as(*const IAMMultiMediaStream, @ptrCast(self)), pp_graph_builder_);
            }
            pub inline fn getFilter(self: *const T, pp_filter_: ?*?*IMediaStreamFilter) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IAMMultiMediaStream, @ptrCast(self)), pp_filter_);
            }
            pub inline fn addMediaStream(self: *const T, p_stream_object_: ?*IUnknown, purpose_id_: ?*const Guid, dw_flags_: AMMSF_MS_FLAGS, pp_new_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).AddMediaStream(@as(*const IAMMultiMediaStream, @ptrCast(self)), p_stream_object_, purpose_id_, dw_flags_, pp_new_stream_);
            }
            pub inline fn openFile(self: *const T, psz_file_name_: ?[*:0]const u16, dw_flags_: u32) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).OpenFile(@as(*const IAMMultiMediaStream, @ptrCast(self)), psz_file_name_, dw_flags_);
            }
            pub inline fn openMoniker(self: *const T, p_ctx_: ?*IBindCtx, p_moniker_: ?*IMoniker, dw_flags_: u32) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).OpenMoniker(@as(*const IAMMultiMediaStream, @ptrCast(self)), p_ctx_, p_moniker_, dw_flags_);
            }
            pub inline fn render(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).Render(@as(*const IAMMultiMediaStream, @ptrCast(self)), dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaStream_Value = Guid.initString("bebe595d-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMediaStream = &IID_IAMMediaStream_Value;
pub const IAMMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        Initialize: *const fn (
            self: *const IAMMediaStream,
            p_source_object: ?*IUnknown,
            dw_flags: u32,
            purpose_id: ?*Guid,
            stream_type: STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: *const fn (
            self: *const IAMMediaStream,
            state: FILTER_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinAMMultiMediaStream: *const fn (
            self: *const IAMMediaStream,
            p_a_m_multi_media_stream: ?*IAMMultiMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilter: *const fn (
            self: *const IAMMediaStream,
            p_media_stream_filter: ?*IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilterGraph: *const fn (
            self: *const IAMMediaStream,
            p_filter_graph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaStream.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_source_object_: ?*IUnknown, dw_flags_: u32, purpose_id_: ?*Guid, stream_type_: STREAM_TYPE) HRESULT {
                return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAMMediaStream, @ptrCast(self)), p_source_object_, dw_flags_, purpose_id_, stream_type_);
            }
            pub inline fn setState(self: *const T, state_: FILTER_STATE) HRESULT {
                return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).SetState(@as(*const IAMMediaStream, @ptrCast(self)), state_);
            }
            pub inline fn joinAMMultiMediaStream(self: *const T, p_a_m_multi_media_stream_: ?*IAMMultiMediaStream) HRESULT {
                return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinAMMultiMediaStream(@as(*const IAMMediaStream, @ptrCast(self)), p_a_m_multi_media_stream_);
            }
            pub inline fn joinFilter(self: *const T, p_media_stream_filter_: ?*IMediaStreamFilter) HRESULT {
                return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinFilter(@as(*const IAMMediaStream, @ptrCast(self)), p_media_stream_filter_);
            }
            pub inline fn joinFilterGraph(self: *const T, p_filter_graph_: ?*IFilterGraph) HRESULT {
                return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinFilterGraph(@as(*const IAMMediaStream, @ptrCast(self)), p_filter_graph_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStreamFilter_Value = Guid.initString("bebe595e-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStreamFilter = &IID_IMediaStreamFilter_Value;
pub const IMediaStreamFilter = extern struct {
    pub const VTable = extern struct {
        base: IBaseFilter.VTable,
        AddMediaStream: *const fn (
            self: *const IMediaStreamFilter,
            p_a_m_media_stream: ?*IAMMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaStream: *const fn (
            self: *const IMediaStreamFilter,
            id_purpose: ?*Guid,
            pp_media_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaStreams: *const fn (
            self: *const IMediaStreamFilter,
            index: i32,
            pp_media_stream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportSeeking: *const fn (
            self: *const IMediaStreamFilter,
            b_renderer: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReferenceTimeToStreamTime: *const fn (
            self: *const IMediaStreamFilter,
            p_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentStreamTime: *const fn (
            self: *const IMediaStreamFilter,
            p_current_stream_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitUntil: *const fn (
            self: *const IMediaStreamFilter,
            wait_stream_time: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: *const fn (
            self: *const IMediaStreamFilter,
            b_cancel_e_o_s: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOfStream: *const fn (
            self: *const IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBaseFilter.MethodMixin(T);
            pub inline fn addMediaStream(self: *const T, p_a_m_media_stream_: ?*IAMMediaStream) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).AddMediaStream(@as(*const IMediaStreamFilter, @ptrCast(self)), p_a_m_media_stream_);
            }
            pub inline fn getMediaStream(self: *const T, id_purpose_: ?*Guid, pp_media_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IMediaStreamFilter, @ptrCast(self)), id_purpose_, pp_media_stream_);
            }
            pub inline fn enumMediaStreams(self: *const T, index_: i32, pp_media_stream_: ?*?*IMediaStream) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).EnumMediaStreams(@as(*const IMediaStreamFilter, @ptrCast(self)), index_, pp_media_stream_);
            }
            pub inline fn supportSeeking(self: *const T, b_renderer_: BOOL) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).SupportSeeking(@as(*const IMediaStreamFilter, @ptrCast(self)), b_renderer_);
            }
            pub inline fn referenceTimeToStreamTime(self: *const T, p_time_: ?*i64) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).ReferenceTimeToStreamTime(@as(*const IMediaStreamFilter, @ptrCast(self)), p_time_);
            }
            pub inline fn getCurrentStreamTime(self: *const T, p_current_stream_time_: ?*i64) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).GetCurrentStreamTime(@as(*const IMediaStreamFilter, @ptrCast(self)), p_current_stream_time_);
            }
            pub inline fn waitUntil(self: *const T, wait_stream_time_: i64) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).WaitUntil(@as(*const IMediaStreamFilter, @ptrCast(self)), wait_stream_time_);
            }
            pub inline fn flush(self: *const T, b_cancel_e_o_s_: BOOL) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMediaStreamFilter, @ptrCast(self)), b_cancel_e_o_s_);
            }
            pub inline fn endOfStream(self: *const T) HRESULT {
                return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).EndOfStream(@as(*const IMediaStreamFilter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSampleAllocator_Value = Guid.initString("ab6b4afc-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSampleAllocator = &IID_IDirectDrawMediaSampleAllocator_Value;
pub const IDirectDrawMediaSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectDraw: *const fn (
            self: *const IDirectDrawMediaSampleAllocator,
            pp_direct_draw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDirectDraw(self: *const T, pp_direct_draw_: ?*?*IDirectDraw) HRESULT {
                return @as(*const IDirectDrawMediaSampleAllocator.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawMediaSampleAllocator, @ptrCast(self)), pp_direct_draw_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSample_Value = Guid.initString("ab6b4afe-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSample = &IID_IDirectDrawMediaSample_Value;
pub const IDirectDrawMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurfaceAndReleaseLock: *const fn (
            self: *const IDirectDrawMediaSample,
            pp_direct_draw_surface: ?*?*IDirectDrawSurface,
            p_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockMediaSamplePointer: *const fn (
            self: *const IDirectDrawMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSurfaceAndReleaseLock(self: *const T, pp_direct_draw_surface_: ?*?*IDirectDrawSurface, p_rect_: ?*RECT) HRESULT {
                return @as(*const IDirectDrawMediaSample.VTable, @ptrCast(self.vtable)).GetSurfaceAndReleaseLock(@as(*const IDirectDrawMediaSample, @ptrCast(self)), pp_direct_draw_surface_, p_rect_);
            }
            pub inline fn lockMediaSamplePointer(self: *const T) HRESULT {
                return @as(*const IDirectDrawMediaSample.VTable, @ptrCast(self.vtable)).LockMediaSamplePointer(@as(*const IDirectDrawMediaSample, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeStream_Value = Guid.initString("ab6b4afa-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeStream = &IID_IAMMediaTypeStream_Value;
pub const IAMMediaTypeStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: *const fn (
            self: *const IAMMediaTypeStream,
            p_media_type: ?*AM_MEDIA_TYPE,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: *const fn (
            self: *const IAMMediaTypeStream,
            p_media_type: ?*AM_MEDIA_TYPE,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: *const fn (
            self: *const IAMMediaTypeStream,
            l_sample_size: i32,
            pb_buffer: ?*u8,
            dw_flags: u32,
            p_unk_outer: ?*IUnknown,
            pp_a_m_media_type_sample: ?*?*IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAllocatorRequirements: *const fn (
            self: *const IAMMediaTypeStream,
            p_props: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamAllocatorRequirements: *const fn (
            self: *const IAMMediaTypeStream,
            p_props: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaStream.MethodMixin(T);
            pub inline fn getFormat(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE, dw_flags_: u32) HRESULT {
                return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAMMediaTypeStream, @ptrCast(self)), p_media_type_, dw_flags_);
            }
            pub inline fn setFormat(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE, dw_flags_: u32) HRESULT {
                return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAMMediaTypeStream, @ptrCast(self)), p_media_type_, dw_flags_);
            }
            pub inline fn createSample(self: *const T, l_sample_size_: i32, pb_buffer_: ?*u8, dw_flags_: u32, p_unk_outer_: ?*IUnknown, pp_a_m_media_type_sample_: ?*?*IAMMediaTypeSample) HRESULT {
                return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IAMMediaTypeStream, @ptrCast(self)), l_sample_size_, pb_buffer_, dw_flags_, p_unk_outer_, pp_a_m_media_type_sample_);
            }
            pub inline fn getStreamAllocatorRequirements(self: *const T, p_props_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).GetStreamAllocatorRequirements(@as(*const IAMMediaTypeStream, @ptrCast(self)), p_props_);
            }
            pub inline fn setStreamAllocatorRequirements(self: *const T, p_props_: ?*ALLOCATOR_PROPERTIES) HRESULT {
                return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).SetStreamAllocatorRequirements(@as(*const IAMMediaTypeStream, @ptrCast(self)), p_props_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeSample_Value = Guid.initString("ab6b4afb-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeSample = &IID_IAMMediaTypeSample_Value;
pub const IAMMediaTypeSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        SetPointer: *const fn (
            self: *const IAMMediaTypeSample,
            p_buffer: [*:0]u8,
            l_size: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPointer: *const fn (
            self: *const IAMMediaTypeSample,
            pp_buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetTime: *const fn (
            self: *const IAMMediaTypeSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTime: *const fn (
            self: *const IAMMediaTypeSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSyncPoint: *const fn (
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncPoint: *const fn (
            self: *const IAMMediaTypeSample,
            b_is_sync_point: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreroll: *const fn (
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreroll: *const fn (
            self: *const IAMMediaTypeSample,
            b_is_preroll: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDataLength: *const fn (
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        SetActualDataLength: *const fn (
            self: *const IAMMediaTypeSample,
            ___m_i_d_l___i_a_m_media_type_sample0000: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: *const fn (
            self: *const IAMMediaTypeSample,
            pp_media_type: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: *const fn (
            self: *const IAMMediaTypeSample,
            p_media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDiscontinuity: *const fn (
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDiscontinuity: *const fn (
            self: *const IAMMediaTypeSample,
            b_discontinuity: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTime: *const fn (
            self: *const IAMMediaTypeSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaTime: *const fn (
            self: *const IAMMediaTypeSample,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamSample.MethodMixin(T);
            pub inline fn setPointer(self: *const T, p_buffer_: [*:0]u8, l_size_: i32) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetPointer(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_buffer_, l_size_);
            }
            pub inline fn getPointer(self: *const T, pp_buffer_: ?*?*u8) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetPointer(@as(*const IAMMediaTypeSample, @ptrCast(self)), pp_buffer_);
            }
            pub inline fn getSize(self: *const T) i32 {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IAMMediaTypeSample, @ptrCast(self)));
            }
            pub inline fn getTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn setTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn isSyncPoint(self: *const T) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsSyncPoint(@as(*const IAMMediaTypeSample, @ptrCast(self)));
            }
            pub inline fn setSyncPoint(self: *const T, b_is_sync_point_: BOOL) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetSyncPoint(@as(*const IAMMediaTypeSample, @ptrCast(self)), b_is_sync_point_);
            }
            pub inline fn isPreroll(self: *const T) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsPreroll(@as(*const IAMMediaTypeSample, @ptrCast(self)));
            }
            pub inline fn setPreroll(self: *const T, b_is_preroll_: BOOL) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetPreroll(@as(*const IAMMediaTypeSample, @ptrCast(self)), b_is_preroll_);
            }
            pub inline fn getActualDataLength(self: *const T) i32 {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetActualDataLength(@as(*const IAMMediaTypeSample, @ptrCast(self)));
            }
            pub inline fn setActualDataLength(self: *const T, ___m_i_d_l___i_a_m_media_type_sample0000_: i32) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetActualDataLength(@as(*const IAMMediaTypeSample, @ptrCast(self)), ___m_i_d_l___i_a_m_media_type_sample0000_);
            }
            pub inline fn getMediaType(self: *const T, pp_media_type_: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IAMMediaTypeSample, @ptrCast(self)), pp_media_type_);
            }
            pub inline fn setMediaType(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_media_type_);
            }
            pub inline fn isDiscontinuity(self: *const T) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsDiscontinuity(@as(*const IAMMediaTypeSample, @ptrCast(self)));
            }
            pub inline fn setDiscontinuity(self: *const T, b_discontinuity_: BOOL) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetDiscontinuity(@as(*const IAMMediaTypeSample, @ptrCast(self)), b_discontinuity_);
            }
            pub inline fn getMediaTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetMediaTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
            pub inline fn setMediaTime(self: *const T, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetMediaTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), p_time_start_, p_time_end_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDirectDrawVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSwitches: *const fn (
            self: *const IDirectDrawVideo,
            p_switches: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSwitches: *const fn (
            self: *const IDirectDrawVideo,
            switches: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaps: *const fn (
            self: *const IDirectDrawVideo,
            p_caps: ?*DDCAPS_DX7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmulatedCaps: *const fn (
            self: *const IDirectDrawVideo,
            p_caps: ?*DDCAPS_DX7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurfaceDesc: *const fn (
            self: *const IDirectDrawVideo,
            p_surface_desc: ?*DDSURFACEDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFourCCCodes: *const fn (
            self: *const IDirectDrawVideo,
            p_count: ?*u32,
            p_codes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDraw: *const fn (
            self: *const IDirectDrawVideo,
            p_direct_draw: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectDraw: *const fn (
            self: *const IDirectDrawVideo,
            pp_direct_draw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurfaceType: *const fn (
            self: *const IDirectDrawVideo,
            p_surface_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefault: *const fn (
            self: *const IDirectDrawVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseScanLine: *const fn (
            self: *const IDirectDrawVideo,
            use_scan_line: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUseScanLine: *const fn (
            self: *const IDirectDrawVideo,
            use_scan_line: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseOverlayStretch: *const fn (
            self: *const IDirectDrawVideo,
            use_overlay_stretch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUseOverlayStretch: *const fn (
            self: *const IDirectDrawVideo,
            use_overlay_stretch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseWhenFullScreen: *const fn (
            self: *const IDirectDrawVideo,
            use_when_full_screen: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WillUseFullScreen: *const fn (
            self: *const IDirectDrawVideo,
            use_when_full_screen: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSwitches(self: *const T, p_switches_: ?*u32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSwitches(@as(*const IDirectDrawVideo, @ptrCast(self)), p_switches_);
            }
            pub inline fn setSwitches(self: *const T, switches_: u32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetSwitches(@as(*const IDirectDrawVideo, @ptrCast(self)), switches_);
            }
            pub inline fn getCaps(self: *const T, p_caps_: ?*DDCAPS_DX7) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IDirectDrawVideo, @ptrCast(self)), p_caps_);
            }
            pub inline fn getEmulatedCaps(self: *const T, p_caps_: ?*DDCAPS_DX7) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetEmulatedCaps(@as(*const IDirectDrawVideo, @ptrCast(self)), p_caps_);
            }
            pub inline fn getSurfaceDesc(self: *const T, p_surface_desc_: ?*DDSURFACEDESC) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSurfaceDesc(@as(*const IDirectDrawVideo, @ptrCast(self)), p_surface_desc_);
            }
            pub inline fn getFourCCCodes(self: *const T, p_count_: ?*u32, p_codes_: ?*u32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetFourCCCodes(@as(*const IDirectDrawVideo, @ptrCast(self)), p_count_, p_codes_);
            }
            pub inline fn setDirectDraw(self: *const T, p_direct_draw_: ?*IDirectDraw) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetDirectDraw(@as(*const IDirectDrawVideo, @ptrCast(self)), p_direct_draw_);
            }
            pub inline fn getDirectDraw(self: *const T, pp_direct_draw_: ?*?*IDirectDraw) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawVideo, @ptrCast(self)), pp_direct_draw_);
            }
            pub inline fn getSurfaceType(self: *const T, p_surface_type_: ?*u32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSurfaceType(@as(*const IDirectDrawVideo, @ptrCast(self)), p_surface_type_);
            }
            pub inline fn setDefault(self: *const T) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetDefault(@as(*const IDirectDrawVideo, @ptrCast(self)));
            }
            pub inline fn useScanLine(self: *const T, use_scan_line_: i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseScanLine(@as(*const IDirectDrawVideo, @ptrCast(self)), use_scan_line_);
            }
            pub inline fn canUseScanLine(self: *const T, use_scan_line_: ?*i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).CanUseScanLine(@as(*const IDirectDrawVideo, @ptrCast(self)), use_scan_line_);
            }
            pub inline fn useOverlayStretch(self: *const T, use_overlay_stretch_: i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseOverlayStretch(@as(*const IDirectDrawVideo, @ptrCast(self)), use_overlay_stretch_);
            }
            pub inline fn canUseOverlayStretch(self: *const T, use_overlay_stretch_: ?*i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).CanUseOverlayStretch(@as(*const IDirectDrawVideo, @ptrCast(self)), use_overlay_stretch_);
            }
            pub inline fn useWhenFullScreen(self: *const T, use_when_full_screen_: i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseWhenFullScreen(@as(*const IDirectDrawVideo, @ptrCast(self)), use_when_full_screen_);
            }
            pub inline fn willUseFullScreen(self: *const T, use_when_full_screen_: ?*i32) HRESULT {
                return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).WillUseFullScreen(@as(*const IDirectDrawVideo, @ptrCast(self)), use_when_full_screen_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IQualProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDroppedInRenderer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            pc_frames: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDrawn: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            pc_frames_drawn: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgFrameRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            pi_avg_frame_rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Jitter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            i_jitter: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgSyncOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            pi_avg: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevSyncOffset: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IQualProp,
            pi_dev: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFramesDroppedInRenderer(self: *const T, pc_frames_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_FramesDroppedInRenderer(@as(*const IQualProp, @ptrCast(self)), pc_frames_);
            }
            pub inline fn getFramesDrawn(self: *const T, pc_frames_drawn_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_FramesDrawn(@as(*const IQualProp, @ptrCast(self)), pc_frames_drawn_);
            }
            pub inline fn getAvgFrameRate(self: *const T, pi_avg_frame_rate_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_AvgFrameRate(@as(*const IQualProp, @ptrCast(self)), pi_avg_frame_rate_);
            }
            pub inline fn getJitter(self: *const T, i_jitter_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_Jitter(@as(*const IQualProp, @ptrCast(self)), i_jitter_);
            }
            pub inline fn getAvgSyncOffset(self: *const T, pi_avg_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_AvgSyncOffset(@as(*const IQualProp, @ptrCast(self)), pi_avg_);
            }
            pub inline fn getDevSyncOffset(self: *const T, pi_dev_: ?*i32) HRESULT {
                return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_DevSyncOffset(@as(*const IQualProp, @ptrCast(self)), pi_dev_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IFullScreenVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CountModes: *const fn (
            self: *const IFullScreenVideo,
            p_modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModeInfo: *const fn (
            self: *const IFullScreenVideo,
            mode: i32,
            p_width: ?*i32,
            p_height: ?*i32,
            p_depth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMode: *const fn (
            self: *const IFullScreenVideo,
            p_mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsModeAvailable: *const fn (
            self: *const IFullScreenVideo,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsModeEnabled: *const fn (
            self: *const IFullScreenVideo,
            mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: *const fn (
            self: *const IFullScreenVideo,
            mode: i32,
            b_enabled: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipFactor: *const fn (
            self: *const IFullScreenVideo,
            p_clip_factor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClipFactor: *const fn (
            self: *const IFullScreenVideo,
            clip_factor: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMessageDrain: *const fn (
            self: *const IFullScreenVideo,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageDrain: *const fn (
            self: *const IFullScreenVideo,
            hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMonitor: *const fn (
            self: *const IFullScreenVideo,
            monitor: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: *const fn (
            self: *const IFullScreenVideo,
            monitor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HideOnDeactivate: *const fn (
            self: *const IFullScreenVideo,
            hide: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsHideOnDeactivate: *const fn (
            self: *const IFullScreenVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaption: *const fn (
            self: *const IFullScreenVideo,
            str_caption: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaption: *const fn (
            self: *const IFullScreenVideo,
            pstr_caption: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefault: *const fn (
            self: *const IFullScreenVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn countModes(self: *const T, p_modes_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).CountModes(@as(*const IFullScreenVideo, @ptrCast(self)), p_modes_);
            }
            pub inline fn getModeInfo(self: *const T, mode_: i32, p_width_: ?*i32, p_height_: ?*i32, p_depth_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetModeInfo(@as(*const IFullScreenVideo, @ptrCast(self)), mode_, p_width_, p_height_, p_depth_);
            }
            pub inline fn getCurrentMode(self: *const T, p_mode_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetCurrentMode(@as(*const IFullScreenVideo, @ptrCast(self)), p_mode_);
            }
            pub inline fn isModeAvailable(self: *const T, mode_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsModeAvailable(@as(*const IFullScreenVideo, @ptrCast(self)), mode_);
            }
            pub inline fn isModeEnabled(self: *const T, mode_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsModeEnabled(@as(*const IFullScreenVideo, @ptrCast(self)), mode_);
            }
            pub inline fn setEnabled(self: *const T, mode_: i32, b_enabled_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IFullScreenVideo, @ptrCast(self)), mode_, b_enabled_);
            }
            pub inline fn getClipFactor(self: *const T, p_clip_factor_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetClipFactor(@as(*const IFullScreenVideo, @ptrCast(self)), p_clip_factor_);
            }
            pub inline fn setClipFactor(self: *const T, clip_factor_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetClipFactor(@as(*const IFullScreenVideo, @ptrCast(self)), clip_factor_);
            }
            pub inline fn setMessageDrain(self: *const T, hwnd_: ?HWND) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetMessageDrain(@as(*const IFullScreenVideo, @ptrCast(self)), hwnd_);
            }
            pub inline fn getMessageDrain(self: *const T, hwnd_: ?*?HWND) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetMessageDrain(@as(*const IFullScreenVideo, @ptrCast(self)), hwnd_);
            }
            pub inline fn setMonitor(self: *const T, monitor_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IFullScreenVideo, @ptrCast(self)), monitor_);
            }
            pub inline fn getMonitor(self: *const T, monitor_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IFullScreenVideo, @ptrCast(self)), monitor_);
            }
            pub inline fn hideOnDeactivate(self: *const T, hide_: i32) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).HideOnDeactivate(@as(*const IFullScreenVideo, @ptrCast(self)), hide_);
            }
            pub inline fn isHideOnDeactivate(self: *const T) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsHideOnDeactivate(@as(*const IFullScreenVideo, @ptrCast(self)));
            }
            pub inline fn setCaption(self: *const T, str_caption_: ?BSTR) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetCaption(@as(*const IFullScreenVideo, @ptrCast(self)), str_caption_);
            }
            pub inline fn getCaption(self: *const T, pstr_caption_: ?*?BSTR) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetCaption(@as(*const IFullScreenVideo, @ptrCast(self)), pstr_caption_);
            }
            pub inline fn setDefault(self: *const T) HRESULT {
                return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetDefault(@as(*const IFullScreenVideo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IFullScreenVideoEx = extern struct {
    pub const VTable = extern struct {
        base: IFullScreenVideo.VTable,
        SetAcceleratorTable: *const fn (
            self: *const IFullScreenVideoEx,
            hwnd: ?HWND,
            h_accel: ?HACCEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAcceleratorTable: *const fn (
            self: *const IFullScreenVideoEx,
            phwnd: ?*?HWND,
            ph_accel: ?*?HACCEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeepPixelAspectRatio: *const fn (
            self: *const IFullScreenVideoEx,
            keep_aspect: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKeepPixelAspectRatio: *const fn (
            self: *const IFullScreenVideoEx,
            p_keep_aspect: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFullScreenVideo.MethodMixin(T);
            pub inline fn setAcceleratorTable(self: *const T, hwnd_: ?HWND, h_accel_: ?HACCEL) HRESULT {
                return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).SetAcceleratorTable(@as(*const IFullScreenVideoEx, @ptrCast(self)), hwnd_, h_accel_);
            }
            pub inline fn getAcceleratorTable(self: *const T, phwnd_: ?*?HWND, ph_accel_: ?*?HACCEL) HRESULT {
                return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).GetAcceleratorTable(@as(*const IFullScreenVideoEx, @ptrCast(self)), phwnd_, ph_accel_);
            }
            pub inline fn keepPixelAspectRatio(self: *const T, keep_aspect_: i32) HRESULT {
                return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).KeepPixelAspectRatio(@as(*const IFullScreenVideoEx, @ptrCast(self)), keep_aspect_);
            }
            pub inline fn isKeepPixelAspectRatio(self: *const T, p_keep_aspect_: ?*i32) HRESULT {
                return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).IsKeepPixelAspectRatio(@as(*const IFullScreenVideoEx, @ptrCast(self)), p_keep_aspect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IBaseVideoMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLeadPin: *const fn (
            self: *const IBaseVideoMixer,
            i_pin: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeadPin: *const fn (
            self: *const IBaseVideoMixer,
            pi_pin: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputPinCount: *const fn (
            self: *const IBaseVideoMixer,
            pi_pin_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingClock: *const fn (
            self: *const IBaseVideoMixer,
            pb_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUsingClock: *const fn (
            self: *const IBaseVideoMixer,
            b_value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClockPeriod: *const fn (
            self: *const IBaseVideoMixer,
            pb_value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClockPeriod: *const fn (
            self: *const IBaseVideoMixer,
            b_value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setLeadPin(self: *const T, i_pin_: i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetLeadPin(@as(*const IBaseVideoMixer, @ptrCast(self)), i_pin_);
            }
            pub inline fn getLeadPin(self: *const T, pi_pin_: ?*i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetLeadPin(@as(*const IBaseVideoMixer, @ptrCast(self)), pi_pin_);
            }
            pub inline fn getInputPinCount(self: *const T, pi_pin_count_: ?*i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetInputPinCount(@as(*const IBaseVideoMixer, @ptrCast(self)), pi_pin_count_);
            }
            pub inline fn isUsingClock(self: *const T, pb_value_: ?*i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).IsUsingClock(@as(*const IBaseVideoMixer, @ptrCast(self)), pb_value_);
            }
            pub inline fn setUsingClock(self: *const T, b_value_: i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetUsingClock(@as(*const IBaseVideoMixer, @ptrCast(self)), b_value_);
            }
            pub inline fn getClockPeriod(self: *const T, pb_value_: ?*i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetClockPeriod(@as(*const IBaseVideoMixer, @ptrCast(self)), pb_value_);
            }
            pub inline fn setClockPeriod(self: *const T, b_value_: i32) HRESULT {
                return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetClockPeriod(@as(*const IBaseVideoMixer, @ptrCast(self)), b_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TRUECOLORINFO = extern struct {
    dwBitMasks: [3]u32,
    bmiColors: [256]RGBQUAD,
};

pub const VIDEOINFOHEADER = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
};

pub const VIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
    Anonymous: extern union {
        bmiColors: [256]RGBQUAD,
        dwBitMasks: [3]u32,
        TrueColorInfo: TRUECOLORINFO,
    },
};

pub const MPEG1VIDEOINFO = extern struct {
    hdr: VIDEOINFOHEADER,
    dwStartTimeCode: u32,
    cbSequenceHeader: u32,
    bSequenceHeader: [1]u8,
};

pub const ANALOGVIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwActiveWidth: u32,
    dwActiveHeight: u32,
    AvgTimePerFrame: i64,
};

pub const AM_PROPERTY_FRAMESTEP = enum(i32) {
    STEP = 1,
    CANCEL = 2,
    CANSTEP = 3,
    CANSTEPMULTIPLE = 4,
};
pub const AM_PROPERTY_FRAMESTEP_STEP = AM_PROPERTY_FRAMESTEP.STEP;
pub const AM_PROPERTY_FRAMESTEP_CANCEL = AM_PROPERTY_FRAMESTEP.CANCEL;
pub const AM_PROPERTY_FRAMESTEP_CANSTEP = AM_PROPERTY_FRAMESTEP.CANSTEP;
pub const AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = AM_PROPERTY_FRAMESTEP.CANSTEPMULTIPLE;

pub const AM_FRAMESTEP_STEP = extern struct {
    dwFramesToStep: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDMOWrapperFilter_Value = Guid.initString("52d6f586-9f0f-4824-8fc8-e32ca04930c2");
pub const IID_IDMOWrapperFilter = &IID_IDMOWrapperFilter_Value;
pub const IDMOWrapperFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const IDMOWrapperFilter,
            clsid_d_m_o: ?*const Guid,
            cat_d_m_o: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, clsid_d_m_o_: ?*const Guid, cat_d_m_o_: ?*const Guid) HRESULT {
                return @as(*const IDMOWrapperFilter.VTable, @ptrCast(self.vtable)).Init(@as(*const IDMOWrapperFilter, @ptrCast(self)), clsid_d_m_o_, cat_d_m_o_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCXNotify_Value = Guid.initString("81a3bd31-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCXNotify = &IID_IMixerOCXNotify_Value;
pub const IMixerOCXNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInvalidateRect: *const fn (
            self: *const IMixerOCXNotify,
            lpc_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: *const fn (
            self: *const IMixerOCXNotify,
            ul_status_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataChange: *const fn (
            self: *const IMixerOCXNotify,
            ul_data_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onInvalidateRect(self: *const T, lpc_rect_: ?*RECT) HRESULT {
                return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnInvalidateRect(@as(*const IMixerOCXNotify, @ptrCast(self)), lpc_rect_);
            }
            pub inline fn onStatusChange(self: *const T, ul_status_flags_: u32) HRESULT {
                return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const IMixerOCXNotify, @ptrCast(self)), ul_status_flags_);
            }
            pub inline fn onDataChange(self: *const T, ul_data_flags_: u32) HRESULT {
                return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnDataChange(@as(*const IMixerOCXNotify, @ptrCast(self)), ul_data_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCX_Value = Guid.initString("81a3bd32-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCX = &IID_IMixerOCX_Value;
pub const IMixerOCX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayChange: *const fn (
            self: *const IMixerOCX,
            ul_bits_per_pixel: u32,
            ul_screen_width: u32,
            ul_screen_height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatio: *const fn (
            self: *const IMixerOCX,
            pdw_pict_aspect_ratio_x: ?*u32,
            pdw_pict_aspect_ratio_y: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSize: *const fn (
            self: *const IMixerOCX,
            pdw_video_width: ?*u32,
            pdw_video_height: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IMixerOCX,
            pdw_status: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDraw: *const fn (
            self: *const IMixerOCX,
            hdc_draw: ?HDC,
            prc_draw: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawRegion: *const fn (
            self: *const IMixerOCX,
            lppt_top_left_s_c: ?*POINT,
            prc_draw_c_c: ?*RECT,
            lprc_clip: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn (
            self: *const IMixerOCX,
            pmdns: ?*IMixerOCXNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: *const fn (
            self: *const IMixerOCX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onDisplayChange(self: *const T, ul_bits_per_pixel_: u32, ul_screen_width_: u32, ul_screen_height_: u32) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).OnDisplayChange(@as(*const IMixerOCX, @ptrCast(self)), ul_bits_per_pixel_, ul_screen_width_, ul_screen_height_);
            }
            pub inline fn getAspectRatio(self: *const T, pdw_pict_aspect_ratio_x_: ?*u32, pdw_pict_aspect_ratio_y_: ?*u32) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetAspectRatio(@as(*const IMixerOCX, @ptrCast(self)), pdw_pict_aspect_ratio_x_, pdw_pict_aspect_ratio_y_);
            }
            pub inline fn getVideoSize(self: *const T, pdw_video_width_: ?*u32, pdw_video_height_: ?*u32) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetVideoSize(@as(*const IMixerOCX, @ptrCast(self)), pdw_video_width_, pdw_video_height_);
            }
            pub inline fn getStatus(self: *const T, pdw_status_: ?*?*u32) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMixerOCX, @ptrCast(self)), pdw_status_);
            }
            pub inline fn onDraw(self: *const T, hdc_draw_: ?HDC, prc_draw_: ?*RECT) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).OnDraw(@as(*const IMixerOCX, @ptrCast(self)), hdc_draw_, prc_draw_);
            }
            pub inline fn setDrawRegion(self: *const T, lppt_top_left_s_c_: ?*POINT, prc_draw_c_c_: ?*RECT, lprc_clip_: ?*RECT) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).SetDrawRegion(@as(*const IMixerOCX, @ptrCast(self)), lppt_top_left_s_c_, prc_draw_c_c_, lprc_clip_);
            }
            pub inline fn advise(self: *const T, pmdns_: ?*IMixerOCXNotify) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMixerOCX, @ptrCast(self)), pmdns_);
            }
            pub inline fn unAdvise(self: *const T) HRESULT {
                return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).UnAdvise(@as(*const IMixerOCX, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_ASPECT_RATIO_MODE = enum(i32) {
    STRETCHED = 0,
    LETTER_BOX = 1,
    CROP = 2,
    STRETCHED_AS_PRIMARY = 3,
};
pub const AM_ARMODE_STRETCHED = AM_ASPECT_RATIO_MODE.STRETCHED;
pub const AM_ARMODE_LETTER_BOX = AM_ASPECT_RATIO_MODE.LETTER_BOX;
pub const AM_ARMODE_CROP = AM_ASPECT_RATIO_MODE.CROP;
pub const AM_ARMODE_STRETCHED_AS_PRIMARY = AM_ASPECT_RATIO_MODE.STRETCHED_AS_PRIMARY;

// TODO: this type is limited to platform 'windows5.0'
pub const IMixerPinConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRelativePosition: *const fn (
            self: *const IMixerPinConfig,
            dw_left: u32,
            dw_top: u32,
            dw_right: u32,
            dw_bottom: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelativePosition: *const fn (
            self: *const IMixerPinConfig,
            pdw_left: ?*u32,
            pdw_top: ?*u32,
            pdw_right: ?*u32,
            pdw_bottom: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: *const fn (
            self: *const IMixerPinConfig,
            dw_z_order: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: *const fn (
            self: *const IMixerPinConfig,
            pdw_z_order: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: *const fn (
            self: *const IMixerPinConfig,
            p_color_key: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: *const fn (
            self: *const IMixerPinConfig,
            p_color_key: ?*COLORKEY,
            p_color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlendingParameter: *const fn (
            self: *const IMixerPinConfig,
            dw_blending_parameter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlendingParameter: *const fn (
            self: *const IMixerPinConfig,
            pdw_blending_parameter: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: *const fn (
            self: *const IMixerPinConfig,
            am_aspect_ratio_mode: AM_ASPECT_RATIO_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: *const fn (
            self: *const IMixerPinConfig,
            pam_aspect_ratio_mode: ?*AM_ASPECT_RATIO_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamTransparent: *const fn (
            self: *const IMixerPinConfig,
            b_stream_transparent: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamTransparent: *const fn (
            self: *const IMixerPinConfig,
            pb_stream_transparent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setRelativePosition(self: *const T, dw_left_: u32, dw_top_: u32, dw_right_: u32, dw_bottom_: u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetRelativePosition(@as(*const IMixerPinConfig, @ptrCast(self)), dw_left_, dw_top_, dw_right_, dw_bottom_);
            }
            pub inline fn getRelativePosition(self: *const T, pdw_left_: ?*u32, pdw_top_: ?*u32, pdw_right_: ?*u32, pdw_bottom_: ?*u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetRelativePosition(@as(*const IMixerPinConfig, @ptrCast(self)), pdw_left_, pdw_top_, pdw_right_, pdw_bottom_);
            }
            pub inline fn setZOrder(self: *const T, dw_z_order_: u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IMixerPinConfig, @ptrCast(self)), dw_z_order_);
            }
            pub inline fn getZOrder(self: *const T, pdw_z_order_: ?*u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IMixerPinConfig, @ptrCast(self)), pdw_z_order_);
            }
            pub inline fn setColorKey(self: *const T, p_color_key_: ?*COLORKEY) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IMixerPinConfig, @ptrCast(self)), p_color_key_);
            }
            pub inline fn getColorKey(self: *const T, p_color_key_: ?*COLORKEY, p_color_: ?*u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IMixerPinConfig, @ptrCast(self)), p_color_key_, p_color_);
            }
            pub inline fn setBlendingParameter(self: *const T, dw_blending_parameter_: u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetBlendingParameter(@as(*const IMixerPinConfig, @ptrCast(self)), dw_blending_parameter_);
            }
            pub inline fn getBlendingParameter(self: *const T, pdw_blending_parameter_: ?*u32) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetBlendingParameter(@as(*const IMixerPinConfig, @ptrCast(self)), pdw_blending_parameter_);
            }
            pub inline fn setAspectRatioMode(self: *const T, am_aspect_ratio_mode_: AM_ASPECT_RATIO_MODE) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IMixerPinConfig, @ptrCast(self)), am_aspect_ratio_mode_);
            }
            pub inline fn getAspectRatioMode(self: *const T, pam_aspect_ratio_mode_: ?*AM_ASPECT_RATIO_MODE) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IMixerPinConfig, @ptrCast(self)), pam_aspect_ratio_mode_);
            }
            pub inline fn setStreamTransparent(self: *const T, b_stream_transparent_: BOOL) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetStreamTransparent(@as(*const IMixerPinConfig, @ptrCast(self)), b_stream_transparent_);
            }
            pub inline fn getStreamTransparent(self: *const T, pb_stream_transparent_: ?*BOOL) HRESULT {
                return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetStreamTransparent(@as(*const IMixerPinConfig, @ptrCast(self)), pb_stream_transparent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMixerPinConfig2 = extern struct {
    pub const VTable = extern struct {
        base: IMixerPinConfig.VTable,
        SetOverlaySurfaceColorControls: *const fn (
            self: *const IMixerPinConfig2,
            p_color_control: ?*DDCOLORCONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlaySurfaceColorControls: *const fn (
            self: *const IMixerPinConfig2,
            p_color_control: ?*DDCOLORCONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMixerPinConfig.MethodMixin(T);
            pub inline fn setOverlaySurfaceColorControls(self: *const T, p_color_control_: ?*DDCOLORCONTROL) HRESULT {
                return @as(*const IMixerPinConfig2.VTable, @ptrCast(self.vtable)).SetOverlaySurfaceColorControls(@as(*const IMixerPinConfig2, @ptrCast(self)), p_color_control_);
            }
            pub inline fn getOverlaySurfaceColorControls(self: *const T, p_color_control_: ?*DDCOLORCONTROL) HRESULT {
                return @as(*const IMixerPinConfig2.VTable, @ptrCast(self.vtable)).GetOverlaySurfaceColorControls(@as(*const IMixerPinConfig2, @ptrCast(self)), p_color_control_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MPEGSTREAMTYPE = extern struct {
    dwStreamId: u32,
    dwReserved: u32,
    mt: AM_MEDIA_TYPE,
    bFormat: [1]u8,
};

pub const AM_MPEGSYSTEMTYPE = extern struct {
    dwBitRate: u32,
    cStreams: u32,
    Streams: [1]AM_MPEGSTREAMTYPE,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMpegAudioDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyDivider: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_divider: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyDivider: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            divider: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderAccuracy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_accuracy: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderAccuracy: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            accuracy: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stereo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_stereo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Stereo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            stereo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderWordSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_word_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderWordSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            word_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntegerDecode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_int_decode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IntegerDecode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            int_decode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DualMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            p_int_decode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DualMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            int_decode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMpegAudioDecoder,
            lp_fmt: ?*MPEG1WAVEFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFrequencyDivider(self: *const T, p_divider_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_FrequencyDivider(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_divider_);
            }
            pub inline fn putFrequencyDivider(self: *const T, divider_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_FrequencyDivider(@as(*const IMpegAudioDecoder, @ptrCast(self)), divider_);
            }
            pub inline fn getDecoderAccuracy(self: *const T, p_accuracy_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DecoderAccuracy(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_accuracy_);
            }
            pub inline fn putDecoderAccuracy(self: *const T, accuracy_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DecoderAccuracy(@as(*const IMpegAudioDecoder, @ptrCast(self)), accuracy_);
            }
            pub inline fn getStereo(self: *const T, p_stereo_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_Stereo(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_stereo_);
            }
            pub inline fn putStereo(self: *const T, stereo_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_Stereo(@as(*const IMpegAudioDecoder, @ptrCast(self)), stereo_);
            }
            pub inline fn getDecoderWordSize(self: *const T, p_word_size_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DecoderWordSize(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_word_size_);
            }
            pub inline fn putDecoderWordSize(self: *const T, word_size_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DecoderWordSize(@as(*const IMpegAudioDecoder, @ptrCast(self)), word_size_);
            }
            pub inline fn getIntegerDecode(self: *const T, p_int_decode_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_IntegerDecode(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_int_decode_);
            }
            pub inline fn putIntegerDecode(self: *const T, int_decode_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_IntegerDecode(@as(*const IMpegAudioDecoder, @ptrCast(self)), int_decode_);
            }
            pub inline fn getDualMode(self: *const T, p_int_decode_: ?*u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DualMode(@as(*const IMpegAudioDecoder, @ptrCast(self)), p_int_decode_);
            }
            pub inline fn putDualMode(self: *const T, int_decode_: u32) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DualMode(@as(*const IMpegAudioDecoder, @ptrCast(self)), int_decode_);
            }
            pub inline fn getAudioFormat(self: *const T, lp_fmt_: ?*MPEG1WAVEFORMAT) HRESULT {
                return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_AudioFormat(@as(*const IMpegAudioDecoder, @ptrCast(self)), lp_fmt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9PresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMR9Sample_SyncPoint = VMR9PresentationFlags.SyncPoint;
pub const VMR9Sample_Preroll = VMR9PresentationFlags.Preroll;
pub const VMR9Sample_Discontinuity = VMR9PresentationFlags.Discontinuity;
pub const VMR9Sample_TimeValid = VMR9PresentationFlags.TimeValid;
pub const VMR9Sample_SrcDstRectsValid = VMR9PresentationFlags.SrcDstRectsValid;

pub const VMR9PresentationInfo = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirect3DSurface9,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwReserved1: u32,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter9_Value = Guid.initString("69188c61-12a3-40f0-8ffc-342e7b433fd7");
pub const IID_IVMRImagePresenter9 = &IID_IVMRImagePresenter9_Value;
pub const IVMRImagePresenter9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: *const fn (
            self: *const IVMRImagePresenter9,
            dw_user_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopPresenting: *const fn (
            self: *const IVMRImagePresenter9,
            dw_user_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PresentImage: *const fn (
            self: *const IVMRImagePresenter9,
            dw_user_i_d: usize,
            lp_pres_info: ?*VMR9PresentationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startPresenting(self: *const T, dw_user_i_d_: usize) HRESULT {
                return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).StartPresenting(@as(*const IVMRImagePresenter9, @ptrCast(self)), dw_user_i_d_);
            }
            pub inline fn stopPresenting(self: *const T, dw_user_i_d_: usize) HRESULT {
                return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).StopPresenting(@as(*const IVMRImagePresenter9, @ptrCast(self)), dw_user_i_d_);
            }
            pub inline fn presentImage(self: *const T, dw_user_i_d_: usize, lp_pres_info_: ?*VMR9PresentationInfo) HRESULT {
                return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).PresentImage(@as(*const IVMRImagePresenter9, @ptrCast(self)), dw_user_i_d_, lp_pres_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9SurfaceAllocationFlags = enum(i32) {
    @"3DRenderTarget" = 1,
    DXVATarget = 2,
    TextureSurface = 4,
    OffscreenSurface = 8,
    RGBDynamicSwitch = 16,
    UsageReserved = 224,
    UsageMask = 255,
};
pub const VMR9AllocFlag_3DRenderTarget = VMR9SurfaceAllocationFlags.@"3DRenderTarget";
pub const VMR9AllocFlag_DXVATarget = VMR9SurfaceAllocationFlags.DXVATarget;
pub const VMR9AllocFlag_TextureSurface = VMR9SurfaceAllocationFlags.TextureSurface;
pub const VMR9AllocFlag_OffscreenSurface = VMR9SurfaceAllocationFlags.OffscreenSurface;
pub const VMR9AllocFlag_RGBDynamicSwitch = VMR9SurfaceAllocationFlags.RGBDynamicSwitch;
pub const VMR9AllocFlag_UsageReserved = VMR9SurfaceAllocationFlags.UsageReserved;
pub const VMR9AllocFlag_UsageMask = VMR9SurfaceAllocationFlags.UsageMask;

pub const VMR9AllocationInfo = extern struct {
    dwFlags: u32,
    dwWidth: u32,
    dwHeight: u32,
    Format: D3DFORMAT,
    Pool: D3DPOOL,
    MinBuffers: u32,
    szAspectRatio: SIZE,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator9_Value = Guid.initString("8d5148ea-3f5d-46cf-9df1-d1b896eedb1f");
pub const IID_IVMRSurfaceAllocator9 = &IID_IVMRSurfaceAllocator9_Value;
pub const IVMRSurfaceAllocator9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeDevice: *const fn (
            self: *const IVMRSurfaceAllocator9,
            dw_user_i_d: usize,
            lp_alloc_info: ?*VMR9AllocationInfo,
            lp_num_buffers: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateDevice: *const fn (
            self: *const IVMRSurfaceAllocator9,
            dw_i_d: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: *const fn (
            self: *const IVMRSurfaceAllocator9,
            dw_user_i_d: usize,
            surface_index: u32,
            surface_flags: u32,
            lplp_surface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseNotify: *const fn (
            self: *const IVMRSurfaceAllocator9,
            lp_i_v_m_r_surf_alloc_notify: ?*IVMRSurfaceAllocatorNotify9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initializeDevice(self: *const T, dw_user_i_d_: usize, lp_alloc_info_: ?*VMR9AllocationInfo, lp_num_buffers_: ?*u32) HRESULT {
                return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).InitializeDevice(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dw_user_i_d_, lp_alloc_info_, lp_num_buffers_);
            }
            pub inline fn terminateDevice(self: *const T, dw_i_d_: usize) HRESULT {
                return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).TerminateDevice(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dw_i_d_);
            }
            pub inline fn getSurface(self: *const T, dw_user_i_d_: usize, surface_index_: u32, surface_flags_: u32, lplp_surface_: ?*?*IDirect3DSurface9) HRESULT {
                return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dw_user_i_d_, surface_index_, surface_flags_, lplp_surface_);
            }
            pub inline fn adviseNotify(self: *const T, lp_i_v_m_r_surf_alloc_notify_: ?*IVMRSurfaceAllocatorNotify9) HRESULT {
                return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).AdviseNotify(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), lp_i_v_m_r_surf_alloc_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorEx9_Value = Guid.initString("6de9a68a-a928-4522-bf57-655ae3866456");
pub const IID_IVMRSurfaceAllocatorEx9 = &IID_IVMRSurfaceAllocatorEx9_Value;
pub const IVMRSurfaceAllocatorEx9 = extern struct {
    pub const VTable = extern struct {
        base: IVMRSurfaceAllocator9.VTable,
        GetSurfaceEx: *const fn (
            self: *const IVMRSurfaceAllocatorEx9,
            dw_user_i_d: usize,
            surface_index: u32,
            surface_flags: u32,
            lplp_surface: ?*?*IDirect3DSurface9,
            lprc_dst: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVMRSurfaceAllocator9.MethodMixin(T);
            pub inline fn getSurfaceEx(self: *const T, dw_user_i_d_: usize, surface_index_: u32, surface_flags_: u32, lplp_surface_: ?*?*IDirect3DSurface9, lprc_dst_: ?*RECT) HRESULT {
                return @as(*const IVMRSurfaceAllocatorEx9.VTable, @ptrCast(self.vtable)).GetSurfaceEx(@as(*const IVMRSurfaceAllocatorEx9, @ptrCast(self)), dw_user_i_d_, surface_index_, surface_flags_, lplp_surface_, lprc_dst_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify9_Value = Guid.initString("dca3f5df-bb3a-4d03-bd81-84614bfbfa0c");
pub const IID_IVMRSurfaceAllocatorNotify9 = &IID_IVMRSurfaceAllocatorNotify9_Value;
pub const IVMRSurfaceAllocatorNotify9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: *const fn (
            self: *const IVMRSurfaceAllocatorNotify9,
            dw_user_i_d: usize,
            lp_i_v_r_m_surface_allocator: ?*IVMRSurfaceAllocator9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetD3DDevice: *const fn (
            self: *const IVMRSurfaceAllocatorNotify9,
            lp_d3_d_device: ?*IDirect3DDevice9,
            h_monitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeD3DDevice: *const fn (
            self: *const IVMRSurfaceAllocatorNotify9,
            lp_d3_d_device: ?*IDirect3DDevice9,
            h_monitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateSurfaceHelper: *const fn (
            self: *const IVMRSurfaceAllocatorNotify9,
            lp_alloc_info: ?*VMR9AllocationInfo,
            lp_num_buffers: ?*u32,
            lplp_surface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEvent: *const fn (
            self: *const IVMRSurfaceAllocatorNotify9,
            event_code: i32,
            param1: isize,
            param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn adviseSurfaceAllocator(self: *const T, dw_user_i_d_: usize, lp_i_v_r_m_surface_allocator_: ?*IVMRSurfaceAllocator9) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).AdviseSurfaceAllocator(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), dw_user_i_d_, lp_i_v_r_m_surface_allocator_);
            }
            pub inline fn setD3DDevice(self: *const T, lp_d3_d_device_: ?*IDirect3DDevice9, h_monitor_: ?HMONITOR) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).SetD3DDevice(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lp_d3_d_device_, h_monitor_);
            }
            pub inline fn changeD3DDevice(self: *const T, lp_d3_d_device_: ?*IDirect3DDevice9, h_monitor_: ?HMONITOR) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).ChangeD3DDevice(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lp_d3_d_device_, h_monitor_);
            }
            pub inline fn allocateSurfaceHelper(self: *const T, lp_alloc_info_: ?*VMR9AllocationInfo, lp_num_buffers_: ?*u32, lplp_surface_: ?*?*IDirect3DSurface9) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).AllocateSurfaceHelper(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lp_alloc_info_, lp_num_buffers_, lplp_surface_);
            }
            pub inline fn notifyEvent(self: *const T, event_code_: i32, param1_: isize, param2_: isize) HRESULT {
                return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).NotifyEvent(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), event_code_, param1_, param2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AspectRatioMode = enum(i32) {
    None = 0,
    LetterBox = 1,
};
pub const VMR9ARMode_None = VMR9AspectRatioMode.None;
pub const VMR9ARMode_LetterBox = VMR9AspectRatioMode.LetterBox;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl9_Value = Guid.initString("8f537d09-f85e-4414-b23b-502e54c79927");
pub const IID_IVMRWindowlessControl9 = &IID_IVMRWindowlessControl9_Value;
pub const IVMRWindowlessControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_width: ?*i32,
            lp_height: ?*i32,
            lp_a_r_width: ?*i32,
            lp_a_r_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealVideoSize: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_width: ?*i32,
            lp_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealVideoSize: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_width: ?*i32,
            lp_height: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPosition: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_s_r_c_rect: ?*const RECT,
            lp_d_s_t_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_s_r_c_rect: ?*RECT,
            lp_d_s_t_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_aspect_ratio_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: *const fn (
            self: *const IVMRWindowlessControl9,
            aspect_ratio_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoClippingWindow: *const fn (
            self: *const IVMRWindowlessControl9,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RepaintVideo: *const fn (
            self: *const IVMRWindowlessControl9,
            hwnd: ?HWND,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayModeChanged: *const fn (
            self: *const IVMRWindowlessControl9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_dib: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: *const fn (
            self: *const IVMRWindowlessControl9,
            clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: *const fn (
            self: *const IVMRWindowlessControl9,
            lp_clr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNativeVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32, lp_a_r_width_: ?*i32, lp_a_r_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_width_, lp_height_, lp_a_r_width_, lp_a_r_height_);
            }
            pub inline fn getMinIdealVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetMinIdealVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_width_, lp_height_);
            }
            pub inline fn getMaxIdealVideoSize(self: *const T, lp_width_: ?*i32, lp_height_: ?*i32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetMaxIdealVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_width_, lp_height_);
            }
            pub inline fn setVideoPosition(self: *const T, lp_s_r_c_rect_: ?*const RECT, lp_d_s_t_rect_: ?*const RECT) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetVideoPosition(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_s_r_c_rect_, lp_d_s_t_rect_);
            }
            pub inline fn getVideoPosition(self: *const T, lp_s_r_c_rect_: ?*RECT, lp_d_s_t_rect_: ?*RECT) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_s_r_c_rect_, lp_d_s_t_rect_);
            }
            pub inline fn getAspectRatioMode(self: *const T, lp_aspect_ratio_mode_: ?*u32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_aspect_ratio_mode_);
            }
            pub inline fn setAspectRatioMode(self: *const T, aspect_ratio_mode_: u32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRWindowlessControl9, @ptrCast(self)), aspect_ratio_mode_);
            }
            pub inline fn setVideoClippingWindow(self: *const T, hwnd_: ?HWND) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetVideoClippingWindow(@as(*const IVMRWindowlessControl9, @ptrCast(self)), hwnd_);
            }
            pub inline fn repaintVideo(self: *const T, hwnd_: ?HWND, hdc_: ?HDC) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).RepaintVideo(@as(*const IVMRWindowlessControl9, @ptrCast(self)), hwnd_, hdc_);
            }
            pub inline fn displayModeChanged(self: *const T) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).DisplayModeChanged(@as(*const IVMRWindowlessControl9, @ptrCast(self)));
            }
            pub inline fn getCurrentImage(self: *const T, lp_dib_: ?*?*u8) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_dib_);
            }
            pub inline fn setBorderColor(self: *const T, clr_: u32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRWindowlessControl9, @ptrCast(self)), clr_);
            }
            pub inline fn getBorderColor(self: *const T, lp_clr_: ?*u32) HRESULT {
                return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lp_clr_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    NonSquareMixing = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    AnisotropicFiltering = 64,
    PyramidalQuadFiltering = 128,
    GaussianQuadFiltering = 256,
    FilteringReserved = 3584,
    FilteringMask = 4080,
    RenderTargetRGB = 4096,
    RenderTargetYUV = 8192,
    RenderTargetReserved = 1032192,
    RenderTargetMask = 1044480,
    DynamicSwitchToBOB = 1048576,
    DynamicDecimateBy2 = 2097152,
    DynamicReserved = 12582912,
    DynamicMask = 15728640,
};
pub const MixerPref9_NoDecimation = VMR9MixerPrefs.NoDecimation;
pub const MixerPref9_DecimateOutput = VMR9MixerPrefs.DecimateOutput;
pub const MixerPref9_ARAdjustXorY = VMR9MixerPrefs.ARAdjustXorY;
pub const MixerPref9_NonSquareMixing = VMR9MixerPrefs.NonSquareMixing;
pub const MixerPref9_DecimateMask = VMR9MixerPrefs.DecimateMask;
pub const MixerPref9_BiLinearFiltering = VMR9MixerPrefs.BiLinearFiltering;
pub const MixerPref9_PointFiltering = VMR9MixerPrefs.PointFiltering;
pub const MixerPref9_AnisotropicFiltering = VMR9MixerPrefs.AnisotropicFiltering;
pub const MixerPref9_PyramidalQuadFiltering = VMR9MixerPrefs.PyramidalQuadFiltering;
pub const MixerPref9_GaussianQuadFiltering = VMR9MixerPrefs.GaussianQuadFiltering;
pub const MixerPref9_FilteringReserved = VMR9MixerPrefs.FilteringReserved;
pub const MixerPref9_FilteringMask = VMR9MixerPrefs.FilteringMask;
pub const MixerPref9_RenderTargetRGB = VMR9MixerPrefs.RenderTargetRGB;
pub const MixerPref9_RenderTargetYUV = VMR9MixerPrefs.RenderTargetYUV;
pub const MixerPref9_RenderTargetReserved = VMR9MixerPrefs.RenderTargetReserved;
pub const MixerPref9_RenderTargetMask = VMR9MixerPrefs.RenderTargetMask;
pub const MixerPref9_DynamicSwitchToBOB = VMR9MixerPrefs.DynamicSwitchToBOB;
pub const MixerPref9_DynamicDecimateBy2 = VMR9MixerPrefs.DynamicDecimateBy2;
pub const MixerPref9_DynamicReserved = VMR9MixerPrefs.DynamicReserved;
pub const MixerPref9_DynamicMask = VMR9MixerPrefs.DynamicMask;

pub const VMR9NormalizedRect = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

pub const VMR9ProcAmpControlFlags = enum(i32) {
    Brightness = 1,
    Contrast = 2,
    Hue = 4,
    Saturation = 8,
    Mask = 15,
};
pub const ProcAmpControl9_Brightness = VMR9ProcAmpControlFlags.Brightness;
pub const ProcAmpControl9_Contrast = VMR9ProcAmpControlFlags.Contrast;
pub const ProcAmpControl9_Hue = VMR9ProcAmpControlFlags.Hue;
pub const ProcAmpControl9_Saturation = VMR9ProcAmpControlFlags.Saturation;
pub const ProcAmpControl9_Mask = VMR9ProcAmpControlFlags.Mask;

pub const VMR9ProcAmpControl = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Brightness: f32,
    Contrast: f32,
    Hue: f32,
    Saturation: f32,
};

pub const VMR9ProcAmpControlRange = extern struct {
    dwSize: u32,
    dwProperty: VMR9ProcAmpControlFlags,
    MinValue: f32,
    MaxValue: f32,
    DefaultValue: f32,
    StepSize: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl9_Value = Guid.initString("1a777eaa-47c8-4930-b2c9-8fee1c1b0f3b");
pub const IID_IVMRMixerControl9 = &IID_IVMRMixerControl9_Value;
pub const IVMRMixerControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            alpha: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlpha: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            p_alpha: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            dw_z: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            p_z: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputRect: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            p_rect: ?*const VMR9NormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputRect: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            p_rect: ?*VMR9NormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundClr: *const fn (
            self: *const IVMRMixerControl9,
            clr_bkg: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundClr: *const fn (
            self: *const IVMRMixerControl9,
            lp_clr_bkg: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMixingPrefs: *const fn (
            self: *const IVMRMixerControl9,
            dw_mixer_prefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixingPrefs: *const fn (
            self: *const IVMRMixerControl9,
            pdw_mixer_prefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcAmpControl: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            lp_clr_control: ?*VMR9ProcAmpControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpControl: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            lp_clr_control: ?*VMR9ProcAmpControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpControlRange: *const fn (
            self: *const IVMRMixerControl9,
            dw_stream_i_d: u32,
            lp_clr_control: ?*VMR9ProcAmpControlRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAlpha(self: *const T, dw_stream_i_d_: u32, alpha_: f32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetAlpha(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, alpha_);
            }
            pub inline fn getAlpha(self: *const T, dw_stream_i_d_: u32, p_alpha_: ?*f32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetAlpha(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, p_alpha_);
            }
            pub inline fn setZOrder(self: *const T, dw_stream_i_d_: u32, dw_z_: u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, dw_z_);
            }
            pub inline fn getZOrder(self: *const T, dw_stream_i_d_: u32, p_z_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, p_z_);
            }
            pub inline fn setOutputRect(self: *const T, dw_stream_i_d_: u32, p_rect_: ?*const VMR9NormalizedRect) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetOutputRect(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, p_rect_);
            }
            pub inline fn getOutputRect(self: *const T, dw_stream_i_d_: u32, p_rect_: ?*VMR9NormalizedRect) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetOutputRect(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, p_rect_);
            }
            pub inline fn setBackgroundClr(self: *const T, clr_bkg_: u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetBackgroundClr(@as(*const IVMRMixerControl9, @ptrCast(self)), clr_bkg_);
            }
            pub inline fn getBackgroundClr(self: *const T, lp_clr_bkg_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetBackgroundClr(@as(*const IVMRMixerControl9, @ptrCast(self)), lp_clr_bkg_);
            }
            pub inline fn setMixingPrefs(self: *const T, dw_mixer_prefs_: u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetMixingPrefs(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_mixer_prefs_);
            }
            pub inline fn getMixingPrefs(self: *const T, pdw_mixer_prefs_: ?*u32) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetMixingPrefs(@as(*const IVMRMixerControl9, @ptrCast(self)), pdw_mixer_prefs_);
            }
            pub inline fn setProcAmpControl(self: *const T, dw_stream_i_d_: u32, lp_clr_control_: ?*VMR9ProcAmpControl) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetProcAmpControl(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, lp_clr_control_);
            }
            pub inline fn getProcAmpControl(self: *const T, dw_stream_i_d_: u32, lp_clr_control_: ?*VMR9ProcAmpControl) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetProcAmpControl(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, lp_clr_control_);
            }
            pub inline fn getProcAmpControlRange(self: *const T, dw_stream_i_d_: u32, lp_clr_control_: ?*VMR9ProcAmpControlRange) HRESULT {
                return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetProcAmpControlRange(@as(*const IVMRMixerControl9, @ptrCast(self)), dw_stream_i_d_, lp_clr_control_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AlphaBitmap = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirect3DSurface9,
    rSrc: RECT,
    rDest: VMR9NormalizedRect,
    fAlpha: f32,
    clrSrcKey: u32,
    dwFilterMode: u32,
};

pub const VMR9AlphaBitmapFlags = enum(i32) {
    Disable = 1,
    hDC = 2,
    EntireDDS = 4,
    SrcColorKey = 8,
    SrcRect = 16,
    FilterMode = 32,
};
pub const VMR9AlphaBitmap_Disable = VMR9AlphaBitmapFlags.Disable;
pub const VMR9AlphaBitmap_hDC = VMR9AlphaBitmapFlags.hDC;
pub const VMR9AlphaBitmap_EntireDDS = VMR9AlphaBitmapFlags.EntireDDS;
pub const VMR9AlphaBitmap_SrcColorKey = VMR9AlphaBitmapFlags.SrcColorKey;
pub const VMR9AlphaBitmap_SrcRect = VMR9AlphaBitmapFlags.SrcRect;
pub const VMR9AlphaBitmap_FilterMode = VMR9AlphaBitmapFlags.FilterMode;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap9_Value = Guid.initString("ced175e5-1935-4820-81bd-ff6ad00c9108");
pub const IID_IVMRMixerBitmap9 = &IID_IVMRMixerBitmap9_Value;
pub const IVMRMixerBitmap9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: *const fn (
            self: *const IVMRMixerBitmap9,
            p_bmp_parms: ?*const VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAlphaBitmapParameters: *const fn (
            self: *const IVMRMixerBitmap9,
            p_bmp_parms: ?*const VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlphaBitmapParameters: *const fn (
            self: *const IVMRMixerBitmap9,
            p_bmp_parms: ?*VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAlphaBitmap(self: *const T, p_bmp_parms_: ?*const VMR9AlphaBitmap) HRESULT {
                return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).SetAlphaBitmap(@as(*const IVMRMixerBitmap9, @ptrCast(self)), p_bmp_parms_);
            }
            pub inline fn updateAlphaBitmapParameters(self: *const T, p_bmp_parms_: ?*const VMR9AlphaBitmap) HRESULT {
                return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).UpdateAlphaBitmapParameters(@as(*const IVMRMixerBitmap9, @ptrCast(self)), p_bmp_parms_);
            }
            pub inline fn getAlphaBitmapParameters(self: *const T, p_bmp_parms_: ?*VMR9AlphaBitmap) HRESULT {
                return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).GetAlphaBitmapParameters(@as(*const IVMRMixerBitmap9, @ptrCast(self)), p_bmp_parms_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface9_Value = Guid.initString("dfc581a1-6e1f-4c3a-8d0a-5e9792ea2afc");
pub const IID_IVMRSurface9 = &IID_IVMRSurface9_Value;
pub const IVMRSurface9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: *const fn (
            self: *const IVMRSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockSurface: *const fn (
            self: *const IVMRSurface9,
            lp_surface: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockSurface: *const fn (
            self: *const IVMRSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: *const fn (
            self: *const IVMRSurface9,
            lplp_surface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isSurfaceLocked(self: *const T) HRESULT {
                return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).IsSurfaceLocked(@as(*const IVMRSurface9, @ptrCast(self)));
            }
            pub inline fn lockSurface(self: *const T, lp_surface_: ?*?*u8) HRESULT {
                return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).LockSurface(@as(*const IVMRSurface9, @ptrCast(self)), lp_surface_);
            }
            pub inline fn unlockSurface(self: *const T) HRESULT {
                return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).UnlockSurface(@as(*const IVMRSurface9, @ptrCast(self)));
            }
            pub inline fn getSurface(self: *const T, lplp_surface_: ?*?*IDirect3DSurface9) HRESULT {
                return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurface9, @ptrCast(self)), lplp_surface_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9RenderPrefs = enum(i32) {
    DoNotRenderBorder = 1,
    // Mask = 1, this enum value conflicts with DoNotRenderBorder
};
pub const RenderPrefs9_DoNotRenderBorder = VMR9RenderPrefs.DoNotRenderBorder;
pub const RenderPrefs9_Mask = VMR9RenderPrefs.DoNotRenderBorder;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig9_Value = Guid.initString("45c15cab-6e22-420a-8043-ae1f0ac02c7d");
pub const IID_IVMRImagePresenterConfig9 = &IID_IVMRImagePresenterConfig9_Value;
pub const IVMRImagePresenterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: *const fn (
            self: *const IVMRImagePresenterConfig9,
            dw_render_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: *const fn (
            self: *const IVMRImagePresenterConfig9,
            dw_render_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setRenderingPrefs(self: *const T, dw_render_flags_: u32) HRESULT {
                return @as(*const IVMRImagePresenterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRImagePresenterConfig9, @ptrCast(self)), dw_render_flags_);
            }
            pub inline fn getRenderingPrefs(self: *const T, dw_render_flags_: ?*u32) HRESULT {
                return @as(*const IVMRImagePresenterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRImagePresenterConfig9, @ptrCast(self)), dw_render_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl9_Value = Guid.initString("d0cfe38b-93e7-4772-8957-0400c49a4485");
pub const IID_IVMRVideoStreamControl9 = &IID_IVMRVideoStreamControl9_Value;
pub const IVMRVideoStreamControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamActiveState: *const fn (
            self: *const IVMRVideoStreamControl9,
            f_active: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamActiveState: *const fn (
            self: *const IVMRVideoStreamControl9,
            lpf_active: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setStreamActiveState(self: *const T, f_active_: BOOL) HRESULT {
                return @as(*const IVMRVideoStreamControl9.VTable, @ptrCast(self.vtable)).SetStreamActiveState(@as(*const IVMRVideoStreamControl9, @ptrCast(self)), f_active_);
            }
            pub inline fn getStreamActiveState(self: *const T, lpf_active_: ?*BOOL) HRESULT {
                return @as(*const IVMRVideoStreamControl9.VTable, @ptrCast(self.vtable)).GetStreamActiveState(@as(*const IVMRVideoStreamControl9, @ptrCast(self)), lpf_active_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9Mode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMR9Mode_Windowed = VMR9Mode.Windowed;
pub const VMR9Mode_Windowless = VMR9Mode.Windowless;
pub const VMR9Mode_Renderless = VMR9Mode.Renderless;
pub const VMR9Mode_Mask = VMR9Mode.Mask;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig9_Value = Guid.initString("5a804648-4f66-4867-9c43-4f5c822cf1b8");
pub const IID_IVMRFilterConfig9 = &IID_IVMRFilterConfig9_Value;
pub const IVMRFilterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: *const fn (
            self: *const IVMRFilterConfig9,
            lp_v_m_r_img_compositor: ?*IVMRImageCompositor9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNumberOfStreams: *const fn (
            self: *const IVMRFilterConfig9,
            dw_max_streams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: *const fn (
            self: *const IVMRFilterConfig9,
            pdw_max_streams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingPrefs: *const fn (
            self: *const IVMRFilterConfig9,
            dw_render_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: *const fn (
            self: *const IVMRFilterConfig9,
            pdw_render_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingMode: *const fn (
            self: *const IVMRFilterConfig9,
            mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingMode: *const fn (
            self: *const IVMRFilterConfig9,
            p_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setImageCompositor(self: *const T, lp_v_m_r_img_compositor_: ?*IVMRImageCompositor9) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetImageCompositor(@as(*const IVMRFilterConfig9, @ptrCast(self)), lp_v_m_r_img_compositor_);
            }
            pub inline fn setNumberOfStreams(self: *const T, dw_max_streams_: u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetNumberOfStreams(@as(*const IVMRFilterConfig9, @ptrCast(self)), dw_max_streams_);
            }
            pub inline fn getNumberOfStreams(self: *const T, pdw_max_streams_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IVMRFilterConfig9, @ptrCast(self)), pdw_max_streams_);
            }
            pub inline fn setRenderingPrefs(self: *const T, dw_render_flags_: u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRFilterConfig9, @ptrCast(self)), dw_render_flags_);
            }
            pub inline fn getRenderingPrefs(self: *const T, pdw_render_flags_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRFilterConfig9, @ptrCast(self)), pdw_render_flags_);
            }
            pub inline fn setRenderingMode(self: *const T, mode_: u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingMode(@as(*const IVMRFilterConfig9, @ptrCast(self)), mode_);
            }
            pub inline fn getRenderingMode(self: *const T, p_mode_: ?*u32) HRESULT {
                return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingMode(@as(*const IVMRFilterConfig9, @ptrCast(self)), p_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl9_Value = Guid.initString("00d96c29-bbde-4efc-9901-bb5036392146");
pub const IID_IVMRAspectRatioControl9 = &IID_IVMRAspectRatioControl9_Value;
pub const IVMRAspectRatioControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: *const fn (
            self: *const IVMRAspectRatioControl9,
            lpdw_a_r_mode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: *const fn (
            self: *const IVMRAspectRatioControl9,
            dw_a_r_mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAspectRatioMode(self: *const T, lpdw_a_r_mode_: ?*u32) HRESULT {
                return @as(*const IVMRAspectRatioControl9.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRAspectRatioControl9, @ptrCast(self)), lpdw_a_r_mode_);
            }
            pub inline fn setAspectRatioMode(self: *const T, dw_a_r_mode_: u32) HRESULT {
                return @as(*const IVMRAspectRatioControl9.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRAspectRatioControl9, @ptrCast(self)), dw_a_r_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MonitorInfo = extern struct {
    uDevID: u32,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [512]u16,
    liDriverVersion: LARGE_INTEGER,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig9_Value = Guid.initString("46c2e457-8ba0-4eef-b80b-0680f0978749");
pub const IID_IVMRMonitorConfig9 = &IID_IVMRMonitorConfig9_Value;
pub const IVMRMonitorConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: *const fn (
            self: *const IVMRMonitorConfig9,
            u_dev: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: *const fn (
            self: *const IVMRMonitorConfig9,
            pu_dev: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultMonitor: *const fn (
            self: *const IVMRMonitorConfig9,
            u_dev: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMonitor: *const fn (
            self: *const IVMRMonitorConfig9,
            pu_dev: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableMonitors: *const fn (
            self: *const IVMRMonitorConfig9,
            p_info: [*]VMR9MonitorInfo,
            dw_max_info_array_size: u32,
            pdw_num_devices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMonitor(self: *const T, u_dev_: u32) HRESULT {
                return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), u_dev_);
            }
            pub inline fn getMonitor(self: *const T, pu_dev_: ?*u32) HRESULT {
                return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), pu_dev_);
            }
            pub inline fn setDefaultMonitor(self: *const T, u_dev_: u32) HRESULT {
                return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).SetDefaultMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), u_dev_);
            }
            pub inline fn getDefaultMonitor(self: *const T, pu_dev_: ?*u32) HRESULT {
                return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetDefaultMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), pu_dev_);
            }
            pub inline fn getAvailableMonitors(self: *const T, p_info_: [*]VMR9MonitorInfo, dw_max_info_array_size_: u32, pdw_num_devices_: ?*u32) HRESULT {
                return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetAvailableMonitors(@as(*const IVMRMonitorConfig9, @ptrCast(self)), p_info_, dw_max_info_array_size_, pdw_num_devices_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9DeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref9_NextBest = VMR9DeinterlacePrefs.NextBest;
pub const DeinterlacePref9_BOB = VMR9DeinterlacePrefs.BOB;
pub const DeinterlacePref9_Weave = VMR9DeinterlacePrefs.Weave;
pub const DeinterlacePref9_Mask = VMR9DeinterlacePrefs.Mask;

pub const VMR9DeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech9_Unknown = VMR9DeinterlaceTech.Unknown;
pub const DeinterlaceTech9_BOBLineReplicate = VMR9DeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech9_BOBVerticalStretch = VMR9DeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech9_MedianFiltering = VMR9DeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech9_EdgeFiltering = VMR9DeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech9_FieldAdaptive = VMR9DeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech9_PixelAdaptive = VMR9DeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech9_MotionVectorSteered = VMR9DeinterlaceTech.MotionVectorSteered;

pub const VMR9Frequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMR9_SampleFormat = enum(i32) {
    Reserved = 1,
    ProgressiveFrame = 2,
    FieldInterleavedEvenFirst = 3,
    FieldInterleavedOddFirst = 4,
    FieldSingleEven = 5,
    FieldSingleOdd = 6,
};
pub const VMR9_SampleReserved = VMR9_SampleFormat.Reserved;
pub const VMR9_SampleProgressiveFrame = VMR9_SampleFormat.ProgressiveFrame;
pub const VMR9_SampleFieldInterleavedEvenFirst = VMR9_SampleFormat.FieldInterleavedEvenFirst;
pub const VMR9_SampleFieldInterleavedOddFirst = VMR9_SampleFormat.FieldInterleavedOddFirst;
pub const VMR9_SampleFieldSingleEven = VMR9_SampleFormat.FieldSingleEven;
pub const VMR9_SampleFieldSingleOdd = VMR9_SampleFormat.FieldSingleOdd;

pub const VMR9VideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SampleFormat: VMR9_SampleFormat,
    dwFourCC: u32,
    InputSampleFreq: VMR9Frequency,
    OutputFrameFreq: VMR9Frequency,
};

pub const VMR9DeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMR9DeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl9_Value = Guid.initString("a215fb8d-13c2-4f7f-993c-003d6271a459");
pub const IID_IVMRDeinterlaceControl9 = &IID_IVMRDeinterlaceControl9_Value;
pub const IVMRDeinterlaceControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: *const fn (
            self: *const IVMRDeinterlaceControl9,
            lp_video_description: ?*VMR9VideoDesc,
            lpdw_num_deinterlace_modes: ?*u32,
            lp_deinterlace_modes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceModeCaps: *const fn (
            self: *const IVMRDeinterlaceControl9,
            lp_deinterlace_mode: ?*Guid,
            lp_video_description: ?*VMR9VideoDesc,
            lp_deinterlace_caps: ?*VMR9DeinterlaceCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl9,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl9,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlacePrefs: *const fn (
            self: *const IVMRDeinterlaceControl9,
            lpdw_deinterlace_prefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlacePrefs: *const fn (
            self: *const IVMRDeinterlaceControl9,
            dw_deinterlace_prefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDeinterlaceMode: *const fn (
            self: *const IVMRDeinterlaceControl9,
            dw_stream_i_d: u32,
            lp_deinterlace_mode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumberOfDeinterlaceModes(self: *const T, lp_video_description_: ?*VMR9VideoDesc, lpdw_num_deinterlace_modes_: ?*u32, lp_deinterlace_modes_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetNumberOfDeinterlaceModes(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lp_video_description_, lpdw_num_deinterlace_modes_, lp_deinterlace_modes_);
            }
            pub inline fn getDeinterlaceModeCaps(self: *const T, lp_deinterlace_mode_: ?*Guid, lp_video_description_: ?*VMR9VideoDesc, lp_deinterlace_caps_: ?*VMR9DeinterlaceCaps) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlaceModeCaps(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lp_deinterlace_mode_, lp_video_description_, lp_deinterlace_caps_);
            }
            pub inline fn getDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
            pub inline fn setDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
            pub inline fn getDeinterlacePrefs(self: *const T, lpdw_deinterlace_prefs_: ?*u32) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lpdw_deinterlace_prefs_);
            }
            pub inline fn setDeinterlacePrefs(self: *const T, dw_deinterlace_prefs_: u32) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).SetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dw_deinterlace_prefs_);
            }
            pub inline fn getActualDeinterlaceMode(self: *const T, dw_stream_i_d_: u32, lp_deinterlace_mode_: ?*Guid) HRESULT {
                return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetActualDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dw_stream_i_d_, lp_deinterlace_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9VideoStreamInfo = extern struct {
    pddsVideoSurface: ?*IDirect3DSurface9,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    rNormal: VMR9NormalizedRect,
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: VMR9_SampleFormat,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor9_Value = Guid.initString("4a5c89eb-df51-4654-ac2a-e48e02bbabf6");
pub const IID_IVMRImageCompositor9 = &IID_IVMRImageCompositor9_Value;
pub const IVMRImageCompositor9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionDevice: *const fn (
            self: *const IVMRImageCompositor9,
            p_d3_d_device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TermCompositionDevice: *const fn (
            self: *const IVMRImageCompositor9,
            p_d3_d_device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamMediaType: *const fn (
            self: *const IVMRImageCompositor9,
            dw_strm_i_d: u32,
            pmt: ?*AM_MEDIA_TYPE,
            f_texture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompositeImage: *const fn (
            self: *const IVMRImageCompositor9,
            p_d3_d_device: ?*IUnknown,
            pdds_render_target: ?*IDirect3DSurface9,
            pmt_render_target: ?*AM_MEDIA_TYPE,
            rt_start: i64,
            rt_end: i64,
            dw_clr_bk_gnd: u32,
            p_video_stream_info: ?*VMR9VideoStreamInfo,
            c_streams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initCompositionDevice(self: *const T, p_d3_d_device_: ?*IUnknown) HRESULT {
                return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).InitCompositionDevice(@as(*const IVMRImageCompositor9, @ptrCast(self)), p_d3_d_device_);
            }
            pub inline fn termCompositionDevice(self: *const T, p_d3_d_device_: ?*IUnknown) HRESULT {
                return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).TermCompositionDevice(@as(*const IVMRImageCompositor9, @ptrCast(self)), p_d3_d_device_);
            }
            pub inline fn setStreamMediaType(self: *const T, dw_strm_i_d_: u32, pmt_: ?*AM_MEDIA_TYPE, f_texture_: BOOL) HRESULT {
                return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).SetStreamMediaType(@as(*const IVMRImageCompositor9, @ptrCast(self)), dw_strm_i_d_, pmt_, f_texture_);
            }
            pub inline fn compositeImage(self: *const T, p_d3_d_device_: ?*IUnknown, pdds_render_target_: ?*IDirect3DSurface9, pmt_render_target_: ?*AM_MEDIA_TYPE, rt_start_: i64, rt_end_: i64, dw_clr_bk_gnd_: u32, p_video_stream_info_: ?*VMR9VideoStreamInfo, c_streams_: u32) HRESULT {
                return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).CompositeImage(@as(*const IVMRImageCompositor9, @ptrCast(self)), p_d3_d_device_, pdds_render_target_, pmt_render_target_, rt_start_, rt_end_, dw_clr_bk_gnd_, p_video_stream_info_, c_streams_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectInfo: *const fn (
            self: *const IVPBaseConfig,
            pdw_num_connect_info: ?*u32,
            pdd_v_p_connect_info: ?[*]DDVIDEOPORTCONNECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConnectInfo: *const fn (
            self: *const IVPBaseConfig,
            dw_chosen_entry: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVPDataInfo: *const fn (
            self: *const IVPBaseConfig,
            pamvp_data_info: ?*AMVPDATAINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxPixelRate: *const fn (
            self: *const IVPBaseConfig,
            pamvp_size: ?*AMVPSIZE,
            pdw_max_pixels_per_second: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InformVPInputFormats: *const fn (
            self: *const IVPBaseConfig,
            dw_num_formats: u32,
            p_d_d_pixel_formats: ?*DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoFormats: *const fn (
            self: *const IVPBaseConfig,
            pdw_num_formats: ?*u32,
            pdd_pixel_formats: ?[*]DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoFormat: *const fn (
            self: *const IVPBaseConfig,
            dw_chosen_entry: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInvertPolarity: *const fn (
            self: *const IVPBaseConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlaySurface: *const fn (
            self: *const IVPBaseConfig,
            ppdd_overlay_surface: ?*?*IDirectDrawSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDrawKernelHandle: *const fn (
            self: *const IVPBaseConfig,
            dw_d_d_kernel_handle: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPortID: *const fn (
            self: *const IVPBaseConfig,
            dw_video_port_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDSurfaceKernelHandles: *const fn (
            self: *const IVPBaseConfig,
            c_handles: u32,
            rg_d_d_kernel_handles: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSurfaceParameters: *const fn (
            self: *const IVPBaseConfig,
            dw_pitch: u32,
            dw_x_origin: u32,
            dw_y_origin: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getConnectInfo(self: *const T, pdw_num_connect_info_: ?*u32, pdd_v_p_connect_info_: ?[*]DDVIDEOPORTCONNECT) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetConnectInfo(@as(*const IVPBaseConfig, @ptrCast(self)), pdw_num_connect_info_, pdd_v_p_connect_info_);
            }
            pub inline fn setConnectInfo(self: *const T, dw_chosen_entry_: u32) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetConnectInfo(@as(*const IVPBaseConfig, @ptrCast(self)), dw_chosen_entry_);
            }
            pub inline fn getVPDataInfo(self: *const T, pamvp_data_info_: ?*AMVPDATAINFO) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetVPDataInfo(@as(*const IVPBaseConfig, @ptrCast(self)), pamvp_data_info_);
            }
            pub inline fn getMaxPixelRate(self: *const T, pamvp_size_: ?*AMVPSIZE, pdw_max_pixels_per_second_: ?*u32) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetMaxPixelRate(@as(*const IVPBaseConfig, @ptrCast(self)), pamvp_size_, pdw_max_pixels_per_second_);
            }
            pub inline fn informVPInputFormats(self: *const T, dw_num_formats_: u32, p_d_d_pixel_formats_: ?*DDPIXELFORMAT) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).InformVPInputFormats(@as(*const IVPBaseConfig, @ptrCast(self)), dw_num_formats_, p_d_d_pixel_formats_);
            }
            pub inline fn getVideoFormats(self: *const T, pdw_num_formats_: ?*u32, pdd_pixel_formats_: ?[*]DDPIXELFORMAT) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetVideoFormats(@as(*const IVPBaseConfig, @ptrCast(self)), pdw_num_formats_, pdd_pixel_formats_);
            }
            pub inline fn setVideoFormat(self: *const T, dw_chosen_entry_: u32) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetVideoFormat(@as(*const IVPBaseConfig, @ptrCast(self)), dw_chosen_entry_);
            }
            pub inline fn setInvertPolarity(self: *const T) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetInvertPolarity(@as(*const IVPBaseConfig, @ptrCast(self)));
            }
            pub inline fn getOverlaySurface(self: *const T, ppdd_overlay_surface_: ?*?*IDirectDrawSurface) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetOverlaySurface(@as(*const IVPBaseConfig, @ptrCast(self)), ppdd_overlay_surface_);
            }
            pub inline fn setDirectDrawKernelHandle(self: *const T, dw_d_d_kernel_handle_: usize) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetDirectDrawKernelHandle(@as(*const IVPBaseConfig, @ptrCast(self)), dw_d_d_kernel_handle_);
            }
            pub inline fn setVideoPortID(self: *const T, dw_video_port_i_d_: u32) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetVideoPortID(@as(*const IVPBaseConfig, @ptrCast(self)), dw_video_port_i_d_);
            }
            pub inline fn setDDSurfaceKernelHandles(self: *const T, c_handles_: u32, rg_d_d_kernel_handles_: ?*usize) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetDDSurfaceKernelHandles(@as(*const IVPBaseConfig, @ptrCast(self)), c_handles_, rg_d_d_kernel_handles_);
            }
            pub inline fn setSurfaceParameters(self: *const T, dw_pitch_: u32, dw_x_origin_: u32, dw_y_origin_: u32) HRESULT {
                return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetSurfaceParameters(@as(*const IVPBaseConfig, @ptrCast(self)), dw_pitch_, dw_x_origin_, dw_y_origin_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
        IsVPDecimationAllowed: *const fn (
            self: *const IVPConfig,
            pb_is_decimation_allowed: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScalingFactors: *const fn (
            self: *const IVPConfig,
            pamvp_size: ?*AMVPSIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVPBaseConfig.MethodMixin(T);
            pub inline fn isVPDecimationAllowed(self: *const T, pb_is_decimation_allowed_: ?*i32) HRESULT {
                return @as(*const IVPConfig.VTable, @ptrCast(self.vtable)).IsVPDecimationAllowed(@as(*const IVPConfig, @ptrCast(self)), pb_is_decimation_allowed_);
            }
            pub inline fn setScalingFactors(self: *const T, pamvp_size_: ?*AMVPSIZE) HRESULT {
                return @as(*const IVPConfig.VTable, @ptrCast(self.vtable)).SetScalingFactors(@as(*const IVPConfig, @ptrCast(self)), pamvp_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IVPVBIConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVPBaseConfig.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenegotiateVPParameters: *const fn (
            self: *const IVPBaseNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn renegotiateVPParameters(self: *const T) HRESULT {
                return @as(*const IVPBaseNotify.VTable, @ptrCast(self.vtable)).RenegotiateVPParameters(@as(*const IVPBaseNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPNotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
        SetDeinterlaceMode: *const fn (
            self: *const IVPNotify,
            mode: AMVP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: *const fn (
            self: *const IVPNotify,
            p_mode: ?*AMVP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVPBaseNotify.MethodMixin(T);
            pub inline fn setDeinterlaceMode(self: *const T, mode_: AMVP_MODE) HRESULT {
                return @as(*const IVPNotify.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVPNotify, @ptrCast(self)), mode_);
            }
            pub inline fn getDeinterlaceMode(self: *const T, p_mode_: ?*AMVP_MODE) HRESULT {
                return @as(*const IVPNotify.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVPNotify, @ptrCast(self)), p_mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IVPNotify.VTable,
        SetVPSyncMaster: *const fn (
            self: *const IVPNotify2,
            b_v_p_sync_master: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVPSyncMaster: *const fn (
            self: *const IVPNotify2,
            pb_v_p_sync_master: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVPNotify.MethodMixin(T);
            pub inline fn setVPSyncMaster(self: *const T, b_v_p_sync_master_: BOOL) HRESULT {
                return @as(*const IVPNotify2.VTable, @ptrCast(self.vtable)).SetVPSyncMaster(@as(*const IVPNotify2, @ptrCast(self)), b_v_p_sync_master_);
            }
            pub inline fn getVPSyncMaster(self: *const T, pb_v_p_sync_master_: ?*BOOL) HRESULT {
                return @as(*const IVPNotify2.VTable, @ptrCast(self.vtable)).GetVPSyncMaster(@as(*const IVPNotify2, @ptrCast(self)), pb_v_p_sync_master_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IVPVBINotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IVPBaseNotify.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RIFFCHUNK = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
};

pub const RIFFLIST = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    fccListType: u32 align(2),
};

pub const AVIMAINHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    dwMicroSecPerFrame: u32 align(2),
    dwMaxBytesPerSec: u32 align(2),
    dwPaddingGranularity: u32 align(2),
    dwFlags: u32 align(2),
    dwTotalFrames: u32 align(2),
    dwInitialFrames: u32 align(2),
    dwStreams: u32 align(2),
    dwSuggestedBufferSize: u32 align(2),
    dwWidth: u32 align(2),
    dwHeight: u32 align(2),
    dwReserved: [4]u32 align(2),
};

pub const AVIEXTHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    dwGrandFrames: u32 align(2),
    dwFuture: [61]u32 align(2),
};

pub const AVISTREAMHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    fccType: u32 align(2),
    fccHandler: u32 align(2),
    dwFlags: u32 align(2),
    wPriority: u16 align(2),
    wLanguage: u16 align(2),
    dwInitialFrames: u32 align(2),
    dwScale: u32 align(2),
    dwRate: u32 align(2),
    dwStart: u32 align(2),
    dwLength: u32 align(2),
    dwSuggestedBufferSize: u32 align(2),
    dwQuality: u32 align(2),
    dwSampleSize: u32 align(2),
    rcFrame: extern struct {
        left: i16,
        top: i16,
        right: i16,
        bottom: i16,
    } align(2),
};

pub const AVIOLDINDEX = extern struct {
    pub const _avioldindex_entry = extern struct {
        dwChunkId: u32 align(2),
        dwFlags: u32 align(2),
        dwOffset: u32 align(2),
        dwSize: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    aIndex: [1]_avioldindex_entry align(2),
};

pub const TIMECODEDATA = extern struct {
    time: TIMECODE align(2),
    dwSMPTEflags: u32 align(2),
    dwUser: u32 align(2),
};

pub const AVIMETAINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    adwIndex: [1]u32 align(2),
};

pub const AVISUPERINDEX = extern struct {
    pub const _avisuperindex_entry = extern struct {
        qwOffset: u64 align(2),
        dwSize: u32 align(2),
        dwDuration: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [1022]_avisuperindex_entry align(2),
};

pub const AVISTDINDEX_ENTRY = extern struct {
    dwOffset: u32 align(2),
    dwSize: u32 align(2),
};

pub const AVISTDINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved_3: u32 align(2),
    aIndex: [2044]AVISTDINDEX_ENTRY align(2),
};

pub const AVITIMEDINDEX_ENTRY = extern struct {
    dwOffset: u32 align(2),
    dwSize: u32 align(2),
    dwDuration: u32 align(2),
};

pub const _avitimedindex = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved_3: u32 align(2),
    aIndex: [1362]AVITIMEDINDEX_ENTRY align(2),
    adwTrailingFill: [2734]u32 align(2),
};

pub const AVITIMECODEINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [1022]TIMECODEDATA align(2),
};

pub const AVITCDLINDEX_ENTRY = extern struct {
    dwTick: u32 align(2),
    time: TIMECODE align(2),
    dwSMPTEflags: u32 align(2),
    dwUser: u32 align(2),
    szReelId: [12]i8 align(2),
};

pub const _avitcdlindex = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [584]AVITCDLINDEX_ENTRY align(2),
    adwTrailingFill: [3512]u32 align(2),
};

pub const AVIFIELDINDEX = extern struct {
    pub const _avifieldindex_entry = extern struct {
        dwOffset: u32 align(2),
        dwSize: u32 align(2),
        dwOffsetField2: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved3: u32 align(2),
    aIndex: [1]_avifieldindex_entry align(2),
};

pub const MainAVIHeader = extern struct {
    dwMicroSecPerFrame: u32,
    dwMaxBytesPerSec: u32,
    dwPaddingGranularity: u32,
    dwFlags: u32,
    dwTotalFrames: u32,
    dwInitialFrames: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwReserved: [4]u32,
};

pub const AVIStreamHeader = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    wPriority: u16,
    wLanguage: u16,
    dwInitialFrames: u32,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
};

pub const AVIINDEXENTRY = extern struct {
    ckid: u32,
    dwFlags: u32,
    dwChunkOffset: u32,
    dwChunkLength: u32,
};

pub const AVIPALCHANGE = extern struct {
    bFirstEntry: u8,
    bNumEntries: u8,
    wFlags: u16,
    peNew: [1]PALETTEENTRY,
};

pub const AM_PROPERTY_AC3 = enum(i32) {
    ERROR_CONCEALMENT = 1,
    ALTERNATE_AUDIO = 2,
    DOWNMIX = 3,
    BIT_STREAM_MODE = 4,
    DIALOGUE_LEVEL = 5,
    LANGUAGE_CODE = 6,
    ROOM_TYPE = 7,
};
pub const AM_PROPERTY_AC3_ERROR_CONCEALMENT = AM_PROPERTY_AC3.ERROR_CONCEALMENT;
pub const AM_PROPERTY_AC3_ALTERNATE_AUDIO = AM_PROPERTY_AC3.ALTERNATE_AUDIO;
pub const AM_PROPERTY_AC3_DOWNMIX = AM_PROPERTY_AC3.DOWNMIX;
pub const AM_PROPERTY_AC3_BIT_STREAM_MODE = AM_PROPERTY_AC3.BIT_STREAM_MODE;
pub const AM_PROPERTY_AC3_DIALOGUE_LEVEL = AM_PROPERTY_AC3.DIALOGUE_LEVEL;
pub const AM_PROPERTY_AC3_LANGUAGE_CODE = AM_PROPERTY_AC3.LANGUAGE_CODE;
pub const AM_PROPERTY_AC3_ROOM_TYPE = AM_PROPERTY_AC3.ROOM_TYPE;

pub const AM_AC3_ERROR_CONCEALMENT = extern struct {
    fRepeatPreviousBlock: BOOL,
    fErrorInCurrentBlock: BOOL,
};

pub const AM_AC3_ALTERNATE_AUDIO = extern struct {
    fStereo: BOOL,
    DualMode: u32,
};

pub const AM_AC3_DOWNMIX = extern struct {
    fDownMix: BOOL,
    fDolbySurround: BOOL,
};

pub const AM_AC3_BIT_STREAM_MODE = extern struct {
    BitStreamMode: i32,
};

pub const AM_AC3_DIALOGUE_LEVEL = extern struct {
    DialogueLevel: u32,
};

pub const AM_AC3_ROOM_TYPE = extern struct {
    fLargeRoom: BOOL,
};

pub const AM_PROPERTY_DVDSUBPIC = enum(i32) {
    PALETTE = 0,
    HLI = 1,
    COMPOSIT_ON = 2,
};
pub const AM_PROPERTY_DVDSUBPIC_PALETTE = AM_PROPERTY_DVDSUBPIC.PALETTE;
pub const AM_PROPERTY_DVDSUBPIC_HLI = AM_PROPERTY_DVDSUBPIC.HLI;
pub const AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = AM_PROPERTY_DVDSUBPIC.COMPOSIT_ON;

pub const AM_DVD_YUV = extern struct {
    Reserved: u8,
    Y: u8,
    U: u8,
    V: u8,
};

pub const AM_PROPERTY_SPPAL = extern struct {
    sppal: [16]AM_DVD_YUV,
};

pub const AM_COLCON = extern struct {
    _bitfield1: u8,
    _bitfield2: u8,
    _bitfield3: u8,
    _bitfield4: u8,
};

pub const AM_PROPERTY_SPHLI = extern struct {
    HLISS: u16,
    Reserved: u16,
    StartPTM: u32,
    EndPTM: u32,
    StartX: u16,
    StartY: u16,
    StopX: u16,
    StopY: u16,
    ColCon: AM_COLCON,
};

pub const AM_PROPERTY_DVDCOPYPROT = enum(i32) {
    DVDCOPY_CHLG_KEY = 1,
    DVDCOPY_DVD_KEY1 = 2,
    DVDCOPY_DEC_KEY2 = 3,
    DVDCOPY_TITLE_KEY = 4,
    COPY_MACROVISION = 5,
    DVDCOPY_REGION = 6,
    DVDCOPY_SET_COPY_STATE = 7,
    COPY_ANALOG_COMPONENT = 8,
    COPY_DIGITAL_CP = 9,
    COPY_DVD_SRM = 10,
    DVDCOPY_SUPPORTS_NEW_KEYCOUNT = 11,
    DVDCOPY_DISC_KEY = 128,
};
pub const AM_PROPERTY_DVDCOPY_CHLG_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_CHLG_KEY;
pub const AM_PROPERTY_DVDCOPY_DVD_KEY1 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DVD_KEY1;
pub const AM_PROPERTY_DVDCOPY_DEC_KEY2 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DEC_KEY2;
pub const AM_PROPERTY_DVDCOPY_TITLE_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_TITLE_KEY;
pub const AM_PROPERTY_COPY_MACROVISION = AM_PROPERTY_DVDCOPYPROT.COPY_MACROVISION;
pub const AM_PROPERTY_DVDCOPY_REGION = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_REGION;
pub const AM_PROPERTY_DVDCOPY_SET_COPY_STATE = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SET_COPY_STATE;
pub const AM_PROPERTY_COPY_ANALOG_COMPONENT = AM_PROPERTY_DVDCOPYPROT.COPY_ANALOG_COMPONENT;
pub const AM_PROPERTY_COPY_DIGITAL_CP = AM_PROPERTY_DVDCOPYPROT.COPY_DIGITAL_CP;
pub const AM_PROPERTY_COPY_DVD_SRM = AM_PROPERTY_DVDCOPYPROT.COPY_DVD_SRM;
pub const AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SUPPORTS_NEW_KEYCOUNT;
pub const AM_PROPERTY_DVDCOPY_DISC_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DISC_KEY;

pub const AM_DIGITAL_CP = enum(i32) {
    OFF = 0,
    ON = 1,
    DVD_COMPLIANT = 2,
};
pub const AM_DIGITAL_CP_OFF = AM_DIGITAL_CP.OFF;
pub const AM_DIGITAL_CP_ON = AM_DIGITAL_CP.ON;
pub const AM_DIGITAL_CP_DVD_COMPLIANT = AM_DIGITAL_CP.DVD_COMPLIANT;

pub const AM_DVDCOPY_CHLGKEY = extern struct {
    ChlgKey: [10]u8,
    Reserved: [2]u8,
};

pub const AM_DVDCOPY_BUSKEY = extern struct {
    BusKey: [5]u8,
    Reserved: [1]u8,
};

pub const AM_DVDCOPY_DISCKEY = extern struct {
    DiscKey: [2048]u8,
};

pub const AM_DVDCOPY_TITLEKEY = extern struct {
    KeyFlags: u32,
    Reserved1: [2]u32,
    TitleKey: [6]u8,
    Reserved2: [2]u8,
};

pub const AM_COPY_MACROVISION = extern struct {
    MACROVISIONLevel: u32,
};

pub const AM_DVDCOPY_SET_COPY_STATE = extern struct {
    DVDCopyState: u32,
};

pub const AM_DVDCOPYSTATE = enum(i32) {
    INITIALIZE = 0,
    INITIALIZE_TITLE = 1,
    AUTHENTICATION_NOT_REQUIRED = 2,
    AUTHENTICATION_REQUIRED = 3,
    DONE = 4,
};
pub const AM_DVDCOPYSTATE_INITIALIZE = AM_DVDCOPYSTATE.INITIALIZE;
pub const AM_DVDCOPYSTATE_INITIALIZE_TITLE = AM_DVDCOPYSTATE.INITIALIZE_TITLE;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_NOT_REQUIRED;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_REQUIRED;
pub const AM_DVDCOPYSTATE_DONE = AM_DVDCOPYSTATE.DONE;

pub const AM_COPY_MACROVISION_LEVEL = enum(i32) {
    DISABLED = 0,
    LEVEL1 = 1,
    LEVEL2 = 2,
    LEVEL3 = 3,
};
pub const AM_MACROVISION_DISABLED = AM_COPY_MACROVISION_LEVEL.DISABLED;
pub const AM_MACROVISION_LEVEL1 = AM_COPY_MACROVISION_LEVEL.LEVEL1;
pub const AM_MACROVISION_LEVEL2 = AM_COPY_MACROVISION_LEVEL.LEVEL2;
pub const AM_MACROVISION_LEVEL3 = AM_COPY_MACROVISION_LEVEL.LEVEL3;

pub const DVD_REGION = extern struct {
    CopySystem: u8,
    RegionData: u8,
    SystemRegion: u8,
    ResetCount: u8,
};

pub const AM_MPEG2Level = enum(i32) {
    Low = 1,
    Main = 2,
    High1440 = 3,
    High = 4,
};
pub const AM_MPEG2Level_Low = AM_MPEG2Level.Low;
pub const AM_MPEG2Level_Main = AM_MPEG2Level.Main;
pub const AM_MPEG2Level_High1440 = AM_MPEG2Level.High1440;
pub const AM_MPEG2Level_High = AM_MPEG2Level.High;

pub const AM_MPEG2Profile = enum(i32) {
    Simple = 1,
    Main = 2,
    SNRScalable = 3,
    SpatiallyScalable = 4,
    High = 5,
};
pub const AM_MPEG2Profile_Simple = AM_MPEG2Profile.Simple;
pub const AM_MPEG2Profile_Main = AM_MPEG2Profile.Main;
pub const AM_MPEG2Profile_SNRScalable = AM_MPEG2Profile.SNRScalable;
pub const AM_MPEG2Profile_SpatiallyScalable = AM_MPEG2Profile.SpatiallyScalable;
pub const AM_MPEG2Profile_High = AM_MPEG2Profile.High;

pub const VIDEOINFOHEADER2 = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    dwInterlaceFlags: u32,
    dwCopyProtectFlags: u32,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    Anonymous: extern union {
        dwControlFlags: u32,
        dwReserved1: u32,
    },
    dwReserved2: u32,
    bmiHeader: BITMAPINFOHEADER,
};

pub const MPEG2VIDEOINFO = extern struct {
    hdr: VIDEOINFOHEADER2,
    dwStartTimeCode: u32,
    cbSequenceHeader: u32,
    dwProfile: u32,
    dwLevel: u32,
    dwFlags: MPEG2VIDEOINFO_FLAGS,
    dwSequenceHeader: [1]u32,
};

pub const AM_DvdKaraokeData = extern struct {
    dwDownmix: u32,
    dwSpeakerAssignment: u32,
};

pub const AM_PROPERTY_DVDKARAOKE = enum(i32) {
    ENABLE = 0,
    DATA = 1,
};
pub const AM_PROPERTY_DVDKARAOKE_ENABLE = AM_PROPERTY_DVDKARAOKE.ENABLE;
pub const AM_PROPERTY_DVDKARAOKE_DATA = AM_PROPERTY_DVDKARAOKE.DATA;

pub const AM_PROPERTY_TS_RATE_CHANGE = enum(i32) {
    SimpleRateChange = 1,
    ExactRateChange = 2,
    MaxFullDataRate = 3,
    Step = 4,
    UseRateVersion = 5,
    QueryFullFrameRate = 6,
    QueryLastRateSegPTS = 7,
    CorrectTS = 8,
    ReverseMaxFullDataRate = 9,
    ResetOnTimeDisc = 10,
    QueryMapping = 11,
};
pub const AM_RATE_SimpleRateChange = AM_PROPERTY_TS_RATE_CHANGE.SimpleRateChange;
pub const AM_RATE_ExactRateChange = AM_PROPERTY_TS_RATE_CHANGE.ExactRateChange;
pub const AM_RATE_MaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.MaxFullDataRate;
pub const AM_RATE_Step = AM_PROPERTY_TS_RATE_CHANGE.Step;
pub const AM_RATE_UseRateVersion = AM_PROPERTY_TS_RATE_CHANGE.UseRateVersion;
pub const AM_RATE_QueryFullFrameRate = AM_PROPERTY_TS_RATE_CHANGE.QueryFullFrameRate;
pub const AM_RATE_QueryLastRateSegPTS = AM_PROPERTY_TS_RATE_CHANGE.QueryLastRateSegPTS;
pub const AM_RATE_CorrectTS = AM_PROPERTY_TS_RATE_CHANGE.CorrectTS;
pub const AM_RATE_ReverseMaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.ReverseMaxFullDataRate;
pub const AM_RATE_ResetOnTimeDisc = AM_PROPERTY_TS_RATE_CHANGE.ResetOnTimeDisc;
pub const AM_RATE_QueryMapping = AM_PROPERTY_TS_RATE_CHANGE.QueryMapping;

pub const AM_PROPERTY_DVD_RATE_CHANGE = enum(i32) {
    ChangeRate = 1,
    FullDataRateMax = 2,
    ReverseDecode = 3,
    DecoderPosition = 4,
    DecoderVersion = 5,
};
pub const AM_RATE_ChangeRate = AM_PROPERTY_DVD_RATE_CHANGE.ChangeRate;
pub const AM_RATE_FullDataRateMax = AM_PROPERTY_DVD_RATE_CHANGE.FullDataRateMax;
pub const AM_RATE_ReverseDecode = AM_PROPERTY_DVD_RATE_CHANGE.ReverseDecode;
pub const AM_RATE_DecoderPosition = AM_PROPERTY_DVD_RATE_CHANGE.DecoderPosition;
pub const AM_RATE_DecoderVersion = AM_PROPERTY_DVD_RATE_CHANGE.DecoderVersion;

pub const AM_SimpleRateChange = extern struct {
    StartTime: i64,
    Rate: i32,
};

pub const AM_QueryRate = extern struct {
    lMaxForwardFullFrame: i32,
    lMaxReverseFullFrame: i32,
};

pub const AM_ExactRateChange = extern struct {
    OutputZeroTime: i64,
    Rate: i32,
};

pub const AM_DVD_ChangeRate = extern struct {
    StartInTime: i64,
    StartOutTime: i64,
    Rate: i32,
};

pub const DVD_PLAY_DIRECTION = enum(i32) {
    FORWARD = 0,
    BACKWARD = 1,
};
pub const DVD_DIR_FORWARD = DVD_PLAY_DIRECTION.FORWARD;
pub const DVD_DIR_BACKWARD = DVD_PLAY_DIRECTION.BACKWARD;

pub const DVD_ERROR = enum(i32) {
    Unexpected = 1,
    CopyProtectFail = 2,
    InvalidDVD1_0Disc = 3,
    InvalidDiscRegion = 4,
    LowParentalLevel = 5,
    MacrovisionFail = 6,
    IncompatibleSystemAndDecoderRegions = 7,
    IncompatibleDiscAndDecoderRegions = 8,
    CopyProtectOutputFail = 9,
    CopyProtectOutputNotSupported = 10,
};
pub const DVD_ERROR_Unexpected = DVD_ERROR.Unexpected;
pub const DVD_ERROR_CopyProtectFail = DVD_ERROR.CopyProtectFail;
pub const DVD_ERROR_InvalidDVD1_0Disc = DVD_ERROR.InvalidDVD1_0Disc;
pub const DVD_ERROR_InvalidDiscRegion = DVD_ERROR.InvalidDiscRegion;
pub const DVD_ERROR_LowParentalLevel = DVD_ERROR.LowParentalLevel;
pub const DVD_ERROR_MacrovisionFail = DVD_ERROR.MacrovisionFail;
pub const DVD_ERROR_IncompatibleSystemAndDecoderRegions = DVD_ERROR.IncompatibleSystemAndDecoderRegions;
pub const DVD_ERROR_IncompatibleDiscAndDecoderRegions = DVD_ERROR.IncompatibleDiscAndDecoderRegions;
pub const DVD_ERROR_CopyProtectOutputFail = DVD_ERROR.CopyProtectOutputFail;
pub const DVD_ERROR_CopyProtectOutputNotSupported = DVD_ERROR.CopyProtectOutputNotSupported;

pub const DVD_WARNING = enum(i32) {
    InvalidDVD1_0Disc = 1,
    FormatNotSupported = 2,
    IllegalNavCommand = 3,
    Open = 4,
    Seek = 5,
    Read = 6,
};
pub const DVD_WARNING_InvalidDVD1_0Disc = DVD_WARNING.InvalidDVD1_0Disc;
pub const DVD_WARNING_FormatNotSupported = DVD_WARNING.FormatNotSupported;
pub const DVD_WARNING_IllegalNavCommand = DVD_WARNING.IllegalNavCommand;
pub const DVD_WARNING_Open = DVD_WARNING.Open;
pub const DVD_WARNING_Seek = DVD_WARNING.Seek;
pub const DVD_WARNING_Read = DVD_WARNING.Read;

pub const DVD_PB_STOPPED = enum(i32) {
    Other = 0,
    NoBranch = 1,
    NoFirstPlayDomain = 2,
    StopCommand = 3,
    Reset = 4,
    DiscEjected = 5,
    IllegalNavCommand = 6,
    PlayPeriodAutoStop = 7,
    PlayChapterAutoStop = 8,
    ParentalFailure = 9,
    RegionFailure = 10,
    MacrovisionFailure = 11,
    DiscReadError = 12,
    CopyProtectFailure = 13,
    CopyProtectOutputFailure = 14,
    CopyProtectOutputNotSupported = 15,
};
pub const DVD_PB_STOPPED_Other = DVD_PB_STOPPED.Other;
pub const DVD_PB_STOPPED_NoBranch = DVD_PB_STOPPED.NoBranch;
pub const DVD_PB_STOPPED_NoFirstPlayDomain = DVD_PB_STOPPED.NoFirstPlayDomain;
pub const DVD_PB_STOPPED_StopCommand = DVD_PB_STOPPED.StopCommand;
pub const DVD_PB_STOPPED_Reset = DVD_PB_STOPPED.Reset;
pub const DVD_PB_STOPPED_DiscEjected = DVD_PB_STOPPED.DiscEjected;
pub const DVD_PB_STOPPED_IllegalNavCommand = DVD_PB_STOPPED.IllegalNavCommand;
pub const DVD_PB_STOPPED_PlayPeriodAutoStop = DVD_PB_STOPPED.PlayPeriodAutoStop;
pub const DVD_PB_STOPPED_PlayChapterAutoStop = DVD_PB_STOPPED.PlayChapterAutoStop;
pub const DVD_PB_STOPPED_ParentalFailure = DVD_PB_STOPPED.ParentalFailure;
pub const DVD_PB_STOPPED_RegionFailure = DVD_PB_STOPPED.RegionFailure;
pub const DVD_PB_STOPPED_MacrovisionFailure = DVD_PB_STOPPED.MacrovisionFailure;
pub const DVD_PB_STOPPED_DiscReadError = DVD_PB_STOPPED.DiscReadError;
pub const DVD_PB_STOPPED_CopyProtectFailure = DVD_PB_STOPPED.CopyProtectFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputFailure = DVD_PB_STOPPED.CopyProtectOutputFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputNotSupported = DVD_PB_STOPPED.CopyProtectOutputNotSupported;

pub const AMGETERRORTEXTPROCA = *const fn (
    param0: HRESULT,
    param1: ?PSTR,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const AMGETERRORTEXTPROCW = *const fn (
    param0: HRESULT,
    param1: ?PWSTR,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SNDDEV_ERR = enum(i32) {
    Open = 1,
    Close = 2,
    GetCaps = 3,
    PrepareHeader = 4,
    UnprepareHeader = 5,
    Reset = 6,
    Restart = 7,
    GetPosition = 8,
    Write = 9,
    Pause = 10,
    Stop = 11,
    Start = 12,
    AddBuffer = 13,
    Query = 14,
};
pub const SNDDEV_ERROR_Open = SNDDEV_ERR.Open;
pub const SNDDEV_ERROR_Close = SNDDEV_ERR.Close;
pub const SNDDEV_ERROR_GetCaps = SNDDEV_ERR.GetCaps;
pub const SNDDEV_ERROR_PrepareHeader = SNDDEV_ERR.PrepareHeader;
pub const SNDDEV_ERROR_UnprepareHeader = SNDDEV_ERR.UnprepareHeader;
pub const SNDDEV_ERROR_Reset = SNDDEV_ERR.Reset;
pub const SNDDEV_ERROR_Restart = SNDDEV_ERR.Restart;
pub const SNDDEV_ERROR_GetPosition = SNDDEV_ERR.GetPosition;
pub const SNDDEV_ERROR_Write = SNDDEV_ERR.Write;
pub const SNDDEV_ERROR_Pause = SNDDEV_ERR.Pause;
pub const SNDDEV_ERROR_Stop = SNDDEV_ERR.Stop;
pub const SNDDEV_ERROR_Start = SNDDEV_ERR.Start;
pub const SNDDEV_ERROR_AddBuffer = SNDDEV_ERR.AddBuffer;
pub const SNDDEV_ERROR_Query = SNDDEV_ERR.Query;

pub const MP_TYPE = enum(i32) {
    INT = 0,
    FLOAT = 1,
    BOOL = 2,
    ENUM = 3,
    MAX = 4,
};
pub const MPT_INT = MP_TYPE.INT;
pub const MPT_FLOAT = MP_TYPE.FLOAT;
pub const MPT_BOOL = MP_TYPE.BOOL;
pub const MPT_ENUM = MP_TYPE.ENUM;
pub const MPT_MAX = MP_TYPE.MAX;

pub const MP_CURVE_TYPE = enum(i32) {
    JUMP = 1,
    LINEAR = 2,
    SQUARE = 4,
    INVSQUARE = 8,
    SINE = 16,
};
pub const MP_CURVE_JUMP = MP_CURVE_TYPE.JUMP;
pub const MP_CURVE_LINEAR = MP_CURVE_TYPE.LINEAR;
pub const MP_CURVE_SQUARE = MP_CURVE_TYPE.SQUARE;
pub const MP_CURVE_INVSQUARE = MP_CURVE_TYPE.INVSQUARE;
pub const MP_CURVE_SINE = MP_CURVE_TYPE.SINE;

pub const MP_PARAMINFO = extern struct {
    mpType: MP_TYPE,
    mopCaps: u32,
    mpdMinValue: f32,
    mpdMaxValue: f32,
    mpdNeutralValue: f32,
    szUnitText: [32]u16,
    szLabel: [32]u16,
};

pub const MP_ENVELOPE_SEGMENT = extern struct {
    rtStart: i64,
    rtEnd: i64,
    valStart: f32,
    valEnd: f32,
    iCurve: MP_CURVE_TYPE,
    flags: u32,
};

const IID_IMediaParamInfo_Value = Guid.initString("6d6cbb60-a223-44aa-842f-a2f06750be6d");
pub const IID_IMediaParamInfo = &IID_IMediaParamInfo_Value;
pub const IMediaParamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParamCount: *const fn (
            self: *const IMediaParamInfo,
            pdw_params: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamInfo: *const fn (
            self: *const IMediaParamInfo,
            dw_param_index: u32,
            p_info: ?*MP_PARAMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamText: *const fn (
            self: *const IMediaParamInfo,
            dw_param_index: u32,
            ppwch_text: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumTimeFormats: *const fn (
            self: *const IMediaParamInfo,
            pdw_num_time_formats: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedTimeFormat: *const fn (
            self: *const IMediaParamInfo,
            dw_format_index: u32,
            pguid_time_format: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeFormat: *const fn (
            self: *const IMediaParamInfo,
            pguid_time_format: ?*Guid,
            p_time_data: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getParamCount(self: *const T, pdw_params_: ?*u32) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamCount(@as(*const IMediaParamInfo, @ptrCast(self)), pdw_params_);
            }
            pub inline fn getParamInfo(self: *const T, dw_param_index_: u32, p_info_: ?*MP_PARAMINFO) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamInfo(@as(*const IMediaParamInfo, @ptrCast(self)), dw_param_index_, p_info_);
            }
            pub inline fn getParamText(self: *const T, dw_param_index_: u32, ppwch_text_: ?*?*u16) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamText(@as(*const IMediaParamInfo, @ptrCast(self)), dw_param_index_, ppwch_text_);
            }
            pub inline fn getNumTimeFormats(self: *const T, pdw_num_time_formats_: ?*u32) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetNumTimeFormats(@as(*const IMediaParamInfo, @ptrCast(self)), pdw_num_time_formats_);
            }
            pub inline fn getSupportedTimeFormat(self: *const T, dw_format_index_: u32, pguid_time_format_: ?*Guid) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetSupportedTimeFormat(@as(*const IMediaParamInfo, @ptrCast(self)), dw_format_index_, pguid_time_format_);
            }
            pub inline fn getCurrentTimeFormat(self: *const T, pguid_time_format_: ?*Guid, p_time_data_: ?*u32) HRESULT {
                return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetCurrentTimeFormat(@as(*const IMediaParamInfo, @ptrCast(self)), pguid_time_format_, p_time_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaParams_Value = Guid.initString("6d6cbb61-a223-44aa-842f-a2f06750be6e");
pub const IID_IMediaParams = &IID_IMediaParams_Value;
pub const IMediaParams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParam: *const fn (
            self: *const IMediaParams,
            dw_param_index: u32,
            p_value: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: *const fn (
            self: *const IMediaParams,
            dw_param_index: u32,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEnvelope: *const fn (
            self: *const IMediaParams,
            dw_param_index: u32,
            c_segments: u32,
            p_envelope_segments: ?*MP_ENVELOPE_SEGMENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushEnvelope: *const fn (
            self: *const IMediaParams,
            dw_param_index: u32,
            ref_time_start: i64,
            ref_time_end: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimeFormat: *const fn (
            self: *const IMediaParams,
            guid_time_format: Guid,
            mp_time_data: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getParam(self: *const T, dw_param_index_: u32, p_value_: ?*f32) HRESULT {
                return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).GetParam(@as(*const IMediaParams, @ptrCast(self)), dw_param_index_, p_value_);
            }
            pub inline fn setParam(self: *const T, dw_param_index_: u32, value_: f32) HRESULT {
                return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).SetParam(@as(*const IMediaParams, @ptrCast(self)), dw_param_index_, value_);
            }
            pub inline fn addEnvelope(self: *const T, dw_param_index_: u32, c_segments_: u32, p_envelope_segments_: ?*MP_ENVELOPE_SEGMENT) HRESULT {
                return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).AddEnvelope(@as(*const IMediaParams, @ptrCast(self)), dw_param_index_, c_segments_, p_envelope_segments_);
            }
            pub inline fn flushEnvelope(self: *const T, dw_param_index_: u32, ref_time_start_: i64, ref_time_end_: i64) HRESULT {
                return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).FlushEnvelope(@as(*const IMediaParams, @ptrCast(self)), dw_param_index_, ref_time_start_, ref_time_end_);
            }
            pub inline fn setTimeFormat(self: *const T, guid_time_format_: Guid, mp_time_data_: u32) HRESULT {
                return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).SetTimeFormat(@as(*const IMediaParams, @ptrCast(self)), guid_time_format_, mp_time_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VFW_FILTERLIST = extern struct {
    cFilters: u32,
    aClsId: [1]Guid,
};

pub const DXVA2_SampleFlags = enum(i32) {
    _Palette_Changed = 1,
    _SrcRect_Changed = 2,
    _DstRect_Changed = 4,
    _ColorData_Changed = 8,
    _PlanarAlpha_Changed = 16,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    sMask = -65505,
};
pub const DXVA2_SampleFlag_Palette_Changed = DXVA2_SampleFlags._Palette_Changed;
pub const DXVA2_SampleFlag_SrcRect_Changed = DXVA2_SampleFlags._SrcRect_Changed;
pub const DXVA2_SampleFlag_DstRect_Changed = DXVA2_SampleFlags._DstRect_Changed;
pub const DXVA2_SampleFlag_ColorData_Changed = DXVA2_SampleFlags._ColorData_Changed;
pub const DXVA2_SampleFlag_PlanarAlpha_Changed = DXVA2_SampleFlags._PlanarAlpha_Changed;
pub const DXVA2_SampleFlag_RFF = DXVA2_SampleFlags._RFF;
pub const DXVA2_SampleFlag_TFF = DXVA2_SampleFlags._TFF;
pub const DXVA2_SampleFlag_RFF_TFF_Present = DXVA2_SampleFlags._RFF_TFF_Present;
pub const DXVA2_SampleFlagsMask = DXVA2_SampleFlags.sMask;

pub const DXVA2_DestinationFlags = enum(i32) {
    _Background_Changed = 1,
    _TargetRect_Changed = 2,
    _ColorData_Changed = 4,
    _Alpha_Changed = 8,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    Mask = -65521,
};
pub const DXVA2_DestinationFlag_Background_Changed = DXVA2_DestinationFlags._Background_Changed;
pub const DXVA2_DestinationFlag_TargetRect_Changed = DXVA2_DestinationFlags._TargetRect_Changed;
pub const DXVA2_DestinationFlag_ColorData_Changed = DXVA2_DestinationFlags._ColorData_Changed;
pub const DXVA2_DestinationFlag_Alpha_Changed = DXVA2_DestinationFlags._Alpha_Changed;
pub const DXVA2_DestinationFlag_RFF = DXVA2_DestinationFlags._RFF;
pub const DXVA2_DestinationFlag_TFF = DXVA2_DestinationFlags._TFF;
pub const DXVA2_DestinationFlag_RFF_TFF_Present = DXVA2_DestinationFlags._RFF_TFF_Present;
pub const DXVA2_DestinationFlagMask = DXVA2_DestinationFlags.Mask;

pub const DXVA2_VIDEOSAMPLE = extern struct {
    Start: i64,
    End: i64,
    SampleFormat: DXVA2_ExtendedFormat,
    SampleFlags: u32,
    SrcResource: ?*anyopaque,
    SrcRect: RECT,
    DstRect: RECT,
    Pal: [16]DXVA2_AYUVSample8,
    PlanarAlpha: DXVA2_Fixed32,
};

pub const DXVA2_VIDEOPROCESSBLT = extern struct {
    TargetFrame: i64,
    TargetRect: RECT,
    ConstrictionSize: SIZE,
    StreamingFlags: u32,
    BackgroundColor: DXVA2_AYUVSample16,
    DestFormat: DXVA2_ExtendedFormat,
    DestFlags: u32,
    ProcAmpValues: DXVA2_ProcAmpValues,
    Alpha: DXVA2_Fixed32,
    NoiseFilterLuma: DXVA2_FilterValues,
    NoiseFilterChroma: DXVA2_FilterValues,
    DetailFilterLuma: DXVA2_FilterValues,
    DetailFilterChroma: DXVA2_FilterValues,
    pSrcSurfaces: ?*DXVA2_VIDEOSAMPLE,
    NumSrcSurfaces: u32,
};

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    p_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    count: u32,
    p_formats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORCAPS = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    p_caps: ?*DXVA2_VideoProcessorCaps,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    p_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    count: u32,
    p_formats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETPROCAMPRANGE = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    proc_amp_cap: u32,
    p_range: ?*DXVA2_ValueRange,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETFILTERPROPERTYRANGE = *const fn (
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    filter_setting: u32,
    p_range: ?*DXVA2_ValueRange,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_CREATEVIDEOPROCESSDEVICE = *const fn (
    p_d3_d_d9: ?*IDirect3DDevice9,
    p_video_desc: ?*const DXVA2_VideoDesc,
    render_target_format: D3DFORMAT,
    max_sub_streams: u32,
    ph_device: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_DESTROYVIDEOPROCESSDEVICE = *const fn (
    h_device: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSBEGINFRAME = *const fn (
    h_device: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSENDFRAME = *const fn (
    h_device: ?HANDLE,
    p_handle_complete: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSSETRENDERTARGET = *const fn (
    h_device: ?HANDLE,
    p_render_target: ?*IDirect3DSurface9,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSBLT = *const fn (
    h_device: ?HANDLE,
    p_blt: ?*const DXVA2_VIDEOPROCESSBLT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DXVA2SW_CALLBACKS = extern struct {
    Size: u32,
    GetVideoProcessorRenderTargetCount: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT,
    GetVideoProcessorRenderTargets: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS,
    GetVideoProcessorCaps: ?PDXVA2SW_GETVIDEOPROCESSORCAPS,
    GetVideoProcessorSubStreamFormatCount: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT,
    GetVideoProcessorSubStreamFormats: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS,
    GetProcAmpRange: ?PDXVA2SW_GETPROCAMPRANGE,
    GetFilterPropertyRange: ?PDXVA2SW_GETFILTERPROPERTYRANGE,
    CreateVideoProcessDevice: ?PDXVA2SW_CREATEVIDEOPROCESSDEVICE,
    DestroyVideoProcessDevice: ?PDXVA2SW_DESTROYVIDEOPROCESSDEVICE,
    VideoProcessBeginFrame: ?PDXVA2SW_VIDEOPROCESSBEGINFRAME,
    VideoProcessEndFrame: ?PDXVA2SW_VIDEOPROCESSENDFRAME,
    VideoProcessSetRenderTarget: ?PDXVA2SW_VIDEOPROCESSSETRENDERTARGET,
    VideoProcessBlt: ?PDXVA2SW_VIDEOPROCESSBLT,
};

pub const DXVA2Trace_DecodeDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevBeginFrameData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevGetBufferData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    BufferType: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    RTFourCC: u32,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2TraceVideoProcessBltData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    TargetFrameTime: u64,
    TargetRect: RECT,
    Enter: BOOL,
};

pub const AMPlayListItemFlags = enum(i32) {
    SKIP = 1,
    BIND = 2,
};
pub const AMPLAYLISTITEM_CANSKIP = AMPlayListItemFlags.SKIP;
pub const AMPLAYLISTITEM_CANBIND = AMPlayListItemFlags.BIND;

const IID_IAMPlayListItem_Value = Guid.initString("56a868ff-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayListItem = &IID_IAMPlayListItem_Value;
pub const IAMPlayListItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: *const fn (
            self: *const IAMPlayListItem,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceCount: *const fn (
            self: *const IAMPlayListItem,
            pdw_sources: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceURL: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            pbstr_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStart: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            prt_start: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceDuration: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            prt_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStartMarker: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            pdw_marker: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEndMarker: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            pdw_marker: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStartMarkerName: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            pbstr_start_marker: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEndMarkerName: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            pbstr_end_marker: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkURL: *const fn (
            self: *const IAMPlayListItem,
            pbstr_u_r_l: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScanDuration: *const fn (
            self: *const IAMPlayListItem,
            dw_source_index: u32,
            prt_scan_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFlags(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IAMPlayListItem, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn getSourceCount(self: *const T, pdw_sources_: ?*u32) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceCount(@as(*const IAMPlayListItem, @ptrCast(self)), pdw_sources_);
            }
            pub inline fn getSourceURL(self: *const T, dw_source_index_: u32, pbstr_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceURL(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, pbstr_u_r_l_);
            }
            pub inline fn getSourceStart(self: *const T, dw_source_index_: u32, prt_start_: ?*i64) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStart(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, prt_start_);
            }
            pub inline fn getSourceDuration(self: *const T, dw_source_index_: u32, prt_duration_: ?*i64) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceDuration(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, prt_duration_);
            }
            pub inline fn getSourceStartMarker(self: *const T, dw_source_index_: u32, pdw_marker_: ?*u32) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStartMarker(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, pdw_marker_);
            }
            pub inline fn getSourceEndMarker(self: *const T, dw_source_index_: u32, pdw_marker_: ?*u32) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceEndMarker(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, pdw_marker_);
            }
            pub inline fn getSourceStartMarkerName(self: *const T, dw_source_index_: u32, pbstr_start_marker_: ?*?BSTR) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStartMarkerName(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, pbstr_start_marker_);
            }
            pub inline fn getSourceEndMarkerName(self: *const T, dw_source_index_: u32, pbstr_end_marker_: ?*?BSTR) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceEndMarkerName(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, pbstr_end_marker_);
            }
            pub inline fn getLinkURL(self: *const T, pbstr_u_r_l_: ?*?BSTR) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetLinkURL(@as(*const IAMPlayListItem, @ptrCast(self)), pbstr_u_r_l_);
            }
            pub inline fn getScanDuration(self: *const T, dw_source_index_: u32, prt_scan_duration_: ?*i64) HRESULT {
                return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetScanDuration(@as(*const IAMPlayListItem, @ptrCast(self)), dw_source_index_, prt_scan_duration_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMPlayListFlags = enum(i32) {
    STARTINSCANMODE = 1,
    FORCEBANNER = 2,
};
pub const AMPLAYLIST_STARTINSCANMODE = AMPlayListFlags.STARTINSCANMODE;
pub const AMPLAYLIST_FORCEBANNER = AMPlayListFlags.FORCEBANNER;

pub const AMPlayListEventFlags = enum(i32) {
    RESUME = 0,
    BREAK = 1,
    NEXT = 2,
    MASK = 15,
    REFRESH = 16,
};
pub const AMPLAYLISTEVENT_RESUME = AMPlayListEventFlags.RESUME;
pub const AMPLAYLISTEVENT_BREAK = AMPlayListEventFlags.BREAK;
pub const AMPLAYLISTEVENT_NEXT = AMPlayListEventFlags.NEXT;
pub const AMPLAYLISTEVENT_MASK = AMPlayListEventFlags.MASK;
pub const AMPLAYLISTEVENT_REFRESH = AMPlayListEventFlags.REFRESH;

const IID_IAMPlayList_Value = Guid.initString("56a868fe-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayList = &IID_IAMPlayList_Value;
pub const IAMPlayList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: *const fn (
            self: *const IAMPlayList,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemCount: *const fn (
            self: *const IAMPlayList,
            pdw_items: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: *const fn (
            self: *const IAMPlayList,
            dw_item_index: u32,
            pp_item: ?*?*IAMPlayListItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedEvent: *const fn (
            self: *const IAMPlayList,
            pwsz_event_name: ?PWSTR,
            dw_item_index: u32,
            pp_item: ?*?*IAMPlayListItem,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRepeatInfo: *const fn (
            self: *const IAMPlayList,
            pdw_repeat_count: ?*u32,
            pdw_repeat_start: ?*u32,
            pdw_repeat_end: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFlags(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IAMPlayList, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn getItemCount(self: *const T, pdw_items_: ?*u32) HRESULT {
                return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetItemCount(@as(*const IAMPlayList, @ptrCast(self)), pdw_items_);
            }
            pub inline fn getItem(self: *const T, dw_item_index_: u32, pp_item_: ?*?*IAMPlayListItem) HRESULT {
                return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IAMPlayList, @ptrCast(self)), dw_item_index_, pp_item_);
            }
            pub inline fn getNamedEvent(self: *const T, pwsz_event_name_: ?PWSTR, dw_item_index_: u32, pp_item_: ?*?*IAMPlayListItem, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetNamedEvent(@as(*const IAMPlayList, @ptrCast(self)), pwsz_event_name_, dw_item_index_, pp_item_, pdw_flags_);
            }
            pub inline fn getRepeatInfo(self: *const T, pdw_repeat_count_: ?*u32, pdw_repeat_start_: ?*u32, pdw_repeat_end_: ?*u32) HRESULT {
                return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetRepeatInfo(@as(*const IAMPlayList, @ptrCast(self)), pdw_repeat_count_, pdw_repeat_start_, pdw_repeat_end_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpecifyParticularPages_Value = Guid.initString("4c437b91-6e9e-11d1-a704-006097c4e476");
pub const IID_ISpecifyParticularPages = &IID_ISpecifyParticularPages_Value;
pub const ISpecifyParticularPages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPages: *const fn (
            self: *const ISpecifyParticularPages,
            guid_what_pages: ?*const Guid,
            p_pages: ?*CAUUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPages(self: *const T, guid_what_pages_: ?*const Guid, p_pages_: ?*CAUUID) HRESULT {
                return @as(*const ISpecifyParticularPages.VTable, @ptrCast(self.vtable)).GetPages(@as(*const ISpecifyParticularPages, @ptrCast(self)), guid_what_pages_, p_pages_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMRebuild_Value = Guid.initString("02ef04dd-7580-11d1-bece-00c04fb6e937");
pub const IID_IAMRebuild = &IID_IAMRebuild_Value;
pub const IAMRebuild = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RebuildNow: *const fn (
            self: *const IAMRebuild,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn rebuildNow(self: *const T) HRESULT {
                return @as(*const IAMRebuild.VTable, @ptrCast(self.vtable)).RebuildNow(@as(*const IAMRebuild, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBufferingTime_Value = Guid.initString("1e00486a-78dd-11d2-8dd3-006097c9a2b2");
pub const IID_IBufferingTime = &IID_IBufferingTime_Value;
pub const IBufferingTime = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferingTime: *const fn (
            self: *const IBufferingTime,
            pdw_milliseconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBufferingTime: *const fn (
            self: *const IBufferingTime,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBufferingTime(self: *const T, pdw_milliseconds_: ?*u32) HRESULT {
                return @as(*const IBufferingTime.VTable, @ptrCast(self.vtable)).GetBufferingTime(@as(*const IBufferingTime, @ptrCast(self)), pdw_milliseconds_);
            }
            pub inline fn setBufferingTime(self: *const T, dw_milliseconds_: u32) HRESULT {
                return @as(*const IBufferingTime.VTable, @ptrCast(self.vtable)).SetBufferingTime(@as(*const IBufferingTime, @ptrCast(self)), dw_milliseconds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SystemTuningSpaces_Value = Guid.initString("d02aac50-027e-11d3-9d8e-00c04f72d980");
pub const CLSID_SystemTuningSpaces = &CLSID_SystemTuningSpaces_Value;

const CLSID_TuningSpace_Value = Guid.initString("5ffdc5e6-b83a-4b55-b6e8-c69e765fe9db");
pub const CLSID_TuningSpace = &CLSID_TuningSpace_Value;

const CLSID_ChannelIDTuningSpace_Value = Guid.initString("cc829a2f-3365-463f-af13-81dbb6f3a555");
pub const CLSID_ChannelIDTuningSpace = &CLSID_ChannelIDTuningSpace_Value;

const CLSID_ATSCTuningSpace_Value = Guid.initString("a2e30750-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_ATSCTuningSpace = &CLSID_ATSCTuningSpace_Value;

const CLSID_DigitalCableTuningSpace_Value = Guid.initString("d9bb4cee-b87a-47f1-ac92-b08d9c7813fc");
pub const CLSID_DigitalCableTuningSpace = &CLSID_DigitalCableTuningSpace_Value;

const CLSID_AnalogRadioTuningSpace_Value = Guid.initString("8a674b4c-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogRadioTuningSpace = &CLSID_AnalogRadioTuningSpace_Value;

const CLSID_AuxInTuningSpace_Value = Guid.initString("f9769a06-7aca-4e39-9cfb-97bb35f0e77e");
pub const CLSID_AuxInTuningSpace = &CLSID_AuxInTuningSpace_Value;

const CLSID_AnalogTVTuningSpace_Value = Guid.initString("8a674b4d-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogTVTuningSpace = &CLSID_AnalogTVTuningSpace_Value;

const CLSID_DVBTuningSpace_Value = Guid.initString("c6b14b32-76aa-4a86-a7ac-5c79aaf58da7");
pub const CLSID_DVBTuningSpace = &CLSID_DVBTuningSpace_Value;

const CLSID_DVBSTuningSpace_Value = Guid.initString("b64016f3-c9a2-4066-96f0-bd9563314726");
pub const CLSID_DVBSTuningSpace = &CLSID_DVBSTuningSpace_Value;

const CLSID_ComponentTypes_Value = Guid.initString("a1a2b1c4-0e3a-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentTypes = &CLSID_ComponentTypes_Value;

const CLSID_ComponentType_Value = Guid.initString("823535a0-0318-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentType = &CLSID_ComponentType_Value;

const CLSID_LanguageComponentType_Value = Guid.initString("1be49f30-0e1b-11d3-9d8e-00c04f72d980");
pub const CLSID_LanguageComponentType = &CLSID_LanguageComponentType_Value;

const CLSID_MPEG2ComponentType_Value = Guid.initString("418008f3-cf67-4668-9628-10dc52be1d08");
pub const CLSID_MPEG2ComponentType = &CLSID_MPEG2ComponentType_Value;

const CLSID_ATSCComponentType_Value = Guid.initString("a8dcf3d5-0780-4ef4-8a83-2cffaacb8ace");
pub const CLSID_ATSCComponentType = &CLSID_ATSCComponentType_Value;

const CLSID_Components_Value = Guid.initString("809b6661-94c4-49e6-b6ec-3f0f862215aa");
pub const CLSID_Components = &CLSID_Components_Value;

const CLSID_Component_Value = Guid.initString("59dc47a8-116c-11d3-9d8e-00c04f72d980");
pub const CLSID_Component = &CLSID_Component_Value;

const CLSID_MPEG2Component_Value = Guid.initString("055cb2d7-2969-45cd-914b-76890722f112");
pub const CLSID_MPEG2Component = &CLSID_MPEG2Component_Value;

const CLSID_AnalogAudioComponentType_Value = Guid.initString("28ab0005-e845-4ffa-aa9b-f4665236141c");
pub const CLSID_AnalogAudioComponentType = &CLSID_AnalogAudioComponentType_Value;

const CLSID_TuneRequest_Value = Guid.initString("b46e0d38-ab35-4a06-a137-70576b01b39f");
pub const CLSID_TuneRequest = &CLSID_TuneRequest_Value;

const CLSID_ChannelIDTuneRequest_Value = Guid.initString("3a9428a7-31a4-45e9-9efb-e055bf7bb3db");
pub const CLSID_ChannelIDTuneRequest = &CLSID_ChannelIDTuneRequest_Value;

const CLSID_ChannelTuneRequest_Value = Guid.initString("0369b4e5-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ChannelTuneRequest = &CLSID_ChannelTuneRequest_Value;

const CLSID_ATSCChannelTuneRequest_Value = Guid.initString("0369b4e6-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ATSCChannelTuneRequest = &CLSID_ATSCChannelTuneRequest_Value;

const CLSID_DigitalCableTuneRequest_Value = Guid.initString("26ec0b63-aa90-458a-8df4-5659f2c8a18a");
pub const CLSID_DigitalCableTuneRequest = &CLSID_DigitalCableTuneRequest_Value;

const CLSID_MPEG2TuneRequest_Value = Guid.initString("0955ac62-bf2e-4cba-a2b9-a63f772d46cf");
pub const CLSID_MPEG2TuneRequest = &CLSID_MPEG2TuneRequest_Value;

const CLSID_MPEG2TuneRequestFactory_Value = Guid.initString("2c63e4eb-4cea-41b8-919c-e947ea19a77c");
pub const CLSID_MPEG2TuneRequestFactory = &CLSID_MPEG2TuneRequestFactory_Value;

const CLSID_Locator_Value = Guid.initString("0888c883-ac4f-4943-b516-2c38d9b34562");
pub const CLSID_Locator = &CLSID_Locator_Value;

const CLSID_DigitalLocator_Value = Guid.initString("6e50cc0d-c19b-4bf6-810b-5bd60761f5cc");
pub const CLSID_DigitalLocator = &CLSID_DigitalLocator_Value;

const CLSID_AnalogLocator_Value = Guid.initString("49638b91-48ab-48b7-a47a-7d0e75a08ede");
pub const CLSID_AnalogLocator = &CLSID_AnalogLocator_Value;

const CLSID_ATSCLocator_Value = Guid.initString("8872ff1b-98fa-4d7a-8d93-c9f1055f85bb");
pub const CLSID_ATSCLocator = &CLSID_ATSCLocator_Value;

const CLSID_DigitalCableLocator_Value = Guid.initString("03c06416-d127-407a-ab4c-fdd279abbe5d");
pub const CLSID_DigitalCableLocator = &CLSID_DigitalCableLocator_Value;

const CLSID_DVBTLocator_Value = Guid.initString("9cd64701-bdf3-4d14-8e03-f12983d86664");
pub const CLSID_DVBTLocator = &CLSID_DVBTLocator_Value;

const CLSID_DVBTLocator2_Value = Guid.initString("efe3fa02-45d7-4920-be96-53fa7f35b0e6");
pub const CLSID_DVBTLocator2 = &CLSID_DVBTLocator2_Value;

const CLSID_DVBSLocator_Value = Guid.initString("1df7d126-4050-47f0-a7cf-4c4ca9241333");
pub const CLSID_DVBSLocator = &CLSID_DVBSLocator_Value;

const CLSID_DVBCLocator_Value = Guid.initString("c531d9fd-9685-4028-8b68-6e1232079f1e");
pub const CLSID_DVBCLocator = &CLSID_DVBCLocator_Value;

const CLSID_ISDBSLocator_Value = Guid.initString("6504afed-a629-455c-a7f1-04964dea5cc4");
pub const CLSID_ISDBSLocator = &CLSID_ISDBSLocator_Value;

const CLSID_DVBTuneRequest_Value = Guid.initString("15d6504a-5494-499c-886c-973c9e53b9f1");
pub const CLSID_DVBTuneRequest = &CLSID_DVBTuneRequest_Value;

const CLSID_CreatePropBagOnRegKey_Value = Guid.initString("8a674b49-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_CreatePropBagOnRegKey = &CLSID_CreatePropBagOnRegKey_Value;

const CLSID_BroadcastEventService_Value = Guid.initString("0b3ffb92-0919-4934-9d5b-619c719d0202");
pub const CLSID_BroadcastEventService = &CLSID_BroadcastEventService_Value;

const CLSID_TunerMarshaler_Value = Guid.initString("6438570b-0c08-4a25-9504-8012bb4d50cf");
pub const CLSID_TunerMarshaler = &CLSID_TunerMarshaler_Value;

const CLSID_PersistTuneXmlUtility_Value = Guid.initString("e77026b0-b97f-4cbb-b7fb-f4f03ad69f11");
pub const CLSID_PersistTuneXmlUtility = &CLSID_PersistTuneXmlUtility_Value;

const CLSID_ESEventService_Value = Guid.initString("c20447fc-ec60-475e-813f-d2b0a6decefe");
pub const CLSID_ESEventService = &CLSID_ESEventService_Value;

const CLSID_ESEventFactory_Value = Guid.initString("8e8a07da-71f8-40c1-a929-5e3a868ac2c6");
pub const CLSID_ESEventFactory = &CLSID_ESEventFactory_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICreatePropBagOnRegKey_Value = Guid.initString("8a674b48-1f63-11d3-b64c-00c04f79498e");
pub const IID_ICreatePropBagOnRegKey = &IID_ICreatePropBagOnRegKey_Value;
pub const ICreatePropBagOnRegKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: *const fn (
            self: *const ICreatePropBagOnRegKey,
            hkey: ?HKEY,
            subkey: ?[*:0]const u16,
            ul_options: u32,
            sam_desired: u32,
            iid: ?*const Guid,
            pp_bag: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn create(self: *const T, hkey_: ?HKEY, subkey_: ?[*:0]const u16, ul_options_: u32, sam_desired_: u32, iid_: ?*const Guid, pp_bag_: ?*?*anyopaque) HRESULT {
                return @as(*const ICreatePropBagOnRegKey.VTable, @ptrCast(self.vtable)).Create(@as(*const ICreatePropBagOnRegKey, @ptrCast(self)), hkey_, subkey_, ul_options_, sam_desired_, iid_, pp_bag_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DISPID_TUNER = enum(i32) {
    TUNER_TS_UNIQUENAME = 1,
    TUNER_TS_FRIENDLYNAME = 2,
    TUNER_TS_CLSID = 3,
    TUNER_TS_NETWORKTYPE = 4,
    TUNER_TS__NETWORKTYPE = 5,
    TUNER_TS_CREATETUNEREQUEST = 6,
    TUNER_TS_ENUMCATEGORYGUIDS = 7,
    TUNER_TS_ENUMDEVICEMONIKERS = 8,
    TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = 9,
    TUNER_TS_FREQMAP = 10,
    TUNER_TS_DEFLOCATOR = 11,
    TUNER_TS_CLONE = 12,
    // TUNER_TR_TUNINGSPACE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_TR_COMPONENTS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_TR_CLONE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_TR_LOCATOR = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT_CATEGORY = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_CT_MEDIAMAJORTYPE = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_CT__MEDIAMAJORTYPE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_CT_MEDIASUBTYPE = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT__MEDIASUBTYPE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_CT_MEDIAFORMATTYPE = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_CT__MEDIAFORMATTYPE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_CT_MEDIATYPE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    // TUNER_CT_CLONE = 9, this enum value conflicts with TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES
    TUNER_LCT_LANGID = 100,
    TUNER_MP2CT_TYPE = 200,
    TUNER_ATSCCT_FLAGS = 300,
    // TUNER_L_CARRFREQ = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_L_INNERFECMETHOD = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_L_INNERFECRATE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_L_OUTERFECMETHOD = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_L_OUTERFECRATE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_L_MOD = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_L_SYMRATE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_L_CLONE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    TUNER_L_ATSC_PHYS_CHANNEL = 201,
    TUNER_L_ATSC_TSID = 202,
    TUNER_L_ATSC_MP2_PROGNO = 203,
    TUNER_L_DVBT_BANDWIDTH = 301,
    TUNER_L_DVBT_LPINNERFECMETHOD = 302,
    TUNER_L_DVBT_LPINNERFECRATE = 303,
    TUNER_L_DVBT_GUARDINTERVAL = 304,
    TUNER_L_DVBT_HALPHA = 305,
    TUNER_L_DVBT_TRANSMISSIONMODE = 306,
    TUNER_L_DVBT_INUSE = 307,
    TUNER_L_DVBT2_PHYSICALLAYERPIPEID = 351,
    TUNER_L_DVBS_POLARISATION = 401,
    TUNER_L_DVBS_WEST = 402,
    TUNER_L_DVBS_ORBITAL = 403,
    TUNER_L_DVBS_AZIMUTH = 404,
    TUNER_L_DVBS_ELEVATION = 405,
    TUNER_L_DVBS2_DISEQ_LNB_SOURCE = 406,
    TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = 407,
    TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = 408,
    TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = 409,
    TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = 410,
    TUNER_L_DVBS2_ROLLOFF = 411,
    TUNER_L_DVBS2_PILOT = 412,
    TUNER_L_ANALOG_STANDARD = 601,
    TUNER_L_DTV_O_MAJOR_CHANNEL = 701,
    // TUNER_C_TYPE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_C_STATUS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_C_LANGID = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_C_DESCRIPTION = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_C_CLONE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    TUNER_C_MP2_PID = 101,
    TUNER_C_MP2_PCRPID = 102,
    TUNER_C_MP2_PROGNO = 103,
    // TUNER_C_ANALOG_AUDIO = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_DVB_SYSTEMTYPE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_DVB2_NETWORK_ID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    TUNER_TS_DVBS_LOW_OSC_FREQ = 1001,
    TUNER_TS_DVBS_HI_OSC_FREQ = 1002,
    TUNER_TS_DVBS_LNB_SWITCH_FREQ = 1003,
    TUNER_TS_DVBS_INPUT_RANGE = 1004,
    TUNER_TS_DVBS_SPECTRAL_INVERSION = 1005,
    // TUNER_TS_AR_MINFREQUENCY = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_AR_MAXFREQUENCY = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_AR_STEP = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    TUNER_TS_AR_COUNTRYCODE = 104,
    // TUNER_TS_AUX_COUNTRYCODE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MINCHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MAXCHANNEL = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_ATV_INPUTTYPE = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // TUNER_TS_ATV_COUNTRYCODE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // TUNER_TS_ATSC_MINMINORCHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_ATSC_MAXMINORCHANNEL = 202, this enum value conflicts with TUNER_L_ATSC_TSID
    // TUNER_TS_ATSC_MINPHYSCHANNEL = 203, this enum value conflicts with TUNER_L_ATSC_MP2_PROGNO
    TUNER_TS_ATSC_MAXPHYSCHANNEL = 204,
    // TUNER_TS_DC_MINMAJORCHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // TUNER_TS_DC_MAXMAJORCHANNEL = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // TUNER_TS_DC_MINSOURCEID = 303, this enum value conflicts with TUNER_L_DVBT_LPINNERFECRATE
    // TUNER_TS_DC_MAXSOURCEID = 304, this enum value conflicts with TUNER_L_DVBT_GUARDINTERVAL
    // CHTUNER_ATVAC_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_SYSTEM = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_CONTENT = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // CHTUNER_CIDTR_CHANNELID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_CTR_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ACTR_MINOR_CHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // CHTUNER_DCTR_MAJOR_CHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // CHTUNER_DCTR_SRCID = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // DVBTUNER_DVBC_ATTRIBUTESVALID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_DVBC_PID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_DVBC_TAG = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // DVBTUNER_DVBC_COMPONENTTYPE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // DVBTUNER_ONID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_TSID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_SID = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // MP2TUNER_TSID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // MP2TUNER_PROGNO = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // MP2TUNERFACTORY_CREATETUNEREQUEST = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
};
pub const DISPID_TUNER_TS_UNIQUENAME = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TS_FRIENDLYNAME = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TS_CLSID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TS_NETWORKTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_TS__NETWORKTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_TS_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_TS_ENUMCATEGORYGUIDS = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_TS_ENUMDEVICEMONIKERS = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_TS_FREQMAP = DISPID_TUNER.TUNER_TS_FREQMAP;
pub const DISPID_TUNER_TS_DEFLOCATOR = DISPID_TUNER.TUNER_TS_DEFLOCATOR;
pub const DISPID_TUNER_TS_CLONE = DISPID_TUNER.TUNER_TS_CLONE;
pub const DISPID_TUNER_TR_TUNINGSPACE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TR_COMPONENTS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TR_CLONE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TR_LOCATOR = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT_CATEGORY = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_CT_MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_CT__MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_CT_MEDIASUBTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT__MEDIASUBTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_CT_MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_CT__MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_CT_MEDIATYPE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_CT_CLONE = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_LCT_LANGID = DISPID_TUNER.TUNER_LCT_LANGID;
pub const DISPID_TUNER_MP2CT_TYPE = DISPID_TUNER.TUNER_MP2CT_TYPE;
pub const DISPID_TUNER_ATSCCT_FLAGS = DISPID_TUNER.TUNER_ATSCCT_FLAGS;
pub const DISPID_TUNER_L_CARRFREQ = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_L_INNERFECMETHOD = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_L_INNERFECRATE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_L_OUTERFECMETHOD = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_L_OUTERFECRATE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_L_MOD = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_L_SYMRATE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_L_CLONE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_L_ATSC_PHYS_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_L_ATSC_TSID = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_L_ATSC_MP2_PROGNO = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_L_DVBT_BANDWIDTH = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_L_DVBT_LPINNERFECMETHOD = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_L_DVBT_LPINNERFECRATE = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_L_DVBT_GUARDINTERVAL = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_TUNER_L_DVBT_HALPHA = DISPID_TUNER.TUNER_L_DVBT_HALPHA;
pub const DISPID_TUNER_L_DVBT_TRANSMISSIONMODE = DISPID_TUNER.TUNER_L_DVBT_TRANSMISSIONMODE;
pub const DISPID_TUNER_L_DVBT_INUSE = DISPID_TUNER.TUNER_L_DVBT_INUSE;
pub const DISPID_TUNER_L_DVBT2_PHYSICALLAYERPIPEID = DISPID_TUNER.TUNER_L_DVBT2_PHYSICALLAYERPIPEID;
pub const DISPID_TUNER_L_DVBS_POLARISATION = DISPID_TUNER.TUNER_L_DVBS_POLARISATION;
pub const DISPID_TUNER_L_DVBS_WEST = DISPID_TUNER.TUNER_L_DVBS_WEST;
pub const DISPID_TUNER_L_DVBS_ORBITAL = DISPID_TUNER.TUNER_L_DVBS_ORBITAL;
pub const DISPID_TUNER_L_DVBS_AZIMUTH = DISPID_TUNER.TUNER_L_DVBS_AZIMUTH;
pub const DISPID_TUNER_L_DVBS_ELEVATION = DISPID_TUNER.TUNER_L_DVBS_ELEVATION;
pub const DISPID_TUNER_L_DVBS2_DISEQ_LNB_SOURCE = DISPID_TUNER.TUNER_L_DVBS2_DISEQ_LNB_SOURCE;
pub const DISPID_TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE;
pub const DISPID_TUNER_L_DVBS2_ROLLOFF = DISPID_TUNER.TUNER_L_DVBS2_ROLLOFF;
pub const DISPID_TUNER_L_DVBS2_PILOT = DISPID_TUNER.TUNER_L_DVBS2_PILOT;
pub const DISPID_TUNER_L_ANALOG_STANDARD = DISPID_TUNER.TUNER_L_ANALOG_STANDARD;
pub const DISPID_TUNER_L_DTV_O_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DTV_O_MAJOR_CHANNEL;
pub const DISPID_TUNER_C_TYPE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_C_STATUS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_C_LANGID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_C_DESCRIPTION = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_C_CLONE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_C_MP2_PID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_C_MP2_PCRPID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_C_MP2_PROGNO = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_C_ANALOG_AUDIO = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_DVB_SYSTEMTYPE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_DVB2_NETWORK_ID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_DVBS_LOW_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LOW_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_HI_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_HI_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_LNB_SWITCH_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LNB_SWITCH_FREQ;
pub const DISPID_TUNER_TS_DVBS_INPUT_RANGE = DISPID_TUNER.TUNER_TS_DVBS_INPUT_RANGE;
pub const DISPID_TUNER_TS_DVBS_SPECTRAL_INVERSION = DISPID_TUNER.TUNER_TS_DVBS_SPECTRAL_INVERSION;
pub const DISPID_TUNER_TS_AR_MINFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_AR_MAXFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_AR_STEP = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_AR_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_AUX_COUNTRYCODE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MINCHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MAXCHANNEL = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_ATV_INPUTTYPE = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATV_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_ATSC_MINMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_ATSC_MAXMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_TS_ATSC_MINPHYSCHANNEL = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATSC_MAXPHYSCHANNEL = DISPID_TUNER.TUNER_TS_ATSC_MAXPHYSCHANNEL;
pub const DISPID_TUNER_TS_DC_MINMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_TS_DC_MAXMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_TS_DC_MINSOURCEID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_TS_DC_MAXSOURCEID = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_CHTUNER_ATVAC_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_SYSTEM = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_CONTENT = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_CHTUNER_CIDTR_CHANNELID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_CTR_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ACTR_MINOR_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_CHTUNER_DCTR_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_CHTUNER_DCTR_SRCID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_DVBTUNER_DVBC_ATTRIBUTESVALID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_DVBC_PID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_DVBC_TAG = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_DVBTUNER_DVBC_COMPONENTTYPE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_DVBTUNER_ONID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_SID = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_MP2TUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_MP2TUNER_PROGNO = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_MP2TUNERFACTORY_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_UNIQUENAME;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaces_Value = Guid.initString("901284e4-33fe-4b69-8d63-634a596f3756");
pub const IID_ITuningSpaces = &IID_ITuningSpaces_Value;
pub const ITuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaces,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaces,
            new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaces,
            var_index: VARIANT,
            tuning_space: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaces,
            new_enum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ITuningSpaces, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ITuningSpaces, @ptrCast(self)), new_enum_);
            }
            pub inline fn getItem(self: *const T, var_index_: VARIANT, tuning_space_: ?*?*ITuningSpace) HRESULT {
                return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ITuningSpaces, @ptrCast(self)), var_index_, tuning_space_);
            }
            pub inline fn getEnumTuningSpaces(self: *const T, new_enum_: ?*?*IEnumTuningSpaces) HRESULT {
                return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_EnumTuningSpaces(@as(*const ITuningSpaces, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaceContainer_Value = Guid.initString("5b692e84-e2f1-11d2-9493-00c04f72d980");
pub const IID_ITuningSpaceContainer = &IID_ITuningSpaceContainer_Value;
pub const ITuningSpaceContainer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            var_index: VARIANT,
            tuning_space: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            var_index: VARIANT,
            tuning_space: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuningSpacesForCLSID: *const fn (
            self: *const ITuningSpaceContainer,
            space_c_l_s_i_d: ?BSTR,
            new_coll: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _TuningSpacesForCLSID2: *const fn (
            self: *const ITuningSpaceContainer,
            space_c_l_s_i_d: ?*const Guid,
            new_coll: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuningSpacesForName: *const fn (
            self: *const ITuningSpaceContainer,
            name: ?BSTR,
            new_coll: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindID: *const fn (
            self: *const ITuningSpaceContainer,
            tuning_space: ?*ITuningSpace,
            i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const ITuningSpaceContainer,
            tuning_space: ?*ITuningSpace,
            new_index: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            pp_enum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const ITuningSpaceContainer,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            max_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpaceContainer,
            max_count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ITuningSpaceContainer, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ITuningSpaceContainer, @ptrCast(self)), new_enum_);
            }
            pub inline fn getItem(self: *const T, var_index_: VARIANT, tuning_space_: ?*?*ITuningSpace) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ITuningSpaceContainer, @ptrCast(self)), var_index_, tuning_space_);
            }
            pub inline fn putItem(self: *const T, var_index_: VARIANT, tuning_space_: ?*ITuningSpace) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).put_Item(@as(*const ITuningSpaceContainer, @ptrCast(self)), var_index_, tuning_space_);
            }
            pub inline fn tuningSpacesForCLSID(self: *const T, space_c_l_s_i_d_: ?BSTR, new_coll_: ?*?*ITuningSpaces) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).TuningSpacesForCLSID(@as(*const ITuningSpaceContainer, @ptrCast(self)), space_c_l_s_i_d_, new_coll_);
            }
            pub inline fn tuningSpacesForCLSID2(self: *const T, space_c_l_s_i_d_: ?*const Guid, new_coll_: ?*?*ITuningSpaces) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable))._TuningSpacesForCLSID2(@as(*const ITuningSpaceContainer, @ptrCast(self)), space_c_l_s_i_d_, new_coll_);
            }
            pub inline fn tuningSpacesForName(self: *const T, name_: ?BSTR, new_coll_: ?*?*ITuningSpaces) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).TuningSpacesForName(@as(*const ITuningSpaceContainer, @ptrCast(self)), name_, new_coll_);
            }
            pub inline fn findID(self: *const T, tuning_space_: ?*ITuningSpace, i_d_: ?*i32) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).FindID(@as(*const ITuningSpaceContainer, @ptrCast(self)), tuning_space_, i_d_);
            }
            pub inline fn add(self: *const T, tuning_space_: ?*ITuningSpace, new_index_: ?*VARIANT) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).Add(@as(*const ITuningSpaceContainer, @ptrCast(self)), tuning_space_, new_index_);
            }
            pub inline fn getEnumTuningSpaces(self: *const T, pp_enum_: ?*?*IEnumTuningSpaces) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_EnumTuningSpaces(@as(*const ITuningSpaceContainer, @ptrCast(self)), pp_enum_);
            }
            pub inline fn remove(self: *const T, index_: VARIANT) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).Remove(@as(*const ITuningSpaceContainer, @ptrCast(self)), index_);
            }
            pub inline fn getMaxCount(self: *const T, max_count_: ?*i32) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_MaxCount(@as(*const ITuningSpaceContainer, @ptrCast(self)), max_count_);
            }
            pub inline fn putMaxCount(self: *const T, max_count_: i32) HRESULT {
                return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).put_MaxCount(@as(*const ITuningSpaceContainer, @ptrCast(self)), max_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpace_Value = Guid.initString("061c6e30-e622-11d2-9493-00c04f72d980");
pub const IID_ITuningSpace = &IID_ITuningSpace_Value;
pub const ITuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UniqueName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FriendlyName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CLSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            space_c_l_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            network_type_guid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            network_type_guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NetworkType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            network_type_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__NetworkType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            network_type_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTuneRequest: *const fn (
            self: *const ITuningSpace,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCategoryGUIDs: *const fn (
            self: *const ITuningSpace,
            pp_enum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDeviceMonikers: *const fn (
            self: *const ITuningSpace,
            pp_enum: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultPreferredComponentTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            component_types: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultPreferredComponentTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            new_component_types: ?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMapping: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            p_mapping: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMapping: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            mapping: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultLocator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            locator_val: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultLocator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuningSpace,
            locator_val: ?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ITuningSpace,
            new_t_s: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getUniqueName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_UniqueName(@as(*const ITuningSpace, @ptrCast(self)), name_);
            }
            pub inline fn putUniqueName(self: *const T, name_: ?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_UniqueName(@as(*const ITuningSpace, @ptrCast(self)), name_);
            }
            pub inline fn getFriendlyName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_FriendlyName(@as(*const ITuningSpace, @ptrCast(self)), name_);
            }
            pub inline fn putFriendlyName(self: *const T, name_: ?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_FriendlyName(@as(*const ITuningSpace, @ptrCast(self)), name_);
            }
            pub inline fn getCLSID(self: *const T, space_c_l_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_CLSID(@as(*const ITuningSpace, @ptrCast(self)), space_c_l_s_i_d_);
            }
            pub inline fn getNetworkType(self: *const T, network_type_guid_: ?*?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_NetworkType(@as(*const ITuningSpace, @ptrCast(self)), network_type_guid_);
            }
            pub inline fn putNetworkType(self: *const T, network_type_guid_: ?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_NetworkType(@as(*const ITuningSpace, @ptrCast(self)), network_type_guid_);
            }
            pub inline fn getNetworkType1(self: *const T, network_type_guid_: ?*Guid) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get__NetworkType(@as(*const ITuningSpace, @ptrCast(self)), network_type_guid_);
            }
            pub inline fn putNetworkType1(self: *const T, network_type_guid_: ?*const Guid) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put__NetworkType(@as(*const ITuningSpace, @ptrCast(self)), network_type_guid_);
            }
            pub inline fn createTuneRequest(self: *const T, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).CreateTuneRequest(@as(*const ITuningSpace, @ptrCast(self)), tune_request_);
            }
            pub inline fn enumCategoryGUIDs(self: *const T, pp_enum_: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).EnumCategoryGUIDs(@as(*const ITuningSpace, @ptrCast(self)), pp_enum_);
            }
            pub inline fn enumDeviceMonikers(self: *const T, pp_enum_: ?*?*IEnumMoniker) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).EnumDeviceMonikers(@as(*const ITuningSpace, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getDefaultPreferredComponentTypes(self: *const T, component_types_: ?*?*IComponentTypes) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_DefaultPreferredComponentTypes(@as(*const ITuningSpace, @ptrCast(self)), component_types_);
            }
            pub inline fn putDefaultPreferredComponentTypes(self: *const T, new_component_types_: ?*IComponentTypes) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_DefaultPreferredComponentTypes(@as(*const ITuningSpace, @ptrCast(self)), new_component_types_);
            }
            pub inline fn getFrequencyMapping(self: *const T, p_mapping_: ?*?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_FrequencyMapping(@as(*const ITuningSpace, @ptrCast(self)), p_mapping_);
            }
            pub inline fn putFrequencyMapping(self: *const T, mapping_: ?BSTR) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_FrequencyMapping(@as(*const ITuningSpace, @ptrCast(self)), mapping_);
            }
            pub inline fn getDefaultLocator(self: *const T, locator_val_: ?*?*ILocator) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_DefaultLocator(@as(*const ITuningSpace, @ptrCast(self)), locator_val_);
            }
            pub inline fn putDefaultLocator(self: *const T, locator_val_: ?*ILocator) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_DefaultLocator(@as(*const ITuningSpace, @ptrCast(self)), locator_val_);
            }
            pub inline fn clone(self: *const T, new_t_s_: ?*?*ITuningSpace) HRESULT {
                return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITuningSpace, @ptrCast(self)), new_t_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumTuningSpaces_Value = Guid.initString("8b8eb248-fc2b-11d2-9d8c-00c04f72d980");
pub const IID_IEnumTuningSpaces = &IID_IEnumTuningSpaces_Value;
pub const IEnumTuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumTuningSpaces,
            celt: u32,
            rgelt: [*]?*ITuningSpace,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTuningSpaces,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumTuningSpaces,
            pp_enum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*ITuningSpace, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTuningSpaces, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTuningSpaces, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTuningSpaces, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumTuningSpaces) HRESULT {
                return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTuningSpaces, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace_Value = Guid.initString("ada0b268-3b19-4e5b-acc4-49f852be13ba");
pub const IID_IDVBTuningSpace = &IID_IDVBTuningSpace_Value;
pub const IDVBTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SystemType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuningSpace,
            sys_type: ?*DVBSystemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SystemType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuningSpace,
            sys_type: DVBSystemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuningSpace.MethodMixin(T);
            pub inline fn getSystemType(self: *const T, sys_type_: ?*DVBSystemType) HRESULT {
                return @as(*const IDVBTuningSpace.VTable, @ptrCast(self.vtable)).get_SystemType(@as(*const IDVBTuningSpace, @ptrCast(self)), sys_type_);
            }
            pub inline fn putSystemType(self: *const T, sys_type_: DVBSystemType) HRESULT {
                return @as(*const IDVBTuningSpace.VTable, @ptrCast(self.vtable)).put_SystemType(@as(*const IDVBTuningSpace, @ptrCast(self)), sys_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace2_Value = Guid.initString("843188b4-ce62-43db-966b-8145a094e040");
pub const IID_IDVBTuningSpace2 = &IID_IDVBTuningSpace2_Value;
pub const IDVBTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuningSpace2,
            network_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuningSpace2,
            network_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVBTuningSpace.MethodMixin(T);
            pub inline fn getNetworkID(self: *const T, network_i_d_: ?*i32) HRESULT {
                return @as(*const IDVBTuningSpace2.VTable, @ptrCast(self.vtable)).get_NetworkID(@as(*const IDVBTuningSpace2, @ptrCast(self)), network_i_d_);
            }
            pub inline fn putNetworkID(self: *const T, network_i_d_: i32) HRESULT {
                return @as(*const IDVBTuningSpace2.VTable, @ptrCast(self.vtable)).put_NetworkID(@as(*const IDVBTuningSpace2, @ptrCast(self)), network_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSTuningSpace_Value = Guid.initString("cdf7be60-d954-42fd-a972-78971958e470");
pub const IID_IDVBSTuningSpace = &IID_IDVBSTuningSpace_Value;
pub const IDVBSTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LowOscillator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            low_oscillator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LowOscillator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            low_oscillator: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighOscillator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            high_oscillator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighOscillator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            high_oscillator: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LNBSwitch: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            l_n_b_switch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LNBSwitch: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            l_n_b_switch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputRange: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            input_range: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputRange: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            input_range: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            spectral_inversion_val: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSTuningSpace,
            spectral_inversion_val: SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVBTuningSpace2.MethodMixin(T);
            pub inline fn getLowOscillator(self: *const T, low_oscillator_: ?*i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_LowOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), low_oscillator_);
            }
            pub inline fn putLowOscillator(self: *const T, low_oscillator_: i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_LowOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), low_oscillator_);
            }
            pub inline fn getHighOscillator(self: *const T, high_oscillator_: ?*i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_HighOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), high_oscillator_);
            }
            pub inline fn putHighOscillator(self: *const T, high_oscillator_: i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_HighOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), high_oscillator_);
            }
            pub inline fn getLNBSwitch(self: *const T, l_n_b_switch_: ?*i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_LNBSwitch(@as(*const IDVBSTuningSpace, @ptrCast(self)), l_n_b_switch_);
            }
            pub inline fn putLNBSwitch(self: *const T, l_n_b_switch_: i32) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_LNBSwitch(@as(*const IDVBSTuningSpace, @ptrCast(self)), l_n_b_switch_);
            }
            pub inline fn getInputRange(self: *const T, input_range_: ?*?BSTR) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_InputRange(@as(*const IDVBSTuningSpace, @ptrCast(self)), input_range_);
            }
            pub inline fn putInputRange(self: *const T, input_range_: ?BSTR) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_InputRange(@as(*const IDVBSTuningSpace, @ptrCast(self)), input_range_);
            }
            pub inline fn getSpectralInversion(self: *const T, spectral_inversion_val_: ?*SpectralInversion) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_SpectralInversion(@as(*const IDVBSTuningSpace, @ptrCast(self)), spectral_inversion_val_);
            }
            pub inline fn putSpectralInversion(self: *const T, spectral_inversion_val_: SpectralInversion) HRESULT {
                return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_SpectralInversion(@as(*const IDVBSTuningSpace, @ptrCast(self)), spectral_inversion_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAuxInTuningSpace_Value = Guid.initString("e48244b8-7e17-4f76-a763-5090ff1e2f30");
pub const IID_IAuxInTuningSpace = &IID_IAuxInTuningSpace_Value;
pub const IAuxInTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuningSpace.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuxInTuningSpace2_Value = Guid.initString("b10931ed-8bfe-4ab0-9dce-e469c29a9729");
pub const IID_IAuxInTuningSpace2 = &IID_IAuxInTuningSpace2_Value;
pub const IAuxInTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAuxInTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAuxInTuningSpace2,
            country_code_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAuxInTuningSpace2,
            new_country_code_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAuxInTuningSpace.MethodMixin(T);
            pub inline fn getCountryCode(self: *const T, country_code_val_: ?*i32) HRESULT {
                return @as(*const IAuxInTuningSpace2.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAuxInTuningSpace2, @ptrCast(self)), country_code_val_);
            }
            pub inline fn putCountryCode(self: *const T, new_country_code_val_: i32) HRESULT {
                return @as(*const IAuxInTuningSpace2.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAuxInTuningSpace2, @ptrCast(self)), new_country_code_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogTVTuningSpace_Value = Guid.initString("2a6e293c-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogTVTuningSpace = &IID_IAnalogTVTuningSpace_Value;
pub const IAnalogTVTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            min_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            new_min_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            max_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            new_max_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            input_type_val: ?*TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            new_input_type_val: TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            country_code_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogTVTuningSpace,
            new_country_code_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuningSpace.MethodMixin(T);
            pub inline fn getMinChannel(self: *const T, min_channel_val_: ?*i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_MinChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), min_channel_val_);
            }
            pub inline fn putMinChannel(self: *const T, new_min_channel_val_: i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_MinChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), new_min_channel_val_);
            }
            pub inline fn getMaxChannel(self: *const T, max_channel_val_: ?*i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), max_channel_val_);
            }
            pub inline fn putMaxChannel(self: *const T, new_max_channel_val_: i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), new_max_channel_val_);
            }
            pub inline fn getInputType(self: *const T, input_type_val_: ?*TunerInputType) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_InputType(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), input_type_val_);
            }
            pub inline fn putInputType(self: *const T, new_input_type_val_: TunerInputType) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_InputType(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), new_input_type_val_);
            }
            pub inline fn getCountryCode(self: *const T, country_code_val_: ?*i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), country_code_val_);
            }
            pub inline fn putCountryCode(self: *const T, new_country_code_val_: i32) HRESULT {
                return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), new_country_code_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCTuningSpace_Value = Guid.initString("0369b4e2-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCTuningSpace = &IID_IATSCTuningSpace_Value;
pub const IATSCTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IAnalogTVTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            min_minor_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            new_min_minor_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            max_minor_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            new_max_minor_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinPhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            min_physical_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinPhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            new_min_physical_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxPhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            max_physical_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxPhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCTuningSpace,
            new_max_physical_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAnalogTVTuningSpace.MethodMixin(T);
            pub inline fn getMinMinorChannel(self: *const T, min_minor_channel_val_: ?*i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MinMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), min_minor_channel_val_);
            }
            pub inline fn putMinMinorChannel(self: *const T, new_min_minor_channel_val_: i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MinMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), new_min_minor_channel_val_);
            }
            pub inline fn getMaxMinorChannel(self: *const T, max_minor_channel_val_: ?*i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), max_minor_channel_val_);
            }
            pub inline fn putMaxMinorChannel(self: *const T, new_max_minor_channel_val_: i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), new_max_minor_channel_val_);
            }
            pub inline fn getMinPhysicalChannel(self: *const T, min_physical_channel_val_: ?*i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MinPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), min_physical_channel_val_);
            }
            pub inline fn putMinPhysicalChannel(self: *const T, new_min_physical_channel_val_: i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MinPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), new_min_physical_channel_val_);
            }
            pub inline fn getMaxPhysicalChannel(self: *const T, max_physical_channel_val_: ?*i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), max_physical_channel_val_);
            }
            pub inline fn putMaxPhysicalChannel(self: *const T, new_max_physical_channel_val_: i32) HRESULT {
                return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), new_max_physical_channel_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuningSpace_Value = Guid.initString("013f9f9c-b449-4ec7-a6d2-9d4f2fc70ae5");
pub const IID_IDigitalCableTuningSpace = &IID_IDigitalCableTuningSpace_Value;
pub const IDigitalCableTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IATSCTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            min_major_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            new_min_major_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            max_major_channel_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            new_max_major_channel_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinSourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            min_source_i_d_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinSourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            new_min_source_i_d_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxSourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            max_source_i_d_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxSourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuningSpace,
            new_max_source_i_d_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IATSCTuningSpace.MethodMixin(T);
            pub inline fn getMinMajorChannel(self: *const T, min_major_channel_val_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MinMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), min_major_channel_val_);
            }
            pub inline fn putMinMajorChannel(self: *const T, new_min_major_channel_val_: i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MinMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), new_min_major_channel_val_);
            }
            pub inline fn getMaxMajorChannel(self: *const T, max_major_channel_val_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), max_major_channel_val_);
            }
            pub inline fn putMaxMajorChannel(self: *const T, new_max_major_channel_val_: i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), new_max_major_channel_val_);
            }
            pub inline fn getMinSourceID(self: *const T, min_source_i_d_val_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MinSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), min_source_i_d_val_);
            }
            pub inline fn putMinSourceID(self: *const T, new_min_source_i_d_val_: i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MinSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), new_min_source_i_d_val_);
            }
            pub inline fn getMaxSourceID(self: *const T, max_source_i_d_val_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), max_source_i_d_val_);
            }
            pub inline fn putMaxSourceID(self: *const T, new_max_source_i_d_val_: i32) HRESULT {
                return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), new_max_source_i_d_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogRadioTuningSpace_Value = Guid.initString("2a6e293b-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogRadioTuningSpace = &IID_IAnalogRadioTuningSpace_Value;
pub const IAnalogRadioTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            min_frequency_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            new_min_frequency_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            max_frequency_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            new_max_frequency_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Step: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            step_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Step: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace,
            new_step_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuningSpace.MethodMixin(T);
            pub inline fn getMinFrequency(self: *const T, min_frequency_val_: ?*i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_MinFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), min_frequency_val_);
            }
            pub inline fn putMinFrequency(self: *const T, new_min_frequency_val_: i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_MinFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), new_min_frequency_val_);
            }
            pub inline fn getMaxFrequency(self: *const T, max_frequency_val_: ?*i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), max_frequency_val_);
            }
            pub inline fn putMaxFrequency(self: *const T, new_max_frequency_val_: i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), new_max_frequency_val_);
            }
            pub inline fn getStep(self: *const T, step_val_: ?*i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_Step(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), step_val_);
            }
            pub inline fn putStep(self: *const T, new_step_val_: i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_Step(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), new_step_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAnalogRadioTuningSpace2_Value = Guid.initString("39dd45da-2da8-46ba-8a8a-87e2b73d983a");
pub const IID_IAnalogRadioTuningSpace2 = &IID_IAnalogRadioTuningSpace2_Value;
pub const IAnalogRadioTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAnalogRadioTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace2,
            country_code_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogRadioTuningSpace2,
            new_country_code_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAnalogRadioTuningSpace.MethodMixin(T);
            pub inline fn getCountryCode(self: *const T, country_code_val_: ?*i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace2.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAnalogRadioTuningSpace2, @ptrCast(self)), country_code_val_);
            }
            pub inline fn putCountryCode(self: *const T, new_country_code_val_: i32) HRESULT {
                return @as(*const IAnalogRadioTuningSpace2.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAnalogRadioTuningSpace2, @ptrCast(self)), new_country_code_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuneRequest_Value = Guid.initString("07ddc146-fc3d-11d2-9d8c-00c04f72d980");
pub const IID_ITuneRequest = &IID_ITuneRequest_Value;
pub const ITuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuneRequest,
            tuning_space: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Components: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuneRequest,
            components: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ITuneRequest,
            new_tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Locator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuneRequest,
            locator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Locator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuneRequest,
            locator: ?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getTuningSpace(self: *const T, tuning_space_: ?*?*ITuningSpace) HRESULT {
                return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const ITuneRequest, @ptrCast(self)), tuning_space_);
            }
            pub inline fn getComponents(self: *const T, components_: ?*?*IComponents) HRESULT {
                return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_Components(@as(*const ITuneRequest, @ptrCast(self)), components_);
            }
            pub inline fn clone(self: *const T, new_tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITuneRequest, @ptrCast(self)), new_tune_request_);
            }
            pub inline fn getLocator(self: *const T, locator_: ?*?*ILocator) HRESULT {
                return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_Locator(@as(*const ITuneRequest, @ptrCast(self)), locator_);
            }
            pub inline fn putLocator(self: *const T, locator_: ?*ILocator) HRESULT {
                return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).put_Locator(@as(*const ITuneRequest, @ptrCast(self)), locator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChannelIDTuneRequest_Value = Guid.initString("156eff60-86f4-4e28-89fc-109799fd57ee");
pub const IID_IChannelIDTuneRequest = &IID_IChannelIDTuneRequest_Value;
pub const IChannelIDTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IChannelIDTuneRequest,
            channel_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ChannelID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IChannelIDTuneRequest,
            channel_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuneRequest.MethodMixin(T);
            pub inline fn getChannelID(self: *const T, channel_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IChannelIDTuneRequest.VTable, @ptrCast(self.vtable)).get_ChannelID(@as(*const IChannelIDTuneRequest, @ptrCast(self)), channel_i_d_);
            }
            pub inline fn putChannelID(self: *const T, channel_i_d_: ?BSTR) HRESULT {
                return @as(*const IChannelIDTuneRequest.VTable, @ptrCast(self.vtable)).put_ChannelID(@as(*const IChannelIDTuneRequest, @ptrCast(self)), channel_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IChannelTuneRequest_Value = Guid.initString("0369b4e0-45b6-11d3-b650-00c04f79498e");
pub const IID_IChannelTuneRequest = &IID_IChannelTuneRequest_Value;
pub const IChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IChannelTuneRequest,
            channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IChannelTuneRequest,
            channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuneRequest.MethodMixin(T);
            pub inline fn getChannel(self: *const T, channel_: ?*i32) HRESULT {
                return @as(*const IChannelTuneRequest.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IChannelTuneRequest, @ptrCast(self)), channel_);
            }
            pub inline fn putChannel(self: *const T, channel_: i32) HRESULT {
                return @as(*const IChannelTuneRequest.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IChannelTuneRequest, @ptrCast(self)), channel_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCChannelTuneRequest_Value = Guid.initString("0369b4e1-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCChannelTuneRequest = &IID_IATSCChannelTuneRequest_Value;
pub const IATSCChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCChannelTuneRequest,
            minor_channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCChannelTuneRequest,
            minor_channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IChannelTuneRequest.MethodMixin(T);
            pub inline fn getMinorChannel(self: *const T, minor_channel_: ?*i32) HRESULT {
                return @as(*const IATSCChannelTuneRequest.VTable, @ptrCast(self.vtable)).get_MinorChannel(@as(*const IATSCChannelTuneRequest, @ptrCast(self)), minor_channel_);
            }
            pub inline fn putMinorChannel(self: *const T, minor_channel_: i32) HRESULT {
                return @as(*const IATSCChannelTuneRequest.VTable, @ptrCast(self.vtable)).put_MinorChannel(@as(*const IATSCChannelTuneRequest, @ptrCast(self)), minor_channel_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuneRequest_Value = Guid.initString("bad7753b-6b37-4810-ae57-3ce0c4a9e6cb");
pub const IID_IDigitalCableTuneRequest = &IID_IDigitalCableTuneRequest_Value;
pub const IDigitalCableTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IATSCChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuneRequest,
            p_major_channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MajorChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuneRequest,
            major_channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuneRequest,
            p_source_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDigitalCableTuneRequest,
            source_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IATSCChannelTuneRequest.MethodMixin(T);
            pub inline fn getMajorChannel(self: *const T, p_major_channel_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).get_MajorChannel(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), p_major_channel_);
            }
            pub inline fn putMajorChannel(self: *const T, major_channel_: i32) HRESULT {
                return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).put_MajorChannel(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), major_channel_);
            }
            pub inline fn getSourceID(self: *const T, p_source_i_d_: ?*i32) HRESULT {
                return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).get_SourceID(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), p_source_i_d_);
            }
            pub inline fn putSourceID(self: *const T, source_i_d_: i32) HRESULT {
                return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).put_SourceID(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), source_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuneRequest_Value = Guid.initString("0d6f567e-a636-42bb-83ba-ce4c1704afa2");
pub const IID_IDVBTuneRequest = &IID_IDVBTuneRequest_Value;
pub const IDVBTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ONID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            o_n_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ONID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            o_n_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            t_s_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            t_s_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            s_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTuneRequest,
            s_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuneRequest.MethodMixin(T);
            pub inline fn getONID(self: *const T, o_n_i_d_: ?*i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_ONID(@as(*const IDVBTuneRequest, @ptrCast(self)), o_n_i_d_);
            }
            pub inline fn putONID(self: *const T, o_n_i_d_: i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_ONID(@as(*const IDVBTuneRequest, @ptrCast(self)), o_n_i_d_);
            }
            pub inline fn getTSID(self: *const T, t_s_i_d_: ?*i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IDVBTuneRequest, @ptrCast(self)), t_s_i_d_);
            }
            pub inline fn putTSID(self: *const T, t_s_i_d_: i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IDVBTuneRequest, @ptrCast(self)), t_s_i_d_);
            }
            pub inline fn getSID(self: *const T, s_i_d_: ?*i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_SID(@as(*const IDVBTuneRequest, @ptrCast(self)), s_i_d_);
            }
            pub inline fn putSID(self: *const T, s_i_d_: i32) HRESULT {
                return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_SID(@as(*const IDVBTuneRequest, @ptrCast(self)), s_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequest_Value = Guid.initString("eb7d987f-8a01-42ad-b8ae-574deee44d1a");
pub const IID_IMPEG2TuneRequest = &IID_IMPEG2TuneRequest_Value;
pub const IMPEG2TuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2TuneRequest,
            t_s_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2TuneRequest,
            t_s_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgNo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2TuneRequest,
            prog_no: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgNo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2TuneRequest,
            prog_no: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuneRequest.MethodMixin(T);
            pub inline fn getTSID(self: *const T, t_s_i_d_: ?*i32) HRESULT {
                return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IMPEG2TuneRequest, @ptrCast(self)), t_s_i_d_);
            }
            pub inline fn putTSID(self: *const T, t_s_i_d_: i32) HRESULT {
                return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IMPEG2TuneRequest, @ptrCast(self)), t_s_i_d_);
            }
            pub inline fn getProgNo(self: *const T, prog_no_: ?*i32) HRESULT {
                return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).get_ProgNo(@as(*const IMPEG2TuneRequest, @ptrCast(self)), prog_no_);
            }
            pub inline fn putProgNo(self: *const T, prog_no_: i32) HRESULT {
                return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).put_ProgNo(@as(*const IMPEG2TuneRequest, @ptrCast(self)), prog_no_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestFactory_Value = Guid.initString("14e11abd-ee37-4893-9ea1-6964de933e39");
pub const IID_IMPEG2TuneRequestFactory = &IID_IMPEG2TuneRequestFactory_Value;
pub const IMPEG2TuneRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateTuneRequest: *const fn (
            self: *const IMPEG2TuneRequestFactory,
            tuning_space: ?*ITuningSpace,
            tune_request: ?*?*IMPEG2TuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn createTuneRequest(self: *const T, tuning_space_: ?*ITuningSpace, tune_request_: ?*?*IMPEG2TuneRequest) HRESULT {
                return @as(*const IMPEG2TuneRequestFactory.VTable, @ptrCast(self.vtable)).CreateTuneRequest(@as(*const IMPEG2TuneRequestFactory, @ptrCast(self)), tuning_space_, tune_request_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestSupport_Value = Guid.initString("1b9d5fc3-5bbc-4b6c-bb18-b9d10e3eeebf");
pub const IID_IMPEG2TuneRequestSupport = &IID_IMPEG2TuneRequestSupport_Value;
pub const IMPEG2TuneRequestSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITunerCap_Value = Guid.initString("e60dfa45-8d56-4e65-a8ab-d6be9412c249");
pub const IID_ITunerCap = &IID_ITunerCap_Value;
pub const ITunerCap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedNetworkTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITunerCap,
            ulc_network_types_max: u32,
            pulc_network_types: ?*u32,
            pguid_network_types: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedVideoFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITunerCap,
            pul_a_m_tuner_mode_type: ?*u32,
            pul_analog_video_standard: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuxInputCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITunerCap,
            pul_composite_count: ?*u32,
            pul_svideo_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupportedNetworkTypes(self: *const T, ulc_network_types_max_: u32, pulc_network_types_: ?*u32, pguid_network_types_: ?*Guid) HRESULT {
                return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_SupportedNetworkTypes(@as(*const ITunerCap, @ptrCast(self)), ulc_network_types_max_, pulc_network_types_, pguid_network_types_);
            }
            pub inline fn getSupportedVideoFormats(self: *const T, pul_a_m_tuner_mode_type_: ?*u32, pul_analog_video_standard_: ?*u32) HRESULT {
                return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_SupportedVideoFormats(@as(*const ITunerCap, @ptrCast(self)), pul_a_m_tuner_mode_type_, pul_analog_video_standard_);
            }
            pub inline fn getAuxInputCount(self: *const T, pul_composite_count_: ?*u32, pul_svideo_count_: ?*u32) HRESULT {
                return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_AuxInputCount(@as(*const ITunerCap, @ptrCast(self)), pul_composite_count_, pul_svideo_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITunerCapEx_Value = Guid.initString("ed3e0c66-18c8-4ea6-9300-f6841fdd35dc");
pub const IID_ITunerCapEx = &IID_ITunerCapEx_Value;
pub const ITunerCapEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Has608_708Caption: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITunerCapEx,
            pb_has_caption: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getHas608708Caption(self: *const T, pb_has_caption_: ?*i16) HRESULT {
                return @as(*const ITunerCapEx.VTable, @ptrCast(self.vtable)).get_Has608_708Caption(@as(*const ITunerCapEx, @ptrCast(self)), pb_has_caption_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuner_Value = Guid.initString("28c52640-018a-11d3-9d8e-00c04f72d980");
pub const IID_ITuner = &IID_ITuner_Value;
pub const ITuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            tuning_space: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            tuning_space: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTuningSpaces: *const fn (
            self: *const ITuner,
            pp_enum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuneRequest: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuneRequest: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            tune_request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: *const fn (
            self: *const ITuner,
            tune_request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredComponentTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            component_types: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredComponentTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            component_types: ?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ITuner,
            strength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TriggerSignalEvents: *const fn (
            self: *const ITuner,
            interval: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTuningSpace(self: *const T, tuning_space_: ?*?*ITuningSpace) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const ITuner, @ptrCast(self)), tuning_space_);
            }
            pub inline fn putTuningSpace(self: *const T, tuning_space_: ?*ITuningSpace) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const ITuner, @ptrCast(self)), tuning_space_);
            }
            pub inline fn enumTuningSpaces(self: *const T, pp_enum_: ?*?*IEnumTuningSpaces) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).EnumTuningSpaces(@as(*const ITuner, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getTuneRequest(self: *const T, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_TuneRequest(@as(*const ITuner, @ptrCast(self)), tune_request_);
            }
            pub inline fn putTuneRequest(self: *const T, tune_request_: ?*ITuneRequest) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_TuneRequest(@as(*const ITuner, @ptrCast(self)), tune_request_);
            }
            pub inline fn validate(self: *const T, tune_request_: ?*ITuneRequest) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).Validate(@as(*const ITuner, @ptrCast(self)), tune_request_);
            }
            pub inline fn getPreferredComponentTypes(self: *const T, component_types_: ?*?*IComponentTypes) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_PreferredComponentTypes(@as(*const ITuner, @ptrCast(self)), component_types_);
            }
            pub inline fn putPreferredComponentTypes(self: *const T, component_types_: ?*IComponentTypes) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_PreferredComponentTypes(@as(*const ITuner, @ptrCast(self)), component_types_);
            }
            pub inline fn getSignalStrength(self: *const T, strength_: ?*i32) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_SignalStrength(@as(*const ITuner, @ptrCast(self)), strength_);
            }
            pub inline fn triggerSignalEvents(self: *const T, interval_: i32) HRESULT {
                return @as(*const ITuner.VTable, @ptrCast(self.vtable)).TriggerSignalEvents(@as(*const ITuner, @ptrCast(self)), interval_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTuner_Value = Guid.initString("1dfd0a5c-0284-11d3-9d8e-00c04f72d980");
pub const IID_IScanningTuner = &IID_IScanningTuner_Value;
pub const IScanningTuner = extern struct {
    pub const VTable = extern struct {
        base: ITuner.VTable,
        SeekUp: *const fn (
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekDown: *const fn (
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanUp: *const fn (
            self: *const IScanningTuner,
            milliseconds_pause: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanDown: *const fn (
            self: *const IScanningTuner,
            milliseconds_pause: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoProgram: *const fn (
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuner.MethodMixin(T);
            pub inline fn seekUp(self: *const T) HRESULT {
                return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).SeekUp(@as(*const IScanningTuner, @ptrCast(self)));
            }
            pub inline fn seekDown(self: *const T) HRESULT {
                return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).SeekDown(@as(*const IScanningTuner, @ptrCast(self)));
            }
            pub inline fn scanUp(self: *const T, milliseconds_pause_: i32) HRESULT {
                return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).ScanUp(@as(*const IScanningTuner, @ptrCast(self)), milliseconds_pause_);
            }
            pub inline fn scanDown(self: *const T, milliseconds_pause_: i32) HRESULT {
                return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).ScanDown(@as(*const IScanningTuner, @ptrCast(self)), milliseconds_pause_);
            }
            pub inline fn autoProgram(self: *const T) HRESULT {
                return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).AutoProgram(@as(*const IScanningTuner, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTunerEx_Value = Guid.initString("04bbd195-0e2d-4593-9bd5-4f908bc33cf5");
pub const IID_IScanningTunerEx = &IID_IScanningTunerEx_Value;
pub const IScanningTunerEx = extern struct {
    pub const VTable = extern struct {
        base: IScanningTuner.VTable,
        GetCurrentLocator: *const fn (
            self: *const IScanningTunerEx,
            p_i_locator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformExhaustiveScan: *const fn (
            self: *const IScanningTunerEx,
            dw_lower_freq: i32,
            dw_higher_freq: i32,
            b_fine_tune: i16,
            h_event: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentScan: *const fn (
            self: *const IScanningTunerEx,
            pcurrent_freq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeCurrentScan: *const fn (
            self: *const IScanningTunerEx,
            h_event: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTunerScanningCapability: *const fn (
            self: *const IScanningTunerEx,
            hardware_assisted_scanning: ?*i32,
            num_standards_supported: ?*i32,
            broadcast_standards: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTunerStatus: *const fn (
            self: *const IScanningTunerEx,
            seconds_left: ?*i32,
            current_lock_type: ?*i32,
            auto_detect: ?*i32,
            current_freq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTunerStandardCapability: *const fn (
            self: *const IScanningTunerEx,
            current_broadcast_standard: Guid,
            settling_time: ?*i32,
            tv_standards_supported: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScanSignalTypeFilter: *const fn (
            self: *const IScanningTunerEx,
            scan_modulation_types: i32,
            analog_video_standard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IScanningTuner.MethodMixin(T);
            pub inline fn getCurrentLocator(self: *const T, p_i_locator_: ?*?*ILocator) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetCurrentLocator(@as(*const IScanningTunerEx, @ptrCast(self)), p_i_locator_);
            }
            pub inline fn performExhaustiveScan(self: *const T, dw_lower_freq_: i32, dw_higher_freq_: i32, b_fine_tune_: i16, h_event_: usize) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).PerformExhaustiveScan(@as(*const IScanningTunerEx, @ptrCast(self)), dw_lower_freq_, dw_higher_freq_, b_fine_tune_, h_event_);
            }
            pub inline fn terminateCurrentScan(self: *const T, pcurrent_freq_: ?*i32) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).TerminateCurrentScan(@as(*const IScanningTunerEx, @ptrCast(self)), pcurrent_freq_);
            }
            pub inline fn resumeCurrentScan(self: *const T, h_event_: usize) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).ResumeCurrentScan(@as(*const IScanningTunerEx, @ptrCast(self)), h_event_);
            }
            pub inline fn getTunerScanningCapability(self: *const T, hardware_assisted_scanning_: ?*i32, num_standards_supported_: ?*i32, broadcast_standards_: ?*Guid) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetTunerScanningCapability(@as(*const IScanningTunerEx, @ptrCast(self)), hardware_assisted_scanning_, num_standards_supported_, broadcast_standards_);
            }
            pub inline fn getTunerStatus(self: *const T, seconds_left_: ?*i32, current_lock_type_: ?*i32, auto_detect_: ?*i32, current_freq_: ?*i32) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetTunerStatus(@as(*const IScanningTunerEx, @ptrCast(self)), seconds_left_, current_lock_type_, auto_detect_, current_freq_);
            }
            pub inline fn getCurrentTunerStandardCapability(self: *const T, current_broadcast_standard_: Guid, settling_time_: ?*i32, tv_standards_supported_: ?*i32) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetCurrentTunerStandardCapability(@as(*const IScanningTunerEx, @ptrCast(self)), current_broadcast_standard_, settling_time_, tv_standards_supported_);
            }
            pub inline fn setScanSignalTypeFilter(self: *const T, scan_modulation_types_: i32, analog_video_standard_: i32) HRESULT {
                return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).SetScanSignalTypeFilter(@as(*const IScanningTunerEx, @ptrCast(self)), scan_modulation_types_, analog_video_standard_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentType_Value = Guid.initString("6a340dc0-0311-11d3-9d8e-00c04f72d980");
pub const IID_IComponentType = &IID_IComponentType_Value;
pub const IComponentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            category: ?*ComponentCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            category: ComponentCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaMajorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_major_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaMajorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_major_type: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaMajorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_major_type_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaMajorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_major_type_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaSubType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_sub_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaSubType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_sub_type: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaSubType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_sub_type_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaSubType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_sub_type_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaFormatType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_format_type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaFormatType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_format_type: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaFormatType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_format_type_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaFormatType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_format_type_guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentType,
            media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IComponentType,
            new_c_t: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCategory(self: *const T, category_: ?*ComponentCategory) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IComponentType, @ptrCast(self)), category_);
            }
            pub inline fn putCategory(self: *const T, category_: ComponentCategory) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_Category(@as(*const IComponentType, @ptrCast(self)), category_);
            }
            pub inline fn getMediaMajorType(self: *const T, media_major_type_: ?*?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaMajorType(@as(*const IComponentType, @ptrCast(self)), media_major_type_);
            }
            pub inline fn putMediaMajorType(self: *const T, media_major_type_: ?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaMajorType(@as(*const IComponentType, @ptrCast(self)), media_major_type_);
            }
            pub inline fn getMediaMajorType1(self: *const T, media_major_type_guid_: ?*Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaMajorType(@as(*const IComponentType, @ptrCast(self)), media_major_type_guid_);
            }
            pub inline fn putMediaMajorType1(self: *const T, media_major_type_guid_: ?*const Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaMajorType(@as(*const IComponentType, @ptrCast(self)), media_major_type_guid_);
            }
            pub inline fn getMediaSubType(self: *const T, media_sub_type_: ?*?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaSubType(@as(*const IComponentType, @ptrCast(self)), media_sub_type_);
            }
            pub inline fn putMediaSubType(self: *const T, media_sub_type_: ?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaSubType(@as(*const IComponentType, @ptrCast(self)), media_sub_type_);
            }
            pub inline fn getMediaSubType1(self: *const T, media_sub_type_guid_: ?*Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaSubType(@as(*const IComponentType, @ptrCast(self)), media_sub_type_guid_);
            }
            pub inline fn putMediaSubType1(self: *const T, media_sub_type_guid_: ?*const Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaSubType(@as(*const IComponentType, @ptrCast(self)), media_sub_type_guid_);
            }
            pub inline fn getMediaFormatType(self: *const T, media_format_type_: ?*?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaFormatType(@as(*const IComponentType, @ptrCast(self)), media_format_type_);
            }
            pub inline fn putMediaFormatType(self: *const T, media_format_type_: ?BSTR) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaFormatType(@as(*const IComponentType, @ptrCast(self)), media_format_type_);
            }
            pub inline fn getMediaFormatType1(self: *const T, media_format_type_guid_: ?*Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaFormatType(@as(*const IComponentType, @ptrCast(self)), media_format_type_guid_);
            }
            pub inline fn putMediaFormatType1(self: *const T, media_format_type_guid_: ?*const Guid) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaFormatType(@as(*const IComponentType, @ptrCast(self)), media_format_type_guid_);
            }
            pub inline fn getMediaType(self: *const T, media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const IComponentType, @ptrCast(self)), media_type_);
            }
            pub inline fn putMediaType(self: *const T, media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaType(@as(*const IComponentType, @ptrCast(self)), media_type_);
            }
            pub inline fn clone(self: *const T, new_c_t_: ?*?*IComponentType) HRESULT {
                return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentType, @ptrCast(self)), new_c_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILanguageComponentType_Value = Guid.initString("b874c8ba-0fa2-11d3-9d8e-00c04f72d980");
pub const IID_ILanguageComponentType = &IID_ILanguageComponentType_Value;
pub const ILanguageComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILanguageComponentType,
            lang_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LangID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILanguageComponentType,
            lang_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IComponentType.MethodMixin(T);
            pub inline fn getLangID(self: *const T, lang_i_d_: ?*i32) HRESULT {
                return @as(*const ILanguageComponentType.VTable, @ptrCast(self.vtable)).get_LangID(@as(*const ILanguageComponentType, @ptrCast(self)), lang_i_d_);
            }
            pub inline fn putLangID(self: *const T, lang_i_d_: i32) HRESULT {
                return @as(*const ILanguageComponentType.VTable, @ptrCast(self.vtable)).put_LangID(@as(*const ILanguageComponentType, @ptrCast(self)), lang_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2ComponentType_Value = Guid.initString("2c073d84-b51c-48c9-aa9f-68971e1f6e38");
pub const IID_IMPEG2ComponentType = &IID_IMPEG2ComponentType_Value;
pub const IMPEG2ComponentType = extern struct {
    pub const VTable = extern struct {
        base: ILanguageComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2ComponentType,
            m_p2_stream_type: ?*MPEG2StreamType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StreamType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2ComponentType,
            m_p2_stream_type: MPEG2StreamType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ILanguageComponentType.MethodMixin(T);
            pub inline fn getStreamType(self: *const T, m_p2_stream_type_: ?*MPEG2StreamType) HRESULT {
                return @as(*const IMPEG2ComponentType.VTable, @ptrCast(self.vtable)).get_StreamType(@as(*const IMPEG2ComponentType, @ptrCast(self)), m_p2_stream_type_);
            }
            pub inline fn putStreamType(self: *const T, m_p2_stream_type_: MPEG2StreamType) HRESULT {
                return @as(*const IMPEG2ComponentType.VTable, @ptrCast(self.vtable)).put_StreamType(@as(*const IMPEG2ComponentType, @ptrCast(self)), m_p2_stream_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCComponentType_Value = Guid.initString("fc189e4d-7bd4-4125-b3b3-3a76a332cc96");
pub const IID_IATSCComponentType = &IID_IATSCComponentType_Value;
pub const IATSCComponentType = extern struct {
    pub const VTable = extern struct {
        base: IMPEG2ComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCComponentType,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCComponentType,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMPEG2ComponentType.MethodMixin(T);
            pub inline fn getFlags(self: *const T, flags_: ?*i32) HRESULT {
                return @as(*const IATSCComponentType.VTable, @ptrCast(self.vtable)).get_Flags(@as(*const IATSCComponentType, @ptrCast(self)), flags_);
            }
            pub inline fn putFlags(self: *const T, flags_: i32) HRESULT {
                return @as(*const IATSCComponentType.VTable, @ptrCast(self.vtable)).put_Flags(@as(*const IATSCComponentType, @ptrCast(self)), flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponentTypes_Value = Guid.initString("8a674b4a-1f63-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponentTypes = &IID_IEnumComponentTypes_Value;
pub const IEnumComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumComponentTypes,
            celt: u32,
            rgelt: [*]?*IComponentType,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumComponentTypes,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumComponentTypes,
            pp_enum: ?*?*IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IComponentType, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumComponentTypes, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumComponentTypes, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumComponentTypes, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumComponentTypes) HRESULT {
                return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumComponentTypes, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentTypes_Value = Guid.initString("0dc13d4a-0313-11d3-9d8e-00c04f72d980");
pub const IID_IComponentTypes = &IID_IComponentTypes_Value;
pub const IComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentTypes,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentTypes,
            pp_new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponentTypes: *const fn (
            self: *const IComponentTypes,
            pp_new_enum: ?*?*IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentTypes,
            index: VARIANT,
            component_type: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentTypes,
            index: VARIANT,
            component_type: ?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IComponentTypes,
            component_type: ?*IComponentType,
            new_index: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IComponentTypes,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IComponentTypes,
            new_list: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponentTypes, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, pp_new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponentTypes, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn enumComponentTypes(self: *const T, pp_new_enum_: ?*?*IEnumComponentTypes) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).EnumComponentTypes(@as(*const IComponentTypes, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn getItem(self: *const T, index_: VARIANT, component_type_: ?*?*IComponentType) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponentTypes, @ptrCast(self)), index_, component_type_);
            }
            pub inline fn putItem(self: *const T, index_: VARIANT, component_type_: ?*IComponentType) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IComponentTypes, @ptrCast(self)), index_, component_type_);
            }
            pub inline fn add(self: *const T, component_type_: ?*IComponentType, new_index_: ?*VARIANT) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponentTypes, @ptrCast(self)), component_type_, new_index_);
            }
            pub inline fn remove(self: *const T, index_: VARIANT) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponentTypes, @ptrCast(self)), index_);
            }
            pub inline fn clone(self: *const T, new_list_: ?*?*IComponentTypes) HRESULT {
                return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentTypes, @ptrCast(self)), new_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent_Value = Guid.initString("1a5576fc-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponent = &IID_IComponent_Value;
pub const IComponent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            c_t: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            c_t: ?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DescLangID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            lang_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DescLangID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            lang_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            status: ?*ComponentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            status: ComponentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponent,
            description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IComponent,
            new_component: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getType(self: *const T, c_t_: ?*?*IComponentType) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IComponent, @ptrCast(self)), c_t_);
            }
            pub inline fn putType(self: *const T, c_t_: ?*IComponentType) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Type(@as(*const IComponent, @ptrCast(self)), c_t_);
            }
            pub inline fn getDescLangID(self: *const T, lang_i_d_: ?*i32) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_DescLangID(@as(*const IComponent, @ptrCast(self)), lang_i_d_);
            }
            pub inline fn putDescLangID(self: *const T, lang_i_d_: i32) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_DescLangID(@as(*const IComponent, @ptrCast(self)), lang_i_d_);
            }
            pub inline fn getStatus(self: *const T, status_: ?*ComponentStatus) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IComponent, @ptrCast(self)), status_);
            }
            pub inline fn putStatus(self: *const T, status_: ComponentStatus) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Status(@as(*const IComponent, @ptrCast(self)), status_);
            }
            pub inline fn getDescription(self: *const T, description_: ?*?BSTR) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IComponent, @ptrCast(self)), description_);
            }
            pub inline fn putDescription(self: *const T, description_: ?BSTR) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Description(@as(*const IComponent, @ptrCast(self)), description_);
            }
            pub inline fn clone(self: *const T, new_component_: ?*?*IComponent) HRESULT {
                return @as(*const IComponent.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponent, @ptrCast(self)), new_component_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogAudioComponentType_Value = Guid.initString("2cfeb2a8-1787-4a24-a941-c6eaec39c842");
pub const IID_IAnalogAudioComponentType = &IID_IAnalogAudioComponentType_Value;
pub const IAnalogAudioComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnalogAudioMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogAudioComponentType,
            mode: ?*TVAudioMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AnalogAudioMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogAudioComponentType,
            mode: TVAudioMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IComponentType.MethodMixin(T);
            pub inline fn getAnalogAudioMode(self: *const T, mode_: ?*TVAudioMode) HRESULT {
                return @as(*const IAnalogAudioComponentType.VTable, @ptrCast(self.vtable)).get_AnalogAudioMode(@as(*const IAnalogAudioComponentType, @ptrCast(self)), mode_);
            }
            pub inline fn putAnalogAudioMode(self: *const T, mode_: TVAudioMode) HRESULT {
                return @as(*const IAnalogAudioComponentType.VTable, @ptrCast(self.vtable)).put_AnalogAudioMode(@as(*const IAnalogAudioComponentType, @ptrCast(self)), mode_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2Component_Value = Guid.initString("1493e353-1eb6-473c-802d-8e6b8ec9d2a9");
pub const IID_IMPEG2Component = &IID_IMPEG2Component_Value;
pub const IMPEG2Component = extern struct {
    pub const VTable = extern struct {
        base: IComponent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            p_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            p_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PCRPID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            p_c_r_p_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PCRPID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            p_c_r_p_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            program_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMPEG2Component,
            program_number: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IComponent.MethodMixin(T);
            pub inline fn getPID(self: *const T, p_i_d_: ?*i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_PID(@as(*const IMPEG2Component, @ptrCast(self)), p_i_d_);
            }
            pub inline fn putPID(self: *const T, p_i_d_: i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_PID(@as(*const IMPEG2Component, @ptrCast(self)), p_i_d_);
            }
            pub inline fn getPCRPID(self: *const T, p_c_r_p_i_d_: ?*i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_PCRPID(@as(*const IMPEG2Component, @ptrCast(self)), p_c_r_p_i_d_);
            }
            pub inline fn putPCRPID(self: *const T, p_c_r_p_i_d_: i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_PCRPID(@as(*const IMPEG2Component, @ptrCast(self)), p_c_r_p_i_d_);
            }
            pub inline fn getProgramNumber(self: *const T, program_number_: ?*i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_ProgramNumber(@as(*const IMPEG2Component, @ptrCast(self)), program_number_);
            }
            pub inline fn putProgramNumber(self: *const T, program_number_: i32) HRESULT {
                return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_ProgramNumber(@as(*const IMPEG2Component, @ptrCast(self)), program_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponents_Value = Guid.initString("2a6e2939-2595-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponents = &IID_IEnumComponents_Value;
pub const IEnumComponents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumComponents,
            celt: u32,
            rgelt: [*]?*IComponent,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumComponents,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumComponents,
            pp_enum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IComponent, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumComponents, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumComponents, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumComponents, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumComponents) HRESULT {
                return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumComponents, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponents_Value = Guid.initString("39a48091-fffe-4182-a161-3ff802640e26");
pub const IID_IComponents = &IID_IComponents_Value;
pub const IComponents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponents,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponents,
            pp_new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponents: *const fn (
            self: *const IComponents,
            pp_new_enum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponents,
            index: VARIANT,
            pp_component: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IComponents,
            component: ?*IComponent,
            new_index: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IComponents,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IComponents,
            new_list: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponents,
            index: VARIANT,
            pp_component: ?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponents, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, pp_new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponents, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn enumComponents(self: *const T, pp_new_enum_: ?*?*IEnumComponents) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).EnumComponents(@as(*const IComponents, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn getItem(self: *const T, index_: VARIANT, pp_component_: ?*?*IComponent) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponents, @ptrCast(self)), index_, pp_component_);
            }
            pub inline fn add(self: *const T, component_: ?*IComponent, new_index_: ?*VARIANT) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponents, @ptrCast(self)), component_, new_index_);
            }
            pub inline fn remove(self: *const T, index_: VARIANT) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponents, @ptrCast(self)), index_);
            }
            pub inline fn clone(self: *const T, new_list_: ?*?*IComponents) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponents, @ptrCast(self)), new_list_);
            }
            pub inline fn putItem(self: *const T, index_: VARIANT, pp_component_: ?*IComponent) HRESULT {
                return @as(*const IComponents.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IComponents, @ptrCast(self)), index_, pp_component_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IComponentsOld_Value = Guid.initString("fcd01846-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponentsOld = &IID_IComponentsOld_Value;
pub const IComponentsOld = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentsOld,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentsOld,
            pp_new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponents: *const fn (
            self: *const IComponentsOld,
            pp_new_enum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IComponentsOld,
            index: VARIANT,
            pp_component: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IComponentsOld,
            component: ?*IComponent,
            new_index: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IComponentsOld,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IComponentsOld,
            new_list: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponentsOld, @ptrCast(self)), count_);
            }
            pub inline fn getNewEnum(self: *const T, pp_new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponentsOld, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn enumComponents(self: *const T, pp_new_enum_: ?*?*IEnumComponents) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).EnumComponents(@as(*const IComponentsOld, @ptrCast(self)), pp_new_enum_);
            }
            pub inline fn getItem(self: *const T, index_: VARIANT, pp_component_: ?*?*IComponent) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponentsOld, @ptrCast(self)), index_, pp_component_);
            }
            pub inline fn add(self: *const T, component_: ?*IComponent, new_index_: ?*VARIANT) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponentsOld, @ptrCast(self)), component_, new_index_);
            }
            pub inline fn remove(self: *const T, index_: VARIANT) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponentsOld, @ptrCast(self)), index_);
            }
            pub inline fn clone(self: *const T, new_list_: ?*?*IComponents) HRESULT {
                return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentsOld, @ptrCast(self)), new_list_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILocator_Value = Guid.initString("286d7f89-760c-4f89-80c4-66841d2507aa");
pub const IID_ILocator = &IID_ILocator_Value;
pub const ILocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CarrierFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            frequency: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CarrierFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            frequency: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            f_e_c: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modulation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            modulation: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Modulation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            modulation: ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ILocator,
            rate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ILocator,
            new_locator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCarrierFrequency(self: *const T, frequency_: ?*i32) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_CarrierFrequency(@as(*const ILocator, @ptrCast(self)), frequency_);
            }
            pub inline fn putCarrierFrequency(self: *const T, frequency_: i32) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_CarrierFrequency(@as(*const ILocator, @ptrCast(self)), frequency_);
            }
            pub inline fn getInnerFEC(self: *const T, f_e_c_: ?*FECMethod) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_InnerFEC(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putInnerFEC(self: *const T, f_e_c_: FECMethod) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_InnerFEC(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getInnerFECRate(self: *const T, f_e_c_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_InnerFECRate(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putInnerFECRate(self: *const T, f_e_c_: BinaryConvolutionCodeRate) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_InnerFECRate(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getOuterFEC(self: *const T, f_e_c_: ?*FECMethod) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_OuterFEC(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putOuterFEC(self: *const T, f_e_c_: FECMethod) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_OuterFEC(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getOuterFECRate(self: *const T, f_e_c_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_OuterFECRate(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putOuterFECRate(self: *const T, f_e_c_: BinaryConvolutionCodeRate) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_OuterFECRate(@as(*const ILocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getModulation(self: *const T, modulation_: ?*ModulationType) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_Modulation(@as(*const ILocator, @ptrCast(self)), modulation_);
            }
            pub inline fn putModulation(self: *const T, modulation_: ModulationType) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_Modulation(@as(*const ILocator, @ptrCast(self)), modulation_);
            }
            pub inline fn getSymbolRate(self: *const T, rate_: ?*i32) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_SymbolRate(@as(*const ILocator, @ptrCast(self)), rate_);
            }
            pub inline fn putSymbolRate(self: *const T, rate_: i32) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_SymbolRate(@as(*const ILocator, @ptrCast(self)), rate_);
            }
            pub inline fn clone(self: *const T, new_locator_: ?*?*ILocator) HRESULT {
                return @as(*const ILocator.VTable, @ptrCast(self.vtable)).Clone(@as(*const ILocator, @ptrCast(self)), new_locator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogLocator_Value = Guid.initString("34d1f26b-e339-430d-abce-738cb48984dc");
pub const IID_IAnalogLocator = &IID_IAnalogLocator_Value;
pub const IAnalogLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoStandard: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogLocator,
            a_v_s: ?*AnalogVideoStandard,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoStandard: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IAnalogLocator,
            a_v_s: AnalogVideoStandard,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ILocator.MethodMixin(T);
            pub inline fn getVideoStandard(self: *const T, a_v_s_: ?*AnalogVideoStandard) HRESULT {
                return @as(*const IAnalogLocator.VTable, @ptrCast(self.vtable)).get_VideoStandard(@as(*const IAnalogLocator, @ptrCast(self)), a_v_s_);
            }
            pub inline fn putVideoStandard(self: *const T, a_v_s_: AnalogVideoStandard) HRESULT {
                return @as(*const IAnalogLocator.VTable, @ptrCast(self.vtable)).put_VideoStandard(@as(*const IAnalogLocator, @ptrCast(self)), a_v_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalLocator_Value = Guid.initString("19b595d8-839a-47f0-96df-4f194f3c768c");
pub const IID_IDigitalLocator = &IID_IDigitalLocator_Value;
pub const IDigitalLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ILocator.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCLocator_Value = Guid.initString("bf8d986f-8c2b-4131-94d7-4d3d9fcc21ef");
pub const IID_IATSCLocator = &IID_IATSCLocator_Value;
pub const IATSCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator,
            physical_channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalChannel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator,
            physical_channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator,
            t_s_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator,
            t_s_i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDigitalLocator.MethodMixin(T);
            pub inline fn getPhysicalChannel(self: *const T, physical_channel_: ?*i32) HRESULT {
                return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).get_PhysicalChannel(@as(*const IATSCLocator, @ptrCast(self)), physical_channel_);
            }
            pub inline fn putPhysicalChannel(self: *const T, physical_channel_: i32) HRESULT {
                return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).put_PhysicalChannel(@as(*const IATSCLocator, @ptrCast(self)), physical_channel_);
            }
            pub inline fn getTSID(self: *const T, t_s_i_d_: ?*i32) HRESULT {
                return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IATSCLocator, @ptrCast(self)), t_s_i_d_);
            }
            pub inline fn putTSID(self: *const T, t_s_i_d_: i32) HRESULT {
                return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IATSCLocator, @ptrCast(self)), t_s_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IATSCLocator2_Value = Guid.initString("612aa885-66cf-4090-ba0a-566f5312e4ca");
pub const IID_IATSCLocator2 = &IID_IATSCLocator2_Value;
pub const IATSCLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator2,
            program_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IATSCLocator2,
            program_number: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IATSCLocator.MethodMixin(T);
            pub inline fn getProgramNumber(self: *const T, program_number_: ?*i32) HRESULT {
                return @as(*const IATSCLocator2.VTable, @ptrCast(self.vtable)).get_ProgramNumber(@as(*const IATSCLocator2, @ptrCast(self)), program_number_);
            }
            pub inline fn putProgramNumber(self: *const T, program_number_: i32) HRESULT {
                return @as(*const IATSCLocator2.VTable, @ptrCast(self.vtable)).put_ProgramNumber(@as(*const IATSCLocator2, @ptrCast(self)), program_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableLocator_Value = Guid.initString("48f66a11-171a-419a-9525-beeecd51584c");
pub const IID_IDigitalCableLocator = &IID_IDigitalCableLocator_Value;
pub const IDigitalCableLocator = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IATSCLocator2.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTLocator_Value = Guid.initString("8664da16-dda2-42ac-926a-c18f9127c302");
pub const IID_IDVBTLocator = &IID_IDVBTLocator_Value;
pub const IDVBTLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            band_width_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            bandwidth_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            f_e_c: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFEC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            f_e_c: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            f_e_c: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFECRate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            f_e_c: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HAlpha: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            alpha: ?*HierarchyAlpha,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HAlpha: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            alpha: HierarchyAlpha,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guard: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            g_i: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guard: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            g_i: GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            mode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            mode: TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OtherFrequencyInUse: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            other_frequency_in_use_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OtherFrequencyInUse: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator,
            other_frequency_in_use_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDigitalLocator.MethodMixin(T);
            pub inline fn getBandwidth(self: *const T, band_width_val_: ?*i32) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IDVBTLocator, @ptrCast(self)), band_width_val_);
            }
            pub inline fn putBandwidth(self: *const T, bandwidth_val_: i32) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Bandwidth(@as(*const IDVBTLocator, @ptrCast(self)), bandwidth_val_);
            }
            pub inline fn getLPInnerFEC(self: *const T, f_e_c_: ?*FECMethod) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_LPInnerFEC(@as(*const IDVBTLocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putLPInnerFEC(self: *const T, f_e_c_: FECMethod) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_LPInnerFEC(@as(*const IDVBTLocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getLPInnerFECRate(self: *const T, f_e_c_: ?*BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_LPInnerFECRate(@as(*const IDVBTLocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn putLPInnerFECRate(self: *const T, f_e_c_: BinaryConvolutionCodeRate) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_LPInnerFECRate(@as(*const IDVBTLocator, @ptrCast(self)), f_e_c_);
            }
            pub inline fn getHAlpha(self: *const T, alpha_: ?*HierarchyAlpha) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_HAlpha(@as(*const IDVBTLocator, @ptrCast(self)), alpha_);
            }
            pub inline fn putHAlpha(self: *const T, alpha_: HierarchyAlpha) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_HAlpha(@as(*const IDVBTLocator, @ptrCast(self)), alpha_);
            }
            pub inline fn getGuard(self: *const T, g_i_: ?*GuardInterval) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Guard(@as(*const IDVBTLocator, @ptrCast(self)), g_i_);
            }
            pub inline fn putGuard(self: *const T, g_i_: GuardInterval) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Guard(@as(*const IDVBTLocator, @ptrCast(self)), g_i_);
            }
            pub inline fn getMode(self: *const T, mode_: ?*TransmissionMode) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IDVBTLocator, @ptrCast(self)), mode_);
            }
            pub inline fn putMode(self: *const T, mode_: TransmissionMode) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IDVBTLocator, @ptrCast(self)), mode_);
            }
            pub inline fn getOtherFrequencyInUse(self: *const T, other_frequency_in_use_val_: ?*i16) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_OtherFrequencyInUse(@as(*const IDVBTLocator, @ptrCast(self)), other_frequency_in_use_val_);
            }
            pub inline fn putOtherFrequencyInUse(self: *const T, other_frequency_in_use_val_: i16) HRESULT {
                return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_OtherFrequencyInUse(@as(*const IDVBTLocator, @ptrCast(self)), other_frequency_in_use_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBTLocator2_Value = Guid.initString("448a2edf-ae95-4b43-a3cc-747843c453d4");
pub const IID_IDVBTLocator2 = &IID_IDVBTLocator2_Value;
pub const IDVBTLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalLayerPipeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator2,
            physical_layer_pipe_id_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalLayerPipeId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBTLocator2,
            physical_layer_pipe_id_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVBTLocator.MethodMixin(T);
            pub inline fn getPhysicalLayerPipeId(self: *const T, physical_layer_pipe_id_val_: ?*i32) HRESULT {
                return @as(*const IDVBTLocator2.VTable, @ptrCast(self.vtable)).get_PhysicalLayerPipeId(@as(*const IDVBTLocator2, @ptrCast(self)), physical_layer_pipe_id_val_);
            }
            pub inline fn putPhysicalLayerPipeId(self: *const T, physical_layer_pipe_id_val_: i32) HRESULT {
                return @as(*const IDVBTLocator2.VTable, @ptrCast(self.vtable)).put_PhysicalLayerPipeId(@as(*const IDVBTLocator2, @ptrCast(self)), physical_layer_pipe_id_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSLocator_Value = Guid.initString("3d7c353c-0d04-45f1-a742-f97cc1188dc8");
pub const IID_IDVBSLocator = &IID_IDVBSLocator_Value;
pub const IDVBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPolarisation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            polarisation_val: ?*Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPolarisation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            polarisation_val: Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WestPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            west_longitude: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WestPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            west_longitude: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OrbitalPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            longitude: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OrbitalPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            longitude: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Azimuth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            azimuth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Azimuth: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            azimuth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Elevation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            elevation: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Elevation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator,
            elevation: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDigitalLocator.MethodMixin(T);
            pub inline fn getSignalPolarisation(self: *const T, polarisation_val_: ?*Polarisation) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_SignalPolarisation(@as(*const IDVBSLocator, @ptrCast(self)), polarisation_val_);
            }
            pub inline fn putSignalPolarisation(self: *const T, polarisation_val_: Polarisation) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_SignalPolarisation(@as(*const IDVBSLocator, @ptrCast(self)), polarisation_val_);
            }
            pub inline fn getWestPosition(self: *const T, west_longitude_: ?*i16) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_WestPosition(@as(*const IDVBSLocator, @ptrCast(self)), west_longitude_);
            }
            pub inline fn putWestPosition(self: *const T, west_longitude_: i16) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_WestPosition(@as(*const IDVBSLocator, @ptrCast(self)), west_longitude_);
            }
            pub inline fn getOrbitalPosition(self: *const T, longitude_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_OrbitalPosition(@as(*const IDVBSLocator, @ptrCast(self)), longitude_);
            }
            pub inline fn putOrbitalPosition(self: *const T, longitude_: i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_OrbitalPosition(@as(*const IDVBSLocator, @ptrCast(self)), longitude_);
            }
            pub inline fn getAzimuth(self: *const T, azimuth_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_Azimuth(@as(*const IDVBSLocator, @ptrCast(self)), azimuth_);
            }
            pub inline fn putAzimuth(self: *const T, azimuth_: i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_Azimuth(@as(*const IDVBSLocator, @ptrCast(self)), azimuth_);
            }
            pub inline fn getElevation(self: *const T, elevation_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_Elevation(@as(*const IDVBSLocator, @ptrCast(self)), elevation_);
            }
            pub inline fn putElevation(self: *const T, elevation_: i32) HRESULT {
                return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_Elevation(@as(*const IDVBSLocator, @ptrCast(self)), elevation_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBSLocator2_Value = Guid.initString("6044634a-1733-4f99-b982-5fb12afce4f0");
pub const IID_IDVBSLocator2 = &IID_IDVBSLocator2_Value;
pub const IDVBSLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiseqLNBSource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            diseq_l_n_b_source_val: ?*LNB_Source,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            diseq_l_n_b_source_val: LNB_Source,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideLow: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_oscillator_override_low_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideLow: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_oscillator_override_low_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideHigh: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_oscillator_override_high_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideHigh: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_oscillator_override_high_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalLNBSwitchOverride: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_l_n_b_switch_override_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalLNBSwitchOverride: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_l_n_b_switch_override_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalSpectralInversionOverride: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_spectral_inversion_override_val: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalSpectralInversionOverride: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            local_spectral_inversion_override_val: SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalRollOff: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            roll_off_val: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalRollOff: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            roll_off_val: RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPilot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            pilot_val: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPilot: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDVBSLocator2,
            pilot_val: Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVBSLocator.MethodMixin(T);
            pub inline fn getDiseqLNBSource(self: *const T, diseq_l_n_b_source_val_: ?*LNB_Source) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_DiseqLNBSource(@as(*const IDVBSLocator2, @ptrCast(self)), diseq_l_n_b_source_val_);
            }
            pub inline fn putDiseqLNBSource(self: *const T, diseq_l_n_b_source_val_: LNB_Source) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_DiseqLNBSource(@as(*const IDVBSLocator2, @ptrCast(self)), diseq_l_n_b_source_val_);
            }
            pub inline fn getLocalOscillatorOverrideLow(self: *const T, local_oscillator_override_low_val_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalOscillatorOverrideLow(@as(*const IDVBSLocator2, @ptrCast(self)), local_oscillator_override_low_val_);
            }
            pub inline fn putLocalOscillatorOverrideLow(self: *const T, local_oscillator_override_low_val_: i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalOscillatorOverrideLow(@as(*const IDVBSLocator2, @ptrCast(self)), local_oscillator_override_low_val_);
            }
            pub inline fn getLocalOscillatorOverrideHigh(self: *const T, local_oscillator_override_high_val_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalOscillatorOverrideHigh(@as(*const IDVBSLocator2, @ptrCast(self)), local_oscillator_override_high_val_);
            }
            pub inline fn putLocalOscillatorOverrideHigh(self: *const T, local_oscillator_override_high_val_: i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalOscillatorOverrideHigh(@as(*const IDVBSLocator2, @ptrCast(self)), local_oscillator_override_high_val_);
            }
            pub inline fn getLocalLNBSwitchOverride(self: *const T, local_l_n_b_switch_override_val_: ?*i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalLNBSwitchOverride(@as(*const IDVBSLocator2, @ptrCast(self)), local_l_n_b_switch_override_val_);
            }
            pub inline fn putLocalLNBSwitchOverride(self: *const T, local_l_n_b_switch_override_val_: i32) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalLNBSwitchOverride(@as(*const IDVBSLocator2, @ptrCast(self)), local_l_n_b_switch_override_val_);
            }
            pub inline fn getLocalSpectralInversionOverride(self: *const T, local_spectral_inversion_override_val_: ?*SpectralInversion) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalSpectralInversionOverride(@as(*const IDVBSLocator2, @ptrCast(self)), local_spectral_inversion_override_val_);
            }
            pub inline fn putLocalSpectralInversionOverride(self: *const T, local_spectral_inversion_override_val_: SpectralInversion) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalSpectralInversionOverride(@as(*const IDVBSLocator2, @ptrCast(self)), local_spectral_inversion_override_val_);
            }
            pub inline fn getSignalRollOff(self: *const T, roll_off_val_: ?*RollOff) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_SignalRollOff(@as(*const IDVBSLocator2, @ptrCast(self)), roll_off_val_);
            }
            pub inline fn putSignalRollOff(self: *const T, roll_off_val_: RollOff) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_SignalRollOff(@as(*const IDVBSLocator2, @ptrCast(self)), roll_off_val_);
            }
            pub inline fn getSignalPilot(self: *const T, pilot_val_: ?*Pilot) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_SignalPilot(@as(*const IDVBSLocator2, @ptrCast(self)), pilot_val_);
            }
            pub inline fn putSignalPilot(self: *const T, pilot_val_: Pilot) HRESULT {
                return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_SignalPilot(@as(*const IDVBSLocator2, @ptrCast(self)), pilot_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBCLocator_Value = Guid.initString("6e42f36e-1dd2-43c4-9f78-69d25ae39034");
pub const IID_IDVBCLocator = &IID_IDVBCLocator_Value;
pub const IDVBCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDigitalLocator.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IISDBSLocator_Value = Guid.initString("c9897087-e29c-473f-9e4b-7072123dea14");
pub const IID_IISDBSLocator = &IID_IISDBSLocator_Value;
pub const IISDBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVBSLocator.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESOpenMmiEvent_Value = Guid.initString("ba4b6526-1a35-4635-8b56-3ec612746a8c");
pub const IID_IESOpenMmiEvent = &IID_IESOpenMmiEvent_Value;
pub const IESOpenMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: *const fn (
            self: *const IESOpenMmiEvent,
            p_dialog_request: ?*u32,
            p_dialog_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogType: *const fn (
            self: *const IESOpenMmiEvent,
            guid_dialog_type: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogData: *const fn (
            self: *const IESOpenMmiEvent,
            pb_data: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogStringData: *const fn (
            self: *const IESOpenMmiEvent,
            pbstr_base_url: ?*?BSTR,
            pbstr_data: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getDialogNumber(self: *const T, p_dialog_request_: ?*u32, p_dialog_number_: ?*u32) HRESULT {
                return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogNumber(@as(*const IESOpenMmiEvent, @ptrCast(self)), p_dialog_request_, p_dialog_number_);
            }
            pub inline fn getDialogType(self: *const T, guid_dialog_type_: ?*Guid) HRESULT {
                return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogType(@as(*const IESOpenMmiEvent, @ptrCast(self)), guid_dialog_type_);
            }
            pub inline fn getDialogData(self: *const T, pb_data_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogData(@as(*const IESOpenMmiEvent, @ptrCast(self)), pb_data_);
            }
            pub inline fn getDialogStringData(self: *const T, pbstr_base_url_: ?*?BSTR, pbstr_data_: ?*?BSTR) HRESULT {
                return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogStringData(@as(*const IESOpenMmiEvent, @ptrCast(self)), pbstr_base_url_, pbstr_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESCloseMmiEvent_Value = Guid.initString("6b80e96f-55e2-45aa-b754-0c23c8e7d5c1");
pub const IID_IESCloseMmiEvent = &IID_IESCloseMmiEvent_Value;
pub const IESCloseMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: *const fn (
            self: *const IESCloseMmiEvent,
            p_dialog_number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getDialogNumber(self: *const T, p_dialog_number_: ?*u32) HRESULT {
                return @as(*const IESCloseMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogNumber(@as(*const IESCloseMmiEvent, @ptrCast(self)), p_dialog_number_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESValueUpdatedEvent_Value = Guid.initString("8a24c46e-bb63-4664-8602-5d9c718c146d");
pub const IID_IESValueUpdatedEvent = &IID_IESValueUpdatedEvent_Value;
pub const IESValueUpdatedEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetValueNames: *const fn (
            self: *const IESValueUpdatedEvent,
            pbstr_names: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getValueNames(self: *const T, pbstr_names_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IESValueUpdatedEvent.VTable, @ptrCast(self.vtable)).GetValueNames(@as(*const IESValueUpdatedEvent, @ptrCast(self)), pbstr_names_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESRequestTunerEvent_Value = Guid.initString("54c7a5e8-c3bb-4f51-af14-e0e2c0e34c6d");
pub const IID_IESRequestTunerEvent = &IID_IESRequestTunerEvent_Value;
pub const IESRequestTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetPriority: *const fn (
            self: *const IESRequestTunerEvent,
            pby_priority: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReason: *const fn (
            self: *const IESRequestTunerEvent,
            pby_reason: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConsequences: *const fn (
            self: *const IESRequestTunerEvent,
            pby_consequences: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEstimatedTime: *const fn (
            self: *const IESRequestTunerEvent,
            pdw_estimated_time: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getPriority(self: *const T, pby_priority_: ?*u8) HRESULT {
                return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IESRequestTunerEvent, @ptrCast(self)), pby_priority_);
            }
            pub inline fn getReason(self: *const T, pby_reason_: ?*u8) HRESULT {
                return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetReason(@as(*const IESRequestTunerEvent, @ptrCast(self)), pby_reason_);
            }
            pub inline fn getConsequences(self: *const T, pby_consequences_: ?*u8) HRESULT {
                return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetConsequences(@as(*const IESRequestTunerEvent, @ptrCast(self)), pby_consequences_);
            }
            pub inline fn getEstimatedTime(self: *const T, pdw_estimated_time_: ?*u32) HRESULT {
                return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetEstimatedTime(@as(*const IESRequestTunerEvent, @ptrCast(self)), pdw_estimated_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESIsdbCasResponseEvent_Value = Guid.initString("2017cb03-dc0f-4c24-83ca-36307b2cd19f");
pub const IID_IESIsdbCasResponseEvent = &IID_IESIsdbCasResponseEvent_Value;
pub const IESIsdbCasResponseEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetRequestId: *const fn (
            self: *const IESIsdbCasResponseEvent,
            p_request_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn (
            self: *const IESIsdbCasResponseEvent,
            p_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataLength: *const fn (
            self: *const IESIsdbCasResponseEvent,
            p_request_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResponseData: *const fn (
            self: *const IESIsdbCasResponseEvent,
            pb_data: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getRequestId(self: *const T, p_request_id_: ?*u32) HRESULT {
                return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetRequestId(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), p_request_id_);
            }
            pub inline fn getStatus(self: *const T, p_status_: ?*u32) HRESULT {
                return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), p_status_);
            }
            pub inline fn getDataLength(self: *const T, p_request_length_: ?*u32) HRESULT {
                return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetDataLength(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), p_request_length_);
            }
            pub inline fn getResponseData(self: *const T, pb_data_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetResponseData(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), pb_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGpnvsCommonBase_Value = Guid.initString("907e0b5c-e42d-4f04-91f0-26f401f36907");
pub const IID_IGpnvsCommonBase = &IID_IGpnvsCommonBase_Value;
pub const IGpnvsCommonBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueUpdateName: *const fn (
            self: *const IGpnvsCommonBase,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getValueUpdateName(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IGpnvsCommonBase.VTable, @ptrCast(self.vtable)).GetValueUpdateName(@as(*const IGpnvsCommonBase, @ptrCast(self)), pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IESEventFactory_Value = Guid.initString("506a09b8-7f86-4e04-ac05-3303bfe8fc49");
pub const IID_IESEventFactory = &IID_IESEventFactory_Value;
pub const IESEventFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateESEvent: *const fn (
            self: *const IESEventFactory,
            p_service_provider: ?*IUnknown,
            dw_event_id: u32,
            guid_event_type: Guid,
            dw_event_data_length: u32,
            p_event_data: [*:0]u8,
            bstr_base_url: ?BSTR,
            p_init_context: ?*IUnknown,
            pp_e_s_event: ?*?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createESEvent(self: *const T, p_service_provider_: ?*IUnknown, dw_event_id_: u32, guid_event_type_: Guid, dw_event_data_length_: u32, p_event_data_: [*:0]u8, bstr_base_url_: ?BSTR, p_init_context_: ?*IUnknown, pp_e_s_event_: ?*?*IESEvent) HRESULT {
                return @as(*const IESEventFactory.VTable, @ptrCast(self.vtable)).CreateESEvent(@as(*const IESEventFactory, @ptrCast(self)), p_service_provider_, dw_event_id_, guid_event_type_, dw_event_data_length_, p_event_data_, bstr_base_url_, p_init_context_, pp_e_s_event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESLicenseRenewalResultEvent_Value = Guid.initString("d5a48ef5-a81b-4df0-acaa-5e35e7ea45d4");
pub const IID_IESLicenseRenewalResultEvent = &IID_IESLicenseRenewalResultEvent_Value;
pub const IESLicenseRenewalResultEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetCallersId: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pdw_callers_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pbstr_filename: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRenewalSuccessful: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pf_renewal_successful: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCheckEntitlementCallRequired: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pf_check_ent_token_call_needed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescrambledStatus: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            p_descrambled_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenewalResultCode: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pdw_renewal_result_code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASFailureCode: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pdw_c_a_s_failure_code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenewalHResult: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            phr: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntitlementTokenLength: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntitlementToken: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pb_data: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpiryDate: *const fn (
            self: *const IESLicenseRenewalResultEvent,
            pqw_expiry_date: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getCallersId(self: *const T, pdw_callers_id_: ?*u32) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetCallersId(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdw_callers_id_);
            }
            pub inline fn getFileName(self: *const T, pbstr_filename_: ?*?BSTR) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pbstr_filename_);
            }
            pub inline fn isRenewalSuccessful(self: *const T, pf_renewal_successful_: ?*BOOL) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).IsRenewalSuccessful(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pf_renewal_successful_);
            }
            pub inline fn isCheckEntitlementCallRequired(self: *const T, pf_check_ent_token_call_needed_: ?*BOOL) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).IsCheckEntitlementCallRequired(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pf_check_ent_token_call_needed_);
            }
            pub inline fn getDescrambledStatus(self: *const T, p_descrambled_status_: ?*u32) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetDescrambledStatus(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), p_descrambled_status_);
            }
            pub inline fn getRenewalResultCode(self: *const T, pdw_renewal_result_code_: ?*u32) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetRenewalResultCode(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdw_renewal_result_code_);
            }
            pub inline fn getCASFailureCode(self: *const T, pdw_c_a_s_failure_code_: ?*u32) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetCASFailureCode(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdw_c_a_s_failure_code_);
            }
            pub inline fn getRenewalHResult(self: *const T, phr_: ?*HRESULT) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetRenewalHResult(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), phr_);
            }
            pub inline fn getEntitlementTokenLength(self: *const T, pdw_length_: ?*u32) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetEntitlementTokenLength(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdw_length_);
            }
            pub inline fn getEntitlementToken(self: *const T, pb_data_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetEntitlementToken(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pb_data_);
            }
            pub inline fn getExpiryDate(self: *const T, pqw_expiry_date_: ?*u64) HRESULT {
                return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetExpiryDate(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pqw_expiry_date_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESFileExpiryDateEvent_Value = Guid.initString("ba9edcb6-4d36-4cfe-8c56-87a6b0ca48e1");
pub const IID_IESFileExpiryDateEvent = &IID_IESFileExpiryDateEvent_Value;
pub const IESFileExpiryDateEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetTunerId: *const fn (
            self: *const IESFileExpiryDateEvent,
            pguid_tuner_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpiryDate: *const fn (
            self: *const IESFileExpiryDateEvent,
            pqw_expiry_date: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFinalExpiryDate: *const fn (
            self: *const IESFileExpiryDateEvent,
            pqw_expiry_date: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxRenewalCount: *const fn (
            self: *const IESFileExpiryDateEvent,
            dw_max_renewal_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEntitlementTokenPresent: *const fn (
            self: *const IESFileExpiryDateEvent,
            pf_ent_token_present: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoesExpireAfterFirstUse: *const fn (
            self: *const IESFileExpiryDateEvent,
            pf_expire_after_first_use: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IESEvent.MethodMixin(T);
            pub inline fn getTunerId(self: *const T, pguid_tuner_id_: ?*Guid) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetTunerId(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pguid_tuner_id_);
            }
            pub inline fn getExpiryDate(self: *const T, pqw_expiry_date_: ?*u64) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetExpiryDate(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pqw_expiry_date_);
            }
            pub inline fn getFinalExpiryDate(self: *const T, pqw_expiry_date_: ?*u64) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetFinalExpiryDate(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pqw_expiry_date_);
            }
            pub inline fn getMaxRenewalCount(self: *const T, dw_max_renewal_count_: ?*u32) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetMaxRenewalCount(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), dw_max_renewal_count_);
            }
            pub inline fn isEntitlementTokenPresent(self: *const T, pf_ent_token_present_: ?*BOOL) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).IsEntitlementTokenPresent(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pf_ent_token_present_);
            }
            pub inline fn doesExpireAfterFirstUse(self: *const T, pf_expire_after_first_use_: ?*BOOL) HRESULT {
                return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).DoesExpireAfterFirstUse(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pf_expire_after_first_use_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventService_Value = Guid.initString("ed89a619-4c06-4b2f-99eb-c7669b13047c");
pub const IID_IESEventService = &IID_IESEventService_Value;
pub const IESEventService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireESEvent: *const fn (
            self: *const IESEventService,
            p_e_s_event: ?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn fireESEvent(self: *const T, p_e_s_event_: ?*IESEvent) HRESULT {
                return @as(*const IESEventService.VTable, @ptrCast(self.vtable)).FireESEvent(@as(*const IESEventService, @ptrCast(self)), p_e_s_event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventServiceConfiguration_Value = Guid.initString("33b9daae-9309-491d-a051-bcad2a70cd66");
pub const IID_IESEventServiceConfiguration = &IID_IESEventServiceConfiguration_Value;
pub const IESEventServiceConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParent: *const fn (
            self: *const IESEventServiceConfiguration,
            p_event_service: ?*IESEventService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveParent: *const fn (
            self: *const IESEventServiceConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOwner: *const fn (
            self: *const IESEventServiceConfiguration,
            p_e_s_events: ?*IESEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveOwner: *const fn (
            self: *const IESEventServiceConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGraph: *const fn (
            self: *const IESEventServiceConfiguration,
            p_graph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGraph: *const fn (
            self: *const IESEventServiceConfiguration,
            p_graph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setParent(self: *const T, p_event_service_: ?*IESEventService) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetParent(@as(*const IESEventServiceConfiguration, @ptrCast(self)), p_event_service_);
            }
            pub inline fn removeParent(self: *const T) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveParent(@as(*const IESEventServiceConfiguration, @ptrCast(self)));
            }
            pub inline fn setOwner(self: *const T, p_e_s_events_: ?*IESEvents) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetOwner(@as(*const IESEventServiceConfiguration, @ptrCast(self)), p_e_s_events_);
            }
            pub inline fn removeOwner(self: *const T) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveOwner(@as(*const IESEventServiceConfiguration, @ptrCast(self)));
            }
            pub inline fn setGraph(self: *const T, p_graph_: ?*IFilterGraph) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetGraph(@as(*const IESEventServiceConfiguration, @ptrCast(self)), p_graph_);
            }
            pub inline fn removeGraph(self: *const T, p_graph_: ?*IFilterGraph) HRESULT {
                return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveGraph(@as(*const IESEventServiceConfiguration, @ptrCast(self)), p_graph_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterTuner_Value = Guid.initString("359b3901-572c-4854-bb49-cdef66606a25");
pub const IID_IRegisterTuner = &IID_IRegisterTuner_Value;
pub const IRegisterTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: *const fn (
            self: *const IRegisterTuner,
            p_tuner: ?*ITuner,
            p_graph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: *const fn (
            self: *const IRegisterTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn register(self: *const T, p_tuner_: ?*ITuner, p_graph_: ?*IGraphBuilder) HRESULT {
                return @as(*const IRegisterTuner.VTable, @ptrCast(self.vtable)).Register(@as(*const IRegisterTuner, @ptrCast(self)), p_tuner_, p_graph_);
            }
            pub inline fn unregister(self: *const T) HRESULT {
                return @as(*const IRegisterTuner.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IRegisterTuner, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDAComparable_Value = Guid.initString("b34505e0-2f0e-497b-80bc-d43f3b24ed7f");
pub const IID_IBDAComparable = &IID_IBDAComparable_Value;
pub const IBDAComparable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareExact: *const fn (
            self: *const IBDAComparable,
            compare_to: ?*IDispatch,
            result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEquivalent: *const fn (
            self: *const IBDAComparable,
            compare_to: ?*IDispatch,
            dw_flags: u32,
            result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashExact: *const fn (
            self: *const IBDAComparable,
            result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashExactIncremental: *const fn (
            self: *const IBDAComparable,
            partial_result: i64,
            result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashEquivalent: *const fn (
            self: *const IBDAComparable,
            dw_flags: u32,
            result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashEquivalentIncremental: *const fn (
            self: *const IBDAComparable,
            partial_result: i64,
            dw_flags: u32,
            result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn compareExact(self: *const T, compare_to_: ?*IDispatch, result_: ?*i32) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).CompareExact(@as(*const IBDAComparable, @ptrCast(self)), compare_to_, result_);
            }
            pub inline fn compareEquivalent(self: *const T, compare_to_: ?*IDispatch, dw_flags_: u32, result_: ?*i32) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).CompareEquivalent(@as(*const IBDAComparable, @ptrCast(self)), compare_to_, dw_flags_, result_);
            }
            pub inline fn hashExact(self: *const T, result_: ?*i64) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashExact(@as(*const IBDAComparable, @ptrCast(self)), result_);
            }
            pub inline fn hashExactIncremental(self: *const T, partial_result_: i64, result_: ?*i64) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashExactIncremental(@as(*const IBDAComparable, @ptrCast(self)), partial_result_, result_);
            }
            pub inline fn hashEquivalent(self: *const T, dw_flags_: u32, result_: ?*i64) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashEquivalent(@as(*const IBDAComparable, @ptrCast(self)), dw_flags_, result_);
            }
            pub inline fn hashEquivalentIncremental(self: *const T, partial_result_: i64, dw_flags_: u32, result_: ?*i64) HRESULT {
                return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashEquivalentIncremental(@as(*const IBDAComparable, @ptrCast(self)), partial_result_, dw_flags_, result_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXml_Value = Guid.initString("0754cd31-8d15-47a9-8215-d20064157244");
pub const IID_IPersistTuneXml = &IID_IPersistTuneXml_Value;
pub const IPersistTuneXml = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: *const fn (
            self: *const IPersistTuneXml,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: *const fn (
            self: *const IPersistTuneXml,
            var_value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: *const fn (
            self: *const IPersistTuneXml,
            pvar_fragment: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn initNew(self: *const T) HRESULT {
                return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistTuneXml, @ptrCast(self)));
            }
            pub inline fn load(self: *const T, var_value_: VARIANT) HRESULT {
                return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistTuneXml, @ptrCast(self)), var_value_);
            }
            pub inline fn save(self: *const T, pvar_fragment_: ?*VARIANT) HRESULT {
                return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistTuneXml, @ptrCast(self)), pvar_fragment_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility_Value = Guid.initString("990237ae-ac11-4614-be8f-dd217a4cb4cb");
pub const IID_IPersistTuneXmlUtility = &IID_IPersistTuneXmlUtility_Value;
pub const IPersistTuneXmlUtility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Deserialize: *const fn (
            self: *const IPersistTuneXmlUtility,
            var_value: VARIANT,
            pp_object: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn deserialize(self: *const T, var_value_: VARIANT, pp_object_: ?*?*IUnknown) HRESULT {
                return @as(*const IPersistTuneXmlUtility.VTable, @ptrCast(self.vtable)).Deserialize(@as(*const IPersistTuneXmlUtility, @ptrCast(self)), var_value_, pp_object_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility2_Value = Guid.initString("992e165f-ea24-4b2f-9a1d-009d92120451");
pub const IID_IPersistTuneXmlUtility2 = &IID_IPersistTuneXmlUtility2_Value;
pub const IPersistTuneXmlUtility2 = extern struct {
    pub const VTable = extern struct {
        base: IPersistTuneXmlUtility.VTable,
        Serialize: *const fn (
            self: *const IPersistTuneXmlUtility2,
            pi_tune_request: ?*ITuneRequest,
            p_string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistTuneXmlUtility.MethodMixin(T);
            pub inline fn serialize(self: *const T, pi_tune_request_: ?*ITuneRequest, p_string_: ?*?BSTR) HRESULT {
                return @as(*const IPersistTuneXmlUtility2.VTable, @ptrCast(self.vtable)).Serialize(@as(*const IPersistTuneXmlUtility2, @ptrCast(self)), pi_tune_request_, p_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDACreateTuneRequestEx_Value = Guid.initString("c0a4a1d4-2b3c-491a-ba22-499fbadd4d12");
pub const IID_IBDACreateTuneRequestEx = &IID_IBDACreateTuneRequestEx_Value;
pub const IBDACreateTuneRequestEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTuneRequestEx: *const fn (
            self: *const IBDACreateTuneRequestEx,
            tune_request_i_i_d: ?*const Guid,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createTuneRequestEx(self: *const T, tune_request_i_i_d_: ?*const Guid, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const IBDACreateTuneRequestEx.VTable, @ptrCast(self.vtable)).CreateTuneRequestEx(@as(*const IBDACreateTuneRequestEx, @ptrCast(self)), tune_request_i_i_d_, tune_request_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_XDSToRat_Value = Guid.initString("c5c5c5f0-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_XDSToRat = &CLSID_XDSToRat_Value;

const CLSID_EvalRat_Value = Guid.initString("c5c5c5f1-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_EvalRat = &CLSID_EvalRat_Value;

const CLSID_ETFilter_Value = Guid.initString("c4c4c4f1-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilter = &CLSID_ETFilter_Value;

const CLSID_DTFilter_Value = Guid.initString("c4c4c4f2-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilter = &CLSID_DTFilter_Value;

const CLSID_XDSCodec_Value = Guid.initString("c4c4c4f3-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodec = &CLSID_XDSCodec_Value;

const CLSID_CXDSData_Value = Guid.initString("c4c4c4f4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CXDSData = &CLSID_CXDSData_Value;

pub const EnTvRat_System = enum(i32) {
    MPAA = 0,
    US_TV = 1,
    Canadian_English = 2,
    Canadian_French = 3,
    Reserved4 = 4,
    System5 = 5,
    System6 = 6,
    Reserved7 = 7,
    PBDA = 8,
    AgeBased = 9,
    TvRat_kSystems = 10,
    TvRat_SystemDontKnow = 255,
};
pub const MPAA = EnTvRat_System.MPAA;
pub const US_TV = EnTvRat_System.US_TV;
pub const Canadian_English = EnTvRat_System.Canadian_English;
pub const Canadian_French = EnTvRat_System.Canadian_French;
pub const Reserved4 = EnTvRat_System.Reserved4;
pub const System5 = EnTvRat_System.System5;
pub const System6 = EnTvRat_System.System6;
pub const Reserved7 = EnTvRat_System.Reserved7;
pub const PBDA = EnTvRat_System.PBDA;
pub const AgeBased = EnTvRat_System.AgeBased;
pub const TvRat_kSystems = EnTvRat_System.TvRat_kSystems;
pub const TvRat_SystemDontKnow = EnTvRat_System.TvRat_SystemDontKnow;

pub const EnTvRat_GenericLevel = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
    kLevels = 22,
    Unblock = -1,
    LevelDontKnow = 255,
};
pub const TvRat_0 = EnTvRat_GenericLevel.@"0";
pub const TvRat_1 = EnTvRat_GenericLevel.@"1";
pub const TvRat_2 = EnTvRat_GenericLevel.@"2";
pub const TvRat_3 = EnTvRat_GenericLevel.@"3";
pub const TvRat_4 = EnTvRat_GenericLevel.@"4";
pub const TvRat_5 = EnTvRat_GenericLevel.@"5";
pub const TvRat_6 = EnTvRat_GenericLevel.@"6";
pub const TvRat_7 = EnTvRat_GenericLevel.@"7";
pub const TvRat_8 = EnTvRat_GenericLevel.@"8";
pub const TvRat_9 = EnTvRat_GenericLevel.@"9";
pub const TvRat_10 = EnTvRat_GenericLevel.@"10";
pub const TvRat_11 = EnTvRat_GenericLevel.@"11";
pub const TvRat_12 = EnTvRat_GenericLevel.@"12";
pub const TvRat_13 = EnTvRat_GenericLevel.@"13";
pub const TvRat_14 = EnTvRat_GenericLevel.@"14";
pub const TvRat_15 = EnTvRat_GenericLevel.@"15";
pub const TvRat_16 = EnTvRat_GenericLevel.@"16";
pub const TvRat_17 = EnTvRat_GenericLevel.@"17";
pub const TvRat_18 = EnTvRat_GenericLevel.@"18";
pub const TvRat_19 = EnTvRat_GenericLevel.@"19";
pub const TvRat_20 = EnTvRat_GenericLevel.@"20";
pub const TvRat_21 = EnTvRat_GenericLevel.@"21";
pub const TvRat_kLevels = EnTvRat_GenericLevel.kLevels;
pub const TvRat_Unblock = EnTvRat_GenericLevel.Unblock;
pub const TvRat_LevelDontKnow = EnTvRat_GenericLevel.LevelDontKnow;

pub const EnTvRat_MPAA = enum(i32) {
    NotApplicable = 0,
    G = 1,
    PG = 2,
    PG13 = 3,
    R = 4,
    NC17 = 5,
    X = 6,
    NotRated = 7,
};
pub const MPAA_NotApplicable = EnTvRat_MPAA.NotApplicable;
pub const MPAA_G = EnTvRat_MPAA.G;
pub const MPAA_PG = EnTvRat_MPAA.PG;
pub const MPAA_PG13 = EnTvRat_MPAA.PG13;
pub const MPAA_R = EnTvRat_MPAA.R;
pub const MPAA_NC17 = EnTvRat_MPAA.NC17;
pub const MPAA_X = EnTvRat_MPAA.X;
pub const MPAA_NotRated = EnTvRat_MPAA.NotRated;

pub const EnTvRat_US_TV = enum(i32) {
    None = 0,
    Y = 1,
    Y7 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    MA = 6,
    None7 = 7,
};
pub const US_TV_None = EnTvRat_US_TV.None;
pub const US_TV_Y = EnTvRat_US_TV.Y;
pub const US_TV_Y7 = EnTvRat_US_TV.Y7;
pub const US_TV_G = EnTvRat_US_TV.G;
pub const US_TV_PG = EnTvRat_US_TV.PG;
pub const US_TV_14 = EnTvRat_US_TV.@"14";
pub const US_TV_MA = EnTvRat_US_TV.MA;
pub const US_TV_None7 = EnTvRat_US_TV.None7;

pub const EnTvRat_CAE_TV = enum(i32) {
    Exempt = 0,
    C = 1,
    C8 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    @"18" = 6,
    Reserved = 7,
};
pub const CAE_TV_Exempt = EnTvRat_CAE_TV.Exempt;
pub const CAE_TV_C = EnTvRat_CAE_TV.C;
pub const CAE_TV_C8 = EnTvRat_CAE_TV.C8;
pub const CAE_TV_G = EnTvRat_CAE_TV.G;
pub const CAE_TV_PG = EnTvRat_CAE_TV.PG;
pub const CAE_TV_14 = EnTvRat_CAE_TV.@"14";
pub const CAE_TV_18 = EnTvRat_CAE_TV.@"18";
pub const CAE_TV_Reserved = EnTvRat_CAE_TV.Reserved;

pub const EnTvRat_CAF_TV = enum(i32) {
    Exempt = 0,
    G = 1,
    @"8" = 2,
    @"13" = 3,
    @"16" = 4,
    @"18" = 5,
    Reserved6 = 6,
    Reserved = 7,
};
pub const CAF_TV_Exempt = EnTvRat_CAF_TV.Exempt;
pub const CAF_TV_G = EnTvRat_CAF_TV.G;
pub const CAF_TV_8 = EnTvRat_CAF_TV.@"8";
pub const CAF_TV_13 = EnTvRat_CAF_TV.@"13";
pub const CAF_TV_16 = EnTvRat_CAF_TV.@"16";
pub const CAF_TV_18 = EnTvRat_CAF_TV.@"18";
pub const CAF_TV_Reserved6 = EnTvRat_CAF_TV.Reserved6;
pub const CAF_TV_Reserved = EnTvRat_CAF_TV.Reserved;

pub const BfEnTvRat_GenericAttributes = enum(i32) {
    AttrNone = 0,
    IsBlocked = 1,
    IsAttr_1 = 2,
    IsAttr_2 = 4,
    IsAttr_3 = 8,
    IsAttr_4 = 16,
    IsAttr_5 = 32,
    IsAttr_6 = 64,
    IsAttr_7 = 128,
    ValidAttrSubmask = 255,
};
pub const BfAttrNone = BfEnTvRat_GenericAttributes.AttrNone;
pub const BfIsBlocked = BfEnTvRat_GenericAttributes.IsBlocked;
pub const BfIsAttr_1 = BfEnTvRat_GenericAttributes.IsAttr_1;
pub const BfIsAttr_2 = BfEnTvRat_GenericAttributes.IsAttr_2;
pub const BfIsAttr_3 = BfEnTvRat_GenericAttributes.IsAttr_3;
pub const BfIsAttr_4 = BfEnTvRat_GenericAttributes.IsAttr_4;
pub const BfIsAttr_5 = BfEnTvRat_GenericAttributes.IsAttr_5;
pub const BfIsAttr_6 = BfEnTvRat_GenericAttributes.IsAttr_6;
pub const BfIsAttr_7 = BfEnTvRat_GenericAttributes.IsAttr_7;
pub const BfValidAttrSubmask = BfEnTvRat_GenericAttributes.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_US_TV = enum(i32) {
    IsBlocked = 1,
    IsViolent = 2,
    IsSexualSituation = 4,
    IsAdultLanguage = 8,
    IsSexuallySuggestiveDialog = 16,
    ValidAttrSubmask = 31,
};
pub const US_TV_IsBlocked = BfEnTvRat_Attributes_US_TV.IsBlocked;
pub const US_TV_IsViolent = BfEnTvRat_Attributes_US_TV.IsViolent;
pub const US_TV_IsSexualSituation = BfEnTvRat_Attributes_US_TV.IsSexualSituation;
pub const US_TV_IsAdultLanguage = BfEnTvRat_Attributes_US_TV.IsAdultLanguage;
pub const US_TV_IsSexuallySuggestiveDialog = BfEnTvRat_Attributes_US_TV.IsSexuallySuggestiveDialog;
pub const US_TV_ValidAttrSubmask = BfEnTvRat_Attributes_US_TV.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_MPAA = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const MPAA_IsBlocked = BfEnTvRat_Attributes_MPAA.IsBlocked;
pub const MPAA_ValidAttrSubmask = BfEnTvRat_Attributes_MPAA.IsBlocked;

pub const BfEnTvRat_Attributes_CAE_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAE_IsBlocked = BfEnTvRat_Attributes_CAE_TV.IsBlocked;
pub const CAE_ValidAttrSubmask = BfEnTvRat_Attributes_CAE_TV.IsBlocked;

pub const BfEnTvRat_Attributes_CAF_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAF_IsBlocked = BfEnTvRat_Attributes_CAF_TV.IsBlocked;
pub const CAF_ValidAttrSubmask = BfEnTvRat_Attributes_CAF_TV.IsBlocked;

pub const FormatNotSupportedEvents = enum(i32) {
    CLEAR = 0,
    NOTSUPPORTED = 1,
};
pub const FORMATNOTSUPPORTED_CLEAR = FormatNotSupportedEvents.CLEAR;
pub const FORMATNOTSUPPORTED_NOTSUPPORTED = FormatNotSupportedEvents.NOTSUPPORTED;

pub const WMDRMProtectionInfo = extern struct {
    wszKID: [25]u16 align(1),
    qwCounter: u64 align(1),
    qwIndex: u64 align(1),
    bOffset: u8 align(1),
};

pub const BadSampleInfo = extern struct {
    hrReason: HRESULT align(1),
};

pub const ProtType = enum(i32) {
    FREE = 1,
    ONCE = 2,
    NEVER = 3,
    NEVER_REALLY = 4,
    NO_MORE = 5,
    FREE_CIT = 6,
    BF = 7,
    CN_RECORDING_STOP = 8,
    FREE_SECURE = 9,
    INVALID = 50,
};
pub const PROT_COPY_FREE = ProtType.FREE;
pub const PROT_COPY_ONCE = ProtType.ONCE;
pub const PROT_COPY_NEVER = ProtType.NEVER;
pub const PROT_COPY_NEVER_REALLY = ProtType.NEVER_REALLY;
pub const PROT_COPY_NO_MORE = ProtType.NO_MORE;
pub const PROT_COPY_FREE_CIT = ProtType.FREE_CIT;
pub const PROT_COPY_BF = ProtType.BF;
pub const PROT_COPY_CN_RECORDING_STOP = ProtType.CN_RECORDING_STOP;
pub const PROT_COPY_FREE_SECURE = ProtType.FREE_SECURE;
pub const PROT_COPY_INVALID = ProtType.INVALID;

pub const EncDecEvents = enum(i32) {
    CPEVENT = 0,
    RECORDING_STATUS = 1,
};
pub const ENCDEC_CPEVENT = EncDecEvents.CPEVENT;
pub const ENCDEC_RECORDING_STATUS = EncDecEvents.RECORDING_STATUS;

pub const CPRecordingStatus = enum(i32) {
    OPPED = 0,
    ARTED = 1,
};
pub const RECORDING_STOPPED = CPRecordingStatus.OPPED;
pub const RECORDING_STARTED = CPRecordingStatus.ARTED;

pub const CPEventBitShift = enum(i32) {
    RATINGS = 0,
    COPP = 1,
    LICENSE = 2,
    ROLLBACK = 3,
    SAC = 4,
    DOWNRES = 5,
    STUBLIB = 6,
    UNTRUSTEDGRAPH = 7,
    PENDING_CERTIFICATE = 8,
    NO_PLAYREADY = 9,
};
pub const CPEVENT_BITSHIFT_RATINGS = CPEventBitShift.RATINGS;
pub const CPEVENT_BITSHIFT_COPP = CPEventBitShift.COPP;
pub const CPEVENT_BITSHIFT_LICENSE = CPEventBitShift.LICENSE;
pub const CPEVENT_BITSHIFT_ROLLBACK = CPEventBitShift.ROLLBACK;
pub const CPEVENT_BITSHIFT_SAC = CPEventBitShift.SAC;
pub const CPEVENT_BITSHIFT_DOWNRES = CPEventBitShift.DOWNRES;
pub const CPEVENT_BITSHIFT_STUBLIB = CPEventBitShift.STUBLIB;
pub const CPEVENT_BITSHIFT_UNTRUSTEDGRAPH = CPEventBitShift.UNTRUSTEDGRAPH;
pub const CPEVENT_BITSHIFT_PENDING_CERTIFICATE = CPEventBitShift.PENDING_CERTIFICATE;
pub const CPEVENT_BITSHIFT_NO_PLAYREADY = CPEventBitShift.NO_PLAYREADY;

pub const CPEvents = enum(i32) {
    NONE = 0,
    RATINGS = 1,
    COPP = 2,
    LICENSE = 3,
    ROLLBACK = 4,
    SAC = 5,
    DOWNRES = 6,
    STUBLIB = 7,
    UNTRUSTEDGRAPH = 8,
    PROTECTWINDOWED = 9,
};
pub const CPEVENT_NONE = CPEvents.NONE;
pub const CPEVENT_RATINGS = CPEvents.RATINGS;
pub const CPEVENT_COPP = CPEvents.COPP;
pub const CPEVENT_LICENSE = CPEvents.LICENSE;
pub const CPEVENT_ROLLBACK = CPEvents.ROLLBACK;
pub const CPEVENT_SAC = CPEvents.SAC;
pub const CPEVENT_DOWNRES = CPEvents.DOWNRES;
pub const CPEVENT_STUBLIB = CPEvents.STUBLIB;
pub const CPEVENT_UNTRUSTEDGRAPH = CPEvents.UNTRUSTEDGRAPH;
pub const CPEVENT_PROTECTWINDOWED = CPEvents.PROTECTWINDOWED;

pub const RevokedComponent = enum(i32) {
    COPP = 0,
    SAC = 1,
    APP_STUB = 2,
    SECURE_PIPELINE = 3,
    MAX_TYPES = 4,
};
pub const REVOKED_COPP = RevokedComponent.COPP;
pub const REVOKED_SAC = RevokedComponent.SAC;
pub const REVOKED_APP_STUB = RevokedComponent.APP_STUB;
pub const REVOKED_SECURE_PIPELINE = RevokedComponent.SECURE_PIPELINE;
pub const REVOKED_MAX_TYPES = RevokedComponent.MAX_TYPES;

pub const EnTag_Mode = enum(i32) {
    Remove = 0,
    Once = 1,
    Repeat = 2,
};
pub const EnTag_Remove = EnTag_Mode.Remove;
pub const EnTag_Once = EnTag_Mode.Once;
pub const EnTag_Repeat = EnTag_Mode.Repeat;

pub const COPPEventBlockReason = enum(i32) {
    Unknown = -1,
    BadDriver = 0,
    NoCardHDCPSupport = 1,
    NoMonitorHDCPSupport = 2,
    BadCertificate = 3,
    InvalidBusProtection = 4,
    AeroGlassOff = 5,
    RogueApp = 6,
    ForbiddenVideo = 7,
    Activate = 8,
    DigitalAudioUnprotected = 9,
};
pub const COPP_Unknown = COPPEventBlockReason.Unknown;
pub const COPP_BadDriver = COPPEventBlockReason.BadDriver;
pub const COPP_NoCardHDCPSupport = COPPEventBlockReason.NoCardHDCPSupport;
pub const COPP_NoMonitorHDCPSupport = COPPEventBlockReason.NoMonitorHDCPSupport;
pub const COPP_BadCertificate = COPPEventBlockReason.BadCertificate;
pub const COPP_InvalidBusProtection = COPPEventBlockReason.InvalidBusProtection;
pub const COPP_AeroGlassOff = COPPEventBlockReason.AeroGlassOff;
pub const COPP_RogueApp = COPPEventBlockReason.RogueApp;
pub const COPP_ForbiddenVideo = COPPEventBlockReason.ForbiddenVideo;
pub const COPP_Activate = COPPEventBlockReason.Activate;
pub const COPP_DigitalAudioUnprotected = COPPEventBlockReason.DigitalAudioUnprotected;

pub const LicenseEventBlockReason = enum(i32) {
    BadLicense = 0,
    NeedIndiv = 1,
    Expired = 2,
    NeedActivation = 3,
    ExtenderBlocked = 4,
};
pub const LIC_BadLicense = LicenseEventBlockReason.BadLicense;
pub const LIC_NeedIndiv = LicenseEventBlockReason.NeedIndiv;
pub const LIC_Expired = LicenseEventBlockReason.Expired;
pub const LIC_NeedActivation = LicenseEventBlockReason.NeedActivation;
pub const LIC_ExtenderBlocked = LicenseEventBlockReason.ExtenderBlocked;

pub const DownResEventParam = enum(i32) {
    Always = 0,
    InWindowOnly = 1,
    Undefined = 2,
};
pub const DOWNRES_Always = DownResEventParam.Always;
pub const DOWNRES_InWindowOnly = DownResEventParam.InWindowOnly;
pub const DOWNRES_Undefined = DownResEventParam.Undefined;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilterConfig_Value = Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterConfig = &IID_IETFilterConfig_Value;
pub const IETFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitLicense: *const fn (
            self: *const IETFilterConfig,
            license_id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecureChannelObject: *const fn (
            self: *const IETFilterConfig,
            pp_unk_d_r_m_secure_channel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initLicense(self: *const T, license_id_: i32) HRESULT {
                return @as(*const IETFilterConfig.VTable, @ptrCast(self.vtable)).InitLicense(@as(*const IETFilterConfig, @ptrCast(self)), license_id_);
            }
            pub inline fn getSecureChannelObject(self: *const T, pp_unk_d_r_m_secure_channel_: ?*?*IUnknown) HRESULT {
                return @as(*const IETFilterConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IETFilterConfig, @ptrCast(self)), pp_unk_d_r_m_secure_channel_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilterConfig_Value = Guid.initString("c4c4c4d2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterConfig = &IID_IDTFilterConfig_Value;
pub const IDTFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: *const fn (
            self: *const IDTFilterConfig,
            pp_unk_d_r_m_secure_channel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSecureChannelObject(self: *const T, pp_unk_d_r_m_secure_channel_: ?*?*IUnknown) HRESULT {
                return @as(*const IDTFilterConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IDTFilterConfig, @ptrCast(self)), pp_unk_d_r_m_secure_channel_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecConfig_Value = Guid.initString("c4c4c4d3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecConfig = &IID_IXDSCodecConfig_Value;
pub const IXDSCodecConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: *const fn (
            self: *const IXDSCodecConfig,
            pp_unk_d_r_m_secure_channel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPauseBufferTime: *const fn (
            self: *const IXDSCodecConfig,
            dw_pause_buffer_time: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSecureChannelObject(self: *const T, pp_unk_d_r_m_secure_channel_: ?*?*IUnknown) HRESULT {
                return @as(*const IXDSCodecConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IXDSCodecConfig, @ptrCast(self)), pp_unk_d_r_m_secure_channel_);
            }
            pub inline fn setPauseBufferTime(self: *const T, dw_pause_buffer_time_: u32) HRESULT {
                return @as(*const IXDSCodecConfig.VTable, @ptrCast(self.vtable)).SetPauseBufferTime(@as(*const IXDSCodecConfig, @ptrCast(self)), dw_pause_buffer_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterLicenseRenewal_Value = Guid.initString("8a78b317-e405-4a43-994a-620d8f5ce25e");
pub const IID_IDTFilterLicenseRenewal = &IID_IDTFilterLicenseRenewal_Value;
pub const IDTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLicenseRenewalData: *const fn (
            self: *const IDTFilterLicenseRenewal,
            ppwsz_file_name: ?*?PWSTR,
            ppwsz_expired_kid: ?*?PWSTR,
            ppwsz_tuner_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLicenseRenewalData(self: *const T, ppwsz_file_name_: ?*?PWSTR, ppwsz_expired_kid_: ?*?PWSTR, ppwsz_tuner_id_: ?*?PWSTR) HRESULT {
                return @as(*const IDTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).GetLicenseRenewalData(@as(*const IDTFilterLicenseRenewal, @ptrCast(self)), ppwsz_file_name_, ppwsz_expired_kid_, ppwsz_tuner_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPTFilterLicenseRenewal_Value = Guid.initString("26d836a5-0c15-44c7-ac59-b0da8728f240");
pub const IID_IPTFilterLicenseRenewal = &IID_IPTFilterLicenseRenewal_Value;
pub const IPTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenewLicenses: *const fn (
            self: *const IPTFilterLicenseRenewal,
            wsz_file_name: ?PWSTR,
            wsz_expired_kid: ?PWSTR,
            dw_callers_id: u32,
            b_high_priority: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelLicenseRenewal: *const fn (
            self: *const IPTFilterLicenseRenewal,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn renewLicenses(self: *const T, wsz_file_name_: ?PWSTR, wsz_expired_kid_: ?PWSTR, dw_callers_id_: u32, b_high_priority_: BOOL) HRESULT {
                return @as(*const IPTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).RenewLicenses(@as(*const IPTFilterLicenseRenewal, @ptrCast(self)), wsz_file_name_, wsz_expired_kid_, dw_callers_id_, b_high_priority_);
            }
            pub inline fn cancelLicenseRenewal(self: *const T) HRESULT {
                return @as(*const IPTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).CancelLicenseRenewal(@as(*const IPTFilterLicenseRenewal, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMceBurnerControl_Value = Guid.initString("5a86b91a-e71e-46c1-88a9-9bb338710552");
pub const IID_IMceBurnerControl = &IID_IMceBurnerControl_Value;
pub const IMceBurnerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBurnerNoDecryption: *const fn (
            self: *const IMceBurnerControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBurnerNoDecryption(self: *const T) HRESULT {
                return @as(*const IMceBurnerControl.VTable, @ptrCast(self.vtable)).GetBurnerNoDecryption(@as(*const IMceBurnerControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilter_Value = Guid.initString("c4c4c4b1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilter = &IID_IETFilter_Value;
pub const IETFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IETFilter,
            p_hr_co_create_ret_val: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrRating: *const fn (
            self: *const IETFilter,
            p_en_system: ?*EnTvRat_System,
            p_en_rating: ?*EnTvRat_GenericLevel,
            plbf_en_attr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: *const fn (
            self: *const IETFilter,
            prot_type: ?*ProtType,
            lp_date_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: *const fn (
            self: *const IETFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecordingOn: *const fn (
            self: *const IETFilter,
            f_rec_state: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEvalRatObjOK(self: *const T, p_hr_co_create_ret_val_: ?*HRESULT) HRESULT {
                return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).get_EvalRatObjOK(@as(*const IETFilter, @ptrCast(self)), p_hr_co_create_ret_val_);
            }
            pub inline fn getCurrRating(self: *const T, p_en_system_: ?*EnTvRat_System, p_en_rating_: ?*EnTvRat_GenericLevel, plbf_en_attr_: ?*i32) HRESULT {
                return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetCurrRating(@as(*const IETFilter, @ptrCast(self)), p_en_system_, p_en_rating_, plbf_en_attr_);
            }
            pub inline fn getCurrLicenseExpDate(self: *const T, prot_type_: ?*ProtType, lp_date_time_: ?*i32) HRESULT {
                return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IETFilter, @ptrCast(self)), prot_type_, lp_date_time_);
            }
            pub inline fn getLastErrorCode(self: *const T) HRESULT {
                return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IETFilter, @ptrCast(self)));
            }
            pub inline fn setRecordingOn(self: *const T, f_rec_state_: BOOL) HRESULT {
                return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).SetRecordingOn(@as(*const IETFilter, @ptrCast(self)), f_rec_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IETFilterEvents_Value = Guid.initString("c4c4c4c1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterEvents = &IID_IETFilterEvents_Value;
pub const IETFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter_Value = Guid.initString("c4c4c4b2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter = &IID_IDTFilter_Value;
pub const IDTFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            p_hr_co_create_ret_val: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrRating: *const fn (
            self: *const IDTFilter,
            p_en_system: ?*EnTvRat_System,
            p_en_rating: ?*EnTvRat_GenericLevel,
            plbf_en_attr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockedRatingAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            en_system: EnTvRat_System,
            en_level: EnTvRat_GenericLevel,
            plbf_en_attr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockedRatingAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            en_system: EnTvRat_System,
            en_level: EnTvRat_GenericLevel,
            lbf_attrs: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            pf_block_un_rated_shows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            f_block_un_rated_shows: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRatedDelay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            pmsecs_delay_before_block: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRatedDelay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter,
            msecs_delay_before_block: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEvalRatObjOK(self: *const T, p_hr_co_create_ret_val_: ?*HRESULT) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_EvalRatObjOK(@as(*const IDTFilter, @ptrCast(self)), p_hr_co_create_ret_val_);
            }
            pub inline fn getCurrRating(self: *const T, p_en_system_: ?*EnTvRat_System, p_en_rating_: ?*EnTvRat_GenericLevel, plbf_en_attr_: ?*i32) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).GetCurrRating(@as(*const IDTFilter, @ptrCast(self)), p_en_system_, p_en_rating_, plbf_en_attr_);
            }
            pub inline fn getBlockedRatingAttributes(self: *const T, en_system_: EnTvRat_System, en_level_: EnTvRat_GenericLevel, plbf_en_attr_: ?*i32) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockedRatingAttributes(@as(*const IDTFilter, @ptrCast(self)), en_system_, en_level_, plbf_en_attr_);
            }
            pub inline fn putBlockedRatingAttributes(self: *const T, en_system_: EnTvRat_System, en_level_: EnTvRat_GenericLevel, lbf_attrs_: i32) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockedRatingAttributes(@as(*const IDTFilter, @ptrCast(self)), en_system_, en_level_, lbf_attrs_);
            }
            pub inline fn getBlockUnRated(self: *const T, pf_block_un_rated_shows_: ?*BOOL) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockUnRated(@as(*const IDTFilter, @ptrCast(self)), pf_block_un_rated_shows_);
            }
            pub inline fn putBlockUnRated(self: *const T, f_block_un_rated_shows_: BOOL) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockUnRated(@as(*const IDTFilter, @ptrCast(self)), f_block_un_rated_shows_);
            }
            pub inline fn getBlockUnRatedDelay(self: *const T, pmsecs_delay_before_block_: ?*i32) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockUnRatedDelay(@as(*const IDTFilter, @ptrCast(self)), pmsecs_delay_before_block_);
            }
            pub inline fn putBlockUnRatedDelay(self: *const T, msecs_delay_before_block_: i32) HRESULT {
                return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockUnRatedDelay(@as(*const IDTFilter, @ptrCast(self)), msecs_delay_before_block_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter2_Value = Guid.initString("c4c4c4b4-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter2 = &IID_IDTFilter2_Value;
pub const IDTFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChallengeUrl: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDTFilter2,
            pbstr_challenge_url: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: *const fn (
            self: *const IDTFilter2,
            prot_type: ?*ProtType,
            lp_date_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: *const fn (
            self: *const IDTFilter2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDTFilter.MethodMixin(T);
            pub inline fn getChallengeUrl(self: *const T, pbstr_challenge_url_: ?*?BSTR) HRESULT {
                return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).get_ChallengeUrl(@as(*const IDTFilter2, @ptrCast(self)), pbstr_challenge_url_);
            }
            pub inline fn getCurrLicenseExpDate(self: *const T, prot_type_: ?*ProtType, lp_date_time_: ?*i32) HRESULT {
                return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IDTFilter2, @ptrCast(self)), prot_type_, lp_date_time_);
            }
            pub inline fn getLastErrorCode(self: *const T) HRESULT {
                return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IDTFilter2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDTFilter3_Value = Guid.initString("513998cc-e929-4cdf-9fbd-bad1e0314866");
pub const IID_IDTFilter3 = &IID_IDTFilter3_Value;
pub const IDTFilter3 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter2.VTable,
        GetProtectionType: *const fn (
            self: *const IDTFilter3,
            p_protection_type: ?*ProtType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LicenseHasExpirationDate: *const fn (
            self: *const IDTFilter3,
            pf_license_has_expiration_date: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRights: *const fn (
            self: *const IDTFilter3,
            bstr_rights: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDTFilter2.MethodMixin(T);
            pub inline fn getProtectionType(self: *const T, p_protection_type_: ?*ProtType) HRESULT {
                return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).GetProtectionType(@as(*const IDTFilter3, @ptrCast(self)), p_protection_type_);
            }
            pub inline fn licenseHasExpirationDate(self: *const T, pf_license_has_expiration_date_: ?*BOOL) HRESULT {
                return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).LicenseHasExpirationDate(@as(*const IDTFilter3, @ptrCast(self)), pf_license_has_expiration_date_);
            }
            pub inline fn setRights(self: *const T, bstr_rights_: ?BSTR) HRESULT {
                return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).SetRights(@as(*const IDTFilter3, @ptrCast(self)), bstr_rights_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterEvents_Value = Guid.initString("c4c4c4c2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterEvents = &IID_IDTFilterEvents_Value;
pub const IDTFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSCodec_Value = Guid.initString("c4c4c4b3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodec = &IID_IXDSCodec_Value;
pub const IXDSCodec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XDSToRatObjOK: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IXDSCodec,
            p_hr_co_create_ret_val: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCSubstreamService: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IXDSCodec,
            substream_mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCSubstreamService: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IXDSCodec,
            p_substream_mask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentAdvisoryRating: *const fn (
            self: *const IXDSCodec,
            p_rat: ?*i32,
            p_pkt_seq_i_d: ?*i32,
            p_call_seq_i_d: ?*i32,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXDSPacket: *const fn (
            self: *const IXDSCodec,
            p_x_d_s_class_pkt: ?*i32,
            p_x_d_s_type_pkt: ?*i32,
            p_bstr_x_d_s_pkt: ?*?BSTR,
            p_pkt_seq_i_d: ?*i32,
            p_call_seq_i_d: ?*i32,
            p_time_start: ?*i64,
            p_time_end: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: *const fn (
            self: *const IXDSCodec,
            prot_type: ?*ProtType,
            lp_date_time: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: *const fn (
            self: *const IXDSCodec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getXDSToRatObjOK(self: *const T, p_hr_co_create_ret_val_: ?*HRESULT) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).get_XDSToRatObjOK(@as(*const IXDSCodec, @ptrCast(self)), p_hr_co_create_ret_val_);
            }
            pub inline fn putCCSubstreamService(self: *const T, substream_mask_: i32) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).put_CCSubstreamService(@as(*const IXDSCodec, @ptrCast(self)), substream_mask_);
            }
            pub inline fn getCCSubstreamService(self: *const T, p_substream_mask_: ?*i32) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).get_CCSubstreamService(@as(*const IXDSCodec, @ptrCast(self)), p_substream_mask_);
            }
            pub inline fn getContentAdvisoryRating(self: *const T, p_rat_: ?*i32, p_pkt_seq_i_d_: ?*i32, p_call_seq_i_d_: ?*i32, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetContentAdvisoryRating(@as(*const IXDSCodec, @ptrCast(self)), p_rat_, p_pkt_seq_i_d_, p_call_seq_i_d_, p_time_start_, p_time_end_);
            }
            pub inline fn getXDSPacket(self: *const T, p_x_d_s_class_pkt_: ?*i32, p_x_d_s_type_pkt_: ?*i32, p_bstr_x_d_s_pkt_: ?*?BSTR, p_pkt_seq_i_d_: ?*i32, p_call_seq_i_d_: ?*i32, p_time_start_: ?*i64, p_time_end_: ?*i64) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetXDSPacket(@as(*const IXDSCodec, @ptrCast(self)), p_x_d_s_class_pkt_, p_x_d_s_type_pkt_, p_bstr_x_d_s_pkt_, p_pkt_seq_i_d_, p_call_seq_i_d_, p_time_start_, p_time_end_);
            }
            pub inline fn getCurrLicenseExpDate(self: *const T, prot_type_: ?*ProtType, lp_date_time_: ?*i32) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IXDSCodec, @ptrCast(self)), prot_type_, lp_date_time_);
            }
            pub inline fn getLastErrorCode(self: *const T) HRESULT {
                return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IXDSCodec, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecEvents_Value = Guid.initString("c4c4c4c3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecEvents = &IID_IXDSCodecEvents_Value;
pub const IXDSCodecEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSToRat_Value = Guid.initString("c5c5c5b0-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IXDSToRat = &IID_IXDSToRat_Value;
pub const IXDSToRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Init: *const fn (
            self: *const IXDSToRat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseXDSBytePair: *const fn (
            self: *const IXDSToRat,
            byte1: u8,
            byte2: u8,
            p_en_system: ?*EnTvRat_System,
            p_en_level: ?*EnTvRat_GenericLevel,
            pl_bf_en_attributes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn init(self: *const T) HRESULT {
                return @as(*const IXDSToRat.VTable, @ptrCast(self.vtable)).Init(@as(*const IXDSToRat, @ptrCast(self)));
            }
            pub inline fn parseXDSBytePair(self: *const T, byte1_: u8, byte2_: u8, p_en_system_: ?*EnTvRat_System, p_en_level_: ?*EnTvRat_GenericLevel, pl_bf_en_attributes_: ?*i32) HRESULT {
                return @as(*const IXDSToRat.VTable, @ptrCast(self.vtable)).ParseXDSBytePair(@as(*const IXDSToRat, @ptrCast(self)), byte1_, byte2_, p_en_system_, p_en_level_, pl_bf_en_attributes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEvalRat_Value = Guid.initString("c5c5c5b1-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IEvalRat = &IID_IEvalRat_Value;
pub const IEvalRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockedRatingAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEvalRat,
            en_system: EnTvRat_System,
            en_level: EnTvRat_GenericLevel,
            plbf_attrs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockedRatingAttributes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEvalRat,
            en_system: EnTvRat_System,
            en_level: EnTvRat_GenericLevel,
            lbf_attrs: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEvalRat,
            pf_block_un_rated_shows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IEvalRat,
            f_block_un_rated_shows: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MostRestrictiveRating: *const fn (
            self: *const IEvalRat,
            en_system1: EnTvRat_System,
            en_en_level1: EnTvRat_GenericLevel,
            lbf_en_attr1: i32,
            en_system2: EnTvRat_System,
            en_en_level2: EnTvRat_GenericLevel,
            lbf_en_attr2: i32,
            pen_system: ?*EnTvRat_System,
            pen_en_level: ?*EnTvRat_GenericLevel,
            plbf_en_attr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestRating: *const fn (
            self: *const IEvalRat,
            en_show_system: EnTvRat_System,
            en_show_level: EnTvRat_GenericLevel,
            lbf_en_show_attributes: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getBlockedRatingAttributes(self: *const T, en_system_: EnTvRat_System, en_level_: EnTvRat_GenericLevel, plbf_attrs_: ?*i32) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).get_BlockedRatingAttributes(@as(*const IEvalRat, @ptrCast(self)), en_system_, en_level_, plbf_attrs_);
            }
            pub inline fn putBlockedRatingAttributes(self: *const T, en_system_: EnTvRat_System, en_level_: EnTvRat_GenericLevel, lbf_attrs_: i32) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).put_BlockedRatingAttributes(@as(*const IEvalRat, @ptrCast(self)), en_system_, en_level_, lbf_attrs_);
            }
            pub inline fn getBlockUnRated(self: *const T, pf_block_un_rated_shows_: ?*BOOL) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).get_BlockUnRated(@as(*const IEvalRat, @ptrCast(self)), pf_block_un_rated_shows_);
            }
            pub inline fn putBlockUnRated(self: *const T, f_block_un_rated_shows_: BOOL) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).put_BlockUnRated(@as(*const IEvalRat, @ptrCast(self)), f_block_un_rated_shows_);
            }
            pub inline fn mostRestrictiveRating(self: *const T, en_system1_: EnTvRat_System, en_en_level1_: EnTvRat_GenericLevel, lbf_en_attr1_: i32, en_system2_: EnTvRat_System, en_en_level2_: EnTvRat_GenericLevel, lbf_en_attr2_: i32, pen_system_: ?*EnTvRat_System, pen_en_level_: ?*EnTvRat_GenericLevel, plbf_en_attr_: ?*i32) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).MostRestrictiveRating(@as(*const IEvalRat, @ptrCast(self)), en_system1_, en_en_level1_, lbf_en_attr1_, en_system2_, en_en_level2_, lbf_en_attr2_, pen_system_, pen_en_level_, plbf_en_attr_);
            }
            pub inline fn testRating(self: *const T, en_show_system_: EnTvRat_System, en_show_level_: EnTvRat_GenericLevel, lbf_en_show_attributes_: i32) HRESULT {
                return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).TestRating(@as(*const IEvalRat, @ptrCast(self)), en_show_system_, en_show_level_, lbf_en_show_attributes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SegDispidList = enum(i32) {
    dispidName = 0,
    dispidStatus = 1,
    dispidDevImageSourceWidth = 2,
    dispidDevImageSourceHeight = 3,
    dispidDevCountryCode = 4,
    dispidDevOverScan = 5,
    dispidSegment = 6,
    dispidDevVolume = 7,
    dispidDevBalance = 8,
    dispidDevPower = 9,
    dispidTuneChan = 10,
    dispidDevVideoSubchannel = 11,
    dispidDevAudioSubchannel = 12,
    dispidChannelAvailable = 13,
    dispidDevVideoFrequency = 14,
    dispidDevAudioFrequency = 15,
    dispidCount = 16,
    dispidDevFileName = 17,
    dispidVisible = 18,
    dispidOwner = 19,
    dispidMessageDrain = 20,
    dispidViewable = 21,
    dispidDevView = 22,
    dispidKSCat = 23,
    dispidCLSID = 24,
    dispid_KSCat = 25,
    dispid_CLSID = 26,
    dispidTune = 27,
    dispidTS = 28,
    dispidDevSAP = 29,
    dispidClip = 30,
    dispidRequestedClipRect = 31,
    dispidClippedSourceRect = 32,
    dispidAvailableSourceRect = 33,
    dispidMediaPosition = 34,
    dispidDevRun = 35,
    dispidDevPause = 36,
    dispidDevStop = 37,
    dispidCCEnable = 38,
    dispidDevStep = 39,
    dispidDevCanStep = 40,
    dispidSourceSize = 41,
    dispid_playtitle = 42,
    dispid_playchapterintitle = 43,
    dispid_playchapter = 44,
    dispid_playchaptersautostop = 45,
    dispid_playattime = 46,
    dispid_playattimeintitle = 47,
    dispid_playperiodintitleautostop = 48,
    dispid_replaychapter = 49,
    dispid_playprevchapter = 50,
    dispid_playnextchapter = 51,
    dispid_playforwards = 52,
    dispid_playbackwards = 53,
    dispid_stilloff = 54,
    dispid_audiolanguage = 55,
    dispid_showmenu = 56,
    dispid_resume = 57,
    dispid_returnfromsubmenu = 58,
    dispid_buttonsavailable = 59,
    dispid_currentbutton = 60,
    dispid_SelectAndActivateButton = 61,
    dispid_ActivateButton = 62,
    dispid_SelectRightButton = 63,
    dispid_SelectLeftButton = 64,
    dispid_SelectLowerButton = 65,
    dispid_SelectUpperButton = 66,
    dispid_ActivateAtPosition = 67,
    dispid_SelectAtPosition = 68,
    dispid_ButtonAtPosition = 69,
    dispid_NumberOfChapters = 70,
    dispid_TotalTitleTime = 71,
    dispid_TitlesAvailable = 72,
    dispid_VolumesAvailable = 73,
    dispid_CurrentVolume = 74,
    dispid_CurrentDiscSide = 75,
    dispid_CurrentDomain = 76,
    dispid_CurrentChapter = 77,
    dispid_CurrentTitle = 78,
    dispid_CurrentTime = 79,
    dispid_FramesPerSecond = 80,
    dispid_DVDTimeCode2bstr = 81,
    dispid_DVDDirectory = 82,
    dispid_IsSubpictureStreamEnabled = 83,
    dispid_IsAudioStreamEnabled = 84,
    dispid_CurrentSubpictureStream = 85,
    dispid_SubpictureLanguage = 86,
    dispid_CurrentAudioStream = 87,
    dispid_AudioStreamsAvailable = 88,
    dispid_AnglesAvailable = 89,
    dispid_CurrentAngle = 90,
    dispid_CCActive = 91,
    dispid_CurrentCCService = 92,
    dispid_SubpictureStreamsAvailable = 93,
    dispid_SubpictureOn = 94,
    dispid_DVDUniqueID = 95,
    dispid_EnableResetOnStop = 96,
    dispid_AcceptParentalLevelChange = 97,
    dispid_NotifyParentalLevelChange = 98,
    dispid_SelectParentalCountry = 99,
    dispid_SelectParentalLevel = 100,
    dispid_TitleParentalLevels = 101,
    dispid_PlayerParentalCountry = 102,
    dispid_PlayerParentalLevel = 103,
    dispid_Eject = 104,
    dispid_UOPValid = 105,
    dispid_SPRM = 106,
    dispid_GPRM = 107,
    dispid_DVDTextStringType = 108,
    dispid_DVDTextString = 109,
    dispid_DVDTextNumberOfStrings = 110,
    dispid_DVDTextNumberOfLanguages = 111,
    dispid_DVDTextLanguageLCID = 112,
    dispid_RegionChange = 113,
    dispid_DVDAdm = 114,
    dispid_DeleteBookmark = 115,
    dispid_RestoreBookmark = 116,
    dispid_SaveBookmark = 117,
    dispid_SelectDefaultAudioLanguage = 118,
    dispid_SelectDefaultSubpictureLanguage = 119,
    dispid_PreferredSubpictureStream = 120,
    dispid_DefaultMenuLanguage = 121,
    dispid_DefaultSubpictureLanguage = 122,
    dispid_DefaultAudioLanguage = 123,
    dispid_DefaultSubpictureLanguageExt = 124,
    dispid_DefaultAudioLanguageExt = 125,
    dispid_LanguageFromLCID = 126,
    dispid_KaraokeAudioPresentationMode = 127,
    dispid_KaraokeChannelContent = 128,
    dispid_KaraokeChannelAssignment = 129,
    dispid_RestorePreferredSettings = 130,
    dispid_ButtonRect = 131,
    dispid_DVDScreenInMouseCoordinates = 132,
    dispid_CustomCompositorClass = 133,
    dispidCustomCompositorClass = 134,
    dispid_CustomCompositor = 135,
    dispidMixerBitmap = 136,
    dispid_MixerBitmap = 137,
    dispidMixerBitmapOpacity = 138,
    dispidMixerBitmapRect = 139,
    dispidSetupMixerBitmap = 140,
    dispidUsingOverlay = 141,
    dispidDisplayChange = 142,
    dispidRePaint = 143,
    dispid_IsEqualDevice = 144,
    dispidrate = 145,
    dispidposition = 146,
    dispidpositionmode = 147,
    dispidlength = 148,
    dispidChangePassword = 149,
    dispidSaveParentalLevel = 150,
    dispidSaveParentalCountry = 151,
    dispidConfirmPassword = 152,
    dispidGetParentalLevel = 153,
    dispidGetParentalCountry = 154,
    dispidDefaultAudioLCID = 155,
    dispidDefaultSubpictureLCID = 156,
    dispidDefaultMenuLCID = 157,
    dispidBookmarkOnStop = 158,
    dispidMaxVidRect = 159,
    dispidMinVidRect = 160,
    dispidCapture = 161,
    dispid_DecimateInput = 162,
    dispidAlloctor = 163,
    dispid_Allocator = 164,
    dispidAllocPresentID = 165,
    dispidSetAllocator = 166,
    dispid_SetAllocator = 167,
    dispidStreamBufferSinkName = 168,
    dispidStreamBufferSourceName = 169,
    dispidStreamBufferContentRecording = 170,
    dispidStreamBufferReferenceRecording = 171,
    dispidstarttime = 172,
    dispidstoptime = 173,
    dispidrecordingstopped = 174,
    dispidrecordingstarted = 175,
    dispidNameSetLock = 176,
    dispidrecordingtype = 177,
    dispidstart = 178,
    dispidRecordingAttribute = 179,
    dispid_RecordingAttribute = 180,
    dispidSBEConfigure = 181,
    dispid_CurrentRatings = 182,
    dispid_MaxRatingsLevel = 183,
    dispid_audioencoderint = 184,
    dispid_videoencoderint = 185,
    dispidService = 186,
    dispid_BlockUnrated = 187,
    dispid_UnratedDelay = 188,
    dispid_SuppressEffects = 189,
    dispidsbesource = 190,
    dispidSetSinkFilter = 191,
    dispid_SinkStreams = 192,
    dispidTVFormats = 193,
    dispidModes = 194,
    dispidAuxInputs = 195,
    dispidTeleTextFilter = 196,
    dispid_channelchangeint = 197,
    dispidUnlockProfile = 198,
    dispid_AddFilter = 199,
    dispidSetMinSeek = 200,
    dispidRateEx = 201,
    dispidaudiocounter = 202,
    dispidvideocounter = 203,
    dispidcccounter = 204,
    dispidwstcounter = 205,
    dispid_audiocounter = 206,
    dispid_videocounter = 207,
    dispid_cccounter = 208,
    dispid_wstcounter = 209,
    dispidaudioanalysis = 210,
    dispidvideoanalysis = 211,
    dispiddataanalysis = 212,
    dispidaudio_analysis = 213,
    dispidvideo_analysis = 214,
    dispiddata_analysis = 215,
    dispid_resetFilterList = 216,
    dispidDevicePath = 217,
    dispid_SourceFilter = 218,
    dispid__SourceFilter = 219,
    dispidUserEvent = 220,
    dispid_Bookmark = 221,
    LastReservedDeviceDispid = 16383,
};
pub const dispidName = SegDispidList.dispidName;
pub const dispidStatus = SegDispidList.dispidStatus;
pub const dispidDevImageSourceWidth = SegDispidList.dispidDevImageSourceWidth;
pub const dispidDevImageSourceHeight = SegDispidList.dispidDevImageSourceHeight;
pub const dispidDevCountryCode = SegDispidList.dispidDevCountryCode;
pub const dispidDevOverScan = SegDispidList.dispidDevOverScan;
pub const dispidSegment = SegDispidList.dispidSegment;
pub const dispidDevVolume = SegDispidList.dispidDevVolume;
pub const dispidDevBalance = SegDispidList.dispidDevBalance;
pub const dispidDevPower = SegDispidList.dispidDevPower;
pub const dispidTuneChan = SegDispidList.dispidTuneChan;
pub const dispidDevVideoSubchannel = SegDispidList.dispidDevVideoSubchannel;
pub const dispidDevAudioSubchannel = SegDispidList.dispidDevAudioSubchannel;
pub const dispidChannelAvailable = SegDispidList.dispidChannelAvailable;
pub const dispidDevVideoFrequency = SegDispidList.dispidDevVideoFrequency;
pub const dispidDevAudioFrequency = SegDispidList.dispidDevAudioFrequency;
pub const dispidCount = SegDispidList.dispidCount;
pub const dispidDevFileName = SegDispidList.dispidDevFileName;
pub const dispidVisible = SegDispidList.dispidVisible;
pub const dispidOwner = SegDispidList.dispidOwner;
pub const dispidMessageDrain = SegDispidList.dispidMessageDrain;
pub const dispidViewable = SegDispidList.dispidViewable;
pub const dispidDevView = SegDispidList.dispidDevView;
pub const dispidKSCat = SegDispidList.dispidKSCat;
pub const dispidCLSID = SegDispidList.dispidCLSID;
pub const dispid_KSCat = SegDispidList.dispid_KSCat;
pub const dispid_CLSID = SegDispidList.dispid_CLSID;
pub const dispidTune = SegDispidList.dispidTune;
pub const dispidTS = SegDispidList.dispidTS;
pub const dispidDevSAP = SegDispidList.dispidDevSAP;
pub const dispidClip = SegDispidList.dispidClip;
pub const dispidRequestedClipRect = SegDispidList.dispidRequestedClipRect;
pub const dispidClippedSourceRect = SegDispidList.dispidClippedSourceRect;
pub const dispidAvailableSourceRect = SegDispidList.dispidAvailableSourceRect;
pub const dispidMediaPosition = SegDispidList.dispidMediaPosition;
pub const dispidDevRun = SegDispidList.dispidDevRun;
pub const dispidDevPause = SegDispidList.dispidDevPause;
pub const dispidDevStop = SegDispidList.dispidDevStop;
pub const dispidCCEnable = SegDispidList.dispidCCEnable;
pub const dispidDevStep = SegDispidList.dispidDevStep;
pub const dispidDevCanStep = SegDispidList.dispidDevCanStep;
pub const dispidSourceSize = SegDispidList.dispidSourceSize;
pub const dispid_playtitle = SegDispidList.dispid_playtitle;
pub const dispid_playchapterintitle = SegDispidList.dispid_playchapterintitle;
pub const dispid_playchapter = SegDispidList.dispid_playchapter;
pub const dispid_playchaptersautostop = SegDispidList.dispid_playchaptersautostop;
pub const dispid_playattime = SegDispidList.dispid_playattime;
pub const dispid_playattimeintitle = SegDispidList.dispid_playattimeintitle;
pub const dispid_playperiodintitleautostop = SegDispidList.dispid_playperiodintitleautostop;
pub const dispid_replaychapter = SegDispidList.dispid_replaychapter;
pub const dispid_playprevchapter = SegDispidList.dispid_playprevchapter;
pub const dispid_playnextchapter = SegDispidList.dispid_playnextchapter;
pub const dispid_playforwards = SegDispidList.dispid_playforwards;
pub const dispid_playbackwards = SegDispidList.dispid_playbackwards;
pub const dispid_stilloff = SegDispidList.dispid_stilloff;
pub const dispid_audiolanguage = SegDispidList.dispid_audiolanguage;
pub const dispid_showmenu = SegDispidList.dispid_showmenu;
pub const dispid_resume = SegDispidList.dispid_resume;
pub const dispid_returnfromsubmenu = SegDispidList.dispid_returnfromsubmenu;
pub const dispid_buttonsavailable = SegDispidList.dispid_buttonsavailable;
pub const dispid_currentbutton = SegDispidList.dispid_currentbutton;
pub const dispid_SelectAndActivateButton = SegDispidList.dispid_SelectAndActivateButton;
pub const dispid_ActivateButton = SegDispidList.dispid_ActivateButton;
pub const dispid_SelectRightButton = SegDispidList.dispid_SelectRightButton;
pub const dispid_SelectLeftButton = SegDispidList.dispid_SelectLeftButton;
pub const dispid_SelectLowerButton = SegDispidList.dispid_SelectLowerButton;
pub const dispid_SelectUpperButton = SegDispidList.dispid_SelectUpperButton;
pub const dispid_ActivateAtPosition = SegDispidList.dispid_ActivateAtPosition;
pub const dispid_SelectAtPosition = SegDispidList.dispid_SelectAtPosition;
pub const dispid_ButtonAtPosition = SegDispidList.dispid_ButtonAtPosition;
pub const dispid_NumberOfChapters = SegDispidList.dispid_NumberOfChapters;
pub const dispid_TotalTitleTime = SegDispidList.dispid_TotalTitleTime;
pub const dispid_TitlesAvailable = SegDispidList.dispid_TitlesAvailable;
pub const dispid_VolumesAvailable = SegDispidList.dispid_VolumesAvailable;
pub const dispid_CurrentVolume = SegDispidList.dispid_CurrentVolume;
pub const dispid_CurrentDiscSide = SegDispidList.dispid_CurrentDiscSide;
pub const dispid_CurrentDomain = SegDispidList.dispid_CurrentDomain;
pub const dispid_CurrentChapter = SegDispidList.dispid_CurrentChapter;
pub const dispid_CurrentTitle = SegDispidList.dispid_CurrentTitle;
pub const dispid_CurrentTime = SegDispidList.dispid_CurrentTime;
pub const dispid_FramesPerSecond = SegDispidList.dispid_FramesPerSecond;
pub const dispid_DVDTimeCode2bstr = SegDispidList.dispid_DVDTimeCode2bstr;
pub const dispid_DVDDirectory = SegDispidList.dispid_DVDDirectory;
pub const dispid_IsSubpictureStreamEnabled = SegDispidList.dispid_IsSubpictureStreamEnabled;
pub const dispid_IsAudioStreamEnabled = SegDispidList.dispid_IsAudioStreamEnabled;
pub const dispid_CurrentSubpictureStream = SegDispidList.dispid_CurrentSubpictureStream;
pub const dispid_SubpictureLanguage = SegDispidList.dispid_SubpictureLanguage;
pub const dispid_CurrentAudioStream = SegDispidList.dispid_CurrentAudioStream;
pub const dispid_AudioStreamsAvailable = SegDispidList.dispid_AudioStreamsAvailable;
pub const dispid_AnglesAvailable = SegDispidList.dispid_AnglesAvailable;
pub const dispid_CurrentAngle = SegDispidList.dispid_CurrentAngle;
pub const dispid_CCActive = SegDispidList.dispid_CCActive;
pub const dispid_CurrentCCService = SegDispidList.dispid_CurrentCCService;
pub const dispid_SubpictureStreamsAvailable = SegDispidList.dispid_SubpictureStreamsAvailable;
pub const dispid_SubpictureOn = SegDispidList.dispid_SubpictureOn;
pub const dispid_DVDUniqueID = SegDispidList.dispid_DVDUniqueID;
pub const dispid_EnableResetOnStop = SegDispidList.dispid_EnableResetOnStop;
pub const dispid_AcceptParentalLevelChange = SegDispidList.dispid_AcceptParentalLevelChange;
pub const dispid_NotifyParentalLevelChange = SegDispidList.dispid_NotifyParentalLevelChange;
pub const dispid_SelectParentalCountry = SegDispidList.dispid_SelectParentalCountry;
pub const dispid_SelectParentalLevel = SegDispidList.dispid_SelectParentalLevel;
pub const dispid_TitleParentalLevels = SegDispidList.dispid_TitleParentalLevels;
pub const dispid_PlayerParentalCountry = SegDispidList.dispid_PlayerParentalCountry;
pub const dispid_PlayerParentalLevel = SegDispidList.dispid_PlayerParentalLevel;
pub const dispid_Eject = SegDispidList.dispid_Eject;
pub const dispid_UOPValid = SegDispidList.dispid_UOPValid;
pub const dispid_SPRM = SegDispidList.dispid_SPRM;
pub const dispid_GPRM = SegDispidList.dispid_GPRM;
pub const dispid_DVDTextStringType = SegDispidList.dispid_DVDTextStringType;
pub const dispid_DVDTextString = SegDispidList.dispid_DVDTextString;
pub const dispid_DVDTextNumberOfStrings = SegDispidList.dispid_DVDTextNumberOfStrings;
pub const dispid_DVDTextNumberOfLanguages = SegDispidList.dispid_DVDTextNumberOfLanguages;
pub const dispid_DVDTextLanguageLCID = SegDispidList.dispid_DVDTextLanguageLCID;
pub const dispid_RegionChange = SegDispidList.dispid_RegionChange;
pub const dispid_DVDAdm = SegDispidList.dispid_DVDAdm;
pub const dispid_DeleteBookmark = SegDispidList.dispid_DeleteBookmark;
pub const dispid_RestoreBookmark = SegDispidList.dispid_RestoreBookmark;
pub const dispid_SaveBookmark = SegDispidList.dispid_SaveBookmark;
pub const dispid_SelectDefaultAudioLanguage = SegDispidList.dispid_SelectDefaultAudioLanguage;
pub const dispid_SelectDefaultSubpictureLanguage = SegDispidList.dispid_SelectDefaultSubpictureLanguage;
pub const dispid_PreferredSubpictureStream = SegDispidList.dispid_PreferredSubpictureStream;
pub const dispid_DefaultMenuLanguage = SegDispidList.dispid_DefaultMenuLanguage;
pub const dispid_DefaultSubpictureLanguage = SegDispidList.dispid_DefaultSubpictureLanguage;
pub const dispid_DefaultAudioLanguage = SegDispidList.dispid_DefaultAudioLanguage;
pub const dispid_DefaultSubpictureLanguageExt = SegDispidList.dispid_DefaultSubpictureLanguageExt;
pub const dispid_DefaultAudioLanguageExt = SegDispidList.dispid_DefaultAudioLanguageExt;
pub const dispid_LanguageFromLCID = SegDispidList.dispid_LanguageFromLCID;
pub const dispid_KaraokeAudioPresentationMode = SegDispidList.dispid_KaraokeAudioPresentationMode;
pub const dispid_KaraokeChannelContent = SegDispidList.dispid_KaraokeChannelContent;
pub const dispid_KaraokeChannelAssignment = SegDispidList.dispid_KaraokeChannelAssignment;
pub const dispid_RestorePreferredSettings = SegDispidList.dispid_RestorePreferredSettings;
pub const dispid_ButtonRect = SegDispidList.dispid_ButtonRect;
pub const dispid_DVDScreenInMouseCoordinates = SegDispidList.dispid_DVDScreenInMouseCoordinates;
pub const dispid_CustomCompositorClass = SegDispidList.dispid_CustomCompositorClass;
pub const dispidCustomCompositorClass = SegDispidList.dispidCustomCompositorClass;
pub const dispid_CustomCompositor = SegDispidList.dispid_CustomCompositor;
pub const dispidMixerBitmap = SegDispidList.dispidMixerBitmap;
pub const dispid_MixerBitmap = SegDispidList.dispid_MixerBitmap;
pub const dispidMixerBitmapOpacity = SegDispidList.dispidMixerBitmapOpacity;
pub const dispidMixerBitmapRect = SegDispidList.dispidMixerBitmapRect;
pub const dispidSetupMixerBitmap = SegDispidList.dispidSetupMixerBitmap;
pub const dispidUsingOverlay = SegDispidList.dispidUsingOverlay;
pub const dispidDisplayChange = SegDispidList.dispidDisplayChange;
pub const dispidRePaint = SegDispidList.dispidRePaint;
pub const dispid_IsEqualDevice = SegDispidList.dispid_IsEqualDevice;
pub const dispidrate = SegDispidList.dispidrate;
pub const dispidposition = SegDispidList.dispidposition;
pub const dispidpositionmode = SegDispidList.dispidpositionmode;
pub const dispidlength = SegDispidList.dispidlength;
pub const dispidChangePassword = SegDispidList.dispidChangePassword;
pub const dispidSaveParentalLevel = SegDispidList.dispidSaveParentalLevel;
pub const dispidSaveParentalCountry = SegDispidList.dispidSaveParentalCountry;
pub const dispidConfirmPassword = SegDispidList.dispidConfirmPassword;
pub const dispidGetParentalLevel = SegDispidList.dispidGetParentalLevel;
pub const dispidGetParentalCountry = SegDispidList.dispidGetParentalCountry;
pub const dispidDefaultAudioLCID = SegDispidList.dispidDefaultAudioLCID;
pub const dispidDefaultSubpictureLCID = SegDispidList.dispidDefaultSubpictureLCID;
pub const dispidDefaultMenuLCID = SegDispidList.dispidDefaultMenuLCID;
pub const dispidBookmarkOnStop = SegDispidList.dispidBookmarkOnStop;
pub const dispidMaxVidRect = SegDispidList.dispidMaxVidRect;
pub const dispidMinVidRect = SegDispidList.dispidMinVidRect;
pub const dispidCapture = SegDispidList.dispidCapture;
pub const dispid_DecimateInput = SegDispidList.dispid_DecimateInput;
pub const dispidAlloctor = SegDispidList.dispidAlloctor;
pub const dispid_Allocator = SegDispidList.dispid_Allocator;
pub const dispidAllocPresentID = SegDispidList.dispidAllocPresentID;
pub const dispidSetAllocator = SegDispidList.dispidSetAllocator;
pub const dispid_SetAllocator = SegDispidList.dispid_SetAllocator;
pub const dispidStreamBufferSinkName = SegDispidList.dispidStreamBufferSinkName;
pub const dispidStreamBufferSourceName = SegDispidList.dispidStreamBufferSourceName;
pub const dispidStreamBufferContentRecording = SegDispidList.dispidStreamBufferContentRecording;
pub const dispidStreamBufferReferenceRecording = SegDispidList.dispidStreamBufferReferenceRecording;
pub const dispidstarttime = SegDispidList.dispidstarttime;
pub const dispidstoptime = SegDispidList.dispidstoptime;
pub const dispidrecordingstopped = SegDispidList.dispidrecordingstopped;
pub const dispidrecordingstarted = SegDispidList.dispidrecordingstarted;
pub const dispidNameSetLock = SegDispidList.dispidNameSetLock;
pub const dispidrecordingtype = SegDispidList.dispidrecordingtype;
pub const dispidstart = SegDispidList.dispidstart;
pub const dispidRecordingAttribute = SegDispidList.dispidRecordingAttribute;
pub const dispid_RecordingAttribute = SegDispidList.dispid_RecordingAttribute;
pub const dispidSBEConfigure = SegDispidList.dispidSBEConfigure;
pub const dispid_CurrentRatings = SegDispidList.dispid_CurrentRatings;
pub const dispid_MaxRatingsLevel = SegDispidList.dispid_MaxRatingsLevel;
pub const dispid_audioencoderint = SegDispidList.dispid_audioencoderint;
pub const dispid_videoencoderint = SegDispidList.dispid_videoencoderint;
pub const dispidService = SegDispidList.dispidService;
pub const dispid_BlockUnrated = SegDispidList.dispid_BlockUnrated;
pub const dispid_UnratedDelay = SegDispidList.dispid_UnratedDelay;
pub const dispid_SuppressEffects = SegDispidList.dispid_SuppressEffects;
pub const dispidsbesource = SegDispidList.dispidsbesource;
pub const dispidSetSinkFilter = SegDispidList.dispidSetSinkFilter;
pub const dispid_SinkStreams = SegDispidList.dispid_SinkStreams;
pub const dispidTVFormats = SegDispidList.dispidTVFormats;
pub const dispidModes = SegDispidList.dispidModes;
pub const dispidAuxInputs = SegDispidList.dispidAuxInputs;
pub const dispidTeleTextFilter = SegDispidList.dispidTeleTextFilter;
pub const dispid_channelchangeint = SegDispidList.dispid_channelchangeint;
pub const dispidUnlockProfile = SegDispidList.dispidUnlockProfile;
pub const dispid_AddFilter = SegDispidList.dispid_AddFilter;
pub const dispidSetMinSeek = SegDispidList.dispidSetMinSeek;
pub const dispidRateEx = SegDispidList.dispidRateEx;
pub const dispidaudiocounter = SegDispidList.dispidaudiocounter;
pub const dispidvideocounter = SegDispidList.dispidvideocounter;
pub const dispidcccounter = SegDispidList.dispidcccounter;
pub const dispidwstcounter = SegDispidList.dispidwstcounter;
pub const dispid_audiocounter = SegDispidList.dispid_audiocounter;
pub const dispid_videocounter = SegDispidList.dispid_videocounter;
pub const dispid_cccounter = SegDispidList.dispid_cccounter;
pub const dispid_wstcounter = SegDispidList.dispid_wstcounter;
pub const dispidaudioanalysis = SegDispidList.dispidaudioanalysis;
pub const dispidvideoanalysis = SegDispidList.dispidvideoanalysis;
pub const dispiddataanalysis = SegDispidList.dispiddataanalysis;
pub const dispidaudio_analysis = SegDispidList.dispidaudio_analysis;
pub const dispidvideo_analysis = SegDispidList.dispidvideo_analysis;
pub const dispiddata_analysis = SegDispidList.dispiddata_analysis;
pub const dispid_resetFilterList = SegDispidList.dispid_resetFilterList;
pub const dispidDevicePath = SegDispidList.dispidDevicePath;
pub const dispid_SourceFilter = SegDispidList.dispid_SourceFilter;
pub const dispid__SourceFilter = SegDispidList.dispid__SourceFilter;
pub const dispidUserEvent = SegDispidList.dispidUserEvent;
pub const dispid_Bookmark = SegDispidList.dispid_Bookmark;
pub const LastReservedDeviceDispid = SegDispidList.LastReservedDeviceDispid;

pub const SegEventidList = enum(i32) {
    eventidStateChange = 0,
    eventidOnTuneChanged = 1,
    eventidEndOfMedia = 2,
    eventidDVDNotify = 3,
    eventidPlayForwards = 4,
    eventidPlayBackwards = 5,
    eventidShowMenu = 6,
    eventidResume = 7,
    eventidSelectOrActivateButton = 8,
    eventidStillOff = 9,
    eventidPauseOn = 10,
    eventidChangeCurrentAudioStream = 11,
    eventidChangeCurrentSubpictureStream = 12,
    eventidChangeCurrentAngle = 13,
    eventidPlayAtTimeInTitle = 14,
    eventidPlayAtTime = 15,
    eventidPlayChapterInTitle = 16,
    eventidPlayChapter = 17,
    eventidReplayChapter = 18,
    eventidPlayNextChapter = 19,
    eventidStop = 20,
    eventidReturnFromSubmenu = 21,
    eventidPlayTitle = 22,
    eventidPlayPrevChapter = 23,
    eventidChangeKaraokePresMode = 24,
    eventidChangeVideoPresMode = 25,
    eventidOverlayUnavailable = 26,
    eventidSinkCertificateFailure = 27,
    eventidSinkCertificateSuccess = 28,
    eventidSourceCertificateFailure = 29,
    eventidSourceCertificateSuccess = 30,
    eventidRatingsBlocked = 31,
    eventidRatingsUnlocked = 32,
    eventidRatingsChanged = 33,
    eventidWriteFailure = 34,
    eventidTimeHole = 35,
    eventidStaleDataRead = 36,
    eventidContentBecomingStale = 37,
    eventidStaleFileDeleted = 38,
    eventidEncryptionOn = 39,
    eventidEncryptionOff = 40,
    eventidRateChange = 41,
    eventidLicenseChange = 42,
    eventidCOPPBlocked = 43,
    eventidCOPPUnblocked = 44,
    dispidlicenseerrorcode = 45,
    eventidBroadcastEvent = 46,
    eventidBroadcastEventEx = 47,
    eventidContentPrimarilyAudio = 48,
    dispidAVDecAudioDualMonoEvent = 49,
    dispidAVAudioSampleRateEvent = 50,
    dispidAVAudioChannelConfigEvent = 51,
    dispidAVAudioChannelCountEvent = 52,
    dispidAVDecCommonMeanBitRateEvent = 53,
    dispidAVDDSurroundModeEvent = 54,
    dispidAVDecCommonInputFormatEvent = 55,
    dispidAVDecCommonOutputFormatEvent = 56,
    eventidWriteFailureClear = 57,
    LastReservedDeviceEvent = 16383,
};
pub const eventidStateChange = SegEventidList.eventidStateChange;
pub const eventidOnTuneChanged = SegEventidList.eventidOnTuneChanged;
pub const eventidEndOfMedia = SegEventidList.eventidEndOfMedia;
pub const eventidDVDNotify = SegEventidList.eventidDVDNotify;
pub const eventidPlayForwards = SegEventidList.eventidPlayForwards;
pub const eventidPlayBackwards = SegEventidList.eventidPlayBackwards;
pub const eventidShowMenu = SegEventidList.eventidShowMenu;
pub const eventidResume = SegEventidList.eventidResume;
pub const eventidSelectOrActivateButton = SegEventidList.eventidSelectOrActivateButton;
pub const eventidStillOff = SegEventidList.eventidStillOff;
pub const eventidPauseOn = SegEventidList.eventidPauseOn;
pub const eventidChangeCurrentAudioStream = SegEventidList.eventidChangeCurrentAudioStream;
pub const eventidChangeCurrentSubpictureStream = SegEventidList.eventidChangeCurrentSubpictureStream;
pub const eventidChangeCurrentAngle = SegEventidList.eventidChangeCurrentAngle;
pub const eventidPlayAtTimeInTitle = SegEventidList.eventidPlayAtTimeInTitle;
pub const eventidPlayAtTime = SegEventidList.eventidPlayAtTime;
pub const eventidPlayChapterInTitle = SegEventidList.eventidPlayChapterInTitle;
pub const eventidPlayChapter = SegEventidList.eventidPlayChapter;
pub const eventidReplayChapter = SegEventidList.eventidReplayChapter;
pub const eventidPlayNextChapter = SegEventidList.eventidPlayNextChapter;
pub const eventidStop = SegEventidList.eventidStop;
pub const eventidReturnFromSubmenu = SegEventidList.eventidReturnFromSubmenu;
pub const eventidPlayTitle = SegEventidList.eventidPlayTitle;
pub const eventidPlayPrevChapter = SegEventidList.eventidPlayPrevChapter;
pub const eventidChangeKaraokePresMode = SegEventidList.eventidChangeKaraokePresMode;
pub const eventidChangeVideoPresMode = SegEventidList.eventidChangeVideoPresMode;
pub const eventidOverlayUnavailable = SegEventidList.eventidOverlayUnavailable;
pub const eventidSinkCertificateFailure = SegEventidList.eventidSinkCertificateFailure;
pub const eventidSinkCertificateSuccess = SegEventidList.eventidSinkCertificateSuccess;
pub const eventidSourceCertificateFailure = SegEventidList.eventidSourceCertificateFailure;
pub const eventidSourceCertificateSuccess = SegEventidList.eventidSourceCertificateSuccess;
pub const eventidRatingsBlocked = SegEventidList.eventidRatingsBlocked;
pub const eventidRatingsUnlocked = SegEventidList.eventidRatingsUnlocked;
pub const eventidRatingsChanged = SegEventidList.eventidRatingsChanged;
pub const eventidWriteFailure = SegEventidList.eventidWriteFailure;
pub const eventidTimeHole = SegEventidList.eventidTimeHole;
pub const eventidStaleDataRead = SegEventidList.eventidStaleDataRead;
pub const eventidContentBecomingStale = SegEventidList.eventidContentBecomingStale;
pub const eventidStaleFileDeleted = SegEventidList.eventidStaleFileDeleted;
pub const eventidEncryptionOn = SegEventidList.eventidEncryptionOn;
pub const eventidEncryptionOff = SegEventidList.eventidEncryptionOff;
pub const eventidRateChange = SegEventidList.eventidRateChange;
pub const eventidLicenseChange = SegEventidList.eventidLicenseChange;
pub const eventidCOPPBlocked = SegEventidList.eventidCOPPBlocked;
pub const eventidCOPPUnblocked = SegEventidList.eventidCOPPUnblocked;
pub const dispidlicenseerrorcode = SegEventidList.dispidlicenseerrorcode;
pub const eventidBroadcastEvent = SegEventidList.eventidBroadcastEvent;
pub const eventidBroadcastEventEx = SegEventidList.eventidBroadcastEventEx;
pub const eventidContentPrimarilyAudio = SegEventidList.eventidContentPrimarilyAudio;
pub const dispidAVDecAudioDualMonoEvent = SegEventidList.dispidAVDecAudioDualMonoEvent;
pub const dispidAVAudioSampleRateEvent = SegEventidList.dispidAVAudioSampleRateEvent;
pub const dispidAVAudioChannelConfigEvent = SegEventidList.dispidAVAudioChannelConfigEvent;
pub const dispidAVAudioChannelCountEvent = SegEventidList.dispidAVAudioChannelCountEvent;
pub const dispidAVDecCommonMeanBitRateEvent = SegEventidList.dispidAVDecCommonMeanBitRateEvent;
pub const dispidAVDDSurroundModeEvent = SegEventidList.dispidAVDDSurroundModeEvent;
pub const dispidAVDecCommonInputFormatEvent = SegEventidList.dispidAVDecCommonInputFormatEvent;
pub const dispidAVDecCommonOutputFormatEvent = SegEventidList.dispidAVDecCommonOutputFormatEvent;
pub const eventidWriteFailureClear = SegEventidList.eventidWriteFailureClear;
pub const LastReservedDeviceEvent = SegEventidList.LastReservedDeviceEvent;

pub const PositionModeList = enum(i32) {
    FrameMode = 0,
    TenthsSecondsMode = 1,
};
pub const FrameMode = PositionModeList.FrameMode;
pub const TenthsSecondsMode = PositionModeList.TenthsSecondsMode;

pub const RecordingType = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const CONTENT = RecordingType.CONTENT;
pub const REFERENCE = RecordingType.REFERENCE;

pub const MSVidCCService = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const MSVidSinkStreams = enum(i32) {
    Video = 1,
    Audio = 2,
    Other = 4,
};
pub const MSVidSink_Video = MSVidSinkStreams.Video;
pub const MSVidSink_Audio = MSVidSinkStreams.Audio;
pub const MSVidSink_Other = MSVidSinkStreams.Other;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidRect_Value = Guid.initString("7f5000a6-a440-47ca-8acc-c0e75531a2c2");
pub const IID_IMSVidRect = &IID_IMSVidRect_Value;
pub const IMSVidRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            top_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            top_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            left_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            left_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            width_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            width_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            height_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            height_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWnd: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            h_wnd_val: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HWnd: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            h_wnd_val: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidRect,
            rect_val: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getTop(self: *const T, top_val_: ?*i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IMSVidRect, @ptrCast(self)), top_val_);
            }
            pub inline fn putTop(self: *const T, top_val_: i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IMSVidRect, @ptrCast(self)), top_val_);
            }
            pub inline fn getLeft(self: *const T, left_val_: ?*i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IMSVidRect, @ptrCast(self)), left_val_);
            }
            pub inline fn putLeft(self: *const T, left_val_: i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IMSVidRect, @ptrCast(self)), left_val_);
            }
            pub inline fn getWidth(self: *const T, width_val_: ?*i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IMSVidRect, @ptrCast(self)), width_val_);
            }
            pub inline fn putWidth(self: *const T, width_val_: i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IMSVidRect, @ptrCast(self)), width_val_);
            }
            pub inline fn getHeight(self: *const T, height_val_: ?*i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IMSVidRect, @ptrCast(self)), height_val_);
            }
            pub inline fn putHeight(self: *const T, height_val_: i32) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IMSVidRect, @ptrCast(self)), height_val_);
            }
            pub inline fn getHWnd(self: *const T, h_wnd_val_: ?*?HWND) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_HWnd(@as(*const IMSVidRect, @ptrCast(self)), h_wnd_val_);
            }
            pub inline fn putHWnd(self: *const T, h_wnd_val_: ?HWND) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_HWnd(@as(*const IMSVidRect, @ptrCast(self)), h_wnd_val_);
            }
            pub inline fn putRect(self: *const T, rect_val_: ?*IMSVidRect) HRESULT {
                return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Rect(@as(*const IMSVidRect, @ptrCast(self)), rect_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidGraphSegmentContainer_Value = Guid.initString("3dd2903d-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidGraphSegmentContainer = &IID_IMSVidGraphSegmentContainer_Value;
pub const IMSVidGraphSegmentContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Graph: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_graph: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Input: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_input: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Outputs: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_outputs: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_v_r: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_a_r: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Features: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_features: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Composites: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_composites: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentContainer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegmentContainer,
            pp_container: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: *const fn (
            self: *const IMSVidGraphSegmentContainer,
            p_segment: ?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsWindowless: *const fn (
            self: *const IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: *const fn (
            self: *const IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getGraph(self: *const T, pp_graph_: ?*?*IGraphBuilder) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Graph(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_graph_);
            }
            pub inline fn getInput(self: *const T, pp_input_: ?*?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Input(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_input_);
            }
            pub inline fn getOutputs(self: *const T, pp_outputs_: ?*?*IEnumMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Outputs(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_outputs_);
            }
            pub inline fn getVideoRenderer(self: *const T, pp_v_r_: ?*?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_VideoRenderer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_v_r_);
            }
            pub inline fn getAudioRenderer(self: *const T, pp_a_r_: ?*?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_AudioRenderer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_a_r_);
            }
            pub inline fn getFeatures(self: *const T, pp_features_: ?*?*IEnumMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Features(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_features_);
            }
            pub inline fn getComposites(self: *const T, pp_composites_: ?*?*IEnumMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Composites(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_composites_);
            }
            pub inline fn getParentContainer(self: *const T, pp_container_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_ParentContainer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pp_container_);
            }
            pub inline fn decompose(self: *const T, p_segment_: ?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), p_segment_);
            }
            pub inline fn isWindowless(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).IsWindowless(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)));
            }
            pub inline fn getFocus(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidSegmentType = enum(i32) {
    SOURCE = 0,
    XFORM = 1,
    DEST = 2,
};
pub const MSVidSEG_SOURCE = MSVidSegmentType.SOURCE;
pub const MSVidSEG_XFORM = MSVidSegmentType.XFORM;
pub const MSVidSEG_DEST = MSVidSegmentType.DEST;

const IID_IMSVidGraphSegment_Value = Guid.initString("238dec54-adeb-4005-a349-f772b9afebc4");
pub const IID_IMSVidGraphSegment = &IID_IMSVidGraphSegment_Value;
pub const IMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Init: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            p_init: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Init: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            p_init: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFilters: *const fn (
            self: *const IMSVidGraphSegment,
            p_new_enum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            pp_ctl: ?*?*IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Container: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            p_ctl: ?*IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            p_type: ?*MSVidSegmentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGraphSegment,
            p_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Build: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostBuild: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreRun: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostRun: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreStop: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostStop: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEventNotify: *const fn (
            self: *const IMSVidGraphSegment,
            l_event_code: i32,
            l_event_parm1: isize,
            l_event_parm2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: *const fn (
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            pub inline fn getInit(self: *const T, p_init_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Init(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_init_);
            }
            pub inline fn putInit(self: *const T, p_init_: ?*IUnknown) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).put_Init(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_init_);
            }
            pub inline fn enumFilters(self: *const T, p_new_enum_: ?*?*IEnumFilters) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).EnumFilters(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_new_enum_);
            }
            pub inline fn getContainer(self: *const T, pp_ctl_: ?*?*IMSVidGraphSegmentContainer) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Container(@as(*const IMSVidGraphSegment, @ptrCast(self)), pp_ctl_);
            }
            pub inline fn putContainer(self: *const T, p_ctl_: ?*IMSVidGraphSegmentContainer) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).put_Container(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_ctl_);
            }
            pub inline fn getType(self: *const T, p_type_: ?*MSVidSegmentType) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_type_);
            }
            pub inline fn getCategory(self: *const T, p_guid_: ?*Guid) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IMSVidGraphSegment, @ptrCast(self)), p_guid_);
            }
            pub inline fn build(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Build(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn postBuild(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostBuild(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn preRun(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PreRun(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn postRun(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostRun(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn preStop(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PreStop(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn postStop(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostStop(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn onEventNotify(self: *const T, l_event_code_: i32, l_event_parm1_: isize, l_event_parm2_: isize) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).OnEventNotify(@as(*const IMSVidGraphSegment, @ptrCast(self)), l_event_code_, l_event_parm1_, l_event_parm2_);
            }
            pub inline fn decompose(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidGraphSegment, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidCtlButtonstate = enum(i32) {
    LEFT_BUTTON = 1,
    RIGHT_BUTTON = 2,
    MIDDLE_BUTTON = 4,
    X_BUTTON1 = 8,
    X_BUTTON2 = 16,
    // SHIFT = 1, this enum value conflicts with LEFT_BUTTON
    // CTRL = 2, this enum value conflicts with RIGHT_BUTTON
    // ALT = 4, this enum value conflicts with MIDDLE_BUTTON
};
pub const MSVIDCTL_LEFT_BUTTON = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_RIGHT_BUTTON = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_MIDDLE_BUTTON = MSVidCtlButtonstate.MIDDLE_BUTTON;
pub const MSVIDCTL_X_BUTTON1 = MSVidCtlButtonstate.X_BUTTON1;
pub const MSVIDCTL_X_BUTTON2 = MSVidCtlButtonstate.X_BUTTON2;
pub const MSVIDCTL_SHIFT = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_CTRL = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_ALT = MSVidCtlButtonstate.MIDDLE_BUTTON;

const IID_IMSVidGraphSegmentUserInput_Value = Guid.initString("301c060e-20d9-4587-9b03-f82ed9a9943c");
pub const IID_IMSVidGraphSegmentUserInput = &IID_IMSVidGraphSegmentUserInput_Value;
pub const IMSVidGraphSegmentUserInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Click: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DblClick: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyDown: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            key_code: ?*i16,
            shift_state: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyPress: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            key_ascii: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyUp: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            key_code: ?*i16,
            shift_state: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseDown: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            button_state: i16,
            shift_state: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseMove: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            button_state: i16,
            shift_state: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseUp: *const fn (
            self: *const IMSVidGraphSegmentUserInput,
            button_state: i16,
            shift_state: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn click(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).Click(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)));
            }
            pub inline fn dblClick(self: *const T) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).DblClick(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)));
            }
            pub inline fn keyDown(self: *const T, key_code_: ?*i16, shift_state_: i16) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyDown(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), key_code_, shift_state_);
            }
            pub inline fn keyPress(self: *const T, key_ascii_: ?*i16) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyPress(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), key_ascii_);
            }
            pub inline fn keyUp(self: *const T, key_code_: ?*i16, shift_state_: i16) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyUp(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), key_code_, shift_state_);
            }
            pub inline fn mouseDown(self: *const T, button_state_: i16, shift_state_: i16, x_: i32, y_: i32) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseDown(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), button_state_, shift_state_, x_, y_);
            }
            pub inline fn mouseMove(self: *const T, button_state_: i16, shift_state_: i16, x_: i32, y_: i32) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseMove(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), button_state_, shift_state_, x_, y_);
            }
            pub inline fn mouseUp(self: *const T, button_state_: i16, shift_state_: i16, x_: i32, y_: i32) HRESULT {
                return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseUp(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), button_state_, shift_state_, x_, y_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidCompositionSegment_Value = Guid.initString("1c15d483-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidCompositionSegment = &IID_IMSVidCompositionSegment_Value;
pub const IMSVidCompositionSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        Compose: *const fn (
            self: *const IMSVidCompositionSegment,
            upstream: ?*IMSVidGraphSegment,
            downstream: ?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Up: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCompositionSegment,
            upstream: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Down: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCompositionSegment,
            downstream: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
            pub inline fn compose(self: *const T, upstream_: ?*IMSVidGraphSegment, downstream_: ?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).Compose(@as(*const IMSVidCompositionSegment, @ptrCast(self)), upstream_, downstream_);
            }
            pub inline fn getUp(self: *const T, upstream_: ?*?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).get_Up(@as(*const IMSVidCompositionSegment, @ptrCast(self)), upstream_);
            }
            pub inline fn getDown(self: *const T, downstream_: ?*?*IMSVidGraphSegment) HRESULT {
                return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).get_Down(@as(*const IMSVidCompositionSegment, @ptrCast(self)), downstream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMSVidGraphSegment_Value = Guid.initString("3dd2903e-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IEnumMSVidGraphSegment = &IID_IEnumMSVidGraphSegment_Value;
pub const IEnumMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumMSVidGraphSegment,
            celt: u32,
            rgelt: ?*?*IMSVidGraphSegment,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumMSVidGraphSegment,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumMSVidGraphSegment,
            ppenum: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: ?*?*IMSVidGraphSegment, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumMSVidGraphSegment) HRESULT {
                return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVRGraphSegment_Value = Guid.initString("dd47de3f-9874-4f7b-8b22-7cb2688461e7");
pub const IID_IMSVidVRGraphSegment = &IID_IMSVidVRGraphSegment_Value;
pub const IMSVidVRGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VMRendererMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            dw_mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            window: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            window: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseOverlay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            use_overlay_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseOverlay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            use_overlay_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            visible: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            visible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            color_key: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            color_key: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Source: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            r: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Source: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            r: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Destination: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            r: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Destination: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            r: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NativeSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            sizeval: ?*SIZE,
            aspectratio: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            f_maintain: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVRGraphSegment,
            f_maintain: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: *const fn (
            self: *const IMSVidVRGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayChange: *const fn (
            self: *const IMSVidVRGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RePaint: *const fn (
            self: *const IMSVidVRGraphSegment,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
            pub inline fn putVMRendererMode(self: *const T, dw_mode_: i32) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put__VMRendererMode(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), dw_mode_);
            }
            pub inline fn putOwner(self: *const T, window_: ?HWND) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Owner(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), window_);
            }
            pub inline fn getOwner(self: *const T, window_: ?*?HWND) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Owner(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), window_);
            }
            pub inline fn getUseOverlay(self: *const T, use_overlay_val_: ?*i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_UseOverlay(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), use_overlay_val_);
            }
            pub inline fn putUseOverlay(self: *const T, use_overlay_val_: i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_UseOverlay(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), use_overlay_val_);
            }
            pub inline fn getVisible(self: *const T, visible_: ?*i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), visible_);
            }
            pub inline fn putVisible(self: *const T, visible_: i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), visible_);
            }
            pub inline fn getColorKey(self: *const T, color_key_: ?*u32) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_ColorKey(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color_key_);
            }
            pub inline fn putColorKey(self: *const T, color_key_: u32) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_ColorKey(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color_key_);
            }
            pub inline fn getSource(self: *const T, r_: ?*RECT) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Source(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r_);
            }
            pub inline fn putSource(self: *const T, r_: RECT) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Source(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r_);
            }
            pub inline fn getDestination(self: *const T, r_: ?*RECT) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Destination(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r_);
            }
            pub inline fn putDestination(self: *const T, r_: RECT) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Destination(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r_);
            }
            pub inline fn getNativeSize(self: *const T, sizeval_: ?*SIZE, aspectratio_: ?*SIZE) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_NativeSize(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), sizeval_, aspectratio_);
            }
            pub inline fn getBorderColor(self: *const T, color_: ?*u32) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_BorderColor(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color_);
            }
            pub inline fn putBorderColor(self: *const T, color_: u32) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_BorderColor(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color_);
            }
            pub inline fn getMaintainAspectRatio(self: *const T, f_maintain_: ?*i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_MaintainAspectRatio(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), f_maintain_);
            }
            pub inline fn putMaintainAspectRatio(self: *const T, f_maintain_: i16) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_MaintainAspectRatio(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), f_maintain_);
            }
            pub inline fn refresh(self: *const T) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IMSVidVRGraphSegment, @ptrCast(self)));
            }
            pub inline fn displayChange(self: *const T) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).DisplayChange(@as(*const IMSVidVRGraphSegment, @ptrCast(self)));
            }
            pub inline fn rePaint(self: *const T, hdc_: ?HDC) HRESULT {
                return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).RePaint(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), hdc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDevice_Value = Guid.initString("1c15d47c-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDevice = &IID_IMSVidDevice_Value;
pub const IMSVidDevice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            status: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Power: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            power: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Power: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            power: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            guid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            clsid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Category: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__ClassID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualDevice: *const fn (
            self: *const IMSVidDevice,
            device: ?*IMSVidDevice,
            is_equal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IMSVidDevice, @ptrCast(self)), name_);
            }
            pub inline fn getStatus(self: *const T, status_: ?*i32) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IMSVidDevice, @ptrCast(self)), status_);
            }
            pub inline fn putPower(self: *const T, power_: i16) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).put_Power(@as(*const IMSVidDevice, @ptrCast(self)), power_);
            }
            pub inline fn getPower(self: *const T, power_: ?*i16) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Power(@as(*const IMSVidDevice, @ptrCast(self)), power_);
            }
            pub inline fn getCategory(self: *const T, guid_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IMSVidDevice, @ptrCast(self)), guid_);
            }
            pub inline fn getClassID(self: *const T, clsid_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_ClassID(@as(*const IMSVidDevice, @ptrCast(self)), clsid_);
            }
            pub inline fn getCategory1(self: *const T, guid_: ?*Guid) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get__Category(@as(*const IMSVidDevice, @ptrCast(self)), guid_);
            }
            pub inline fn getClassID1(self: *const T, clsid_: ?*Guid) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get__ClassID(@as(*const IMSVidDevice, @ptrCast(self)), clsid_);
            }
            pub inline fn isEqualDevice(self: *const T, device_: ?*IMSVidDevice, is_equal_: ?*i16) HRESULT {
                return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).IsEqualDevice(@as(*const IMSVidDevice, @ptrCast(self)), device_, is_equal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDevice2_Value = Guid.initString("87bd2783-ebc0-478c-b4a0-e8e7f43ab78e");
pub const IID_IMSVidDevice2 = &IID_IMSVidDevice2_Value;
pub const IMSVidDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidDevice2,
            dev_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDevicePath(self: *const T, dev_path_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidDevice2.VTable, @ptrCast(self.vtable)).get_DevicePath(@as(*const IMSVidDevice2, @ptrCast(self)), dev_path_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevice_Value = Guid.initString("37b0353d-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDevice = &IID_IMSVidInputDevice_Value;
pub const IMSVidInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
        IsViewable: *const fn (
            self: *const IMSVidInputDevice,
            v: ?*VARIANT,
            pf_viewable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        View: *const fn (
            self: *const IMSVidInputDevice,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDevice.MethodMixin(T);
            pub inline fn isViewable(self: *const T, v_: ?*VARIANT, pf_viewable_: ?*i16) HRESULT {
                return @as(*const IMSVidInputDevice.VTable, @ptrCast(self.vtable)).IsViewable(@as(*const IMSVidInputDevice, @ptrCast(self)), v_, pf_viewable_);
            }
            pub inline fn view(self: *const T, v_: ?*VARIANT) HRESULT {
                return @as(*const IMSVidInputDevice.VTable, @ptrCast(self.vtable)).View(@as(*const IMSVidInputDevice, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDeviceEvent_Value = Guid.initString("1c15d480-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDeviceEvent = &IID_IMSVidDeviceEvent_Value;
pub const IMSVidDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StateChange: *const fn (
            self: *const IMSVidDeviceEvent,
            lpd: ?*IMSVidDevice,
            old_state: i32,
            new_state: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn stateChange(self: *const T, lpd_: ?*IMSVidDevice, old_state_: i32, new_state_: i32) HRESULT {
                return @as(*const IMSVidDeviceEvent.VTable, @ptrCast(self.vtable)).StateChange(@as(*const IMSVidDeviceEvent, @ptrCast(self)), lpd_, old_state_, new_state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidInputDeviceEvent_Value = Guid.initString("37b0353e-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDeviceEvent = &IID_IMSVidInputDeviceEvent_Value;
pub const IMSVidInputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoInputDevice_Value = Guid.initString("1c15d47f-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidVideoInputDevice = &IID_IMSVidVideoInputDevice_Value;
pub const IMSVidVideoInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidInputDevice.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidPlayback_Value = Guid.initString("37b03538-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlayback = &IID_IMSVidPlayback_Value;
pub const IMSVidPlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableResetOnStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableResetOnStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: *const fn (
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanStep: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            f_backwards: i16,
            pf_can: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Step: *const fn (
            self: *const IMSVidPlayback,
            l_step: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            pl_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            pl_rate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            l_position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            l_position: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PositionMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            l_position_mode: PositionModeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PositionMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            l_position_mode: ?*PositionModeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidPlayback,
            l_length: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidInputDevice.MethodMixin(T);
            pub inline fn getEnableResetOnStop(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_EnableResetOnStop(@as(*const IMSVidPlayback, @ptrCast(self)), p_val_);
            }
            pub inline fn putEnableResetOnStop(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_EnableResetOnStop(@as(*const IMSVidPlayback, @ptrCast(self)), new_val_);
            }
            pub inline fn run(self: *const T) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Run(@as(*const IMSVidPlayback, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMSVidPlayback, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidPlayback, @ptrCast(self)));
            }
            pub inline fn getCanStep(self: *const T, f_backwards_: i16, pf_can_: ?*i16) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_CanStep(@as(*const IMSVidPlayback, @ptrCast(self)), f_backwards_, pf_can_);
            }
            pub inline fn step(self: *const T, l_step_: i32) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Step(@as(*const IMSVidPlayback, @ptrCast(self)), l_step_);
            }
            pub inline fn putRate(self: *const T, pl_rate_: f64) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IMSVidPlayback, @ptrCast(self)), pl_rate_);
            }
            pub inline fn getRate(self: *const T, pl_rate_: ?*f64) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IMSVidPlayback, @ptrCast(self)), pl_rate_);
            }
            pub inline fn putCurrentPosition(self: *const T, l_position_: i32) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_CurrentPosition(@as(*const IMSVidPlayback, @ptrCast(self)), l_position_);
            }
            pub inline fn getCurrentPosition(self: *const T, l_position_: ?*i32) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_CurrentPosition(@as(*const IMSVidPlayback, @ptrCast(self)), l_position_);
            }
            pub inline fn putPositionMode(self: *const T, l_position_mode_: PositionModeList) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_PositionMode(@as(*const IMSVidPlayback, @ptrCast(self)), l_position_mode_);
            }
            pub inline fn getPositionMode(self: *const T, l_position_mode_: ?*PositionModeList) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_PositionMode(@as(*const IMSVidPlayback, @ptrCast(self)), l_position_mode_);
            }
            pub inline fn getLength(self: *const T, l_length_: ?*i32) HRESULT {
                return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_Length(@as(*const IMSVidPlayback, @ptrCast(self)), l_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidPlaybackEvent_Value = Guid.initString("37b0353b-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlaybackEvent = &IID_IMSVidPlaybackEvent_Value;
pub const IMSVidPlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        EndOfMedia: *const fn (
            self: *const IMSVidPlaybackEvent,
            lpd: ?*IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
            pub inline fn endOfMedia(self: *const T, lpd_: ?*IMSVidPlayback) HRESULT {
                return @as(*const IMSVidPlaybackEvent.VTable, @ptrCast(self.vtable)).EndOfMedia(@as(*const IMSVidPlaybackEvent, @ptrCast(self)), lpd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidTuner_Value = Guid.initString("1c15d47d-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTuner = &IID_IMSVidTuner_Value;
pub const IMSVidTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tune: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidTuner,
            pp_t_r: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Tune: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidTuner,
            p_t_r: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidTuner,
            pl_t_s: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidTuner,
            pl_t_s: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidVideoInputDevice.MethodMixin(T);
            pub inline fn getTune(self: *const T, pp_t_r_: ?*?*ITuneRequest) HRESULT {
                return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).get_Tune(@as(*const IMSVidTuner, @ptrCast(self)), pp_t_r_);
            }
            pub inline fn putTune(self: *const T, p_t_r_: ?*ITuneRequest) HRESULT {
                return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).put_Tune(@as(*const IMSVidTuner, @ptrCast(self)), p_t_r_);
            }
            pub inline fn getTuningSpace(self: *const T, pl_t_s_: ?*?*ITuningSpace) HRESULT {
                return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const IMSVidTuner, @ptrCast(self)), pl_t_s_);
            }
            pub inline fn putTuningSpace(self: *const T, pl_t_s_: ?*ITuningSpace) HRESULT {
                return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const IMSVidTuner, @ptrCast(self)), pl_t_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidTunerEvent_Value = Guid.initString("1c15d485-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTunerEvent = &IID_IMSVidTunerEvent_Value;
pub const IMSVidTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        TuneChanged: *const fn (
            self: *const IMSVidTunerEvent,
            lpd: ?*IMSVidTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
            pub inline fn tuneChanged(self: *const T, lpd_: ?*IMSVidTuner) HRESULT {
                return @as(*const IMSVidTunerEvent.VTable, @ptrCast(self.vtable)).TuneChanged(@as(*const IMSVidTunerEvent, @ptrCast(self)), lpd_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAnalogTuner_Value = Guid.initString("1c15d47e-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTuner = &IID_IMSVidAnalogTuner_Value;
pub const IMSVidAnalogTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            lcc: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            pf_sap_on: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAP: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner,
            f_sap_on: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChannelAvailable: *const fn (
            self: *const IMSVidAnalogTuner,
            n_channel: i32,
            signal_strength: ?*i32,
            f_signal_present: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidTuner.MethodMixin(T);
            pub inline fn getChannel(self: *const T, channel_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IMSVidAnalogTuner, @ptrCast(self)), channel_);
            }
            pub inline fn putChannel(self: *const T, channel_: i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IMSVidAnalogTuner, @ptrCast(self)), channel_);
            }
            pub inline fn getVideoFrequency(self: *const T, lcc_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_VideoFrequency(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc_);
            }
            pub inline fn getAudioFrequency(self: *const T, lcc_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_AudioFrequency(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc_);
            }
            pub inline fn getCountryCode(self: *const T, lcc_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc_);
            }
            pub inline fn putCountryCode(self: *const T, lcc_: i32) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc_);
            }
            pub inline fn getSAP(self: *const T, pf_sap_on_: ?*i16) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_SAP(@as(*const IMSVidAnalogTuner, @ptrCast(self)), pf_sap_on_);
            }
            pub inline fn putSAP(self: *const T, f_sap_on_: i16) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_SAP(@as(*const IMSVidAnalogTuner, @ptrCast(self)), f_sap_on_);
            }
            pub inline fn channelAvailable(self: *const T, n_channel_: i32, signal_strength_: ?*i32, f_signal_present_: ?*i16) HRESULT {
                return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).ChannelAvailable(@as(*const IMSVidAnalogTuner, @ptrCast(self)), n_channel_, signal_strength_, f_signal_present_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTuner2_Value = Guid.initString("37647bf7-3dde-4cc8-a4dc-0d534d3d0037");
pub const IID_IMSVidAnalogTuner2 = &IID_IMSVidAnalogTuner2_Value;
pub const IMSVidAnalogTuner2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAnalogTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormats: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner2,
            formats: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TunerModes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner2,
            modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumAuxInputs: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAnalogTuner2,
            inputs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidAnalogTuner.MethodMixin(T);
            pub inline fn getTVFormats(self: *const T, formats_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_TVFormats(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), formats_);
            }
            pub inline fn getTunerModes(self: *const T, modes_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_TunerModes(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), modes_);
            }
            pub inline fn getNumAuxInputs(self: *const T, inputs_: ?*i32) HRESULT {
                return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_NumAuxInputs(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), inputs_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTunerEvent_Value = Guid.initString("1c15d486-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTunerEvent = &IID_IMSVidAnalogTunerEvent_Value;
pub const IMSVidAnalogTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTunerEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidTunerEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFilePlayback_Value = Guid.initString("37b03539-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlayback = &IID_IMSVidFilePlayback_Value;
pub const IMSVidFilePlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFilePlayback,
            file_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFilePlayback,
            file_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidPlayback.MethodMixin(T);
            pub inline fn getFileName(self: *const T, file_name_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidFilePlayback.VTable, @ptrCast(self.vtable)).get_FileName(@as(*const IMSVidFilePlayback, @ptrCast(self)), file_name_);
            }
            pub inline fn putFileName(self: *const T, file_name_: ?BSTR) HRESULT {
                return @as(*const IMSVidFilePlayback.VTable, @ptrCast(self.vtable)).put_FileName(@as(*const IMSVidFilePlayback, @ptrCast(self)), file_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlayback2_Value = Guid.initString("2f7e44af-6e52-4660-bc08-d8d542587d72");
pub const IID_IMSVidFilePlayback2 = &IID_IMSVidFilePlayback2_Value;
pub const IMSVidFilePlayback2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__SourceFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFilePlayback2,
            file_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put___SourceFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFilePlayback2,
            file_name: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
            pub inline fn putSourceFilter(self: *const T, file_name_: ?BSTR) HRESULT {
                return @as(*const IMSVidFilePlayback2.VTable, @ptrCast(self.vtable)).put__SourceFilter(@as(*const IMSVidFilePlayback2, @ptrCast(self)), file_name_);
            }
            pub inline fn putSourceFilter1(self: *const T, file_name_: Guid) HRESULT {
                return @as(*const IMSVidFilePlayback2.VTable, @ptrCast(self.vtable)).put___SourceFilter(@as(*const IMSVidFilePlayback2, @ptrCast(self)), file_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlaybackEvent_Value = Guid.initString("37b0353a-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlaybackEvent = &IID_IMSVidFilePlaybackEvent_Value;
pub const IMSVidFilePlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVDMenuIDConstants = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const dvdMenu_Title = DVDMenuIDConstants.Title;
pub const dvdMenu_Root = DVDMenuIDConstants.Root;
pub const dvdMenu_Subpicture = DVDMenuIDConstants.Subpicture;
pub const dvdMenu_Audio = DVDMenuIDConstants.Audio;
pub const dvdMenu_Angle = DVDMenuIDConstants.Angle;
pub const dvdMenu_Chapter = DVDMenuIDConstants.Chapter;

pub const DVDFilterState = enum(i32) {
    Undefined = -2,
    Unitialized = -1,
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const dvdState_Undefined = DVDFilterState.Undefined;
pub const dvdState_Unitialized = DVDFilterState.Unitialized;
pub const dvdState_Stopped = DVDFilterState.Stopped;
pub const dvdState_Paused = DVDFilterState.Paused;
pub const dvdState_Running = DVDFilterState.Running;

pub const DVDTextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const dvdStruct_Volume = DVDTextStringType.Struct_Volume;
pub const dvdStruct_Title = DVDTextStringType.Struct_Title;
pub const dvdStruct_ParentalID = DVDTextStringType.Struct_ParentalID;
pub const dvdStruct_PartOfTitle = DVDTextStringType.Struct_PartOfTitle;
pub const dvdStruct_Cell = DVDTextStringType.Struct_Cell;
pub const dvdStream_Audio = DVDTextStringType.Stream_Audio;
pub const dvdStream_Subpicture = DVDTextStringType.Stream_Subpicture;
pub const dvdStream_Angle = DVDTextStringType.Stream_Angle;
pub const dvdChannel_Audio = DVDTextStringType.Channel_Audio;
pub const dvdGeneral_Name = DVDTextStringType.General_Name;
pub const dvdGeneral_Comments = DVDTextStringType.General_Comments;
pub const dvdTitle_Series = DVDTextStringType.Title_Series;
pub const dvdTitle_Movie = DVDTextStringType.Title_Movie;
pub const dvdTitle_Video = DVDTextStringType.Title_Video;
pub const dvdTitle_Album = DVDTextStringType.Title_Album;
pub const dvdTitle_Song = DVDTextStringType.Title_Song;
pub const dvdTitle_Other = DVDTextStringType.Title_Other;
pub const dvdTitle_Sub_Series = DVDTextStringType.Title_Sub_Series;
pub const dvdTitle_Sub_Movie = DVDTextStringType.Title_Sub_Movie;
pub const dvdTitle_Sub_Video = DVDTextStringType.Title_Sub_Video;
pub const dvdTitle_Sub_Album = DVDTextStringType.Title_Sub_Album;
pub const dvdTitle_Sub_Song = DVDTextStringType.Title_Sub_Song;
pub const dvdTitle_Sub_Other = DVDTextStringType.Title_Sub_Other;
pub const dvdTitle_Orig_Series = DVDTextStringType.Title_Orig_Series;
pub const dvdTitle_Orig_Movie = DVDTextStringType.Title_Orig_Movie;
pub const dvdTitle_Orig_Video = DVDTextStringType.Title_Orig_Video;
pub const dvdTitle_Orig_Album = DVDTextStringType.Title_Orig_Album;
pub const dvdTitle_Orig_Song = DVDTextStringType.Title_Orig_Song;
pub const dvdTitle_Orig_Other = DVDTextStringType.Title_Orig_Other;
pub const dvdOther_Scene = DVDTextStringType.Other_Scene;
pub const dvdOther_Cut = DVDTextStringType.Other_Cut;
pub const dvdOther_Take = DVDTextStringType.Other_Take;

pub const DVDSPExt = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const dvdSPExt_NotSpecified = DVDSPExt.NotSpecified;
pub const dvdSPExt_Caption_Normal = DVDSPExt.Caption_Normal;
pub const dvdSPExt_Caption_Big = DVDSPExt.Caption_Big;
pub const dvdSPExt_Caption_Children = DVDSPExt.Caption_Children;
pub const dvdSPExt_CC_Normal = DVDSPExt.CC_Normal;
pub const dvdSPExt_CC_Big = DVDSPExt.CC_Big;
pub const dvdSPExt_CC_Children = DVDSPExt.CC_Children;
pub const dvdSPExt_Forced = DVDSPExt.Forced;
pub const dvdSPExt_DirectorComments_Normal = DVDSPExt.DirectorComments_Normal;
pub const dvdSPExt_DirectorComments_Big = DVDSPExt.DirectorComments_Big;
pub const dvdSPExt_DirectorComments_Children = DVDSPExt.DirectorComments_Children;

const IID_IMSVidWebDVD_Value = Guid.initString("cf45f88b-ac56-4ee2-a73a-ed04e2885d3c");
pub const IID_IMSVidWebDVD = &IID_IMSVidWebDVD_Value;
pub const IMSVidWebDVD = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        OnDVDEvent: *const fn (
            self: *const IMSVidWebDVD,
            l_event: i32,
            l_param1: isize,
            l_param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayTitle: *const fn (
            self: *const IMSVidWebDVD,
            l_title: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: *const fn (
            self: *const IMSVidWebDVD,
            l_title: i32,
            l_chapter: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: *const fn (
            self: *const IMSVidWebDVD,
            l_chapter: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChaptersAutoStop: *const fn (
            self: *const IMSVidWebDVD,
            l_title: i32,
            lstr_chapter: i32,
            l_chapter_count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: *const fn (
            self: *const IMSVidWebDVD,
            str_time: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: *const fn (
            self: *const IMSVidWebDVD,
            l_title: i32,
            str_time: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPeriodInTitleAutoStop: *const fn (
            self: *const IMSVidWebDVD,
            l_title: i32,
            str_start_time: ?BSTR,
            str_end_time: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_stream: i32,
            f_format: i16,
            str_audio_lang: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: *const fn (
            self: *const IMSVidWebDVD,
            menu_i_d: DVDMenuIDConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentButton: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndActivateButton: *const fn (
            self: *const IMSVidWebDVD,
            l_button: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateButton: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRightButton: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectLeftButton: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectLowerButton: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectUpperButton: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAtPosition: *const fn (
            self: *const IMSVidWebDVD,
            x_pos: i32,
            y_pos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAtPosition: *const fn (
            self: *const IMSVidWebDVD,
            x_pos: i32,
            y_pos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonAtPosition: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            x_pos: i32,
            y_pos: i32,
            pl_button: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfChapters: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_title: i32,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTitleTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TitlesAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumesAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVolume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDiscSide: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDomain: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentChapter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTitle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DVDTimeCode2bstr: *const fn (
            self: *const IMSVidWebDVD,
            time_code: i32,
            p_time_str: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDDirectory: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDDirectory: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubpictureStreamEnabled: *const fn (
            self: *const IMSVidWebDVD,
            lstream: i32,
            f_enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioStreamEnabled: *const fn (
            self: *const IMSVidWebDVD,
            lstream: i32,
            f_enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSubpictureStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentSubpictureStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_stream: i32,
            str_language: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAudioStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAudioStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnglesAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAngle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAngle: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureStreamsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureOn: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubpictureOn: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDUniqueID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcceptParentalLevelChange: *const fn (
            self: *const IMSVidWebDVD,
            f_accept: i16,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyParentalLevelChange: *const fn (
            self: *const IMSVidWebDVD,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalCountry: *const fn (
            self: *const IMSVidWebDVD,
            l_country: i32,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalLevel: *const fn (
            self: *const IMSVidWebDVD,
            l_parental_level: i32,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TitleParentalLevels: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_title: i32,
            pl_parental_levels: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalCountry: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            pl_country_code: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            pl_parental_level: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Eject: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UOPValid: *const fn (
            self: *const IMSVidWebDVD,
            l_u_o_p: i32,
            pf_valid: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SPRM: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_index: i32,
            ps_s_p_r_m: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GPRM: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_index: i32,
            ps_s_p_r_m: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GPRM: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_index: i32,
            s_value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextStringType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_lang_index: i32,
            l_string_index: i32,
            p_type: ?*DVDTextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_lang_index: i32,
            l_string_index: i32,
            pstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextNumberOfStrings: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_lang_index: i32,
            pl_num_of_strings: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextNumberOfLanguages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            pl_num_of_langs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextLanguageLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_lang_index: i32,
            lcid: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegionChange: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDAdm: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteBookmark: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreBookmark: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveBookmark: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultAudioLanguage: *const fn (
            self: *const IMSVidWebDVD,
            lang: i32,
            ext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultSubpictureLanguage: *const fn (
            self: *const IMSVidWebDVD,
            lang: i32,
            ext: DVDSPExt,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredSubpictureStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            lang: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguageExt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            ext: ?*DVDSPExt,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguageExt: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            ext: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageFromLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            lcid: i32,
            lang: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeAudioPresentationMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KaraokeAudioPresentationMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeChannelContent: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_stream: i32,
            l_chan: i32,
            l_content: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeChannelAssignment: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_stream: i32,
            l_channel_assignment: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestorePreferredSettings: *const fn (
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            l_button: i32,
            p_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDScreenInMouseCoordinates: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            pp_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDScreenInMouseCoordinates: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD,
            p_rect: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidPlayback.MethodMixin(T);
            pub inline fn onDVDEvent(self: *const T, l_event_: i32, l_param1_: isize, l_param2_: isize) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).OnDVDEvent(@as(*const IMSVidWebDVD, @ptrCast(self)), l_event_, l_param1_, l_param2_);
            }
            pub inline fn playTitle(self: *const T, l_title_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_);
            }
            pub inline fn playChapterInTitle(self: *const T, l_title_: i32, l_chapter_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, l_chapter_);
            }
            pub inline fn playChapter(self: *const T, l_chapter_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IMSVidWebDVD, @ptrCast(self)), l_chapter_);
            }
            pub inline fn playChaptersAutoStop(self: *const T, l_title_: i32, lstr_chapter_: i32, l_chapter_count_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChaptersAutoStop(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, lstr_chapter_, l_chapter_count_);
            }
            pub inline fn playAtTime(self: *const T, str_time_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IMSVidWebDVD, @ptrCast(self)), str_time_);
            }
            pub inline fn playAtTimeInTitle(self: *const T, l_title_: i32, str_time_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, str_time_);
            }
            pub inline fn playPeriodInTitleAutoStop(self: *const T, l_title_: i32, str_start_time_: ?BSTR, str_end_time_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayPeriodInTitleAutoStop(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, str_start_time_, str_end_time_);
            }
            pub inline fn replayChapter(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn playPrevChapter(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn playNextChapter(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn stillOff(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn getAudioLanguage(self: *const T, l_stream_: i32, f_format_: i16, str_audio_lang_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), l_stream_, f_format_, str_audio_lang_);
            }
            pub inline fn showMenu(self: *const T, menu_i_d_: DVDMenuIDConstants) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IMSVidWebDVD, @ptrCast(self)), menu_i_d_);
            }
            pub inline fn @"resume"(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).Resume(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn returnFromSubmenu(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn getButtonsAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentButton(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentButton(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn selectAndActivateButton(self: *const T, l_button_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectAndActivateButton(@as(*const IMSVidWebDVD, @ptrCast(self)), l_button_);
            }
            pub inline fn activateButton(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ActivateButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn selectRightButton(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectRightButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn selectLeftButton(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectLeftButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn selectLowerButton(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectLowerButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn selectUpperButton(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectUpperButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn activateAtPosition(self: *const T, x_pos_: i32, y_pos_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ActivateAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), x_pos_, y_pos_);
            }
            pub inline fn selectAtPosition(self: *const T, x_pos_: i32, y_pos_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), x_pos_, y_pos_);
            }
            pub inline fn getButtonAtPosition(self: *const T, x_pos_: i32, y_pos_: i32, pl_button_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), x_pos_, y_pos_, pl_button_);
            }
            pub inline fn getNumberOfChapters(self: *const T, l_title_: i32, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_NumberOfChapters(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, p_val_);
            }
            pub inline fn getTotalTitleTime(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TotalTitleTime(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getTitlesAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TitlesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getVolumesAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_VolumesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentVolume(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentVolume(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentDiscSide(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentDiscSide(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentDomain(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentDomain(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentChapter(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentChapter(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentTitle(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentTime(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentTime(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn dvdTimeCode2bstr(self: *const T, time_code_: i32, p_time_str_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).DVDTimeCode2bstr(@as(*const IMSVidWebDVD, @ptrCast(self)), time_code_, p_time_str_);
            }
            pub inline fn getDVDDirectory(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDDirectory(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putDVDDirectory(self: *const T, new_val_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DVDDirectory(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn isSubpictureStreamEnabled(self: *const T, lstream_: i32, f_enabled_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).IsSubpictureStreamEnabled(@as(*const IMSVidWebDVD, @ptrCast(self)), lstream_, f_enabled_);
            }
            pub inline fn isAudioStreamEnabled(self: *const T, lstream_: i32, f_enabled_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).IsAudioStreamEnabled(@as(*const IMSVidWebDVD, @ptrCast(self)), lstream_, f_enabled_);
            }
            pub inline fn getCurrentSubpictureStream(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putCurrentSubpictureStream(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn getSubpictureLanguage(self: *const T, l_stream_: i32, str_language_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), l_stream_, str_language_);
            }
            pub inline fn getCurrentAudioStream(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentAudioStream(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putCurrentAudioStream(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentAudioStream(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn getAudioStreamsAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AudioStreamsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getAnglesAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AnglesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getCurrentAngle(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentAngle(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putCurrentAngle(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentAngle(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn getSubpictureStreamsAvailable(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureStreamsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getSubpictureOn(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureOn(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putSubpictureOn(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_SubpictureOn(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn getDVDUniqueID(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDUniqueID(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn acceptParentalLevelChange(self: *const T, f_accept_: i16, str_user_name_: ?BSTR, str_password_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).AcceptParentalLevelChange(@as(*const IMSVidWebDVD, @ptrCast(self)), f_accept_, str_user_name_, str_password_);
            }
            pub inline fn notifyParentalLevelChange(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).NotifyParentalLevelChange(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn selectParentalCountry(self: *const T, l_country_: i32, str_user_name_: ?BSTR, str_password_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectParentalCountry(@as(*const IMSVidWebDVD, @ptrCast(self)), l_country_, str_user_name_, str_password_);
            }
            pub inline fn selectParentalLevel(self: *const T, l_parental_level_: i32, str_user_name_: ?BSTR, str_password_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectParentalLevel(@as(*const IMSVidWebDVD, @ptrCast(self)), l_parental_level_, str_user_name_, str_password_);
            }
            pub inline fn getTitleParentalLevels(self: *const T, l_title_: i32, pl_parental_levels_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TitleParentalLevels(@as(*const IMSVidWebDVD, @ptrCast(self)), l_title_, pl_parental_levels_);
            }
            pub inline fn getPlayerParentalCountry(self: *const T, pl_country_code_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PlayerParentalCountry(@as(*const IMSVidWebDVD, @ptrCast(self)), pl_country_code_);
            }
            pub inline fn getPlayerParentalLevel(self: *const T, pl_parental_level_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PlayerParentalLevel(@as(*const IMSVidWebDVD, @ptrCast(self)), pl_parental_level_);
            }
            pub inline fn eject(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).Eject(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn uopValid(self: *const T, l_u_o_p_: i32, pf_valid_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).UOPValid(@as(*const IMSVidWebDVD, @ptrCast(self)), l_u_o_p_, pf_valid_);
            }
            pub inline fn getSPRM(self: *const T, l_index_: i32, ps_s_p_r_m_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), l_index_, ps_s_p_r_m_);
            }
            pub inline fn getGPRM(self: *const T, l_index_: i32, ps_s_p_r_m_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_GPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), l_index_, ps_s_p_r_m_);
            }
            pub inline fn putGPRM(self: *const T, l_index_: i32, s_value_: i16) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_GPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), l_index_, s_value_);
            }
            pub inline fn getDVDTextStringType(self: *const T, l_lang_index_: i32, l_string_index_: i32, p_type_: ?*DVDTextStringType) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextStringType(@as(*const IMSVidWebDVD, @ptrCast(self)), l_lang_index_, l_string_index_, p_type_);
            }
            pub inline fn getDVDTextString(self: *const T, l_lang_index_: i32, l_string_index_: i32, pstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextString(@as(*const IMSVidWebDVD, @ptrCast(self)), l_lang_index_, l_string_index_, pstr_text_);
            }
            pub inline fn getDVDTextNumberOfStrings(self: *const T, l_lang_index_: i32, pl_num_of_strings_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextNumberOfStrings(@as(*const IMSVidWebDVD, @ptrCast(self)), l_lang_index_, pl_num_of_strings_);
            }
            pub inline fn getDVDTextNumberOfLanguages(self: *const T, pl_num_of_langs_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextNumberOfLanguages(@as(*const IMSVidWebDVD, @ptrCast(self)), pl_num_of_langs_);
            }
            pub inline fn getDVDTextLanguageLCID(self: *const T, l_lang_index_: i32, lcid_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextLanguageLCID(@as(*const IMSVidWebDVD, @ptrCast(self)), l_lang_index_, lcid_);
            }
            pub inline fn regionChange(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RegionChange(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn getDVDAdm(self: *const T, p_val_: ?*?*IDispatch) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDAdm(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn deleteBookmark(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).DeleteBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn restoreBookmark(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RestoreBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn saveBookmark(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SaveBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn selectDefaultAudioLanguage(self: *const T, lang_: i32, ext_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectDefaultAudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_, ext_);
            }
            pub inline fn selectDefaultSubpictureLanguage(self: *const T, lang_: i32, ext_: DVDSPExt) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectDefaultSubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_, ext_);
            }
            pub inline fn getPreferredSubpictureStream(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PreferredSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn getDefaultMenuLanguage(self: *const T, lang_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultMenuLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_);
            }
            pub inline fn putDefaultMenuLanguage(self: *const T, lang_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DefaultMenuLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_);
            }
            pub inline fn getDefaultSubpictureLanguage(self: *const T, lang_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_);
            }
            pub inline fn getDefaultAudioLanguage(self: *const T, lang_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultAudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang_);
            }
            pub inline fn getDefaultSubpictureLanguageExt(self: *const T, ext_: ?*DVDSPExt) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLanguageExt(@as(*const IMSVidWebDVD, @ptrCast(self)), ext_);
            }
            pub inline fn getDefaultAudioLanguageExt(self: *const T, ext_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultAudioLanguageExt(@as(*const IMSVidWebDVD, @ptrCast(self)), ext_);
            }
            pub inline fn getLanguageFromLCID(self: *const T, lcid_: i32, lang_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_LanguageFromLCID(@as(*const IMSVidWebDVD, @ptrCast(self)), lcid_, lang_);
            }
            pub inline fn getKaraokeAudioPresentationMode(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeAudioPresentationMode(@as(*const IMSVidWebDVD, @ptrCast(self)), p_val_);
            }
            pub inline fn putKaraokeAudioPresentationMode(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_KaraokeAudioPresentationMode(@as(*const IMSVidWebDVD, @ptrCast(self)), new_val_);
            }
            pub inline fn getKaraokeChannelContent(self: *const T, l_stream_: i32, l_chan_: i32, l_content_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeChannelContent(@as(*const IMSVidWebDVD, @ptrCast(self)), l_stream_, l_chan_, l_content_);
            }
            pub inline fn getKaraokeChannelAssignment(self: *const T, l_stream_: i32, l_channel_assignment_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeChannelAssignment(@as(*const IMSVidWebDVD, @ptrCast(self)), l_stream_, l_channel_assignment_);
            }
            pub inline fn restorePreferredSettings(self: *const T) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RestorePreferredSettings(@as(*const IMSVidWebDVD, @ptrCast(self)));
            }
            pub inline fn getButtonRect(self: *const T, l_button_: i32, p_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonRect(@as(*const IMSVidWebDVD, @ptrCast(self)), l_button_, p_rect_);
            }
            pub inline fn getDVDScreenInMouseCoordinates(self: *const T, pp_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDScreenInMouseCoordinates(@as(*const IMSVidWebDVD, @ptrCast(self)), pp_rect_);
            }
            pub inline fn putDVDScreenInMouseCoordinates(self: *const T, p_rect_: ?*IMSVidRect) HRESULT {
                return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DVDScreenInMouseCoordinates(@as(*const IMSVidWebDVD, @ptrCast(self)), p_rect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidWebDVD2_Value = Guid.initString("7027212f-ee9a-4a7c-8b67-f023714cdaff");
pub const IID_IMSVidWebDVD2 = &IID_IMSVidWebDVD2_Value;
pub const IMSVidWebDVD2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidWebDVD.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bookmark: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD2,
            pp_data: [*]?*u8,
            p_data_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bookmark: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVD2,
            p_data: ?*u8,
            dw_data_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidWebDVD.MethodMixin(T);
            pub inline fn getBookmark(self: *const T, pp_data_: [*]?*u8, p_data_length_: ?*u32) HRESULT {
                return @as(*const IMSVidWebDVD2.VTable, @ptrCast(self.vtable)).get_Bookmark(@as(*const IMSVidWebDVD2, @ptrCast(self)), pp_data_, p_data_length_);
            }
            pub inline fn putBookmark(self: *const T, p_data_: ?*u8, dw_data_length_: u32) HRESULT {
                return @as(*const IMSVidWebDVD2.VTable, @ptrCast(self.vtable)).put_Bookmark(@as(*const IMSVidWebDVD2, @ptrCast(self)), p_data_, dw_data_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDEvent_Value = Guid.initString("b4f7a674-9b83-49cb-a357-c63b871be958");
pub const IID_IMSVidWebDVDEvent = &IID_IMSVidWebDVDEvent_Value;
pub const IMSVidWebDVDEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
        DVDNotify: *const fn (
            self: *const IMSVidWebDVDEvent,
            l_event_code: i32,
            l_param1: VARIANT,
            l_param2: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayForwards: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayBackwards: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: *const fn (
            self: *const IMSVidWebDVDEvent,
            menu_i_d: DVDMenuIDConstants,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectOrActivateButton: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOn: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentAudioStream: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentSubpictureStream: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentAngle: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayTitle: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeKaraokePresMode: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeVideoPresMode: *const fn (
            self: *const IMSVidWebDVDEvent,
            b_enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
            pub inline fn dvdNotify(self: *const T, l_event_code_: i32, l_param1_: VARIANT, l_param2_: VARIANT) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).DVDNotify(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), l_event_code_, l_param1_, l_param2_);
            }
            pub inline fn playForwards(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayForwards(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playBackwards(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayBackwards(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn showMenu(self: *const T, menu_i_d_: DVDMenuIDConstants, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), menu_i_d_, b_enabled_);
            }
            pub inline fn @"resume"(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).Resume(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn selectOrActivateButton(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).SelectOrActivateButton(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn stillOff(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn pauseOn(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PauseOn(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn changeCurrentAudioStream(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentAudioStream(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn changeCurrentSubpictureStream(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentSubpictureStream(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn changeCurrentAngle(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentAngle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playAtTimeInTitle(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playAtTime(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playChapterInTitle(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playChapter(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn replayChapter(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playNextChapter(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn stop(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn returnFromSubmenu(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playTitle(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn playPrevChapter(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn changeKaraokePresMode(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeKaraokePresMode(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
            pub inline fn changeVideoPresMode(self: *const T, b_enabled_: i16) HRESULT {
                return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeVideoPresMode(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), b_enabled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDAdm_Value = Guid.initString("b8be681a-eb2c-47f0-b415-94d5452f0e05");
pub const IID_IMSVidWebDVDAdm = &IID_IMSVidWebDVDAdm_Value;
pub const IMSVidWebDVDAdm = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ChangePassword: *const fn (
            self: *const IMSVidWebDVDAdm,
            str_user_name: ?BSTR,
            str_old: ?BSTR,
            str_new: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveParentalLevel: *const fn (
            self: *const IMSVidWebDVDAdm,
            level: i32,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveParentalCountry: *const fn (
            self: *const IMSVidWebDVDAdm,
            country: i32,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfirmPassword: *const fn (
            self: *const IMSVidWebDVDAdm,
            str_user_name: ?BSTR,
            str_password: ?BSTR,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalLevel: *const fn (
            self: *const IMSVidWebDVDAdm,
            l_level: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalCountry: *const fn (
            self: *const IMSVidWebDVDAdm,
            l_country: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultAudioLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultSubpictureLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLCID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BookmarkOnStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BookmarkOnStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidWebDVDAdm,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn changePassword(self: *const T, str_user_name_: ?BSTR, str_old_: ?BSTR, str_new_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).ChangePassword(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), str_user_name_, str_old_, str_new_);
            }
            pub inline fn saveParentalLevel(self: *const T, level_: i32, str_user_name_: ?BSTR, str_password_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).SaveParentalLevel(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), level_, str_user_name_, str_password_);
            }
            pub inline fn saveParentalCountry(self: *const T, country_: i32, str_user_name_: ?BSTR, str_password_: ?BSTR) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).SaveParentalCountry(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), country_, str_user_name_, str_password_);
            }
            pub inline fn confirmPassword(self: *const T, str_user_name_: ?BSTR, str_password_: ?BSTR, p_val_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).ConfirmPassword(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), str_user_name_, str_password_, p_val_);
            }
            pub inline fn getParentalLevel(self: *const T, l_level_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).GetParentalLevel(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), l_level_);
            }
            pub inline fn getParentalCountry(self: *const T, l_country_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).GetParentalCountry(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), l_country_);
            }
            pub inline fn getDefaultAudioLCID(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultAudioLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), p_val_);
            }
            pub inline fn putDefaultAudioLCID(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultAudioLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), new_val_);
            }
            pub inline fn getDefaultSubpictureLCID(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), p_val_);
            }
            pub inline fn putDefaultSubpictureLCID(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultSubpictureLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), new_val_);
            }
            pub inline fn getDefaultMenuLCID(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultMenuLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), p_val_);
            }
            pub inline fn putDefaultMenuLCID(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultMenuLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), new_val_);
            }
            pub inline fn getBookmarkOnStop(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_BookmarkOnStop(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), p_val_);
            }
            pub inline fn putBookmarkOnStop(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_BookmarkOnStop(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevice_Value = Guid.initString("37b03546-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidOutputDevice = &IID_IMSVidOutputDevice_Value;
pub const IMSVidOutputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDevice.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidOutputDeviceEvent_Value = Guid.initString("2e6a14e2-571c-11d3-b652-00c04f79498e");
pub const IID_IMSVidOutputDeviceEvent = &IID_IMSVidOutputDeviceEvent_Value;
pub const IMSVidOutputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeature_Value = Guid.initString("37b03547-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFeature = &IID_IMSVidFeature_Value;
pub const IMSVidFeature = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDevice.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFeatureEvent_Value = Guid.initString("3dd2903c-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidFeatureEvent = &IID_IMSVidFeatureEvent_Value;
pub const IMSVidFeatureEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidEncoder_Value = Guid.initString("c0020fd4-bee7-43d9-a495-9f213117103d");
pub const IID_IMSVidEncoder = &IID_IMSVidEncoder_Value;
pub const IMSVidEncoder = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoEncoderInterface: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEncoder,
            pp_enc_int: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioEncoderInterface: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEncoder,
            pp_enc_int: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFeature.MethodMixin(T);
            pub inline fn getVideoEncoderInterface(self: *const T, pp_enc_int_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidEncoder.VTable, @ptrCast(self.vtable)).get_VideoEncoderInterface(@as(*const IMSVidEncoder, @ptrCast(self)), pp_enc_int_);
            }
            pub inline fn getAudioEncoderInterface(self: *const T, pp_enc_int_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidEncoder.VTable, @ptrCast(self.vtable)).get_AudioEncoderInterface(@as(*const IMSVidEncoder, @ptrCast(self)), pp_enc_int_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning_Value = Guid.initString("99652ea1-c1f7-414f-bb7b-1c967de75983");
pub const IID_IMSVidClosedCaptioning = &IID_IMSVidClosedCaptioning_Value;
pub const IMSVidClosedCaptioning = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidClosedCaptioning,
            on: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidClosedCaptioning,
            on: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFeature.MethodMixin(T);
            pub inline fn getEnable(self: *const T, on_: ?*i16) HRESULT {
                return @as(*const IMSVidClosedCaptioning.VTable, @ptrCast(self.vtable)).get_Enable(@as(*const IMSVidClosedCaptioning, @ptrCast(self)), on_);
            }
            pub inline fn putEnable(self: *const T, on_: i16) HRESULT {
                return @as(*const IMSVidClosedCaptioning.VTable, @ptrCast(self.vtable)).put_Enable(@as(*const IMSVidClosedCaptioning, @ptrCast(self)), on_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning2_Value = Guid.initString("e00cb864-a029-4310-9987-a873f5887d97");
pub const IID_IMSVidClosedCaptioning2 = &IID_IMSVidClosedCaptioning2_Value;
pub const IMSVidClosedCaptioning2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Service: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidClosedCaptioning2,
            on: ?*MSVidCCService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Service: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidClosedCaptioning2,
            on: MSVidCCService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidClosedCaptioning.MethodMixin(T);
            pub inline fn getService(self: *const T, on_: ?*MSVidCCService) HRESULT {
                return @as(*const IMSVidClosedCaptioning2.VTable, @ptrCast(self.vtable)).get_Service(@as(*const IMSVidClosedCaptioning2, @ptrCast(self)), on_);
            }
            pub inline fn putService(self: *const T, on_: MSVidCCService) HRESULT {
                return @as(*const IMSVidClosedCaptioning2.VTable, @ptrCast(self.vtable)).put_Service(@as(*const IMSVidClosedCaptioning2, @ptrCast(self)), on_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidClosedCaptioning3_Value = Guid.initString("c8638e8a-7625-4c51-9366-2f40a9831fc0");
pub const IID_IMSVidClosedCaptioning3 = &IID_IMSVidClosedCaptioning3_Value;
pub const IMSVidClosedCaptioning3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TeleTextFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidClosedCaptioning3,
            punk_t_t_filter: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidClosedCaptioning2.MethodMixin(T);
            pub inline fn getTeleTextFilter(self: *const T, punk_t_t_filter_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidClosedCaptioning3.VTable, @ptrCast(self.vtable)).get_TeleTextFilter(@as(*const IMSVidClosedCaptioning3, @ptrCast(self)), punk_t_t_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDS_Value = Guid.initString("11ebc158-e712-4d1f-8bb3-01ed5274c4ce");
pub const IID_IMSVidXDS = &IID_IMSVidXDS_Value;
pub const IMSVidXDS = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelChangeInterface: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidXDS,
            punk_c_c: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFeature.MethodMixin(T);
            pub inline fn getChannelChangeInterface(self: *const T, punk_c_c_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidXDS.VTable, @ptrCast(self.vtable)).get_ChannelChangeInterface(@as(*const IMSVidXDS, @ptrCast(self)), punk_c_c_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDSEvent_Value = Guid.initString("6db2317d-3b23-41ec-ba4b-701f407eaf3a");
pub const IID_IMSVidXDSEvent = &IID_IMSVidXDSEvent_Value;
pub const IMSVidXDSEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeatureEvent.VTable,
        RatingChange: *const fn (
            self: *const IMSVidXDSEvent,
            prev_rating_system: EnTvRat_System,
            prev_level: EnTvRat_GenericLevel,
            prev_attributes: BfEnTvRat_GenericAttributes,
            new_rating_system: EnTvRat_System,
            new_level: EnTvRat_GenericLevel,
            new_attributes: BfEnTvRat_GenericAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFeatureEvent.MethodMixin(T);
            pub inline fn ratingChange(self: *const T, prev_rating_system_: EnTvRat_System, prev_level_: EnTvRat_GenericLevel, prev_attributes_: BfEnTvRat_GenericAttributes, new_rating_system_: EnTvRat_System, new_level_: EnTvRat_GenericLevel, new_attributes_: BfEnTvRat_GenericAttributes) HRESULT {
                return @as(*const IMSVidXDSEvent.VTable, @ptrCast(self.vtable)).RatingChange(@as(*const IMSVidXDSEvent, @ptrCast(self)), prev_rating_system_, prev_level_, prev_attributes_, new_rating_system_, new_level_, new_attributes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDataServices_Value = Guid.initString("334125c1-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServices = &IID_IMSVidDataServices_Value;
pub const IMSVidDataServices = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFeature.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDataServicesEvent_Value = Guid.initString("334125c2-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServicesEvent = &IID_IMSVidDataServicesEvent_Value;
pub const IMSVidDataServicesEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SourceSizeList = enum(i32) {
    FullSize = 0,
    ClipByOverScan = 1,
    ClipByClipRect = 2,
};
pub const sslFullSize = SourceSizeList.FullSize;
pub const sslClipByOverScan = SourceSizeList.ClipByOverScan;
pub const sslClipByClipRect = SourceSizeList.ClipByClipRect;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer_Value = Guid.initString("37b03540-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRenderer = &IID_IMSVidVideoRenderer_Value;
pub const IMSVidVideoRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CustomCompositorClass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor_c_l_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CustomCompositorClass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor_c_l_s_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositorClass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor_c_l_s_i_d: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositorClass: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor_c_l_s_i_d: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor: ?*?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            compositor: ?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmap: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            mixer_picture_disp: ?*?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MixerBitmap: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            mixer_picture: ?*?*IVMRMixerBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmap: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            mixer_picture_disp: ?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MixerBitmap: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            mixer_picture: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapPositionRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            r_dest: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapPositionRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            r_dest: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapOpacity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            opacity: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapOpacity: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            opacity: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetupMixerBitmap: *const fn (
            self: *const IMSVidVideoRenderer,
            mixer_picture_disp: ?*IPictureDisp,
            opacity: i32,
            r_dest: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            current_size: ?*SourceSizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            new_size: SourceSizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverScan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            pl_percent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverScan: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            l_percent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableSourceRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxVidRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            pp_vid_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinVidRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            pp_vid_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClippedSourceRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_rect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClippedSourceRect: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_rect: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsingOverlay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            use_overlay_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UsingOverlay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            use_overlay_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Capture: *const fn (
            self: *const IMSVidVideoRenderer,
            current_image: ?*?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesPerSecond: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecimateInput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_deci: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecimateInput: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer,
            p_deci: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
            pub inline fn getCustomCompositorClass(self: *const T, compositor_c_l_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_c_l_s_i_d_);
            }
            pub inline fn putCustomCompositorClass(self: *const T, compositor_c_l_s_i_d_: ?BSTR) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_c_l_s_i_d_);
            }
            pub inline fn getCustomCompositorClass1(self: *const T, compositor_c_l_s_i_d_: ?*Guid) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_c_l_s_i_d_);
            }
            pub inline fn putCustomCompositorClass1(self: *const T, compositor_c_l_s_i_d_: ?*const Guid) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_c_l_s_i_d_);
            }
            pub inline fn getCustomCompositor(self: *const T, compositor_: ?*?*IVMRImageCompositor) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__CustomCompositor(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_);
            }
            pub inline fn putCustomCompositor(self: *const T, compositor_: ?*IVMRImageCompositor) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__CustomCompositor(@as(*const IMSVidVideoRenderer, @ptrCast(self)), compositor_);
            }
            pub inline fn getMixerBitmap(self: *const T, mixer_picture_disp_: ?*?*IPictureDisp) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), mixer_picture_disp_);
            }
            pub inline fn getMixerBitmap1(self: *const T, mixer_picture_: ?*?*IVMRMixerBitmap) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), mixer_picture_);
            }
            pub inline fn putMixerBitmap(self: *const T, mixer_picture_disp_: ?*IPictureDisp) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), mixer_picture_disp_);
            }
            pub inline fn putMixerBitmap1(self: *const T, mixer_picture_: ?*VMRALPHABITMAP) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), mixer_picture_);
            }
            pub inline fn getMixerBitmapPositionRect(self: *const T, r_dest_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmapPositionRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), r_dest_);
            }
            pub inline fn putMixerBitmapPositionRect(self: *const T, r_dest_: ?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmapPositionRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), r_dest_);
            }
            pub inline fn getMixerBitmapOpacity(self: *const T, opacity_: ?*i32) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmapOpacity(@as(*const IMSVidVideoRenderer, @ptrCast(self)), opacity_);
            }
            pub inline fn putMixerBitmapOpacity(self: *const T, opacity_: i32) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmapOpacity(@as(*const IMSVidVideoRenderer, @ptrCast(self)), opacity_);
            }
            pub inline fn setupMixerBitmap(self: *const T, mixer_picture_disp_: ?*IPictureDisp, opacity_: i32, r_dest_: ?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).SetupMixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), mixer_picture_disp_, opacity_, r_dest_);
            }
            pub inline fn getSourceSize(self: *const T, current_size_: ?*SourceSizeList) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_SourceSize(@as(*const IMSVidVideoRenderer, @ptrCast(self)), current_size_);
            }
            pub inline fn putSourceSize(self: *const T, new_size_: SourceSizeList) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_SourceSize(@as(*const IMSVidVideoRenderer, @ptrCast(self)), new_size_);
            }
            pub inline fn getOverScan(self: *const T, pl_percent_: ?*i32) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_OverScan(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pl_percent_);
            }
            pub inline fn putOverScan(self: *const T, l_percent_: i32) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_OverScan(@as(*const IMSVidVideoRenderer, @ptrCast(self)), l_percent_);
            }
            pub inline fn getAvailableSourceRect(self: *const T, p_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_AvailableSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_rect_);
            }
            pub inline fn getMaxVidRect(self: *const T, pp_vid_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MaxVidRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pp_vid_rect_);
            }
            pub inline fn getMinVidRect(self: *const T, pp_vid_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MinVidRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pp_vid_rect_);
            }
            pub inline fn getClippedSourceRect(self: *const T, p_rect_: ?*?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_ClippedSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_rect_);
            }
            pub inline fn putClippedSourceRect(self: *const T, p_rect_: ?*IMSVidRect) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_ClippedSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_rect_);
            }
            pub inline fn getUsingOverlay(self: *const T, use_overlay_val_: ?*i16) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_UsingOverlay(@as(*const IMSVidVideoRenderer, @ptrCast(self)), use_overlay_val_);
            }
            pub inline fn putUsingOverlay(self: *const T, use_overlay_val_: i16) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_UsingOverlay(@as(*const IMSVidVideoRenderer, @ptrCast(self)), use_overlay_val_);
            }
            pub inline fn capture(self: *const T, current_image_: ?*?*IPictureDisp) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).Capture(@as(*const IMSVidVideoRenderer, @ptrCast(self)), current_image_);
            }
            pub inline fn getFramesPerSecond(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_FramesPerSecond(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_val_);
            }
            pub inline fn getDecimateInput(self: *const T, p_deci_: ?*i16) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_DecimateInput(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_deci_);
            }
            pub inline fn putDecimateInput(self: *const T, p_deci_: i16) HRESULT {
                return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_DecimateInput(@as(*const IMSVidVideoRenderer, @ptrCast(self)), p_deci_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent_Value = Guid.initString("37b03545-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRendererEvent = &IID_IMSVidVideoRendererEvent_Value;
pub const IMSVidVideoRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: *const fn (
            self: *const IMSVidVideoRendererEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
            pub inline fn overlayUnavailable(self: *const T) HRESULT {
                return @as(*const IMSVidVideoRendererEvent.VTable, @ptrCast(self.vtable)).OverlayUnavailable(@as(*const IMSVidVideoRendererEvent, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink_Value = Guid.initString("6c29b41d-455b-4c33-963a-0d28e5e555ea");
pub const IID_IMSVidGenericSink = &IID_IMSVidGenericSink_Value;
pub const IMSVidGenericSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        SetSinkFilter: *const fn (
            self: *const IMSVidGenericSink,
            bstr_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkStreams: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGenericSink,
            p_streams: ?*MSVidSinkStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkStreams: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidGenericSink,
            streams: MSVidSinkStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
            pub inline fn setSinkFilter(self: *const T, bstr_name_: ?BSTR) HRESULT {
                return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).SetSinkFilter(@as(*const IMSVidGenericSink, @ptrCast(self)), bstr_name_);
            }
            pub inline fn getSinkStreams(self: *const T, p_streams_: ?*MSVidSinkStreams) HRESULT {
                return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).get_SinkStreams(@as(*const IMSVidGenericSink, @ptrCast(self)), p_streams_);
            }
            pub inline fn putSinkStreams(self: *const T, streams_: MSVidSinkStreams) HRESULT {
                return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).put_SinkStreams(@as(*const IMSVidGenericSink, @ptrCast(self)), streams_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink2_Value = Guid.initString("6b5a28f3-47f1-4092-b168-60cabec08f1c");
pub const IID_IMSVidGenericSink2 = &IID_IMSVidGenericSink2_Value;
pub const IMSVidGenericSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGenericSink.VTable,
        AddFilter: *const fn (
            self: *const IMSVidGenericSink2,
            bstr_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetFilterList: *const fn (
            self: *const IMSVidGenericSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidGenericSink.MethodMixin(T);
            pub inline fn addFilter(self: *const T, bstr_name_: ?BSTR) HRESULT {
                return @as(*const IMSVidGenericSink2.VTable, @ptrCast(self.vtable)).AddFilter(@as(*const IMSVidGenericSink2, @ptrCast(self)), bstr_name_);
            }
            pub inline fn resetFilterList(self: *const T) HRESULT {
                return @as(*const IMSVidGenericSink2.VTable, @ptrCast(self.vtable)).ResetFilterList(@as(*const IMSVidGenericSink2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferRecordingControl_Value = Guid.initString("160621aa-bbbc-4326-a824-c395aebc6e74");
pub const IID_IMSVidStreamBufferRecordingControl = &IID_IMSVidStreamBufferRecordingControl_Value;
pub const IMSVidStreamBufferRecordingControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            rt_start: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            rt_start: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            rt_stop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            rt_stop: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStopped: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            ph_result: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStarted: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            ph_result: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            dw_type: ?*RecordingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferRecordingControl,
            p_recording_attribute: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStartTime(self: *const T, rt_start_: ?*i32) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_StartTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rt_start_);
            }
            pub inline fn putStartTime(self: *const T, rt_start_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).put_StartTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rt_start_);
            }
            pub inline fn getStopTime(self: *const T, rt_stop_: ?*i32) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_StopTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rt_stop_);
            }
            pub inline fn putStopTime(self: *const T, rt_stop_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).put_StopTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rt_stop_);
            }
            pub inline fn getRecordingStopped(self: *const T, ph_result_: ?*i16) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingStopped(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), ph_result_);
            }
            pub inline fn getRecordingStarted(self: *const T, ph_result_: ?*i16) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingStarted(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), ph_result_);
            }
            pub inline fn getRecordingType(self: *const T, dw_type_: ?*RecordingType) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingType(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), dw_type_);
            }
            pub inline fn getRecordingAttribute(self: *const T, p_recording_attribute_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingAttribute(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), p_recording_attribute_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSink_Value = Guid.initString("159dbb45-cd1b-4dab-83ea-5cb1f4f21d07");
pub const IID_IMSVidStreamBufferSink = &IID_IMSVidStreamBufferSink_Value;
pub const IMSVidStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentRecorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink,
            psz_filename: ?BSTR,
            p_recording_i_unknown: ?*?*IMSVidStreamBufferRecordingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferenceRecorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink,
            psz_filename: ?BSTR,
            p_recording_i_unknown: ?*?*IMSVidStreamBufferRecordingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink,
            p_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NameSetLock: *const fn (
            self: *const IMSVidStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESink: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink,
            sbe_config: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
            pub inline fn getContentRecorder(self: *const T, psz_filename_: ?BSTR, p_recording_i_unknown_: ?*?*IMSVidStreamBufferRecordingControl) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_ContentRecorder(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), psz_filename_, p_recording_i_unknown_);
            }
            pub inline fn getReferenceRecorder(self: *const T, psz_filename_: ?BSTR, p_recording_i_unknown_: ?*?*IMSVidStreamBufferRecordingControl) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_ReferenceRecorder(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), psz_filename_, p_recording_i_unknown_);
            }
            pub inline fn getSinkName(self: *const T, p_name_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_SinkName(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), p_name_);
            }
            pub inline fn putSinkName(self: *const T, name_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).put_SinkName(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), name_);
            }
            pub inline fn nameSetLock(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).NameSetLock(@as(*const IMSVidStreamBufferSink, @ptrCast(self)));
            }
            pub inline fn getSBESink(self: *const T, sbe_config_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_SBESink(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), sbe_config_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink2_Value = Guid.initString("2ca9fc63-c131-4e5a-955a-544a47c67146");
pub const IID_IMSVidStreamBufferSink2 = &IID_IMSVidStreamBufferSink2_Value;
pub const IMSVidStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink.VTable,
        UnlockProfile: *const fn (
            self: *const IMSVidStreamBufferSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSink.MethodMixin(T);
            pub inline fn unlockProfile(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSink2.VTable, @ptrCast(self.vtable)).UnlockProfile(@as(*const IMSVidStreamBufferSink2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink3_Value = Guid.initString("4f8721d7-7d59-4d8b-99f5-a77775586bd5");
pub const IID_IMSVidStreamBufferSink3 = &IID_IMSVidStreamBufferSink3_Value;
pub const IMSVidStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink2.VTable,
        SetMinSeek: *const fn (
            self: *const IMSVidStreamBufferSink3,
            pdw_min: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            sz_c_l_s_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            psz_c_l_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__AudioAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__AudioAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            p_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            sz_c_l_s_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            psz_c_l_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VideoAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__VideoAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            p_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            sz_c_l_s_i_d: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            psz_c_l_s_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__DataAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__DataAnalysisFilter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            p_guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LicenseErrorCode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSink3,
            hres: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSink2.MethodMixin(T);
            pub inline fn setMinSeek(self: *const T, pdw_min_: ?*i32) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).SetMinSeek(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pdw_min_);
            }
            pub inline fn getAudioCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_AudioCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getVideoCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_VideoCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getCCCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_CCCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getWSTCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_WSTCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pp_unk_);
            }
            pub inline fn putAudioAnalysisFilter(self: *const T, sz_c_l_s_i_d_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), sz_c_l_s_i_d_);
            }
            pub inline fn getAudioAnalysisFilter(self: *const T, psz_c_l_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), psz_c_l_s_i_d_);
            }
            pub inline fn putAudioAnalysisFilter1(self: *const T, guid_: Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid_);
            }
            pub inline fn getAudioAnalysisFilter1(self: *const T, p_guid_: ?*Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), p_guid_);
            }
            pub inline fn putVideoAnalysisFilter(self: *const T, sz_c_l_s_i_d_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), sz_c_l_s_i_d_);
            }
            pub inline fn getVideoAnalysisFilter(self: *const T, psz_c_l_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), psz_c_l_s_i_d_);
            }
            pub inline fn putVideoAnalysisFilter1(self: *const T, guid_: Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid_);
            }
            pub inline fn getVideoAnalysisFilter1(self: *const T, p_guid_: ?*Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), p_guid_);
            }
            pub inline fn putDataAnalysisFilter(self: *const T, sz_c_l_s_i_d_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), sz_c_l_s_i_d_);
            }
            pub inline fn getDataAnalysisFilter(self: *const T, psz_c_l_s_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), psz_c_l_s_i_d_);
            }
            pub inline fn putDataAnalysisFilter1(self: *const T, guid_: Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid_);
            }
            pub inline fn getDataAnalysisFilter1(self: *const T, p_guid_: ?*Guid) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), p_guid_);
            }
            pub inline fn getLicenseErrorCode(self: *const T, hres_: ?*HRESULT) HRESULT {
                return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_LicenseErrorCode(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), hres_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent_Value = Guid.initString("f798a36b-b05b-4bbe-9703-eaea7d61cd51");
pub const IID_IMSVidStreamBufferSinkEvent = &IID_IMSVidStreamBufferSinkEvent_Value;
pub const IMSVidStreamBufferSinkEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        CertificateFailure: *const fn (
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CertificateSuccess: *const fn (
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFailure: *const fn (
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
            pub inline fn certificateFailure(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).CertificateFailure(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
            }
            pub inline fn certificateSuccess(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).CertificateSuccess(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
            }
            pub inline fn writeFailure(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).WriteFailure(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent2_Value = Guid.initString("3d7a5166-72d7-484b-a06f-286187b80ca1");
pub const IID_IMSVidStreamBufferSinkEvent2 = &IID_IMSVidStreamBufferSinkEvent2_Value;
pub const IMSVidStreamBufferSinkEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent.VTable,
        EncryptionOn: *const fn (
            self: *const IMSVidStreamBufferSinkEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptionOff: *const fn (
            self: *const IMSVidStreamBufferSinkEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSinkEvent.MethodMixin(T);
            pub inline fn encryptionOn(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent2.VTable, @ptrCast(self.vtable)).EncryptionOn(@as(*const IMSVidStreamBufferSinkEvent2, @ptrCast(self)));
            }
            pub inline fn encryptionOff(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent2.VTable, @ptrCast(self.vtable)).EncryptionOff(@as(*const IMSVidStreamBufferSinkEvent2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent3_Value = Guid.initString("735ad8d5-c259-48e9-81e7-d27953665b23");
pub const IID_IMSVidStreamBufferSinkEvent3 = &IID_IMSVidStreamBufferSinkEvent3_Value;
pub const IMSVidStreamBufferSinkEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent2.VTable,
        LicenseChange: *const fn (
            self: *const IMSVidStreamBufferSinkEvent3,
            dw_prot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSinkEvent2.MethodMixin(T);
            pub inline fn licenseChange(self: *const T, dw_prot_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent3.VTable, @ptrCast(self.vtable)).LicenseChange(@as(*const IMSVidStreamBufferSinkEvent3, @ptrCast(self)), dw_prot_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferSinkEvent4_Value = Guid.initString("1b01dcb0-daf0-412c-a5d1-590c7f62e2b8");
pub const IID_IMSVidStreamBufferSinkEvent4 = &IID_IMSVidStreamBufferSinkEvent4_Value;
pub const IMSVidStreamBufferSinkEvent4 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent3.VTable,
        WriteFailureClear: *const fn (
            self: *const IMSVidStreamBufferSinkEvent4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSinkEvent3.MethodMixin(T);
            pub inline fn writeFailureClear(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSinkEvent4.VTable, @ptrCast(self.vtable)).WriteFailureClear(@as(*const IMSVidStreamBufferSinkEvent4, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSource_Value = Guid.initString("eb0c8cf9-6950-4772-87b1-47d11cf3a02f");
pub const IID_IMSVidStreamBufferSource = &IID_IMSVidStreamBufferSource_Value;
pub const IMSVidStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Start: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource,
            l_start: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource,
            p_recording_attribute: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CurrentRatings: *const fn (
            self: *const IMSVidStreamBufferSource,
            p_en_system: ?*EnTvRat_System,
            p_en_rating: ?*EnTvRat_GenericLevel,
            p_bf_en_attr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MaxRatingsLevel: *const fn (
            self: *const IMSVidStreamBufferSource,
            en_system: EnTvRat_System,
            en_rating: EnTvRat_GenericLevel,
            lbf_en_attr: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnrated: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource,
            b_block: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnratedDelay: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource,
            dw_delay: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESource: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource,
            sbe_filter: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
            pub inline fn getStart(self: *const T, l_start_: ?*i32) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_Start(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), l_start_);
            }
            pub inline fn getRecordingAttribute(self: *const T, p_recording_attribute_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_RecordingAttribute(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), p_recording_attribute_);
            }
            pub inline fn currentRatings(self: *const T, p_en_system_: ?*EnTvRat_System, p_en_rating_: ?*EnTvRat_GenericLevel, p_bf_en_attr_: ?*i32) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).CurrentRatings(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), p_en_system_, p_en_rating_, p_bf_en_attr_);
            }
            pub inline fn maxRatingsLevel(self: *const T, en_system_: EnTvRat_System, en_rating_: EnTvRat_GenericLevel, lbf_en_attr_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).MaxRatingsLevel(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), en_system_, en_rating_, lbf_en_attr_);
            }
            pub inline fn putBlockUnrated(self: *const T, b_block_: i16) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).put_BlockUnrated(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), b_block_);
            }
            pub inline fn putUnratedDelay(self: *const T, dw_delay_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).put_UnratedDelay(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), dw_delay_);
            }
            pub inline fn getSBESource(self: *const T, sbe_filter_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_SBESource(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), sbe_filter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSource2_Value = Guid.initString("e4ba9059-b1ce-40d8-b9a0-d4ea4a9989d3");
pub const IID_IMSVidStreamBufferSource2 = &IID_IMSVidStreamBufferSource2_Value;
pub const IMSVidStreamBufferSource2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSource.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RateEx: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource2,
            dw_rate: f64,
            dw_frames_per_second: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource2,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource2,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource2,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidStreamBufferSource2,
            pp_unk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSource.MethodMixin(T);
            pub inline fn putRateEx(self: *const T, dw_rate_: f64, dw_frames_per_second_: u32) HRESULT {
                return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).put_RateEx(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), dw_rate_, dw_frames_per_second_);
            }
            pub inline fn getAudioCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_AudioCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getVideoCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_VideoCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getCCCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_CCCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), pp_unk_);
            }
            pub inline fn getWSTCounter(self: *const T, pp_unk_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_WSTCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), pp_unk_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent_Value = Guid.initString("50ce8a7d-9c28-4da8-9042-cdfa7116f979");
pub const IID_IMSVidStreamBufferSourceEvent = &IID_IMSVidStreamBufferSourceEvent_Value;
pub const IMSVidStreamBufferSourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        CertificateFailure: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CertificateSuccess: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsBlocked: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsUnblocked: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsChanged: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeHole: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
            stream_offset_m_s: i32,
            size_m_s: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleDataRead: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentBecomingStale: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleFileDeleted: *const fn (
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
            pub inline fn certificateFailure(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).CertificateFailure(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn certificateSuccess(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).CertificateSuccess(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn ratingsBlocked(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsBlocked(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn ratingsUnblocked(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsUnblocked(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn ratingsChanged(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsChanged(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn timeHole(self: *const T, stream_offset_m_s_: i32, size_m_s_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).TimeHole(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)), stream_offset_m_s_, size_m_s_);
            }
            pub inline fn staleDataRead(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).StaleDataRead(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn contentBecomingStale(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).ContentBecomingStale(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
            pub inline fn staleFileDeleted(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).StaleFileDeleted(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent2_Value = Guid.initString("7aef50ce-8e22-4ba8-bc06-a92a458b4ef2");
pub const IID_IMSVidStreamBufferSourceEvent2 = &IID_IMSVidStreamBufferSourceEvent2_Value;
pub const IMSVidStreamBufferSourceEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent.VTable,
        RateChange: *const fn (
            self: *const IMSVidStreamBufferSourceEvent2,
            qw_new_rate: f64,
            qw_old_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSourceEvent.MethodMixin(T);
            pub inline fn rateChange(self: *const T, qw_new_rate_: f64, qw_old_rate_: f64) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent2.VTable, @ptrCast(self.vtable)).RateChange(@as(*const IMSVidStreamBufferSourceEvent2, @ptrCast(self)), qw_new_rate_, qw_old_rate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent3_Value = Guid.initString("ceabd6ab-9b90-4570-adf1-3ce76e00a763");
pub const IID_IMSVidStreamBufferSourceEvent3 = &IID_IMSVidStreamBufferSourceEvent3_Value;
pub const IMSVidStreamBufferSourceEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent2.VTable,
        BroadcastEvent: *const fn (
            self: *const IMSVidStreamBufferSourceEvent3,
            guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEventEx: *const fn (
            self: *const IMSVidStreamBufferSourceEvent3,
            guid: ?BSTR,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        COPPBlocked: *const fn (
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        COPPUnblocked: *const fn (
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentPrimarilyAudio: *const fn (
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidStreamBufferSourceEvent2.MethodMixin(T);
            pub inline fn broadcastEvent(self: *const T, guid_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).BroadcastEvent(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)), guid_);
            }
            pub inline fn broadcastEventEx(self: *const T, guid_: ?BSTR, param1_: u32, param2_: u32, param3_: u32, param4_: u32) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).BroadcastEventEx(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)), guid_, param1_, param2_, param3_, param4_);
            }
            pub inline fn coppBlocked(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).COPPBlocked(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
            }
            pub inline fn coppUnblocked(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).COPPUnblocked(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
            }
            pub inline fn contentPrimarilyAudio(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).ContentPrimarilyAudio(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferV2SourceEvent_Value = Guid.initString("49c771f9-41b2-4cf7-9f9a-a313a8f6027e");
pub const IID_IMSVidStreamBufferV2SourceEvent = &IID_IMSVidStreamBufferV2SourceEvent_Value;
pub const IMSVidStreamBufferV2SourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        RatingsChanged: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeHole: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
            stream_offset_m_s: i32,
            size_m_s: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleDataRead: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentBecomingStale: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleFileDeleted: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RateChange: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
            qw_new_rate: f64,
            qw_old_rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEvent: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
            guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEventEx: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
            guid: ?BSTR,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentPrimarilyAudio: *const fn (
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
            pub inline fn ratingsChanged(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).RatingsChanged(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
            }
            pub inline fn timeHole(self: *const T, stream_offset_m_s_: i32, size_m_s_: i32) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).TimeHole(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), stream_offset_m_s_, size_m_s_);
            }
            pub inline fn staleDataRead(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).StaleDataRead(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
            }
            pub inline fn contentBecomingStale(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).ContentBecomingStale(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
            }
            pub inline fn staleFileDeleted(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).StaleFileDeleted(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
            }
            pub inline fn rateChange(self: *const T, qw_new_rate_: f64, qw_old_rate_: f64) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).RateChange(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), qw_new_rate_, qw_old_rate_);
            }
            pub inline fn broadcastEvent(self: *const T, guid_: ?BSTR) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).BroadcastEvent(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), guid_);
            }
            pub inline fn broadcastEventEx(self: *const T, guid_: ?BSTR, param1_: u32, param2_: u32, param3_: u32, param4_: u32) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).BroadcastEventEx(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), guid_, param1_, param2_, param3_, param4_);
            }
            pub inline fn contentPrimarilyAudio(self: *const T) HRESULT {
                return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).ContentPrimarilyAudio(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer2_Value = Guid.initString("6bdd5c1e-2810-4159-94bc-05511ae8549b");
pub const IID_IMSVidVideoRenderer2 = &IID_IMSVidVideoRenderer2_Value;
pub const IMSVidVideoRenderer2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer2,
            alloc_present: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Allocator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer2,
            alloc_present: ?*?*IVMRSurfaceAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer2,
            i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllocator: *const fn (
            self: *const IMSVidVideoRenderer2,
            alloc_present: ?*IUnknown,
            i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _SetAllocator2: *const fn (
            self: *const IMSVidVideoRenderer2,
            alloc_present: ?*IVMRSurfaceAllocator,
            i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer2,
            b_suppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRenderer2,
            b_suppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
            pub inline fn getAllocator(self: *const T, alloc_present_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_Allocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), alloc_present_);
            }
            pub inline fn getAllocator1(self: *const T, alloc_present_: ?*?*IVMRSurfaceAllocator) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get__Allocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), alloc_present_);
            }
            pub inline fn getAllocatorID(self: *const T, i_d_: ?*i32) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_Allocator_ID(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), i_d_);
            }
            pub inline fn setAllocator(self: *const T, alloc_present_: ?*IUnknown, i_d_: i32) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).SetAllocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), alloc_present_, i_d_);
            }
            pub inline fn setAllocator2(self: *const T, alloc_present_: ?*IVMRSurfaceAllocator, i_d_: i32) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable))._SetAllocator2(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), alloc_present_, i_d_);
            }
            pub inline fn putSuppressEffects(self: *const T, b_suppress_: i16) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), b_suppress_);
            }
            pub inline fn getSuppressEffects(self: *const T, b_suppress_: ?*i16) HRESULT {
                return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), b_suppress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent2_Value = Guid.initString("7145ed66-4730-4fdb-8a53-fde7508d3e5e");
pub const IID_IMSVidVideoRendererEvent2 = &IID_IMSVidVideoRendererEvent2_Value;
pub const IMSVidVideoRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: *const fn (
            self: *const IMSVidVideoRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
            pub inline fn overlayUnavailable(self: *const T) HRESULT {
                return @as(*const IMSVidVideoRendererEvent2.VTable, @ptrCast(self.vtable)).OverlayUnavailable(@as(*const IMSVidVideoRendererEvent2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVMR9_Value = Guid.initString("d58b0015-ebef-44bb-bbdd-3f3699d76ea1");
pub const IID_IMSVidVMR9 = &IID_IMSVidVMR9_Value;
pub const IMSVidVMR9 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVMR9,
            i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllocator: *const fn (
            self: *const IMSVidVMR9,
            alloc_present: ?*IUnknown,
            i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVMR9,
            b_suppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVMR9,
            b_suppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVMR9,
            alloc_present: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
            pub inline fn getAllocatorID(self: *const T, i_d_: ?*i32) HRESULT {
                return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_Allocator_ID(@as(*const IMSVidVMR9, @ptrCast(self)), i_d_);
            }
            pub inline fn setAllocator(self: *const T, alloc_present_: ?*IUnknown, i_d_: i32) HRESULT {
                return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).SetAllocator(@as(*const IMSVidVMR9, @ptrCast(self)), alloc_present_, i_d_);
            }
            pub inline fn putSuppressEffects(self: *const T, b_suppress_: i16) HRESULT {
                return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidVMR9, @ptrCast(self)), b_suppress_);
            }
            pub inline fn getSuppressEffects(self: *const T, b_suppress_: ?*i16) HRESULT {
                return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidVMR9, @ptrCast(self)), b_suppress_);
            }
            pub inline fn getAllocator(self: *const T, alloc_present_: ?*?*IUnknown) HRESULT {
                return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_Allocator(@as(*const IMSVidVMR9, @ptrCast(self)), alloc_present_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMSVidEVR_Value = Guid.initString("15e496ae-82a8-4cf9-a6b6-c561dc60398f");
pub const IID_IMSVidEVR = &IID_IMSVidEVR_Value;
pub const IMSVidEVR = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Presenter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEVR,
            pp_alloc_present: ?*?*IMFVideoPresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Presenter: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEVR,
            p_alloc_present: ?*IMFVideoPresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEVR,
            b_suppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidEVR,
            b_suppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
            pub inline fn getPresenter(self: *const T, pp_alloc_present_: ?*?*IMFVideoPresenter) HRESULT {
                return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).get_Presenter(@as(*const IMSVidEVR, @ptrCast(self)), pp_alloc_present_);
            }
            pub inline fn putPresenter(self: *const T, p_alloc_present_: ?*IMFVideoPresenter) HRESULT {
                return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).put_Presenter(@as(*const IMSVidEVR, @ptrCast(self)), p_alloc_present_);
            }
            pub inline fn putSuppressEffects(self: *const T, b_suppress_: i16) HRESULT {
                return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidEVR, @ptrCast(self)), b_suppress_);
            }
            pub inline fn getSuppressEffects(self: *const T, b_suppress_: ?*i16) HRESULT {
                return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidEVR, @ptrCast(self)), b_suppress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidEVREvent_Value = Guid.initString("349abb10-883c-4f22-8714-cecaeee45d62");
pub const IID_IMSVidEVREvent = &IID_IMSVidEVREvent_Value;
pub const IMSVidEVREvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OnUserEvent: *const fn (
            self: *const IMSVidEVREvent,
            l_event_code: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
            pub inline fn onUserEvent(self: *const T, l_event_code_: i32) HRESULT {
                return @as(*const IMSVidEVREvent.VTable, @ptrCast(self.vtable)).OnUserEvent(@as(*const IMSVidEVREvent, @ptrCast(self)), l_event_code_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRenderer_Value = Guid.initString("37b0353f-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRenderer = &IID_IMSVidAudioRenderer_Value;
pub const IMSVidAudioRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRenderer,
            l_vol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRenderer,
            l_vol: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRenderer,
            l_bal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRenderer,
            l_bal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
            pub inline fn putVolume(self: *const T, l_vol_: i32) HRESULT {
                return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const IMSVidAudioRenderer, @ptrCast(self)), l_vol_);
            }
            pub inline fn getVolume(self: *const T, l_vol_: ?*i32) HRESULT {
                return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const IMSVidAudioRenderer, @ptrCast(self)), l_vol_);
            }
            pub inline fn putBalance(self: *const T, l_bal_: i32) HRESULT {
                return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).put_Balance(@as(*const IMSVidAudioRenderer, @ptrCast(self)), l_bal_);
            }
            pub inline fn getBalance(self: *const T, l_bal_: ?*i32) HRESULT {
                return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).get_Balance(@as(*const IMSVidAudioRenderer, @ptrCast(self)), l_bal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAudioRendererEvent_Value = Guid.initString("37b03541-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRendererEvent = &IID_IMSVidAudioRendererEvent_Value;
pub const IMSVidAudioRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidAudioRendererEvent2_Value = Guid.initString("e3f55729-353b-4c43-a028-50f79aa9a907");
pub const IID_IMSVidAudioRendererEvent2 = &IID_IMSVidAudioRendererEvent2_Value;
pub const IMSVidAudioRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAudioRendererEvent.VTable,
        AVDecAudioDualMono: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioSampleRate: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioChannelConfig: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioChannelCount: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonMeanBitRate: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDDSurroundMode: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonInputFormat: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonOutputFormat: *const fn (
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMSVidAudioRendererEvent.MethodMixin(T);
            pub inline fn avDecAudioDualMono(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecAudioDualMono(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avAudioSampleRate(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioSampleRate(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avAudioChannelConfig(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioChannelConfig(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avAudioChannelCount(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioChannelCount(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avDecCommonMeanBitRate(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonMeanBitRate(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avddSurroundMode(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDDSurroundMode(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avDecCommonInputFormat(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonInputFormat(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
            pub inline fn avDecCommonOutputFormat(self: *const T) HRESULT {
                return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonOutputFormat(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevices_Value = Guid.initString("c5702cd1-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidInputDevices = &IID_IMSVidInputDevices_Value;
pub const IMSVidInputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidInputDevices,
            l_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidInputDevices,
            p_d: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidInputDevices,
            v: VARIANT,
            p_d_b: ?*?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IMSVidInputDevices,
            p_d_b: ?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IMSVidInputDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, l_count_: ?*i32) HRESULT {
                return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidInputDevices, @ptrCast(self)), l_count_);
            }
            pub inline fn getNewEnum(self: *const T, p_d_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidInputDevices, @ptrCast(self)), p_d_);
            }
            pub inline fn getItem(self: *const T, v_: VARIANT, p_d_b_: ?*?*IMSVidInputDevice) HRESULT {
                return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidInputDevices, @ptrCast(self)), v_, p_d_b_);
            }
            pub inline fn add(self: *const T, p_d_b_: ?*IMSVidInputDevice) HRESULT {
                return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidInputDevices, @ptrCast(self)), p_d_b_);
            }
            pub inline fn remove(self: *const T, v_: VARIANT) HRESULT {
                return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidInputDevices, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevices_Value = Guid.initString("c5702cd2-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidOutputDevices = &IID_IMSVidOutputDevices_Value;
pub const IMSVidOutputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidOutputDevices,
            l_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidOutputDevices,
            p_d: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidOutputDevices,
            v: VARIANT,
            p_d_b: ?*?*IMSVidOutputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IMSVidOutputDevices,
            p_d_b: ?*IMSVidOutputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IMSVidOutputDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, l_count_: ?*i32) HRESULT {
                return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidOutputDevices, @ptrCast(self)), l_count_);
            }
            pub inline fn getNewEnum(self: *const T, p_d_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidOutputDevices, @ptrCast(self)), p_d_);
            }
            pub inline fn getItem(self: *const T, v_: VARIANT, p_d_b_: ?*?*IMSVidOutputDevice) HRESULT {
                return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidOutputDevices, @ptrCast(self)), v_, p_d_b_);
            }
            pub inline fn add(self: *const T, p_d_b_: ?*IMSVidOutputDevice) HRESULT {
                return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidOutputDevices, @ptrCast(self)), p_d_b_);
            }
            pub inline fn remove(self: *const T, v_: VARIANT) HRESULT {
                return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidOutputDevices, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRendererDevices_Value = Guid.initString("c5702cd3-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidVideoRendererDevices = &IID_IMSVidVideoRendererDevices_Value;
pub const IMSVidVideoRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRendererDevices,
            l_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRendererDevices,
            p_d: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidVideoRendererDevices,
            v: VARIANT,
            p_d_b: ?*?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IMSVidVideoRendererDevices,
            p_d_b: ?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IMSVidVideoRendererDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, l_count_: ?*i32) HRESULT {
                return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), l_count_);
            }
            pub inline fn getNewEnum(self: *const T, p_d_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), p_d_);
            }
            pub inline fn getItem(self: *const T, v_: VARIANT, p_d_b_: ?*?*IMSVidVideoRenderer) HRESULT {
                return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), v_, p_d_b_);
            }
            pub inline fn add(self: *const T, p_d_b_: ?*IMSVidVideoRenderer) HRESULT {
                return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), p_d_b_);
            }
            pub inline fn remove(self: *const T, v_: VARIANT) HRESULT {
                return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRendererDevices_Value = Guid.initString("c5702cd4-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidAudioRendererDevices = &IID_IMSVidAudioRendererDevices_Value;
pub const IMSVidAudioRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRendererDevices,
            l_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRendererDevices,
            p_d: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidAudioRendererDevices,
            v: VARIANT,
            p_d_b: ?*?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IMSVidAudioRendererDevices,
            p_d_b: ?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IMSVidAudioRendererDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, l_count_: ?*i32) HRESULT {
                return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), l_count_);
            }
            pub inline fn getNewEnum(self: *const T, p_d_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), p_d_);
            }
            pub inline fn getItem(self: *const T, v_: VARIANT, p_d_b_: ?*?*IMSVidAudioRenderer) HRESULT {
                return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), v_, p_d_b_);
            }
            pub inline fn add(self: *const T, p_d_b_: ?*IMSVidAudioRenderer) HRESULT {
                return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), p_d_b_);
            }
            pub inline fn remove(self: *const T, v_: VARIANT) HRESULT {
                return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeatures_Value = Guid.initString("c5702cd5-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidFeatures = &IID_IMSVidFeatures_Value;
pub const IMSVidFeatures = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFeatures,
            l_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFeatures,
            p_d: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidFeatures,
            v: VARIANT,
            p_d_b: ?*?*IMSVidFeature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IMSVidFeatures,
            p_d_b: ?*IMSVidFeature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IMSVidFeatures,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCount(self: *const T, l_count_: ?*i32) HRESULT {
                return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidFeatures, @ptrCast(self)), l_count_);
            }
            pub inline fn getNewEnum(self: *const T, p_d_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidFeatures, @ptrCast(self)), p_d_);
            }
            pub inline fn getItem(self: *const T, v_: VARIANT, p_d_b_: ?*?*IMSVidFeature) HRESULT {
                return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidFeatures, @ptrCast(self)), v_, p_d_b_);
            }
            pub inline fn add(self: *const T, p_d_b_: ?*IMSVidFeature) HRESULT {
                return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidFeatures, @ptrCast(self)), p_d_b_);
            }
            pub inline fn remove(self: *const T, v_: VARIANT) HRESULT {
                return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidFeatures, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSVidAnalogTunerDevice_Value = Guid.initString("1c15d484-911d-11d2-b632-00c04f79498e");
pub const CLSID_MSVidAnalogTunerDevice = &CLSID_MSVidAnalogTunerDevice_Value;

const CLSID_MSVidBDATunerDevice_Value = Guid.initString("a2e3074e-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_MSVidBDATunerDevice = &CLSID_MSVidBDATunerDevice_Value;

const CLSID_MSVidFilePlaybackDevice_Value = Guid.initString("37b0353c-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidFilePlaybackDevice = &CLSID_MSVidFilePlaybackDevice_Value;

const CLSID_MSVidWebDVD_Value = Guid.initString("011b3619-fe63-4814-8a84-15a194ce9ce3");
pub const CLSID_MSVidWebDVD = &CLSID_MSVidWebDVD_Value;

const CLSID_MSVidWebDVDAdm_Value = Guid.initString("fa7c375b-66a7-4280-879d-fd459c84bb02");
pub const CLSID_MSVidWebDVDAdm = &CLSID_MSVidWebDVDAdm_Value;

const CLSID_MSVidVideoRenderer_Value = Guid.initString("37b03543-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidVideoRenderer = &CLSID_MSVidVideoRenderer_Value;

const CLSID_MSVidVMR9_Value = Guid.initString("24dc3975-09bf-4231-8655-3ee71f43837d");
pub const CLSID_MSVidVMR9 = &CLSID_MSVidVMR9_Value;

const CLSID_MSVidEVR_Value = Guid.initString("c45268a2-fa81-4e19-b1e3-72edbd60aeda");
pub const CLSID_MSVidEVR = &CLSID_MSVidEVR_Value;

const CLSID_MSVidAudioRenderer_Value = Guid.initString("37b03544-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidAudioRenderer = &CLSID_MSVidAudioRenderer_Value;

const CLSID_MSVidGenericSink_Value = Guid.initString("4a5869cf-929d-4040-ae03-fcafc5b9cd42");
pub const CLSID_MSVidGenericSink = &CLSID_MSVidGenericSink_Value;

const CLSID_MSVidStreamBufferSink_Value = Guid.initString("9e77aac4-35e5-42a1-bdc2-8f3ff399847c");
pub const CLSID_MSVidStreamBufferSink = &CLSID_MSVidStreamBufferSink_Value;

const CLSID_MSVidStreamBufferSource_Value = Guid.initString("ad8e510d-217f-409b-8076-29c5e73b98e8");
pub const CLSID_MSVidStreamBufferSource = &CLSID_MSVidStreamBufferSource_Value;

const CLSID_MSVidStreamBufferV2Source_Value = Guid.initString("fd351ea1-4173-4af4-821d-80d4ae979048");
pub const CLSID_MSVidStreamBufferV2Source = &CLSID_MSVidStreamBufferV2Source_Value;

const CLSID_MSVidEncoder_Value = Guid.initString("bb530c63-d9df-4b49-9439-63453962e598");
pub const CLSID_MSVidEncoder = &CLSID_MSVidEncoder_Value;

const CLSID_MSVidITVCapture_Value = Guid.initString("5740a302-ef0b-45ce-bf3b-4470a14a8980");
pub const CLSID_MSVidITVCapture = &CLSID_MSVidITVCapture_Value;

const CLSID_MSVidITVPlayback_Value = Guid.initString("9e797ed0-5253-4243-a9b7-bd06c58f8ef3");
pub const CLSID_MSVidITVPlayback = &CLSID_MSVidITVPlayback_Value;

const CLSID_MSVidCCA_Value = Guid.initString("86151827-e47b-45ee-8421-d10e6e690979");
pub const CLSID_MSVidCCA = &CLSID_MSVidCCA_Value;

const CLSID_MSVidClosedCaptioning_Value = Guid.initString("7f9cb14d-48e4-43b6-9346-1aebc39c64d3");
pub const CLSID_MSVidClosedCaptioning = &CLSID_MSVidClosedCaptioning_Value;

const CLSID_MSVidClosedCaptioningSI_Value = Guid.initString("92ed88bf-879e-448f-b6b6-a385bceb846d");
pub const CLSID_MSVidClosedCaptioningSI = &CLSID_MSVidClosedCaptioningSI_Value;

const CLSID_MSVidDataServices_Value = Guid.initString("334125c0-77e5-11d3-b653-00c04f79498e");
pub const CLSID_MSVidDataServices = &CLSID_MSVidDataServices_Value;

const CLSID_MSVidXDS_Value = Guid.initString("0149eedf-d08f-4142-8d73-d23903d21e90");
pub const CLSID_MSVidXDS = &CLSID_MSVidXDS_Value;

const CLSID_MSVidAnalogCaptureToDataServices_Value = Guid.initString("c5702cd6-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToDataServices = &CLSID_MSVidAnalogCaptureToDataServices_Value;

const CLSID_MSVidDataServicesToStreamBufferSink_Value = Guid.initString("38f03426-e83b-4e68-b65b-dcae73304838");
pub const CLSID_MSVidDataServicesToStreamBufferSink = &CLSID_MSVidDataServicesToStreamBufferSink_Value;

const CLSID_MSVidDataServicesToXDS_Value = Guid.initString("0429ec6e-1144-4bed-b88b-2fb9899a4a3d");
pub const CLSID_MSVidDataServicesToXDS = &CLSID_MSVidDataServicesToXDS_Value;

const CLSID_MSVidAnalogCaptureToXDS_Value = Guid.initString("3540d440-5b1d-49cb-821a-e84b8cf065a7");
pub const CLSID_MSVidAnalogCaptureToXDS = &CLSID_MSVidAnalogCaptureToXDS_Value;

const CLSID_MSVidCtl_Value = Guid.initString("b0edf163-910a-11d2-b632-00c04f79498e");
pub const CLSID_MSVidCtl = &CLSID_MSVidCtl_Value;

const CLSID_MSVidInputDevices_Value = Guid.initString("c5702ccc-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidInputDevices = &CLSID_MSVidInputDevices_Value;

const CLSID_MSVidOutputDevices_Value = Guid.initString("c5702ccd-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidOutputDevices = &CLSID_MSVidOutputDevices_Value;

const CLSID_MSVidVideoRendererDevices_Value = Guid.initString("c5702cce-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidVideoRendererDevices = &CLSID_MSVidVideoRendererDevices_Value;

const CLSID_MSVidAudioRendererDevices_Value = Guid.initString("c5702ccf-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAudioRendererDevices = &CLSID_MSVidAudioRendererDevices_Value;

const CLSID_MSVidFeatures_Value = Guid.initString("c5702cd0-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidFeatures = &CLSID_MSVidFeatures_Value;

const CLSID_MSVidGenericComposite_Value = Guid.initString("2764bce5-cc39-11d2-b639-00c04f79498e");
pub const CLSID_MSVidGenericComposite = &CLSID_MSVidGenericComposite_Value;

const CLSID_MSVidAnalogCaptureToOverlayMixer_Value = Guid.initString("e18af75a-08af-11d3-b64a-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToOverlayMixer = &CLSID_MSVidAnalogCaptureToOverlayMixer_Value;

const CLSID_MSVidWebDVDToVideoRenderer_Value = Guid.initString("267db0b3-55e3-4902-949b-df8f5cec0191");
pub const CLSID_MSVidWebDVDToVideoRenderer = &CLSID_MSVidWebDVDToVideoRenderer_Value;

const CLSID_MSVidWebDVDToAudioRenderer_Value = Guid.initString("8d04238e-9fd1-41c6-8de3-9e1ee309e935");
pub const CLSID_MSVidWebDVDToAudioRenderer = &CLSID_MSVidWebDVDToAudioRenderer_Value;

const CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value = Guid.initString("6ad28ee1-5002-4e71-aaf7-bd077907b1a4");
pub const CLSID_MSVidMPEG2DecoderToClosedCaptioning = &CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value;

const CLSID_MSVidAnalogCaptureToStreamBufferSink_Value = Guid.initString("9f50e8b1-9530-4ddc-825e-1af81d47aed6");
pub const CLSID_MSVidAnalogCaptureToStreamBufferSink = &CLSID_MSVidAnalogCaptureToStreamBufferSink_Value;

const CLSID_MSVidDigitalCaptureToStreamBufferSink_Value = Guid.initString("abe40035-27c3-4a2f-8153-6624471608af");
pub const CLSID_MSVidDigitalCaptureToStreamBufferSink = &CLSID_MSVidDigitalCaptureToStreamBufferSink_Value;

const CLSID_MSVidITVToStreamBufferSink_Value = Guid.initString("92b94828-1af7-4e6e-9ebf-770657f77af5");
pub const CLSID_MSVidITVToStreamBufferSink = &CLSID_MSVidITVToStreamBufferSink_Value;

const CLSID_MSVidCCAToStreamBufferSink_Value = Guid.initString("3ef76d68-8661-4843-8b8f-c37163d8c9ce");
pub const CLSID_MSVidCCAToStreamBufferSink = &CLSID_MSVidCCAToStreamBufferSink_Value;

const CLSID_MSVidEncoderToStreamBufferSink_Value = Guid.initString("a0b9b497-afbc-45ad-a8a6-9b077c40d4f2");
pub const CLSID_MSVidEncoderToStreamBufferSink = &CLSID_MSVidEncoderToStreamBufferSink_Value;

const CLSID_MSVidFilePlaybackToVideoRenderer_Value = Guid.initString("b401c5eb-8457-427f-84ea-a4d2363364b0");
pub const CLSID_MSVidFilePlaybackToVideoRenderer = &CLSID_MSVidFilePlaybackToVideoRenderer_Value;

const CLSID_MSVidFilePlaybackToAudioRenderer_Value = Guid.initString("cc23f537-18d4-4ece-93bd-207a84726979");
pub const CLSID_MSVidFilePlaybackToAudioRenderer = &CLSID_MSVidFilePlaybackToAudioRenderer_Value;

const CLSID_MSVidAnalogTVToEncoder_Value = Guid.initString("28953661-0231-41db-8986-21ff4388ee9b");
pub const CLSID_MSVidAnalogTVToEncoder = &CLSID_MSVidAnalogTVToEncoder_Value;

const CLSID_MSVidStreamBufferSourceToVideoRenderer_Value = Guid.initString("3c4708dc-b181-46a8-8da8-4ab0371758cd");
pub const CLSID_MSVidStreamBufferSourceToVideoRenderer = &CLSID_MSVidStreamBufferSourceToVideoRenderer_Value;

const CLSID_MSVidAnalogCaptureToCCA_Value = Guid.initString("942b7909-a28e-49a1-a207-34ebcbcb4b3b");
pub const CLSID_MSVidAnalogCaptureToCCA = &CLSID_MSVidAnalogCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToCCA_Value = Guid.initString("73d14237-b9db-4efa-a6dd-84350421fb2f");
pub const CLSID_MSVidDigitalCaptureToCCA = &CLSID_MSVidDigitalCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToITV_Value = Guid.initString("5d8e73f7-4989-4ac8-8a98-39ba0d325302");
pub const CLSID_MSVidDigitalCaptureToITV = &CLSID_MSVidDigitalCaptureToITV_Value;

const CLSID_MSVidSBESourceToITV_Value = Guid.initString("2291478c-5ee3-4bef-ab5d-b5ff2cf58352");
pub const CLSID_MSVidSBESourceToITV = &CLSID_MSVidSBESourceToITV_Value;

const CLSID_MSVidSBESourceToCC_Value = Guid.initString("9193a8f9-0cba-400e-aa97-eb4709164576");
pub const CLSID_MSVidSBESourceToCC = &CLSID_MSVidSBESourceToCC_Value;

const CLSID_MSVidSBESourceToGenericSink_Value = Guid.initString("991da7e5-953f-435b-be5e-b92a05edfc42");
pub const CLSID_MSVidSBESourceToGenericSink = &CLSID_MSVidSBESourceToGenericSink_Value;

const CLSID_MSVidCCToVMR_Value = Guid.initString("c4bf2784-ae00-41ba-9828-9c953bd3c54a");
pub const CLSID_MSVidCCToVMR = &CLSID_MSVidCCToVMR_Value;

const CLSID_MSVidCCToAR_Value = Guid.initString("d76334ca-d89e-4baf-86ab-ddb59372afc2");
pub const CLSID_MSVidCCToAR = &CLSID_MSVidCCToAR_Value;

const CLSID_MSEventBinder_Value = Guid.initString("577faa18-4518-445e-8f70-1473f8cf4ba4");
pub const CLSID_MSEventBinder = &CLSID_MSEventBinder_Value;

const CLSID_MSVidStreamBufferRecordingControl_Value = Guid.initString("caafdd83-cefc-4e3d-ba03-175f17a24f91");
pub const CLSID_MSVidStreamBufferRecordingControl = &CLSID_MSVidStreamBufferRecordingControl_Value;

const CLSID_MSVidRect_Value = Guid.initString("cb4276e6-7d5f-4cf1-9727-629c5e6db6ae");
pub const CLSID_MSVidRect = &CLSID_MSVidRect_Value;

const CLSID_MSVidDevice_Value = Guid.initString("6e40476f-9c49-4c3e-8bb9-8587958eff74");
pub const CLSID_MSVidDevice = &CLSID_MSVidDevice_Value;

const CLSID_MSVidDevice2_Value = Guid.initString("30997f7d-b3b5-4a1c-983a-1fe8098cb77d");
pub const CLSID_MSVidDevice2 = &CLSID_MSVidDevice2_Value;

const CLSID_MSVidInputDevice_Value = Guid.initString("ac1972f2-138a-4ca3-90da-ae51112eda28");
pub const CLSID_MSVidInputDevice = &CLSID_MSVidInputDevice_Value;

const CLSID_MSVidVideoInputDevice_Value = Guid.initString("95f4820b-bb3a-4e2d-bc64-5b817bc2c30e");
pub const CLSID_MSVidVideoInputDevice = &CLSID_MSVidVideoInputDevice_Value;

const CLSID_MSVidVideoPlaybackDevice_Value = Guid.initString("1990d634-1a5e-4071-a34a-53aaffce9f36");
pub const CLSID_MSVidVideoPlaybackDevice = &CLSID_MSVidVideoPlaybackDevice_Value;

const CLSID_MSVidFeature_Value = Guid.initString("7748530b-c08a-47ea-b24c-be8695ff405f");
pub const CLSID_MSVidFeature = &CLSID_MSVidFeature_Value;

const CLSID_MSVidOutput_Value = Guid.initString("87eb890d-03ad-4e9d-9866-376e5ec572ed");
pub const CLSID_MSVidOutput = &CLSID_MSVidOutput_Value;

pub const MSViddispidList = enum(i32) {
    Inputs = 0,
    Outputs = 1,
    _Inputs = 2,
    _Outputs = 3,
    VideoRenderers = 4,
    AudioRenderers = 5,
    Features = 6,
    Input = 7,
    Output = 8,
    VideoRenderer = 9,
    AudioRenderer = 10,
    SelectedFeatures = 11,
    View = 12,
    Build = 13,
    Pause = 14,
    Run = 15,
    Stop = 16,
    Decompose = 17,
    DisplaySize = 18,
    MaintainAspectRatio = 19,
    ColorKey = 20,
    StateChange = 21,
    getState = 22,
    unbind = 23,
    bind = 24,
    DisableVideo = 25,
    DisableAudio = 26,
    ViewNext = 27,
    ServiceP = 28,
};
pub const dispidInputs = MSViddispidList.Inputs;
pub const dispidOutputs = MSViddispidList.Outputs;
pub const dispid_Inputs = MSViddispidList._Inputs;
pub const dispid_Outputs = MSViddispidList._Outputs;
pub const dispidVideoRenderers = MSViddispidList.VideoRenderers;
pub const dispidAudioRenderers = MSViddispidList.AudioRenderers;
pub const dispidFeatures = MSViddispidList.Features;
pub const dispidInput = MSViddispidList.Input;
pub const dispidOutput = MSViddispidList.Output;
pub const dispidVideoRenderer = MSViddispidList.VideoRenderer;
pub const dispidAudioRenderer = MSViddispidList.AudioRenderer;
pub const dispidSelectedFeatures = MSViddispidList.SelectedFeatures;
pub const dispidView = MSViddispidList.View;
pub const dispidBuild = MSViddispidList.Build;
pub const dispidPause = MSViddispidList.Pause;
pub const dispidRun = MSViddispidList.Run;
pub const dispidStop = MSViddispidList.Stop;
pub const dispidDecompose = MSViddispidList.Decompose;
pub const dispidDisplaySize = MSViddispidList.DisplaySize;
pub const dispidMaintainAspectRatio = MSViddispidList.MaintainAspectRatio;
pub const dispidColorKey = MSViddispidList.ColorKey;
pub const dispidStateChange = MSViddispidList.StateChange;
pub const dispidgetState = MSViddispidList.getState;
pub const dispidunbind = MSViddispidList.unbind;
pub const dispidbind = MSViddispidList.bind;
pub const dispidDisableVideo = MSViddispidList.DisableVideo;
pub const dispidDisableAudio = MSViddispidList.DisableAudio;
pub const dispidViewNext = MSViddispidList.ViewNext;
pub const dispidServiceP = MSViddispidList.ServiceP;

pub const DisplaySizeList = enum(i32) {
    DefaultSize = 0,
    // SourceSize = 0, this enum value conflicts with DefaultSize
    HalfSourceSize = 1,
    DoubleSourceSize = 2,
    FullScreen = 3,
    HalfScreen = 4,
    QuarterScreen = 5,
    SixteenthScreen = 6,
};
pub const dslDefaultSize = DisplaySizeList.DefaultSize;
pub const dslSourceSize = DisplaySizeList.DefaultSize;
pub const dslHalfSourceSize = DisplaySizeList.HalfSourceSize;
pub const dslDoubleSourceSize = DisplaySizeList.DoubleSourceSize;
pub const dslFullScreen = DisplaySizeList.FullScreen;
pub const dslHalfScreen = DisplaySizeList.HalfScreen;
pub const dslQuarterScreen = DisplaySizeList.QuarterScreen;
pub const dslSixteenthScreen = DisplaySizeList.SixteenthScreen;

pub const MSVidCtlStateList = enum(i32) {
    UNBUILT = -1,
    STOP = 0,
    PAUSE = 1,
    PLAY = 2,
};
pub const STATE_UNBUILT = MSVidCtlStateList.UNBUILT;
pub const STATE_STOP = MSVidCtlStateList.STOP;
pub const STATE_PAUSE = MSVidCtlStateList.PAUSE;
pub const STATE_PLAY = MSVidCtlStateList.PLAY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidCtl_Value = Guid.initString("b0edf162-910a-11d2-b632-00c04f79498e");
pub const IID_IMSVidCtl = &IID_IMSVidCtl_Value;
pub const IMSVidCtl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            backcolor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackColor: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            backcolor: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TabStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TabStop: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Window: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplaySize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            current_value: ?*DisplaySizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplaySize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            new_value: DisplaySizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            current_value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            new_value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            current_value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            new_value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            category_guid: ?BSTR,
            p_val: ?*?*IMSVidInputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            category_guid: ?BSTR,
            p_val: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__InputsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            category_guid: ?*const Guid,
            p_val: ?*?*IMSVidInputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__OutputsAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            category_guid: ?*const Guid,
            p_val: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderersAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidVideoRendererDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderersAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidAudioRendererDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesAvailable: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputsActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputsActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRendererActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoRendererActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRendererActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioRendererActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FeaturesActive: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            p_val: ?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSVidCtl,
            l_state: ?*MSVidCtlStateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        View: *const fn (
            self: *const IMSVidCtl,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Build: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableVideo: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableAudio: *const fn (
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ViewNext: *const fn (
            self: *const IMSVidCtl,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getAutoSize(self: *const T, pbool_: ?*i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AutoSize(@as(*const IMSVidCtl, @ptrCast(self)), pbool_);
            }
            pub inline fn putAutoSize(self: *const T, vbool_: i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_AutoSize(@as(*const IMSVidCtl, @ptrCast(self)), vbool_);
            }
            pub inline fn getBackColor(self: *const T, backcolor_: ?*u32) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_BackColor(@as(*const IMSVidCtl, @ptrCast(self)), backcolor_);
            }
            pub inline fn putBackColor(self: *const T, backcolor_: u32) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_BackColor(@as(*const IMSVidCtl, @ptrCast(self)), backcolor_);
            }
            pub inline fn getEnabled(self: *const T, pbool_: ?*i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IMSVidCtl, @ptrCast(self)), pbool_);
            }
            pub inline fn putEnabled(self: *const T, vbool_: i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IMSVidCtl, @ptrCast(self)), vbool_);
            }
            pub inline fn getTabStop(self: *const T, pbool_: ?*i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_TabStop(@as(*const IMSVidCtl, @ptrCast(self)), pbool_);
            }
            pub inline fn putTabStop(self: *const T, vbool_: i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_TabStop(@as(*const IMSVidCtl, @ptrCast(self)), vbool_);
            }
            pub inline fn getWindow(self: *const T, phwnd_: ?*?HWND) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_Window(@as(*const IMSVidCtl, @ptrCast(self)), phwnd_);
            }
            pub inline fn refresh(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn getDisplaySize(self: *const T, current_value_: ?*DisplaySizeList) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_DisplaySize(@as(*const IMSVidCtl, @ptrCast(self)), current_value_);
            }
            pub inline fn putDisplaySize(self: *const T, new_value_: DisplaySizeList) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_DisplaySize(@as(*const IMSVidCtl, @ptrCast(self)), new_value_);
            }
            pub inline fn getMaintainAspectRatio(self: *const T, current_value_: ?*i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_MaintainAspectRatio(@as(*const IMSVidCtl, @ptrCast(self)), current_value_);
            }
            pub inline fn putMaintainAspectRatio(self: *const T, new_value_: i16) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_MaintainAspectRatio(@as(*const IMSVidCtl, @ptrCast(self)), new_value_);
            }
            pub inline fn getColorKey(self: *const T, current_value_: ?*u32) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_ColorKey(@as(*const IMSVidCtl, @ptrCast(self)), current_value_);
            }
            pub inline fn putColorKey(self: *const T, new_value_: u32) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_ColorKey(@as(*const IMSVidCtl, @ptrCast(self)), new_value_);
            }
            pub inline fn getInputsAvailable(self: *const T, category_guid_: ?BSTR, p_val_: ?*?*IMSVidInputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_InputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), category_guid_, p_val_);
            }
            pub inline fn getOutputsAvailable(self: *const T, category_guid_: ?BSTR, p_val_: ?*?*IMSVidOutputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_OutputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), category_guid_, p_val_);
            }
            pub inline fn getInputsAvailable1(self: *const T, category_guid_: ?*const Guid, p_val_: ?*?*IMSVidInputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get__InputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), category_guid_, p_val_);
            }
            pub inline fn getOutputsAvailable1(self: *const T, category_guid_: ?*const Guid, p_val_: ?*?*IMSVidOutputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get__OutputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), category_guid_, p_val_);
            }
            pub inline fn getVideoRenderersAvailable(self: *const T, p_val_: ?*?*IMSVidVideoRendererDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_VideoRenderersAvailable(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getAudioRenderersAvailable(self: *const T, p_val_: ?*?*IMSVidAudioRendererDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AudioRenderersAvailable(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getFeaturesAvailable(self: *const T, p_val_: ?*?*IMSVidFeatures) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_FeaturesAvailable(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getInputActive(self: *const T, p_val_: ?*?*IMSVidInputDevice) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_InputActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn putInputActive(self: *const T, p_val_: ?*IMSVidInputDevice) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_InputActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getOutputsActive(self: *const T, p_val_: ?*?*IMSVidOutputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_OutputsActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn putOutputsActive(self: *const T, p_val_: ?*IMSVidOutputDevices) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_OutputsActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getVideoRendererActive(self: *const T, p_val_: ?*?*IMSVidVideoRenderer) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_VideoRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn putVideoRendererActive(self: *const T, p_val_: ?*IMSVidVideoRenderer) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_VideoRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getAudioRendererActive(self: *const T, p_val_: ?*?*IMSVidAudioRenderer) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AudioRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn putAudioRendererActive(self: *const T, p_val_: ?*IMSVidAudioRenderer) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_AudioRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getFeaturesActive(self: *const T, p_val_: ?*?*IMSVidFeatures) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_FeaturesActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn putFeaturesActive(self: *const T, p_val_: ?*IMSVidFeatures) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_FeaturesActive(@as(*const IMSVidCtl, @ptrCast(self)), p_val_);
            }
            pub inline fn getState(self: *const T, l_state_: ?*MSVidCtlStateList) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_State(@as(*const IMSVidCtl, @ptrCast(self)), l_state_);
            }
            pub inline fn view(self: *const T, v_: ?*VARIANT) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).View(@as(*const IMSVidCtl, @ptrCast(self)), v_);
            }
            pub inline fn build(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Build(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn run(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Run(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn stop(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn decompose(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn disableVideo(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).DisableVideo(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn disableAudio(self: *const T) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).DisableAudio(@as(*const IMSVidCtl, @ptrCast(self)));
            }
            pub inline fn viewNext(self: *const T, v_: ?*VARIANT) HRESULT {
                return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).ViewNext(@as(*const IMSVidCtl, @ptrCast(self)), v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSEventBinder_Value = Guid.initString("c3a9f406-2222-436d-86d5-ba3229279efb");
pub const IID_IMSEventBinder = &IID_IMSEventBinder_Value;
pub const IMSEventBinder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Bind: *const fn (
            self: *const IMSEventBinder,
            p_event_object: ?*IDispatch,
            event_name: ?BSTR,
            event_handler: ?BSTR,
            cancel_i_d: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unbind: *const fn (
            self: *const IMSEventBinder,
            cancel_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn bind(self: *const T, p_event_object_: ?*IDispatch, event_name_: ?BSTR, event_handler_: ?BSTR, cancel_i_d_: ?*i32) HRESULT {
                return @as(*const IMSEventBinder.VTable, @ptrCast(self.vtable)).Bind(@as(*const IMSEventBinder, @ptrCast(self)), p_event_object_, event_name_, event_handler_, cancel_i_d_);
            }
            pub inline fn unbind(self: *const T, cancel_cookie_: u32) HRESULT {
                return @as(*const IMSEventBinder.VTable, @ptrCast(self.vtable)).Unbind(@as(*const IMSEventBinder, @ptrCast(self)), cancel_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IMSVidCtlEvents_Value = Guid.initString("b0edf164-910a-11d2-b632-00c04f79498e");
pub const IID__IMSVidCtlEvents = &IID__IMSVidCtlEvents_Value;
pub const _IMSVidCtlEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferInitialize_Value = Guid.initString("9ce50f2d-6ba7-40fb-a034-50b1a674ec78");
pub const IID_IStreamBufferInitialize = &IID_IStreamBufferInitialize_Value;
pub const IStreamBufferInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHKEY: *const fn (
            self: *const IStreamBufferInitialize,
            hkey_root: ?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSIDs: *const fn (
            self: *const IStreamBufferInitialize,
            c_s_i_ds: u32,
            pp_s_i_d: ?*?PSID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setHKEY(self: *const T, hkey_root_: ?HKEY) HRESULT {
                return @as(*const IStreamBufferInitialize.VTable, @ptrCast(self.vtable)).SetHKEY(@as(*const IStreamBufferInitialize, @ptrCast(self)), hkey_root_);
            }
            pub inline fn setSIDs(self: *const T, c_s_i_ds_: u32, pp_s_i_d_: ?*?PSID) HRESULT {
                return @as(*const IStreamBufferInitialize.VTable, @ptrCast(self.vtable)).SetSIDs(@as(*const IStreamBufferInitialize, @ptrCast(self)), c_s_i_ds_, pp_s_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RECORDING_TYPE = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const RECORDING_TYPE_CONTENT = RECORDING_TYPE.CONTENT;
pub const RECORDING_TYPE_REFERENCE = RECORDING_TYPE.REFERENCE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink_Value = Guid.initString("afd1f242-7efd-45ee-ba4e-407a25c9a77a");
pub const IID_IStreamBufferSink = &IID_IStreamBufferSink_Value;
pub const IStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProfile: *const fn (
            self: *const IStreamBufferSink,
            psz_stream_buffer_filename: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRecorder: *const fn (
            self: *const IStreamBufferSink,
            psz_filename: ?[*:0]const u16,
            dw_record_type: u32,
            p_recording_i_unknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProfileLocked: *const fn (
            self: *const IStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn lockProfile(self: *const T, psz_stream_buffer_filename_: ?[*:0]const u16) HRESULT {
                return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).LockProfile(@as(*const IStreamBufferSink, @ptrCast(self)), psz_stream_buffer_filename_);
            }
            pub inline fn createRecorder(self: *const T, psz_filename_: ?[*:0]const u16, dw_record_type_: u32, p_recording_i_unknown_: ?*?*IUnknown) HRESULT {
                return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).CreateRecorder(@as(*const IStreamBufferSink, @ptrCast(self)), psz_filename_, dw_record_type_, p_recording_i_unknown_);
            }
            pub inline fn isProfileLocked(self: *const T) HRESULT {
                return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).IsProfileLocked(@as(*const IStreamBufferSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink2_Value = Guid.initString("db94a660-f4fb-4bfa-bcc6-fe159a4eea93");
pub const IID_IStreamBufferSink2 = &IID_IStreamBufferSink2_Value;
pub const IStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink.VTable,
        UnlockProfile: *const fn (
            self: *const IStreamBufferSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamBufferSink.MethodMixin(T);
            pub inline fn unlockProfile(self: *const T) HRESULT {
                return @as(*const IStreamBufferSink2.VTable, @ptrCast(self.vtable)).UnlockProfile(@as(*const IStreamBufferSink2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink3_Value = Guid.initString("974723f2-887a-4452-9366-2cff3057bc8f");
pub const IID_IStreamBufferSink3 = &IID_IStreamBufferSink3_Value;
pub const IStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink2.VTable,
        SetAvailableFilter: *const fn (
            self: *const IStreamBufferSink3,
            prt_min: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamBufferSink2.MethodMixin(T);
            pub inline fn setAvailableFilter(self: *const T, prt_min_: ?*i64) HRESULT {
                return @as(*const IStreamBufferSink3.VTable, @ptrCast(self.vtable)).SetAvailableFilter(@as(*const IStreamBufferSink3, @ptrCast(self)), prt_min_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSource_Value = Guid.initString("1c5bd776-6ced-4f44-8164-5eab0e98db12");
pub const IID_IStreamBufferSource = &IID_IStreamBufferSource_Value;
pub const IStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamSink: *const fn (
            self: *const IStreamBufferSource,
            p_i_stream_buffer_sink: ?*IStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setStreamSink(self: *const T, p_i_stream_buffer_sink_: ?*IStreamBufferSink) HRESULT {
                return @as(*const IStreamBufferSource.VTable, @ptrCast(self.vtable)).SetStreamSink(@as(*const IStreamBufferSource, @ptrCast(self)), p_i_stream_buffer_sink_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordControl_Value = Guid.initString("ba9b6c99-f3c7-4ff2-92db-cfdd4851bf31");
pub const IID_IStreamBufferRecordControl = &IID_IStreamBufferRecordControl_Value;
pub const IStreamBufferRecordControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: *const fn (
            self: *const IStreamBufferRecordControl,
            prt_start: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IStreamBufferRecordControl,
            rt_stop: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordingStatus: *const fn (
            self: *const IStreamBufferRecordControl,
            ph_result: ?*HRESULT,
            pb_started: ?*BOOL,
            pb_stopped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn start(self: *const T, prt_start_: ?*i64) HRESULT {
                return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).Start(@as(*const IStreamBufferRecordControl, @ptrCast(self)), prt_start_);
            }
            pub inline fn stop(self: *const T, rt_stop_: i64) HRESULT {
                return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IStreamBufferRecordControl, @ptrCast(self)), rt_stop_);
            }
            pub inline fn getRecordingStatus(self: *const T, ph_result_: ?*HRESULT, pb_started_: ?*BOOL, pb_stopped_: ?*BOOL) HRESULT {
                return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).GetRecordingStatus(@as(*const IStreamBufferRecordControl, @ptrCast(self)), ph_result_, pb_started_, pb_stopped_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecComp_Value = Guid.initString("9e259a9b-8815-42ae-b09f-221970b154fd");
pub const IID_IStreamBufferRecComp = &IID_IStreamBufferRecComp_Value;
pub const IStreamBufferRecComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IStreamBufferRecComp,
            psz_target_filename: ?[*:0]const u16,
            psz_s_b_rec_profile_ref: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: *const fn (
            self: *const IStreamBufferRecComp,
            psz_s_b_recording: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendEx: *const fn (
            self: *const IStreamBufferRecComp,
            psz_s_b_recording: ?[*:0]const u16,
            rt_start: i64,
            rt_stop: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLength: *const fn (
            self: *const IStreamBufferRecComp,
            pc_seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IStreamBufferRecComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: *const fn (
            self: *const IStreamBufferRecComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, psz_target_filename_: ?[*:0]const u16, psz_s_b_rec_profile_ref_: ?[*:0]const u16) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamBufferRecComp, @ptrCast(self)), psz_target_filename_, psz_s_b_rec_profile_ref_);
            }
            pub inline fn append(self: *const T, psz_s_b_recording_: ?[*:0]const u16) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Append(@as(*const IStreamBufferRecComp, @ptrCast(self)), psz_s_b_recording_);
            }
            pub inline fn appendEx(self: *const T, psz_s_b_recording_: ?[*:0]const u16, rt_start_: i64, rt_stop_: i64) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).AppendEx(@as(*const IStreamBufferRecComp, @ptrCast(self)), psz_s_b_recording_, rt_start_, rt_stop_);
            }
            pub inline fn getCurrentLength(self: *const T, pc_seconds_: ?*u32) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).GetCurrentLength(@as(*const IStreamBufferRecComp, @ptrCast(self)), pc_seconds_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Close(@as(*const IStreamBufferRecComp, @ptrCast(self)));
            }
            pub inline fn cancel(self: *const T) HRESULT {
                return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IStreamBufferRecComp, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTR_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
};
pub const STREAMBUFFER_TYPE_DWORD = STREAMBUFFER_ATTR_DATATYPE.DWORD;
pub const STREAMBUFFER_TYPE_STRING = STREAMBUFFER_ATTR_DATATYPE.STRING;
pub const STREAMBUFFER_TYPE_BINARY = STREAMBUFFER_ATTR_DATATYPE.BINARY;
pub const STREAMBUFFER_TYPE_BOOL = STREAMBUFFER_ATTR_DATATYPE.BOOL;
pub const STREAMBUFFER_TYPE_QWORD = STREAMBUFFER_ATTR_DATATYPE.QWORD;
pub const STREAMBUFFER_TYPE_WORD = STREAMBUFFER_ATTR_DATATYPE.WORD;
pub const STREAMBUFFER_TYPE_GUID = STREAMBUFFER_ATTR_DATATYPE.GUID;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordingAttribute_Value = Guid.initString("16ca4e03-fe69-4705-bd41-5b7dfc0c95f3");
pub const IID_IStreamBufferRecordingAttribute = &IID_IStreamBufferRecordingAttribute_Value;
pub const IStreamBufferRecordingAttribute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttribute: *const fn (
            self: *const IStreamBufferRecordingAttribute,
            ul_reserved: u32,
            psz_attribute_name: ?[*:0]const u16,
            stream_buffer_attribute_type: STREAMBUFFER_ATTR_DATATYPE,
            pb_attribute: [*:0]u8,
            cb_attribute_length: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeCount: *const fn (
            self: *const IStreamBufferRecordingAttribute,
            ul_reserved: u32,
            pc_attributes: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeByName: *const fn (
            self: *const IStreamBufferRecordingAttribute,
            psz_attribute_name: ?[*:0]const u16,
            pul_reserved: ?*u32,
            p_stream_buffer_attribute_type: ?*STREAMBUFFER_ATTR_DATATYPE,
            pb_attribute: [*:0]u8,
            pcb_length: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeByIndex: *const fn (
            self: *const IStreamBufferRecordingAttribute,
            w_index: u16,
            pul_reserved: ?*u32,
            psz_attribute_name: ?PWSTR,
            pcch_name_length: ?*u16,
            p_stream_buffer_attribute_type: ?*STREAMBUFFER_ATTR_DATATYPE,
            pb_attribute: [*:0]u8,
            pcb_length: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAttributes: *const fn (
            self: *const IStreamBufferRecordingAttribute,
            pp_i_enum_stream_buffer_attrib: ?*?*IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAttribute(self: *const T, ul_reserved_: u32, psz_attribute_name_: ?[*:0]const u16, stream_buffer_attribute_type_: STREAMBUFFER_ATTR_DATATYPE, pb_attribute_: [*:0]u8, cb_attribute_length_: u16) HRESULT {
                return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).SetAttribute(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), ul_reserved_, psz_attribute_name_, stream_buffer_attribute_type_, pb_attribute_, cb_attribute_length_);
            }
            pub inline fn getAttributeCount(self: *const T, ul_reserved_: u32, pc_attributes_: ?*u16) HRESULT {
                return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeCount(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), ul_reserved_, pc_attributes_);
            }
            pub inline fn getAttributeByName(self: *const T, psz_attribute_name_: ?[*:0]const u16, pul_reserved_: ?*u32, p_stream_buffer_attribute_type_: ?*STREAMBUFFER_ATTR_DATATYPE, pb_attribute_: [*:0]u8, pcb_length_: ?*u16) HRESULT {
                return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeByName(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), psz_attribute_name_, pul_reserved_, p_stream_buffer_attribute_type_, pb_attribute_, pcb_length_);
            }
            pub inline fn getAttributeByIndex(self: *const T, w_index_: u16, pul_reserved_: ?*u32, psz_attribute_name_: ?PWSTR, pcch_name_length_: ?*u16, p_stream_buffer_attribute_type_: ?*STREAMBUFFER_ATTR_DATATYPE, pb_attribute_: [*:0]u8, pcb_length_: ?*u16) HRESULT {
                return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeByIndex(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), w_index_, pul_reserved_, psz_attribute_name_, pcch_name_length_, p_stream_buffer_attribute_type_, pb_attribute_, pcb_length_);
            }
            pub inline fn enumAttributes(self: *const T, pp_i_enum_stream_buffer_attrib_: ?*?*IEnumStreamBufferRecordingAttrib) HRESULT {
                return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).EnumAttributes(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), pp_i_enum_stream_buffer_attrib_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTRIBUTE = extern struct {
    pszName: ?PWSTR,
    StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
    pbAttribute: ?*u8,
    cbLength: u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamBufferRecordingAttrib_Value = Guid.initString("c18a9162-1e82-4142-8c73-5690fa62fe33");
pub const IID_IEnumStreamBufferRecordingAttrib = &IID_IEnumStreamBufferRecordingAttrib_Value;
pub const IEnumStreamBufferRecordingAttrib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumStreamBufferRecordingAttrib,
            c_request: u32,
            p_stream_buffer_attribute: [*]STREAMBUFFER_ATTRIBUTE,
            pc_received: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumStreamBufferRecordingAttrib,
            c_records: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumStreamBufferRecordingAttrib,
            pp_i_enum_stream_buffer_attrib: ?*?*IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_request_: u32, p_stream_buffer_attribute_: [*]STREAMBUFFER_ATTRIBUTE, pc_received_: ?*u32) HRESULT {
                return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), c_request_, p_stream_buffer_attribute_, pc_received_);
            }
            pub inline fn skip(self: *const T, c_records_: u32) HRESULT {
                return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), c_records_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_i_enum_stream_buffer_attrib_: ?*?*IEnumStreamBufferRecordingAttrib) HRESULT {
                return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), pp_i_enum_stream_buffer_attrib_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure_Value = Guid.initString("ce14dfae-4098-4af7-bbf7-d6511f835414");
pub const IID_IStreamBufferConfigure = &IID_IStreamBufferConfigure_Value;
pub const IStreamBufferConfigure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectory: *const fn (
            self: *const IStreamBufferConfigure,
            psz_directory_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectory: *const fn (
            self: *const IStreamBufferConfigure,
            ppsz_directory_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackingFileCount: *const fn (
            self: *const IStreamBufferConfigure,
            dw_min: u32,
            dw_max: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackingFileCount: *const fn (
            self: *const IStreamBufferConfigure,
            pdw_min: ?*u32,
            pdw_max: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackingFileDuration: *const fn (
            self: *const IStreamBufferConfigure,
            dw_seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackingFileDuration: *const fn (
            self: *const IStreamBufferConfigure,
            pdw_seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setDirectory(self: *const T, psz_directory_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetDirectory(@as(*const IStreamBufferConfigure, @ptrCast(self)), psz_directory_name_);
            }
            pub inline fn getDirectory(self: *const T, ppsz_directory_name_: ?*?PWSTR) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetDirectory(@as(*const IStreamBufferConfigure, @ptrCast(self)), ppsz_directory_name_);
            }
            pub inline fn setBackingFileCount(self: *const T, dw_min_: u32, dw_max_: u32) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetBackingFileCount(@as(*const IStreamBufferConfigure, @ptrCast(self)), dw_min_, dw_max_);
            }
            pub inline fn getBackingFileCount(self: *const T, pdw_min_: ?*u32, pdw_max_: ?*u32) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetBackingFileCount(@as(*const IStreamBufferConfigure, @ptrCast(self)), pdw_min_, pdw_max_);
            }
            pub inline fn setBackingFileDuration(self: *const T, dw_seconds_: u32) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetBackingFileDuration(@as(*const IStreamBufferConfigure, @ptrCast(self)), dw_seconds_);
            }
            pub inline fn getBackingFileDuration(self: *const T, pdw_seconds_: ?*u32) HRESULT {
                return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetBackingFileDuration(@as(*const IStreamBufferConfigure, @ptrCast(self)), pdw_seconds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure2_Value = Guid.initString("53e037bf-3992-4282-ae34-2487b4dae06b");
pub const IID_IStreamBufferConfigure2 = &IID_IStreamBufferConfigure2_Value;
pub const IStreamBufferConfigure2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure.VTable,
        SetMultiplexedPacketSize: *const fn (
            self: *const IStreamBufferConfigure2,
            cb_bytes_per_packet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMultiplexedPacketSize: *const fn (
            self: *const IStreamBufferConfigure2,
            pcb_bytes_per_packet: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFFTransitionRates: *const fn (
            self: *const IStreamBufferConfigure2,
            dw_max_full_frame_rate: u32,
            dw_max_non_skipping_rate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFFTransitionRates: *const fn (
            self: *const IStreamBufferConfigure2,
            pdw_max_full_frame_rate: ?*u32,
            pdw_max_non_skipping_rate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamBufferConfigure.MethodMixin(T);
            pub inline fn setMultiplexedPacketSize(self: *const T, cb_bytes_per_packet_: u32) HRESULT {
                return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).SetMultiplexedPacketSize(@as(*const IStreamBufferConfigure2, @ptrCast(self)), cb_bytes_per_packet_);
            }
            pub inline fn getMultiplexedPacketSize(self: *const T, pcb_bytes_per_packet_: ?*u32) HRESULT {
                return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).GetMultiplexedPacketSize(@as(*const IStreamBufferConfigure2, @ptrCast(self)), pcb_bytes_per_packet_);
            }
            pub inline fn setFFTransitionRates(self: *const T, dw_max_full_frame_rate_: u32, dw_max_non_skipping_rate_: u32) HRESULT {
                return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).SetFFTransitionRates(@as(*const IStreamBufferConfigure2, @ptrCast(self)), dw_max_full_frame_rate_, dw_max_non_skipping_rate_);
            }
            pub inline fn getFFTransitionRates(self: *const T, pdw_max_full_frame_rate_: ?*u32, pdw_max_non_skipping_rate_: ?*u32) HRESULT {
                return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).GetFFTransitionRates(@as(*const IStreamBufferConfigure2, @ptrCast(self)), pdw_max_full_frame_rate_, pdw_max_non_skipping_rate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamBufferConfigure3_Value = Guid.initString("7e2d2a1e-7192-4bd7-80c1-061fd1d10402");
pub const IID_IStreamBufferConfigure3 = &IID_IStreamBufferConfigure3_Value;
pub const IStreamBufferConfigure3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure2.VTable,
        SetStartRecConfig: *const fn (
            self: *const IStreamBufferConfigure3,
            f_start_stops_cur: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartRecConfig: *const fn (
            self: *const IStreamBufferConfigure3,
            pf_start_stops_cur: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNamespace: *const fn (
            self: *const IStreamBufferConfigure3,
            psz_namespace: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamespace: *const fn (
            self: *const IStreamBufferConfigure3,
            ppsz_namespace: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamBufferConfigure2.MethodMixin(T);
            pub inline fn setStartRecConfig(self: *const T, f_start_stops_cur_: BOOL) HRESULT {
                return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).SetStartRecConfig(@as(*const IStreamBufferConfigure3, @ptrCast(self)), f_start_stops_cur_);
            }
            pub inline fn getStartRecConfig(self: *const T, pf_start_stops_cur_: ?*BOOL) HRESULT {
                return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).GetStartRecConfig(@as(*const IStreamBufferConfigure3, @ptrCast(self)), pf_start_stops_cur_);
            }
            pub inline fn setNamespace(self: *const T, psz_namespace_: ?PWSTR) HRESULT {
                return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).SetNamespace(@as(*const IStreamBufferConfigure3, @ptrCast(self)), psz_namespace_);
            }
            pub inline fn getNamespace(self: *const T, ppsz_namespace_: ?*?PWSTR) HRESULT {
                return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).GetNamespace(@as(*const IStreamBufferConfigure3, @ptrCast(self)), ppsz_namespace_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking_Value = Guid.initString("f61f5c26-863d-4afa-b0ba-2f81dc978596");
pub const IID_IStreamBufferMediaSeeking = &IID_IStreamBufferMediaSeeking_Value;
pub const IStreamBufferMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IMediaSeeking.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMediaSeeking.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking2_Value = Guid.initString("3a439ab0-155f-470a-86a6-9ea54afd6eaf");
pub const IID_IStreamBufferMediaSeeking2 = &IID_IStreamBufferMediaSeeking2_Value;
pub const IStreamBufferMediaSeeking2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferMediaSeeking.VTable,
        SetRateEx: *const fn (
            self: *const IStreamBufferMediaSeeking2,
            d_rate: f64,
            dw_frames_per_sec: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStreamBufferMediaSeeking.MethodMixin(T);
            pub inline fn setRateEx(self: *const T, d_rate_: f64, dw_frames_per_sec_: u32) HRESULT {
                return @as(*const IStreamBufferMediaSeeking2.VTable, @ptrCast(self.vtable)).SetRateEx(@as(*const IStreamBufferMediaSeeking2, @ptrCast(self)), d_rate_, dw_frames_per_sec_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SBE_PIN_DATA = extern struct {
    cDataBytes: u64,
    cSamplesProcessed: u64,
    cDiscontinuities: u64,
    cSyncPoints: u64,
    cTimestamps: u64,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferDataCounters_Value = Guid.initString("9d2a2563-31ab-402e-9a6b-adb903489440");
pub const IID_IStreamBufferDataCounters = &IID_IStreamBufferDataCounters_Value;
pub const IStreamBufferDataCounters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: *const fn (
            self: *const IStreamBufferDataCounters,
            p_pin_data: ?*SBE_PIN_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetData: *const fn (
            self: *const IStreamBufferDataCounters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getData(self: *const T, p_pin_data_: ?*SBE_PIN_DATA) HRESULT {
                return @as(*const IStreamBufferDataCounters.VTable, @ptrCast(self.vtable)).GetData(@as(*const IStreamBufferDataCounters, @ptrCast(self)), p_pin_data_);
            }
            pub inline fn resetData(self: *const T) HRESULT {
                return @as(*const IStreamBufferDataCounters.VTable, @ptrCast(self.vtable)).ResetData(@as(*const IStreamBufferDataCounters, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CROSSBAR_DEFAULT_FLAGS = enum(i32) {
    PROFILE = 1,
    STREAMS = 2,
};
pub const DEF_MODE_PROFILE = CROSSBAR_DEFAULT_FLAGS.PROFILE;
pub const DEF_MODE_STREAMS = CROSSBAR_DEFAULT_FLAGS.STREAMS;

pub const SBE2_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: u32,
    Reserved: u32,
};

pub const DVR_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
    guidSubMediaType: Guid,
    guidFormatType: Guid,
    MediaType: AM_MEDIA_TYPE,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent_Value = Guid.initString("caede759-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2GlobalEvent = &IID_ISBE2GlobalEvent_Value;
pub const ISBE2GlobalEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: *const fn (
            self: *const ISBE2GlobalEvent,
            id_evt: ?*const Guid,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
            p_spanning: ?*BOOL,
            pcb: ?*u32,
            pb: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEvent(self: *const T, id_evt_: ?*const Guid, param1_: u32, param2_: u32, param3_: u32, param4_: u32, p_spanning_: ?*BOOL, pcb_: ?*u32, pb_: ?*u8) HRESULT {
                return @as(*const ISBE2GlobalEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ISBE2GlobalEvent, @ptrCast(self)), id_evt_, param1_, param2_, param3_, param4_, p_spanning_, pcb_, pb_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent2_Value = Guid.initString("6d8309bf-00fe-4506-8b03-f8c65b5c9b39");
pub const IID_ISBE2GlobalEvent2 = &IID_ISBE2GlobalEvent2_Value;
pub const ISBE2GlobalEvent2 = extern struct {
    pub const VTable = extern struct {
        base: ISBE2GlobalEvent.VTable,
        GetEventEx: *const fn (
            self: *const ISBE2GlobalEvent2,
            id_evt: ?*const Guid,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
            p_spanning: ?*BOOL,
            pcb: ?*u32,
            pb: ?*u8,
            p_stream_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISBE2GlobalEvent.MethodMixin(T);
            pub inline fn getEventEx(self: *const T, id_evt_: ?*const Guid, param1_: u32, param2_: u32, param3_: u32, param4_: u32, p_spanning_: ?*BOOL, pcb_: ?*u32, pb_: ?*u8, p_stream_time_: ?*i64) HRESULT {
                return @as(*const ISBE2GlobalEvent2.VTable, @ptrCast(self.vtable)).GetEventEx(@as(*const ISBE2GlobalEvent2, @ptrCast(self)), id_evt_, param1_, param2_, param3_, param4_, p_spanning_, pcb_, pb_, p_stream_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2SpanningEvent_Value = Guid.initString("caede760-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2SpanningEvent = &IID_ISBE2SpanningEvent_Value;
pub const ISBE2SpanningEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: *const fn (
            self: *const ISBE2SpanningEvent,
            id_evt: ?*const Guid,
            stream_id: u32,
            pcb: ?*u32,
            pb: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getEvent(self: *const T, id_evt_: ?*const Guid, stream_id_: u32, pcb_: ?*u32, pb_: ?*u8) HRESULT {
                return @as(*const ISBE2SpanningEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ISBE2SpanningEvent, @ptrCast(self)), id_evt_, stream_id_, pcb_, pb_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2Crossbar_Value = Guid.initString("547b6d26-3226-487e-8253-8aa168749434");
pub const IID_ISBE2Crossbar = &IID_ISBE2Crossbar_Value;
pub const ISBE2Crossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDefaultMode: *const fn (
            self: *const ISBE2Crossbar,
            default_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInitialProfile: *const fn (
            self: *const ISBE2Crossbar,
            pp_profile: ?*?*ISBE2MediaTypeProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputProfile: *const fn (
            self: *const ISBE2Crossbar,
            p_profile: ?*ISBE2MediaTypeProfile,
            pc_output_pins: ?*u32,
            pp_output_pins: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStreams: *const fn (
            self: *const ISBE2Crossbar,
            pp_streams: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn enableDefaultMode(self: *const T, default_flags_: u32) HRESULT {
                return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).EnableDefaultMode(@as(*const ISBE2Crossbar, @ptrCast(self)), default_flags_);
            }
            pub inline fn getInitialProfile(self: *const T, pp_profile_: ?*?*ISBE2MediaTypeProfile) HRESULT {
                return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).GetInitialProfile(@as(*const ISBE2Crossbar, @ptrCast(self)), pp_profile_);
            }
            pub inline fn setOutputProfile(self: *const T, p_profile_: ?*ISBE2MediaTypeProfile, pc_output_pins_: ?*u32, pp_output_pins_: ?*?*IPin) HRESULT {
                return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).SetOutputProfile(@as(*const ISBE2Crossbar, @ptrCast(self)), p_profile_, pc_output_pins_, pp_output_pins_);
            }
            pub inline fn enumStreams(self: *const T, pp_streams_: ?*?*ISBE2EnumStream) HRESULT {
                return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).EnumStreams(@as(*const ISBE2Crossbar, @ptrCast(self)), pp_streams_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2StreamMap_Value = Guid.initString("667c7745-85b1-4c55-ae55-4e25056159fc");
pub const IID_ISBE2StreamMap = &IID_ISBE2StreamMap_Value;
pub const ISBE2StreamMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStream: *const fn (
            self: *const ISBE2StreamMap,
            stream: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapStream: *const fn (
            self: *const ISBE2StreamMap,
            stream: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMappedStreams: *const fn (
            self: *const ISBE2StreamMap,
            pp_streams: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn mapStream(self: *const T, stream_: u32) HRESULT {
                return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).MapStream(@as(*const ISBE2StreamMap, @ptrCast(self)), stream_);
            }
            pub inline fn unmapStream(self: *const T, stream_: u32) HRESULT {
                return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).UnmapStream(@as(*const ISBE2StreamMap, @ptrCast(self)), stream_);
            }
            pub inline fn enumMappedStreams(self: *const T, pp_streams_: ?*?*ISBE2EnumStream) HRESULT {
                return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).EnumMappedStreams(@as(*const ISBE2StreamMap, @ptrCast(self)), pp_streams_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2EnumStream_Value = Guid.initString("f7611092-9fbc-46ec-a7c7-548ea78b71a4");
pub const IID_ISBE2EnumStream = &IID_ISBE2EnumStream_Value;
pub const ISBE2EnumStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const ISBE2EnumStream,
            c_request: u32,
            p_stream_desc: [*]SBE2_STREAM_DESC,
            pc_received: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const ISBE2EnumStream,
            c_records: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const ISBE2EnumStream,
            pp_i_enum_stream: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_request_: u32, p_stream_desc_: [*]SBE2_STREAM_DESC, pc_received_: ?*u32) HRESULT {
                return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Next(@as(*const ISBE2EnumStream, @ptrCast(self)), c_request_, p_stream_desc_, pc_received_);
            }
            pub inline fn skip(self: *const T, c_records_: u32) HRESULT {
                return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Skip(@as(*const ISBE2EnumStream, @ptrCast(self)), c_records_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISBE2EnumStream, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_i_enum_stream_: ?*?*ISBE2EnumStream) HRESULT {
                return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const ISBE2EnumStream, @ptrCast(self)), pp_i_enum_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2MediaTypeProfile_Value = Guid.initString("f238267d-4671-40d7-997e-25dc32cfed2a");
pub const IID_ISBE2MediaTypeProfile = &IID_ISBE2MediaTypeProfile_Value;
pub const ISBE2MediaTypeProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: *const fn (
            self: *const ISBE2MediaTypeProfile,
            p_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: *const fn (
            self: *const ISBE2MediaTypeProfile,
            index: u32,
            pp_media_type: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: *const fn (
            self: *const ISBE2MediaTypeProfile,
            p_media_type: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteStream: *const fn (
            self: *const ISBE2MediaTypeProfile,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStreamCount(self: *const T, p_count_: ?*u32) HRESULT {
                return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), p_count_);
            }
            pub inline fn getStream(self: *const T, index_: u32, pp_media_type_: ?*?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).GetStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), index_, pp_media_type_);
            }
            pub inline fn addStream(self: *const T, p_media_type_: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).AddStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), p_media_type_);
            }
            pub inline fn deleteStream(self: *const T, index_: u32) HRESULT {
                return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).DeleteStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), index_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2FileScan_Value = Guid.initString("3e2bf5a5-4f96-4899-a1a3-75e8be9a5ac0");
pub const IID_ISBE2FileScan = &IID_ISBE2FileScan_Value;
pub const ISBE2FileScan = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RepairFile: *const fn (
            self: *const ISBE2FileScan,
            filename: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn repairFile(self: *const T, filename_: ?[*:0]const u16) HRESULT {
                return @as(*const ISBE2FileScan.VTable, @ptrCast(self.vtable)).RepairFile(@as(*const ISBE2FileScan, @ptrCast(self)), filename_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SectionList_Value = Guid.initString("73da5d04-4347-45d3-a9dc-fae9ddbe558d");
pub const CLSID_SectionList = &CLSID_SectionList_Value;

const CLSID_Mpeg2Stream_Value = Guid.initString("f91d96c7-8509-4d0b-ab26-a0dd10904bb7");
pub const CLSID_Mpeg2Stream = &CLSID_Mpeg2Stream_Value;

const CLSID_Mpeg2Data_Value = Guid.initString("c666e115-bb62-4027-a113-82d643fe2d99");
pub const CLSID_Mpeg2Data = &CLSID_Mpeg2Data_Value;

pub const PID_BITS_MIDL = extern struct {
    Bits: u16 align(1),
};

pub const MPEG_HEADER_BITS_MIDL = extern struct {
    Bits: u16 align(1),
};

pub const MPEG_HEADER_VERSION_BITS_MIDL = extern struct {
    Bits: u8,
};

pub const MPEG_CURRENT_NEXT_BIT = enum(i32) {
    NEXT = 0,
    CURRENT = 1,
};
pub const MPEG_SECTION_IS_NEXT = MPEG_CURRENT_NEXT_BIT.NEXT;
pub const MPEG_SECTION_IS_CURRENT = MPEG_CURRENT_NEXT_BIT.CURRENT;

pub const TID_EXTENSION = extern struct {
    wTidExt: u16 align(1),
    wCount: u16 align(1),
};

pub const SECTION = extern struct {
    TableId: u8,
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    },
    SectionData: [1]u8,
};

pub const LONG_SECTION = extern struct {
    TableId: u8 align(1),
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    } align(1),
    TableIdExtension: u16 align(1),
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    } align(1),
    SectionNumber: u8 align(1),
    LastSectionNumber: u8 align(1),
    RemainingData: [1]u8 align(1),
};

pub const DSMCC_SECTION = extern struct {
    TableId: u8 align(1),
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    } align(1),
    TableIdExtension: u16 align(1),
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    } align(1),
    SectionNumber: u8 align(1),
    LastSectionNumber: u8 align(1),
    ProtocolDiscriminator: u8 align(1),
    DsmccType: u8 align(1),
    MessageId: u16 align(1),
    TransactionId: u32 align(1),
    Reserved: u8 align(1),
    AdaptationLength: u8 align(1),
    MessageLength: u16 align(1),
    RemainingData: [1]u8 align(1),
};

pub const MPEG_RQST_PACKET = extern struct {
    dwLength: u32 align(1),
    pSection: ?*SECTION align(1),
};

pub const MPEG_PACKET_LIST = extern struct {
    wPacketCount: u16 align(1),
    PacketList: [1]?*MPEG_RQST_PACKET align(1),
};

pub const DSMCC_FILTER_OPTIONS = extern struct {
    fSpecifyProtocol: BOOL align(1),
    Protocol: u8 align(1),
    fSpecifyType: BOOL align(1),
    Type: u8 align(1),
    fSpecifyMessageId: BOOL align(1),
    MessageId: u16 align(1),
    fSpecifyTransactionId: BOOL align(1),
    fUseTrxIdMessageIdMask: BOOL align(1),
    TransactionId: u32 align(1),
    fSpecifyModuleVersion: BOOL align(1),
    ModuleVersion: u8 align(1),
    fSpecifyBlockNumber: BOOL align(1),
    BlockNumber: u16 align(1),
    fGetModuleCall: BOOL align(1),
    NumberOfBlocksInModule: u16 align(1),
};

pub const ATSC_FILTER_OPTIONS = extern struct {
    fSpecifyEtmId: BOOL align(1),
    EtmId: u32 align(1),
};

pub const DVB_EIT_FILTER_OPTIONS = extern struct {
    fSpecifySegment: BOOL align(1),
    bSegment: u8 align(1),
};

pub const MPEG2_FILTER = extern struct {
    bVersionNumber: u8 align(1),
    wFilterSize: u16 align(1),
    fUseRawFilteringBits: BOOL align(1),
    Filter: [16]u8 align(1),
    Mask: [16]u8 align(1),
    fSpecifyTableIdExtension: BOOL align(1),
    TableIdExtension: u16 align(1),
    fSpecifyVersion: BOOL align(1),
    Version: u8 align(1),
    fSpecifySectionNumber: BOOL align(1),
    SectionNumber: u8 align(1),
    fSpecifyCurrentNext: BOOL align(1),
    fNext: BOOL align(1),
    fSpecifyDsmccOptions: BOOL align(1),
    Dsmcc: DSMCC_FILTER_OPTIONS align(1),
    fSpecifyAtscOptions: BOOL align(1),
    Atsc: ATSC_FILTER_OPTIONS align(1),
};

pub const MPEG2_FILTER2 = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            bVersionNumber: u8 align(1),
            wFilterSize: u16 align(1),
            fUseRawFilteringBits: BOOL align(1),
            Filter: [16]u8 align(1),
            Mask: [16]u8 align(1),
            fSpecifyTableIdExtension: BOOL align(1),
            TableIdExtension: u16 align(1),
            fSpecifyVersion: BOOL align(1),
            Version: u8 align(1),
            fSpecifySectionNumber: BOOL align(1),
            SectionNumber: u8 align(1),
            fSpecifyCurrentNext: BOOL align(1),
            fNext: BOOL align(1),
            fSpecifyDsmccOptions: BOOL align(1),
            Dsmcc: DSMCC_FILTER_OPTIONS align(1),
            fSpecifyAtscOptions: BOOL align(1),
            Atsc: ATSC_FILTER_OPTIONS align(1),
        },
        bVersion1Bytes: [124]u8,
    } align(1),
    fSpecifyDvbEitOptions: BOOL align(1),
    DvbEit: DVB_EIT_FILTER_OPTIONS align(1),
};

pub const MPEG_STREAM_BUFFER = extern struct {
    hr: HRESULT align(1),
    dwDataBufferSize: u32 align(1),
    dwSizeOfDataRead: u32 align(1),
    pDataBuffer: ?*u8 align(1),
};

pub const MPEG_TIME = extern struct {
    Hours: u8,
    Minutes: u8,
    Seconds: u8,
};

pub const MPEG_DATE = extern struct {
    Date: u8 align(1),
    Month: u8 align(1),
    Year: u16 align(1),
};

pub const MPEG_DATE_AND_TIME = extern struct {
    D: MPEG_DATE,
    T: MPEG_TIME,
};

pub const MPEG_CONTEXT_TYPE = enum(i32) {
    BCS_DEMUX = 0,
    WINSOCK = 1,
};
pub const MPEG_CONTEXT_BCS_DEMUX = MPEG_CONTEXT_TYPE.BCS_DEMUX;
pub const MPEG_CONTEXT_WINSOCK = MPEG_CONTEXT_TYPE.WINSOCK;

pub const MPEG_BCS_DEMUX = extern struct {
    AVMGraphId: u32 align(1),
};

pub const MPEG_WINSOCK = extern struct {
    AVMGraphId: u32 align(1),
};

pub const MPEG_CONTEXT = extern struct {
    Type: MPEG_CONTEXT_TYPE align(1),
    U: extern union {
        Demux: MPEG_BCS_DEMUX,
        Winsock: MPEG_WINSOCK,
    } align(1),
};

pub const MPEG_REQUEST_TYPE = enum(i32) {
    UNKNOWN = 0,
    GET_SECTION = 1,
    GET_SECTION_ASYNC = 2,
    GET_TABLE = 3,
    GET_TABLE_ASYNC = 4,
    GET_SECTIONS_STREAM = 5,
    GET_PES_STREAM = 6,
    GET_TS_STREAM = 7,
    START_MPE_STREAM = 8,
};
pub const MPEG_RQST_UNKNOWN = MPEG_REQUEST_TYPE.UNKNOWN;
pub const MPEG_RQST_GET_SECTION = MPEG_REQUEST_TYPE.GET_SECTION;
pub const MPEG_RQST_GET_SECTION_ASYNC = MPEG_REQUEST_TYPE.GET_SECTION_ASYNC;
pub const MPEG_RQST_GET_TABLE = MPEG_REQUEST_TYPE.GET_TABLE;
pub const MPEG_RQST_GET_TABLE_ASYNC = MPEG_REQUEST_TYPE.GET_TABLE_ASYNC;
pub const MPEG_RQST_GET_SECTIONS_STREAM = MPEG_REQUEST_TYPE.GET_SECTIONS_STREAM;
pub const MPEG_RQST_GET_PES_STREAM = MPEG_REQUEST_TYPE.GET_PES_STREAM;
pub const MPEG_RQST_GET_TS_STREAM = MPEG_REQUEST_TYPE.GET_TS_STREAM;
pub const MPEG_RQST_START_MPE_STREAM = MPEG_REQUEST_TYPE.START_MPE_STREAM;

pub const MPEG_SERVICE_REQUEST = extern struct {
    Type: MPEG_REQUEST_TYPE align(1),
    Context: MPEG_CONTEXT align(1),
    Pid: u16 align(1),
    TableId: u8 align(1),
    Filter: MPEG2_FILTER align(1),
    Flags: u32 align(1),
};

pub const MPEG_SERVICE_RESPONSE = extern struct {
    IPAddress: u32 align(1),
    Port: u16 align(1),
};

pub const DSMCC_ELEMENT = extern struct {
    pid: u16 align(1),
    bComponentTag: u8 align(1),
    dwCarouselId: u32 align(1),
    dwTransactionId: u32 align(1),
    pNext: ?*DSMCC_ELEMENT align(1),
};

pub const MPE_ELEMENT = extern struct {
    pid: u16 align(1),
    bComponentTag: u8 align(1),
    pNext: ?*MPE_ELEMENT align(1),
};

pub const MPEG_STREAM_FILTER = extern struct {
    wPidValue: u16 align(1),
    dwFilterSize: u32 align(1),
    fCrcEnabled: BOOL align(1),
    rgchFilter: [16]u8 align(1),
    rgchMask: [16]u8 align(1),
};

const IID_IMpeg2TableFilter_Value = Guid.initString("bdcdd913-9ecd-4fb2-81ae-adf747ea75a5");
pub const IID_IMpeg2TableFilter = &IID_IMpeg2TableFilter_Value;
pub const IMpeg2TableFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPID: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTable: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
            e: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePID: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTable: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: *const fn (
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
            e: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPID(self: *const T, p_: u16) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddPID(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_);
            }
            pub inline fn addTable(self: *const T, p_: u16, t_: u8) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddTable(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_, t_);
            }
            pub inline fn addExtension(self: *const T, p_: u16, t_: u8, e_: u16) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_, t_, e_);
            }
            pub inline fn removePID(self: *const T, p_: u16) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemovePID(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_);
            }
            pub inline fn removeTable(self: *const T, p_: u16, t_: u8) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemoveTable(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_, t_);
            }
            pub inline fn removeExtension(self: *const T, p_: u16, t_: u8, e_: u16) HRESULT {
                return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IMpeg2TableFilter, @ptrCast(self)), p_, t_, e_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Mpeg2TableSampleHdr = extern struct {
    SectionCount: u8 align(1),
    Reserved: [3]u8 align(1),
    SectionOffsets: [1]i32 align(1),
};

const CLSID_Mpeg2DataLib_Value = Guid.initString("dbaf6c1b-b6a4-4898-ae65-204f0d9509a1");
pub const CLSID_Mpeg2DataLib = &CLSID_Mpeg2DataLib_Value;

const IID_IMpeg2Data_Value = Guid.initString("9b396d40-f380-4e3c-a514-1a82bf6ebfe6");
pub const IID_IMpeg2Data = &IID_IMpeg2Data_Value;
pub const IMpeg2Data = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSection: *const fn (
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            p_filter: ?*MPEG2_FILTER,
            dw_timeout: u32,
            pp_section_list: ?*?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: *const fn (
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            p_filter: ?*MPEG2_FILTER,
            dw_timeout: u32,
            pp_section_list: ?*?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamOfSections: *const fn (
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            p_filter: ?*MPEG2_FILTER,
            h_data_ready_event: ?HANDLE,
            pp_mpeg_stream: ?*?*IMpeg2Stream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSection(self: *const T, pid_: u16, tid_: u8, p_filter_: ?*MPEG2_FILTER, dw_timeout_: u32, pp_section_list_: ?*?*ISectionList) HRESULT {
                return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetSection(@as(*const IMpeg2Data, @ptrCast(self)), pid_, tid_, p_filter_, dw_timeout_, pp_section_list_);
            }
            pub inline fn getTable(self: *const T, pid_: u16, tid_: u8, p_filter_: ?*MPEG2_FILTER, dw_timeout_: u32, pp_section_list_: ?*?*ISectionList) HRESULT {
                return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetTable(@as(*const IMpeg2Data, @ptrCast(self)), pid_, tid_, p_filter_, dw_timeout_, pp_section_list_);
            }
            pub inline fn getStreamOfSections(self: *const T, pid_: u16, tid_: u8, p_filter_: ?*MPEG2_FILTER, h_data_ready_event_: ?HANDLE, pp_mpeg_stream_: ?*?*IMpeg2Stream) HRESULT {
                return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetStreamOfSections(@as(*const IMpeg2Data, @ptrCast(self)), pid_, tid_, p_filter_, h_data_ready_event_, pp_mpeg_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISectionList_Value = Guid.initString("afec1eb5-2a64-46c6-bf4b-ae3ccb6afdb0");
pub const IID_ISectionList = &IID_ISectionList_Value;
pub const ISectionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const ISectionList,
            request_type: MPEG_REQUEST_TYPE,
            p_mpeg2_data: ?*IMpeg2Data,
            p_context: ?*MPEG_CONTEXT,
            pid: u16,
            tid: u8,
            p_filter: ?*MPEG2_FILTER,
            timeout: u32,
            h_done_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeWithRawSections: *const fn (
            self: *const ISectionList,
            pmpl_sections: ?*MPEG_PACKET_LIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelPendingRequest: *const fn (
            self: *const ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfSections: *const fn (
            self: *const ISectionList,
            p_count: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSectionData: *const fn (
            self: *const ISectionList,
            section_number: u16,
            pdw_raw_packet_length: ?*u32,
            pp_section: ?*?*SECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramIdentifier: *const fn (
            self: *const ISectionList,
            p_pid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdentifier: *const fn (
            self: *const ISectionList,
            p_table_id: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, request_type_: MPEG_REQUEST_TYPE, p_mpeg2_data_: ?*IMpeg2Data, p_context_: ?*MPEG_CONTEXT, pid_: u16, tid_: u8, p_filter_: ?*MPEG2_FILTER, timeout_: u32, h_done_event_: ?HANDLE) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ISectionList, @ptrCast(self)), request_type_, p_mpeg2_data_, p_context_, pid_, tid_, p_filter_, timeout_, h_done_event_);
            }
            pub inline fn initializeWithRawSections(self: *const T, pmpl_sections_: ?*MPEG_PACKET_LIST) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).InitializeWithRawSections(@as(*const ISectionList, @ptrCast(self)), pmpl_sections_);
            }
            pub inline fn cancelPendingRequest(self: *const T) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).CancelPendingRequest(@as(*const ISectionList, @ptrCast(self)));
            }
            pub inline fn getNumberOfSections(self: *const T, p_count_: ?*u16) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetNumberOfSections(@as(*const ISectionList, @ptrCast(self)), p_count_);
            }
            pub inline fn getSectionData(self: *const T, section_number_: u16, pdw_raw_packet_length_: ?*u32, pp_section_: ?*?*SECTION) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetSectionData(@as(*const ISectionList, @ptrCast(self)), section_number_, pdw_raw_packet_length_, pp_section_);
            }
            pub inline fn getProgramIdentifier(self: *const T, p_pid_: ?*u16) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetProgramIdentifier(@as(*const ISectionList, @ptrCast(self)), p_pid_);
            }
            pub inline fn getTableIdentifier(self: *const T, p_table_id_: ?*u8) HRESULT {
                return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetTableIdentifier(@as(*const ISectionList, @ptrCast(self)), p_table_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMpeg2Stream_Value = Guid.initString("400cc286-32a0-4ce4-9041-39571125a635");
pub const IID_IMpeg2Stream = &IID_IMpeg2Stream_Value;
pub const IMpeg2Stream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IMpeg2Stream,
            request_type: MPEG_REQUEST_TYPE,
            p_mpeg2_data: ?*IMpeg2Data,
            p_context: ?*MPEG_CONTEXT,
            pid: u16,
            tid: u8,
            p_filter: ?*MPEG2_FILTER,
            h_data_ready_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupplyDataBuffer: *const fn (
            self: *const IMpeg2Stream,
            p_stream_buffer: ?*MPEG_STREAM_BUFFER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, request_type_: MPEG_REQUEST_TYPE, p_mpeg2_data_: ?*IMpeg2Data, p_context_: ?*MPEG_CONTEXT, pid_: u16, tid_: u8, p_filter_: ?*MPEG2_FILTER, h_data_ready_event_: ?HANDLE) HRESULT {
                return @as(*const IMpeg2Stream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMpeg2Stream, @ptrCast(self)), request_type_, p_mpeg2_data_, p_context_, pid_, tid_, p_filter_, h_data_ready_event_);
            }
            pub inline fn supplyDataBuffer(self: *const T, p_stream_buffer_: ?*MPEG_STREAM_BUFFER) HRESULT {
                return @as(*const IMpeg2Stream.VTable, @ptrCast(self.vtable)).SupplyDataBuffer(@as(*const IMpeg2Stream, @ptrCast(self)), p_stream_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGenericDescriptor_Value = Guid.initString("6a5918f8-a77a-4f61-aed0-5702bdcda3e6");
pub const IID_IGenericDescriptor = &IID_IGenericDescriptor_Value;
pub const IGenericDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IGenericDescriptor,
            pb_desc: ?*u8,
            b_count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTag: *const fn (
            self: *const IGenericDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IGenericDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBody: *const fn (
            self: *const IGenericDescriptor,
            ppb_val: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, pb_desc_: ?*u8, b_count_: i32) HRESULT {
                return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IGenericDescriptor, @ptrCast(self)), pb_desc_, b_count_);
            }
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IGenericDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IGenericDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getBody(self: *const T, ppb_val_: ?*?*u8) HRESULT {
                return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetBody(@as(*const IGenericDescriptor, @ptrCast(self)), ppb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGenericDescriptor2_Value = Guid.initString("bf02fb7e-9792-4e10-a68d-033a2cc246a5");
pub const IID_IGenericDescriptor2 = &IID_IGenericDescriptor2_Value;
pub const IGenericDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IGenericDescriptor.VTable,
        Initialize: *const fn (
            self: *const IGenericDescriptor2,
            pb_desc: ?*u8,
            w_count: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IGenericDescriptor2,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IGenericDescriptor.MethodMixin(T);
            pub inline fn initialize(self: *const T, pb_desc_: ?*u8, w_count_: u16) HRESULT {
                return @as(*const IGenericDescriptor2.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IGenericDescriptor2, @ptrCast(self)), pb_desc_, w_count_);
            }
            pub inline fn getLength(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IGenericDescriptor2.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IGenericDescriptor2, @ptrCast(self)), pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ProgramElement = extern struct {
    wProgramNumber: u16,
    wProgramMapPID: u16,
};

const IID_IPAT_Value = Guid.initString("6623b511-4b5f-43c3-9a01-e8ff84188060");
pub const IID_IPAT = &IID_IPAT_Value;
pub const IPAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IPAT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IPAT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IPAT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IPAT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramNumber: *const fn (
            self: *const IPAT,
            dw_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramMapPid: *const fn (
            self: *const IPAT,
            dw_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRecordProgramMapPid: *const fn (
            self: *const IPAT,
            w_program_number: u16,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IPAT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IPAT,
            pp_p_a_t: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IPAT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPAT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IPAT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPAT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPAT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordProgramNumber(self: *const T, dw_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetRecordProgramNumber(@as(*const IPAT, @ptrCast(self)), dw_index_, pw_val_);
            }
            pub inline fn getRecordProgramMapPid(self: *const T, dw_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetRecordProgramMapPid(@as(*const IPAT, @ptrCast(self)), dw_index_, pw_val_);
            }
            pub inline fn findRecordProgramMapPid(self: *const T, w_program_number_: u16, pw_val_: ?*u16) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).FindRecordProgramMapPid(@as(*const IPAT, @ptrCast(self)), w_program_number_, pw_val_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IPAT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_p_a_t_: ?*?*IPAT) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IPAT, @ptrCast(self)), pp_p_a_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IPAT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IPAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IPAT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICAT_Value = Guid.initString("7c6995fb-2a31-4bd7-953e-b1ad7fb7d31c");
pub const IID_ICAT = &IID_ICAT_Value;
pub const ICAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const ICAT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const ICAT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const ICAT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const ICAT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const ICAT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const ICAT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const ICAT,
            dw_timeout: u32,
            pp_c_a_t: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const ICAT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ICAT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ICAT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ICAT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ICAT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ICAT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const ICAT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, dw_timeout_: u32, pp_c_a_t_: ?*?*ICAT) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const ICAT, @ptrCast(self)), dw_timeout_, pp_c_a_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const ICAT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const ICAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const ICAT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMT_Value = Guid.initString("01f3b398-9527-4736-94db-5195878e97a8");
pub const IID_IPMT = &IID_IPMT_Value;
pub const IPMT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IPMT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramNumber: *const fn (
            self: *const IPMT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IPMT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPcrPid: *const fn (
            self: *const IPMT,
            p_pid_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IPMT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IPMT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IPMT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IPMT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStreamType: *const fn (
            self: *const IPMT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordElementaryPid: *const fn (
            self: *const IPMT,
            dw_record_index: u32,
            p_pid_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IPMT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IPMT,
            dw_record_index: u32,
            dw_desc_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IPMT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryServiceGatewayInfo: *const fn (
            self: *const IPMT,
            pp_d_s_m_c_c_list: ?*?*DSMCC_ELEMENT,
            pui_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMPEInfo: *const fn (
            self: *const IPMT,
            pp_m_p_e_list: ?*?*MPE_ELEMENT,
            pui_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IPMT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IPMT,
            pp_p_m_t: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IPMT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPMT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getProgramNumber(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetProgramNumber(@as(*const IPMT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPMT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getPcrPid(self: *const T, p_pid_val_: ?*u16) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetPcrPid(@as(*const IPMT, @ptrCast(self)), p_pid_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IPMT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IPMT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IPMT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfRecords(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPMT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getRecordStreamType(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordStreamType(@as(*const IPMT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordElementaryPid(self: *const T, dw_record_index_: u32, p_pid_val_: ?*u16) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordElementaryPid(@as(*const IPMT, @ptrCast(self)), dw_record_index_, p_pid_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IPMT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_desc_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IPMT, @ptrCast(self)), dw_record_index_, dw_desc_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IPMT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn queryServiceGatewayInfo(self: *const T, pp_d_s_m_c_c_list_: ?*?*DSMCC_ELEMENT, pui_count_: ?*u32) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).QueryServiceGatewayInfo(@as(*const IPMT, @ptrCast(self)), pp_d_s_m_c_c_list_, pui_count_);
            }
            pub inline fn queryMPEInfo(self: *const T, pp_m_p_e_list_: ?*?*MPE_ELEMENT, pui_count_: ?*u32) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).QueryMPEInfo(@as(*const IPMT, @ptrCast(self)), pp_m_p_e_list_, pui_count_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IPMT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_p_m_t_: ?*?*IPMT) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IPMT, @ptrCast(self)), pp_p_m_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IPMT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IPMT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IPMT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITSDT_Value = Guid.initString("d19bdb43-405b-4a7c-a791-c89110c33165");
pub const IID_ITSDT = &IID_ITSDT_Value;
pub const ITSDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const ITSDT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const ITSDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const ITSDT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const ITSDT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const ITSDT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const ITSDT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const ITSDT,
            pp_t_s_d_t: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const ITSDT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITSDT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ITSDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ITSDT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ITSDT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ITSDT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const ITSDT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_t_s_d_t_: ?*?*ITSDT) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const ITSDT, @ptrCast(self)), pp_t_s_d_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const ITSDT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const ITSDT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPSITables_Value = Guid.initString("919f24c5-7b14-42ac-a4b0-2ae08daf00ac");
pub const IID_IPSITables = &IID_IPSITables_Value;
pub const IPSITables = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTable: *const fn (
            self: *const IPSITables,
            dw_t_s_i_d: u32,
            dw_t_i_d__p_i_d: u32,
            dw_hashed_ver: u32,
            dw_para4: u32,
            pp_i_unknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTable(self: *const T, dw_t_s_i_d_: u32, dw_t_i_d__p_i_d_: u32, dw_hashed_ver_: u32, dw_para4_: u32, pp_i_unknown_: ?*?*IUnknown) HRESULT {
                return @as(*const IPSITables.VTable, @ptrCast(self.vtable)).GetTable(@as(*const IPSITables, @ptrCast(self)), dw_t_s_i_d_, dw_t_i_d__p_i_d_, dw_hashed_ver_, dw_para4_, pp_i_unknown_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscPsipParser_Value = Guid.initString("b2c98995-5eb2-4fb1-b406-f3e8e2026a9a");
pub const IID_IAtscPsipParser = &IID_IAtscPsipParser_Value;
pub const IAtscPsipParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IAtscPsipParser,
            punk_mpeg2_data: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAT: *const fn (
            self: *const IAtscPsipParser,
            pp_p_a_t: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAT: *const fn (
            self: *const IAtscPsipParser,
            dw_timeout: u32,
            pp_c_a_t: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPMT: *const fn (
            self: *const IAtscPsipParser,
            pid: u16,
            pw_program_number: ?*u16,
            pp_p_m_t: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSDT: *const fn (
            self: *const IAtscPsipParser,
            pp_t_s_d_t: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMGT: *const fn (
            self: *const IAtscPsipParser,
            pp_m_g_t: ?*?*IATSC_MGT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVCT: *const fn (
            self: *const IAtscPsipParser,
            table_id: u8,
            f_get_next_table: BOOL,
            pp_v_c_t: ?*?*IATSC_VCT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: *const fn (
            self: *const IAtscPsipParser,
            pid: u16,
            pw_source_id: ?*u16,
            dw_timeout: u32,
            pp_e_i_t: ?*?*IATSC_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetETT: *const fn (
            self: *const IAtscPsipParser,
            pid: u16,
            w_source_id: ?*u16,
            pw_event_id: ?*u16,
            pp_e_t_t: ?*?*IATSC_ETT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSTT: *const fn (
            self: *const IAtscPsipParser,
            pp_s_t_t: ?*?*IATSC_STT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEAS: *const fn (
            self: *const IAtscPsipParser,
            pid: u16,
            pp_e_a_s: ?*?*ISCTE_EAS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, punk_mpeg2_data_: ?*IUnknown) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAtscPsipParser, @ptrCast(self)), punk_mpeg2_data_);
            }
            pub inline fn getPAT(self: *const T, pp_p_a_t_: ?*?*IPAT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetPAT(@as(*const IAtscPsipParser, @ptrCast(self)), pp_p_a_t_);
            }
            pub inline fn getCAT(self: *const T, dw_timeout_: u32, pp_c_a_t_: ?*?*ICAT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetCAT(@as(*const IAtscPsipParser, @ptrCast(self)), dw_timeout_, pp_c_a_t_);
            }
            pub inline fn getPMT(self: *const T, pid_: u16, pw_program_number_: ?*u16, pp_p_m_t_: ?*?*IPMT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetPMT(@as(*const IAtscPsipParser, @ptrCast(self)), pid_, pw_program_number_, pp_p_m_t_);
            }
            pub inline fn getTSDT(self: *const T, pp_t_s_d_t_: ?*?*ITSDT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetTSDT(@as(*const IAtscPsipParser, @ptrCast(self)), pp_t_s_d_t_);
            }
            pub inline fn getMGT(self: *const T, pp_m_g_t_: ?*?*IATSC_MGT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetMGT(@as(*const IAtscPsipParser, @ptrCast(self)), pp_m_g_t_);
            }
            pub inline fn getVCT(self: *const T, table_id_: u8, f_get_next_table_: BOOL, pp_v_c_t_: ?*?*IATSC_VCT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetVCT(@as(*const IAtscPsipParser, @ptrCast(self)), table_id_, f_get_next_table_, pp_v_c_t_);
            }
            pub inline fn getEIT(self: *const T, pid_: u16, pw_source_id_: ?*u16, dw_timeout_: u32, pp_e_i_t_: ?*?*IATSC_EIT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IAtscPsipParser, @ptrCast(self)), pid_, pw_source_id_, dw_timeout_, pp_e_i_t_);
            }
            pub inline fn getETT(self: *const T, pid_: u16, w_source_id_: ?*u16, pw_event_id_: ?*u16, pp_e_t_t_: ?*?*IATSC_ETT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetETT(@as(*const IAtscPsipParser, @ptrCast(self)), pid_, w_source_id_, pw_event_id_, pp_e_t_t_);
            }
            pub inline fn getSTT(self: *const T, pp_s_t_t_: ?*?*IATSC_STT) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetSTT(@as(*const IAtscPsipParser, @ptrCast(self)), pp_s_t_t_);
            }
            pub inline fn getEAS(self: *const T, pid_: u16, pp_e_a_s_: ?*?*ISCTE_EAS) HRESULT {
                return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetEAS(@as(*const IAtscPsipParser, @ptrCast(self)), pid_, pp_e_a_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_MGT_Value = Guid.initString("8877dabd-c137-4073-97e3-779407a5d87a");
pub const IID_IATSC_MGT = &IID_IATSC_MGT_Value;
pub const IATSC_MGT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IATSC_MGT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IATSC_MGT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const IATSC_MGT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IATSC_MGT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordType: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTypePid: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            ppid_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVersionNumber: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IATSC_MGT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IATSC_MGT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IATSC_MGT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IATSC_MGT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_MGT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_MGT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_MGT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_MGT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordType(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordType(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordTypePid(self: *const T, dw_record_index_: u32, ppid_val_: ?*u16) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordTypePid(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, ppid_val_);
            }
            pub inline fn getRecordVersionNumber(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordVersionNumber(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_MGT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_MGT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_MGT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_MGT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_VCT_Value = Guid.initString("26879a18-32f9-46c6-91f0-fb6479270e8c");
pub const IID_IATSC_VCT = &IID_IATSC_VCT_Value;
pub const IATSC_VCT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IATSC_VCT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IATSC_VCT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IATSC_VCT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const IATSC_VCT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IATSC_VCT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordName: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pws_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMajorChannelNumber: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMinorChannelNumber: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModulationMode: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCarrierFrequency: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramNumber: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEtmLocation: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsAccessControlledBitSet: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsHiddenBitSet: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsPathSelectBitSet: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsOutOfBandBitSet: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsHideGuideBitSet: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceType: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSourceId: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IATSC_VCT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IATSC_VCT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IATSC_VCT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IATSC_VCT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_VCT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_VCT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IATSC_VCT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_VCT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_VCT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordName(self: *const T, dw_record_index_: u32, pws_name_: ?*?PWSTR) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordName(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pws_name_);
            }
            pub inline fn getRecordMajorChannelNumber(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordMajorChannelNumber(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordMinorChannelNumber(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordMinorChannelNumber(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordModulationMode(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordModulationMode(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordCarrierFrequency(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordCarrierFrequency(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordTransportStreamId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordProgramNumber(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordProgramNumber(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordEtmLocation(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordEtmLocation(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordIsAccessControlledBitSet(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsAccessControlledBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordIsHiddenBitSet(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsHiddenBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordIsPathSelectBitSet(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsPathSelectBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordIsOutOfBandBitSet(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsOutOfBandBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordIsHideGuideBitSet(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsHideGuideBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordServiceType(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordServiceType(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordSourceId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordSourceId(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_VCT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_VCT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_VCT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_VCT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_EIT_Value = Guid.initString("d7c212d7-76a2-4b4b-aa56-846879a80096");
pub const IID_IATSC_EIT = &IID_IATSC_EIT_Value;
pub const IATSC_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IATSC_EIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IATSC_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceId: *const fn (
            self: *const IATSC_EIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const IATSC_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IATSC_EIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEtmLocation: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pmd_val: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTitleText: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pdw_length: ?*u32,
            pp_text: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IATSC_EIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_EIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSourceId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetSourceId(@as(*const IATSC_EIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_EIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordEventId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordStartTime(self: *const T, dw_record_index_: u32, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pmdt_val_);
            }
            pub inline fn getRecordEtmLocation(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordEtmLocation(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordDuration(self: *const T, dw_record_index_: u32, pmd_val_: ?*MPEG_TIME) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pmd_val_);
            }
            pub inline fn getRecordTitleText(self: *const T, dw_record_index_: u32, pdw_length_: ?*u32, pp_text_: ?*?*u8) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordTitleText(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pdw_length_, pp_text_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_EIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_ETT_Value = Guid.initString("5a142cc9-b8cf-4a86-a040-e9cadf3ef3e7");
pub const IID_IATSC_ETT = &IID_IATSC_ETT_Value;
pub const IATSC_ETT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IATSC_ETT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IATSC_ETT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const IATSC_ETT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEtmId: *const fn (
            self: *const IATSC_ETT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedMessageText: *const fn (
            self: *const IATSC_ETT,
            pdw_length: ?*u32,
            pp_text: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_ETT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_ETT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_ETT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getEtmId(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetEtmId(@as(*const IATSC_ETT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getExtendedMessageText(self: *const T, pdw_length_: ?*u32, pp_text_: ?*?*u8) HRESULT {
                return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetExtendedMessageText(@as(*const IATSC_ETT, @ptrCast(self)), pdw_length_, pp_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_STT_Value = Guid.initString("6bf42423-217d-4d6f-81e1-3a7b360ec896");
pub const IID_IATSC_STT = &IID_IATSC_STT_Value;
pub const IATSC_STT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IATSC_STT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const IATSC_STT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemTime: *const fn (
            self: *const IATSC_STT,
            pmdt_system_time: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGpsUtcOffset: *const fn (
            self: *const IATSC_STT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDaylightSavings: *const fn (
            self: *const IATSC_STT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IATSC_STT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IATSC_STT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IATSC_STT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_STT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_STT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSystemTime(self: *const T, pmdt_system_time_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetSystemTime(@as(*const IATSC_STT, @ptrCast(self)), pmdt_system_time_);
            }
            pub inline fn getGpsUtcOffset(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetGpsUtcOffset(@as(*const IATSC_STT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDaylightSavings(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetDaylightSavings(@as(*const IATSC_STT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_STT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_STT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_STT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISCTE_EAS_Value = Guid.initString("1ff544d6-161d-4fae-9faa-4f9f492ae999");
pub const IID_ISCTE_EAS = &IID_ISCTE_EAS_Value;
pub const ISCTE_EAS = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const ISCTE_EAS,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSequencyNumber: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventID: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginatorCode: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventCodeLen: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventCode: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawNatureOfActivationTextLen: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawNatureOfActivationText: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNatureOfActivationText: *const fn (
            self: *const ISCTE_EAS,
            bstr_i_s0639code: ?BSTR,
            pbstr_string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeRemaining: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartTime: *const fn (
            self: *const ISCTE_EAS,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlertPriority: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsOOBSourceID: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsMajor: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsMinor: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsAudioOOBSourceID: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlertText: *const fn (
            self: *const ISCTE_EAS,
            bstr_i_s0639code: ?BSTR,
            pbstr_string: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawAlertTextLen: *const fn (
            self: *const ISCTE_EAS,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawAlertText: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocationCount: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocationCodes: *const fn (
            self: *const ISCTE_EAS,
            b_index: u8,
            pb_state: ?*u8,
            pb_county_subdivision: ?*u8,
            pw_county: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionCount: *const fn (
            self: *const ISCTE_EAS,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionService: *const fn (
            self: *const ISCTE_EAS,
            b_index: u8,
            pb_i_b_ref: ?*u8,
            pw_first: ?*u16,
            pw_second: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const ISCTE_EAS,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const ISCTE_EAS,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const ISCTE_EAS,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ISCTE_EAS, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSequencyNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetSequencyNumber(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getProtocolVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getEASEventID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventID(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOriginatorCode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetOriginatorCode(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getEASEventCodeLen(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventCodeLen(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getEASEventCode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventCode(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRawNatureOfActivationTextLen(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawNatureOfActivationTextLen(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRawNatureOfActivationText(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawNatureOfActivationText(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getNatureOfActivationText(self: *const T, bstr_i_s0639code_: ?BSTR, pbstr_string_: ?*?BSTR) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetNatureOfActivationText(@as(*const ISCTE_EAS, @ptrCast(self)), bstr_i_s0639code_, pbstr_string_);
            }
            pub inline fn getTimeRemaining(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTimeRemaining(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getStartTime(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const ISCTE_EAS, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getDuration(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getAlertPriority(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetAlertPriority(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDetailsOOBSourceID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsOOBSourceID(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDetailsMajor(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsMajor(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDetailsMinor(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsMinor(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDetailsAudioOOBSourceID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsAudioOOBSourceID(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getAlertText(self: *const T, bstr_i_s0639code_: ?BSTR, pbstr_string_: ?*?BSTR) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetAlertText(@as(*const ISCTE_EAS, @ptrCast(self)), bstr_i_s0639code_, pbstr_string_);
            }
            pub inline fn getRawAlertTextLen(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawAlertTextLen(@as(*const ISCTE_EAS, @ptrCast(self)), pw_val_);
            }
            pub inline fn getRawAlertText(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawAlertText(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLocationCount(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetLocationCount(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLocationCodes(self: *const T, b_index_: u8, pb_state_: ?*u8, pb_county_subdivision_: ?*u8, pw_county_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetLocationCodes(@as(*const ISCTE_EAS, @ptrCast(self)), b_index_, pb_state_, pb_county_subdivision_, pw_county_);
            }
            pub inline fn getExceptionCount(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetExceptionCount(@as(*const ISCTE_EAS, @ptrCast(self)), pb_val_);
            }
            pub inline fn getExceptionService(self: *const T, b_index_: u8, pb_i_b_ref_: ?*u8, pw_first_: ?*u16, pw_second_: ?*u16) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetExceptionService(@as(*const ISCTE_EAS, @ptrCast(self)), b_index_, pb_i_b_ref_, pw_first_, pw_second_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ISCTE_EAS, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ISCTE_EAS, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ISCTE_EAS, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscContentAdvisoryDescriptor_Value = Guid.initString("ff76e60c-0283-43ea-ba32-b422238547ee");
pub const IID_IAtscContentAdvisoryDescriptor = &IID_IAtscContentAdvisoryDescriptor_Value;
pub const IAtscContentAdvisoryDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRatingRegionCount: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingRegion: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatedDimensions: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingDimension: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            b_index_outer: u8,
            b_index_inner: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingValue: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            b_index_outer: u8,
            b_index_inner: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingDescriptionText: *const fn (
            self: *const IAtscContentAdvisoryDescriptor,
            b_index: u8,
            pb_length: ?*u8,
            pp_text: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRatingRegionCount(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRatingRegionCount(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordRatingRegion(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingRegion(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getRecordRatedDimensions(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatedDimensions(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getRecordRatingDimension(self: *const T, b_index_outer_: u8, b_index_inner_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingDimension(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), b_index_outer_, b_index_inner_, pb_val_);
            }
            pub inline fn getRecordRatingValue(self: *const T, b_index_outer_: u8, b_index_inner_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingValue(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), b_index_outer_, b_index_inner_, pb_val_);
            }
            pub inline fn getRecordRatingDescriptionText(self: *const T, b_index_: u8, pb_length_: ?*u8, pp_text_: ?*?*u8) HRESULT {
                return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingDescriptionText(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), b_index_, pb_length_, pp_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptionServiceDescriptor_Value = Guid.initString("40834007-6834-46f0-bd45-d5f6a6be258c");
pub const IID_ICaptionServiceDescriptor = &IID_ICaptionServiceDescriptor_Value;
pub const ICaptionServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfServices: *const fn (
            self: *const ICaptionServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const ICaptionServiceDescriptor,
            b_index: u8,
            lang_code: *[3]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaptionServiceNumber: *const fn (
            self: *const ICaptionServiceDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCCType: *const fn (
            self: *const ICaptionServiceDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEasyReader: *const fn (
            self: *const ICaptionServiceDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWideAspectRatio: *const fn (
            self: *const ICaptionServiceDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumberOfServices(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetNumberOfServices(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, b_index_: u8, lang_code_: *[3]u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), b_index_, lang_code_);
            }
            pub inline fn getCaptionServiceNumber(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCaptionServiceNumber(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getCCType(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCCType(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getEasyReader(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetEasyReader(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getWideAspectRatio(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetWideAspectRatio(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IServiceLocationDescriptor_Value = Guid.initString("58c3c827-9d91-4215-bff3-820a49f0904c");
pub const IID_IServiceLocationDescriptor = &IID_IServiceLocationDescriptor_Value;
pub const IServiceLocationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPCR_PID: *const fn (
            self: *const IServiceLocationDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfElements: *const fn (
            self: *const IServiceLocationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementStreamType: *const fn (
            self: *const IServiceLocationDescriptor,
            b_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementPID: *const fn (
            self: *const IServiceLocationDescriptor,
            b_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementLanguageCode: *const fn (
            self: *const IServiceLocationDescriptor,
            b_index: u8,
            lang_code: *[3]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPCRPID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetPCR_PID(@as(*const IServiceLocationDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getNumberOfElements(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetNumberOfElements(@as(*const IServiceLocationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getElementStreamType(self: *const T, b_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementStreamType(@as(*const IServiceLocationDescriptor, @ptrCast(self)), b_index_, pb_val_);
            }
            pub inline fn getElementPID(self: *const T, b_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementPID(@as(*const IServiceLocationDescriptor, @ptrCast(self)), b_index_, pw_val_);
            }
            pub inline fn getElementLanguageCode(self: *const T, b_index_: u8, lang_code_: *[3]u8) HRESULT {
                return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementLanguageCode(@as(*const IServiceLocationDescriptor, @ptrCast(self)), b_index_, lang_code_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeSet_Value = Guid.initString("583ec3cc-4960-4857-982b-41a33ea0a006");
pub const IID_IAttributeSet = &IID_IAttributeSet_Value;
pub const IAttributeSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttrib: *const fn (
            self: *const IAttributeSet,
            guid_attribute: Guid,
            pb_attribute: ?*u8,
            dw_attribute_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAttrib(self: *const T, guid_attribute_: Guid, pb_attribute_: ?*u8, dw_attribute_length_: u32) HRESULT {
                return @as(*const IAttributeSet.VTable, @ptrCast(self.vtable)).SetAttrib(@as(*const IAttributeSet, @ptrCast(self)), guid_attribute_, pb_attribute_, dw_attribute_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeGet_Value = Guid.initString("52dbd1ec-e48f-4528-9232-f442a68f0ae1");
pub const IID_IAttributeGet = &IID_IAttributeGet_Value;
pub const IAttributeGet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: *const fn (
            self: *const IAttributeGet,
            pl_count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttribIndexed: *const fn (
            self: *const IAttributeGet,
            l_index: i32,
            pguid_attribute: ?*Guid,
            pb_attribute: ?*u8,
            pdw_attribute_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttrib: *const fn (
            self: *const IAttributeGet,
            guid_attribute: Guid,
            pb_attribute: ?*u8,
            pdw_attribute_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCount(self: *const T, pl_count_: ?*i32) HRESULT {
                return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAttributeGet, @ptrCast(self)), pl_count_);
            }
            pub inline fn getAttribIndexed(self: *const T, l_index_: i32, pguid_attribute_: ?*Guid, pb_attribute_: ?*u8, pdw_attribute_length_: ?*u32) HRESULT {
                return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetAttribIndexed(@as(*const IAttributeGet, @ptrCast(self)), l_index_, pguid_attribute_, pb_attribute_, pdw_attribute_length_);
            }
            pub inline fn getAttrib(self: *const T, guid_attribute_: Guid, pb_attribute_: ?*u8, pdw_attribute_length_: ?*u32) HRESULT {
                return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetAttrib(@as(*const IAttributeGet, @ptrCast(self)), guid_attribute_, pb_attribute_, pdw_attribute_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UDCR_TAG = extern struct {
    bVersion: u8,
    KID: [25]u8,
    ullBaseCounter: u64,
    ullBaseCounterRange: u64,
    fScrambled: BOOL,
    bStreamMark: u8,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const PIC_SEQ_SAMPLE = extern struct {
    _bitfield: u32,
};

pub const SAMPLE_SEQ_OFFSET = extern struct {
    _bitfield: u32,
};

pub const VA_VIDEO_FORMAT = enum(i32) {
    COMPONENT = 0,
    PAL = 1,
    NTSC = 2,
    SECAM = 3,
    MAC = 4,
    UNSPECIFIED = 5,
};
pub const VA_VIDEO_COMPONENT = VA_VIDEO_FORMAT.COMPONENT;
pub const VA_VIDEO_PAL = VA_VIDEO_FORMAT.PAL;
pub const VA_VIDEO_NTSC = VA_VIDEO_FORMAT.NTSC;
pub const VA_VIDEO_SECAM = VA_VIDEO_FORMAT.SECAM;
pub const VA_VIDEO_MAC = VA_VIDEO_FORMAT.MAC;
pub const VA_VIDEO_UNSPECIFIED = VA_VIDEO_FORMAT.UNSPECIFIED;

pub const VA_COLOR_PRIMARIES = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_GENERIC_FILM = 8,
};
pub const VA_PRIMARIES_ITU_R_BT_709 = VA_COLOR_PRIMARIES.ITU_R_BT_709;
pub const VA_PRIMARIES_UNSPECIFIED = VA_COLOR_PRIMARIES.UNSPECIFIED;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_M = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_M;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_B_G = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_PRIMARIES_SMPTE_170M = VA_COLOR_PRIMARIES.SMPTE_170M;
pub const VA_PRIMARIES_SMPTE_240M = VA_COLOR_PRIMARIES.SMPTE_240M;
pub const VA_PRIMARIES_H264_GENERIC_FILM = VA_COLOR_PRIMARIES.H264_GENERIC_FILM;

pub const VA_TRANSFER_CHARACTERISTICS = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    LINEAR = 8,
    H264_LOG_100_TO_1 = 9,
    H264_LOG_316_TO_1 = 10,
};
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_709 = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_709;
pub const VA_TRANSFER_CHARACTERISTICS_UNSPECIFIED = VA_TRANSFER_CHARACTERISTICS.UNSPECIFIED;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_M = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_M;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_B_G = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_170M = VA_TRANSFER_CHARACTERISTICS.SMPTE_170M;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_240M = VA_TRANSFER_CHARACTERISTICS.SMPTE_240M;
pub const VA_TRANSFER_CHARACTERISTICS_LINEAR = VA_TRANSFER_CHARACTERISTICS.LINEAR;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_100_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_100_TO_1;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_316_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_316_TO_1;

pub const VA_MATRIX_COEFFICIENTS = enum(i32) {
    H264_RGB = 0,
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    FCC = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_YCgCo = 8,
};
pub const VA_MATRIX_COEFF_H264_RGB = VA_MATRIX_COEFFICIENTS.H264_RGB;
pub const VA_MATRIX_COEFF_ITU_R_BT_709 = VA_MATRIX_COEFFICIENTS.ITU_R_BT_709;
pub const VA_MATRIX_COEFF_UNSPECIFIED = VA_MATRIX_COEFFICIENTS.UNSPECIFIED;
pub const VA_MATRIX_COEFF_FCC = VA_MATRIX_COEFFICIENTS.FCC;
pub const VA_MATRIX_COEFF_ITU_R_BT_470_SYSTEM_B_G = VA_MATRIX_COEFFICIENTS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_MATRIX_COEFF_SMPTE_170M = VA_MATRIX_COEFFICIENTS.SMPTE_170M;
pub const VA_MATRIX_COEFF_SMPTE_240M = VA_MATRIX_COEFFICIENTS.SMPTE_240M;
pub const VA_MATRIX_COEFF_H264_YCgCo = VA_MATRIX_COEFFICIENTS.H264_YCgCo;

pub const VA_OPTIONAL_VIDEO_PROPERTIES = extern struct {
    dwPictureHeight: u16,
    dwPictureWidth: u16,
    dwAspectRatioX: u16,
    dwAspectRatioY: u16,
    VAVideoFormat: VA_VIDEO_FORMAT,
    VAColorPrimaries: VA_COLOR_PRIMARIES,
    VATransferCharacteristics: VA_TRANSFER_CHARACTERISTICS,
    VAMatrixCoefficients: VA_MATRIX_COEFFICIENTS,
};

pub const TRANSPORT_PROPERTIES = extern struct {
    PID: u32,
    PCR: i64,
    Fields: extern union {
        pub const _Others = extern struct {
            _bitfield: i64,
        };
        Others: _Others,
        Value: i64,
    },
};

pub const PBDA_TAG_ATTRIBUTE = extern struct {
    TableUUId: Guid,
    TableId: u8,
    VersionNo: u16,
    TableDataSize: u32,
    TableData: [1]u8,
};

pub const CAPTURE_STREAMTIME = extern struct {
    StreamTime: i64,
};

pub const DSHOW_STREAM_DESC = extern struct {
    VersionNo: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
};

pub const SAMPLE_LIVE_STREAM_TIME = extern struct {
    qwStreamTime: u64,
    qwLiveTime: u64,
};

const CLSID_TIFLoad_Value = Guid.initString("14eb8748-1753-4393-95ae-4f7e7a87aad6");
pub const CLSID_TIFLoad = &CLSID_TIFLoad_Value;

pub const DVB_STRCONV_MODE = enum(i32) {
    DVB = 0,
    DVB_EMPHASIS = 1,
    DVB_WITHOUT_EMPHASIS = 2,
    ISDB = 3,
};
pub const STRCONV_MODE_DVB = DVB_STRCONV_MODE.DVB;
pub const STRCONV_MODE_DVB_EMPHASIS = DVB_STRCONV_MODE.DVB_EMPHASIS;
pub const STRCONV_MODE_DVB_WITHOUT_EMPHASIS = DVB_STRCONV_MODE.DVB_WITHOUT_EMPHASIS;
pub const STRCONV_MODE_ISDB = DVB_STRCONV_MODE.ISDB;

const IID_IDvbSiParser_Value = Guid.initString("b758a7bd-14dc-449d-b828-35909acb3b1e");
pub const IID_IDvbSiParser = &IID_IDvbSiParser_Value;
pub const IDvbSiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDvbSiParser,
            punk_mpeg2_data: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAT: *const fn (
            self: *const IDvbSiParser,
            pp_p_a_t: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAT: *const fn (
            self: *const IDvbSiParser,
            dw_timeout: u32,
            pp_c_a_t: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPMT: *const fn (
            self: *const IDvbSiParser,
            pid: u16,
            pw_program_number: ?*u16,
            pp_p_m_t: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSDT: *const fn (
            self: *const IDvbSiParser,
            pp_t_s_d_t: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNIT: *const fn (
            self: *const IDvbSiParser,
            table_id: u8,
            pw_network_id: ?*u16,
            pp_n_i_t: ?*?*IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSDT: *const fn (
            self: *const IDvbSiParser,
            table_id: u8,
            pw_transport_stream_id: ?*u16,
            pp_s_d_t: ?*?*IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: *const fn (
            self: *const IDvbSiParser,
            table_id: u8,
            pw_service_id: ?*u16,
            pp_e_i_t: ?*?*IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBAT: *const fn (
            self: *const IDvbSiParser,
            pw_bouquet_id: ?*u16,
            pp_b_a_t: ?*?*IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRST: *const fn (
            self: *const IDvbSiParser,
            dw_timeout: u32,
            pp_r_s_t: ?*?*IDVB_RST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetST: *const fn (
            self: *const IDvbSiParser,
            pid: u16,
            dw_timeout: u32,
            pp_s_t: ?*?*IDVB_ST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTDT: *const fn (
            self: *const IDvbSiParser,
            pp_t_d_t: ?*?*IDVB_TDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTOT: *const fn (
            self: *const IDvbSiParser,
            pp_t_o_t: ?*?*IDVB_TOT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDIT: *const fn (
            self: *const IDvbSiParser,
            dw_timeout: u32,
            pp_d_i_t: ?*?*IDVB_DIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSIT: *const fn (
            self: *const IDvbSiParser,
            dw_timeout: u32,
            pp_s_i_t: ?*?*IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, punk_mpeg2_data_: ?*IUnknown) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDvbSiParser, @ptrCast(self)), punk_mpeg2_data_);
            }
            pub inline fn getPAT(self: *const T, pp_p_a_t_: ?*?*IPAT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetPAT(@as(*const IDvbSiParser, @ptrCast(self)), pp_p_a_t_);
            }
            pub inline fn getCAT(self: *const T, dw_timeout_: u32, pp_c_a_t_: ?*?*ICAT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetCAT(@as(*const IDvbSiParser, @ptrCast(self)), dw_timeout_, pp_c_a_t_);
            }
            pub inline fn getPMT(self: *const T, pid_: u16, pw_program_number_: ?*u16, pp_p_m_t_: ?*?*IPMT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetPMT(@as(*const IDvbSiParser, @ptrCast(self)), pid_, pw_program_number_, pp_p_m_t_);
            }
            pub inline fn getTSDT(self: *const T, pp_t_s_d_t_: ?*?*ITSDT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTSDT(@as(*const IDvbSiParser, @ptrCast(self)), pp_t_s_d_t_);
            }
            pub inline fn getNIT(self: *const T, table_id_: u8, pw_network_id_: ?*u16, pp_n_i_t_: ?*?*IDVB_NIT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetNIT(@as(*const IDvbSiParser, @ptrCast(self)), table_id_, pw_network_id_, pp_n_i_t_);
            }
            pub inline fn getSDT(self: *const T, table_id_: u8, pw_transport_stream_id_: ?*u16, pp_s_d_t_: ?*?*IDVB_SDT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetSDT(@as(*const IDvbSiParser, @ptrCast(self)), table_id_, pw_transport_stream_id_, pp_s_d_t_);
            }
            pub inline fn getEIT(self: *const T, table_id_: u8, pw_service_id_: ?*u16, pp_e_i_t_: ?*?*IDVB_EIT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IDvbSiParser, @ptrCast(self)), table_id_, pw_service_id_, pp_e_i_t_);
            }
            pub inline fn getBAT(self: *const T, pw_bouquet_id_: ?*u16, pp_b_a_t_: ?*?*IDVB_BAT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetBAT(@as(*const IDvbSiParser, @ptrCast(self)), pw_bouquet_id_, pp_b_a_t_);
            }
            pub inline fn getRST(self: *const T, dw_timeout_: u32, pp_r_s_t_: ?*?*IDVB_RST) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetRST(@as(*const IDvbSiParser, @ptrCast(self)), dw_timeout_, pp_r_s_t_);
            }
            pub inline fn getST(self: *const T, pid_: u16, dw_timeout_: u32, pp_s_t_: ?*?*IDVB_ST) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetST(@as(*const IDvbSiParser, @ptrCast(self)), pid_, dw_timeout_, pp_s_t_);
            }
            pub inline fn getTDT(self: *const T, pp_t_d_t_: ?*?*IDVB_TDT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTDT(@as(*const IDvbSiParser, @ptrCast(self)), pp_t_d_t_);
            }
            pub inline fn getTOT(self: *const T, pp_t_o_t_: ?*?*IDVB_TOT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTOT(@as(*const IDvbSiParser, @ptrCast(self)), pp_t_o_t_);
            }
            pub inline fn getDIT(self: *const T, dw_timeout_: u32, pp_d_i_t_: ?*?*IDVB_DIT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetDIT(@as(*const IDvbSiParser, @ptrCast(self)), dw_timeout_, pp_d_i_t_);
            }
            pub inline fn getSIT(self: *const T, dw_timeout_: u32, pp_s_i_t_: ?*?*IDVB_SIT) HRESULT {
                return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetSIT(@as(*const IDvbSiParser, @ptrCast(self)), dw_timeout_, pp_s_i_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSiParser2_Value = Guid.initString("0ac5525f-f816-42f4-93ba-4c0f32f46e54");
pub const IID_IDvbSiParser2 = &IID_IDvbSiParser2_Value;
pub const IDvbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser.VTable,
        GetEIT2: *const fn (
            self: *const IDvbSiParser2,
            table_id: u8,
            pw_service_id: ?*u16,
            pb_segment: ?*u8,
            pp_e_i_t: ?*?*IDVB_EIT2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbSiParser.MethodMixin(T);
            pub inline fn getEIT2(self: *const T, table_id_: u8, pw_service_id_: ?*u16, pb_segment_: ?*u8, pp_e_i_t_: ?*?*IDVB_EIT2) HRESULT {
                return @as(*const IDvbSiParser2.VTable, @ptrCast(self.vtable)).GetEIT2(@as(*const IDvbSiParser2, @ptrCast(self)), table_id_, pw_service_id_, pb_segment_, pp_e_i_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IIsdbSiParser2_Value = Guid.initString("900e4bb7-18cd-453f-98be-3be6aa211772");
pub const IID_IIsdbSiParser2 = &IID_IIsdbSiParser2_Value;
pub const IIsdbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser2.VTable,
        GetSDT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            pw_transport_stream_id: ?*u16,
            pp_s_d_t: ?*?*IISDB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBIT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            pw_original_network_id: ?*u16,
            pp_b_i_t: ?*?*IISDB_BIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNBIT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            pw_original_network_id: ?*u16,
            pp_n_b_i_t: ?*?*IISDB_NBIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLDT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            pw_original_service_id: ?*u16,
            pp_l_d_t: ?*?*IISDB_LDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSDTT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            pw_table_id_ext: ?*u16,
            pp_s_d_t_t: ?*?*IISDB_SDTT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCDT: *const fn (
            self: *const IIsdbSiParser2,
            table_id: u8,
            b_section_number: u8,
            pw_download_data_id: ?*u16,
            pp_c_d_t: ?*?*IISDB_CDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMM: *const fn (
            self: *const IIsdbSiParser2,
            pid: u16,
            w_table_id_ext: u16,
            pp_e_m_m: ?*?*IISDB_EMM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbSiParser2.MethodMixin(T);
            pub inline fn getSDT(self: *const T, table_id_: u8, pw_transport_stream_id_: ?*u16, pp_s_d_t_: ?*?*IISDB_SDT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetSDT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, pw_transport_stream_id_, pp_s_d_t_);
            }
            pub inline fn getBIT(self: *const T, table_id_: u8, pw_original_network_id_: ?*u16, pp_b_i_t_: ?*?*IISDB_BIT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetBIT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, pw_original_network_id_, pp_b_i_t_);
            }
            pub inline fn getNBIT(self: *const T, table_id_: u8, pw_original_network_id_: ?*u16, pp_n_b_i_t_: ?*?*IISDB_NBIT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetNBIT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, pw_original_network_id_, pp_n_b_i_t_);
            }
            pub inline fn getLDT(self: *const T, table_id_: u8, pw_original_service_id_: ?*u16, pp_l_d_t_: ?*?*IISDB_LDT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetLDT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, pw_original_service_id_, pp_l_d_t_);
            }
            pub inline fn getSDTT(self: *const T, table_id_: u8, pw_table_id_ext_: ?*u16, pp_s_d_t_t_: ?*?*IISDB_SDTT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetSDTT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, pw_table_id_ext_, pp_s_d_t_t_);
            }
            pub inline fn getCDT(self: *const T, table_id_: u8, b_section_number_: u8, pw_download_data_id_: ?*u16, pp_c_d_t_: ?*?*IISDB_CDT) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetCDT(@as(*const IIsdbSiParser2, @ptrCast(self)), table_id_, b_section_number_, pw_download_data_id_, pp_c_d_t_);
            }
            pub inline fn getEMM(self: *const T, pid_: u16, w_table_id_ext_: u16, pp_e_m_m_: ?*?*IISDB_EMM) HRESULT {
                return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetEMM(@as(*const IIsdbSiParser2, @ptrCast(self)), pid_, w_table_id_ext_, pp_e_m_m_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_NIT_Value = Guid.initString("c64935f4-29e4-4e22-911a-63f7f55cb097");
pub const IID_IDVB_NIT = &IID_IDVB_NIT_Value;
pub const IDVB_NIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_NIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IDVB_NIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkId: *const fn (
            self: *const IDVB_NIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IDVB_NIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IDVB_NIT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IDVB_NIT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_NIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: *const fn (
            self: *const IDVB_NIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: *const fn (
            self: *const IDVB_NIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IDVB_NIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IDVB_NIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IDVB_NIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IDVB_NIT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IDVB_NIT,
            pp_n_i_t: ?*?*IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IDVB_NIT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IDVB_NIT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_NIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_NIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetNetworkId(@as(*const IDVB_NIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_NIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_NIT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_NIT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_NIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordTransportStreamId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_NIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordOriginalNetworkId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_NIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_NIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_NIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_NIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_NIT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_n_i_t_: ?*?*IDVB_NIT) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_NIT, @ptrCast(self)), pp_n_i_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_NIT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_NIT, @ptrCast(self)));
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_NIT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SDT_Value = Guid.initString("02cad8d3-fe43-48e2-90bd-450ed9a8a5fd");
pub const IID_IDVB_SDT = &IID_IDVB_SDT_Value;
pub const IDVB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_SDT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IDVB_SDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IDVB_SDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IDVB_SDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_SDT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEITScheduleFlag: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEITPresentFollowingFlag: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFreeCAMode: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IDVB_SDT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IDVB_SDT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IDVB_SDT,
            pp_s_d_t: ?*?*IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IDVB_SDT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IDVB_SDT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_SDT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_SDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IDVB_SDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IDVB_SDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_SDT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordEITScheduleFlag(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITScheduleFlag(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordEITPresentFollowingFlag(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITPresentFollowingFlag(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordRunningStatus(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordFreeCAMode(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordFreeCAMode(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_SDT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_SDT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_s_d_t_: ?*?*IDVB_SDT) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_SDT, @ptrCast(self)), pp_s_d_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_SDT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_SDT, @ptrCast(self)));
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_SDT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDT_Value = Guid.initString("3f3dc9a2-bb32-4fb9-ae9e-d856848927a3");
pub const IID_IISDB_SDT = &IID_IISDB_SDT_Value;
pub const IISDB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IDVB_SDT.VTable,
        GetRecordEITUserDefinedFlags: *const fn (
            self: *const IISDB_SDT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVB_SDT.MethodMixin(T);
            pub inline fn getRecordEITUserDefinedFlags(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITUserDefinedFlags(@as(*const IISDB_SDT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_EIT_Value = Guid.initString("442db029-02cb-4495-8b92-1c13375bce99");
pub const IID_IDVB_EIT = &IID_IDVB_EIT_Value;
pub const IDVB_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_EIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IDVB_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: *const fn (
            self: *const IDVB_EIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IDVB_EIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IDVB_EIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSegmentLastSectionNumber: *const fn (
            self: *const IDVB_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastTableId: *const fn (
            self: *const IDVB_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_EIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pmd_val: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFreeCAMode: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IDVB_EIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IDVB_EIT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IDVB_EIT,
            pp_e_i_t: ?*?*IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IDVB_EIT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IDVB_EIT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_EIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getServiceId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IDVB_EIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IDVB_EIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IDVB_EIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getSegmentLastSectionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetSegmentLastSectionNumber(@as(*const IDVB_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLastTableId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetLastTableId(@as(*const IDVB_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_EIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordEventId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordStartTime(self: *const T, dw_record_index_: u32, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pmdt_val_);
            }
            pub inline fn getRecordDuration(self: *const T, dw_record_index_: u32, pmd_val_: ?*MPEG_TIME) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pmd_val_);
            }
            pub inline fn getRecordRunningStatus(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordFreeCAMode(self: *const T, dw_record_index_: u32, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordFreeCAMode(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pf_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_EIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_EIT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_e_i_t_: ?*?*IDVB_EIT) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_EIT, @ptrCast(self)), pp_e_i_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_EIT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_EIT, @ptrCast(self)));
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_EIT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVB_EIT2_Value = Guid.initString("61a389e0-9b9e-4ba0-aeea-5ddd159820ea");
pub const IID_IDVB_EIT2 = &IID_IDVB_EIT2_Value;
pub const IDVB_EIT2 = extern struct {
    pub const VTable = extern struct {
        base: IDVB_EIT.VTable,
        GetSegmentInfo: *const fn (
            self: *const IDVB_EIT2,
            pb_tid: ?*u8,
            pb_segment: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSection: *const fn (
            self: *const IDVB_EIT2,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDVB_EIT.MethodMixin(T);
            pub inline fn getSegmentInfo(self: *const T, pb_tid_: ?*u8, pb_segment_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT2.VTable, @ptrCast(self.vtable)).GetSegmentInfo(@as(*const IDVB_EIT2, @ptrCast(self)), pb_tid_, pb_segment_);
            }
            pub inline fn getRecordSection(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_EIT2.VTable, @ptrCast(self.vtable)).GetRecordSection(@as(*const IDVB_EIT2, @ptrCast(self)), dw_record_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_BAT_Value = Guid.initString("ece9bb0c-43b6-4558-a0ec-1812c34cd6ca");
pub const IID_IDVB_BAT = &IID_IDVB_BAT_Value;
pub const IDVB_BAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_BAT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IDVB_BAT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBouquetId: *const fn (
            self: *const IDVB_BAT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IDVB_BAT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IDVB_BAT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IDVB_BAT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_BAT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: *const fn (
            self: *const IDVB_BAT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: *const fn (
            self: *const IDVB_BAT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IDVB_BAT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IDVB_BAT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IDVB_BAT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IDVB_BAT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IDVB_BAT,
            pp_b_a_t: ?*?*IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IDVB_BAT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_BAT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_BAT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getBouquetId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetBouquetId(@as(*const IDVB_BAT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_BAT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_BAT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_BAT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_BAT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordTransportStreamId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_BAT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordOriginalNetworkId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_BAT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_BAT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_BAT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_BAT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_BAT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, pp_b_a_t_: ?*?*IDVB_BAT) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_BAT, @ptrCast(self)), pp_b_a_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_BAT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_BAT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_RST_Value = Guid.initString("f47dcd04-1e23-4fb7-9f96-b40eead10b2b");
pub const IID_IDVB_RST = &IID_IDVB_RST_Value;
pub const IDVB_RST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_RST,
            p_section_list: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_RST,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: *const fn (
            self: *const IDVB_RST,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: *const fn (
            self: *const IDVB_RST,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDVB_RST,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: *const fn (
            self: *const IDVB_RST,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: *const fn (
            self: *const IDVB_RST,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_RST, @ptrCast(self)), p_section_list_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_RST, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordTransportStreamId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_RST, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordOriginalNetworkId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_RST, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_RST, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordEventId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IDVB_RST, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordRunningStatus(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_RST, @ptrCast(self)), dw_record_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_ST_Value = Guid.initString("4d5b9f23-2a02-45de-bcda-5d5dbfbfbe62");
pub const IID_IDVB_ST = &IID_IDVB_ST_Value;
pub const IDVB_ST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_ST,
            p_section_list: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataLength: *const fn (
            self: *const IDVB_ST,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const IDVB_ST,
            pp_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList) HRESULT {
                return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_ST, @ptrCast(self)), p_section_list_);
            }
            pub inline fn getDataLength(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).GetDataLength(@as(*const IDVB_ST, @ptrCast(self)), pw_val_);
            }
            pub inline fn getData(self: *const T, pp_data_: ?*?*u8) HRESULT {
                return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).GetData(@as(*const IDVB_ST, @ptrCast(self)), pp_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TDT_Value = Guid.initString("0780dc7d-d55c-4aef-97e6-6b75906e2796");
pub const IID_IDVB_TDT = &IID_IDVB_TDT_Value;
pub const IDVB_TDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_TDT,
            p_section_list: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUTCTime: *const fn (
            self: *const IDVB_TDT,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList) HRESULT {
                return @as(*const IDVB_TDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_TDT, @ptrCast(self)), p_section_list_);
            }
            pub inline fn getUTCTime(self: *const T, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IDVB_TDT.VTable, @ptrCast(self.vtable)).GetUTCTime(@as(*const IDVB_TDT, @ptrCast(self)), pmdt_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TOT_Value = Guid.initString("83295d6a-faba-4ee1-9b15-8067696910ae");
pub const IID_IDVB_TOT = &IID_IDVB_TOT_Value;
pub const IDVB_TOT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_TOT,
            p_section_list: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUTCTime: *const fn (
            self: *const IDVB_TOT,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IDVB_TOT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IDVB_TOT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IDVB_TOT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList) HRESULT {
                return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_TOT, @ptrCast(self)), p_section_list_);
            }
            pub inline fn getUTCTime(self: *const T, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetUTCTime(@as(*const IDVB_TOT, @ptrCast(self)), pmdt_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_TOT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_TOT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_TOT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_DIT_Value = Guid.initString("91bffdf9-9432-410f-86ef-1c228ed0ad70");
pub const IID_IDVB_DIT = &IID_IDVB_DIT_Value;
pub const IDVB_DIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_DIT,
            p_section_list: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransitionFlag: *const fn (
            self: *const IDVB_DIT,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList) HRESULT {
                return @as(*const IDVB_DIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_DIT, @ptrCast(self)), p_section_list_);
            }
            pub inline fn getTransitionFlag(self: *const T, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDVB_DIT.VTable, @ptrCast(self.vtable)).GetTransitionFlag(@as(*const IDVB_DIT, @ptrCast(self)), pf_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SIT_Value = Guid.initString("68cdce53-8bea-45c2-9d9d-acf575a089b5");
pub const IID_IDVB_SIT = &IID_IDVB_SIT_Value;
pub const IDVB_SIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IDVB_SIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IDVB_SIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IDVB_SIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IDVB_SIT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IDVB_SIT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDVB_SIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDVB_SIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: *const fn (
            self: *const IDVB_SIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IDVB_SIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IDVB_SIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IDVB_SIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: *const fn (
            self: *const IDVB_SIT,
            h_next_table_available: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: *const fn (
            self: *const IDVB_SIT,
            dw_timeout: u32,
            pp_s_i_t: ?*?*IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: *const fn (
            self: *const IDVB_SIT,
            h_next_table_is_current: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: *const fn (
            self: *const IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_SIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_SIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_SIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_SIT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_SIT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_SIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_SIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordRunningStatus(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_SIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_SIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_SIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_SIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn registerForNextTable(self: *const T, h_next_table_available_: ?HANDLE) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_SIT, @ptrCast(self)), h_next_table_available_);
            }
            pub inline fn getNextTable(self: *const T, dw_timeout_: u32, pp_s_i_t_: ?*?*IDVB_SIT) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_SIT, @ptrCast(self)), dw_timeout_, pp_s_i_t_);
            }
            pub inline fn registerForWhenCurrent(self: *const T, h_next_table_is_current_: ?HANDLE) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_SIT, @ptrCast(self)), h_next_table_is_current_);
            }
            pub inline fn convertNextToCurrent(self: *const T) HRESULT {
                return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_SIT, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_BIT_Value = Guid.initString("537cd71e-0e46-4173-9001-ba043f3e49e2");
pub const IID_IISDB_BIT = &IID_IISDB_BIT_Value;
pub const IISDB_BIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_BIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_BIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IISDB_BIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBroadcastViewPropriety: *const fn (
            self: *const IISDB_BIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IISDB_BIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IISDB_BIT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IISDB_BIT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IISDB_BIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordBroadcasterId: *const fn (
            self: *const IISDB_BIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IISDB_BIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IISDB_BIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IISDB_BIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_BIT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_BIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_BIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_BIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getBroadcastViewPropriety(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetBroadcastViewPropriety(@as(*const IISDB_BIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IISDB_BIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IISDB_BIT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IISDB_BIT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_BIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordBroadcasterId(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordBroadcasterId(@as(*const IISDB_BIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_BIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_BIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_BIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_BIT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_NBIT_Value = Guid.initString("1b1863ef-08f1-40b7-a559-3b1eff8cafa6");
pub const IID_IISDB_NBIT = &IID_IISDB_NBIT_Value;
pub const IISDB_NBIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_NBIT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_NBIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IISDB_NBIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IISDB_NBIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordInformationId: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordInformationType: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptionBodyLocation: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMessageSectionNumber: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordUserDefined: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfKeys: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordKeys: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pb_keys: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IISDB_NBIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_NBIT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_NBIT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_NBIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_NBIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_NBIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordInformationId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordInformationId(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordInformationType(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordInformationType(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordDescriptionBodyLocation(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptionBodyLocation(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordMessageSectionNumber(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordMessageSectionNumber(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordUserDefined(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordUserDefined(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordNumberOfKeys(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordNumberOfKeys(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordKeys(self: *const T, dw_record_index_: u32, pb_keys_: ?*?*u8) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordKeys(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pb_keys_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_NBIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_NBIT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_LDT_Value = Guid.initString("141a546b-02ff-4fb9-a3a3-2f074b74a9a9");
pub const IID_IISDB_LDT = &IID_IISDB_LDT_Value;
pub const IISDB_LDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_LDT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_LDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalServiceId: *const fn (
            self: *const IISDB_LDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IISDB_LDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IISDB_LDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IISDB_LDT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptionId: *const fn (
            self: *const IISDB_LDT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IISDB_LDT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IISDB_LDT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IISDB_LDT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_LDT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_LDT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_LDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getOriginalServiceId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetOriginalServiceId(@as(*const IISDB_LDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IISDB_LDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_LDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_LDT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordDescriptionId(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptionId(@as(*const IISDB_LDT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_LDT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_LDT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_LDT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_LDT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDTT_Value = Guid.initString("ee60ef2d-813a-4dc7-bf92-ea13dac85313");
pub const IID_IISDB_SDTT = &IID_IISDB_SDTT_Value;
pub const IISDB_SDTT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_SDTT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_SDTT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdExt: *const fn (
            self: *const IISDB_SDTT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: *const fn (
            self: *const IISDB_SDTT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IISDB_SDTT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: *const fn (
            self: *const IISDB_SDTT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IISDB_SDTT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordGroup: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTargetVersion: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNewVersion: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDownloadLevel: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVersionIndicator: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordScheduleTimeShiftInformation: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfSchedules: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTimeByIndex: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            dw_index: u32,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDurationByIndex: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            dw_index: u32,
            pmd_val: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IISDB_SDTT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_SDTT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_SDTT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_SDTT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTableIdExt(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetTableIdExt(@as(*const IISDB_SDTT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getTransportStreamId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IISDB_SDTT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_SDTT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getServiceId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IISDB_SDTT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_SDTT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordGroup(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordGroup(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordTargetVersion(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordTargetVersion(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordNewVersion(self: *const T, dw_record_index_: u32, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordNewVersion(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pw_val_);
            }
            pub inline fn getRecordDownloadLevel(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDownloadLevel(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordVersionIndicator(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordVersionIndicator(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordScheduleTimeShiftInformation(self: *const T, dw_record_index_: u32, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordScheduleTimeShiftInformation(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pb_val_);
            }
            pub inline fn getRecordCountOfSchedules(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordCountOfSchedules(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordStartTimeByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordStartTimeByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, dw_index_, pmdt_val_);
            }
            pub inline fn getRecordDurationByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pmd_val_: ?*MPEG_TIME) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDurationByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, dw_index_, pmd_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_SDTT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_SDTT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_CDT_Value = Guid.initString("25fa92c2-8b80-4787-a841-3a0e8f17984b");
pub const IID_IISDB_CDT = &IID_IISDB_CDT_Value;
pub const IISDB_CDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_CDT,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
            b_section_number: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_CDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadDataId: *const fn (
            self: *const IISDB_CDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSectionNumber: *const fn (
            self: *const IISDB_CDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: *const fn (
            self: *const IISDB_CDT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataType: *const fn (
            self: *const IISDB_CDT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: *const fn (
            self: *const IISDB_CDT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: *const fn (
            self: *const IISDB_CDT,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: *const fn (
            self: *const IISDB_CDT,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeOfDataModule: *const fn (
            self: *const IISDB_CDT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataModule: *const fn (
            self: *const IISDB_CDT,
            pb_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_CDT,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data, b_section_number_: u8) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_CDT, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_, b_section_number_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_CDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDownloadDataId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDownloadDataId(@as(*const IISDB_CDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getSectionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetSectionNumber(@as(*const IISDB_CDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getOriginalNetworkId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_CDT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDataType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDataType(@as(*const IISDB_CDT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfTableDescriptors(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IISDB_CDT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTableDescriptorByIndex(self: *const T, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IISDB_CDT, @ptrCast(self)), dw_index_, pp_descriptor_);
            }
            pub inline fn getTableDescriptorByTag(self: *const T, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IISDB_CDT, @ptrCast(self)), b_tag_, pdw_cookie_, pp_descriptor_);
            }
            pub inline fn getSizeOfDataModule(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetSizeOfDataModule(@as(*const IISDB_CDT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getDataModule(self: *const T, pb_data_: ?*?*u8) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDataModule(@as(*const IISDB_CDT, @ptrCast(self)), pb_data_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_CDT, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_EMM_Value = Guid.initString("0edb556d-43ad-4938-9668-321b2ffecfd3");
pub const IID_IISDB_EMM = &IID_IISDB_EMM_Value;
pub const IISDB_EMM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IISDB_EMM,
            p_section_list: ?*ISectionList,
            p_m_p_e_g_data: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IISDB_EMM,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdExtension: *const fn (
            self: *const IISDB_EMM,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBytes: *const fn (
            self: *const IISDB_EMM,
            pw_buffer_length: ?*u16,
            pb_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSharedEmmMessage: *const fn (
            self: *const IISDB_EMM,
            pw_length: ?*u16,
            ppb_message: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndividualEmmMessage: *const fn (
            self: *const IISDB_EMM,
            p_unknown: ?*IUnknown,
            pw_length: ?*u16,
            ppb_message: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: *const fn (
            self: *const IISDB_EMM,
            pdw_version_hash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, p_section_list_: ?*ISectionList, p_m_p_e_g_data_: ?*IMpeg2Data) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_EMM, @ptrCast(self)), p_section_list_, p_m_p_e_g_data_);
            }
            pub inline fn getVersionNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_EMM, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTableIdExtension(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetTableIdExtension(@as(*const IISDB_EMM, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDataBytes(self: *const T, pw_buffer_length_: ?*u16, pb_buffer_: ?*u8) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetDataBytes(@as(*const IISDB_EMM, @ptrCast(self)), pw_buffer_length_, pb_buffer_);
            }
            pub inline fn getSharedEmmMessage(self: *const T, pw_length_: ?*u16, ppb_message_: ?*?*u8) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetSharedEmmMessage(@as(*const IISDB_EMM, @ptrCast(self)), pw_length_, ppb_message_);
            }
            pub inline fn getIndividualEmmMessage(self: *const T, p_unknown_: ?*IUnknown, pw_length_: ?*u16, ppb_message_: ?*?*u8) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetIndividualEmmMessage(@as(*const IISDB_EMM, @ptrCast(self)), p_unknown_, pw_length_, ppb_message_);
            }
            pub inline fn getVersionHash(self: *const T, pdw_version_hash_: ?*u32) HRESULT {
                return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_EMM, @ptrCast(self)), pdw_version_hash_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceAttributeDescriptor_Value = Guid.initString("0f37bd92-d6a1-4854-b950-3a969d27f30e");
pub const IID_IDvbServiceAttributeDescriptor = &IID_IDvbServiceAttributeDescriptor_Value;
pub const IDvbServiceAttributeDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumericSelectionFlag: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            b_record_index: u8,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVisibleServiceFlag: *const fn (
            self: *const IDvbServiceAttributeDescriptor,
            b_record_index: u8,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
            pub inline fn getRecordNumericSelectionFlag(self: *const T, b_record_index_: u8, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumericSelectionFlag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), b_record_index_, pf_val_);
            }
            pub inline fn getRecordVisibleServiceFlag(self: *const T, b_record_index_: u8, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordVisibleServiceFlag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), b_record_index_, pf_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CRID_LOCATION = enum(i32) {
    IN_DESCRIPTOR = 0,
    IN_CIT = 1,
    DVB_RESERVED1 = 2,
    DVB_RESERVED2 = 3,
};
pub const CRID_LOCATION_IN_DESCRIPTOR = CRID_LOCATION.IN_DESCRIPTOR;
pub const CRID_LOCATION_IN_CIT = CRID_LOCATION.IN_CIT;
pub const CRID_LOCATION_DVB_RESERVED1 = CRID_LOCATION.DVB_RESERVED1;
pub const CRID_LOCATION_DVB_RESERVED2 = CRID_LOCATION.DVB_RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentIdentifierDescriptor_Value = Guid.initString("05e0c1ea-f661-4053-9fbf-d93b28359838");
pub const IID_IDvbContentIdentifierDescriptor = &IID_IDvbContentIdentifierDescriptor_Value;
pub const IDvbContentIdentifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbContentIdentifierDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbContentIdentifierDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbContentIdentifierDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCrid: *const fn (
            self: *const IDvbContentIdentifierDescriptor,
            b_record_index: u8,
            pb_type: ?*u8,
            pb_location: ?*u8,
            pb_length: ?*u8,
            ppb_bytes: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordCrid(self: *const T, b_record_index_: u8, pb_type_: ?*u8, pb_location_: ?*u8, pb_length_: ?*u8, ppb_bytes_: [*]?*u8) HRESULT {
                return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCrid(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), b_record_index_, pb_type_, pb_location_, pb_length_, ppb_bytes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDefaultAuthorityDescriptor_Value = Guid.initString("05ec24d1-3a31-44e7-b408-67c60a352276");
pub const IID_IDvbDefaultAuthorityDescriptor = &IID_IDvbDefaultAuthorityDescriptor_Value;
pub const IDvbDefaultAuthorityDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbDefaultAuthorityDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbDefaultAuthorityDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAuthority: *const fn (
            self: *const IDvbDefaultAuthorityDescriptor,
            pb_length: ?*u8,
            ppb_bytes: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDefaultAuthority(self: *const T, pb_length_: ?*u8, ppb_bytes_: [*]?*u8) HRESULT {
                return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetDefaultAuthority(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pb_length_, ppb_bytes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbSatelliteDeliverySystemDescriptor_Value = Guid.initString("02f2225a-805b-4ec5-a9a6-f9b5913cd470");
pub const IID_IDvbSatelliteDeliverySystemDescriptor = &IID_IDvbSatelliteDeliverySystemDescriptor_Value;
pub const IDvbSatelliteDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequency: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOrbitalPosition: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWestEastFlag: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolarization: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModulation: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolRate: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECInner: *const fn (
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getFrequency(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getOrbitalPosition(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOrbitalPosition(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getWestEastFlag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetWestEastFlag(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getPolarization(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetPolarization(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getModulation(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetModulation(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSymbolRate(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetSymbolRate(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getFECInner(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECInner(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbCableDeliverySystemDescriptor_Value = Guid.initString("dfb98e36-9e1a-4862-9946-993a4e59017b");
pub const IID_IDvbCableDeliverySystemDescriptor = &IID_IDvbCableDeliverySystemDescriptor_Value;
pub const IDvbCableDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequency: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECOuter: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModulation: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolRate: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECInner: *const fn (
            self: *const IDvbCableDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getFrequency(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getFECOuter(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECOuter(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getModulation(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetModulation(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSymbolRate(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetSymbolRate(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getFECInner(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECInner(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrialDeliverySystemDescriptor_Value = Guid.initString("ed7e1b91-d12e-420c-b41d-a49d84fe1823");
pub const IID_IDvbTerrestrialDeliverySystemDescriptor = &IID_IDvbTerrestrialDeliverySystemDescriptor_Value;
pub const IDvbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCentreFrequency: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidth: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstellation: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHierarchyInformation: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeRateHPStream: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeRateLPStream: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherFrequencyFlag: *const fn (
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCentreFrequency(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCentreFrequency(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getBandwidth(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetBandwidth(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getConstellation(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetConstellation(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getHierarchyInformation(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetHierarchyInformation(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCodeRateHPStream(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCodeRateHPStream(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCodeRateLPStream(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCodeRateLPStream(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getGuardInterval(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTransmissionMode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getOtherFrequencyFlag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOtherFrequencyFlag(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrial2DeliverySystemDescriptor_Value = Guid.initString("20ee9be9-cd57-49ab-8f6e-1d07aeb8e482");
pub const IID_IDvbTerrestrial2DeliverySystemDescriptor = &IID_IDvbTerrestrial2DeliverySystemDescriptor_Value;
pub const IDvbTerrestrial2DeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTagExtension: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCentreFrequency: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPLPId: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetT2SystemId: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMultipleInputMode: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidth: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellId: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherFrequencyFlag: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTFSFlag: *const fn (
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTagExtension(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTagExtension(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCentreFrequency(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCentreFrequency(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getPLPId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetPLPId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getT2SystemId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetT2SystemId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getMultipleInputMode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetMultipleInputMode(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getBandwidth(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetBandwidth(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getGuardInterval(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTransmissionMode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCellId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCellId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getOtherFrequencyFlag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOtherFrequencyFlag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTFSFlag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTFSFlag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbFrequencyListDescriptor_Value = Guid.initString("1cadb613-e1dd-4512-afa8-bb7a007ef8b1");
pub const IID_IDvbFrequencyListDescriptor = &IID_IDvbFrequencyListDescriptor_Value;
pub const IDvbFrequencyListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbFrequencyListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbFrequencyListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodingType: *const fn (
            self: *const IDvbFrequencyListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbFrequencyListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCentreFrequency: *const fn (
            self: *const IDvbFrequencyListDescriptor,
            b_record_index: u8,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCodingType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetCodingType(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordCentreFrequency(self: *const T, b_record_index_: u8, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCentreFrequency(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), b_record_index_, pdw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbPrivateDataSpecifierDescriptor_Value = Guid.initString("5660a019-e75a-4b82-9b4c-ed2256d165a2");
pub const IID_IDvbPrivateDataSpecifierDescriptor = &IID_IDvbPrivateDataSpecifierDescriptor_Value;
pub const IDvbPrivateDataSpecifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataSpecifier: *const fn (
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getPrivateDataSpecifier(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataSpecifier(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pdw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbLogicalChannelDescriptor_Value = Guid.initString("cf1edaff-3ffd-4cf7-8201-35756acbf85f");
pub const IID_IDvbLogicalChannelDescriptor = &IID_IDvbLogicalChannelDescriptor_Value;
pub const IDvbLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbLogicalChannelDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbLogicalChannelDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbLogicalChannelDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDvbLogicalChannelDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLogicalChannelNumber: *const fn (
            self: *const IDvbLogicalChannelDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
            pub inline fn getRecordLogicalChannelNumber(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLogicalChannelNumber(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannelDescriptor2_Value = Guid.initString("43aca974-4be8-4b98-bc17-9eafd788b1d7");
pub const IID_IDvbLogicalChannelDescriptor2 = &IID_IDvbLogicalChannelDescriptor2_Value;
pub const IDvbLogicalChannelDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor.VTable,
        GetRecordLogicalChannelAndVisibility: *const fn (
            self: *const IDvbLogicalChannelDescriptor2,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbLogicalChannelDescriptor.MethodMixin(T);
            pub inline fn getRecordLogicalChannelAndVisibility(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannelDescriptor2.VTable, @ptrCast(self.vtable)).GetRecordLogicalChannelAndVisibility(@as(*const IDvbLogicalChannelDescriptor2, @ptrCast(self)), b_record_index_, pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannel2Descriptor_Value = Guid.initString("f69c3747-8a30-4980-998c-01fe7f0ba35a");
pub const IID_IDvbLogicalChannel2Descriptor = &IID_IDvbLogicalChannel2Descriptor_Value;
pub const IDvbLogicalChannel2Descriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
        GetCountOfLists: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListId: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListNameW: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListCountryCode: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListCountOfRecords: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_channel_list_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordServiceId: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordLogicalChannelNumber: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordLogicalChannelAndVisibility: *const fn (
            self: *const IDvbLogicalChannel2Descriptor,
            b_list_index: u8,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
            pub inline fn getCountOfLists(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetCountOfLists(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getListId(self: *const T, b_list_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListId(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, pb_val_);
            }
            pub inline fn getListNameW(self: *const T, b_list_index_: u8, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListNameW(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, conv_mode_, pbstr_name_);
            }
            pub inline fn getListCountryCode(self: *const T, b_list_index_: u8, psz_code_: *[4]u8) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListCountryCode(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, psz_code_);
            }
            pub inline fn getListCountOfRecords(self: *const T, b_channel_list_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListCountOfRecords(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_channel_list_index_, pb_val_);
            }
            pub inline fn getListRecordServiceId(self: *const T, b_list_index_: u8, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordServiceId(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, b_record_index_, pw_val_);
            }
            pub inline fn getListRecordLogicalChannelNumber(self: *const T, b_list_index_: u8, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordLogicalChannelNumber(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, b_record_index_, pw_val_);
            }
            pub inline fn getListRecordLogicalChannelAndVisibility(self: *const T, b_list_index_: u8, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordLogicalChannelAndVisibility(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), b_list_index_, b_record_index_, pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbHDSimulcastLogicalChannelDescriptor_Value = Guid.initString("1ea8b738-a307-4680-9e26-d0a908c824f4");
pub const IID_IDvbHDSimulcastLogicalChannelDescriptor = &IID_IDvbHDSimulcastLogicalChannelDescriptor_Value;
pub const IDvbHDSimulcastLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastIDDescriptor_Value = Guid.initString("5f26f518-65c8-4048-91f2-9290f59f7b90");
pub const IID_IDvbDataBroadcastIDDescriptor = &IID_IDvbDataBroadcastIDDescriptor_Value;
pub const IDvbDataBroadcastIDDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbDataBroadcastIDDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbDataBroadcastIDDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBroadcastID: *const fn (
            self: *const IDvbDataBroadcastIDDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDSelectorBytes: *const fn (
            self: *const IDvbDataBroadcastIDDescriptor,
            pb_len: ?*u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDataBroadcastID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetDataBroadcastID(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getIDSelectorBytes(self: *const T, pb_len_: ?*u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetIDSelectorBytes(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pb_len_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastDescriptor_Value = Guid.initString("d1ebc1d6-8b60-4c20-9caf-e59382e7c400");
pub const IID_IDvbDataBroadcastDescriptor = &IID_IDvbDataBroadcastDescriptor_Value;
pub const IDvbDataBroadcastDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBroadcastID: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorLength: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorBytes: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_len: ?*u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangID: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pul_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextLength: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: *const fn (
            self: *const IDvbDataBroadcastDescriptor,
            pb_len: ?*u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDataBroadcastID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetDataBroadcastID(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getComponentTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSelectorLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSelectorBytes(self: *const T, pb_len_: ?*u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorBytes(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_len_, pb_val_);
            }
            pub inline fn getLangID(self: *const T, pul_val_: ?*u32) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetLangID(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pul_val_);
            }
            pub inline fn getTextLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetTextLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getText(self: *const T, pb_len_: ?*u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetText(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pb_len_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DESC_LINKAGE_TYPE = enum(i32) {
    RESERVED0 = 0,
    INFORMATION = 1,
    EPG = 2,
    CA_REPLACEMENT = 3,
    COMPLETE_NET_BOUQUET_SI = 4,
    REPLACEMENT = 5,
    DATA = 6,
    RESERVED1 = 7,
    USER = 8,
    RESERVED2 = 255,
};
pub const DESC_LINKAGE_RESERVED0 = DESC_LINKAGE_TYPE.RESERVED0;
pub const DESC_LINKAGE_INFORMATION = DESC_LINKAGE_TYPE.INFORMATION;
pub const DESC_LINKAGE_EPG = DESC_LINKAGE_TYPE.EPG;
pub const DESC_LINKAGE_CA_REPLACEMENT = DESC_LINKAGE_TYPE.CA_REPLACEMENT;
pub const DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI = DESC_LINKAGE_TYPE.COMPLETE_NET_BOUQUET_SI;
pub const DESC_LINKAGE_REPLACEMENT = DESC_LINKAGE_TYPE.REPLACEMENT;
pub const DESC_LINKAGE_DATA = DESC_LINKAGE_TYPE.DATA;
pub const DESC_LINKAGE_RESERVED1 = DESC_LINKAGE_TYPE.RESERVED1;
pub const DESC_LINKAGE_USER = DESC_LINKAGE_TYPE.USER;
pub const DESC_LINKAGE_RESERVED2 = DESC_LINKAGE_TYPE.RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLinkageDescriptor_Value = Guid.initString("1cdf8b31-994a-46fc-acfd-6a6be8934dd5");
pub const IID_IDvbLinkageDescriptor = &IID_IDvbLinkageDescriptor_Value;
pub const IDvbLinkageDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbLinkageDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbLinkageDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSId: *const fn (
            self: *const IDvbLinkageDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetONId: *const fn (
            self: *const IDvbLinkageDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: *const fn (
            self: *const IDvbLinkageDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkageType: *const fn (
            self: *const IDvbLinkageDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataLength: *const fn (
            self: *const IDvbLinkageDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateData: *const fn (
            self: *const IDvbLinkageDescriptor,
            pb_len: ?*u8,
            pb_data: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTSId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetTSId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getONId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetONId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getServiceId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getLinkageType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetLinkageType(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getPrivateDataLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataLength(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getPrivateData(self: *const T, pb_len_: ?*u8, pb_data_: ?*u8) HRESULT {
                return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateData(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pb_len_, pb_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbTeletextDescriptor_Value = Guid.initString("9cd29d47-69c6-4f92-98a9-210af1b7303a");
pub const IID_IDvbTeletextDescriptor = &IID_IDvbTeletextDescriptor_Value;
pub const IDvbTeletextDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbTeletextDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbTeletextDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbTeletextDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: *const fn (
            self: *const IDvbTeletextDescriptor,
            b_record_index: u8,
            pul_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTeletextType: *const fn (
            self: *const IDvbTeletextDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMagazineNumber: *const fn (
            self: *const IDvbTeletextDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordPageNumber: *const fn (
            self: *const IDvbTeletextDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordLangId(self: *const T, b_record_index_: u8, pul_val_: ?*u32) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), b_record_index_, pul_val_);
            }
            pub inline fn getRecordTeletextType(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTeletextType(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordMagazineNumber(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordMagazineNumber(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordPageNumber(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordPageNumber(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSubtitlingDescriptor_Value = Guid.initString("9b25fe1d-fa23-4e50-9784-6df8b26f8a49");
pub const IID_IDvbSubtitlingDescriptor = &IID_IDvbSubtitlingDescriptor_Value;
pub const IDvbSubtitlingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            b_record_index: u8,
            pul_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSubtitlingType: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCompositionPageID: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordAncillaryPageID: *const fn (
            self: *const IDvbSubtitlingDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordLangId(self: *const T, b_record_index_: u8, pul_val_: ?*u32) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), b_record_index_, pul_val_);
            }
            pub inline fn getRecordSubtitlingType(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordSubtitlingType(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordCompositionPageID(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCompositionPageID(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
            pub inline fn getRecordAncillaryPageID(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordAncillaryPageID(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceDescriptor_Value = Guid.initString("f9c7fbcf-e2d6-464d-b32d-2ef526e49290");
pub const IID_IDvbServiceDescriptor = &IID_IDvbServiceDescriptor_Value;
pub const IDvbServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceType: *const fn (
            self: *const IDvbServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProviderName: *const fn (
            self: *const IDvbServiceDescriptor,
            psz_name: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProviderNameW: *const fn (
            self: *const IDvbServiceDescriptor,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceName: *const fn (
            self: *const IDvbServiceDescriptor,
            psz_name: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessedServiceName: *const fn (
            self: *const IDvbServiceDescriptor,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceNameEmphasized: *const fn (
            self: *const IDvbServiceDescriptor,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getServiceType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceType(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getServiceProviderName(self: *const T, psz_name_: ?*?*u8) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceProviderName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), psz_name_);
            }
            pub inline fn getServiceProviderNameW(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceProviderNameW(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstr_name_);
            }
            pub inline fn getServiceName(self: *const T, psz_name_: ?*?*u8) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), psz_name_);
            }
            pub inline fn getProcessedServiceName(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetProcessedServiceName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstr_name_);
            }
            pub inline fn getServiceNameEmphasized(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceNameEmphasized(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceDescriptor2_Value = Guid.initString("d6c76506-85ab-487c-9b2b-36416511e4a2");
pub const IID_IDvbServiceDescriptor2 = &IID_IDvbServiceDescriptor2_Value;
pub const IDvbServiceDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbServiceDescriptor.VTable,
        GetServiceProviderNameW: *const fn (
            self: *const IDvbServiceDescriptor2,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceNameW: *const fn (
            self: *const IDvbServiceDescriptor2,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDvbServiceDescriptor.MethodMixin(T);
            pub inline fn getServiceProviderNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbServiceDescriptor2.VTable, @ptrCast(self.vtable)).GetServiceProviderNameW(@as(*const IDvbServiceDescriptor2, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
            pub inline fn getServiceNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbServiceDescriptor2.VTable, @ptrCast(self.vtable)).GetServiceNameW(@as(*const IDvbServiceDescriptor2, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceListDescriptor_Value = Guid.initString("05db0d8f-6008-491a-acd3-7090952707d0");
pub const IID_IDvbServiceListDescriptor = &IID_IDvbServiceListDescriptor_Value;
pub const IDvbServiceListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbServiceListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbServiceListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbServiceListDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: *const fn (
            self: *const IDvbServiceListDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceType: *const fn (
            self: *const IDvbServiceListDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordServiceId(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
            pub inline fn getRecordServiceType(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceType(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbMultilingualServiceNameDescriptor_Value = Guid.initString("2d80433b-b32c-47ef-987f-e78ebb773e34");
pub const IID_IDvbMultilingualServiceNameDescriptor = &IID_IDvbMultilingualServiceNameDescriptor_Value;
pub const IDvbMultilingualServiceNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            b_record_index: u8,
            ul_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceProviderNameW: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            b_record_index: u8,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceNameW: *const fn (
            self: *const IDvbMultilingualServiceNameDescriptor,
            b_record_index: u8,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordLangId(self: *const T, b_record_index_: u8, ul_val_: ?*u32) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), b_record_index_, ul_val_);
            }
            pub inline fn getRecordServiceProviderNameW(self: *const T, b_record_index_: u8, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceProviderNameW(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), b_record_index_, conv_mode_, pbstr_name_);
            }
            pub inline fn getRecordServiceNameW(self: *const T, b_record_index_: u8, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceNameW(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), b_record_index_, conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbNetworkNameDescriptor_Value = Guid.initString("5b2a80cf-35b9-446c-b3e4-048b761dbc51");
pub const IID_IDvbNetworkNameDescriptor = &IID_IDvbNetworkNameDescriptor_Value;
pub const IDvbNetworkNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbNetworkNameDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbNetworkNameDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkName: *const fn (
            self: *const IDvbNetworkNameDescriptor,
            psz_name: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkNameW: *const fn (
            self: *const IDvbNetworkNameDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getNetworkName(self: *const T, psz_name_: ?*?*u8) HRESULT {
                return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetNetworkName(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), psz_name_);
            }
            pub inline fn getNetworkNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetNetworkNameW(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbShortEventDescriptor_Value = Guid.initString("b170be92-5b75-458e-9c6e-b0008231491a");
pub const IID_IDvbShortEventDescriptor = &IID_IDvbShortEventDescriptor_Value;
pub const IDvbShortEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbShortEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbShortEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const IDvbShortEventDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventNameW: *const fn (
            self: *const IDvbShortEventDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IDvbShortEventDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getEventNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetEventNameW(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), conv_mode_, pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbExtendedEventDescriptor_Value = Guid.initString("c9b22eca-85f4-499f-b1db-efa93a91ee57");
pub const IID_IDvbExtendedEventDescriptor = &IID_IDvbExtendedEventDescriptor_Value;
pub const IDvbExtendedEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptorNumber: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastDescriptorNumber: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordItemW: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            b_record_index: u8,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_desc: ?*?BSTR,
            pbstr_item: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConcatenatedItemW: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            p_following_descriptor: ?*IDvbExtendedEventDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_desc: ?*?BSTR,
            pbstr_item: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConcatenatedTextW: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            following_descriptor: ?*IDvbExtendedEventDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordItemRawBytes: *const fn (
            self: *const IDvbExtendedEventDescriptor,
            b_record_index: u8,
            ppb_raw_item: ?*?*u8,
            pb_item_length: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDescriptorNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetDescriptorNumber(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLastDescriptorNumber(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLastDescriptorNumber(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordItemW(self: *const T, b_record_index_: u8, conv_mode_: DVB_STRCONV_MODE, pbstr_desc_: ?*?BSTR, pbstr_item_: ?*?BSTR) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetRecordItemW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), b_record_index_, conv_mode_, pbstr_desc_, pbstr_item_);
            }
            pub inline fn getConcatenatedItemW(self: *const T, p_following_descriptor_: ?*IDvbExtendedEventDescriptor, conv_mode_: DVB_STRCONV_MODE, pbstr_desc_: ?*?BSTR, pbstr_item_: ?*?BSTR) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetConcatenatedItemW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), p_following_descriptor_, conv_mode_, pbstr_desc_, pbstr_item_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), conv_mode_, pbstr_text_);
            }
            pub inline fn getConcatenatedTextW(self: *const T, following_descriptor_: ?*IDvbExtendedEventDescriptor, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetConcatenatedTextW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), following_descriptor_, conv_mode_, pbstr_text_);
            }
            pub inline fn getRecordItemRawBytes(self: *const T, b_record_index_: u8, ppb_raw_item_: ?*?*u8, pb_item_length_: ?*u8) HRESULT {
                return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetRecordItemRawBytes(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), b_record_index_, ppb_raw_item_, pb_item_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbComponentDescriptor_Value = Guid.initString("91e405cf-80e7-457f-9096-1b9d1ce32141");
pub const IID_IDvbComponentDescriptor = &IID_IDvbComponentDescriptor_Value;
pub const IDvbComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamContent: *const fn (
            self: *const IDvbComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: *const fn (
            self: *const IDvbComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: *const fn (
            self: *const IDvbComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const IDvbComponentDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IDvbComponentDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getStreamContent(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamContent(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getComponentType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentType(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getComponentTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbComponentDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbComponentDescriptor, @ptrCast(self)), conv_mode_, pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentDescriptor_Value = Guid.initString("2e883881-a467-412a-9d63-6f2b6da05bf0");
pub const IID_IDvbContentDescriptor = &IID_IDvbContentDescriptor_Value;
pub const IDvbContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordContentNibbles: *const fn (
            self: *const IDvbContentDescriptor,
            b_record_index: u8,
            pb_val_level1: ?*u8,
            pb_val_level2: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordUserNibbles: *const fn (
            self: *const IDvbContentDescriptor,
            b_record_index: u8,
            pb_val1: ?*u8,
            pb_val2: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordContentNibbles(self: *const T, b_record_index_: u8, pb_val_level1_: ?*u8, pb_val_level2_: ?*u8) HRESULT {
                return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordContentNibbles(@as(*const IDvbContentDescriptor, @ptrCast(self)), b_record_index_, pb_val_level1_, pb_val_level2_);
            }
            pub inline fn getRecordUserNibbles(self: *const T, b_record_index_: u8, pb_val1_: ?*u8, pb_val2_: ?*u8) HRESULT {
                return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordUserNibbles(@as(*const IDvbContentDescriptor, @ptrCast(self)), b_record_index_, pb_val1_, pb_val2_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbParentalRatingDescriptor_Value = Guid.initString("3ad9dde1-fb1b-4186-937f-22e6b5a72a10");
pub const IID_IDvbParentalRatingDescriptor = &IID_IDvbParentalRatingDescriptor_Value;
pub const IDvbParentalRatingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IDvbParentalRatingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IDvbParentalRatingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IDvbParentalRatingDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRating: *const fn (
            self: *const IDvbParentalRatingDescriptor,
            b_record_index: u8,
            psz_country_code: *[4]u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordRating(self: *const T, b_record_index_: u8, psz_country_code_: *[4]u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRating(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), b_record_index_, psz_country_code_, pb_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTerrestrialDeliverySystemDescriptor_Value = Guid.initString("39fae0a6-d151-44dd-a28a-765de5991670");
pub const IID_IIsdbTerrestrialDeliverySystemDescriptor = &IID_IIsdbTerrestrialDeliverySystemDescriptor_Value;
pub const IIsdbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAreaCode: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFrequency: *const fn (
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            b_record_index: u8,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getAreaCode(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetAreaCode(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getGuardInterval(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTransmissionMode(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordFrequency(self: *const T, b_record_index_: u8, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetRecordFrequency(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), b_record_index_, pdw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTSInformationDescriptor_Value = Guid.initString("d7ad183e-38f5-4210-b55f-ec8d601bbd47");
pub const IID_IIsdbTSInformationDescriptor = &IID_IIsdbTSInformationDescriptor_Value;
pub const IIsdbTSInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRemoteControlKeyId: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSNameW: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransmissionTypeInfo: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfServices: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceIdByIndex: *const fn (
            self: *const IIsdbTSInformationDescriptor,
            b_record_index: u8,
            b_service_index: u8,
            pdw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRemoteControlKeyId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRemoteControlKeyId(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTSNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTSNameW(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordTransmissionTypeInfo(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTransmissionTypeInfo(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordNumberOfServices(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfServices(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordServiceIdByIndex(self: *const T, b_record_index_: u8, b_service_index_: u8, pdw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceIdByIndex(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), b_record_index_, b_service_index_, pdw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDigitalCopyControlDescriptor_Value = Guid.initString("1a28417e-266a-4bb8-a4bd-d782bcfb8161");
pub const IID_IIsdbDigitalCopyControlDescriptor = &IID_IIsdbDigitalCopyControlDescriptor_Value;
pub const IIsdbDigitalCopyControlDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbDigitalCopyControlDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbDigitalCopyControlDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCopyControl: *const fn (
            self: *const IIsdbDigitalCopyControlDescriptor,
            pb_digital_recording_control_data: ?*u8,
            pb_copy_control_type: ?*u8,
            pb_a_p_s_control_data: ?*u8,
            pb_maximum_bitrate: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbDigitalCopyControlDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCopyControl: *const fn (
            self: *const IIsdbDigitalCopyControlDescriptor,
            b_record_index: u8,
            pb_component_tag: ?*u8,
            pb_digital_recording_control_data: ?*u8,
            pb_copy_control_type: ?*u8,
            pb_a_p_s_control_data: ?*u8,
            pb_maximum_bitrate: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCopyControl(self: *const T, pb_digital_recording_control_data_: ?*u8, pb_copy_control_type_: ?*u8, pb_a_p_s_control_data_: ?*u8, pb_maximum_bitrate_: ?*u8) HRESULT {
                return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetCopyControl(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pb_digital_recording_control_data_, pb_copy_control_type_, pb_a_p_s_control_data_, pb_maximum_bitrate_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordCopyControl(self: *const T, b_record_index_: u8, pb_component_tag_: ?*u8, pb_digital_recording_control_data_: ?*u8, pb_copy_control_type_: ?*u8, pb_a_p_s_control_data_: ?*u8, pb_maximum_bitrate_: ?*u8) HRESULT {
                return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCopyControl(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), b_record_index_, pb_component_tag_, pb_digital_recording_control_data_, pb_copy_control_type_, pb_a_p_s_control_data_, pb_maximum_bitrate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbAudioComponentDescriptor_Value = Guid.initString("679d2002-2425-4be4-a4c7-d6632a574f4d");
pub const IID_IIsdbAudioComponentDescriptor = &IID_IIsdbAudioComponentDescriptor_Value;
pub const IIsdbAudioComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamContent: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamType: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSimulcastGroupTag: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetESMultiLingualFlag: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainComponentFlag: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pf_val: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualityIndicator: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSamplingRate: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode2: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IIsdbAudioComponentDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getStreamContent(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamContent(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getComponentType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentType(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getComponentTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getStreamType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamType(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSimulcastGroupTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetSimulcastGroupTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getESMultiLingualFlag(self: *const T, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetESMultiLingualFlag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pf_val_);
            }
            pub inline fn getMainComponentFlag(self: *const T, pf_val_: ?*BOOL) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetMainComponentFlag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pf_val_);
            }
            pub inline fn getQualityIndicator(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetQualityIndicator(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSamplingRate(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetSamplingRate(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getLanguageCode2(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode2(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), conv_mode_, pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDataContentDescriptor_Value = Guid.initString("a428100a-e646-4bd6-aa14-6087bdc08cd5");
pub const IID_IIsdbDataContentDescriptor = &IID_IIsdbDataContentDescriptor_Value;
pub const IIsdbDataContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataComponentId: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryComponent: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorLength: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorBytes: *const fn (
            self: *const IIsdbDataContentDescriptor,
            b_buf_length: u8,
            pb_buf: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbDataContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordComponentRef: *const fn (
            self: *const IIsdbDataContentDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: *const fn (
            self: *const IIsdbDataContentDescriptor,
            psz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IIsdbDataContentDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getDataComponentId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetDataComponentId(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getEntryComponent(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetEntryComponent(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSelectorLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorLength(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSelectorBytes(self: *const T, b_buf_length_: u8, pb_buf_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorBytes(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), b_buf_length_, pb_buf_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordComponentRef(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordComponentRef(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getLanguageCode(self: *const T, psz_code_: *[4]u8) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), psz_code_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), conv_mode_, pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAContractInformationDescriptor_Value = Guid.initString("08e18b25-a28f-4e92-821e-4fced5cc2291");
pub const IID_IIsdbCAContractInformationDescriptor = &IID_IIsdbCAContractInformationDescriptor_Value;
pub const IIsdbCAContractInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAUnitId: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordComponentTag: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContractVerificationInfoLength: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContractVerificationInfo: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            b_buf_length: u8,
            pb_buf: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFeeNameW: *const fn (
            self: *const IIsdbCAContractInformationDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCASystemId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCAUnitId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCAUnitId(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordComponentTag(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordComponentTag(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getContractVerificationInfoLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetContractVerificationInfoLength(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getContractVerificationInfo(self: *const T, b_buf_length_: u8, pb_buf_: ?*u8) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetContractVerificationInfo(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), b_buf_length_, pb_buf_);
            }
            pub inline fn getFeeNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetFeeNameW(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEventGroupDescriptor_Value = Guid.initString("94b06780-2e2a-44dc-a966-cc56fdabc6c2");
pub const IID_IIsdbEventGroupDescriptor = &IID_IIsdbEventGroupDescriptor_Value;
pub const IIsdbEventGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupType: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEvent: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            b_record_index: u8,
            pw_service_id: ?*u16,
            pw_event_id: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRefRecords: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefRecordEvent: *const fn (
            self: *const IIsdbEventGroupDescriptor,
            b_record_index: u8,
            pw_original_network_id: ?*u16,
            pw_transport_stream_id: ?*u16,
            pw_service_id: ?*u16,
            pw_event_id: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getGroupType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetGroupType(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordEvent(self: *const T, b_record_index_: u8, pw_service_id_: ?*u16, pw_event_id_: ?*u16) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordEvent(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), b_record_index_, pw_service_id_, pw_event_id_);
            }
            pub inline fn getCountOfRefRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRefRecords(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRefRecordEvent(self: *const T, b_record_index_: u8, pw_original_network_id_: ?*u16, pw_transport_stream_id_: ?*u16, pw_service_id_: ?*u16, pw_event_id_: ?*u16) HRESULT {
                return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRefRecordEvent(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), b_record_index_, pw_original_network_id_, pw_transport_stream_id_, pw_service_id_, pw_event_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbComponentGroupDescriptor_Value = Guid.initString("a494f17f-c592-47d8-8943-64c9a34be7b9");
pub const IID_IIsdbComponentGroupDescriptor = &IID_IIsdbComponentGroupDescriptor_Value;
pub const IIsdbComponentGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentGroupType: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordGroupId: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfCAUnit: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitCAUnitId: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            b_c_a_unit_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitNumberOfComponents: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            b_c_a_unit_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitComponentTag: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            b_c_a_unit_index: u8,
            b_component_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTotalBitRate: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTextW: *const fn (
            self: *const IIsdbComponentGroupDescriptor,
            b_record_index: u8,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getComponentGroupType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetComponentGroupType(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getRecordGroupId(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordGroupId(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordNumberOfCAUnit(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfCAUnit(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordCAUnitCAUnitId(self: *const T, b_record_index_: u8, b_c_a_unit_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitCAUnitId(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, b_c_a_unit_index_, pb_val_);
            }
            pub inline fn getRecordCAUnitNumberOfComponents(self: *const T, b_record_index_: u8, b_c_a_unit_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitNumberOfComponents(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, b_c_a_unit_index_, pb_val_);
            }
            pub inline fn getRecordCAUnitComponentTag(self: *const T, b_record_index_: u8, b_c_a_unit_index_: u8, b_component_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitComponentTag(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, b_c_a_unit_index_, b_component_index_, pb_val_);
            }
            pub inline fn getRecordTotalBitRate(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTotalBitRate(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getRecordTextW(self: *const T, b_record_index_: u8, conv_mode_: DVB_STRCONV_MODE, pbstr_text_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTextW(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), b_record_index_, conv_mode_, pbstr_text_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSeriesDescriptor_Value = Guid.initString("07ef6370-1660-4f26-87fc-614adab24b11");
pub const IID_IIsdbSeriesDescriptor = &IID_IIsdbSeriesDescriptor_Value;
pub const IIsdbSeriesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeriesId: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRepeatLabel: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramPattern: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpireDate: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pf_valid: ?*BOOL,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEpisodeNumber: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEpisodeNumber: *const fn (
            self: *const IIsdbSeriesDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeriesNameW: *const fn (
            self: *const IIsdbSeriesDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getSeriesId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetSeriesId(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getRepeatLabel(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetRepeatLabel(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getProgramPattern(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetProgramPattern(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getExpireDate(self: *const T, pf_valid_: ?*BOOL, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetExpireDate(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pf_valid_, pmdt_val_);
            }
            pub inline fn getEpisodeNumber(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetEpisodeNumber(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getLastEpisodeNumber(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetLastEpisodeNumber(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getSeriesNameW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetSeriesNameW(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDownloadContentDescriptor_Value = Guid.initString("5298661e-cb88-4f5f-a1de-5f440c185b92");
pub const IID_IIsdbDownloadContentDescriptor = &IID_IIsdbDownloadContentDescriptor_Value;
pub const IIsdbDownloadContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pf_reboot: ?*BOOL,
            pf_add_on: ?*BOOL,
            pf_compatibility: ?*BOOL,
            pf_module_info: ?*BOOL,
            pf_text_info: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentSize: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadId: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOutValueDII: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeakRate: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompatiblityDescriptorLength: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pw_length: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompatiblityDescriptor: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            ppb_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleId: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            w_record_index: u16,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleSize: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            w_record_index: u16,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleInfoLength: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            w_record_index: u16,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleInfo: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            w_record_index: u16,
            ppb_data: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextLanguageCode: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            sz_code: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: *const fn (
            self: *const IIsdbDownloadContentDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getFlags(self: *const T, pf_reboot_: ?*BOOL, pf_add_on_: ?*BOOL, pf_compatibility_: ?*BOOL, pf_module_info_: ?*BOOL, pf_text_info_: ?*BOOL) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pf_reboot_, pf_add_on_, pf_compatibility_, pf_module_info_, pf_text_info_);
            }
            pub inline fn getComponentSize(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentSize(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getDownloadId(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetDownloadId(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getTimeOutValueDII(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTimeOutValueDII(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getLeakRate(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetLeakRate(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getComponentTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCompatiblityDescriptorLength(self: *const T, pw_length_: ?*u16) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCompatiblityDescriptorLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pw_length_);
            }
            pub inline fn getCompatiblityDescriptor(self: *const T, ppb_data_: ?*?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCompatiblityDescriptor(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), ppb_data_);
            }
            pub inline fn getCountOfRecords(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getRecordModuleId(self: *const T, w_record_index_: u16, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleId(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), w_record_index_, pw_val_);
            }
            pub inline fn getRecordModuleSize(self: *const T, w_record_index_: u16, pdw_val_: ?*u32) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleSize(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), w_record_index_, pdw_val_);
            }
            pub inline fn getRecordModuleInfoLength(self: *const T, w_record_index_: u16, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleInfoLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), w_record_index_, pb_val_);
            }
            pub inline fn getRecordModuleInfo(self: *const T, w_record_index_: u16, ppb_data_: ?*?*u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleInfo(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), w_record_index_, ppb_data_);
            }
            pub inline fn getTextLanguageCode(self: *const T, sz_code_: *[4]u8) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextLanguageCode(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), sz_code_);
            }
            pub inline fn getTextW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), conv_mode_, pbstr_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbLogoTransmissionDescriptor_Value = Guid.initString("e0103f49-4ae1-4f07-9098-756db1fa88cd");
pub const IID_IIsdbLogoTransmissionDescriptor = &IID_IIsdbLogoTransmissionDescriptor_Value;
pub const IIsdbLogoTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoTransmissionType: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoId: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoVersion: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadDataId: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoCharW: *const fn (
            self: *const IIsdbLogoTransmissionDescriptor,
            conv_mode: DVB_STRCONV_MODE,
            pbstr_char: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLogoTransmissionType(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoTransmissionType(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLogoId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoId(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getLogoVersion(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoVersion(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getDownloadDataId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetDownloadDataId(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getLogoCharW(self: *const T, conv_mode_: DVB_STRCONV_MODE, pbstr_char_: ?*?BSTR) HRESULT {
                return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoCharW(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), conv_mode_, pbstr_char_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSIParameterDescriptor_Value = Guid.initString("f837dc36-867c-426a-9111-f62093951a45");
pub const IID_IIsdbSIParameterDescriptor = &IID_IIsdbSIParameterDescriptor_Value;
pub const IIsdbSIParameterDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterVersion: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateTime: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            p_val: ?*MPEG_DATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfTable: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableId: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptionLength: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptionBytes: *const fn (
            self: *const IIsdbSIParameterDescriptor,
            b_record_index: u8,
            pb_buffer_length: ?*u8,
            pb_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getParameterVersion(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetParameterVersion(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getUpdateTime(self: *const T, p_val_: ?*MPEG_DATE) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetUpdateTime(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), p_val_);
            }
            pub inline fn getRecordNumberOfTable(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfTable(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getTableId(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableId(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getTableDescriptionLength(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableDescriptionLength(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getTableDescriptionBytes(self: *const T, b_record_index_: u8, pb_buffer_length_: ?*u8, pb_buffer_: ?*u8) HRESULT {
                return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableDescriptionBytes(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), b_record_index_, pb_buffer_length_, pb_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEmergencyInformationDescriptor_Value = Guid.initString("ba6fa681-b973-4da1-9207-ac3e7f0341eb");
pub const IID_IIsdbEmergencyInformationDescriptor = &IID_IIsdbEmergencyInformationDescriptor_Value;
pub const IIsdbEmergencyInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            b_record_index: u8,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartEndFlag: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            b_record_index: u8,
            p_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalLevel: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            b_record_index: u8,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAreaCode: *const fn (
            self: *const IIsdbEmergencyInformationDescriptor,
            b_record_index: u8,
            ppw_val: ?*?*u16,
            pb_num_area_codes: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getServiceId(self: *const T, b_record_index_: u8, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), b_record_index_, pw_val_);
            }
            pub inline fn getStartEndFlag(self: *const T, b_record_index_: u8, p_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetStartEndFlag(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), b_record_index_, p_val_);
            }
            pub inline fn getSignalLevel(self: *const T, b_record_index_: u8, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetSignalLevel(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), b_record_index_, pb_val_);
            }
            pub inline fn getAreaCode(self: *const T, b_record_index_: u8, ppw_val_: ?*?*u16, pb_num_area_codes_: ?*u8) HRESULT {
                return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetAreaCode(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), b_record_index_, ppw_val_, pb_num_area_codes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCADescriptor_Value = Guid.initString("0570aa47-52bc-42ae-8ca5-969f41e81aea");
pub const IID_IIsdbCADescriptor = &IID_IIsdbCADescriptor_Value;
pub const IIsdbCADescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbCADescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbCADescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: *const fn (
            self: *const IIsdbCADescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReservedBits: *const fn (
            self: *const IIsdbCADescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPID: *const fn (
            self: *const IIsdbCADescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataBytes: *const fn (
            self: *const IIsdbCADescriptor,
            pb_buffer_length: ?*u8,
            pb_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCADescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCADescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCASystemId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCADescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getReservedBits(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetReservedBits(@as(*const IIsdbCADescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCAPID(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetCAPID(@as(*const IIsdbCADescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getPrivateDataBytes(self: *const T, pb_buffer_length_: ?*u8, pb_buffer_: ?*u8) HRESULT {
                return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataBytes(@as(*const IIsdbCADescriptor, @ptrCast(self)), pb_buffer_length_, pb_buffer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAServiceDescriptor_Value = Guid.initString("39cbeb97-ff0b-42a7-9ab9-7b9cfe70a77a");
pub const IID_IIsdbCAServiceDescriptor = &IID_IIsdbCAServiceDescriptor_Value;
pub const IIsdbCAServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCABroadcasterGroupId: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageControl: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceIds: *const fn (
            self: *const IIsdbCAServiceDescriptor,
            pb_num_service_ids: ?*u8,
            pw_service_ids: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getCASystemId(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getCABroadcasterGroupId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCABroadcasterGroupId(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getMessageControl(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetMessageControl(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getServiceIds(self: *const T, pb_num_service_ids_: ?*u8, pw_service_ids_: ?*u16) HRESULT {
                return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceIds(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pb_num_service_ids_, pw_service_ids_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbHierarchicalTransmissionDescriptor_Value = Guid.initString("b7b3ae90-ee0b-446d-8769-f7e2aa266aa6");
pub const IID_IIsdbHierarchicalTransmissionDescriptor = &IID_IIsdbHierarchicalTransmissionDescriptor_Value;
pub const IIsdbHierarchicalTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFutureUse1: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualityLevel: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFutureUse2: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferencePid: *const fn (
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getFutureUse1(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetFutureUse1(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getQualityLevel(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetQualityLevel(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getFutureUse2(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetFutureUse2(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getReferencePid(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetReferencePid(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pw_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDASiParser_Value = Guid.initString("9de49a74-aba2-4a18-93e1-21f17f95c3c3");
pub const IID_IPBDASiParser = &IID_IPBDASiParser_Value;
pub const IPBDASiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IPBDASiParser,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: *const fn (
            self: *const IPBDASiParser,
            dw_size: u32,
            p_buffer: ?*u8,
            pp_e_i_t: ?*?*IPBDA_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServices: *const fn (
            self: *const IPBDASiParser,
            dw_size: u32,
            p_buffer: ?*const u8,
            pp_services: ?*?*IPBDA_Services,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, punk_: ?*IUnknown) HRESULT {
                return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDASiParser, @ptrCast(self)), punk_);
            }
            pub inline fn getEIT(self: *const T, dw_size_: u32, p_buffer_: ?*u8, pp_e_i_t_: ?*?*IPBDA_EIT) HRESULT {
                return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IPBDASiParser, @ptrCast(self)), dw_size_, p_buffer_, pp_e_i_t_);
            }
            pub inline fn getServices(self: *const T, dw_size_: u32, p_buffer_: ?*const u8, pp_services_: ?*?*IPBDA_Services) HRESULT {
                return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IPBDASiParser, @ptrCast(self)), dw_size_, p_buffer_, pp_services_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_EIT_Value = Guid.initString("a35f2dea-098f-4ebd-984c-2bd4c3c8ce0a");
pub const IID_IPBDA_EIT = &IID_IPBDA_EIT_Value;
pub const IPBDA_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IPBDA_EIT,
            size: u32,
            p_buffer: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableId: *const fn (
            self: *const IPBDA_EIT,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: *const fn (
            self: *const IPBDA_EIT,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceIdx: *const fn (
            self: *const IPBDA_EIT,
            plw_val: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IPBDA_EIT,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            plw_val: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            pmdt_val: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            pmd_val: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            dw_index: u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: *const fn (
            self: *const IPBDA_EIT,
            dw_record_index: u32,
            b_tag: u8,
            pdw_cookie: ?*u32,
            pp_descriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, size_: u32, p_buffer_: ?*const u8) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDA_EIT, @ptrCast(self)), size_, p_buffer_);
            }
            pub inline fn getTableId(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetTableId(@as(*const IPBDA_EIT, @ptrCast(self)), pb_val_);
            }
            pub inline fn getVersionNumber(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPBDA_EIT, @ptrCast(self)), pw_val_);
            }
            pub inline fn getServiceIdx(self: *const T, plw_val_: ?*u64) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetServiceIdx(@as(*const IPBDA_EIT, @ptrCast(self)), plw_val_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPBDA_EIT, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordEventId(self: *const T, dw_record_index_: u32, plw_val_: ?*u64) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, plw_val_);
            }
            pub inline fn getRecordStartTime(self: *const T, dw_record_index_: u32, pmdt_val_: ?*MPEG_DATE_AND_TIME) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, pmdt_val_);
            }
            pub inline fn getRecordDuration(self: *const T, dw_record_index_: u32, pmd_val_: ?*MPEG_TIME) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, pmd_val_);
            }
            pub inline fn getRecordCountOfDescriptors(self: *const T, dw_record_index_: u32, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, pdw_val_);
            }
            pub inline fn getRecordDescriptorByIndex(self: *const T, dw_record_index_: u32, dw_index_: u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, dw_index_, pp_descriptor_);
            }
            pub inline fn getRecordDescriptorByTag(self: *const T, dw_record_index_: u32, b_tag_: u8, pdw_cookie_: ?*u32, pp_descriptor_: ?*?*IGenericDescriptor) HRESULT {
                return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IPBDA_EIT, @ptrCast(self)), dw_record_index_, b_tag_, pdw_cookie_, pp_descriptor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_Services_Value = Guid.initString("944eab37-eed4-4850-afd2-77e7efeb4427");
pub const IID_IPBDA_Services = &IID_IPBDA_Services_Value;
pub const IPBDA_Services = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IPBDA_Services,
            size: u32,
            p_buffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: *const fn (
            self: *const IPBDA_Services,
            pdw_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordByIndex: *const fn (
            self: *const IPBDA_Services,
            dw_record_index: u32,
            pul64_service_idx: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, size_: u32, p_buffer_: ?*u8) HRESULT {
                return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDA_Services, @ptrCast(self)), size_, p_buffer_);
            }
            pub inline fn getCountOfRecords(self: *const T, pdw_val_: ?*u32) HRESULT {
                return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPBDA_Services, @ptrCast(self)), pdw_val_);
            }
            pub inline fn getRecordByIndex(self: *const T, dw_record_index_: u32, pul64_service_idx_: ?*u64) HRESULT {
                return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).GetRecordByIndex(@as(*const IPBDA_Services, @ptrCast(self)), dw_record_index_, pul64_service_idx_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAEntitlementDescriptor_Value = Guid.initString("22632497-0de3-4587-aadc-d8d99017e760");
pub const IID_IPBDAEntitlementDescriptor = &IID_IPBDAEntitlementDescriptor_Value;
pub const IPBDAEntitlementDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IPBDAEntitlementDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IPBDAEntitlementDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToken: *const fn (
            self: *const IPBDAEntitlementDescriptor,
            ppb_token_buffer: ?*?*u8,
            pdw_token_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getToken(self: *const T, ppb_token_buffer_: ?*?*u8, pdw_token_length_: ?*u32) HRESULT {
                return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetToken(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), ppb_token_buffer_, pdw_token_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAAttributesDescriptor_Value = Guid.initString("313b3620-3263-45a6-9533-968befbeac03");
pub const IID_IPBDAAttributesDescriptor = &IID_IPBDAAttributesDescriptor_Value;
pub const IPBDAAttributesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: *const fn (
            self: *const IPBDAAttributesDescriptor,
            pb_val: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IPBDAAttributesDescriptor,
            pw_val: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributePayload: *const fn (
            self: *const IPBDAAttributesDescriptor,
            ppb_attribute_buffer: ?*?*u8,
            pdw_attribute_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTag(self: *const T, pb_val_: ?*u8) HRESULT {
                return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), pb_val_);
            }
            pub inline fn getLength(self: *const T, pw_val_: ?*u16) HRESULT {
                return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), pw_val_);
            }
            pub inline fn getAttributePayload(self: *const T, ppb_attribute_buffer_: ?*?*u8, pdw_attribute_length_: ?*u32) HRESULT {
                return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetAttributePayload(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), ppb_attribute_buffer_, pdw_attribute_length_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TIF_REGISTRATION_Value = Guid.initString("dfef4a68-ee61-415f-9ccb-cd95f2f98a3a");
pub const IID_IBDA_TIF_REGISTRATION = &IID_IBDA_TIF_REGISTRATION_Value;
pub const IBDA_TIF_REGISTRATION = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIFEx: *const fn (
            self: *const IBDA_TIF_REGISTRATION,
            p_t_i_f_input_pin: ?*IPin,
            ppv_registration_context: ?*u32,
            pp_mpeg2_data_control: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterTIF: *const fn (
            self: *const IBDA_TIF_REGISTRATION,
            pv_registration_context: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerTIFEx(self: *const T, p_t_i_f_input_pin_: ?*IPin, ppv_registration_context_: ?*u32, pp_mpeg2_data_control_: ?*?*IUnknown) HRESULT {
                return @as(*const IBDA_TIF_REGISTRATION.VTable, @ptrCast(self.vtable)).RegisterTIFEx(@as(*const IBDA_TIF_REGISTRATION, @ptrCast(self)), p_t_i_f_input_pin_, ppv_registration_context_, pp_mpeg2_data_control_);
            }
            pub inline fn unregisterTIF(self: *const T, pv_registration_context_: u32) HRESULT {
                return @as(*const IBDA_TIF_REGISTRATION.VTable, @ptrCast(self.vtable)).UnregisterTIF(@as(*const IBDA_TIF_REGISTRATION, @ptrCast(self)), pv_registration_context_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMPEG2_TIF_CONTROL_Value = Guid.initString("f9bac2f9-4149-4916-b2ef-faa202326862");
pub const IID_IMPEG2_TIF_CONTROL = &IID_IMPEG2_TIF_CONTROL_Value;
pub const IMPEG2_TIF_CONTROL = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIF: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            p_unk_t_i_f: ?*IUnknown,
            ppv_registration_context: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterTIF: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            pv_registration_context: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPIDs: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            ulc_p_i_ds: u32,
            pul_p_i_ds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePIDs: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            ulc_p_i_ds: u32,
            pul_p_i_ds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPIDCount: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            pulc_p_i_ds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPIDs: *const fn (
            self: *const IMPEG2_TIF_CONTROL,
            pulc_p_i_ds: ?*u32,
            pul_p_i_ds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerTIF(self: *const T, p_unk_t_i_f_: ?*IUnknown, ppv_registration_context_: ?*u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).RegisterTIF(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), p_unk_t_i_f_, ppv_registration_context_);
            }
            pub inline fn unregisterTIF(self: *const T, pv_registration_context_: u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).UnregisterTIF(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pv_registration_context_);
            }
            pub inline fn addPIDs(self: *const T, ulc_p_i_ds_: u32, pul_p_i_ds_: ?*u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).AddPIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), ulc_p_i_ds_, pul_p_i_ds_);
            }
            pub inline fn deletePIDs(self: *const T, ulc_p_i_ds_: u32, pul_p_i_ds_: ?*u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).DeletePIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), ulc_p_i_ds_, pul_p_i_ds_);
            }
            pub inline fn getPIDCount(self: *const T, pulc_p_i_ds_: ?*u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).GetPIDCount(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pulc_p_i_ds_);
            }
            pub inline fn getPIDs(self: *const T, pulc_p_i_ds_: ?*u32, pul_p_i_ds_: ?*u32) HRESULT {
                return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).GetPIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pulc_p_i_ds_, pul_p_i_ds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfo_Value = Guid.initString("a3b152df-7a90-4218-ac54-9830bee8c0b6");
pub const IID_ITuneRequestInfo = &IID_ITuneRequestInfo_Value;
pub const ITuneRequestInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocatorData: *const fn (
            self: *const ITuneRequestInfo,
            request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentData: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateComponentList: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextProgram: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousProgram: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextLocator: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousLocator: *const fn (
            self: *const ITuneRequestInfo,
            current_request: ?*ITuneRequest,
            tune_request: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLocatorData(self: *const T, request_: ?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetLocatorData(@as(*const ITuneRequestInfo, @ptrCast(self)), request_);
            }
            pub inline fn getComponentData(self: *const T, current_request_: ?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetComponentData(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_);
            }
            pub inline fn createComponentList(self: *const T, current_request_: ?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).CreateComponentList(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_);
            }
            pub inline fn getNextProgram(self: *const T, current_request_: ?*ITuneRequest, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetNextProgram(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_, tune_request_);
            }
            pub inline fn getPreviousProgram(self: *const T, current_request_: ?*ITuneRequest, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetPreviousProgram(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_, tune_request_);
            }
            pub inline fn getNextLocator(self: *const T, current_request_: ?*ITuneRequest, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetNextLocator(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_, tune_request_);
            }
            pub inline fn getPreviousLocator(self: *const T, current_request_: ?*ITuneRequest, tune_request_: ?*?*ITuneRequest) HRESULT {
                return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetPreviousLocator(@as(*const ITuneRequestInfo, @ptrCast(self)), current_request_, tune_request_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfoEx_Value = Guid.initString("ee957c52-b0d0-4e78-8dd1-b87a08bfd893");
pub const IID_ITuneRequestInfoEx = &IID_ITuneRequestInfoEx_Value;
pub const ITuneRequestInfoEx = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequestInfo.VTable,
        CreateComponentListEx: *const fn (
            self: *const ITuneRequestInfoEx,
            current_request: ?*ITuneRequest,
            pp_cur_p_m_t: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITuneRequestInfo.MethodMixin(T);
            pub inline fn createComponentListEx(self: *const T, current_request_: ?*ITuneRequest, pp_cur_p_m_t_: ?*?*IUnknown) HRESULT {
                return @as(*const ITuneRequestInfoEx.VTable, @ptrCast(self.vtable)).CreateComponentListEx(@as(*const ITuneRequestInfoEx, @ptrCast(self)), current_request_, pp_cur_p_m_t_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPGEvent_Value = Guid.initString("7e47913a-5a89-423d-9a2b-e15168858934");
pub const IID_ISIInbandEPGEvent = &IID_ISIInbandEPGEvent_Value;
pub const ISIInbandEPGEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SIObjectEvent: *const fn (
            self: *const ISIInbandEPGEvent,
            p_i_d_v_b__e_i_t: ?*IDVB_EIT2,
            dw_table__i_d: u32,
            dw_service__i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn siObjectEvent(self: *const T, p_i_d_v_b__e_i_t_: ?*IDVB_EIT2, dw_table__i_d_: u32, dw_service__i_d_: u32) HRESULT {
                return @as(*const ISIInbandEPGEvent.VTable, @ptrCast(self.vtable)).SIObjectEvent(@as(*const ISIInbandEPGEvent, @ptrCast(self)), p_i_d_v_b__e_i_t_, dw_table__i_d_, dw_service__i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPG_Value = Guid.initString("f90ad9d0-b854-4b68-9cc1-b2cc96119d85");
pub const IID_ISIInbandEPG = &IID_ISIInbandEPG_Value;
pub const ISIInbandEPG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartSIEPGScan: *const fn (
            self: *const ISIInbandEPG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopSIEPGScan: *const fn (
            self: *const ISIInbandEPG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSIEPGScanRunning: *const fn (
            self: *const ISIInbandEPG,
            b_running: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn startSIEPGScan(self: *const T) HRESULT {
                return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).StartSIEPGScan(@as(*const ISIInbandEPG, @ptrCast(self)));
            }
            pub inline fn stopSIEPGScan(self: *const T) HRESULT {
                return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).StopSIEPGScan(@as(*const ISIInbandEPG, @ptrCast(self)));
            }
            pub inline fn isSIEPGScanRunning(self: *const T, b_running_: ?*BOOL) HRESULT {
                return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).IsSIEPGScanRunning(@as(*const ISIInbandEPG, @ptrCast(self)), b_running_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataEvent_Value = Guid.initString("efda0c80-f395-42c3-9b3c-56b37dec7bb7");
pub const IID_IGuideDataEvent = &IID_IGuideDataEvent_Value;
pub const IGuideDataEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GuideDataAcquired: *const fn (
            self: *const IGuideDataEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgramChanged: *const fn (
            self: *const IGuideDataEvent,
            var_program_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceChanged: *const fn (
            self: *const IGuideDataEvent,
            var_service_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScheduleEntryChanged: *const fn (
            self: *const IGuideDataEvent,
            var_schedule_entry_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgramDeleted: *const fn (
            self: *const IGuideDataEvent,
            var_program_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceDeleted: *const fn (
            self: *const IGuideDataEvent,
            var_service_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScheduleDeleted: *const fn (
            self: *const IGuideDataEvent,
            var_schedule_entry_description_i_d: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn guideDataAcquired(self: *const T) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).GuideDataAcquired(@as(*const IGuideDataEvent, @ptrCast(self)));
            }
            pub inline fn programChanged(self: *const T, var_program_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ProgramChanged(@as(*const IGuideDataEvent, @ptrCast(self)), var_program_description_i_d_);
            }
            pub inline fn serviceChanged(self: *const T, var_service_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ServiceChanged(@as(*const IGuideDataEvent, @ptrCast(self)), var_service_description_i_d_);
            }
            pub inline fn scheduleEntryChanged(self: *const T, var_schedule_entry_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ScheduleEntryChanged(@as(*const IGuideDataEvent, @ptrCast(self)), var_schedule_entry_description_i_d_);
            }
            pub inline fn programDeleted(self: *const T, var_program_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ProgramDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), var_program_description_i_d_);
            }
            pub inline fn serviceDeleted(self: *const T, var_service_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ServiceDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), var_service_description_i_d_);
            }
            pub inline fn scheduleDeleted(self: *const T, var_schedule_entry_description_i_d_: VARIANT) HRESULT {
                return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ScheduleDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), var_schedule_entry_description_i_d_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataProperty_Value = Guid.initString("88ec5e58-bb73-41d6-99ce-66c524b8b591");
pub const IID_IGuideDataProperty = &IID_IGuideDataProperty_Value;
pub const IGuideDataProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IGuideDataProperty,
            pbstr_name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IGuideDataProperty,
            id_lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IGuideDataProperty,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, pbstr_name_: ?*?BSTR) HRESULT {
                return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IGuideDataProperty, @ptrCast(self)), pbstr_name_);
            }
            pub inline fn getLanguage(self: *const T, id_lang_: ?*i32) HRESULT {
                return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Language(@as(*const IGuideDataProperty, @ptrCast(self)), id_lang_);
            }
            pub inline fn getValue(self: *const T, pvar_: ?*VARIANT) HRESULT {
                return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Value(@as(*const IGuideDataProperty, @ptrCast(self)), pvar_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumGuideDataProperties_Value = Guid.initString("ae44423b-4571-475c-ad2c-f40a771d80ef");
pub const IID_IEnumGuideDataProperties = &IID_IEnumGuideDataProperties_Value;
pub const IEnumGuideDataProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumGuideDataProperties,
            celt: u32,
            ppprop: ?*?*IGuideDataProperty,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumGuideDataProperties,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumGuideDataProperties,
            ppenum: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, ppprop_: ?*?*IGuideDataProperty, pcelt_: ?*u32) HRESULT {
                return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumGuideDataProperties, @ptrCast(self)), celt_, ppprop_, pcelt_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumGuideDataProperties, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumGuideDataProperties, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumGuideDataProperties) HRESULT {
                return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumGuideDataProperties, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTuneRequests_Value = Guid.initString("1993299c-ced6-4788-87a3-420067dce0c7");
pub const IID_IEnumTuneRequests = &IID_IEnumTuneRequests_Value;
pub const IEnumTuneRequests = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumTuneRequests,
            celt: u32,
            ppprop: ?*?*ITuneRequest,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumTuneRequests,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumTuneRequests,
            ppenum: ?*?*IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, ppprop_: ?*?*ITuneRequest, pcelt_: ?*u32) HRESULT {
                return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTuneRequests, @ptrCast(self)), celt_, ppprop_, pcelt_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTuneRequests, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTuneRequests, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, ppenum_: ?*?*IEnumTuneRequests) HRESULT {
                return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTuneRequests, @ptrCast(self)), ppenum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideData_Value = Guid.initString("61571138-5b01-43cd-aeaf-60b784a0bf93");
pub const IID_IGuideData = &IID_IGuideData_Value;
pub const IGuideData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServices: *const fn (
            self: *const IGuideData,
            pp_enum_tune_requests: ?*?*IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProperties: *const fn (
            self: *const IGuideData,
            p_tune_request: ?*ITuneRequest,
            pp_enum_properties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideProgramIDs: *const fn (
            self: *const IGuideData,
            p_enum_programs: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramProperties: *const fn (
            self: *const IGuideData,
            var_program_description_i_d: VARIANT,
            pp_enum_properties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheduleEntryIDs: *const fn (
            self: *const IGuideData,
            p_enum_schedule_entries: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheduleEntryProperties: *const fn (
            self: *const IGuideData,
            var_schedule_entry_description_i_d: VARIANT,
            pp_enum_properties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getServices(self: *const T, pp_enum_tune_requests_: ?*?*IEnumTuneRequests) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IGuideData, @ptrCast(self)), pp_enum_tune_requests_);
            }
            pub inline fn getServiceProperties(self: *const T, p_tune_request_: ?*ITuneRequest, pp_enum_properties_: ?*?*IEnumGuideDataProperties) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetServiceProperties(@as(*const IGuideData, @ptrCast(self)), p_tune_request_, pp_enum_properties_);
            }
            pub inline fn getGuideProgramIDs(self: *const T, p_enum_programs_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetGuideProgramIDs(@as(*const IGuideData, @ptrCast(self)), p_enum_programs_);
            }
            pub inline fn getProgramProperties(self: *const T, var_program_description_i_d_: VARIANT, pp_enum_properties_: ?*?*IEnumGuideDataProperties) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetProgramProperties(@as(*const IGuideData, @ptrCast(self)), var_program_description_i_d_, pp_enum_properties_);
            }
            pub inline fn getScheduleEntryIDs(self: *const T, p_enum_schedule_entries_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetScheduleEntryIDs(@as(*const IGuideData, @ptrCast(self)), p_enum_schedule_entries_);
            }
            pub inline fn getScheduleEntryProperties(self: *const T, var_schedule_entry_description_i_d_: VARIANT, pp_enum_properties_: ?*?*IEnumGuideDataProperties) HRESULT {
                return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetScheduleEntryProperties(@as(*const IGuideData, @ptrCast(self)), var_schedule_entry_description_i_d_, pp_enum_properties_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataLoader_Value = Guid.initString("4764ff7c-fa95-4525-af4d-d32236db9e38");
pub const IID_IGuideDataLoader = &IID_IGuideDataLoader_Value;
pub const IGuideDataLoader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const IGuideDataLoader,
            p_guide_store: ?*IGuideData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: *const fn (
            self: *const IGuideDataLoader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, p_guide_store_: ?*IGuideData) HRESULT {
                return @as(*const IGuideDataLoader.VTable, @ptrCast(self.vtable)).Init(@as(*const IGuideDataLoader, @ptrCast(self)), p_guide_store_);
            }
            pub inline fn terminate(self: *const T) HRESULT {
                return @as(*const IGuideDataLoader.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IGuideDataLoader, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KSP_BDA_NODE_PIN = extern struct {
    Property: KSIDENTIFIER,
    ulNodeType: u32,
    ulInputPinId: u32,
    ulOutputPinId: u32,
};

pub const KSM_BDA_PIN = extern struct {
    Method: KSIDENTIFIER,
    Anonymous: extern union {
        PinId: u32,
        PinType: u32,
    },
    Reserved: u32,
};

pub const KSM_BDA_PIN_PAIR = extern struct {
    Method: KSIDENTIFIER,
    Anonymous1: extern union {
        InputPinId: u32,
        InputPinType: u32,
    },
    Anonymous2: extern union {
        OutputPinId: u32,
        OutputPinType: u32,
    },
};

pub const KSP_NODE_ESPID = extern struct {
    Property: KSP_NODE,
    EsPid: u32,
};

pub const KSM_BDA_DEBUG_LEVEL = extern struct {
    Method: KSIDENTIFIER,
    ucDebugLevel: u8,
    ulDebugStringSize: u32,
    argbDebugString: [1]u8,
};

pub const BDA_DEBUG_DATA = extern struct {
    lResult: i32,
    uuidDebugDataType: Guid,
    ulDataSize: u32,
    argbDebugData: [1]u8,
};

pub const BDA_EVENT_DATA = extern struct {
    lResult: i32,
    ulEventID: u32,
    uuidEventType: Guid,
    ulEventDataLength: u32,
    argbEventData: [1]u8,
};

pub const KSM_BDA_EVENT_COMPLETE = extern struct {
    Method: KSIDENTIFIER,
    ulEventID: u32,
    ulEventResult: u32,
};

pub const KSM_BDA_DRM_SETDRM = extern struct {
    NodeMethod: KSM_NODE,
    NewDRMuuid: Guid,
};

pub const KSM_BDA_BUFFER = extern struct {
    NodeMethod: KSM_NODE,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const KSM_BDA_WMDRM_LICENSE = extern struct {
    NodeMethod: KSM_NODE,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRM_RENEWLICENSE = extern struct {
    NodeMethod: KSM_NODE,
    ulXMRLicenseLength: u32,
    ulEntitlementTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulPurchaseTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_SETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRMTUNER_GETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
};

pub const KSM_BDA_WMDRMTUNER_SYNCVALUE = extern struct {
    NodeMethod: KSM_NODE,
    ulSyncValue: u32,
};

pub const KSM_BDA_TUNER_TUNEREQUEST = extern struct {
    Method: KSIDENTIFIER,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const KSM_BDA_GPNV_GETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulNameLength: u32,
    cLanguage: [12]CHAR,
    argbData: [1]u8,
};

pub const KSM_BDA_GPNV_SETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulNameLength: u32,
    ulValueLength: u32,
    argbName: [1]u8,
};

pub const KSM_BDA_GPNV_NAMEINDEX = extern struct {
    Method: KSIDENTIFIER,
    ulValueNameIndex: u32,
};

pub const KSM_BDA_SCAN_CAPABILTIES = extern struct {
    Method: KSIDENTIFIER,
    uuidBroadcastStandard: Guid,
};

pub const KSM_BDA_SCAN_FILTER = extern struct {
    Method: KSIDENTIFIER,
    ulScanModulationTypeSize: u32,
    AnalogVideoStandards: u64,
    argbScanModulationTypes: [1]u8,
};

pub const KSM_BDA_SCAN_START = extern struct {
    Method: KSIDENTIFIER,
    LowerFrequency: u32,
    HigherFrequency: u32,
};

pub const KSM_BDA_GDDS_TUNEXMLFROMIDX = extern struct {
    Method: KSIDENTIFIER,
    ulIdx: u64,
};

pub const KSM_BDA_GDDS_SERVICEFROMTUNEXML = extern struct {
    Method: KSIDENTIFIER,
    ulTuneXmlLength: u32,
    argbTuneXml: [1]u8,
};

pub const KSM_BDA_USERACTIVITY_USEREASON = extern struct {
    Method: KSIDENTIFIER,
    ulUseReason: u32,
};

pub const KSM_BDA_CAS_ENTITLEMENTTOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulRequestType: u32,
    ulEntitlementTokenLen: u32,
    argbEntitlementToken: [1]u8,
};

pub const KSM_BDA_CAS_CAPTURETOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulTokenLength: u32,
    argbToken: [1]u8,
};

pub const KSM_BDA_CAS_OPENBROADCASTMMI = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulEventId: u32,
};

pub const KSM_BDA_CAS_CLOSEMMIDIALOG = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulDialogNumber: u32,
    ulReason: u32,
};

pub const KSM_BDA_ISDBCAS_REQUEST = extern struct {
    NodeMethod: KSM_NODE,
    ulRequestID: u32,
    ulIsdbCommandSize: u32,
    argbIsdbCommandData: [1]u8,
};

pub const KSM_BDA_TS_SELECTOR_SETTSID = extern struct {
    NodeMethod: KSM_NODE,
    usTSID: u16,
};

pub const KS_DATARANGE_BDA_ANTENNA = extern struct {
    DataRange: KSDATAFORMAT,
};

pub const BDA_TRANSPORT_INFO = extern struct {
    ulcbPhyiscalPacket: u32,
    ulcbPhyiscalFrame: u32,
    ulcbPhyiscalFrameAlignment: u32,
    AvgTimePerFrame: i64,
};

pub const KS_DATARANGE_BDA_TRANSPORT = extern struct {
    DataRange: KSDATAFORMAT,
    BdaTransportInfo: BDA_TRANSPORT_INFO,
};

const CLSID_EVENTID_TuningChanging_Value = Guid.initString("83183c03-c09e-45c4-a719-807a94952bf9");
pub const CLSID_EVENTID_TuningChanging = &CLSID_EVENTID_TuningChanging_Value;

const CLSID_EVENTID_TuningChanged_Value = Guid.initString("9d7e6235-4b7d-425d-a6d1-d717c33b9c4c");
pub const CLSID_EVENTID_TuningChanged = &CLSID_EVENTID_TuningChanged_Value;

const CLSID_EVENTID_CandidatePostTuneData_Value = Guid.initString("9f02d3d0-9f06-4369-9f1e-3ad6ca19807e");
pub const CLSID_EVENTID_CandidatePostTuneData = &CLSID_EVENTID_CandidatePostTuneData_Value;

const CLSID_EVENTID_CADenialCountChanged_Value = Guid.initString("2a65c528-2249-4070-ac16-00390cdfb2dd");
pub const CLSID_EVENTID_CADenialCountChanged = &CLSID_EVENTID_CADenialCountChanged_Value;

const CLSID_EVENTID_SignalStatusChanged_Value = Guid.initString("6d9cfaf2-702d-4b01-8dff-6892ad20d191");
pub const CLSID_EVENTID_SignalStatusChanged = &CLSID_EVENTID_SignalStatusChanged_Value;

const CLSID_EVENTID_NewSignalAcquired_Value = Guid.initString("c87ec52d-cd18-404a-a076-c02a273d3de7");
pub const CLSID_EVENTID_NewSignalAcquired = &CLSID_EVENTID_NewSignalAcquired_Value;

const CLSID_EVENTID_EASMessageReceived_Value = Guid.initString("d10df9d5-c261-4b85-9e8a-517b3299cab2");
pub const CLSID_EVENTID_EASMessageReceived = &CLSID_EVENTID_EASMessageReceived_Value;

const CLSID_EVENTID_PSITable_Value = Guid.initString("1b9c3703-d447-4e16-97bb-01799fc031ed");
pub const CLSID_EVENTID_PSITable = &CLSID_EVENTID_PSITable_Value;

const CLSID_EVENTID_ServiceTerminated_Value = Guid.initString("0a1d591c-e0d2-4f8e-8960-2335bef45ccb");
pub const CLSID_EVENTID_ServiceTerminated = &CLSID_EVENTID_ServiceTerminated_Value;

const CLSID_EVENTID_CardStatusChanged_Value = Guid.initString("a265faea-f874-4b38-9ff7-c53d02969996");
pub const CLSID_EVENTID_CardStatusChanged = &CLSID_EVENTID_CardStatusChanged_Value;

const CLSID_EVENTID_DRMParingStatusChanged_Value = Guid.initString("000906f5-f0d1-41d6-a7df-4028697669f6");
pub const CLSID_EVENTID_DRMParingStatusChanged = &CLSID_EVENTID_DRMParingStatusChanged_Value;

const CLSID_EVENTID_DRMParingStepComplete_Value = Guid.initString("5b2ebf78-b752-4420-b41e-a472dc95828e");
pub const CLSID_EVENTID_DRMParingStepComplete = &CLSID_EVENTID_DRMParingStepComplete_Value;

const CLSID_EVENTID_MMIMessage_Value = Guid.initString("052c29af-09a4-4b93-890f-bd6a348968a4");
pub const CLSID_EVENTID_MMIMessage = &CLSID_EVENTID_MMIMessage_Value;

const CLSID_EVENTID_EntitlementChanged_Value = Guid.initString("9071ad5d-2359-4c95-8694-afa81d70bfd5");
pub const CLSID_EVENTID_EntitlementChanged = &CLSID_EVENTID_EntitlementChanged_Value;

const CLSID_EVENTID_STBChannelNumber_Value = Guid.initString("17c4d730-d0f0-413a-8c99-500469de35ad");
pub const CLSID_EVENTID_STBChannelNumber = &CLSID_EVENTID_STBChannelNumber_Value;

const CLSID_EVENTID_BDAEventingServicePendingEvent_Value = Guid.initString("5ca51711-5ddc-41a6-9430-e41b8b3bbc5b");
pub const CLSID_EVENTID_BDAEventingServicePendingEvent = &CLSID_EVENTID_BDAEventingServicePendingEvent_Value;

const CLSID_EVENTID_BDAConditionalAccessTAG_Value = Guid.initString("efc3a459-ae8b-4b4a-8fe9-79a0d097f3ea");
pub const CLSID_EVENTID_BDAConditionalAccessTAG = &CLSID_EVENTID_BDAConditionalAccessTAG_Value;

const CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value = Guid.initString("b2127d42-7be5-4f4b-9130-6679899f4f4b");
pub const CLSID_EVENTTYPE_CASDescrambleFailureEvent = &CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value;

const CLSID_EVENTID_CASFailureSpanningEvent_Value = Guid.initString("ead831ae-5529-4d1f-afce-0d8cd1257d30");
pub const CLSID_EVENTID_CASFailureSpanningEvent = &CLSID_EVENTID_CASFailureSpanningEvent_Value;

pub const ChannelChangeSpanningEvent_State = enum(i32) {
    Start = 0,
    End = 2,
};
pub const ChannelChangeSpanningEvent_Start = ChannelChangeSpanningEvent_State.Start;
pub const ChannelChangeSpanningEvent_End = ChannelChangeSpanningEvent_State.End;

const CLSID_EVENTID_ChannelChangeSpanningEvent_Value = Guid.initString("9067c5e5-4c5c-4205-86c8-7afe20fe1efa");
pub const CLSID_EVENTID_ChannelChangeSpanningEvent = &CLSID_EVENTID_ChannelChangeSpanningEvent_Value;

pub const ChannelChangeInfo = extern struct {
    state: ChannelChangeSpanningEvent_State,
    TimeStamp: u64,
};

const CLSID_EVENTID_ChannelTypeSpanningEvent_Value = Guid.initString("72ab1d51-87d2-489b-ba11-0e08dc210243");
pub const CLSID_EVENTID_ChannelTypeSpanningEvent = &CLSID_EVENTID_ChannelTypeSpanningEvent_Value;

pub const ChannelType = enum(i32) {
    None = 0,
    Other = 1,
    Video = 2,
    Audio = 4,
    Text = 8,
    Subtitles = 16,
    Captions = 32,
    Superimpose = 64,
    Data = 128,
};
pub const ChannelTypeNone = ChannelType.None;
pub const ChannelTypeOther = ChannelType.Other;
pub const ChannelTypeVideo = ChannelType.Video;
pub const ChannelTypeAudio = ChannelType.Audio;
pub const ChannelTypeText = ChannelType.Text;
pub const ChannelTypeSubtitles = ChannelType.Subtitles;
pub const ChannelTypeCaptions = ChannelType.Captions;
pub const ChannelTypeSuperimpose = ChannelType.Superimpose;
pub const ChannelTypeData = ChannelType.Data;

pub const ChannelTypeInfo = extern struct {
    channelType: ChannelType,
    timeStamp: u64,
};

pub const ChannelInfo = extern struct {
    lFrequency: i32,
    Anonymous: extern union {
        DVB: extern struct {
            lONID: i32,
            lTSID: i32,
            lSID: i32,
        },
        DC: extern struct {
            lProgNumber: i32,
        },
        ATSC: extern struct {
            lProgNumber: i32,
        },
    },
};

const CLSID_EVENTID_ChannelInfoSpanningEvent_Value = Guid.initString("41f36d80-4132-4cc2-b121-01a43219d81b");
pub const CLSID_EVENTID_ChannelInfoSpanningEvent = &CLSID_EVENTID_ChannelInfoSpanningEvent_Value;

const CLSID_EVENTID_RRTSpanningEvent_Value = Guid.initString("f6cfc8f4-da93-4f2f-bff8-ba1ee6fca3a2");
pub const CLSID_EVENTID_RRTSpanningEvent = &CLSID_EVENTID_RRTSpanningEvent_Value;

pub const SpanningEventDescriptor = extern struct {
    wDataLen: u16,
    wProgNumber: u16,
    wSID: u16,
    bDescriptor: [1]u8,
};

const CLSID_EVENTID_CSDescriptorSpanningEvent_Value = Guid.initString("efe779d9-97f0-4786-800d-95cf505ddc66");
pub const CLSID_EVENTID_CSDescriptorSpanningEvent = &CLSID_EVENTID_CSDescriptorSpanningEvent_Value;

const CLSID_EVENTID_CtxADescriptorSpanningEvent_Value = Guid.initString("3ab4a2e6-4247-4b34-896c-30afa5d21c24");
pub const CLSID_EVENTID_CtxADescriptorSpanningEvent = &CLSID_EVENTID_CtxADescriptorSpanningEvent_Value;

pub const DVBScramblingControlSpanningEvent = extern struct {
    ulPID: u32,
    fScrambled: BOOL,
};

const CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value = Guid.initString("4bd4e1c4-90a1-4109-8236-27f00e7dcc5b");
pub const CLSID_EVENTID_DVBScramblingControlSpanningEvent = &CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value;

pub const SignalAndServiceStatusSpanningEvent_State = enum(i32) {
    None = -1,
    Clear = 0,
    NoTVSignal = 1,
    ServiceOffAir = 2,
    WeakTVSignal = 3,
    NoSubscription = 4,
    AllAVScrambled = 5,
};
pub const SignalAndServiceStatusSpanningEvent_None = SignalAndServiceStatusSpanningEvent_State.None;
pub const SignalAndServiceStatusSpanningEvent_Clear = SignalAndServiceStatusSpanningEvent_State.Clear;
pub const SignalAndServiceStatusSpanningEvent_NoTVSignal = SignalAndServiceStatusSpanningEvent_State.NoTVSignal;
pub const SignalAndServiceStatusSpanningEvent_ServiceOffAir = SignalAndServiceStatusSpanningEvent_State.ServiceOffAir;
pub const SignalAndServiceStatusSpanningEvent_WeakTVSignal = SignalAndServiceStatusSpanningEvent_State.WeakTVSignal;
pub const SignalAndServiceStatusSpanningEvent_NoSubscription = SignalAndServiceStatusSpanningEvent_State.NoSubscription;
pub const SignalAndServiceStatusSpanningEvent_AllAVScrambled = SignalAndServiceStatusSpanningEvent_State.AllAVScrambled;

const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value = Guid.initString("8068c5cb-3c04-492b-b47d-0308820dce51");
pub const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent = &CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value;

pub const SpanningEventEmmMessage = extern struct {
    bCAbroadcasterGroupId: u8,
    bMessageControl: u8,
    wServiceId: u16,
    wTableIdExtension: u16,
    bDeletionStatus: u8,
    bDisplayingDuration1: u8,
    bDisplayingDuration2: u8,
    bDisplayingDuration3: u8,
    bDisplayingCycle: u8,
    bFormatVersion: u8,
    bDisplayPosition: u8,
    wMessageLength: u16,
    szMessageArea: [1]u16,
};

const CLSID_EVENTID_EmmMessageSpanningEvent_Value = Guid.initString("6bf00268-4f7e-4294-aa87-e9e953e43f14");
pub const CLSID_EVENTID_EmmMessageSpanningEvent = &CLSID_EVENTID_EmmMessageSpanningEvent_Value;

const CLSID_EVENTID_AudioTypeSpanningEvent_Value = Guid.initString("501cbfbe-b849-42ce-9be9-3db869fb82b3");
pub const CLSID_EVENTID_AudioTypeSpanningEvent = &CLSID_EVENTID_AudioTypeSpanningEvent_Value;

const CLSID_EVENTID_StreamTypeSpanningEvent_Value = Guid.initString("82af2ebc-30a6-4264-a80b-ad2e1372ac60");
pub const CLSID_EVENTID_StreamTypeSpanningEvent = &CLSID_EVENTID_StreamTypeSpanningEvent_Value;

const CLSID_EVENTID_ARIBcontentSpanningEvent_Value = Guid.initString("3a954083-93d0-463e-90b2-0742c496edf0");
pub const CLSID_EVENTID_ARIBcontentSpanningEvent = &CLSID_EVENTID_ARIBcontentSpanningEvent_Value;

const CLSID_EVENTID_LanguageSpanningEvent_Value = Guid.initString("e292666d-9c02-448d-aa8d-781a93fdc395");
pub const CLSID_EVENTID_LanguageSpanningEvent = &CLSID_EVENTID_LanguageSpanningEvent_Value;

pub const LanguageInfo = extern struct {
    LangID: u16,
    lISOLangCode: i32,
};

const CLSID_EVENTID_DualMonoSpanningEvent_Value = Guid.initString("a9a29b56-a84b-488c-89d5-0d4e7657c8ce");
pub const CLSID_EVENTID_DualMonoSpanningEvent = &CLSID_EVENTID_DualMonoSpanningEvent_Value;

pub const DualMonoInfo = extern struct {
    LangID1: u16,
    LangID2: u16,
    lISOLangCode1: i32,
    lISOLangCode2: i32,
};

const CLSID_EVENTID_PIDListSpanningEvent_Value = Guid.initString("47fc8f65-e2bb-4634-9cef-fdbfe6261d5c");
pub const CLSID_EVENTID_PIDListSpanningEvent = &CLSID_EVENTID_PIDListSpanningEvent_Value;

pub const PIDListSpanningEvent = extern struct {
    wPIDCount: u16,
    pulPIDs: [1]u32,
};

const CLSID_EVENTID_AudioDescriptorSpanningEvent_Value = Guid.initString("107bd41c-a6da-4691-8369-11b2cdaa288e");
pub const CLSID_EVENTID_AudioDescriptorSpanningEvent = &CLSID_EVENTID_AudioDescriptorSpanningEvent_Value;

const CLSID_EVENTID_SubtitleSpanningEvent_Value = Guid.initString("5dcec048-d0b9-4163-872c-4f32223be88a");
pub const CLSID_EVENTID_SubtitleSpanningEvent = &CLSID_EVENTID_SubtitleSpanningEvent_Value;

const CLSID_EVENTID_TeletextSpanningEvent_Value = Guid.initString("9599d950-5f33-4617-af7c-1e54b510daa3");
pub const CLSID_EVENTID_TeletextSpanningEvent = &CLSID_EVENTID_TeletextSpanningEvent_Value;

const CLSID_EVENTID_StreamIDSpanningEvent_Value = Guid.initString("caf1ab68-e153-4d41-a6b3-a7c998db75ee");
pub const CLSID_EVENTID_StreamIDSpanningEvent = &CLSID_EVENTID_StreamIDSpanningEvent_Value;

const CLSID_EVENTID_PBDAParentalControlEvent_Value = Guid.initString("f947aa85-fb52-48e8-b9c5-e1e1f411a51a");
pub const CLSID_EVENTID_PBDAParentalControlEvent = &CLSID_EVENTID_PBDAParentalControlEvent_Value;

pub const RATING_ATTRIBUTE = extern struct {
    rating_attribute_id: u32 align(1),
    rating_attribute_value: u32 align(1),
};

pub const RATING_SYSTEM = extern struct {
    rating_system_id: Guid align(1),
    _bitfield: u8 align(1),
    country_code: [3]u8 align(1),
    rating_attribute_count: u32 align(1),
    lpratingattrib: ?*RATING_ATTRIBUTE align(1),
};

pub const RATING_INFO = extern struct {
    rating_system_count: u32 align(1),
    lpratingsystem: ?*RATING_SYSTEM align(1),
};

pub const PBDAParentalControl = extern struct {
    rating_system_count: u32 align(1),
    rating_systems: ?*RATING_SYSTEM align(1),
};

const CLSID_EVENTID_TuneFailureEvent_Value = Guid.initString("d97287b2-2dfd-436a-9485-99d7d4ab5a69");
pub const CLSID_EVENTID_TuneFailureEvent = &CLSID_EVENTID_TuneFailureEvent_Value;

const CLSID_EVENTID_TuneFailureSpanningEvent_Value = Guid.initString("6f8aa455-5ee1-48ab-a27c-4c8d70b9aeba");
pub const CLSID_EVENTID_TuneFailureSpanningEvent = &CLSID_EVENTID_TuneFailureSpanningEvent_Value;

const CLSID_EVENTID_DvbParentalRatingDescriptor_Value = Guid.initString("2a67a58d-eca5-4eac-abcb-e734d3776d0a");
pub const CLSID_EVENTID_DvbParentalRatingDescriptor = &CLSID_EVENTID_DvbParentalRatingDescriptor_Value;

pub const DvbParentalRatingParam = extern struct {
    szCountryCode: [4]CHAR,
    bRating: u8,
};

pub const DvbParentalRatingDescriptor = extern struct {
    ulNumParams: u32,
    pParams: [1]DvbParentalRatingParam,
};

const CLSID_EVENTID_DFNWithNoActualAVData_Value = Guid.initString("f5689ffe-55f9-4bb3-96be-ae971c63bae0");
pub const CLSID_EVENTID_DFNWithNoActualAVData = &CLSID_EVENTID_DFNWithNoActualAVData_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value = Guid.initString("71985f41-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA = &CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value = Guid.initString("f4aeb342-0329-4fdd-a8fd-4aff4926c978");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value = Guid.initString("8deda6fd-ac5f-4334-8ecf-a4ba8fa7d0f0");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value = Guid.initString("61be0b47-a5eb-499b-9a85-5b16c07f1258");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL = &CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value;

const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value = Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS = &CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value = Guid.initString("b3c7397c-d303-414d-b33c-4ed2c9d29733");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value = Guid.initString("e9dd31a3-221d-4adb-8532-9af309c1a408");
pub const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value = Guid.initString("762e3f66-336f-48d1-bf83-2b00352c11f0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value = Guid.initString("951727db-d2ce-4528-96f6-3301fabb2de0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value = Guid.initString("4a2eeb99-6458-4538-b187-04017c41413f");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value = Guid.initString("0d7aed42-cb9a-11db-9705-005056c00008");
pub const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW = &CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value;

const CLSID_PINNAME_BDA_TRANSPORT_Value = Guid.initString("78216a81-cfa8-493e-9711-36a61c08bd9d");
pub const CLSID_PINNAME_BDA_TRANSPORT = &CLSID_PINNAME_BDA_TRANSPORT_Value;

const CLSID_PINNAME_BDA_ANALOG_VIDEO_Value = Guid.initString("5c0c8281-5667-486c-8482-63e31f01a6e9");
pub const CLSID_PINNAME_BDA_ANALOG_VIDEO = &CLSID_PINNAME_BDA_ANALOG_VIDEO_Value;

const CLSID_PINNAME_BDA_ANALOG_AUDIO_Value = Guid.initString("d28a580a-9b1f-4b0c-9c33-9bf0a8ea636b");
pub const CLSID_PINNAME_BDA_ANALOG_AUDIO = &CLSID_PINNAME_BDA_ANALOG_AUDIO_Value;

const CLSID_PINNAME_BDA_FM_RADIO_Value = Guid.initString("d2855fed-b2d3-4eeb-9bd0-193436a2f890");
pub const CLSID_PINNAME_BDA_FM_RADIO = &CLSID_PINNAME_BDA_FM_RADIO_Value;

const CLSID_PINNAME_BDA_IF_PIN_Value = Guid.initString("1a9d4a42-f3cd-48a1-9aea-71de133cbe14");
pub const CLSID_PINNAME_BDA_IF_PIN = &CLSID_PINNAME_BDA_IF_PIN_Value;

const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value = Guid.initString("297bb104-e5c9-4ace-b123-95c3cbb24d4f");
pub const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN = &CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value;

const CLSID_KSPROPSETID_BdaEthernetFilter_Value = Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaEthernetFilter = &CLSID_KSPROPSETID_BdaEthernetFilter_Value;

pub const KSPROPERTY_BDA_ETHERNET_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_ETHERNET_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_ETHERNET_FILTER.LIST;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_ETHERNET_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv4Filter_Value = Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaIPv4Filter = &CLSID_KSPROPSETID_BdaIPv4Filter_Value;

pub const KSPROPERTY_BDA_IPv4_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv4_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv4_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv4_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv6Filter_Value = Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const CLSID_KSPROPSETID_BdaIPv6Filter = &CLSID_KSPROPSETID_BdaIPv6Filter_Value;

pub const KSPROPERTY_BDA_IPv6_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv6_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv6_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv6_FILTER.MODE;

const CLSID_KSPROPSETID_BdaSignalStats_Value = Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const CLSID_KSPROPSETID_BdaSignalStats = &CLSID_KSPROPSETID_BdaSignalStats_Value;

pub const KSPROPERTY_BDA_SIGNAL_STATS = enum(i32) {
    IGNAL_STRENGTH = 0,
    IGNAL_QUALITY = 1,
    IGNAL_PRESENT = 2,
    IGNAL_LOCKED = 3,
    AMPLE_TIME = 4,
    IGNAL_LOCK_CAPS = 5,
    IGNAL_LOCK_TYPE = 6,
};
pub const KSPROPERTY_BDA_SIGNAL_STRENGTH = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_STRENGTH;
pub const KSPROPERTY_BDA_SIGNAL_QUALITY = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_QUALITY;
pub const KSPROPERTY_BDA_SIGNAL_PRESENT = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_PRESENT;
pub const KSPROPERTY_BDA_SIGNAL_LOCKED = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCKED;
pub const KSPROPERTY_BDA_SAMPLE_TIME = KSPROPERTY_BDA_SIGNAL_STATS.AMPLE_TIME;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_CAPS = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_CAPS;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_TYPE = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_TYPE;

pub const BDA_LockType = enum(i32) {
    None = 0,
    PLL = 1,
    DecoderDemod = 2,
    Complete = 128,
};
pub const Bda_LockType_None = BDA_LockType.None;
pub const Bda_LockType_PLL = BDA_LockType.PLL;
pub const Bda_LockType_DecoderDemod = BDA_LockType.DecoderDemod;
pub const Bda_LockType_Complete = BDA_LockType.Complete;

const CLSID_KSMETHODSETID_BdaChangeSync_Value = Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaChangeSync = &CLSID_KSMETHODSETID_BdaChangeSync_Value;

pub const KSMETHOD_BDA_CHANGE_SYNC = enum(i32) {
    START_CHANGES = 0,
    CHECK_CHANGES = 1,
    COMMIT_CHANGES = 2,
    GET_CHANGE_STATE = 3,
};
pub const KSMETHOD_BDA_START_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.START_CHANGES;
pub const KSMETHOD_BDA_CHECK_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.CHECK_CHANGES;
pub const KSMETHOD_BDA_COMMIT_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.COMMIT_CHANGES;
pub const KSMETHOD_BDA_GET_CHANGE_STATE = KSMETHOD_BDA_CHANGE_SYNC.GET_CHANGE_STATE;

const CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value = Guid.initString("71985f45-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaDeviceConfiguration = &CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value;

pub const KSMETHOD_BDA_DEVICE_CONFIGURATION = enum(i32) {
    CREATE_PIN_FACTORY = 0,
    DELETE_PIN_FACTORY = 1,
    CREATE_TOPOLOGY = 2,
};
pub const KSMETHOD_BDA_CREATE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_PIN_FACTORY;
pub const KSMETHOD_BDA_DELETE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.DELETE_PIN_FACTORY;
pub const KSMETHOD_BDA_CREATE_TOPOLOGY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_TOPOLOGY;

const CLSID_KSPROPSETID_BdaTopology_Value = Guid.initString("a14ee835-0a23-11d3-9cc7-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaTopology = &CLSID_KSPROPSETID_BdaTopology_Value;

pub const KSPROPERTY_BDA_TOPOLOGY = enum(i32) {
    NODE_TYPES = 0,
    PIN_TYPES = 1,
    TEMPLATE_CONNECTIONS = 2,
    NODE_METHODS = 3,
    NODE_PROPERTIES = 4,
    NODE_EVENTS = 5,
    CONTROLLING_PIN_ID = 6,
    NODE_DESCRIPTORS = 7,
};
pub const KSPROPERTY_BDA_NODE_TYPES = KSPROPERTY_BDA_TOPOLOGY.NODE_TYPES;
pub const KSPROPERTY_BDA_PIN_TYPES = KSPROPERTY_BDA_TOPOLOGY.PIN_TYPES;
pub const KSPROPERTY_BDA_TEMPLATE_CONNECTIONS = KSPROPERTY_BDA_TOPOLOGY.TEMPLATE_CONNECTIONS;
pub const KSPROPERTY_BDA_NODE_METHODS = KSPROPERTY_BDA_TOPOLOGY.NODE_METHODS;
pub const KSPROPERTY_BDA_NODE_PROPERTIES = KSPROPERTY_BDA_TOPOLOGY.NODE_PROPERTIES;
pub const KSPROPERTY_BDA_NODE_EVENTS = KSPROPERTY_BDA_TOPOLOGY.NODE_EVENTS;
pub const KSPROPERTY_BDA_CONTROLLING_PIN_ID = KSPROPERTY_BDA_TOPOLOGY.CONTROLLING_PIN_ID;
pub const KSPROPERTY_BDA_NODE_DESCRIPTORS = KSPROPERTY_BDA_TOPOLOGY.NODE_DESCRIPTORS;

const CLSID_KSPROPSETID_BdaPinControl_Value = Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const CLSID_KSPROPSETID_BdaPinControl = &CLSID_KSPROPSETID_BdaPinControl_Value;

pub const KSPROPERTY_BDA_PIN_CONTROL = enum(i32) {
    ID = 0,
    TYPE = 1,
};
pub const KSPROPERTY_BDA_PIN_ID = KSPROPERTY_BDA_PIN_CONTROL.ID;
pub const KSPROPERTY_BDA_PIN_TYPE = KSPROPERTY_BDA_PIN_CONTROL.TYPE;

const CLSID_KSEVENTSETID_BdaPinEvent_Value = Guid.initString("104781cd-50bd-40d5-95fb-087e0e86a591");
pub const CLSID_KSEVENTSETID_BdaPinEvent = &CLSID_KSEVENTSETID_BdaPinEvent_Value;

pub const KSPROPERTY_BDA_PIN_EVENT = enum(i32) {
    CONNECTED = 0,
    DISCONNECTED = 1,
};
pub const KSEVENT_BDA_PIN_CONNECTED = KSPROPERTY_BDA_PIN_EVENT.CONNECTED;
pub const KSEVENT_BDA_PIN_DISCONNECTED = KSPROPERTY_BDA_PIN_EVENT.DISCONNECTED;

const CLSID_KSPROPSETID_BdaVoidTransform_Value = Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaVoidTransform = &CLSID_KSPROPSETID_BdaVoidTransform_Value;

pub const KSPROPERTY_BDA_VOID_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_VOID_TRANSFORM_START = KSPROPERTY_BDA_VOID_TRANSFORM.ART;
pub const KSPROPERTY_BDA_VOID_TRANSFORM_STOP = KSPROPERTY_BDA_VOID_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaNullTransform_Value = Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaNullTransform = &CLSID_KSPROPSETID_BdaNullTransform_Value;

pub const KSPROPERTY_BDA_NULL_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_NULL_TRANSFORM_START = KSPROPERTY_BDA_NULL_TRANSFORM.ART;
pub const KSPROPERTY_BDA_NULL_TRANSFORM_STOP = KSPROPERTY_BDA_NULL_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaFrequencyFilter_Value = Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaFrequencyFilter = &CLSID_KSPROPSETID_BdaFrequencyFilter_Value;

pub const KSPROPERTY_BDA_FREQUENCY_FILTER = enum(i32) {
    FREQUENCY = 0,
    POLARITY = 1,
    RANGE = 2,
    TRANSPONDER = 3,
    BANDWIDTH = 4,
    FREQUENCY_MULTIPLIER = 5,
    CAPS = 6,
    SCAN_STATUS = 7,
    STANDARD = 8,
    STANDARD_MODE = 9,
};
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY;
pub const KSPROPERTY_BDA_RF_TUNER_POLARITY = KSPROPERTY_BDA_FREQUENCY_FILTER.POLARITY;
pub const KSPROPERTY_BDA_RF_TUNER_RANGE = KSPROPERTY_BDA_FREQUENCY_FILTER.RANGE;
pub const KSPROPERTY_BDA_RF_TUNER_TRANSPONDER = KSPROPERTY_BDA_FREQUENCY_FILTER.TRANSPONDER;
pub const KSPROPERTY_BDA_RF_TUNER_BANDWIDTH = KSPROPERTY_BDA_FREQUENCY_FILTER.BANDWIDTH;
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY_MULTIPLIER;
pub const KSPROPERTY_BDA_RF_TUNER_CAPS = KSPROPERTY_BDA_FREQUENCY_FILTER.CAPS;
pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS = KSPROPERTY_BDA_FREQUENCY_FILTER.SCAN_STATUS;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD_MODE;

pub const BDA_SignalType = enum(i32) {
    Unknown = 0,
    Analog = 1,
    Digital = 2,
};
pub const Bda_SignalType_Unknown = BDA_SignalType.Unknown;
pub const Bda_SignalType_Analog = BDA_SignalType.Analog;
pub const Bda_SignalType_Digital = BDA_SignalType.Digital;

pub const BDA_DigitalSignalStandard = enum(i32) {
    None = 0,
    DVB_T = 1,
    DVB_S = 2,
    DVB_C = 4,
    ATSC = 8,
    ISDB_T = 16,
    ISDB_S = 32,
    ISDB_C = 64,
};
pub const Bda_DigitalStandard_None = BDA_DigitalSignalStandard.None;
pub const Bda_DigitalStandard_DVB_T = BDA_DigitalSignalStandard.DVB_T;
pub const Bda_DigitalStandard_DVB_S = BDA_DigitalSignalStandard.DVB_S;
pub const Bda_DigitalStandard_DVB_C = BDA_DigitalSignalStandard.DVB_C;
pub const Bda_DigitalStandard_ATSC = BDA_DigitalSignalStandard.ATSC;
pub const Bda_DigitalStandard_ISDB_T = BDA_DigitalSignalStandard.ISDB_T;
pub const Bda_DigitalStandard_ISDB_S = BDA_DigitalSignalStandard.ISDB_S;
pub const Bda_DigitalStandard_ISDB_C = BDA_DigitalSignalStandard.ISDB_C;

pub const KSPROPERTY_BDA_RF_TUNER_CAPS_S = extern struct {
    Property: KSP_NODE,
    Mode: u32,
    AnalogStandardsSupported: u32,
    DigitalStandardsSupported: u32,
    MinFrequency: u32,
    MaxFrequency: u32,
    SettlingTime: u32,
    AnalogSensingRange: u32,
    DigitalSensingRange: u32,
    MilliSecondsPerMHz: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS_S = extern struct {
    Property: KSP_NODE,
    CurrentFrequency: u32,
    FrequencyRangeMin: u32,
    FrequencyRangeMax: u32,
    MilliSecondsLeft: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_S = extern struct {
    Property: KSP_NODE,
    SignalType: BDA_SignalType,
    SignalStandard: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE_S = extern struct {
    Property: KSP_NODE,
    AutoDetect: BOOL,
};

const CLSID_KSEVENTSETID_BdaTunerEvent_Value = Guid.initString("aab59e17-01c9-4ebf-93f2-fc3b79b46f91");
pub const CLSID_KSEVENTSETID_BdaTunerEvent = &CLSID_KSEVENTSETID_BdaTunerEvent_Value;

pub const KSEVENT_BDA_TUNER = enum(i32) {
    N = 0,
};
pub const KSEVENT_BDA_TUNER_SCAN = KSEVENT_BDA_TUNER.N;

pub const KSEVENTDATA_BDA_RF_TUNER_SCAN_S = extern struct {
    EventData: KSEVENTDATA,
    StartFrequency: u32,
    EndFrequency: u32,
    LockRequested: BDA_LockType,
};

const CLSID_KSPROPSETID_BdaLNBInfo_Value = Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const CLSID_KSPROPSETID_BdaLNBInfo = &CLSID_KSPROPSETID_BdaLNBInfo_Value;

pub const KSPROPERTY_BDA_LNB_INFO = enum(i32) {
    LOF_LOW_BAND = 0,
    LOF_HIGH_BAND = 1,
    SWITCH_FREQUENCY = 2,
};
pub const KSPROPERTY_BDA_LNB_LOF_LOW_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_LOW_BAND;
pub const KSPROPERTY_BDA_LNB_LOF_HIGH_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_HIGH_BAND;
pub const KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY = KSPROPERTY_BDA_LNB_INFO.SWITCH_FREQUENCY;

const CLSID_KSPROPSETID_BdaDiseqCommand_Value = Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const CLSID_KSPROPSETID_BdaDiseqCommand = &CLSID_KSPROPSETID_BdaDiseqCommand_Value;

pub const KSPROPERTY_BDA_DISEQC_COMMAND = enum(i32) {
    ENABLE = 0,
    LNB_SOURCE = 1,
    USETONEBURST = 2,
    REPEATS = 3,
    SEND = 4,
    RESPONSE = 5,
};
pub const KSPROPERTY_BDA_DISEQC_ENABLE = KSPROPERTY_BDA_DISEQC_COMMAND.ENABLE;
pub const KSPROPERTY_BDA_DISEQC_LNB_SOURCE = KSPROPERTY_BDA_DISEQC_COMMAND.LNB_SOURCE;
pub const KSPROPERTY_BDA_DISEQC_USETONEBURST = KSPROPERTY_BDA_DISEQC_COMMAND.USETONEBURST;
pub const KSPROPERTY_BDA_DISEQC_REPEATS = KSPROPERTY_BDA_DISEQC_COMMAND.REPEATS;
pub const KSPROPERTY_BDA_DISEQC_SEND = KSPROPERTY_BDA_DISEQC_COMMAND.SEND;
pub const KSPROPERTY_BDA_DISEQC_RESPONSE = KSPROPERTY_BDA_DISEQC_COMMAND.RESPONSE;

const CLSID_KSEVENTSETID_BdaDiseqCEvent_Value = Guid.initString("8b19bbf0-4184-43ac-ad3c-0c889be4c212");
pub const CLSID_KSEVENTSETID_BdaDiseqCEvent = &CLSID_KSEVENTSETID_BdaDiseqCEvent_Value;

pub const KSPROPERTY_BDA_DISEQC_EVENT = enum(i32) {
    D = 0,
};
pub const KSEVENT_BDA_DISEQC_DATA_RECEIVED = KSPROPERTY_BDA_DISEQC_EVENT.D;

const CLSID_KSPROPSETID_BdaDigitalDemodulator_Value = Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const CLSID_KSPROPSETID_BdaDigitalDemodulator = &CLSID_KSPROPSETID_BdaDigitalDemodulator_Value;

pub const KSPROPERTY_BDA_DIGITAL_DEMODULATOR = enum(i32) {
    MODULATION_TYPE = 0,
    INNER_FEC_TYPE = 1,
    INNER_FEC_RATE = 2,
    OUTER_FEC_TYPE = 3,
    OUTER_FEC_RATE = 4,
    SYMBOL_RATE = 5,
    SPECTRAL_INVERSION = 6,
    GUARD_INTERVAL = 7,
    TRANSMISSION_MODE = 8,
    ROLL_OFF = 9,
    PILOT = 10,
    SIGNALTIMEOUTS = 11,
    PLP_NUMBER = 12,
};
pub const KSPROPERTY_BDA_MODULATION_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.MODULATION_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_RATE;
pub const KSPROPERTY_BDA_OUTER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_TYPE;
pub const KSPROPERTY_BDA_OUTER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_RATE;
pub const KSPROPERTY_BDA_SYMBOL_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SYMBOL_RATE;
pub const KSPROPERTY_BDA_SPECTRAL_INVERSION = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SPECTRAL_INVERSION;
pub const KSPROPERTY_BDA_GUARD_INTERVAL = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.GUARD_INTERVAL;
pub const KSPROPERTY_BDA_TRANSMISSION_MODE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.TRANSMISSION_MODE;
pub const KSPROPERTY_BDA_ROLL_OFF = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.ROLL_OFF;
pub const KSPROPERTY_BDA_PILOT = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PILOT;
pub const KSPROPERTY_BDA_SIGNALTIMEOUTS = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SIGNALTIMEOUTS;
pub const KSPROPERTY_BDA_PLP_NUMBER = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PLP_NUMBER;

const CLSID_KSPROPSETID_BdaAutodemodulate_Value = Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaAutodemodulate = &CLSID_KSPROPSETID_BdaAutodemodulate_Value;

pub const KSPROPERTY_BDA_AUTODEMODULATE = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_AUTODEMODULATE_START = KSPROPERTY_BDA_AUTODEMODULATE.ART;
pub const KSPROPERTY_BDA_AUTODEMODULATE_STOP = KSPROPERTY_BDA_AUTODEMODULATE.OP;

const CLSID_KSPROPSETID_BdaTableSection_Value = Guid.initString("516b99c5-971c-4aaf-b3f3-d9fda8a15e16");
pub const CLSID_KSPROPSETID_BdaTableSection = &CLSID_KSPROPSETID_BdaTableSection_Value;

pub const KSPROPERTY_IDS_BDA_TABLE = enum(i32) {
    N = 0,
};
pub const KSPROPERTY_BDA_TABLE_SECTION = KSPROPERTY_IDS_BDA_TABLE.N;

const CLSID_KSPROPSETID_BdaPIDFilter_Value = Guid.initString("d0a67d65-08df-4fec-8533-e5b550410b85");
pub const CLSID_KSPROPSETID_BdaPIDFilter = &CLSID_KSPROPSETID_BdaPIDFilter_Value;

pub const KSPROPERTY_BDA_PIDFILTER = enum(i32) {
    MAP_PIDS = 0,
    UNMAP_PIDS = 1,
    LIST_PIDS = 2,
};
pub const KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = KSPROPERTY_BDA_PIDFILTER.MAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS = KSPROPERTY_BDA_PIDFILTER.UNMAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_LIST_PIDS = KSPROPERTY_BDA_PIDFILTER.LIST_PIDS;

const CLSID_KSPROPSETID_BdaCA_Value = Guid.initString("b0693766-5278-4ec6-b9e1-3ce40560ef5a");
pub const CLSID_KSPROPSETID_BdaCA = &CLSID_KSPROPSETID_BdaCA_Value;

pub const KSPROPERTY_BDA_CA = enum(i32) {
    ECM_MAP_STATUS = 0,
    CA_MODULE_STATUS = 1,
    CA_SMART_CARD_STATUS = 2,
    CA_MODULE_UI = 3,
    CA_SET_PROGRAM_PIDS = 4,
    CA_REMOVE_PROGRAM = 5,
};
pub const KSPROPERTY_BDA_ECM_MAP_STATUS = KSPROPERTY_BDA_CA.ECM_MAP_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_STATUS = KSPROPERTY_BDA_CA.CA_MODULE_STATUS;
pub const KSPROPERTY_BDA_CA_SMART_CARD_STATUS = KSPROPERTY_BDA_CA.CA_SMART_CARD_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_UI = KSPROPERTY_BDA_CA.CA_MODULE_UI;
pub const KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS = KSPROPERTY_BDA_CA.CA_SET_PROGRAM_PIDS;
pub const KSPROPERTY_BDA_CA_REMOVE_PROGRAM = KSPROPERTY_BDA_CA.CA_REMOVE_PROGRAM;

const CLSID_KSEVENTSETID_BdaCAEvent_Value = Guid.initString("488c4ccc-b768-4129-8eb1-b00a071f9068");
pub const CLSID_KSEVENTSETID_BdaCAEvent = &CLSID_KSEVENTSETID_BdaCAEvent_Value;

pub const KSPROPERTY_BDA_CA_EVENT = enum(i32) {
    PROGRAM_FLOW_STATUS_CHANGED = 0,
    CA_MODULE_STATUS_CHANGED = 1,
    CA_SMART_CARD_STATUS_CHANGED = 2,
    CA_MODULE_UI_REQUESTED = 3,
};
pub const KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.PROGRAM_FLOW_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_SMART_CARD_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_UI_REQUESTED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_UI_REQUESTED;

const CLSID_KSMETHODSETID_BdaDrmService_Value = Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const CLSID_KSMETHODSETID_BdaDrmService = &CLSID_KSMETHODSETID_BdaDrmService_Value;

pub const KSMETHOD_BDA_DRM = enum(i32) {
    CURRENT = 0,
    DRMSTATUS = 1,
};
pub const KSMETHOD_BDA_DRM_CURRENT = KSMETHOD_BDA_DRM.CURRENT;
pub const KSMETHOD_BDA_DRM_DRMSTATUS = KSMETHOD_BDA_DRM.DRMSTATUS;

const CLSID_KSMETHODSETID_BdaWmdrmSession_Value = Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const CLSID_KSMETHODSETID_BdaWmdrmSession = &CLSID_KSMETHODSETID_BdaWmdrmSession_Value;

pub const KSMETHOD_BDA_WMDRM = enum(i32) {
    STATUS = 0,
    REVINFO = 1,
    CRL = 2,
    MESSAGE = 3,
    REISSUELICENSE = 4,
    RENEWLICENSE = 5,
    LICENSE = 6,
    KEYINFO = 7,
};
pub const KSMETHOD_BDA_WMDRM_STATUS = KSMETHOD_BDA_WMDRM.STATUS;
pub const KSMETHOD_BDA_WMDRM_REVINFO = KSMETHOD_BDA_WMDRM.REVINFO;
pub const KSMETHOD_BDA_WMDRM_CRL = KSMETHOD_BDA_WMDRM.CRL;
pub const KSMETHOD_BDA_WMDRM_MESSAGE = KSMETHOD_BDA_WMDRM.MESSAGE;
pub const KSMETHOD_BDA_WMDRM_REISSUELICENSE = KSMETHOD_BDA_WMDRM.REISSUELICENSE;
pub const KSMETHOD_BDA_WMDRM_RENEWLICENSE = KSMETHOD_BDA_WMDRM.RENEWLICENSE;
pub const KSMETHOD_BDA_WMDRM_LICENSE = KSMETHOD_BDA_WMDRM.LICENSE;
pub const KSMETHOD_BDA_WMDRM_KEYINFO = KSMETHOD_BDA_WMDRM.KEYINFO;

const CLSID_KSMETHODSETID_BdaWmdrmTuner_Value = Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const CLSID_KSMETHODSETID_BdaWmdrmTuner = &CLSID_KSMETHODSETID_BdaWmdrmTuner_Value;

pub const KSMETHOD_BDA_WMDRM_TUNER = enum(i32) {
    CANCELCAPTURETOKEN = 0,
    SETPIDPROTECTION = 1,
    GETPIDPROTECTION = 2,
    SETSYNCVALUE = 3,
    STARTCODEPROFILE = 4,
    PURCHASE_ENTITLEMENT = 5,
};
pub const KSMETHOD_BDA_WMDRMTUNER_CANCELCAPTURETOKEN = KSMETHOD_BDA_WMDRM_TUNER.CANCELCAPTURETOKEN;
pub const KSMETHOD_BDA_WMDRMTUNER_SETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.SETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_GETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.GETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_SETSYNCVALUE = KSMETHOD_BDA_WMDRM_TUNER.SETSYNCVALUE;
pub const KSMETHOD_BDA_WMDRMTUNER_STARTCODEPROFILE = KSMETHOD_BDA_WMDRM_TUNER.STARTCODEPROFILE;
pub const KSMETHOD_BDA_WMDRMTUNER_PURCHASE_ENTITLEMENT = KSMETHOD_BDA_WMDRM_TUNER.PURCHASE_ENTITLEMENT;

const CLSID_KSMETHODSETID_BdaEventing_Value = Guid.initString("f99492da-6193-4eb0-8690-6686cbff713e");
pub const CLSID_KSMETHODSETID_BdaEventing = &CLSID_KSMETHODSETID_BdaEventing_Value;

pub const KSMETHOD_BDA_EVENTING_SERVICE = enum(i32) {
    DATA = 0,
    COMPLETE = 1,
};
pub const KSMETHOD_BDA_EVENT_DATA = KSMETHOD_BDA_EVENTING_SERVICE.DATA;
pub const KSMETHOD_BDA_EVENT_COMPLETE = KSMETHOD_BDA_EVENTING_SERVICE.COMPLETE;

const CLSID_KSEVENTSETID_BdaEvent_Value = Guid.initString("ae7e55b2-96d7-4e29-908f-62f95b2a1679");
pub const CLSID_KSEVENTSETID_BdaEvent = &CLSID_KSEVENTSETID_BdaEvent_Value;

pub const KSEVENT_BDA_EVENT_TYPE = enum(i32) {
    T = 0,
};
pub const KSEVENT_BDA_EVENT_PENDINGEVENT = KSEVENT_BDA_EVENT_TYPE.T;

const CLSID_KSMETHODSETID_BdaDebug_Value = Guid.initString("0d4a90ec-c69d-4ee2-8c5a-fb1f63a50da1");
pub const CLSID_KSMETHODSETID_BdaDebug = &CLSID_KSMETHODSETID_BdaDebug_Value;

pub const KSMETHOD_BDA_DEBUG_SERVICE = enum(i32) {
    LEVEL = 0,
    DATA = 1,
};
pub const KSMETHOD_BDA_DEBUG_LEVEL = KSMETHOD_BDA_DEBUG_SERVICE.LEVEL;
pub const KSMETHOD_BDA_DEBUG_DATA = KSMETHOD_BDA_DEBUG_SERVICE.DATA;

const CLSID_KSMETHODSETID_BdaTuner_Value = Guid.initString("b774102f-ac07-478a-8228-2742d961fa7e");
pub const CLSID_KSMETHODSETID_BdaTuner = &CLSID_KSMETHODSETID_BdaTuner_Value;

pub const KSMETHOD_BDA_TUNER_SERVICE = enum(i32) {
    SETTUNER = 0,
    GETTUNERSTATE = 1,
    SIGNALNOISERATIO = 2,
};
pub const KSMETHOD_BDA_TUNER_SETTUNER = KSMETHOD_BDA_TUNER_SERVICE.SETTUNER;
pub const KSMETHOD_BDA_TUNER_GETTUNERSTATE = KSMETHOD_BDA_TUNER_SERVICE.GETTUNERSTATE;
pub const KSMETHOD_BDA_TUNER_SIGNALNOISERATIO = KSMETHOD_BDA_TUNER_SERVICE.SIGNALNOISERATIO;

const CLSID_KSMETHODSETID_BdaNameValueA_Value = Guid.initString("0c24096d-5ff5-47de-a856-062e587e3727");
pub const CLSID_KSMETHODSETID_BdaNameValueA = &CLSID_KSMETHODSETID_BdaNameValueA_Value;

const CLSID_KSMETHODSETID_BdaNameValue_Value = Guid.initString("36e07304-9f0d-4e88-9118-ac0ba317b7f2");
pub const CLSID_KSMETHODSETID_BdaNameValue = &CLSID_KSMETHODSETID_BdaNameValue_Value;

pub const KSMETHOD_BDA_GPNV_SERVICE = enum(i32) {
    GETVALUE = 0,
    SETVALUE = 1,
    NAMEFROMINDEX = 2,
    GETVALUEUPDATENAME = 3,
};
pub const KSMETHOD_BDA_GPNV_GETVALUE = KSMETHOD_BDA_GPNV_SERVICE.GETVALUE;
pub const KSMETHOD_BDA_GPNV_SETVALUE = KSMETHOD_BDA_GPNV_SERVICE.SETVALUE;
pub const KSMETHOD_BDA_GPNV_NAMEFROMINDEX = KSMETHOD_BDA_GPNV_SERVICE.NAMEFROMINDEX;
pub const KSMETHOD_BDA_GPNV_GETVALUEUPDATENAME = KSMETHOD_BDA_GPNV_SERVICE.GETVALUEUPDATENAME;

const CLSID_KSMETHODSETID_BdaMux_Value = Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const CLSID_KSMETHODSETID_BdaMux = &CLSID_KSMETHODSETID_BdaMux_Value;

pub const KSMETHOD_BDA_MUX_SERVICE = enum(i32) {
    GETPIDLIST = 0,
    SETPIDLIST = 1,
};
pub const KSMETHOD_BDA_MUX_GETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.GETPIDLIST;
pub const KSMETHOD_BDA_MUX_SETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.SETPIDLIST;

const CLSID_KSMETHODSETID_BdaScanning_Value = Guid.initString("12eb49df-6249-47f3-b190-e21e6e2f8a9c");
pub const CLSID_KSMETHODSETID_BdaScanning = &CLSID_KSMETHODSETID_BdaScanning_Value;

pub const KSMETHOD_BDA_SCAN_SERVICE = enum(i32) {
    _CAPABILTIES = 0,
    NING_STATE = 1,
    _FILTER = 2,
    _START = 3,
    _RESUME = 4,
    _STOP = 5,
};
pub const KSMETHOD_BDA_SCAN_CAPABILTIES = KSMETHOD_BDA_SCAN_SERVICE._CAPABILTIES;
pub const KSMETHOD_BDA_SCANNING_STATE = KSMETHOD_BDA_SCAN_SERVICE.NING_STATE;
pub const KSMETHOD_BDA_SCAN_FILTER = KSMETHOD_BDA_SCAN_SERVICE._FILTER;
pub const KSMETHOD_BDA_SCAN_START = KSMETHOD_BDA_SCAN_SERVICE._START;
pub const KSMETHOD_BDA_SCAN_RESUME = KSMETHOD_BDA_SCAN_SERVICE._RESUME;
pub const KSMETHOD_BDA_SCAN_STOP = KSMETHOD_BDA_SCAN_SERVICE._STOP;

const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value = Guid.initString("8d9d5562-1589-417d-99ce-ac531dda19f9");
pub const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService = &CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value;

pub const KSMETHOD_BDA_GDDS_SERVICE = enum(i32) {
    DATATYPE = 0,
    DATA = 1,
    TUNEXMLFROMIDX = 2,
    GETSERVICES = 3,
    SERVICEFROMTUNEXML = 4,
    DATAUPDATE = 5,
};
pub const KSMETHOD_BDA_GDDS_DATATYPE = KSMETHOD_BDA_GDDS_SERVICE.DATATYPE;
pub const KSMETHOD_BDA_GDDS_DATA = KSMETHOD_BDA_GDDS_SERVICE.DATA;
pub const KSMETHOD_BDA_GDDS_TUNEXMLFROMIDX = KSMETHOD_BDA_GDDS_SERVICE.TUNEXMLFROMIDX;
pub const KSMETHOD_BDA_GDDS_GETSERVICES = KSMETHOD_BDA_GDDS_SERVICE.GETSERVICES;
pub const KSMETHOD_BDA_GDDS_SERVICEFROMTUNEXML = KSMETHOD_BDA_GDDS_SERVICE.SERVICEFROMTUNEXML;
pub const KSMETHOD_BDA_GDDS_DATAUPDATE = KSMETHOD_BDA_GDDS_SERVICE.DATAUPDATE;

const CLSID_KSMETHODSETID_BdaConditionalAccessService_Value = Guid.initString("10ced3b4-320b-41bf-9824-1b2e68e71eb9");
pub const CLSID_KSMETHODSETID_BdaConditionalAccessService = &CLSID_KSMETHODSETID_BdaConditionalAccessService_Value;

pub const KSMETHOD_BDA_CAS_SERVICE = enum(i32) {
    CHECKENTITLEMENTTOKEN = 0,
    SETCAPTURETOKEN = 1,
    OPENBROADCASTMMI = 2,
    CLOSEMMIDIALOG = 3,
};
pub const KSMETHOD_BDA_CAS_CHECKENTITLEMENTTOKEN = KSMETHOD_BDA_CAS_SERVICE.CHECKENTITLEMENTTOKEN;
pub const KSMETHOD_BDA_CAS_SETCAPTURETOKEN = KSMETHOD_BDA_CAS_SERVICE.SETCAPTURETOKEN;
pub const KSMETHOD_BDA_CAS_OPENBROADCASTMMI = KSMETHOD_BDA_CAS_SERVICE.OPENBROADCASTMMI;
pub const KSMETHOD_BDA_CAS_CLOSEMMIDIALOG = KSMETHOD_BDA_CAS_SERVICE.CLOSEMMIDIALOG;

const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value = Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess = &CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value;

pub const KSMETHOD_BDA_ISDB_CAS = enum(i32) {
    SETREQUEST = 0,
    RESPONSEDATA = 1,
};
pub const KSMETHOD_BDA_ISDBCAS_SETREQUEST = KSMETHOD_BDA_ISDB_CAS.SETREQUEST;
pub const KSMETHOD_BDA_ISDBCAS_RESPONSEDATA = KSMETHOD_BDA_ISDB_CAS.RESPONSEDATA;

const CLSID_KSMETHODSETID_BdaTSSelector_Value = Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const CLSID_KSMETHODSETID_BdaTSSelector = &CLSID_KSMETHODSETID_BdaTSSelector_Value;

pub const KSMETHOD_BDA_TS_SELECTOR = enum(i32) {
    SETTSID = 0,
    GETTSINFORMATION = 1,
};
pub const KSMETHOD_BDA_TS_SELECTOR_SETTSID = KSMETHOD_BDA_TS_SELECTOR.SETTSID;
pub const KSMETHOD_BDA_TS_SELECTOR_GETTSINFORMATION = KSMETHOD_BDA_TS_SELECTOR.GETTSINFORMATION;

const CLSID_KSMETHODSETID_BdaUserActivity_Value = Guid.initString("eda5c834-4531-483c-be0a-94e6c96ff396");
pub const CLSID_KSMETHODSETID_BdaUserActivity = &CLSID_KSMETHODSETID_BdaUserActivity_Value;

pub const KSMETHOD_BDA_USERACTIVITY_SERVICE = enum(i32) {
    USEREASON = 0,
    INTERVAL = 1,
    DETECTED = 2,
};
pub const KSMETHOD_BDA_USERACTIVITY_USEREASON = KSMETHOD_BDA_USERACTIVITY_SERVICE.USEREASON;
pub const KSMETHOD_BDA_USERACTIVITY_INTERVAL = KSMETHOD_BDA_USERACTIVITY_SERVICE.INTERVAL;
pub const KSMETHOD_BDA_USERACTIVITY_DETECTED = KSMETHOD_BDA_USERACTIVITY_SERVICE.DETECTED;

const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value = Guid.initString("fd0a5af4-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT = &CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value = Guid.initString("71985f48-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_TUNER = &CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value = Guid.initString("71985f49-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_EPG = &CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value;

const CLSID_KSCATEGORY_BDA_IP_SINK_Value = Guid.initString("71985f4a-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_IP_SINK = &CLSID_KSCATEGORY_BDA_IP_SINK_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value = Guid.initString("71985f4b-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER = &CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value;

const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value = Guid.initString("a2e3074f-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION = &CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value;

const CLSID_KSNODE_BDA_RF_TUNER_Value = Guid.initString("71985f4c-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_RF_TUNER = &CLSID_KSNODE_BDA_RF_TUNER_Value;

const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value = Guid.initString("634db199-27dd-46b8-acfb-ecc98e61a2ad");
pub const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR = &CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value = Guid.initString("71985f4d-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_QAM_DEMODULATOR = &CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value = Guid.initString("6390c905-27c1-4d67-bdb7-77c50d079300");
pub const CLSID_KSNODE_BDA_QPSK_DEMODULATOR = &CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value = Guid.initString("71985f4f-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_8VSB_DEMODULATOR = &CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value = Guid.initString("2dac6e05-edbe-4b9c-b387-1b6fad7d6495");
pub const CLSID_KSNODE_BDA_COFDM_DEMODULATOR = &CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value = Guid.initString("e957a0e7-dd98-4a3c-810b-3525157ab62e");
pub const CLSID_KSNODE_BDA_8PSK_DEMODULATOR = &CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value = Guid.initString("fcea3ae3-2cb2-464d-8f5d-305c0bb778a2");
pub const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value = Guid.initString("edde230a-9086-432d-b8a5-6670263807e9");
pub const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_OPENCABLE_POD_Value = Guid.initString("345812a0-fb7c-4790-aa7e-b1db88ac19c9");
pub const CLSID_KSNODE_BDA_OPENCABLE_POD = &CLSID_KSNODE_BDA_OPENCABLE_POD_Value;

const CLSID_KSNODE_BDA_COMMON_CA_POD_Value = Guid.initString("d83ef8fc-f3b8-45ab-8b71-ecf7c339deb4");
pub const CLSID_KSNODE_BDA_COMMON_CA_POD = &CLSID_KSNODE_BDA_COMMON_CA_POD_Value;

const CLSID_KSNODE_BDA_PID_FILTER_Value = Guid.initString("f5412789-b0a0-44e1-ae4f-ee999b1b7fbe");
pub const CLSID_KSNODE_BDA_PID_FILTER = &CLSID_KSNODE_BDA_PID_FILTER_Value;

const CLSID_KSNODE_BDA_IP_SINK_Value = Guid.initString("71985f4e-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_IP_SINK = &CLSID_KSNODE_BDA_IP_SINK_Value;

const CLSID_KSNODE_BDA_VIDEO_ENCODER_Value = Guid.initString("d98429e3-65c9-4ac4-93aa-766782833b7a");
pub const CLSID_KSNODE_BDA_VIDEO_ENCODER = &CLSID_KSNODE_BDA_VIDEO_ENCODER_Value;

const CLSID_KSNODE_BDA_PBDA_CAS_Value = Guid.initString("c026869f-7129-4e71-8696-ec8f75299b77");
pub const CLSID_KSNODE_BDA_PBDA_CAS = &CLSID_KSNODE_BDA_PBDA_CAS_Value;

const CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value = Guid.initString("f2cf2ab3-5b9d-40ae-ab7c-4e7ad0bd1c52");
pub const CLSID_KSNODE_BDA_PBDA_ISDBCAS = &CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value;

const CLSID_KSNODE_BDA_PBDA_TUNER_Value = Guid.initString("aa5e8286-593c-4979-9494-46a2a9dfe076");
pub const CLSID_KSNODE_BDA_PBDA_TUNER = &CLSID_KSNODE_BDA_PBDA_TUNER_Value;

const CLSID_KSNODE_BDA_PBDA_MUX_Value = Guid.initString("f88c7787-6678-4f4b-a13e-da09861d682b");
pub const CLSID_KSNODE_BDA_PBDA_MUX = &CLSID_KSNODE_BDA_PBDA_MUX_Value;

const CLSID_KSNODE_BDA_PBDA_DRM_Value = Guid.initString("9eeebd03-eea1-450f-96ae-633e6de63cce");
pub const CLSID_KSNODE_BDA_PBDA_DRM = &CLSID_KSNODE_BDA_PBDA_DRM_Value;

const CLSID_KSNODE_BDA_DRI_DRM_Value = Guid.initString("4f95ad74-cefb-42d2-94a9-68c5b2c1aabe");
pub const CLSID_KSNODE_BDA_DRI_DRM = &CLSID_KSNODE_BDA_DRI_DRM_Value;

const CLSID_KSNODE_BDA_TS_SELECTOR_Value = Guid.initString("5eddf185-fed1-4f45-9685-bbb73c323cfc");
pub const CLSID_KSNODE_BDA_TS_SELECTOR = &CLSID_KSNODE_BDA_TS_SELECTOR_Value;

const CLSID_PINNAME_IPSINK_INPUT_Value = Guid.initString("3fdffa70-ac9a-11d2-8f17-00c04f7971e2");
pub const CLSID_PINNAME_IPSINK_INPUT = &CLSID_PINNAME_IPSINK_INPUT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value = Guid.initString("e25f7b8e-cccc-11d2-8f25-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value = Guid.initString("5a9a213c-db08-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value = Guid.initString("6b891420-db09-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value = Guid.initString("dadd5799-7d5b-4b63-80fb-d1442f26b621");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value = Guid.initString("499856e8-e85b-48ed-9bea-410d0dd4ef81");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value;

const CLSID_PINNAME_MPE_Value = Guid.initString("c1b06d73-1dbb-11d3-8f46-00c04f7971e2");
pub const CLSID_PINNAME_MPE = &CLSID_PINNAME_MPE_Value;

const CLSID_KSDATAFORMAT_TYPE_MPE_Value = Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPE = &CLSID_KSDATAFORMAT_TYPE_MPE_Value;

const CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value = Guid.initString("143827ab-f77b-498d-81ca-5a007aec28bf");
pub const CLSID_DIGITAL_CABLE_NETWORK_TYPE = &CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value;

const CLSID_ANALOG_TV_NETWORK_TYPE_Value = Guid.initString("b820d87e-e0e3-478f-8a38-4e13f7b3df42");
pub const CLSID_ANALOG_TV_NETWORK_TYPE = &CLSID_ANALOG_TV_NETWORK_TYPE_Value;

const CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value = Guid.initString("742ef867-09e1-40a3-82d3-9669ba35325f");
pub const CLSID_ANALOG_AUXIN_NETWORK_TYPE = &CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value;

const CLSID_ANALOG_FM_NETWORK_TYPE_Value = Guid.initString("7728087b-2bb9-4e30-8078-449476e59dbb");
pub const CLSID_ANALOG_FM_NETWORK_TYPE = &CLSID_ANALOG_FM_NETWORK_TYPE_Value;

const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("95037f6f-3ac7-4452-b6c4-45a9ce9292a2");
pub const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_T_NETWORK_TYPE_Value = Guid.initString("fc3855a6-c901-4f2e-aba8-90815afc6c83");
pub const CLSID_ISDB_T_NETWORK_TYPE = &CLSID_ISDB_T_NETWORK_TYPE_Value;

const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("b0a4e6a0-6a1a-4b83-bb5b-903e1d90e6b6");
pub const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE = &CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_S_NETWORK_TYPE_Value = Guid.initString("a1e78202-1459-41b1-9ca9-2a92587a42cc");
pub const CLSID_ISDB_S_NETWORK_TYPE = &CLSID_ISDB_S_NETWORK_TYPE_Value;

const CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value = Guid.initString("c974ddb5-41fe-4b25-9741-92f049f1d5d1");
pub const CLSID_ISDB_CABLE_TV_NETWORK_TYPE = &CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("93b66fb5-93d4-4323-921c-c1f52df61d3f");
pub const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE = &CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("c4f6b31b-c6bf-4759-886f-a7386dca27a0");
pub const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE = &CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("0dad2fdd-5fd7-11d3-8f50-00c04f7971e2");
pub const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("216c62df-6d7f-4e9a-8571-05f14edb766a");
pub const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("9e9e46c6-3aba-4f08-ad0e-cc5ac8148c2b");
pub const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("fa4b375a-45b4-4d45-8440-263957b11623");
pub const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE = &CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value = Guid.initString("dc0c0fe7-0485-4266-b93f-68fbf80ed834");
pub const CLSID_DVB_CABLE_TV_NETWORK_TYPE = &CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_BDA_DEBUG_DATA_AVAILABLE_Value = Guid.initString("69c24f54-9983-497e-b415-282be4c555fb");
pub const CLSID_BDA_DEBUG_DATA_AVAILABLE = &CLSID_BDA_DEBUG_DATA_AVAILABLE_Value;

const CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value = Guid.initString("a806e767-de5c-430c-80bf-a21ebe06c748");
pub const CLSID_BDA_DEBUG_DATA_TYPE_STRING = &CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value;

const CLSID_EVENTID_BDA_IsdbCASResponse_Value = Guid.initString("d4cb1966-41bc-4ced-9a20-fdceac78f70d");
pub const CLSID_EVENTID_BDA_IsdbCASResponse = &CLSID_EVENTID_BDA_IsdbCASResponse_Value;

const CLSID_EVENTID_BDA_CASRequestTuner_Value = Guid.initString("cf39a9d8-f5d3-4685-be57-ed81dba46b27");
pub const CLSID_EVENTID_BDA_CASRequestTuner = &CLSID_EVENTID_BDA_CASRequestTuner_Value;

const CLSID_EVENTID_BDA_CASReleaseTuner_Value = Guid.initString("20c1a16b-441f-49a5-bb5c-e9a04495c6c1");
pub const CLSID_EVENTID_BDA_CASReleaseTuner = &CLSID_EVENTID_BDA_CASReleaseTuner_Value;

const CLSID_EVENTID_BDA_CASOpenMMI_Value = Guid.initString("85dac915-e593-410d-8471-d6812105f28e");
pub const CLSID_EVENTID_BDA_CASOpenMMI = &CLSID_EVENTID_BDA_CASOpenMMI_Value;

const CLSID_EVENTID_BDA_CASCloseMMI_Value = Guid.initString("5d0f550f-de2e-479d-8345-ec0e9557e8a2");
pub const CLSID_EVENTID_BDA_CASCloseMMI = &CLSID_EVENTID_BDA_CASCloseMMI_Value;

const CLSID_EVENTID_BDA_CASBroadcastMMI_Value = Guid.initString("676876f0-1132-404c-a7ca-e72069a9d54f");
pub const CLSID_EVENTID_BDA_CASBroadcastMMI = &CLSID_EVENTID_BDA_CASBroadcastMMI_Value;

const CLSID_EVENTID_BDA_TunerSignalLock_Value = Guid.initString("1872e740-f573-429b-a00e-d9c1e408af09");
pub const CLSID_EVENTID_BDA_TunerSignalLock = &CLSID_EVENTID_BDA_TunerSignalLock_Value;

const CLSID_EVENTID_BDA_TunerNoSignal_Value = Guid.initString("e29b382b-1edd-4930-bc46-682fd72d2dfb");
pub const CLSID_EVENTID_BDA_TunerNoSignal = &CLSID_EVENTID_BDA_TunerNoSignal_Value;

const CLSID_EVENTID_BDA_GPNVValueUpdate_Value = Guid.initString("ff75c68c-f416-4e7e-bf17-6d55c5df1575");
pub const CLSID_EVENTID_BDA_GPNVValueUpdate = &CLSID_EVENTID_BDA_GPNVValueUpdate_Value;

const CLSID_EVENTID_BDA_UpdateDrmStatus_Value = Guid.initString("65a6f681-1462-473b-88ce-cb731427bdb5");
pub const CLSID_EVENTID_BDA_UpdateDrmStatus = &CLSID_EVENTID_BDA_UpdateDrmStatus_Value;

const CLSID_EVENTID_BDA_UpdateScanState_Value = Guid.initString("55702b50-7b49-42b8-a82f-4afb691b0628");
pub const CLSID_EVENTID_BDA_UpdateScanState = &CLSID_EVENTID_BDA_UpdateScanState_Value;

const CLSID_EVENTID_BDA_GuideDataAvailable_Value = Guid.initString("98db717a-478a-4cd4-92d0-95f66b89e5b1");
pub const CLSID_EVENTID_BDA_GuideDataAvailable = &CLSID_EVENTID_BDA_GuideDataAvailable_Value;

const CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value = Guid.initString("a1c3ea2b-175f-4458-b735-507d22db23a6");
pub const CLSID_EVENTID_BDA_GuideServiceInformationUpdated = &CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value;

const CLSID_EVENTID_BDA_GuideDataError_Value = Guid.initString("ac33c448-6f73-4fd7-b341-594c360d8d74");
pub const CLSID_EVENTID_BDA_GuideDataError = &CLSID_EVENTID_BDA_GuideDataError_Value;

const CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value = Guid.initString("efa628f8-1f2c-4b67-9ea5-acf6fa9a1f36");
pub const CLSID_EVENTID_BDA_DiseqCResponseAvailable = &CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value;

const CLSID_EVENTID_BDA_LbigsOpenConnection_Value = Guid.initString("356207b2-6f31-4eb0-a271-b3fa6bb7680f");
pub const CLSID_EVENTID_BDA_LbigsOpenConnection = &CLSID_EVENTID_BDA_LbigsOpenConnection_Value;

const CLSID_EVENTID_BDA_LbigsSendData_Value = Guid.initString("1123277b-f1c6-4154-8b0d-48e6157059aa");
pub const CLSID_EVENTID_BDA_LbigsSendData = &CLSID_EVENTID_BDA_LbigsSendData_Value;

const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value = Guid.initString("c2f08b99-65ef-4314-9671-e99d4cce0bae");
pub const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle = &CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value;

const CLSID_EVENTID_BDA_EncoderSignalLock_Value = Guid.initString("5ec90eb9-39fa-4cfc-b93f-00bb11077f5e");
pub const CLSID_EVENTID_BDA_EncoderSignalLock = &CLSID_EVENTID_BDA_EncoderSignalLock_Value;

const CLSID_EVENTID_BDA_FdcStatus_Value = Guid.initString("05f25366-d0eb-43d2-bc3c-682b863df142");
pub const CLSID_EVENTID_BDA_FdcStatus = &CLSID_EVENTID_BDA_FdcStatus_Value;

const CLSID_EVENTID_BDA_FdcTableSection_Value = Guid.initString("6a0cd757-4ce3-4e5b-9444-7187b87152c5");
pub const CLSID_EVENTID_BDA_FdcTableSection = &CLSID_EVENTID_BDA_FdcTableSection_Value;

const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value = Guid.initString("c40f9f85-09d0-489c-9e9c-0abbb56951b0");
pub const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo = &CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value;

const CLSID_EVENTID_BDA_RatingPinReset_Value = Guid.initString("c6e048c0-c574-4c26-bcda-2f4d35eb5e85");
pub const CLSID_EVENTID_BDA_RatingPinReset = &CLSID_EVENTID_BDA_RatingPinReset_Value;

const CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value = Guid.initString("1e1d7141-583f-4ac2-b019-1f430eda0f4c");
pub const CLSID_PBDA_ALWAYS_TUNE_IN_MUX = &CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value;

pub const PID_BITS = extern struct {
    _bitfield: u16 align(1),
};

pub const MPEG_HEADER_BITS = extern struct {
    _bitfield: u16 align(1),
};

pub const MPEG_HEADER_VERSION_BITS = extern struct {
    _bitfield: u8,
};

const CLSID_BDANETWORKTYPE_ATSC_Value = Guid.initString("71985f51-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_BDANETWORKTYPE_ATSC = &CLSID_BDANETWORKTYPE_ATSC_Value;

pub const MPEG1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX align(1),
    fwHeadLayer: u16 align(1),
    dwHeadBitrate: u32 align(1),
    fwHeadMode: u16 align(1),
    fwHeadModeExt: u16 align(1),
    wHeadEmphasis: u16 align(1),
    fwHeadFlags: u16 align(1),
    dwPTSLow: u32 align(1),
    dwPTSHigh: u32 align(1),
};

pub const MPEGLAYER3WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX align(1),
    wID: u16 align(1),
    fdwFlags: MPEGLAYER3WAVEFORMAT_FLAGS align(1),
    nBlockSize: u16 align(1),
    nFramesPerBlock: u16 align(1),
    nCodecDelay: u16 align(1),
};

pub const HEAACWAVEINFO = extern struct {
    wfx: WAVEFORMATEX align(1),
    wPayloadType: u16 align(1),
    wAudioProfileLevelIndication: u16 align(1),
    wStructType: u16 align(1),
    wReserved1: u16 align(1),
    dwReserved2: u32 align(1),
};

pub const HEAACWAVEFORMAT = extern struct {
    wfInfo: HEAACWAVEINFO,
    pbAudioSpecificConfig: [1]u8,
};

pub const VIDEOENCODER_BITRATE_MODE = enum(i32) {
    ConstantBitRate = 0,
    VariableBitRateAverage = 1,
    VariableBitRatePeak = 2,
};
pub const ConstantBitRate = VIDEOENCODER_BITRATE_MODE.ConstantBitRate;
pub const VariableBitRateAverage = VIDEOENCODER_BITRATE_MODE.VariableBitRateAverage;
pub const VariableBitRatePeak = VIDEOENCODER_BITRATE_MODE.VariableBitRatePeak;

pub const DXVA_COPPSetProtectionLevelCmdData = extern struct {
    ProtType: u32,
    ProtLevel: u32,
    ExtendedInfoChangeMask: u32,
    ExtendedInfoData: u32,
};

pub const COPP_HDCP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    // LevelMax = 1, this enum value conflicts with Level1
    ForceDWORD = 2147483647,
};
pub const COPP_HDCP_Level0 = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_LevelMin = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_Level1 = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_LevelMax = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_ForceDWORD = COPP_HDCP_Protection_Level.ForceDWORD;

pub const COPP_CGMSA_Protection_Level = enum(i32) {
    Disabled = 0,
    // LevelMin = 0, this enum value conflicts with Disabled
    CopyFreely = 1,
    CopyNoMore = 2,
    CopyOneGeneration = 3,
    CopyNever = 4,
    RedistributionControlRequired = 8,
    LevelMax = 12,
    ForceDWORD = 2147483647,
};
pub const COPP_CGMSA_Disabled = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_LevelMin = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_CopyFreely = COPP_CGMSA_Protection_Level.CopyFreely;
pub const COPP_CGMSA_CopyNoMore = COPP_CGMSA_Protection_Level.CopyNoMore;
pub const COPP_CGMSA_CopyOneGeneration = COPP_CGMSA_Protection_Level.CopyOneGeneration;
pub const COPP_CGMSA_CopyNever = COPP_CGMSA_Protection_Level.CopyNever;
pub const COPP_CGMSA_RedistributionControlRequired = COPP_CGMSA_Protection_Level.RedistributionControlRequired;
pub const COPP_CGMSA_LevelMax = COPP_CGMSA_Protection_Level.LevelMax;
pub const COPP_CGMSA_ForceDWORD = COPP_CGMSA_Protection_Level.ForceDWORD;

pub const COPP_ACP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    Level2 = 2,
    Level3 = 3,
    // LevelMax = 3, this enum value conflicts with Level3
    ForceDWORD = 2147483647,
};
pub const COPP_ACP_Level0 = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_LevelMin = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_Level1 = COPP_ACP_Protection_Level.Level1;
pub const COPP_ACP_Level2 = COPP_ACP_Protection_Level.Level2;
pub const COPP_ACP_Level3 = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_LevelMax = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_ForceDWORD = COPP_ACP_Protection_Level.ForceDWORD;

pub const DXVA_COPPSetSignalingCmdData = extern struct {
    ActiveTVProtectionStandard: u32,
    AspectRatioChangeMask1: u32,
    AspectRatioData1: u32,
    AspectRatioChangeMask2: u32,
    AspectRatioData2: u32,
    AspectRatioChangeMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoChangeMask: [4]u32,
    ExtendedInfoData: [4]u32,
    Reserved: u32,
};

pub const COPP_TVProtectionStandard = enum(i32) {
    Unknown = -2147483648,
    None = 0,
    IEC61880_525i = 1,
    IEC61880_2_525i = 2,
    IEC62375_625p = 4,
    EIA608B_525 = 8,
    EN300294_625i = 16,
    CEA805A_TypeA_525p = 32,
    CEA805A_TypeA_750p = 64,
    CEA805A_TypeA_1125i = 128,
    CEA805A_TypeB_525p = 256,
    CEA805A_TypeB_750p = 512,
    CEA805A_TypeB_1125i = 1024,
    ARIBTRB15_525i = 2048,
    ARIBTRB15_525p = 4096,
    ARIBTRB15_750p = 8192,
    ARIBTRB15_1125i = 16384,
    Mask = -2147450881,
    Reserved = 2147450880,
};
pub const COPP_ProtectionStandard_Unknown = COPP_TVProtectionStandard.Unknown;
pub const COPP_ProtectionStandard_None = COPP_TVProtectionStandard.None;
pub const COPP_ProtectionStandard_IEC61880_525i = COPP_TVProtectionStandard.IEC61880_525i;
pub const COPP_ProtectionStandard_IEC61880_2_525i = COPP_TVProtectionStandard.IEC61880_2_525i;
pub const COPP_ProtectionStandard_IEC62375_625p = COPP_TVProtectionStandard.IEC62375_625p;
pub const COPP_ProtectionStandard_EIA608B_525 = COPP_TVProtectionStandard.EIA608B_525;
pub const COPP_ProtectionStandard_EN300294_625i = COPP_TVProtectionStandard.EN300294_625i;
pub const COPP_ProtectionStandard_CEA805A_TypeA_525p = COPP_TVProtectionStandard.CEA805A_TypeA_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_750p = COPP_TVProtectionStandard.CEA805A_TypeA_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_1125i = COPP_TVProtectionStandard.CEA805A_TypeA_1125i;
pub const COPP_ProtectionStandard_CEA805A_TypeB_525p = COPP_TVProtectionStandard.CEA805A_TypeB_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_750p = COPP_TVProtectionStandard.CEA805A_TypeB_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_1125i = COPP_TVProtectionStandard.CEA805A_TypeB_1125i;
pub const COPP_ProtectionStandard_ARIBTRB15_525i = COPP_TVProtectionStandard.ARIBTRB15_525i;
pub const COPP_ProtectionStandard_ARIBTRB15_525p = COPP_TVProtectionStandard.ARIBTRB15_525p;
pub const COPP_ProtectionStandard_ARIBTRB15_750p = COPP_TVProtectionStandard.ARIBTRB15_750p;
pub const COPP_ProtectionStandard_ARIBTRB15_1125i = COPP_TVProtectionStandard.ARIBTRB15_1125i;
pub const COPP_ProtectionStandard_Mask = COPP_TVProtectionStandard.Mask;
pub const COPP_ProtectionStandard_Reserved = COPP_TVProtectionStandard.Reserved;

pub const COPP_ImageAspectRatio_EN300294 = enum(i32) {
    EN300294_FullFormat4by3 = 0,
    EN300294_Box14by9Center = 1,
    EN300294_Box14by9Top = 2,
    EN300294_Box16by9Center = 3,
    EN300294_Box16by9Top = 4,
    EN300294_BoxGT16by9Center = 5,
    EN300294_FullFormat4by3ProtectedCenter = 6,
    EN300294_FullFormat16by9Anamorphic = 7,
    ForceDWORD = 2147483647,
};
pub const COPP_AspectRatio_EN300294_FullFormat4by3 = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3;
pub const COPP_AspectRatio_EN300294_Box14by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Center;
pub const COPP_AspectRatio_EN300294_Box14by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Top;
pub const COPP_AspectRatio_EN300294_Box16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Center;
pub const COPP_AspectRatio_EN300294_Box16by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Top;
pub const COPP_AspectRatio_EN300294_BoxGT16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_BoxGT16by9Center;
pub const COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3ProtectedCenter;
pub const COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat16by9Anamorphic;
pub const COPP_AspectRatio_ForceDWORD = COPP_ImageAspectRatio_EN300294.ForceDWORD;

pub const COPP_StatusFlags = enum(i32) {
    StatusNormal = 0,
    LinkLost = 1,
    RenegotiationRequired = 2,
    StatusFlagsReserved = -4,
};
pub const COPP_StatusNormal = COPP_StatusFlags.StatusNormal;
pub const COPP_LinkLost = COPP_StatusFlags.LinkLost;
pub const COPP_RenegotiationRequired = COPP_StatusFlags.RenegotiationRequired;
pub const COPP_StatusFlagsReserved = COPP_StatusFlags.StatusFlagsReserved;

pub const DXVA_COPPStatusData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwData: u32,
    ExtendedInfoValidMask: u32,
    ExtendedInfoData: u32,
};

pub const DXVA_COPPStatusDisplayData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    DisplayWidth: u32,
    DisplayHeight: u32,
    Format: u32,
    d3dFormat: u32,
    FreqNumerator: u32,
    FreqDenominator: u32,
};

pub const COPP_StatusHDCPFlags = enum(i32) {
    Repeater = 1,
    FlagsReserved = -2,
};
pub const COPP_HDCPRepeater = COPP_StatusHDCPFlags.Repeater;
pub const COPP_HDCPFlagsReserved = COPP_StatusHDCPFlags.FlagsReserved;

pub const DXVA_COPPStatusHDCPKeyData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwHDCPFlags: u32,
    BKey: Guid,
    Reserved1: Guid,
    Reserved2: Guid,
};

pub const COPP_ConnectorType = enum(i32) {
    Unknown = -1,
    VGA = 0,
    SVideo = 1,
    CompositeVideo = 2,
    ComponentVideo = 3,
    DVI = 4,
    HDMI = 5,
    LVDS = 6,
    TMDS = 7,
    D_JPN = 8,
    Internal = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_ConnectorType_Unknown = COPP_ConnectorType.Unknown;
pub const COPP_ConnectorType_VGA = COPP_ConnectorType.VGA;
pub const COPP_ConnectorType_SVideo = COPP_ConnectorType.SVideo;
pub const COPP_ConnectorType_CompositeVideo = COPP_ConnectorType.CompositeVideo;
pub const COPP_ConnectorType_ComponentVideo = COPP_ConnectorType.ComponentVideo;
pub const COPP_ConnectorType_DVI = COPP_ConnectorType.DVI;
pub const COPP_ConnectorType_HDMI = COPP_ConnectorType.HDMI;
pub const COPP_ConnectorType_LVDS = COPP_ConnectorType.LVDS;
pub const COPP_ConnectorType_TMDS = COPP_ConnectorType.TMDS;
pub const COPP_ConnectorType_D_JPN = COPP_ConnectorType.D_JPN;
pub const COPP_ConnectorType_Internal = COPP_ConnectorType.Internal;
pub const COPP_ConnectorType_ForceDWORD = COPP_ConnectorType.ForceDWORD;

pub const COPP_BusType = enum(i32) {
    Unknown = 0,
    PCI = 1,
    PCIX = 2,
    PCIExpress = 3,
    AGP = 4,
    Integrated = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_BusType_Unknown = COPP_BusType.Unknown;
pub const COPP_BusType_PCI = COPP_BusType.PCI;
pub const COPP_BusType_PCIX = COPP_BusType.PCIX;
pub const COPP_BusType_PCIExpress = COPP_BusType.PCIExpress;
pub const COPP_BusType_AGP = COPP_BusType.AGP;
pub const COPP_BusType_Integrated = COPP_BusType.Integrated;
pub const COPP_BusType_ForceDWORD = COPP_BusType.ForceDWORD;

pub const DXVA_COPPStatusSignalingCmdData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    AvailableTVProtectionStandards: u32,
    ActiveTVProtectionStandard: u32,
    TVType: u32,
    AspectRatioValidMask1: u32,
    AspectRatioData1: u32,
    AspectRatioValidMask2: u32,
    AspectRatioData2: u32,
    AspectRatioValidMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoValidMask: [4]u32,
    ExtendedInfoData: [4]u32,
};

//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
pub extern "quartz" fn AMGetErrorTextA(
    hr: HRESULT,
    pbuffer: [*:0]u8,
    max_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "quartz" fn AMGetErrorTextW(
    hr: HRESULT,
    pbuffer: [*:0]u16,
    max_len: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (2)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCA;
        pub const AMGetErrorText = thismodule.AMGetErrorTextA;
    },
    .wide => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCW;
        pub const AMGetErrorText = thismodule.AMGetErrorTextW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const AMGETERRORTEXTPROC = *opaque {};
        pub const AMGetErrorText = *opaque {};
    } else struct {
        pub const AMGETERRORTEXTPROC = @compileError("'AMGETERRORTEXTPROC' requires that UNICODE be set to true or false in the root module");
        pub const AMGetErrorText = @compileError("'AMGetErrorText' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (79)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BITMAPINFO = @import("../graphics/gdi.zig").BITMAPINFO;
const BITMAPINFOHEADER = @import("../graphics/gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const CAUUID = @import("../system/ole.zig").CAUUID;
const CHAR = @import("../foundation.zig").CHAR;
const D3DFORMAT = @import("../graphics/direct3d9.zig").D3DFORMAT;
const D3DPOOL = @import("../graphics/direct3d9.zig").D3DPOOL;
const DDCAPS_DX7 = @import("../graphics/direct_draw.zig").DDCAPS_DX7;
const DDCOLORCONTROL = @import("../graphics/direct_draw.zig").DDCOLORCONTROL;
const DDCOLORKEY = @import("../graphics/direct_draw.zig").DDCOLORKEY;
const DDPIXELFORMAT = @import("../graphics/direct_draw.zig").DDPIXELFORMAT;
const DDSCAPS2 = @import("../graphics/direct_draw.zig").DDSCAPS2;
const DDSURFACEDESC = @import("../graphics/direct_draw.zig").DDSURFACEDESC;
const DDVIDEOPORTCONNECT = @import("../graphics/direct_draw.zig").DDVIDEOPORTCONNECT;
const DXVA2_AYUVSample16 = @import("../media/media_foundation.zig").DXVA2_AYUVSample16;
const DXVA2_AYUVSample8 = @import("../media/media_foundation.zig").DXVA2_AYUVSample8;
const DXVA2_ExtendedFormat = @import("../media/media_foundation.zig").DXVA2_ExtendedFormat;
const DXVA2_FilterValues = @import("../media/media_foundation.zig").DXVA2_FilterValues;
const DXVA2_Fixed32 = @import("../media/media_foundation.zig").DXVA2_Fixed32;
const DXVA2_ProcAmpValues = @import("../media/media_foundation.zig").DXVA2_ProcAmpValues;
const DXVA2_ValueRange = @import("../media/media_foundation.zig").DXVA2_ValueRange;
const DXVA2_VideoDesc = @import("../media/media_foundation.zig").DXVA2_VideoDesc;
const DXVA2_VideoProcessorCaps = @import("../media/media_foundation.zig").DXVA2_VideoProcessorCaps;
const EVENT_TRACE_HEADER = @import("../system/diagnostics/etw.zig").EVENT_TRACE_HEADER;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HKEY = @import("../system/registry.zig").HKEY;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IBindCtx = @import("../system/com.zig").IBindCtx;
const IDirect3DDevice9 = @import("../graphics/direct3d9.zig").IDirect3DDevice9;
const IDirect3DSurface9 = @import("../graphics/direct3d9.zig").IDirect3DSurface9;
const IDirectDraw = @import("../graphics/direct_draw.zig").IDirectDraw;
const IDirectDraw7 = @import("../graphics/direct_draw.zig").IDirectDraw7;
const IDirectDrawPalette = @import("../graphics/direct_draw.zig").IDirectDrawPalette;
const IDirectDrawSurface = @import("../graphics/direct_draw.zig").IDirectDrawSurface;
const IDirectDrawSurface7 = @import("../graphics/direct_draw.zig").IDirectDrawSurface7;
const IDirectSound = @import("../media/audio/direct_sound.zig").IDirectSound;
const IDirectSoundBuffer = @import("../media/audio/direct_sound.zig").IDirectSoundBuffer;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumMoniker = @import("../system/com.zig").IEnumMoniker;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IErrorLog = @import("../system/com.zig").IErrorLog;
const IMFVideoPresenter = @import("../media/media_foundation.zig").IMFVideoPresenter;
const IMoniker = @import("../system/com.zig").IMoniker;
const IPersist = @import("../system/com.zig").IPersist;
const IPictureDisp = @import("../system/ole.zig").IPictureDisp;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IReferenceClock = @import("../media.zig").IReferenceClock;
const IUnknown = @import("../system/com.zig").IUnknown;
const IWMProfile = @import("../media/windows_media_format.zig").IWMProfile;
const KSDATAFORMAT = @import("../media/kernel_streaming.zig").KSDATAFORMAT;
const KSEVENTDATA = @import("../media/kernel_streaming.zig").KSEVENTDATA;
const KSIDENTIFIER = @import("../media/kernel_streaming.zig").KSIDENTIFIER;
const KSM_NODE = @import("../media/kernel_streaming.zig").KSM_NODE;
const KSP_NODE = @import("../media/kernel_streaming.zig").KSP_NODE;
const KSTOPOLOGY_CONNECTION = @import("../media/kernel_streaming.zig").KSTOPOLOGY_CONNECTION;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PALETTEENTRY = @import("../graphics/gdi.zig").PALETTEENTRY;
const PAPCFUNC = @import("../foundation.zig").PAPCFUNC;
const POINT = @import("../foundation.zig").POINT;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RGBQUAD = @import("../graphics/gdi.zig").RGBQUAD;
const RGNDATA = @import("../graphics/gdi.zig").RGNDATA;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SIZE = @import("../foundation.zig").SIZE;
const TIMECODE = @import("../media.zig").TIMECODE;
const TIMECODE_SAMPLE = @import("../media.zig").TIMECODE_SAMPLE;
const VARIANT = @import("../system/com.zig").VARIANT;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCA")) {
        _ = AMGETERRORTEXTPROCA;
    }
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCW")) {
        _ = AMGETERRORTEXTPROCW;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT")) {
        _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS")) {
        _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORCAPS")) {
        _ = PDXVA2SW_GETVIDEOPROCESSORCAPS;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT")) {
        _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS")) {
        _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETPROCAMPRANGE")) {
        _ = PDXVA2SW_GETPROCAMPRANGE;
    }
    if (@hasDecl(@This(), "PDXVA2SW_GETFILTERPROPERTYRANGE")) {
        _ = PDXVA2SW_GETFILTERPROPERTYRANGE;
    }
    if (@hasDecl(@This(), "PDXVA2SW_CREATEVIDEOPROCESSDEVICE")) {
        _ = PDXVA2SW_CREATEVIDEOPROCESSDEVICE;
    }
    if (@hasDecl(@This(), "PDXVA2SW_DESTROYVIDEOPROCESSDEVICE")) {
        _ = PDXVA2SW_DESTROYVIDEOPROCESSDEVICE;
    }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBEGINFRAME")) {
        _ = PDXVA2SW_VIDEOPROCESSBEGINFRAME;
    }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSENDFRAME")) {
        _ = PDXVA2SW_VIDEOPROCESSENDFRAME;
    }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSSETRENDERTARGET")) {
        _ = PDXVA2SW_VIDEOPROCESSSETRENDERTARGET;
    }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBLT")) {
        _ = PDXVA2SW_VIDEOPROCESSBLT;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const xml = @import("direct_show/xml.zig");
