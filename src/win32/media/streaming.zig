//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (16)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFDeviceTransform_Value = Guid.initString("d818fbd8-fc46-42f2-87ac-1ea2d1f9bf32");
pub const IID_IMFDeviceTransform = &IID_IMFDeviceTransform_Value;
pub const IMFDeviceTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeTransform: *const fn (
            self: *const IMFDeviceTransform,
            p_attributes: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputAvailableType: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_stream_i_d: u32,
            dw_type_index: u32,
            p_media_type: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCurrentType: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_stream_i_d: u32,
            p_media_type: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamAttributes: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_stream_i_d: u32,
            pp_attributes: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputAvailableType: *const fn (
            self: *const IMFDeviceTransform,
            dw_output_stream_i_d: u32,
            dw_type_index: u32,
            p_media_type: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCurrentType: *const fn (
            self: *const IMFDeviceTransform,
            dw_output_stream_i_d: u32,
            p_media_type: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamAttributes: *const fn (
            self: *const IMFDeviceTransform,
            dw_output_stream_i_d: u32,
            pp_attributes: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamCount: *const fn (
            self: *const IMFDeviceTransform,
            pc_input_streams: ?*u32,
            pc_output_streams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamIDs: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_i_d_array_size: u32,
            pdw_input_stream_ids: ?*u32,
            dw_output_i_d_array_size: u32,
            pdw_output_stream_ids: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessEvent: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_stream_i_d: u32,
            p_event: ?*IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessInput: *const fn (
            self: *const IMFDeviceTransform,
            dw_input_stream_i_d: u32,
            p_sample: ?*IMFSample,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMessage: *const fn (
            self: *const IMFDeviceTransform,
            e_message: MFT_MESSAGE_TYPE,
            ul_param: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessOutput: *const fn (
            self: *const IMFDeviceTransform,
            dw_flags: u32,
            c_output_buffer_count: u32,
            p_output_sample: ?*MFT_OUTPUT_DATA_BUFFER,
            pdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputStreamState: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_i_d: u32,
            p_media_type: ?*IMFMediaType,
            value: DeviceStreamState,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamState: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_i_d: u32,
            value: ?*DeviceStreamState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputStreamState: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_i_d: u32,
            p_media_type: ?*IMFMediaType,
            value: DeviceStreamState,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamState: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_i_d: u32,
            value: ?*DeviceStreamState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamPreferredState: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_i_d: u32,
            value: ?*DeviceStreamState,
            pp_media_type: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushInputStream: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_index: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushOutputStream: *const fn (
            self: *const IMFDeviceTransform,
            dw_stream_index: u32,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initializeTransform(self: *const T, p_attributes_: ?*IMFAttributes) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).InitializeTransform(@as(*const IMFDeviceTransform, @ptrCast(self)), p_attributes_);
            }
            pub inline fn getInputAvailableType(self: *const T, dw_input_stream_i_d_: u32, dw_type_index_: u32, p_media_type_: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputAvailableType(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_stream_i_d_, dw_type_index_, p_media_type_);
            }
            pub inline fn getInputCurrentType(self: *const T, dw_input_stream_i_d_: u32, p_media_type_: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputCurrentType(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_stream_i_d_, p_media_type_);
            }
            pub inline fn getInputStreamAttributes(self: *const T, dw_input_stream_i_d_: u32, pp_attributes_: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamAttributes(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_stream_i_d_, pp_attributes_);
            }
            pub inline fn getOutputAvailableType(self: *const T, dw_output_stream_i_d_: u32, dw_type_index_: u32, p_media_type_: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputAvailableType(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_output_stream_i_d_, dw_type_index_, p_media_type_);
            }
            pub inline fn getOutputCurrentType(self: *const T, dw_output_stream_i_d_: u32, p_media_type_: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputCurrentType(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_output_stream_i_d_, p_media_type_);
            }
            pub inline fn getOutputStreamAttributes(self: *const T, dw_output_stream_i_d_: u32, pp_attributes_: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamAttributes(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_output_stream_i_d_, pp_attributes_);
            }
            pub inline fn getStreamCount(self: *const T, pc_input_streams_: ?*u32, pc_output_streams_: ?*u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFDeviceTransform, @ptrCast(self)), pc_input_streams_, pc_output_streams_);
            }
            pub inline fn getStreamIDs(self: *const T, dw_input_i_d_array_size_: u32, pdw_input_stream_ids_: ?*u32, dw_output_i_d_array_size_: u32, pdw_output_stream_ids_: ?*u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetStreamIDs(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_i_d_array_size_, pdw_input_stream_ids_, dw_output_i_d_array_size_, pdw_output_stream_ids_);
            }
            pub inline fn processEvent(self: *const T, dw_input_stream_i_d_: u32, p_event_: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessEvent(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_stream_i_d_, p_event_);
            }
            pub inline fn processInput(self: *const T, dw_input_stream_i_d_: u32, p_sample_: ?*IMFSample, dw_flags_: u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessInput(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_input_stream_i_d_, p_sample_, dw_flags_);
            }
            pub inline fn processMessage(self: *const T, e_message_: MFT_MESSAGE_TYPE, ul_param_: usize) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessMessage(@as(*const IMFDeviceTransform, @ptrCast(self)), e_message_, ul_param_);
            }
            pub inline fn processOutput(self: *const T, dw_flags_: u32, c_output_buffer_count_: u32, p_output_sample_: ?*MFT_OUTPUT_DATA_BUFFER, pdw_status_: ?*u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessOutput(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_flags_, c_output_buffer_count_, p_output_sample_, pdw_status_);
            }
            pub inline fn setInputStreamState(self: *const T, dw_stream_i_d_: u32, p_media_type_: ?*IMFMediaType, value_: DeviceStreamState, dw_flags_: u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).SetInputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_i_d_, p_media_type_, value_, dw_flags_);
            }
            pub inline fn getInputStreamState(self: *const T, dw_stream_i_d_: u32, value_: ?*DeviceStreamState) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_i_d_, value_);
            }
            pub inline fn setOutputStreamState(self: *const T, dw_stream_i_d_: u32, p_media_type_: ?*IMFMediaType, value_: DeviceStreamState, dw_flags_: u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).SetOutputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_i_d_, p_media_type_, value_, dw_flags_);
            }
            pub inline fn getOutputStreamState(self: *const T, dw_stream_i_d_: u32, value_: ?*DeviceStreamState) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_i_d_, value_);
            }
            pub inline fn getInputStreamPreferredState(self: *const T, dw_stream_i_d_: u32, value_: ?*DeviceStreamState, pp_media_type_: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamPreferredState(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_i_d_, value_, pp_media_type_);
            }
            pub inline fn flushInputStream(self: *const T, dw_stream_index_: u32, dw_flags_: u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).FlushInputStream(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_index_, dw_flags_);
            }
            pub inline fn flushOutputStream(self: *const T, dw_stream_index_: u32, dw_flags_: u32) HRESULT {
                return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).FlushOutputStream(@as(*const IMFDeviceTransform, @ptrCast(self)), dw_stream_index_, dw_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IMFDeviceTransformCallback_Value = Guid.initString("6d5cb646-29ec-41fb-8179-8c4c6d750811");
pub const IID_IMFDeviceTransformCallback = &IID_IMFDeviceTransformCallback_Value;
pub const IMFDeviceTransformCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBufferSent: *const fn (
            self: *const IMFDeviceTransformCallback,
            p_callback_attributes: ?*IMFAttributes,
            pin_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onBufferSent(self: *const T, p_callback_attributes_: ?*IMFAttributes, pin_id_: u32) HRESULT {
                return @as(*const IMFDeviceTransformCallback.VTable, @ptrCast(self.vtable)).OnBufferSent(@as(*const IMFDeviceTransformCallback, @ptrCast(self)), p_callback_attributes_, pin_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TRANSFER_VIDEO_FRAME_FLAGS = enum(i32) {
    DEFAULT = 0,
    STRETCH = 1,
    IGNORE_PAR = 2,
};
pub const MF_TRANSFER_VIDEO_FRAME_DEFAULT = MF_TRANSFER_VIDEO_FRAME_FLAGS.DEFAULT;
pub const MF_TRANSFER_VIDEO_FRAME_STRETCH = MF_TRANSFER_VIDEO_FRAME_FLAGS.STRETCH;
pub const MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR = MF_TRANSFER_VIDEO_FRAME_FLAGS.IGNORE_PAR;

pub const MF_MEDIASOURCE_STATUS_INFO = enum(i32) {
    FULLYSUPPORTED = 0,
    UNKNOWN = 1,
};
pub const MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED = MF_MEDIASOURCE_STATUS_INFO.FULLYSUPPORTED;
pub const MF_MEDIASOURCE_STATUS_INFO_UNKNOWN = MF_MEDIASOURCE_STATUS_INFO.UNKNOWN;

pub const FaceRectInfoBlobHeader = extern struct {
    Size: u32,
    Count: u32,
};

pub const FaceRectInfo = extern struct {
    Region: RECT,
    confidenceLevel: i32,
};

pub const FaceCharacterizationBlobHeader = extern struct {
    Size: u32,
    Count: u32,
};

pub const FaceCharacterization = extern struct {
    BlinkScoreLeft: u32,
    BlinkScoreRight: u32,
    FacialExpression: u32,
    FacialExpressionScore: u32,
};

pub const CapturedMetadataExposureCompensation = extern struct {
    Flags: u64,
    Value: i32,
};

pub const CapturedMetadataISOGains = extern struct {
    AnalogGain: f32,
    DigitalGain: f32,
};

pub const CapturedMetadataWhiteBalanceGains = extern struct {
    R: f32,
    G: f32,
    B: f32,
};

pub const MetadataTimeStamps = extern struct {
    Flags: u32,
    Device: i64,
    Presentation: i64,
};

pub const HistogramGrid = extern struct {
    Width: u32,
    Height: u32,
    Region: RECT,
};

pub const HistogramBlobHeader = extern struct {
    Size: u32,
    Histograms: u32,
};

pub const HistogramHeader = extern struct {
    Size: u32,
    Bins: u32,
    FourCC: u32,
    ChannelMasks: u32,
    Grid: HistogramGrid,
};

pub const HistogramDataHeader = extern struct {
    Size: u32,
    ChannelMask: u32,
    Linear: u32,
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const DeviceStreamState = @import("../media/media_foundation.zig").DeviceStreamState;
const HRESULT = @import("../foundation.zig").HRESULT;
const IMFAttributes = @import("../media/media_foundation.zig").IMFAttributes;
const IMFMediaEvent = @import("../media/media_foundation.zig").IMFMediaEvent;
const IMFMediaType = @import("../media/media_foundation.zig").IMFMediaType;
const IMFSample = @import("../media/media_foundation.zig").IMFSample;
const IUnknown = @import("../system/com.zig").IUnknown;
const MFT_MESSAGE_TYPE = @import("../media/media_foundation.zig").MFT_MESSAGE_TYPE;
const MFT_OUTPUT_DATA_BUFFER = @import("../media/media_foundation.zig").MFT_OUTPUT_DATA_BUFFER;
const RECT = @import("../foundation.zig").RECT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
