//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const DEVPKEY_AudioEndpointPlugin_FactoryCLSID = PROPERTYKEY{ .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 1 };
pub const DEVPKEY_AudioEndpointPlugin_DataFlow = PROPERTYKEY{ .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 2 };
pub const DEVPKEY_AudioEndpointPlugin_PnPInterface = PROPERTYKEY{ .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 3 };
pub const DEVPKEY_AudioEndpointPlugin2_FactoryCLSID = PROPERTYKEY{ .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 4 };

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointFormatControl_Value = Guid.initString("784cfd40-9f89-456e-a1a6-873b006a664e");
pub const IID_IAudioEndpointFormatControl = &IID_IAudioEndpointFormatControl_Value;
pub const IAudioEndpointFormatControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetToDefault: *const fn (
            self: *const IAudioEndpointFormatControl,
            reset_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn resetToDefault(self: *const T, reset_flags_: u32) HRESULT {
                return @as(*const IAudioEndpointFormatControl.VTable, @ptrCast(self.vtable)).ResetToDefault(@as(*const IAudioEndpointFormatControl, @ptrCast(self)), reset_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EndpointConnectorType = enum(i32) {
    HostProcessConnector = 0,
    OffloadConnector = 1,
    LoopbackConnector = 2,
    KeywordDetectorConnector = 3,
    ConnectorCount = 4,
};
pub const eHostProcessConnector = EndpointConnectorType.HostProcessConnector;
pub const eOffloadConnector = EndpointConnectorType.OffloadConnector;
pub const eLoopbackConnector = EndpointConnectorType.LoopbackConnector;
pub const eKeywordDetectorConnector = EndpointConnectorType.KeywordDetectorConnector;
pub const eConnectorCount = EndpointConnectorType.ConnectorCount;

pub const AUDIO_ENDPOINT_SHARED_CREATE_PARAMS = extern struct {
    u32Size: u32,
    u32TSSessionId: u32,
    targetEndpointConnectorType: EndpointConnectorType,
    wfxDeviceFormat: WAVEFORMATEX,
};

const IID_IAudioEndpointOffloadStreamVolume_Value = Guid.initString("64f1dd49-71ca-4281-8672-3a9eddd1d0b6");
pub const IID_IAudioEndpointOffloadStreamVolume = &IID_IAudioEndpointOffloadStreamVolume_Value;
pub const IAudioEndpointOffloadStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVolumeChannelCount: *const fn (
            self: *const IAudioEndpointOffloadStreamVolume,
            pu32_channel_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumes: *const fn (
            self: *const IAudioEndpointOffloadStreamVolume,
            u32_channel_count: u32,
            pf32_volumes: ?*f32,
            u32_curve_type: AUDIO_CURVE_TYPE,
            p_curve_duration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumes: *const fn (
            self: *const IAudioEndpointOffloadStreamVolume,
            u32_channel_count: u32,
            pf32_volumes: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getVolumeChannelCount(self: *const T, pu32_channel_count_: ?*u32) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).GetVolumeChannelCount(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), pu32_channel_count_);
            }
            pub inline fn setChannelVolumes(self: *const T, u32_channel_count_: u32, pf32_volumes_: ?*f32, u32_curve_type_: AUDIO_CURVE_TYPE, p_curve_duration_: ?*i64) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumes(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), u32_channel_count_, pf32_volumes_, u32_curve_type_, p_curve_duration_);
            }
            pub inline fn getChannelVolumes(self: *const T, u32_channel_count_: u32, pf32_volumes_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumes(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), u32_channel_count_, pf32_volumes_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioEndpointOffloadStreamMute_Value = Guid.initString("dfe21355-5ec2-40e0-8d6b-710ac3c00249");
pub const IID_IAudioEndpointOffloadStreamMute = &IID_IAudioEndpointOffloadStreamMute_Value;
pub const IAudioEndpointOffloadStreamMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: *const fn (
            self: *const IAudioEndpointOffloadStreamMute,
            b_muted: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: *const fn (
            self: *const IAudioEndpointOffloadStreamMute,
            pb_muted: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMute(self: *const T, b_muted_: u8) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamMute.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioEndpointOffloadStreamMute, @ptrCast(self)), b_muted_);
            }
            pub inline fn getMute(self: *const T, pb_muted_: ?*u8) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamMute.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioEndpointOffloadStreamMute, @ptrCast(self)), pb_muted_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEndpointOffloadStreamMeter_Value = Guid.initString("e1546dce-9dd1-418b-9ab2-348ced161c86");
pub const IID_IAudioEndpointOffloadStreamMeter = &IID_IAudioEndpointOffloadStreamMeter_Value;
pub const IAudioEndpointOffloadStreamMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMeterChannelCount: *const fn (
            self: *const IAudioEndpointOffloadStreamMeter,
            pu32_channel_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMeteringData: *const fn (
            self: *const IAudioEndpointOffloadStreamMeter,
            u32_channel_count: u32,
            pf32_peak_values: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMeterChannelCount(self: *const T, pu32_channel_count_: ?*u32) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamMeter.VTable, @ptrCast(self.vtable)).GetMeterChannelCount(@as(*const IAudioEndpointOffloadStreamMeter, @ptrCast(self)), pu32_channel_count_);
            }
            pub inline fn getMeteringData(self: *const T, u32_channel_count_: u32, pf32_peak_values_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointOffloadStreamMeter.VTable, @ptrCast(self.vtable)).GetMeteringData(@as(*const IAudioEndpointOffloadStreamMeter, @ptrCast(self)), u32_channel_count_, pf32_peak_values_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAudioEndpointLastBufferControl_Value = Guid.initString("f8520dd3-8f9d-4437-9861-62f584c33dd6");
pub const IID_IAudioEndpointLastBufferControl = &IID_IAudioEndpointLastBufferControl_Value;
pub const IAudioEndpointLastBufferControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsLastBufferControlSupported: *const fn (
            self: *const IAudioEndpointLastBufferControl,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        ReleaseOutputDataPointerForLastBuffer: *const fn (
            self: *const IAudioEndpointLastBufferControl,
            p_connection_property: ?*const APO_CONNECTION_PROPERTY,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isLastBufferControlSupported(self: *const T) BOOL {
                return @as(*const IAudioEndpointLastBufferControl.VTable, @ptrCast(self.vtable)).IsLastBufferControlSupported(@as(*const IAudioEndpointLastBufferControl, @ptrCast(self)));
            }
            pub inline fn releaseOutputDataPointerForLastBuffer(self: *const T, p_connection_property_: ?*const APO_CONNECTION_PROPERTY) void {
                return @as(*const IAudioEndpointLastBufferControl.VTable, @ptrCast(self.vtable)).ReleaseOutputDataPointerForLastBuffer(@as(*const IAudioEndpointLastBufferControl, @ptrCast(self)), p_connection_property_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioLfxControl_Value = Guid.initString("076a6922-d802-4f83-baf6-409d9ca11bfe");
pub const IID_IAudioLfxControl = &IID_IAudioLfxControl_Value;
pub const IAudioLfxControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocalEffectsState: *const fn (
            self: *const IAudioLfxControl,
            b_enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalEffectsState: *const fn (
            self: *const IAudioLfxControl,
            pb_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setLocalEffectsState(self: *const T, b_enabled_: BOOL) HRESULT {
                return @as(*const IAudioLfxControl.VTable, @ptrCast(self.vtable)).SetLocalEffectsState(@as(*const IAudioLfxControl, @ptrCast(self)), b_enabled_);
            }
            pub inline fn getLocalEffectsState(self: *const T, pb_enabled_: ?*BOOL) HRESULT {
                return @as(*const IAudioLfxControl.VTable, @ptrCast(self.vtable)).GetLocalEffectsState(@as(*const IAudioLfxControl, @ptrCast(self)), pb_enabled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHardwareAudioEngineBase_Value = Guid.initString("eddce3e4-f3c1-453a-b461-223563cbd886");
pub const IID_IHardwareAudioEngineBase = &IID_IHardwareAudioEngineBase_Value;
pub const IHardwareAudioEngineBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableOffloadConnectorCount: *const fn (
            self: *const IHardwareAudioEngineBase,
            _pwstr_device_id: ?PWSTR,
            _u_connector_id: u32,
            _p_available_connector_instance_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineFormat: *const fn (
            self: *const IHardwareAudioEngineBase,
            p_device: ?*IMMDevice,
            _b_request_device_format: BOOL,
            _ppwfx_format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineDeviceFormat: *const fn (
            self: *const IHardwareAudioEngineBase,
            p_device: ?*IMMDevice,
            _pwfx_format: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGfxState: *const fn (
            self: *const IHardwareAudioEngineBase,
            p_device: ?*IMMDevice,
            _b_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGfxState: *const fn (
            self: *const IHardwareAudioEngineBase,
            p_device: ?*IMMDevice,
            _pb_enable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAvailableOffloadConnectorCount(self: *const T, _pwstr_device_id_: ?PWSTR, _u_connector_id_: u32, _p_available_connector_instance_count_: ?*u32) HRESULT {
                return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetAvailableOffloadConnectorCount(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), _pwstr_device_id_, _u_connector_id_, _p_available_connector_instance_count_);
            }
            pub inline fn getEngineFormat(self: *const T, p_device_: ?*IMMDevice, _b_request_device_format_: BOOL, _ppwfx_format_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetEngineFormat(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), p_device_, _b_request_device_format_, _ppwfx_format_);
            }
            pub inline fn setEngineDeviceFormat(self: *const T, p_device_: ?*IMMDevice, _pwfx_format_: ?*WAVEFORMATEX) HRESULT {
                return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).SetEngineDeviceFormat(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), p_device_, _pwfx_format_);
            }
            pub inline fn setGfxState(self: *const T, p_device_: ?*IMMDevice, _b_enable_: BOOL) HRESULT {
                return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).SetGfxState(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), p_device_, _b_enable_);
            }
            pub inline fn getGfxState(self: *const T, p_device_: ?*IMMDevice, _pb_enable_: ?*BOOL) HRESULT {
                return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetGfxState(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), p_device_, _pb_enable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value = Guid.initString("9f2f7b66-65ac-4fa6-8ae4-123c78b89313");
pub const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN = &CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolumeCallback_Value = Guid.initString("657804fa-d6ad-4496-8a60-352752af4f89");
pub const IID_IAudioEndpointVolumeCallback = &IID_IAudioEndpointVolumeCallback_Value;
pub const IAudioEndpointVolumeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: *const fn (
            self: *const IAudioEndpointVolumeCallback,
            p_notify: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onNotify(self: *const T, p_notify_: ?*AUDIO_VOLUME_NOTIFICATION_DATA) HRESULT {
                return @as(*const IAudioEndpointVolumeCallback.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IAudioEndpointVolumeCallback, @ptrCast(self)), p_notify_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolume_Value = Guid.initString("5cdf2c82-841e-4546-9722-0cf74078229a");
pub const IID_IAudioEndpointVolume = &IID_IAudioEndpointVolume_Value;
pub const IAudioEndpointVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterControlChangeNotify: *const fn (
            self: *const IAudioEndpointVolume,
            p_notify: ?*IAudioEndpointVolumeCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterControlChangeNotify: *const fn (
            self: *const IAudioEndpointVolume,
            p_notify: ?*IAudioEndpointVolumeCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelCount: *const fn (
            self: *const IAudioEndpointVolume,
            pn_channel_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMasterVolumeLevel: *const fn (
            self: *const IAudioEndpointVolume,
            f_level_d_b: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMasterVolumeLevelScalar: *const fn (
            self: *const IAudioEndpointVolume,
            f_level: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolumeLevel: *const fn (
            self: *const IAudioEndpointVolume,
            pf_level_d_b: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolumeLevelScalar: *const fn (
            self: *const IAudioEndpointVolume,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumeLevel: *const fn (
            self: *const IAudioEndpointVolume,
            n_channel: u32,
            f_level_d_b: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumeLevelScalar: *const fn (
            self: *const IAudioEndpointVolume,
            n_channel: u32,
            f_level: f32,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumeLevel: *const fn (
            self: *const IAudioEndpointVolume,
            n_channel: u32,
            pf_level_d_b: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumeLevelScalar: *const fn (
            self: *const IAudioEndpointVolume,
            n_channel: u32,
            pf_level: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: *const fn (
            self: *const IAudioEndpointVolume,
            b_mute: BOOL,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: *const fn (
            self: *const IAudioEndpointVolume,
            pb_mute: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeStepInfo: *const fn (
            self: *const IAudioEndpointVolume,
            pn_step: ?*u32,
            pn_step_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VolumeStepUp: *const fn (
            self: *const IAudioEndpointVolume,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VolumeStepDown: *const fn (
            self: *const IAudioEndpointVolume,
            pguid_event_context: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHardwareSupport: *const fn (
            self: *const IAudioEndpointVolume,
            pdw_hardware_support_mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeRange: *const fn (
            self: *const IAudioEndpointVolume,
            pfl_volume_mind_b: ?*f32,
            pfl_volume_maxd_b: ?*f32,
            pfl_volume_incrementd_b: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerControlChangeNotify(self: *const T, p_notify_: ?*IAudioEndpointVolumeCallback) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).RegisterControlChangeNotify(@as(*const IAudioEndpointVolume, @ptrCast(self)), p_notify_);
            }
            pub inline fn unregisterControlChangeNotify(self: *const T, p_notify_: ?*IAudioEndpointVolumeCallback) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).UnregisterControlChangeNotify(@as(*const IAudioEndpointVolume, @ptrCast(self)), p_notify_);
            }
            pub inline fn getChannelCount(self: *const T, pn_channel_count_: ?*u32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioEndpointVolume, @ptrCast(self)), pn_channel_count_);
            }
            pub inline fn setMasterVolumeLevel(self: *const T, f_level_d_b_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMasterVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), f_level_d_b_, pguid_event_context_);
            }
            pub inline fn setMasterVolumeLevelScalar(self: *const T, f_level_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMasterVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), f_level_, pguid_event_context_);
            }
            pub inline fn getMasterVolumeLevel(self: *const T, pf_level_d_b_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMasterVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), pf_level_d_b_);
            }
            pub inline fn getMasterVolumeLevelScalar(self: *const T, pf_level_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMasterVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), pf_level_);
            }
            pub inline fn setChannelVolumeLevel(self: *const T, n_channel_: u32, f_level_d_b_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), n_channel_, f_level_d_b_, pguid_event_context_);
            }
            pub inline fn setChannelVolumeLevelScalar(self: *const T, n_channel_: u32, f_level_: f32, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), n_channel_, f_level_, pguid_event_context_);
            }
            pub inline fn getChannelVolumeLevel(self: *const T, n_channel_: u32, pf_level_d_b_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), n_channel_, pf_level_d_b_);
            }
            pub inline fn getChannelVolumeLevelScalar(self: *const T, n_channel_: u32, pf_level_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), n_channel_, pf_level_);
            }
            pub inline fn setMute(self: *const T, b_mute_: BOOL, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioEndpointVolume, @ptrCast(self)), b_mute_, pguid_event_context_);
            }
            pub inline fn getMute(self: *const T, pb_mute_: ?*BOOL) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioEndpointVolume, @ptrCast(self)), pb_mute_);
            }
            pub inline fn getVolumeStepInfo(self: *const T, pn_step_: ?*u32, pn_step_count_: ?*u32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetVolumeStepInfo(@as(*const IAudioEndpointVolume, @ptrCast(self)), pn_step_, pn_step_count_);
            }
            pub inline fn volumeStepUp(self: *const T, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).VolumeStepUp(@as(*const IAudioEndpointVolume, @ptrCast(self)), pguid_event_context_);
            }
            pub inline fn volumeStepDown(self: *const T, pguid_event_context_: ?*const Guid) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).VolumeStepDown(@as(*const IAudioEndpointVolume, @ptrCast(self)), pguid_event_context_);
            }
            pub inline fn queryHardwareSupport(self: *const T, pdw_hardware_support_mask_: ?*u32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).QueryHardwareSupport(@as(*const IAudioEndpointVolume, @ptrCast(self)), pdw_hardware_support_mask_);
            }
            pub inline fn getVolumeRange(self: *const T, pfl_volume_mind_b_: ?*f32, pfl_volume_maxd_b_: ?*f32, pfl_volume_incrementd_b_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetVolumeRange(@as(*const IAudioEndpointVolume, @ptrCast(self)), pfl_volume_mind_b_, pfl_volume_maxd_b_, pfl_volume_incrementd_b_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointVolumeEx_Value = Guid.initString("66e11784-f695-4f28-a505-a7080081a78f");
pub const IID_IAudioEndpointVolumeEx = &IID_IAudioEndpointVolumeEx_Value;
pub const IAudioEndpointVolumeEx = extern struct {
    pub const VTable = extern struct {
        base: IAudioEndpointVolume.VTable,
        GetVolumeRangeChannel: *const fn (
            self: *const IAudioEndpointVolumeEx,
            i_channel: u32,
            pfl_volume_mind_b: ?*f32,
            pfl_volume_maxd_b: ?*f32,
            pfl_volume_incrementd_b: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioEndpointVolume.MethodMixin(T);
            pub inline fn getVolumeRangeChannel(self: *const T, i_channel_: u32, pfl_volume_mind_b_: ?*f32, pfl_volume_maxd_b_: ?*f32, pfl_volume_incrementd_b_: ?*f32) HRESULT {
                return @as(*const IAudioEndpointVolumeEx.VTable, @ptrCast(self.vtable)).GetVolumeRangeChannel(@as(*const IAudioEndpointVolumeEx, @ptrCast(self)), i_channel_, pfl_volume_mind_b_, pfl_volume_maxd_b_, pfl_volume_incrementd_b_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMeterInformation_Value = Guid.initString("c02216f6-8c67-4b5b-9d00-d008e73e0064");
pub const IID_IAudioMeterInformation = &IID_IAudioMeterInformation_Value;
pub const IAudioMeterInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPeakValue: *const fn (
            self: *const IAudioMeterInformation,
            pf_peak: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMeteringChannelCount: *const fn (
            self: *const IAudioMeterInformation,
            pn_channel_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelsPeakValues: *const fn (
            self: *const IAudioMeterInformation,
            u32_channel_count: u32,
            af_peak_values: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHardwareSupport: *const fn (
            self: *const IAudioMeterInformation,
            pdw_hardware_support_mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPeakValue(self: *const T, pf_peak_: ?*f32) HRESULT {
                return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetPeakValue(@as(*const IAudioMeterInformation, @ptrCast(self)), pf_peak_);
            }
            pub inline fn getMeteringChannelCount(self: *const T, pn_channel_count_: ?*u32) HRESULT {
                return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetMeteringChannelCount(@as(*const IAudioMeterInformation, @ptrCast(self)), pn_channel_count_);
            }
            pub inline fn getChannelsPeakValues(self: *const T, u32_channel_count_: u32, af_peak_values_: [*]f32) HRESULT {
                return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetChannelsPeakValues(@as(*const IAudioMeterInformation, @ptrCast(self)), u32_channel_count_, af_peak_values_);
            }
            pub inline fn queryHardwareSupport(self: *const T, pdw_hardware_support_mask_: ?*u32) HRESULT {
                return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).QueryHardwareSupport(@as(*const IAudioMeterInformation, @ptrCast(self)), pdw_hardware_support_mask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const APO_CONNECTION_PROPERTY = @import("../../media/audio/apo.zig").APO_CONNECTION_PROPERTY;
const AUDIO_CURVE_TYPE = @import("../../media/kernel_streaming.zig").AUDIO_CURVE_TYPE;
const AUDIO_VOLUME_NOTIFICATION_DATA = @import("../../media/audio.zig").AUDIO_VOLUME_NOTIFICATION_DATA;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IMMDevice = @import("../../media/audio.zig").IMMDevice;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PROPERTYKEY = @import("../../ui/shell/properties_system.zig").PROPERTYKEY;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
