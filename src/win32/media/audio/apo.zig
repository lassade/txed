//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (53)
//--------------------------------------------------------------------------------
pub const APOERR_ALREADY_INITIALIZED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073919));
pub const APOERR_NOT_INITIALIZED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073918));
pub const APOERR_FORMAT_NOT_SUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073917));
pub const APOERR_INVALID_APO_CLSID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073916));
pub const APOERR_BUFFERS_OVERLAP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073915));
pub const APOERR_ALREADY_UNLOCKED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073914));
pub const APOERR_NUM_CONNECTIONS_INVALID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073913));
pub const APOERR_INVALID_OUTPUT_MAXFRAMECOUNT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073912));
pub const APOERR_INVALID_CONNECTION_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073911));
pub const APOERR_APO_LOCKED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073910));
pub const APOERR_INVALID_COEFFCOUNT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073909));
pub const APOERR_INVALID_COEFFICIENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073908));
pub const APOERR_INVALID_CURVE_PARAM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073907));
pub const APOERR_INVALID_INPUTID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073906));
pub const AUDIO_MIN_FRAMERATE = @as(f64, 10);
pub const AUDIO_MAX_FRAMERATE = @as(f64, 384000);
pub const AUDIO_MIN_CHANNELS = @as(u32, 1);
pub const AUDIO_MAX_CHANNELS = @as(u32, 4096);
pub const PKEY_FX_Association = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 0 };
pub const PKEY_FX_PreMixEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 1 };
pub const PKEY_FX_PostMixEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 2 };
pub const PKEY_FX_UserInterfaceClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 3 };
pub const PKEY_FX_FriendlyName = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 4 };
pub const PKEY_FX_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 5 };
pub const PKEY_FX_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 6 };
pub const PKEY_FX_EndpointEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 7 };
pub const PKEY_FX_KeywordDetector_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 8 };
pub const PKEY_FX_KeywordDetector_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 9 };
pub const PKEY_FX_KeywordDetector_EndpointEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 10 };
pub const PKEY_FX_Offload_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 11 };
pub const PKEY_FX_Offload_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 12 };
pub const PKEY_CompositeFX_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 13 };
pub const PKEY_CompositeFX_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 14 };
pub const PKEY_CompositeFX_EndpointEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 15 };
pub const PKEY_CompositeFX_KeywordDetector_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 16 };
pub const PKEY_CompositeFX_KeywordDetector_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 17 };
pub const PKEY_CompositeFX_KeywordDetector_EndpointEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 18 };
pub const PKEY_CompositeFX_Offload_StreamEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 19 };
pub const PKEY_CompositeFX_Offload_ModeEffectClsid = PROPERTYKEY{ .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 20 };
pub const PKEY_SFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 5 };
pub const PKEY_MFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 6 };
pub const PKEY_EFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 7 };
pub const PKEY_SFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 8 };
pub const PKEY_MFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 9 };
pub const PKEY_EFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 10 };
pub const PKEY_SFX_Offload_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 11 };
pub const PKEY_MFX_Offload_ProcessingModes_Supported_For_Streaming = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 12 };
pub const PKEY_APO_SWFallback_ProcessingModes = PROPERTYKEY{ .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 13 };
pub const SID_AudioProcessingObjectRTQueue = Guid.initString("458c1a1f-6899-4c12-99ac-e2e6ac253104");
pub const SID_AudioProcessingObjectLoggingService = Guid.initString("8b8008af-09f9-456e-a173-bdb58499bce7");
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_TYPES = @as(u32, 2);
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_DATA = @as(u32, 4);
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_USER_DATA = @as(u32, 8);

//--------------------------------------------------------------------------------
// Section: Types (44)
//--------------------------------------------------------------------------------
pub const UNCOMPRESSEDAUDIOFORMAT = extern struct {
    guidFormatType: Guid,
    dwSamplesPerFrame: u32,
    dwBytesPerSampleContainer: u32,
    dwValidBitsPerSample: u32,
    fFramesPerSecond: f32,
    dwChannelMask: u32,
};

const IID_IAudioMediaType_Value = Guid.initString("4e997f73-b71f-4798-873b-ed7dfcf15b4d");
pub const IID_IAudioMediaType = &IID_IAudioMediaType_Value;
pub const IAudioMediaType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsCompressedFormat: *const fn (
            self: *const IAudioMediaType,
            pf_compressed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn (
            self: *const IAudioMediaType,
            p_i_audio_type: ?*IAudioMediaType,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioFormat: *const fn (
            self: *const IAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) ?*WAVEFORMATEX,
        GetUncompressedAudioFormat: *const fn (
            self: *const IAudioMediaType,
            p_uncompressed_audio_format: ?*UNCOMPRESSEDAUDIOFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isCompressedFormat(self: *const T, pf_compressed_: ?*BOOL) HRESULT {
                return @as(*const IAudioMediaType.VTable, @ptrCast(self.vtable)).IsCompressedFormat(@as(*const IAudioMediaType, @ptrCast(self)), pf_compressed_);
            }
            pub inline fn isEqual(self: *const T, p_i_audio_type_: ?*IAudioMediaType, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IAudioMediaType.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IAudioMediaType, @ptrCast(self)), p_i_audio_type_, pdw_flags_);
            }
            pub inline fn getAudioFormat(self: *const T) ?*WAVEFORMATEX {
                return @as(*const IAudioMediaType.VTable, @ptrCast(self.vtable)).GetAudioFormat(@as(*const IAudioMediaType, @ptrCast(self)));
            }
            pub inline fn getUncompressedAudioFormat(self: *const T, p_uncompressed_audio_format_: ?*UNCOMPRESSEDAUDIOFORMAT) HRESULT {
                return @as(*const IAudioMediaType.VTable, @ptrCast(self.vtable)).GetUncompressedAudioFormat(@as(*const IAudioMediaType, @ptrCast(self)), p_uncompressed_audio_format_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APO_BUFFER_FLAGS = enum(i32) {
    INVALID = 0,
    VALID = 1,
    SILENT = 2,
};
pub const BUFFER_INVALID = APO_BUFFER_FLAGS.INVALID;
pub const BUFFER_VALID = APO_BUFFER_FLAGS.VALID;
pub const BUFFER_SILENT = APO_BUFFER_FLAGS.SILENT;

pub const APO_CONNECTION_PROPERTY = extern struct {
    pBuffer: usize,
    u32ValidFrameCount: u32,
    u32BufferFlags: APO_BUFFER_FLAGS,
    u32Signature: u32,
};

pub const APO_CONNECTION_PROPERTY_V2 = extern struct {
    property: APO_CONNECTION_PROPERTY,
    u64QPCTime: u64,
};

pub const APO_CONNECTION_BUFFER_TYPE = enum(i32) {
    ALLOCATED = 0,
    EXTERNAL = 1,
    DEPENDANT = 2,
};
pub const APO_CONNECTION_BUFFER_TYPE_ALLOCATED = APO_CONNECTION_BUFFER_TYPE.ALLOCATED;
pub const APO_CONNECTION_BUFFER_TYPE_EXTERNAL = APO_CONNECTION_BUFFER_TYPE.EXTERNAL;
pub const APO_CONNECTION_BUFFER_TYPE_DEPENDANT = APO_CONNECTION_BUFFER_TYPE.DEPENDANT;

pub const APO_CONNECTION_DESCRIPTOR = extern struct {
    Type: APO_CONNECTION_BUFFER_TYPE,
    pBuffer: usize,
    u32MaxFrameCount: u32,
    pFormat: ?*IAudioMediaType,
    u32Signature: u32,
};

pub const APO_FLAG = enum(i32) {
    NONE = 0,
    INPLACE = 1,
    SAMPLESPERFRAME_MUST_MATCH = 2,
    FRAMESPERSECOND_MUST_MATCH = 4,
    BITSPERSAMPLE_MUST_MATCH = 8,
    MIXER = 16,
    DEFAULT = 14,
};
pub const APO_FLAG_NONE = APO_FLAG.NONE;
pub const APO_FLAG_INPLACE = APO_FLAG.INPLACE;
pub const APO_FLAG_SAMPLESPERFRAME_MUST_MATCH = APO_FLAG.SAMPLESPERFRAME_MUST_MATCH;
pub const APO_FLAG_FRAMESPERSECOND_MUST_MATCH = APO_FLAG.FRAMESPERSECOND_MUST_MATCH;
pub const APO_FLAG_BITSPERSAMPLE_MUST_MATCH = APO_FLAG.BITSPERSAMPLE_MUST_MATCH;
pub const APO_FLAG_MIXER = APO_FLAG.MIXER;
pub const APO_FLAG_DEFAULT = APO_FLAG.DEFAULT;

pub const APO_REG_PROPERTIES = extern struct {
    clsid: Guid,
    Flags: APO_FLAG,
    szFriendlyName: [256]u16,
    szCopyrightInfo: [256]u16,
    u32MajorVersion: u32,
    u32MinorVersion: u32,
    u32MinInputConnections: u32,
    u32MaxInputConnections: u32,
    u32MinOutputConnections: u32,
    u32MaxOutputConnections: u32,
    u32MaxInstances: u32,
    u32NumAPOInterfaces: u32,
    iidAPOInterfaceList: [1]Guid,
};

pub const APOInitBaseStruct = extern struct {
    cbSize: u32,
    clsid: Guid,
};

pub const AUDIO_FLOW_TYPE = enum(i32) {
    LL = 0,
    SH = 1,
};
pub const AUDIO_FLOW_PULL = AUDIO_FLOW_TYPE.LL;
pub const AUDIO_FLOW_PUSH = AUDIO_FLOW_TYPE.SH;

pub const EAudioConstriction = enum(i32) {
    Off = 0,
    @"48_16" = 1,
    @"44_16" = 2,
    @"14_14" = 3,
    Mute = 4,
};
pub const eAudioConstrictionOff = EAudioConstriction.Off;
pub const eAudioConstriction48_16 = EAudioConstriction.@"48_16";
pub const eAudioConstriction44_16 = EAudioConstriction.@"44_16";
pub const eAudioConstriction14_14 = EAudioConstriction.@"14_14";
pub const eAudioConstrictionMute = EAudioConstriction.Mute;

const IID_IAudioProcessingObjectRT_Value = Guid.initString("9e1d6a6d-ddbc-4e95-a4c7-ad64ba37846c");
pub const IID_IAudioProcessingObjectRT = &IID_IAudioProcessingObjectRT_Value;
pub const IAudioProcessingObjectRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        APOProcess: *const fn (
            self: *const IAudioProcessingObjectRT,
            u32_num_input_connections: u32,
            pp_input_connections: ?*?*APO_CONNECTION_PROPERTY,
            u32_num_output_connections: u32,
            pp_output_connections: ?*?*APO_CONNECTION_PROPERTY,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CalcInputFrames: *const fn (
            self: *const IAudioProcessingObjectRT,
            u32_output_frame_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CalcOutputFrames: *const fn (
            self: *const IAudioProcessingObjectRT,
            u32_input_frame_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn apoProcess(self: *const T, u32_num_input_connections_: u32, pp_input_connections_: ?*?*APO_CONNECTION_PROPERTY, u32_num_output_connections_: u32, pp_output_connections_: ?*?*APO_CONNECTION_PROPERTY) void {
                return @as(*const IAudioProcessingObjectRT.VTable, @ptrCast(self.vtable)).APOProcess(@as(*const IAudioProcessingObjectRT, @ptrCast(self)), u32_num_input_connections_, pp_input_connections_, u32_num_output_connections_, pp_output_connections_);
            }
            pub inline fn calcInputFrames(self: *const T, u32_output_frame_count_: u32) u32 {
                return @as(*const IAudioProcessingObjectRT.VTable, @ptrCast(self.vtable)).CalcInputFrames(@as(*const IAudioProcessingObjectRT, @ptrCast(self)), u32_output_frame_count_);
            }
            pub inline fn calcOutputFrames(self: *const T, u32_input_frame_count_: u32) u32 {
                return @as(*const IAudioProcessingObjectRT.VTable, @ptrCast(self.vtable)).CalcOutputFrames(@as(*const IAudioProcessingObjectRT, @ptrCast(self)), u32_input_frame_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObjectVBR_Value = Guid.initString("7ba1db8f-78ad-49cd-9591-f79d80a17c81");
pub const IID_IAudioProcessingObjectVBR = &IID_IAudioProcessingObjectVBR_Value;
pub const IAudioProcessingObjectVBR = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CalcMaxInputFrames: *const fn (
            self: *const IAudioProcessingObjectVBR,
            u32_max_output_frame_count: u32,
            pu32_input_frame_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CalcMaxOutputFrames: *const fn (
            self: *const IAudioProcessingObjectVBR,
            u32_max_input_frame_count: u32,
            pu32_output_frame_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn calcMaxInputFrames(self: *const T, u32_max_output_frame_count_: u32, pu32_input_frame_count_: ?*u32) HRESULT {
                return @as(*const IAudioProcessingObjectVBR.VTable, @ptrCast(self.vtable)).CalcMaxInputFrames(@as(*const IAudioProcessingObjectVBR, @ptrCast(self)), u32_max_output_frame_count_, pu32_input_frame_count_);
            }
            pub inline fn calcMaxOutputFrames(self: *const T, u32_max_input_frame_count_: u32, pu32_output_frame_count_: ?*u32) HRESULT {
                return @as(*const IAudioProcessingObjectVBR.VTable, @ptrCast(self.vtable)).CalcMaxOutputFrames(@as(*const IAudioProcessingObjectVBR, @ptrCast(self)), u32_max_input_frame_count_, pu32_output_frame_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObjectConfiguration_Value = Guid.initString("0e5ed805-aba6-49c3-8f9a-2b8c889c4fa8");
pub const IID_IAudioProcessingObjectConfiguration = &IID_IAudioProcessingObjectConfiguration_Value;
pub const IAudioProcessingObjectConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockForProcess: *const fn (
            self: *const IAudioProcessingObjectConfiguration,
            u32_num_input_connections: u32,
            pp_input_connections: ?*?*APO_CONNECTION_DESCRIPTOR,
            u32_num_output_connections: u32,
            pp_output_connections: ?*?*APO_CONNECTION_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockForProcess: *const fn (
            self: *const IAudioProcessingObjectConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn lockForProcess(self: *const T, u32_num_input_connections_: u32, pp_input_connections_: ?*?*APO_CONNECTION_DESCRIPTOR, u32_num_output_connections_: u32, pp_output_connections_: ?*?*APO_CONNECTION_DESCRIPTOR) HRESULT {
                return @as(*const IAudioProcessingObjectConfiguration.VTable, @ptrCast(self.vtable)).LockForProcess(@as(*const IAudioProcessingObjectConfiguration, @ptrCast(self)), u32_num_input_connections_, pp_input_connections_, u32_num_output_connections_, pp_output_connections_);
            }
            pub inline fn unlockForProcess(self: *const T) HRESULT {
                return @as(*const IAudioProcessingObjectConfiguration.VTable, @ptrCast(self.vtable)).UnlockForProcess(@as(*const IAudioProcessingObjectConfiguration, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObject_Value = Guid.initString("fd7f2b29-24d0-4b5c-b177-592c39f9ca10");
pub const IID_IAudioProcessingObject = &IID_IAudioProcessingObject_Value;
pub const IAudioProcessingObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: *const fn (
            self: *const IAudioProcessingObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLatency: *const fn (
            self: *const IAudioProcessingObject,
            p_time: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegistrationProperties: *const fn (
            self: *const IAudioProcessingObject,
            pp_reg_props: ?*?*APO_REG_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: *const fn (
            self: *const IAudioProcessingObject,
            cb_data_size: u32,
            pby_data: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInputFormatSupported: *const fn (
            self: *const IAudioProcessingObject,
            p_opposite_format: ?*IAudioMediaType,
            p_requested_input_format: ?*IAudioMediaType,
            pp_supported_input_format: ?*?*IAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOutputFormatSupported: *const fn (
            self: *const IAudioProcessingObject,
            p_opposite_format: ?*IAudioMediaType,
            p_requested_output_format: ?*IAudioMediaType,
            pp_supported_output_format: ?*?*IAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputChannelCount: *const fn (
            self: *const IAudioProcessingObject,
            pu32_channel_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAudioProcessingObject, @ptrCast(self)));
            }
            pub inline fn getLatency(self: *const T, p_time_: ?*i64) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).GetLatency(@as(*const IAudioProcessingObject, @ptrCast(self)), p_time_);
            }
            pub inline fn getRegistrationProperties(self: *const T, pp_reg_props_: ?*?*APO_REG_PROPERTIES) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).GetRegistrationProperties(@as(*const IAudioProcessingObject, @ptrCast(self)), pp_reg_props_);
            }
            pub inline fn initialize(self: *const T, cb_data_size_: u32, pby_data_: [*:0]u8) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAudioProcessingObject, @ptrCast(self)), cb_data_size_, pby_data_);
            }
            pub inline fn isInputFormatSupported(self: *const T, p_opposite_format_: ?*IAudioMediaType, p_requested_input_format_: ?*IAudioMediaType, pp_supported_input_format_: ?*?*IAudioMediaType) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).IsInputFormatSupported(@as(*const IAudioProcessingObject, @ptrCast(self)), p_opposite_format_, p_requested_input_format_, pp_supported_input_format_);
            }
            pub inline fn isOutputFormatSupported(self: *const T, p_opposite_format_: ?*IAudioMediaType, p_requested_output_format_: ?*IAudioMediaType, pp_supported_output_format_: ?*?*IAudioMediaType) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).IsOutputFormatSupported(@as(*const IAudioProcessingObject, @ptrCast(self)), p_opposite_format_, p_requested_output_format_, pp_supported_output_format_);
            }
            pub inline fn getInputChannelCount(self: *const T, pu32_channel_count_: ?*u32) HRESULT {
                return @as(*const IAudioProcessingObject.VTable, @ptrCast(self.vtable)).GetInputChannelCount(@as(*const IAudioProcessingObject, @ptrCast(self)), pu32_channel_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioDeviceModulesClient_Value = Guid.initString("98f37dac-d0b6-49f5-896a-aa4d169a4c48");
pub const IID_IAudioDeviceModulesClient = &IID_IAudioDeviceModulesClient_Value;
pub const IAudioDeviceModulesClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioDeviceModulesManager: *const fn (
            self: *const IAudioDeviceModulesClient,
            p_audio_device_modules_manager: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setAudioDeviceModulesManager(self: *const T, p_audio_device_modules_manager_: ?*IUnknown) HRESULT {
                return @as(*const IAudioDeviceModulesClient.VTable, @ptrCast(self.vtable)).SetAudioDeviceModulesManager(@as(*const IAudioDeviceModulesClient, @ptrCast(self)), p_audio_device_modules_manager_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FNAPONOTIFICATIONCALLBACK = *const fn (
    p_properties: ?*APO_REG_PROPERTIES,
    pv_ref_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

const IID_IAudioSystemEffects_Value = Guid.initString("5fa00f27-add6-499a-8a9d-6b98521fa75b");
pub const IID_IAudioSystemEffects = &IID_IAudioSystemEffects_Value;
pub const IAudioSystemEffects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffects2_Value = Guid.initString("bafe99d2-7436-44ce-9e0e-4d89afbfff56");
pub const IID_IAudioSystemEffects2 = &IID_IAudioSystemEffects2_Value;
pub const IAudioSystemEffects2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSystemEffects.VTable,
        GetEffectsList: *const fn (
            self: *const IAudioSystemEffects2,
            pp_effects_ids: ?*?*Guid,
            pc_effects: ?*u32,
            event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSystemEffects.MethodMixin(T);
            pub inline fn getEffectsList(self: *const T, pp_effects_ids_: ?*?*Guid, pc_effects_: ?*u32, event_: ?HANDLE) HRESULT {
                return @as(*const IAudioSystemEffects2.VTable, @ptrCast(self.vtable)).GetEffectsList(@as(*const IAudioSystemEffects2, @ptrCast(self)), pp_effects_ids_, pc_effects_, event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffectsCustomFormats_Value = Guid.initString("b1176e34-bb7f-4f05-bebd-1b18a534e097");
pub const IID_IAudioSystemEffectsCustomFormats = &IID_IAudioSystemEffectsCustomFormats_Value;
pub const IAudioSystemEffectsCustomFormats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFormatCount: *const fn (
            self: *const IAudioSystemEffectsCustomFormats,
            pc_formats: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: *const fn (
            self: *const IAudioSystemEffectsCustomFormats,
            n_format: u32,
            pp_format: ?*?*IAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormatRepresentation: *const fn (
            self: *const IAudioSystemEffectsCustomFormats,
            n_format: u32,
            ppwstr_format_rep: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFormatCount(self: *const T, pc_formats_: ?*u32) HRESULT {
                return @as(*const IAudioSystemEffectsCustomFormats.VTable, @ptrCast(self.vtable)).GetFormatCount(@as(*const IAudioSystemEffectsCustomFormats, @ptrCast(self)), pc_formats_);
            }
            pub inline fn getFormat(self: *const T, n_format_: u32, pp_format_: ?*?*IAudioMediaType) HRESULT {
                return @as(*const IAudioSystemEffectsCustomFormats.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioSystemEffectsCustomFormats, @ptrCast(self)), n_format_, pp_format_);
            }
            pub inline fn getFormatRepresentation(self: *const T, n_format_: u32, ppwstr_format_rep_: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSystemEffectsCustomFormats.VTable, @ptrCast(self.vtable)).GetFormatRepresentation(@as(*const IAudioSystemEffectsCustomFormats, @ptrCast(self)), n_format_, ppwstr_format_rep_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAuxiliaryInputConfiguration_Value = Guid.initString("4ceb0aab-fa19-48ed-a857-87771ae1b768");
pub const IID_IApoAuxiliaryInputConfiguration = &IID_IApoAuxiliaryInputConfiguration_Value;
pub const IApoAuxiliaryInputConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAuxiliaryInput: *const fn (
            self: *const IApoAuxiliaryInputConfiguration,
            dw_input_id: u32,
            cb_data_size: u32,
            pby_data: [*:0]u8,
            p_input_connection: ?*APO_CONNECTION_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAuxiliaryInput: *const fn (
            self: *const IApoAuxiliaryInputConfiguration,
            dw_input_id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInputFormatSupported: *const fn (
            self: *const IApoAuxiliaryInputConfiguration,
            p_requested_input_format: ?*IAudioMediaType,
            pp_supported_input_format: ?*?*IAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addAuxiliaryInput(self: *const T, dw_input_id_: u32, cb_data_size_: u32, pby_data_: [*:0]u8, p_input_connection_: ?*APO_CONNECTION_DESCRIPTOR) HRESULT {
                return @as(*const IApoAuxiliaryInputConfiguration.VTable, @ptrCast(self.vtable)).AddAuxiliaryInput(@as(*const IApoAuxiliaryInputConfiguration, @ptrCast(self)), dw_input_id_, cb_data_size_, pby_data_, p_input_connection_);
            }
            pub inline fn removeAuxiliaryInput(self: *const T, dw_input_id_: u32) HRESULT {
                return @as(*const IApoAuxiliaryInputConfiguration.VTable, @ptrCast(self.vtable)).RemoveAuxiliaryInput(@as(*const IApoAuxiliaryInputConfiguration, @ptrCast(self)), dw_input_id_);
            }
            pub inline fn isInputFormatSupported(self: *const T, p_requested_input_format_: ?*IAudioMediaType, pp_supported_input_format_: ?*?*IAudioMediaType) HRESULT {
                return @as(*const IApoAuxiliaryInputConfiguration.VTable, @ptrCast(self.vtable)).IsInputFormatSupported(@as(*const IApoAuxiliaryInputConfiguration, @ptrCast(self)), p_requested_input_format_, pp_supported_input_format_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAuxiliaryInputRT_Value = Guid.initString("f851809c-c177-49a0-b1b2-b66f017943ab");
pub const IID_IApoAuxiliaryInputRT = &IID_IApoAuxiliaryInputRT_Value;
pub const IApoAuxiliaryInputRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcceptInput: *const fn (
            self: *const IApoAuxiliaryInputRT,
            dw_input_id: u32,
            p_input_connection: ?*const APO_CONNECTION_PROPERTY,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn acceptInput(self: *const T, dw_input_id_: u32, p_input_connection_: ?*const APO_CONNECTION_PROPERTY) void {
                return @as(*const IApoAuxiliaryInputRT.VTable, @ptrCast(self.vtable)).AcceptInput(@as(*const IApoAuxiliaryInputRT, @ptrCast(self)), dw_input_id_, p_input_connection_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAcousticEchoCancellation_Value = Guid.initString("25385759-3236-4101-a943-25693dfb5d2d");
pub const IID_IApoAcousticEchoCancellation = &IID_IApoAcousticEchoCancellation_Value;
pub const IApoAcousticEchoCancellation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APOInitSystemEffects = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pAPOSystemEffectsProperties: ?*IPropertyStore,
    pReserved: ?*anyopaque,
    pDeviceCollection: ?*IMMDeviceCollection,
};

pub const APOInitSystemEffects2 = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pAPOSystemEffectsProperties: ?*IPropertyStore,
    pReserved: ?*anyopaque,
    pDeviceCollection: ?*IMMDeviceCollection,
    nSoftwareIoDeviceInCollection: u32,
    nSoftwareIoConnectorIndex: u32,
    AudioProcessingMode: Guid,
    InitializeForDiscoveryOnly: BOOL,
};

pub const AudioFXExtensionParams = extern struct {
    AddPageParam: LPARAM,
    pwstrEndpointID: ?PWSTR,
    pFxProperties: ?*IPropertyStore,
};

pub const AUDIO_SYSTEMEFFECT_STATE = enum(i32) {
    FF = 0,
    N = 1,
};
pub const AUDIO_SYSTEMEFFECT_STATE_OFF = AUDIO_SYSTEMEFFECT_STATE.FF;
pub const AUDIO_SYSTEMEFFECT_STATE_ON = AUDIO_SYSTEMEFFECT_STATE.N;

pub const AUDIO_SYSTEMEFFECT = extern struct {
    id: Guid,
    canSetState: BOOL,
    state: AUDIO_SYSTEMEFFECT_STATE,
};

const IID_IAudioSystemEffects3_Value = Guid.initString("c58b31cd-fc6a-4255-bc1f-ad29bb0a4a17");
pub const IID_IAudioSystemEffects3 = &IID_IAudioSystemEffects3_Value;
pub const IAudioSystemEffects3 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSystemEffects2.VTable,
        GetControllableSystemEffectsList: *const fn (
            self: *const IAudioSystemEffects3,
            effects: ?*?*AUDIO_SYSTEMEFFECT,
            num_effects: ?*u32,
            event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioSystemEffectState: *const fn (
            self: *const IAudioSystemEffects3,
            effect_id: Guid,
            state: AUDIO_SYSTEMEFFECT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSystemEffects2.MethodMixin(T);
            pub inline fn getControllableSystemEffectsList(self: *const T, effects_: ?*?*AUDIO_SYSTEMEFFECT, num_effects_: ?*u32, event_: ?HANDLE) HRESULT {
                return @as(*const IAudioSystemEffects3.VTable, @ptrCast(self.vtable)).GetControllableSystemEffectsList(@as(*const IAudioSystemEffects3, @ptrCast(self)), effects_, num_effects_, event_);
            }
            pub inline fn setAudioSystemEffectState(self: *const T, effect_id_: Guid, state_: AUDIO_SYSTEMEFFECT_STATE) HRESULT {
                return @as(*const IAudioSystemEffects3.VTable, @ptrCast(self.vtable)).SetAudioSystemEffectState(@as(*const IAudioSystemEffects3, @ptrCast(self)), effect_id_, state_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APOInitSystemEffects3 = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pServiceProvider: ?*IServiceProvider,
    pDeviceCollection: ?*IMMDeviceCollection,
    nSoftwareIoDeviceInCollection: u32,
    nSoftwareIoConnectorIndex: u32,
    AudioProcessingMode: Guid,
    InitializeForDiscoveryOnly: BOOL,
};

const IID_IAudioProcessingObjectRTQueueService_Value = Guid.initString("acd65e2f-955b-4b57-b9bf-ac297bb752c9");
pub const IID_IAudioProcessingObjectRTQueueService = &IID_IAudioProcessingObjectRTQueueService_Value;
pub const IAudioProcessingObjectRTQueueService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRealTimeWorkQueue: *const fn (
            self: *const IAudioProcessingObjectRTQueueService,
            work_queue_id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRealTimeWorkQueue(self: *const T, work_queue_id_: ?*u32) HRESULT {
                return @as(*const IAudioProcessingObjectRTQueueService.VTable, @ptrCast(self.vtable)).GetRealTimeWorkQueue(@as(*const IAudioProcessingObjectRTQueueService, @ptrCast(self)), work_queue_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APO_LOG_LEVEL = enum(i32) {
    ALWAYS = 0,
    CRITICAL = 1,
    ERROR = 2,
    WARNING = 3,
    INFO = 4,
    VERBOSE = 5,
};
pub const APO_LOG_LEVEL_ALWAYS = APO_LOG_LEVEL.ALWAYS;
pub const APO_LOG_LEVEL_CRITICAL = APO_LOG_LEVEL.CRITICAL;
pub const APO_LOG_LEVEL_ERROR = APO_LOG_LEVEL.ERROR;
pub const APO_LOG_LEVEL_WARNING = APO_LOG_LEVEL.WARNING;
pub const APO_LOG_LEVEL_INFO = APO_LOG_LEVEL.INFO;
pub const APO_LOG_LEVEL_VERBOSE = APO_LOG_LEVEL.VERBOSE;

const IID_IAudioProcessingObjectLoggingService_Value = Guid.initString("698f0107-1745-4708-95a5-d84478a62a65");
pub const IID_IAudioProcessingObjectLoggingService = &IID_IAudioProcessingObjectLoggingService_Value;
pub const IAudioProcessingObjectLoggingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ApoLog: *const fn (
            self: *const IAudioProcessingObjectLoggingService,
            level: APO_LOG_LEVEL,
            format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn apoLog(self: *const T, level_: APO_LOG_LEVEL, format_: ?[*:0]const u16) void {
                return @as(*const IAudioProcessingObjectLoggingService.VTable, @ptrCast(self.vtable)).ApoLog(@as(*const IAudioProcessingObjectLoggingService, @ptrCast(self)), level_, format_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APO_NOTIFICATION_TYPE = enum(i32) {
    NONE = 0,
    ENDPOINT_VOLUME = 1,
    ENDPOINT_PROPERTY_CHANGE = 2,
    SYSTEM_EFFECTS_PROPERTY_CHANGE = 3,
};
pub const APO_NOTIFICATION_TYPE_NONE = APO_NOTIFICATION_TYPE.NONE;
pub const APO_NOTIFICATION_TYPE_ENDPOINT_VOLUME = APO_NOTIFICATION_TYPE.ENDPOINT_VOLUME;
pub const APO_NOTIFICATION_TYPE_ENDPOINT_PROPERTY_CHANGE = APO_NOTIFICATION_TYPE.ENDPOINT_PROPERTY_CHANGE;
pub const APO_NOTIFICATION_TYPE_SYSTEM_EFFECTS_PROPERTY_CHANGE = APO_NOTIFICATION_TYPE.SYSTEM_EFFECTS_PROPERTY_CHANGE;

pub const AUDIO_ENDPOINT_VOLUME_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    volume: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
};

pub const AUDIO_ENDPOINT_PROPERTY_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    propertyStore: ?*IPropertyStore,
    propertyKey: PROPERTYKEY,
};

pub const AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    propertyStoreContext: Guid,
    propertyStoreType: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
    propertyStore: ?*IPropertyStore,
    propertyKey: PROPERTYKEY,
};

pub const APO_NOTIFICATION = extern struct {
    type: APO_NOTIFICATION_TYPE,
    Anonymous: extern union {
        audioEndpointVolumeChange: AUDIO_ENDPOINT_VOLUME_CHANGE_NOTIFICATION,
        audioEndpointPropertyChange: AUDIO_ENDPOINT_PROPERTY_CHANGE_NOTIFICATION,
        audioSystemEffectsPropertyChange: AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_NOTIFICATION,
    },
};

pub const AUDIO_ENDPOINT_VOLUME_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
};

pub const AUDIO_ENDPOINT_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
};

pub const AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
    propertyStoreContext: Guid,
};

pub const APO_NOTIFICATION_DESCRIPTOR = extern struct {
    type: APO_NOTIFICATION_TYPE,
    Anonymous: extern union {
        audioEndpointVolume: AUDIO_ENDPOINT_VOLUME_APO_NOTIFICATION_DESCRIPTOR,
        audioEndpointPropertyChange: AUDIO_ENDPOINT_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR,
        audioSystemEffectsPropertyChange: AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR,
    },
};

const IID_IAudioProcessingObjectNotifications_Value = Guid.initString("56b0c76f-02fd-4b21-a52e-9f8219fc86e4");
pub const IID_IAudioProcessingObjectNotifications = &IID_IAudioProcessingObjectNotifications_Value;
pub const IAudioProcessingObjectNotifications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetApoNotificationRegistrationInfo: *const fn (
            self: *const IAudioProcessingObjectNotifications,
            apo_notifications: [*]?*APO_NOTIFICATION_DESCRIPTOR,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleNotification: *const fn (
            self: *const IAudioProcessingObjectNotifications,
            apo_notification: ?*APO_NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getApoNotificationRegistrationInfo(self: *const T, apo_notifications_: [*]?*APO_NOTIFICATION_DESCRIPTOR, count_: ?*u32) HRESULT {
                return @as(*const IAudioProcessingObjectNotifications.VTable, @ptrCast(self.vtable)).GetApoNotificationRegistrationInfo(@as(*const IAudioProcessingObjectNotifications, @ptrCast(self)), apo_notifications_, count_);
            }
            pub inline fn handleNotification(self: *const T, apo_notification_: ?*APO_NOTIFICATION) void {
                return @as(*const IAudioProcessingObjectNotifications.VTable, @ptrCast(self.vtable)).HandleNotification(@as(*const IAudioProcessingObjectNotifications, @ptrCast(self)), apo_notification_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (15)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 = @import("../../media/audio.zig").__MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002;
const AUDIO_VOLUME_NOTIFICATION_DATA = @import("../../media/audio.zig").AUDIO_VOLUME_NOTIFICATION_DATA;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IMMDevice = @import("../../media/audio.zig").IMMDevice;
const IMMDeviceCollection = @import("../../media/audio.zig").IMMDeviceCollection;
const IPropertyStore = @import("../../ui/shell/properties_system.zig").IPropertyStore;
const IServiceProvider = @import("../../system/com.zig").IServiceProvider;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LPARAM = @import("../../foundation.zig").LPARAM;
const PROPERTYKEY = @import("../../ui/shell/properties_system.zig").PROPERTYKEY;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "FNAPONOTIFICATIONCALLBACK")) {
        _ = FNAPONOTIFICATIONCALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
