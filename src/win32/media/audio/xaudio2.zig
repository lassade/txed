//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (224)
//--------------------------------------------------------------------------------
pub const FXEQ_MIN_FRAMERATE = @as(u32, 22000);
pub const FXEQ_MAX_FRAMERATE = @as(u32, 48000);
pub const FXEQ_MIN_FREQUENCY_CENTER = @as(f32, 20);
pub const FXEQ_MAX_FREQUENCY_CENTER = @as(f32, 20000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_0 = @as(f32, 100);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_1 = @as(f32, 800);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_2 = @as(f32, 2000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_3 = @as(f32, 10000);
pub const FXEQ_MIN_GAIN = @as(f32, 1.26e-01);
pub const FXEQ_MAX_GAIN = @as(f32, 7.94e+00);
pub const FXEQ_DEFAULT_GAIN = @as(f32, 1);
pub const FXEQ_MIN_BANDWIDTH = @as(f32, 1.0e-01);
pub const FXEQ_MAX_BANDWIDTH = @as(f32, 2);
pub const FXEQ_DEFAULT_BANDWIDTH = @as(f32, 1);
pub const FXMASTERINGLIMITER_MIN_RELEASE = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_RELEASE = @as(u32, 20);
pub const FXMASTERINGLIMITER_DEFAULT_RELEASE = @as(u32, 6);
pub const FXMASTERINGLIMITER_MIN_LOUDNESS = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_LOUDNESS = @as(u32, 1800);
pub const FXMASTERINGLIMITER_DEFAULT_LOUDNESS = @as(u32, 1000);
pub const FXREVERB_MIN_DIFFUSION = @as(f32, 0);
pub const FXREVERB_MAX_DIFFUSION = @as(f32, 1);
pub const FXREVERB_DEFAULT_DIFFUSION = @as(f32, 9.0e-01);
pub const FXREVERB_MIN_ROOMSIZE = @as(f32, 1.0e-04);
pub const FXREVERB_MAX_ROOMSIZE = @as(f32, 1);
pub const FXREVERB_DEFAULT_ROOMSIZE = @as(f32, 6.0e-01);
pub const FXLOUDNESS_DEFAULT_MOMENTARY_MS = @as(u32, 400);
pub const FXLOUDNESS_DEFAULT_SHORTTERM_MS = @as(u32, 3000);
pub const FXECHO_MIN_WETDRYMIX = @as(f32, 0);
pub const FXECHO_MAX_WETDRYMIX = @as(f32, 1);
pub const FXECHO_DEFAULT_WETDRYMIX = @as(f32, 5.0e-01);
pub const FXECHO_MIN_FEEDBACK = @as(f32, 0);
pub const FXECHO_MAX_FEEDBACK = @as(f32, 1);
pub const FXECHO_DEFAULT_FEEDBACK = @as(f32, 5.0e-01);
pub const FXECHO_MIN_DELAY = @as(f32, 1);
pub const FXECHO_MAX_DELAY = @as(f32, 2000);
pub const FXECHO_DEFAULT_DELAY = @as(f32, 500);
pub const XAUDIO2_DLL_A = "xaudio2_9.dll";
pub const XAUDIO2_DLL_W = "xaudio2_9.dll";
pub const XAUDIO2D_DLL_A = "xaudio2_9d.dll";
pub const XAUDIO2D_DLL_W = "xaudio2_9d.dll";
pub const XAUDIO2_DLL = "xaudio2_9.dll";
pub const XAUDIO2D_DLL = "xaudio2_9d.dll";
pub const XAUDIO2_MAX_BUFFER_BYTES = @as(u32, 2147483648);
pub const XAUDIO2_MAX_QUEUED_BUFFERS = @as(u32, 64);
pub const XAUDIO2_MAX_BUFFERS_SYSTEM = @as(u32, 2);
pub const XAUDIO2_MAX_AUDIO_CHANNELS = @as(u32, 64);
pub const XAUDIO2_MIN_SAMPLE_RATE = @as(u32, 1000);
pub const XAUDIO2_MAX_SAMPLE_RATE = @as(u32, 200000);
pub const XAUDIO2_MAX_VOLUME_LEVEL = @as(f32, 16777216);
pub const XAUDIO2_MAX_FREQ_RATIO = @as(f32, 1024);
pub const XAUDIO2_DEFAULT_FREQ_RATIO = @as(f32, 2);
pub const XAUDIO2_MAX_FILTER_ONEOVERQ = @as(f32, 1.5e+00);
pub const XAUDIO2_MAX_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_MAX_LOOP_COUNT = @as(u32, 254);
pub const XAUDIO2_MAX_INSTANCES = @as(u32, 8);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO = @as(u32, 600000);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL = @as(u32, 300000);
pub const XAUDIO2_COMMIT_NOW = @as(u32, 0);
pub const XAUDIO2_COMMIT_ALL = @as(u32, 0);
pub const XAUDIO2_NO_LOOP_REGION = @as(u32, 0);
pub const XAUDIO2_LOOP_INFINITE = @as(u32, 255);
pub const XAUDIO2_DEFAULT_CHANNELS = @as(u32, 0);
pub const XAUDIO2_DEFAULT_SAMPLERATE = @as(u32, 0);
pub const XAUDIO2_DEBUG_ENGINE = @as(u32, 1);
pub const XAUDIO2_VOICE_NOPITCH = @as(u32, 2);
pub const XAUDIO2_VOICE_NOSRC = @as(u32, 4);
pub const XAUDIO2_VOICE_USEFILTER = @as(u32, 8);
pub const XAUDIO2_PLAY_TAILS = @as(u32, 32);
pub const XAUDIO2_END_OF_STREAM = @as(u32, 64);
pub const XAUDIO2_SEND_USEFILTER = @as(u32, 128);
pub const XAUDIO2_VOICE_NOSAMPLESPLAYED = @as(u32, 256);
pub const XAUDIO2_STOP_ENGINE_WHEN_IDLE = @as(u32, 8192);
pub const XAUDIO2_1024_QUANTUM = @as(u32, 32768);
pub const XAUDIO2_NO_VIRTUAL_AUDIO_CLIENT = @as(u32, 65536);
pub const XAUDIO2_DEFAULT_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_DEFAULT_FILTER_ONEOVERQ = @as(f32, 1);
pub const XAUDIO2_QUANTUM_NUMERATOR = @as(u32, 1);
pub const XAUDIO2_QUANTUM_DENOMINATOR = @as(u32, 100);
pub const FACILITY_XAUDIO2 = @as(u32, 2198);
pub const XAUDIO2_E_INVALID_CALL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435519));
pub const XAUDIO2_E_XMA_DECODER_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435518));
pub const XAUDIO2_E_XAPO_CREATION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435517));
pub const XAUDIO2_E_DEVICE_INVALIDATED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435516));
pub const Processor1 = @as(u32, 1);
pub const Processor2 = @as(u32, 2);
pub const Processor3 = @as(u32, 4);
pub const Processor4 = @as(u32, 8);
pub const Processor5 = @as(u32, 16);
pub const Processor6 = @as(u32, 32);
pub const Processor7 = @as(u32, 64);
pub const Processor8 = @as(u32, 128);
pub const Processor9 = @as(u32, 256);
pub const Processor10 = @as(u32, 512);
pub const Processor11 = @as(u32, 1024);
pub const Processor12 = @as(u32, 2048);
pub const Processor13 = @as(u32, 4096);
pub const Processor14 = @as(u32, 8192);
pub const Processor15 = @as(u32, 16384);
pub const Processor16 = @as(u32, 32768);
pub const Processor17 = @as(u32, 65536);
pub const Processor18 = @as(u32, 131072);
pub const Processor19 = @as(u32, 262144);
pub const Processor20 = @as(u32, 524288);
pub const Processor21 = @as(u32, 1048576);
pub const Processor22 = @as(u32, 2097152);
pub const Processor23 = @as(u32, 4194304);
pub const Processor24 = @as(u32, 8388608);
pub const Processor25 = @as(u32, 16777216);
pub const Processor26 = @as(u32, 33554432);
pub const Processor27 = @as(u32, 67108864);
pub const Processor28 = @as(u32, 134217728);
pub const Processor29 = @as(u32, 268435456);
pub const Processor30 = @as(u32, 536870912);
pub const Processor31 = @as(u32, 1073741824);
pub const Processor32 = @as(u32, 2147483648);
pub const XAUDIO2_ANY_PROCESSOR = @as(u32, 4294967295);
pub const XAUDIO2_USE_DEFAULT_PROCESSOR = @as(u32, 0);
pub const XAUDIO2_DEFAULT_PROCESSOR = @as(u32, 1);
pub const XAUDIO2_LOG_ERRORS = @as(u32, 1);
pub const XAUDIO2_LOG_WARNINGS = @as(u32, 2);
pub const XAUDIO2_LOG_INFO = @as(u32, 4);
pub const XAUDIO2_LOG_DETAIL = @as(u32, 8);
pub const XAUDIO2_LOG_API_CALLS = @as(u32, 16);
pub const XAUDIO2_LOG_FUNC_CALLS = @as(u32, 32);
pub const XAUDIO2_LOG_TIMING = @as(u32, 64);
pub const XAUDIO2_LOG_LOCKS = @as(u32, 128);
pub const XAUDIO2_LOG_MEMORY = @as(u32, 256);
pub const XAUDIO2_LOG_STREAMING = @as(u32, 4096);
pub const XAUDIO2FX_REVERB_MIN_FRAMERATE = @as(u32, 20000);
pub const XAUDIO2FX_REVERB_MAX_FRAMERATE = @as(u32, 48000);
pub const XAUDIO2FX_REVERB_MIN_WET_DRY_MIX = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REVERB_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_SIDE_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_POSITION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_DIFFUSION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_FREQ = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_MAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_HF = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REVERB_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_DECAY_TIME = @as(f32, 1.0e-01);
pub const XAUDIO2FX_REVERB_MIN_DENSITY = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_SIZE = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_DELAY = @as(u32, 300);
pub const XAUDIO2FX_REVERB_MAX_REVERB_DELAY = @as(u32, 85);
pub const XAUDIO2FX_REVERB_MAX_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_MAX_POSITION = @as(u32, 30);
pub const XAUDIO2FX_REVERB_MAX_DIFFUSION = @as(u32, 15);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_GAIN = @as(u32, 12);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_CUTOFF = @as(u32, 9);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_CUTOFF = @as(u32, 14);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_FREQ = @as(f32, 20000);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_REVERB_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION = @as(u32, 6);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION_MATRIX = @as(u32, 27);
pub const XAUDIO2FX_REVERB_DEFAULT_EARLY_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LATE_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_FREQ = @as(f32, 5000);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_DECAY_TIME = @as(f32, 1);
pub const XAUDIO2FX_REVERB_DEFAULT_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_DISABLE_LATE_FIELD = @as(u32, 0);
pub const HRTF_MAX_GAIN_LIMIT = @as(f32, 12);
pub const HRTF_MIN_GAIN_LIMIT = @as(f32, -96);
pub const HRTF_MIN_UNITY_GAIN_DISTANCE = @as(f32, 5.0e-02);
pub const HRTF_DEFAULT_UNITY_GAIN_DISTANCE = @as(f32, 1);
pub const FACILITY_XAPO = @as(u32, 2199);
pub const XAPO_E_FORMAT_UNSUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003369983));
pub const XAPO_MIN_CHANNELS = @as(u32, 1);
pub const XAPO_MAX_CHANNELS = @as(u32, 64);
pub const XAPO_MIN_FRAMERATE = @as(u32, 1000);
pub const XAPO_MAX_FRAMERATE = @as(u32, 200000);
pub const XAPO_REGISTRATION_STRING_LENGTH = @as(u32, 256);
pub const XAPO_FLAG_CHANNELS_MUST_MATCH = @as(u32, 1);
pub const XAPO_FLAG_FRAMERATE_MUST_MATCH = @as(u32, 2);
pub const XAPO_FLAG_BITSPERSAMPLE_MUST_MATCH = @as(u32, 4);
pub const XAPO_FLAG_BUFFERCOUNT_MUST_MATCH = @as(u32, 8);
pub const XAPO_FLAG_INPLACE_REQUIRED = @as(u32, 32);
pub const XAPO_FLAG_INPLACE_SUPPORTED = @as(u32, 16);
pub const SPEAKER_MONO = @as(u32, 4);
pub const X3DAUDIO_HANDLE_BYTESIZE = @as(u32, 20);
pub const X3DAUDIO_PI = @as(f32, 3.1415927e+00);
pub const X3DAUDIO_2PI = @as(f32, 6.2831855e+00);
pub const X3DAUDIO_SPEED_OF_SOUND = @as(f32, 3.435e+02);
pub const X3DAUDIO_CALCULATE_MATRIX = @as(u32, 1);
pub const X3DAUDIO_CALCULATE_DELAY = @as(u32, 2);
pub const X3DAUDIO_CALCULATE_LPF_DIRECT = @as(u32, 4);
pub const X3DAUDIO_CALCULATE_LPF_REVERB = @as(u32, 8);
pub const X3DAUDIO_CALCULATE_REVERB = @as(u32, 16);
pub const X3DAUDIO_CALCULATE_DOPPLER = @as(u32, 32);
pub const X3DAUDIO_CALCULATE_EMITTER_ANGLE = @as(u32, 64);
pub const X3DAUDIO_CALCULATE_ZEROCENTER = @as(u32, 65536);
pub const X3DAUDIO_CALCULATE_REDIRECT_TO_LFE = @as(u32, 131072);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
pub const XAPO_REGISTRATION_PROPERTIES = extern struct {
    clsid: Guid align(1),
    FriendlyName: [256]u16 align(1),
    CopyrightInfo: [256]u16 align(1),
    MajorVersion: u32 align(1),
    MinorVersion: u32 align(1),
    Flags: u32 align(1),
    MinInputBufferCount: u32 align(1),
    MaxInputBufferCount: u32 align(1),
    MinOutputBufferCount: u32 align(1),
    MaxOutputBufferCount: u32 align(1),
};

pub const XAPO_LOCKFORPROCESS_PARAMETERS = extern struct {
    pFormat: ?*const WAVEFORMATEX align(1),
    MaxFrameCount: u32 align(1),
};

pub const XAPO_BUFFER_FLAGS = enum(i32) {
    SILENT = 0,
    VALID = 1,
};
pub const XAPO_BUFFER_SILENT = XAPO_BUFFER_FLAGS.SILENT;
pub const XAPO_BUFFER_VALID = XAPO_BUFFER_FLAGS.VALID;

pub const XAPO_PROCESS_BUFFER_PARAMETERS = extern struct {
    pBuffer: ?*anyopaque align(1),
    BufferFlags: XAPO_BUFFER_FLAGS align(1),
    ValidFrameCount: u32 align(1),
};

const IID_IXAPO_Value = Guid.initString("a410b984-9839-4819-a0be-2856ae6b3adb");
pub const IID_IXAPO = &IID_IXAPO_Value;
pub const IXAPO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegistrationProperties: *const fn (
            self: *const IXAPO,
            pp_registration_properties: ?*?*XAPO_REGISTRATION_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInputFormatSupported: *const fn (
            self: *const IXAPO,
            p_output_format: ?*const WAVEFORMATEX,
            p_requested_input_format: ?*const WAVEFORMATEX,
            pp_supported_input_format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOutputFormatSupported: *const fn (
            self: *const IXAPO,
            p_input_format: ?*const WAVEFORMATEX,
            p_requested_output_format: ?*const WAVEFORMATEX,
            pp_supported_output_format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: *const fn (
            self: *const IXAPO,
            // TODO: what to do with BytesParamIndex 1?
            p_data: ?*const anyopaque,
            data_byte_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        LockForProcess: *const fn (
            self: *const IXAPO,
            input_locked_parameter_count: u32,
            p_input_locked_parameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
            output_locked_parameter_count: u32,
            p_output_locked_parameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockForProcess: *const fn (
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Process: *const fn (
            self: *const IXAPO,
            input_process_parameter_count: u32,
            p_input_process_parameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS,
            output_process_parameter_count: u32,
            p_output_process_parameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS,
            is_enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CalcInputFrames: *const fn (
            self: *const IXAPO,
            output_frame_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CalcOutputFrames: *const fn (
            self: *const IXAPO,
            input_frame_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRegistrationProperties(self: *const T, pp_registration_properties_: ?*?*XAPO_REGISTRATION_PROPERTIES) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).GetRegistrationProperties(@as(*const IXAPO, @ptrCast(self)), pp_registration_properties_);
            }
            pub inline fn isInputFormatSupported(self: *const T, p_output_format_: ?*const WAVEFORMATEX, p_requested_input_format_: ?*const WAVEFORMATEX, pp_supported_input_format_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).IsInputFormatSupported(@as(*const IXAPO, @ptrCast(self)), p_output_format_, p_requested_input_format_, pp_supported_input_format_);
            }
            pub inline fn isOutputFormatSupported(self: *const T, p_input_format_: ?*const WAVEFORMATEX, p_requested_output_format_: ?*const WAVEFORMATEX, pp_supported_output_format_: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).IsOutputFormatSupported(@as(*const IXAPO, @ptrCast(self)), p_input_format_, p_requested_output_format_, pp_supported_output_format_);
            }
            pub inline fn initialize(self: *const T, p_data_: ?*const anyopaque, data_byte_size_: u32) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IXAPO, @ptrCast(self)), p_data_, data_byte_size_);
            }
            pub inline fn reset(self: *const T) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Reset(@as(*const IXAPO, @ptrCast(self)));
            }
            pub inline fn lockForProcess(self: *const T, input_locked_parameter_count_: u32, p_input_locked_parameters_: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS, output_locked_parameter_count_: u32, p_output_locked_parameters_: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).LockForProcess(@as(*const IXAPO, @ptrCast(self)), input_locked_parameter_count_, p_input_locked_parameters_, output_locked_parameter_count_, p_output_locked_parameters_);
            }
            pub inline fn unlockForProcess(self: *const T) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).UnlockForProcess(@as(*const IXAPO, @ptrCast(self)));
            }
            pub inline fn process(self: *const T, input_process_parameter_count_: u32, p_input_process_parameters_: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS, output_process_parameter_count_: u32, p_output_process_parameters_: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS, is_enabled_: BOOL) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Process(@as(*const IXAPO, @ptrCast(self)), input_process_parameter_count_, p_input_process_parameters_, output_process_parameter_count_, p_output_process_parameters_, is_enabled_);
            }
            pub inline fn calcInputFrames(self: *const T, output_frame_count_: u32) u32 {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).CalcInputFrames(@as(*const IXAPO, @ptrCast(self)), output_frame_count_);
            }
            pub inline fn calcOutputFrames(self: *const T, input_frame_count_: u32) u32 {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).CalcOutputFrames(@as(*const IXAPO, @ptrCast(self)), input_frame_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAPOParameters_Value = Guid.initString("26d95c66-80f2-499a-ad54-5ae7f01c6d98");
pub const IID_IXAPOParameters = &IID_IXAPOParameters_Value;
pub const IXAPOParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParameters: *const fn (
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            p_parameters: ?*const anyopaque,
            parameter_byte_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetParameters: *const fn (
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            p_parameters: ?*anyopaque,
            parameter_byte_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setParameters(self: *const T, p_parameters_: ?*const anyopaque, parameter_byte_size_: u32) void {
                return @as(*const IXAPOParameters.VTable, @ptrCast(self.vtable)).SetParameters(@as(*const IXAPOParameters, @ptrCast(self)), p_parameters_, parameter_byte_size_);
            }
            pub inline fn getParameters(self: *const T, p_parameters_: ?*anyopaque, parameter_byte_size_: u32) void {
                return @as(*const IXAPOParameters.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IXAPOParameters, @ptrCast(self)), p_parameters_, parameter_byte_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FXEQ_Value = Guid.initString("f5e01117-d6c4-485a-a3f5-695196f3dbfa");
pub const CLSID_FXEQ = &CLSID_FXEQ_Value;

const CLSID_FXMasteringLimiter_Value = Guid.initString("c4137916-2be1-46fd-8599-441536f49856");
pub const CLSID_FXMasteringLimiter = &CLSID_FXMasteringLimiter_Value;

const CLSID_FXReverb_Value = Guid.initString("7d9aca56-cb68-4807-b632-b137352e8596");
pub const CLSID_FXReverb = &CLSID_FXReverb_Value;

const CLSID_FXEcho_Value = Guid.initString("5039d740-f736-449a-84d3-a56202557b87");
pub const CLSID_FXEcho = &CLSID_FXEcho_Value;

pub const FXEQ_PARAMETERS = extern struct {
    FrequencyCenter0: f32 align(1),
    Gain0: f32 align(1),
    Bandwidth0: f32 align(1),
    FrequencyCenter1: f32 align(1),
    Gain1: f32 align(1),
    Bandwidth1: f32 align(1),
    FrequencyCenter2: f32 align(1),
    Gain2: f32 align(1),
    Bandwidth2: f32 align(1),
    FrequencyCenter3: f32 align(1),
    Gain3: f32 align(1),
    Bandwidth3: f32 align(1),
};

pub const FXMASTERINGLIMITER_PARAMETERS = extern struct {
    Release: u32 align(1),
    Loudness: u32 align(1),
};

pub const FXREVERB_PARAMETERS = extern struct {
    Diffusion: f32 align(1),
    RoomSize: f32 align(1),
};

pub const FXECHO_INITDATA = extern struct {
    MaxDelay: f32 align(1),
};

pub const FXECHO_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Feedback: f32 align(1),
    Delay: f32 align(1),
};

pub const XAUDIO2_VOICE_DETAILS = extern struct {
    CreationFlags: u32 align(1),
    ActiveFlags: u32 align(1),
    InputChannels: u32 align(1),
    InputSampleRate: u32 align(1),
};

pub const XAUDIO2_SEND_DESCRIPTOR = extern struct {
    Flags: u32 align(1),
    pOutputVoice: ?*IXAudio2Voice align(1),
};

pub const XAUDIO2_VOICE_SENDS = extern struct {
    SendCount: u32 align(1),
    pSends: ?*XAUDIO2_SEND_DESCRIPTOR align(1),
};

pub const XAUDIO2_EFFECT_DESCRIPTOR = extern struct {
    pEffect: ?*IUnknown align(1),
    InitialState: BOOL align(1),
    OutputChannels: u32 align(1),
};

pub const XAUDIO2_EFFECT_CHAIN = extern struct {
    EffectCount: u32 align(1),
    pEffectDescriptors: ?*XAUDIO2_EFFECT_DESCRIPTOR align(1),
};

pub const XAUDIO2_FILTER_TYPE = enum(i32) {
    LowPassFilter = 0,
    BandPassFilter = 1,
    HighPassFilter = 2,
    NotchFilter = 3,
    LowPassOnePoleFilter = 4,
    HighPassOnePoleFilter = 5,
};
pub const LowPassFilter = XAUDIO2_FILTER_TYPE.LowPassFilter;
pub const BandPassFilter = XAUDIO2_FILTER_TYPE.BandPassFilter;
pub const HighPassFilter = XAUDIO2_FILTER_TYPE.HighPassFilter;
pub const NotchFilter = XAUDIO2_FILTER_TYPE.NotchFilter;
pub const LowPassOnePoleFilter = XAUDIO2_FILTER_TYPE.LowPassOnePoleFilter;
pub const HighPassOnePoleFilter = XAUDIO2_FILTER_TYPE.HighPassOnePoleFilter;

pub const XAUDIO2_FILTER_PARAMETERS = extern struct {
    Type: XAUDIO2_FILTER_TYPE align(1),
    Frequency: f32 align(1),
    OneOverQ: f32 align(1),
};

pub const XAUDIO2_BUFFER = extern struct {
    Flags: u32 align(1),
    AudioBytes: u32 align(1),
    pAudioData: ?*const u8 align(1),
    PlayBegin: u32 align(1),
    PlayLength: u32 align(1),
    LoopBegin: u32 align(1),
    LoopLength: u32 align(1),
    LoopCount: u32 align(1),
    pContext: ?*anyopaque align(1),
};

pub const XAUDIO2_BUFFER_WMA = extern struct {
    pDecodedPacketCumulativeBytes: ?*const u32 align(1),
    PacketCount: u32 align(1),
};

pub const XAUDIO2_VOICE_STATE = extern struct {
    pCurrentBufferContext: ?*anyopaque align(1),
    BuffersQueued: u32 align(1),
    SamplesPlayed: u64 align(1),
};

pub const XAUDIO2_PERFORMANCE_DATA = extern struct {
    AudioCyclesSinceLastQuery: u64 align(1),
    TotalCyclesSinceLastQuery: u64 align(1),
    MinimumCyclesPerQuantum: u32 align(1),
    MaximumCyclesPerQuantum: u32 align(1),
    MemoryUsageInBytes: u32 align(1),
    CurrentLatencyInSamples: u32 align(1),
    GlitchesSinceEngineStarted: u32 align(1),
    ActiveSourceVoiceCount: u32 align(1),
    TotalSourceVoiceCount: u32 align(1),
    ActiveSubmixVoiceCount: u32 align(1),
    ActiveResamplerCount: u32 align(1),
    ActiveMatrixMixCount: u32 align(1),
    ActiveXmaSourceVoices: u32 align(1),
    ActiveXmaStreams: u32 align(1),
};

pub const XAUDIO2_DEBUG_CONFIGURATION = extern struct {
    TraceMask: u32 align(1),
    BreakMask: u32 align(1),
    LogThreadID: BOOL align(1),
    LogFileline: BOOL align(1),
    LogFunctionName: BOOL align(1),
    LogTiming: BOOL align(1),
};

const IID_IXAudio2_Value = Guid.initString("2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d");
pub const IID_IXAudio2 = &IID_IXAudio2_Value;
pub const IXAudio2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterForCallbacks: *const fn (
            self: *const IXAudio2,
            p_callback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForCallbacks: *const fn (
            self: *const IXAudio2,
            p_callback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CreateSourceVoice: *const fn (
            self: *const IXAudio2,
            pp_source_voice: ?*?*IXAudio2SourceVoice,
            p_source_format: ?*const WAVEFORMATEX,
            flags: u32,
            max_frequency_ratio: f32,
            p_callback: ?*IXAudio2VoiceCallback,
            p_send_list: ?*const XAUDIO2_VOICE_SENDS,
            p_effect_chain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubmixVoice: *const fn (
            self: *const IXAudio2,
            pp_submix_voice: ?*?*IXAudio2SubmixVoice,
            input_channels: u32,
            input_sample_rate: u32,
            flags: u32,
            processing_stage: u32,
            p_send_list: ?*const XAUDIO2_VOICE_SENDS,
            p_effect_chain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMasteringVoice: *const fn (
            self: *const IXAudio2,
            pp_mastering_voice: ?*?*IXAudio2MasteringVoice,
            input_channels: u32,
            input_sample_rate: u32,
            flags: u32,
            sz_device_id: ?[*:0]const u16,
            p_effect_chain: ?*const XAUDIO2_EFFECT_CHAIN,
            stream_category: AUDIO_STREAM_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartEngine: *const fn (
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopEngine: *const fn (
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CommitChanges: *const fn (
            self: *const IXAudio2,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPerformanceData: *const fn (
            self: *const IXAudio2,
            p_perf_data: ?*XAUDIO2_PERFORMANCE_DATA,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetDebugConfiguration: *const fn (
            self: *const IXAudio2,
            p_debug_configuration: ?*const XAUDIO2_DEBUG_CONFIGURATION,
            p_reserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerForCallbacks(self: *const T, p_callback_: ?*IXAudio2EngineCallback) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).RegisterForCallbacks(@as(*const IXAudio2, @ptrCast(self)), p_callback_);
            }
            pub inline fn unregisterForCallbacks(self: *const T, p_callback_: ?*IXAudio2EngineCallback) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).UnregisterForCallbacks(@as(*const IXAudio2, @ptrCast(self)), p_callback_);
            }
            pub inline fn createSourceVoice(self: *const T, pp_source_voice_: ?*?*IXAudio2SourceVoice, p_source_format_: ?*const WAVEFORMATEX, flags_: u32, max_frequency_ratio_: f32, p_callback_: ?*IXAudio2VoiceCallback, p_send_list_: ?*const XAUDIO2_VOICE_SENDS, p_effect_chain_: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateSourceVoice(@as(*const IXAudio2, @ptrCast(self)), pp_source_voice_, p_source_format_, flags_, max_frequency_ratio_, p_callback_, p_send_list_, p_effect_chain_);
            }
            pub inline fn createSubmixVoice(self: *const T, pp_submix_voice_: ?*?*IXAudio2SubmixVoice, input_channels_: u32, input_sample_rate_: u32, flags_: u32, processing_stage_: u32, p_send_list_: ?*const XAUDIO2_VOICE_SENDS, p_effect_chain_: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateSubmixVoice(@as(*const IXAudio2, @ptrCast(self)), pp_submix_voice_, input_channels_, input_sample_rate_, flags_, processing_stage_, p_send_list_, p_effect_chain_);
            }
            pub inline fn createMasteringVoice(self: *const T, pp_mastering_voice_: ?*?*IXAudio2MasteringVoice, input_channels_: u32, input_sample_rate_: u32, flags_: u32, sz_device_id_: ?[*:0]const u16, p_effect_chain_: ?*const XAUDIO2_EFFECT_CHAIN, stream_category_: AUDIO_STREAM_CATEGORY) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateMasteringVoice(@as(*const IXAudio2, @ptrCast(self)), pp_mastering_voice_, input_channels_, input_sample_rate_, flags_, sz_device_id_, p_effect_chain_, stream_category_);
            }
            pub inline fn startEngine(self: *const T) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).StartEngine(@as(*const IXAudio2, @ptrCast(self)));
            }
            pub inline fn stopEngine(self: *const T) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).StopEngine(@as(*const IXAudio2, @ptrCast(self)));
            }
            pub inline fn commitChanges(self: *const T, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CommitChanges(@as(*const IXAudio2, @ptrCast(self)), operation_set_);
            }
            pub inline fn getPerformanceData(self: *const T, p_perf_data_: ?*XAUDIO2_PERFORMANCE_DATA) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).GetPerformanceData(@as(*const IXAudio2, @ptrCast(self)), p_perf_data_);
            }
            pub inline fn setDebugConfiguration(self: *const T, p_debug_configuration_: ?*const XAUDIO2_DEBUG_CONFIGURATION, p_reserved_: ?*anyopaque) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).SetDebugConfiguration(@as(*const IXAudio2, @ptrCast(self)), p_debug_configuration_, p_reserved_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAudio2Extension_Value = Guid.initString("84ac29bb-d619-44d2-b197-e4acf7df3ed6");
pub const IID_IXAudio2Extension = &IID_IXAudio2Extension_Value;
pub const IXAudio2Extension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessingQuantum: *const fn (
            self: *const IXAudio2Extension,
            quantum_numerator: ?*u32,
            quantum_denominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetProcessor: *const fn (
            self: *const IXAudio2Extension,
            processor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getProcessingQuantum(self: *const T, quantum_numerator_: ?*u32, quantum_denominator_: ?*u32) void {
                return @as(*const IXAudio2Extension.VTable, @ptrCast(self.vtable)).GetProcessingQuantum(@as(*const IXAudio2Extension, @ptrCast(self)), quantum_numerator_, quantum_denominator_);
            }
            pub inline fn getProcessor(self: *const T, processor_: ?*u32) void {
                return @as(*const IXAudio2Extension.VTable, @ptrCast(self.vtable)).GetProcessor(@as(*const IXAudio2Extension, @ptrCast(self)), processor_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2Voice = extern struct {
    pub const VTable = extern struct {
        GetVoiceDetails: *const fn (
            self: *const IXAudio2Voice,
            p_voice_details: ?*XAUDIO2_VOICE_DETAILS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputVoices: *const fn (
            self: *const IXAudio2Voice,
            p_send_list: ?*const XAUDIO2_VOICE_SENDS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectChain: *const fn (
            self: *const IXAudio2Voice,
            p_effect_chain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableEffect: *const fn (
            self: *const IXAudio2Voice,
            effect_index: u32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableEffect: *const fn (
            self: *const IXAudio2Voice,
            effect_index: u32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectState: *const fn (
            self: *const IXAudio2Voice,
            effect_index: u32,
            p_enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetEffectParameters: *const fn (
            self: *const IXAudio2Voice,
            effect_index: u32,
            // TODO: what to do with BytesParamIndex 2?
            p_parameters: ?*const anyopaque,
            parameters_byte_size: u32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectParameters: *const fn (
            self: *const IXAudio2Voice,
            effect_index: u32,
            // TODO: what to do with BytesParamIndex 2?
            p_parameters: ?*anyopaque,
            parameters_byte_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilterParameters: *const fn (
            self: *const IXAudio2Voice,
            p_parameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterParameters: *const fn (
            self: *const IXAudio2Voice,
            p_parameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputFilterParameters: *const fn (
            self: *const IXAudio2Voice,
            p_destination_voice: ?*IXAudio2Voice,
            p_parameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFilterParameters: *const fn (
            self: *const IXAudio2Voice,
            p_destination_voice: ?*IXAudio2Voice,
            p_parameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetVolume: *const fn (
            self: *const IXAudio2Voice,
            volume: f32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: *const fn (
            self: *const IXAudio2Voice,
            p_volume: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetChannelVolumes: *const fn (
            self: *const IXAudio2Voice,
            channels: u32,
            p_volumes: [*]const f32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumes: *const fn (
            self: *const IXAudio2Voice,
            channels: u32,
            p_volumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputMatrix: *const fn (
            self: *const IXAudio2Voice,
            p_destination_voice: ?*IXAudio2Voice,
            source_channels: u32,
            destination_channels: u32,
            p_level_matrix: ?*const f32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMatrix: *const fn (
            self: *const IXAudio2Voice,
            p_destination_voice: ?*IXAudio2Voice,
            source_channels: u32,
            destination_channels: u32,
            p_level_matrix: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DestroyVoice: *const fn (
            self: *const IXAudio2Voice,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn getVoiceDetails(self: *const T, p_voice_details_: ?*XAUDIO2_VOICE_DETAILS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetVoiceDetails(@as(*const IXAudio2Voice, @ptrCast(self)), p_voice_details_);
            }
            pub inline fn setOutputVoices(self: *const T, p_send_list_: ?*const XAUDIO2_VOICE_SENDS) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputVoices(@as(*const IXAudio2Voice, @ptrCast(self)), p_send_list_);
            }
            pub inline fn setEffectChain(self: *const T, p_effect_chain_: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetEffectChain(@as(*const IXAudio2Voice, @ptrCast(self)), p_effect_chain_);
            }
            pub inline fn enableEffect(self: *const T, effect_index_: u32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).EnableEffect(@as(*const IXAudio2Voice, @ptrCast(self)), effect_index_, operation_set_);
            }
            pub inline fn disableEffect(self: *const T, effect_index_: u32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).DisableEffect(@as(*const IXAudio2Voice, @ptrCast(self)), effect_index_, operation_set_);
            }
            pub inline fn getEffectState(self: *const T, effect_index_: u32, p_enabled_: ?*BOOL) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetEffectState(@as(*const IXAudio2Voice, @ptrCast(self)), effect_index_, p_enabled_);
            }
            pub inline fn setEffectParameters(self: *const T, effect_index_: u32, p_parameters_: ?*const anyopaque, parameters_byte_size_: u32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetEffectParameters(@as(*const IXAudio2Voice, @ptrCast(self)), effect_index_, p_parameters_, parameters_byte_size_, operation_set_);
            }
            pub inline fn getEffectParameters(self: *const T, effect_index_: u32, p_parameters_: ?*anyopaque, parameters_byte_size_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetEffectParameters(@as(*const IXAudio2Voice, @ptrCast(self)), effect_index_, p_parameters_, parameters_byte_size_);
            }
            pub inline fn setFilterParameters(self: *const T, p_parameters_: ?*const XAUDIO2_FILTER_PARAMETERS, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), p_parameters_, operation_set_);
            }
            pub inline fn getFilterParameters(self: *const T, p_parameters_: ?*XAUDIO2_FILTER_PARAMETERS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), p_parameters_);
            }
            pub inline fn setOutputFilterParameters(self: *const T, p_destination_voice_: ?*IXAudio2Voice, p_parameters_: ?*const XAUDIO2_FILTER_PARAMETERS, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), p_destination_voice_, p_parameters_, operation_set_);
            }
            pub inline fn getOutputFilterParameters(self: *const T, p_destination_voice_: ?*IXAudio2Voice, p_parameters_: ?*XAUDIO2_FILTER_PARAMETERS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetOutputFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), p_destination_voice_, p_parameters_);
            }
            pub inline fn setVolume(self: *const T, volume_: f32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const IXAudio2Voice, @ptrCast(self)), volume_, operation_set_);
            }
            pub inline fn getVolume(self: *const T, p_volume_: ?*f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetVolume(@as(*const IXAudio2Voice, @ptrCast(self)), p_volume_);
            }
            pub inline fn setChannelVolumes(self: *const T, channels_: u32, p_volumes_: [*]const f32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetChannelVolumes(@as(*const IXAudio2Voice, @ptrCast(self)), channels_, p_volumes_, operation_set_);
            }
            pub inline fn getChannelVolumes(self: *const T, channels_: u32, p_volumes_: [*]f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetChannelVolumes(@as(*const IXAudio2Voice, @ptrCast(self)), channels_, p_volumes_);
            }
            pub inline fn setOutputMatrix(self: *const T, p_destination_voice_: ?*IXAudio2Voice, source_channels_: u32, destination_channels_: u32, p_level_matrix_: ?*const f32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputMatrix(@as(*const IXAudio2Voice, @ptrCast(self)), p_destination_voice_, source_channels_, destination_channels_, p_level_matrix_, operation_set_);
            }
            pub inline fn getOutputMatrix(self: *const T, p_destination_voice_: ?*IXAudio2Voice, source_channels_: u32, destination_channels_: u32, p_level_matrix_: ?*f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetOutputMatrix(@as(*const IXAudio2Voice, @ptrCast(self)), p_destination_voice_, source_channels_, destination_channels_, p_level_matrix_);
            }
            pub inline fn destroyVoice(self: *const T) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).DestroyVoice(@as(*const IXAudio2Voice, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SourceVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        Start: *const fn (
            self: *const IXAudio2SourceVoice,
            flags: u32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn (
            self: *const IXAudio2SourceVoice,
            flags: u32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitSourceBuffer: *const fn (
            self: *const IXAudio2SourceVoice,
            p_buffer: ?*const XAUDIO2_BUFFER,
            p_buffer_w_m_a: ?*const XAUDIO2_BUFFER_WMA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushSourceBuffers: *const fn (
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Discontinuity: *const fn (
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitLoop: *const fn (
            self: *const IXAudio2SourceVoice,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn (
            self: *const IXAudio2SourceVoice,
            p_voice_state: ?*XAUDIO2_VOICE_STATE,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetFrequencyRatio: *const fn (
            self: *const IXAudio2SourceVoice,
            ratio: f32,
            operation_set: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequencyRatio: *const fn (
            self: *const IXAudio2SourceVoice,
            p_ratio: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetSourceSampleRate: *const fn (
            self: *const IXAudio2SourceVoice,
            new_source_sample_rate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
            pub inline fn start(self: *const T, flags_: u32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Start(@as(*const IXAudio2SourceVoice, @ptrCast(self)), flags_, operation_set_);
            }
            pub inline fn stop(self: *const T, flags_: u32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Stop(@as(*const IXAudio2SourceVoice, @ptrCast(self)), flags_, operation_set_);
            }
            pub inline fn submitSourceBuffer(self: *const T, p_buffer_: ?*const XAUDIO2_BUFFER, p_buffer_w_m_a_: ?*const XAUDIO2_BUFFER_WMA) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SubmitSourceBuffer(@as(*const IXAudio2SourceVoice, @ptrCast(self)), p_buffer_, p_buffer_w_m_a_);
            }
            pub inline fn flushSourceBuffers(self: *const T) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).FlushSourceBuffers(@as(*const IXAudio2SourceVoice, @ptrCast(self)));
            }
            pub inline fn discontinuity(self: *const T) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Discontinuity(@as(*const IXAudio2SourceVoice, @ptrCast(self)));
            }
            pub inline fn exitLoop(self: *const T, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).ExitLoop(@as(*const IXAudio2SourceVoice, @ptrCast(self)), operation_set_);
            }
            pub inline fn getState(self: *const T, p_voice_state_: ?*XAUDIO2_VOICE_STATE, flags_: u32) void {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).GetState(@as(*const IXAudio2SourceVoice, @ptrCast(self)), p_voice_state_, flags_);
            }
            pub inline fn setFrequencyRatio(self: *const T, ratio_: f32, operation_set_: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SetFrequencyRatio(@as(*const IXAudio2SourceVoice, @ptrCast(self)), ratio_, operation_set_);
            }
            pub inline fn getFrequencyRatio(self: *const T, p_ratio_: ?*f32) void {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).GetFrequencyRatio(@as(*const IXAudio2SourceVoice, @ptrCast(self)), p_ratio_);
            }
            pub inline fn setSourceSampleRate(self: *const T, new_source_sample_rate_: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SetSourceSampleRate(@as(*const IXAudio2SourceVoice, @ptrCast(self)), new_source_sample_rate_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SubmixVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2MasteringVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        GetChannelMask: *const fn (
            self: *const IXAudio2MasteringVoice,
            p_channelmask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
            pub inline fn getChannelMask(self: *const T, p_channelmask_: ?*u32) HRESULT {
                return @as(*const IXAudio2MasteringVoice.VTable, @ptrCast(self.vtable)).GetChannelMask(@as(*const IXAudio2MasteringVoice, @ptrCast(self)), p_channelmask_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2EngineCallback = extern struct {
    pub const VTable = extern struct {
        OnProcessingPassStart: *const fn (
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnProcessingPassEnd: *const fn (
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnCriticalError: *const fn (
            self: *const IXAudio2EngineCallback,
            @"error": HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn onProcessingPassStart(self: *const T) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnProcessingPassStart(@as(*const IXAudio2EngineCallback, @ptrCast(self)));
            }
            pub inline fn onProcessingPassEnd(self: *const T) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnProcessingPassEnd(@as(*const IXAudio2EngineCallback, @ptrCast(self)));
            }
            pub inline fn onCriticalError(self: *const T, error_: HRESULT) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnCriticalError(@as(*const IXAudio2EngineCallback, @ptrCast(self)), error_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2VoiceCallback = extern struct {
    pub const VTable = extern struct {
        OnVoiceProcessingPassStart: *const fn (
            self: *const IXAudio2VoiceCallback,
            bytes_required: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceProcessingPassEnd: *const fn (
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnStreamEnd: *const fn (
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferStart: *const fn (
            self: *const IXAudio2VoiceCallback,
            p_buffer_context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferEnd: *const fn (
            self: *const IXAudio2VoiceCallback,
            p_buffer_context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnLoopEnd: *const fn (
            self: *const IXAudio2VoiceCallback,
            p_buffer_context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceError: *const fn (
            self: *const IXAudio2VoiceCallback,
            p_buffer_context: ?*anyopaque,
            @"error": HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub inline fn onVoiceProcessingPassStart(self: *const T, bytes_required_: u32) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceProcessingPassStart(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), bytes_required_);
            }
            pub inline fn onVoiceProcessingPassEnd(self: *const T) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceProcessingPassEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)));
            }
            pub inline fn onStreamEnd(self: *const T) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnStreamEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)));
            }
            pub inline fn onBufferStart(self: *const T, p_buffer_context_: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnBufferStart(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), p_buffer_context_);
            }
            pub inline fn onBufferEnd(self: *const T, p_buffer_context_: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnBufferEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), p_buffer_context_);
            }
            pub inline fn onLoopEnd(self: *const T, p_buffer_context_: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnLoopEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), p_buffer_context_);
            }
            pub inline fn onVoiceError(self: *const T, p_buffer_context_: ?*anyopaque, error_: HRESULT) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceError(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), p_buffer_context_, error_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_AudioVolumeMeter_Value = Guid.initString("4fc3b166-972a-40cf-bc37-7db03db2fba3");
pub const CLSID_AudioVolumeMeter = &CLSID_AudioVolumeMeter_Value;

const CLSID_AudioReverb_Value = Guid.initString("c2633b16-471b-4498-b8c5-4f0959e2ec09");
pub const CLSID_AudioReverb = &CLSID_AudioReverb_Value;

pub const XAUDIO2FX_VOLUMEMETER_LEVELS = extern struct {
    pPeakLevels: ?*f32 align(1),
    pRMSLevels: ?*f32 align(1),
    ChannelCount: u32 align(1),
};

pub const XAUDIO2FX_REVERB_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    ReflectionsDelay: u32 align(1),
    ReverbDelay: u8 align(1),
    RearDelay: u8 align(1),
    SideDelay: u8 align(1),
    PositionLeft: u8 align(1),
    PositionRight: u8 align(1),
    PositionMatrixLeft: u8 align(1),
    PositionMatrixRight: u8 align(1),
    EarlyDiffusion: u8 align(1),
    LateDiffusion: u8 align(1),
    LowEQGain: u8 align(1),
    LowEQCutoff: u8 align(1),
    HighEQGain: u8 align(1),
    HighEQCutoff: u8 align(1),
    RoomFilterFreq: f32 align(1),
    RoomFilterMain: f32 align(1),
    RoomFilterHF: f32 align(1),
    ReflectionsGain: f32 align(1),
    ReverbGain: f32 align(1),
    DecayTime: f32 align(1),
    Density: f32 align(1),
    RoomSize: f32 align(1),
    DisableLateField: BOOL align(1),
};

pub const XAUDIO2FX_REVERB_I3DL2_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Room: i32 align(1),
    RoomHF: i32 align(1),
    RoomRolloffFactor: f32 align(1),
    DecayTime: f32 align(1),
    DecayHFRatio: f32 align(1),
    Reflections: i32 align(1),
    ReflectionsDelay: f32 align(1),
    Reverb: i32 align(1),
    ReverbDelay: f32 align(1),
    Diffusion: f32 align(1),
    Density: f32 align(1),
    HFReference: f32 align(1),
};

pub const HrtfPosition = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const HrtfOrientation = extern struct {
    element: [9]f32,
};

pub const HrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const OmniDirectional = HrtfDirectivityType.OmniDirectional;
pub const Cardioid = HrtfDirectivityType.Cardioid;
pub const Cone = HrtfDirectivityType.Cone;

pub const HrtfEnvironment = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
};
pub const Small = HrtfEnvironment.Small;
pub const Medium = HrtfEnvironment.Medium;
pub const Large = HrtfEnvironment.Large;
pub const Outdoors = HrtfEnvironment.Outdoors;

pub const HrtfDirectivity = extern struct {
    type: HrtfDirectivityType,
    scaling: f32,
};

pub const HrtfDirectivityCardioid = extern struct {
    directivity: HrtfDirectivity,
    order: f32,
};

pub const HrtfDirectivityCone = extern struct {
    directivity: HrtfDirectivity,
    innerAngle: f32,
    outerAngle: f32,
};

pub const HrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const NaturalDecay = HrtfDistanceDecayType.NaturalDecay;
pub const CustomDecay = HrtfDistanceDecayType.CustomDecay;

pub const HrtfDistanceDecay = extern struct {
    type: HrtfDistanceDecayType,
    maxGain: f32,
    minGain: f32,
    unityGainDistance: f32,
    cutoffDistance: f32,
};

pub const HrtfApoInit = extern struct {
    distanceDecay: ?*HrtfDistanceDecay,
    directivity: ?*HrtfDirectivity,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IXAPOHrtfParameters_Value = Guid.initString("15b3cd66-e9de-4464-b6e6-2bc3cf63d455");
pub const IID_IXAPOHrtfParameters = &IID_IXAPOHrtfParameters_Value;
pub const IXAPOHrtfParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSourcePosition: *const fn (
            self: *const IXAPOHrtfParameters,
            position: ?*const HrtfPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceOrientation: *const fn (
            self: *const IXAPOHrtfParameters,
            orientation: ?*const HrtfOrientation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceGain: *const fn (
            self: *const IXAPOHrtfParameters,
            gain: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironment: *const fn (
            self: *const IXAPOHrtfParameters,
            environment: HrtfEnvironment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setSourcePosition(self: *const T, position_: ?*const HrtfPosition) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourcePosition(@as(*const IXAPOHrtfParameters, @ptrCast(self)), position_);
            }
            pub inline fn setSourceOrientation(self: *const T, orientation_: ?*const HrtfOrientation) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourceOrientation(@as(*const IXAPOHrtfParameters, @ptrCast(self)), orientation_);
            }
            pub inline fn setSourceGain(self: *const T, gain_: f32) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourceGain(@as(*const IXAPOHrtfParameters, @ptrCast(self)), gain_);
            }
            pub inline fn setEnvironment(self: *const T, environment_: HrtfEnvironment) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetEnvironment(@as(*const IXAPOHrtfParameters, @ptrCast(self)), environment_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "xaudio2_8" fn CreateFX(
    clsid: ?*const Guid,
    p_effect: ?*?*IUnknown,
    // TODO: what to do with BytesParamIndex 3?
    p_init_dat: ?*const anyopaque,
    init_data_byte_size: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn XAudio2CreateWithVersionInfo(
    pp_x_audio2: ?*?*IXAudio2,
    flags: u32,
    x_audio2_processor: u32,
    ntddi_version: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioVolumeMeter(
    pp_apo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioReverb(
    pp_apo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hrtfapo" fn CreateHrtfApo(
    init: ?*const HrtfApoInit,
    x_apo: ?*?*IXAPO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const AUDIO_STREAM_CATEGORY = @import("../../media/audio.zig").AUDIO_STREAM_CATEGORY;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
