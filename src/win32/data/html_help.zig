//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (274)
//--------------------------------------------------------------------------------
pub const HH_DISPLAY_TOPIC = @as(u32, 0);
pub const HH_HELP_FINDER = @as(u32, 0);
pub const HH_DISPLAY_TOC = @as(u32, 1);
pub const HH_DISPLAY_INDEX = @as(u32, 2);
pub const HH_DISPLAY_SEARCH = @as(u32, 3);
pub const HH_SET_WIN_TYPE = @as(u32, 4);
pub const HH_GET_WIN_TYPE = @as(u32, 5);
pub const HH_GET_WIN_HANDLE = @as(u32, 6);
pub const HH_ENUM_INFO_TYPE = @as(u32, 7);
pub const HH_SET_INFO_TYPE = @as(u32, 8);
pub const HH_SYNC = @as(u32, 9);
pub const HH_RESERVED1 = @as(u32, 10);
pub const HH_RESERVED2 = @as(u32, 11);
pub const HH_RESERVED3 = @as(u32, 12);
pub const HH_KEYWORD_LOOKUP = @as(u32, 13);
pub const HH_DISPLAY_TEXT_POPUP = @as(u32, 14);
pub const HH_HELP_CONTEXT = @as(u32, 15);
pub const HH_TP_HELP_CONTEXTMENU = @as(u32, 16);
pub const HH_TP_HELP_WM_HELP = @as(u32, 17);
pub const HH_CLOSE_ALL = @as(u32, 18);
pub const HH_ALINK_LOOKUP = @as(u32, 19);
pub const HH_GET_LAST_ERROR = @as(u32, 20);
pub const HH_ENUM_CATEGORY = @as(u32, 21);
pub const HH_ENUM_CATEGORY_IT = @as(u32, 22);
pub const HH_RESET_IT_FILTER = @as(u32, 23);
pub const HH_SET_INCLUSIVE_FILTER = @as(u32, 24);
pub const HH_SET_EXCLUSIVE_FILTER = @as(u32, 25);
pub const HH_INITIALIZE = @as(u32, 28);
pub const HH_UNINITIALIZE = @as(u32, 29);
pub const HH_SET_QUERYSERVICE = @as(u32, 30);
pub const HH_PRETRANSLATEMESSAGE = @as(u32, 253);
pub const HH_SET_GLOBAL_PROPERTY = @as(u32, 252);
pub const HH_SAFE_DISPLAY_TOPIC = @as(u32, 32);
pub const HHWIN_PROP_TAB_AUTOHIDESHOW = @as(u32, 1);
pub const HHWIN_PROP_ONTOP = @as(u32, 2);
pub const HHWIN_PROP_NOTITLEBAR = @as(u32, 4);
pub const HHWIN_PROP_NODEF_STYLES = @as(u32, 8);
pub const HHWIN_PROP_NODEF_EXSTYLES = @as(u32, 16);
pub const HHWIN_PROP_TRI_PANE = @as(u32, 32);
pub const HHWIN_PROP_NOTB_TEXT = @as(u32, 64);
pub const HHWIN_PROP_POST_QUIT = @as(u32, 128);
pub const HHWIN_PROP_AUTO_SYNC = @as(u32, 256);
pub const HHWIN_PROP_TRACKING = @as(u32, 512);
pub const HHWIN_PROP_TAB_SEARCH = @as(u32, 1024);
pub const HHWIN_PROP_TAB_HISTORY = @as(u32, 2048);
pub const HHWIN_PROP_TAB_FAVORITES = @as(u32, 4096);
pub const HHWIN_PROP_CHANGE_TITLE = @as(u32, 8192);
pub const HHWIN_PROP_NAV_ONLY_WIN = @as(u32, 16384);
pub const HHWIN_PROP_NO_TOOLBAR = @as(u32, 32768);
pub const HHWIN_PROP_MENU = @as(u32, 65536);
pub const HHWIN_PROP_TAB_ADVSEARCH = @as(u32, 131072);
pub const HHWIN_PROP_USER_POS = @as(u32, 262144);
pub const HHWIN_PROP_TAB_CUSTOM1 = @as(u32, 524288);
pub const HHWIN_PROP_TAB_CUSTOM2 = @as(u32, 1048576);
pub const HHWIN_PROP_TAB_CUSTOM3 = @as(u32, 2097152);
pub const HHWIN_PROP_TAB_CUSTOM4 = @as(u32, 4194304);
pub const HHWIN_PROP_TAB_CUSTOM5 = @as(u32, 8388608);
pub const HHWIN_PROP_TAB_CUSTOM6 = @as(u32, 16777216);
pub const HHWIN_PROP_TAB_CUSTOM7 = @as(u32, 33554432);
pub const HHWIN_PROP_TAB_CUSTOM8 = @as(u32, 67108864);
pub const HHWIN_PROP_TAB_CUSTOM9 = @as(u32, 134217728);
pub const HHWIN_TB_MARGIN = @as(u32, 268435456);
pub const HHWIN_PARAM_PROPERTIES = @as(u32, 2);
pub const HHWIN_PARAM_STYLES = @as(u32, 4);
pub const HHWIN_PARAM_EXSTYLES = @as(u32, 8);
pub const HHWIN_PARAM_RECT = @as(u32, 16);
pub const HHWIN_PARAM_NAV_WIDTH = @as(u32, 32);
pub const HHWIN_PARAM_SHOWSTATE = @as(u32, 64);
pub const HHWIN_PARAM_INFOTYPES = @as(u32, 128);
pub const HHWIN_PARAM_TB_FLAGS = @as(u32, 256);
pub const HHWIN_PARAM_EXPANSION = @as(u32, 512);
pub const HHWIN_PARAM_TABPOS = @as(u32, 1024);
pub const HHWIN_PARAM_TABORDER = @as(u32, 2048);
pub const HHWIN_PARAM_HISTORY_COUNT = @as(u32, 4096);
pub const HHWIN_PARAM_CUR_TAB = @as(u32, 8192);
pub const HHWIN_BUTTON_EXPAND = @as(u32, 2);
pub const HHWIN_BUTTON_BACK = @as(u32, 4);
pub const HHWIN_BUTTON_FORWARD = @as(u32, 8);
pub const HHWIN_BUTTON_STOP = @as(u32, 16);
pub const HHWIN_BUTTON_REFRESH = @as(u32, 32);
pub const HHWIN_BUTTON_HOME = @as(u32, 64);
pub const HHWIN_BUTTON_BROWSE_FWD = @as(u32, 128);
pub const HHWIN_BUTTON_BROWSE_BCK = @as(u32, 256);
pub const HHWIN_BUTTON_NOTES = @as(u32, 512);
pub const HHWIN_BUTTON_CONTENTS = @as(u32, 1024);
pub const HHWIN_BUTTON_SYNC = @as(u32, 2048);
pub const HHWIN_BUTTON_OPTIONS = @as(u32, 4096);
pub const HHWIN_BUTTON_PRINT = @as(u32, 8192);
pub const HHWIN_BUTTON_INDEX = @as(u32, 16384);
pub const HHWIN_BUTTON_SEARCH = @as(u32, 32768);
pub const HHWIN_BUTTON_HISTORY = @as(u32, 65536);
pub const HHWIN_BUTTON_FAVORITES = @as(u32, 131072);
pub const HHWIN_BUTTON_JUMP1 = @as(u32, 262144);
pub const HHWIN_BUTTON_JUMP2 = @as(u32, 524288);
pub const HHWIN_BUTTON_ZOOM = @as(u32, 1048576);
pub const HHWIN_BUTTON_TOC_NEXT = @as(u32, 2097152);
pub const HHWIN_BUTTON_TOC_PREV = @as(u32, 4194304);
pub const IDTB_EXPAND = @as(u32, 200);
pub const IDTB_CONTRACT = @as(u32, 201);
pub const IDTB_STOP = @as(u32, 202);
pub const IDTB_REFRESH = @as(u32, 203);
pub const IDTB_BACK = @as(u32, 204);
pub const IDTB_HOME = @as(u32, 205);
pub const IDTB_SYNC = @as(u32, 206);
pub const IDTB_PRINT = @as(u32, 207);
pub const IDTB_OPTIONS = @as(u32, 208);
pub const IDTB_FORWARD = @as(u32, 209);
pub const IDTB_NOTES = @as(u32, 210);
pub const IDTB_BROWSE_FWD = @as(u32, 211);
pub const IDTB_BROWSE_BACK = @as(u32, 212);
pub const IDTB_CONTENTS = @as(u32, 213);
pub const IDTB_INDEX = @as(u32, 214);
pub const IDTB_SEARCH = @as(u32, 215);
pub const IDTB_HISTORY = @as(u32, 216);
pub const IDTB_FAVORITES = @as(u32, 217);
pub const IDTB_JUMP1 = @as(u32, 218);
pub const IDTB_JUMP2 = @as(u32, 219);
pub const IDTB_CUSTOMIZE = @as(u32, 221);
pub const IDTB_ZOOM = @as(u32, 222);
pub const IDTB_TOC_NEXT = @as(u32, 223);
pub const IDTB_TOC_PREV = @as(u32, 224);
pub const HH_MAX_TABS = @as(u32, 19);
pub const HH_FTS_DEFAULT_PROXIMITY = @as(i32, -1);
pub const CLSID_IITPropList = Guid.initString("4662daae-d393-11d0-9a56-00c04fb68bf7");
pub const PROP_ADD = @as(u32, 0);
pub const PROP_DELETE = @as(u32, 1);
pub const PROP_UPDATE = @as(u32, 2);
pub const TYPE_VALUE = @as(u32, 0);
pub const TYPE_POINTER = @as(u32, 1);
pub const TYPE_STRING = @as(u32, 2);
pub const CLSID_IITDatabase = Guid.initString("66673452-8c23-11d0-a84e-00aa006c7d01");
pub const CLSID_IITDatabaseLocal = Guid.initString("4662daa9-d393-11d0-9a56-00c04fb68bf7");
pub const STDPROP_UID = @as(u32, 1);
pub const STDPROP_TITLE = @as(u32, 2);
pub const STDPROP_USERDATA = @as(u32, 3);
pub const STDPROP_KEY = @as(u32, 4);
pub const STDPROP_SORTKEY = @as(u32, 100);
pub const STDPROP_DISPLAYKEY = @as(u32, 101);
pub const STDPROP_SORTORDINAL = @as(u32, 102);
pub const STDPROP_INDEX_TEXT = @as(u32, 200);
pub const STDPROP_INDEX_VFLD = @as(u32, 201);
pub const STDPROP_INDEX_DTYPE = @as(u32, 202);
pub const STDPROP_INDEX_LENGTH = @as(u32, 203);
pub const STDPROP_INDEX_BREAK = @as(u32, 204);
pub const STDPROP_INDEX_TERM = @as(u32, 210);
pub const STDPROP_INDEX_TERM_RAW_LENGTH = @as(u32, 211);
pub const STDPROP_USERPROP_BASE = @as(u32, 65536);
pub const STDPROP_USERPROP_MAX = @as(u32, 2147483647);
pub const SZ_WWDEST_GLOBAL = "GLOBAL";
pub const SZ_WWDEST_KEY = "KEY";
pub const SZ_WWDEST_OCC = "OCC";
pub const CLSID_IITCmdInt = Guid.initString("4662daa2-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITSvMgr = Guid.initString("4662daa3-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITWordWheelUpdate = Guid.initString("4662daa5-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITGroupUpdate = Guid.initString("4662daa4-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITIndexBuild = Guid.initString("8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7");
pub const CLSID_IITWWFilterBuild = Guid.initString("8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7");
pub const CLSID_IITWordWheel = Guid.initString("d73725c2-8c12-11d0-a84e-00aa006c7d01");
pub const CLSID_IITWordWheelLocal = Guid.initString("4662daa8-d393-11d0-9a56-00c04fb68bf7");
pub const ITWW_OPEN_NOCONNECT = @as(u32, 1);
pub const ITWW_CBKEY_MAX = @as(u32, 1024);
pub const IITWBC_BREAK_ACCEPT_WILDCARDS = @as(u32, 1);
pub const IITWBC_BREAK_AND_STEM = @as(u32, 2);
pub const E_NOTEXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479552));
pub const E_DUPLICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479551));
pub const E_BADVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479550));
pub const E_BADFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479549));
pub const E_BADFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479548));
pub const E_NOPERMISSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479547));
pub const E_ASSERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479546));
pub const E_INTERRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479545));
pub const E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479544));
pub const E_OUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479543));
pub const E_GROUPIDTOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479542));
pub const E_TOOMANYTITLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479541));
pub const E_NOMERGEDDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479540));
pub const E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479539));
pub const E_CANTFINDDLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479538));
pub const E_NOHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479537));
pub const E_GETLASTERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479536));
pub const E_BADPARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479535));
pub const E_INVALIDSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479534));
pub const E_NOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479533));
pub const E_ALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479533));
pub const E_UNKNOWN_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479530));
pub const E_UNSUPPORTED_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479529));
pub const E_BADFILTERSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479528));
pub const E_TOOMANYOBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479527));
pub const E_NAMETOOLONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479520));
pub const E_FILECREATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479504));
pub const E_FILECLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479503));
pub const E_FILEREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479502));
pub const E_FILESEEK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479501));
pub const E_FILEWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479500));
pub const E_FILEDELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479499));
pub const E_FILEINVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479498));
pub const E_FILENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479497));
pub const E_DISKFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479496));
pub const E_TOOMANYTOPICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479472));
pub const E_TOOMANYDUPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479471));
pub const E_TREETOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479470));
pub const E_BADBREAKER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479469));
pub const E_BADVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479468));
pub const E_ALL_WILD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479467));
pub const E_TOODEEP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479466));
pub const E_EXPECTEDTERM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479465));
pub const E_MISSLPAREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479464));
pub const E_MISSRPAREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479463));
pub const E_MISSQUOTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479462));
pub const E_NULLQUERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479461));
pub const E_STOPWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479460));
pub const E_BADRANGEOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479459));
pub const E_UNMATCHEDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479458));
pub const E_WORDTOOLONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479457));
pub const E_BADINDEXFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479456));
pub const E_WILD_IN_DTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479455));
pub const E_NOSTEMMER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479454));
pub const E_MISSINGPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479424));
pub const E_PROPLISTNOTEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479423));
pub const E_PROPLISTEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479422));
pub const E_ALREADYINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479421));
pub const E_NOTINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479420));
pub const E_RESULTSETEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479419));
pub const E_TOOMANYCOLUMNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479418));
pub const E_NOKEYPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479417));
pub const CLSID_IITResultSet = Guid.initString("4662daa7-d393-11d0-9a56-00c04fb68bf7");
pub const MAX_COLUMNS = @as(u32, 256);
pub const CLSID_ITStdBreaker = Guid.initString("4662daaf-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_ITEngStemmer = Guid.initString("8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7");
pub const HHWIN_NAVTYPE_TOC = @as(i32, 0);
pub const HHWIN_NAVTYPE_INDEX = @as(i32, 1);
pub const HHWIN_NAVTYPE_SEARCH = @as(i32, 2);
pub const HHWIN_NAVTYPE_FAVORITES = @as(i32, 3);
pub const HHWIN_NAVTYPE_HISTORY = @as(i32, 4);
pub const HHWIN_NAVTYPE_AUTHOR = @as(i32, 5);
pub const HHWIN_NAVTYPE_CUSTOM_FIRST = @as(i32, 11);
pub const IT_INCLUSIVE = @as(i32, 0);
pub const IT_EXCLUSIVE = @as(i32, 1);
pub const IT_HIDDEN = @as(i32, 2);
pub const HHWIN_NAVTAB_TOP = @as(i32, 0);
pub const HHWIN_NAVTAB_LEFT = @as(i32, 1);
pub const HHWIN_NAVTAB_BOTTOM = @as(i32, 2);
pub const HH_TAB_CONTENTS = @as(i32, 0);
pub const HH_TAB_INDEX = @as(i32, 1);
pub const HH_TAB_SEARCH = @as(i32, 2);
pub const HH_TAB_FAVORITES = @as(i32, 3);
pub const HH_TAB_HISTORY = @as(i32, 4);
pub const HH_TAB_AUTHOR = @as(i32, 5);
pub const HH_TAB_CUSTOM_FIRST = @as(i32, 11);
pub const HH_TAB_CUSTOM_LAST = @as(i32, 19);
pub const HHACT_TAB_CONTENTS = @as(i32, 0);
pub const HHACT_TAB_INDEX = @as(i32, 1);
pub const HHACT_TAB_SEARCH = @as(i32, 2);
pub const HHACT_TAB_HISTORY = @as(i32, 3);
pub const HHACT_TAB_FAVORITES = @as(i32, 4);
pub const HHACT_EXPAND = @as(i32, 5);
pub const HHACT_CONTRACT = @as(i32, 6);
pub const HHACT_BACK = @as(i32, 7);
pub const HHACT_FORWARD = @as(i32, 8);
pub const HHACT_STOP = @as(i32, 9);
pub const HHACT_REFRESH = @as(i32, 10);
pub const HHACT_HOME = @as(i32, 11);
pub const HHACT_SYNC = @as(i32, 12);
pub const HHACT_OPTIONS = @as(i32, 13);
pub const HHACT_PRINT = @as(i32, 14);
pub const HHACT_HIGHLIGHT = @as(i32, 15);
pub const HHACT_CUSTOMIZE = @as(i32, 16);
pub const HHACT_JUMP1 = @as(i32, 17);
pub const HHACT_JUMP2 = @as(i32, 18);
pub const HHACT_ZOOM = @as(i32, 19);
pub const HHACT_TOC_NEXT = @as(i32, 20);
pub const HHACT_TOC_PREV = @as(i32, 21);
pub const HHACT_NOTES = @as(i32, 22);
pub const HHACT_LAST_ENUM = @as(i32, 23);

//--------------------------------------------------------------------------------
// Section: Types (27)
//--------------------------------------------------------------------------------
pub const WORD_WHEEL_OPEN_FLAGS = enum(u32) {
    T = 0,
    _,
    pub fn initFlags(o: struct {
        T: u1 = 0,
    }) WORD_WHEEL_OPEN_FLAGS {
        return @as(WORD_WHEEL_OPEN_FLAGS, @enumFromInt((if (o.T == 1) @intFromEnum(WORD_WHEEL_OPEN_FLAGS.T) else 0)));
    }
};
pub const ITWW_OPEN_CONNECT = WORD_WHEEL_OPEN_FLAGS.T;

pub const HHN_NOTIFY = extern struct {
    hdr: NMHDR,
    pszUrl: ?[*:0]const u8,
};

pub const HH_POPUP = extern struct {
    cbStruct: i32,
    hinst: ?HINSTANCE,
    idString: u32,
    pszText: ?*i8,
    pt: POINT,
    clrForeground: u32,
    clrBackground: u32,
    rcMargins: RECT,
    pszFont: ?*i8,
};

pub const HH_AKLINK = extern struct {
    cbStruct: i32,
    fReserved: BOOL,
    pszKeywords: ?*i8,
    pszUrl: ?*i8,
    pszMsgText: ?*i8,
    pszMsgTitle: ?*i8,
    pszWindow: ?*i8,
    fIndexOnFail: BOOL,
};

pub const HH_ENUM_IT = extern struct {
    cbStruct: i32,
    iType: i32,
    pszCatName: ?[*:0]const u8,
    pszITName: ?[*:0]const u8,
    pszITDescription: ?[*:0]const u8,
};

pub const HH_ENUM_CAT = extern struct {
    cbStruct: i32,
    pszCatName: ?[*:0]const u8,
    pszCatDescription: ?[*:0]const u8,
};

pub const HH_SET_INFOTYPE = extern struct {
    cbStruct: i32,
    pszCatName: ?[*:0]const u8,
    pszInfoTypeName: ?[*:0]const u8,
};

pub const HH_FTS_QUERY = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszSearchQuery: ?*i8,
    iProximity: i32,
    fStemmedSearch: BOOL,
    fTitleOnly: BOOL,
    fExecute: BOOL,
    pszWindow: ?*i8,
};

pub const HH_WINTYPE = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszType: ?*i8,
    fsValidMembers: u32,
    fsWinProperties: u32,
    pszCaption: ?*i8,
    dwStyles: u32,
    dwExStyles: u32,
    rcWindowPos: RECT,
    nShowState: i32,
    hwndHelp: ?HWND,
    hwndCaller: ?HWND,
    paInfoTypes: ?*u32,
    hwndToolBar: ?HWND,
    hwndNavigation: ?HWND,
    hwndHTML: ?HWND,
    iNavWidth: i32,
    rcHTML: RECT,
    pszToc: ?*i8,
    pszIndex: ?*i8,
    pszFile: ?*i8,
    pszHome: ?*i8,
    fsToolBarFlags: u32,
    fNotExpanded: BOOL,
    curNavType: i32,
    tabpos: i32,
    idNotify: i32,
    tabOrder: [20]u8,
    cHistory: i32,
    pszJump1: ?*i8,
    pszJump2: ?*i8,
    pszUrlJump1: ?*i8,
    pszUrlJump2: ?*i8,
    rcMinSize: RECT,
    cbInfoTypes: i32,
    pszCustomTabs: ?*i8,
};

pub const HHNTRACK = extern struct {
    hdr: NMHDR,
    pszCurUrl: ?[*:0]const u8,
    idAction: i32,
    phhWinType: ?*HH_WINTYPE,
};

pub const HH_GPROPID = enum(i32) {
    SINGLETHREAD = 1,
    TOOLBAR_MARGIN = 2,
    UI_LANGUAGE = 3,
    CURRENT_SUBSET = 4,
    CONTENT_LANGUAGE = 5,
};
pub const HH_GPROPID_SINGLETHREAD = HH_GPROPID.SINGLETHREAD;
pub const HH_GPROPID_TOOLBAR_MARGIN = HH_GPROPID.TOOLBAR_MARGIN;
pub const HH_GPROPID_UI_LANGUAGE = HH_GPROPID.UI_LANGUAGE;
pub const HH_GPROPID_CURRENT_SUBSET = HH_GPROPID.CURRENT_SUBSET;
pub const HH_GPROPID_CONTENT_LANGUAGE = HH_GPROPID.CONTENT_LANGUAGE;

pub const HH_GLOBAL_PROPERTY = extern struct {
    id: HH_GPROPID,
    @"var": VARIANT,
};

pub const CProperty = extern struct {
    dwPropID: u32,
    cbData: u32,
    dwType: u32,
    Anonymous: extern union {
        lpszwData: ?PWSTR,
        lpvData: ?*anyopaque,
        dwValue: u32,
    },
    fPersist: BOOL,
};

const IID_IITPropList_Value = Guid.initString("1f403bb1-9997-11d0-a850-00aa006c7d01");
pub const IID_IITPropList = &IID_IITPropList_Value;
pub const IITPropList = extern struct {
    pub const VTable = extern struct {
        base: IPersistStreamInit.VTable,
        Set: *const fn (
            self: *const IITPropList,
            prop_i_d: u32,
            lpszw_string: ?[*:0]const u16,
            dw_operation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set1: *const fn (
            self: *const IITPropList,
            prop_i_d: u32,
            lpv_data: ?*anyopaque,
            cb_data: u32,
            dw_operation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set2: *const fn (
            self: *const IITPropList,
            prop_i_d: u32,
            dw_data: u32,
            dw_operation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IITPropList,
            prop: ?*CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: *const fn (
            self: *const IITPropList,
            prop_i_d: u32,
            property: ?*CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: *const fn (
            self: *const IITPropList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPersist: *const fn (
            self: *const IITPropList,
            f_persist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPersist1: *const fn (
            self: *const IITPropList,
            prop_i_d: u32,
            f_persist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirst: *const fn (
            self: *const IITPropList,
            property: ?*CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: *const fn (
            self: *const IITPropList,
            property: ?*CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropCount: *const fn (
            self: *const IITPropList,
            c_prop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveHeader: *const fn (
            self: *const IITPropList,
            lpv_data: ?*anyopaque,
            dw_hdr_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveData: *const fn (
            self: *const IITPropList,
            lpv_header: ?*anyopaque,
            dw_hdr_size: u32,
            lpv_data: ?*anyopaque,
            dw_buf_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeaderSize: *const fn (
            self: *const IITPropList,
            dw_hdr_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataSize: *const fn (
            self: *const IITPropList,
            lpv_header: ?*anyopaque,
            dw_hdr_size: u32,
            dw_data_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveDataToStream: *const fn (
            self: *const IITPropList,
            lpv_header: ?*anyopaque,
            dw_hdr_size: u32,
            p_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadFromMem: *const fn (
            self: *const IITPropList,
            lpv_data: ?*anyopaque,
            dw_buf_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveToMem: *const fn (
            self: *const IITPropList,
            lpv_data: ?*anyopaque,
            dw_buf_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistStreamInit.MethodMixin(T);
            pub inline fn set(self: *const T, prop_i_d_: u32, lpszw_string_: ?[*:0]const u16, dw_operation_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), prop_i_d_, lpszw_string_, dw_operation_);
            }
            pub inline fn set1(self: *const T, prop_i_d_: u32, lpv_data_: ?*anyopaque, cb_data_: u32, dw_operation_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), prop_i_d_, lpv_data_, cb_data_, dw_operation_);
            }
            pub inline fn set2(self: *const T, prop_i_d_: u32, dw_data_: u32, dw_operation_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), prop_i_d_, dw_data_, dw_operation_);
            }
            pub inline fn add(self: *const T, prop_: ?*CProperty) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Add(@as(*const IITPropList, @ptrCast(self)), prop_);
            }
            pub inline fn get(self: *const T, prop_i_d_: u32, property_: ?*CProperty) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Get(@as(*const IITPropList, @ptrCast(self)), prop_i_d_, property_);
            }
            pub inline fn clear(self: *const T) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Clear(@as(*const IITPropList, @ptrCast(self)));
            }
            pub inline fn setPersist(self: *const T, f_persist_: BOOL) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SetPersist(@as(*const IITPropList, @ptrCast(self)), f_persist_);
            }
            pub inline fn setPersist1(self: *const T, prop_i_d_: u32, f_persist_: BOOL) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SetPersist(@as(*const IITPropList, @ptrCast(self)), prop_i_d_, f_persist_);
            }
            pub inline fn getFirst(self: *const T, property_: ?*CProperty) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetFirst(@as(*const IITPropList, @ptrCast(self)), property_);
            }
            pub inline fn getNext(self: *const T, property_: ?*CProperty) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IITPropList, @ptrCast(self)), property_);
            }
            pub inline fn getPropCount(self: *const T, c_prop_: ?*i32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetPropCount(@as(*const IITPropList, @ptrCast(self)), c_prop_);
            }
            pub inline fn saveHeader(self: *const T, lpv_data_: ?*anyopaque, dw_hdr_size_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveHeader(@as(*const IITPropList, @ptrCast(self)), lpv_data_, dw_hdr_size_);
            }
            pub inline fn saveData(self: *const T, lpv_header_: ?*anyopaque, dw_hdr_size_: u32, lpv_data_: ?*anyopaque, dw_buf_size_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveData(@as(*const IITPropList, @ptrCast(self)), lpv_header_, dw_hdr_size_, lpv_data_, dw_buf_size_);
            }
            pub inline fn getHeaderSize(self: *const T, dw_hdr_size_: ?*u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetHeaderSize(@as(*const IITPropList, @ptrCast(self)), dw_hdr_size_);
            }
            pub inline fn getDataSize(self: *const T, lpv_header_: ?*anyopaque, dw_hdr_size_: u32, dw_data_size_: ?*u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetDataSize(@as(*const IITPropList, @ptrCast(self)), lpv_header_, dw_hdr_size_, dw_data_size_);
            }
            pub inline fn saveDataToStream(self: *const T, lpv_header_: ?*anyopaque, dw_hdr_size_: u32, p_stream_: ?*IStream) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveDataToStream(@as(*const IITPropList, @ptrCast(self)), lpv_header_, dw_hdr_size_, p_stream_);
            }
            pub inline fn loadFromMem(self: *const T, lpv_data_: ?*anyopaque, dw_buf_size_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).LoadFromMem(@as(*const IITPropList, @ptrCast(self)), lpv_data_, dw_buf_size_);
            }
            pub inline fn saveToMem(self: *const T, lpv_data_: ?*anyopaque, dw_buf_size_: u32) HRESULT {
                return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveToMem(@as(*const IITPropList, @ptrCast(self)), lpv_data_, dw_buf_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IITDatabase_Value = Guid.initString("8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IITDatabase = &IID_IITDatabase_Value;
pub const IITDatabase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const IITDatabase,
            lpsz_host: ?[*:0]const u16,
            lpsz_moniker: ?[*:0]const u16,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IITDatabase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateObject: *const fn (
            self: *const IITDatabase,
            rclsid: ?*const Guid,
            pdw_obj_instance: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: *const fn (
            self: *const IITDatabase,
            dw_obj_instance: u32,
            riid: ?*const Guid,
            ppv_obj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectPersistence: *const fn (
            self: *const IITDatabase,
            lpwsz_object: ?[*:0]const u16,
            dw_obj_instance: u32,
            ppv_persistence: ?*?*anyopaque,
            f_stream: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, lpsz_host_: ?[*:0]const u16, lpsz_moniker_: ?[*:0]const u16, dw_flags_: u32) HRESULT {
                return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).Open(@as(*const IITDatabase, @ptrCast(self)), lpsz_host_, lpsz_moniker_, dw_flags_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).Close(@as(*const IITDatabase, @ptrCast(self)));
            }
            pub inline fn createObject(self: *const T, rclsid_: ?*const Guid, pdw_obj_instance_: ?*u32) HRESULT {
                return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).CreateObject(@as(*const IITDatabase, @ptrCast(self)), rclsid_, pdw_obj_instance_);
            }
            pub inline fn getObject(self: *const T, dw_obj_instance_: u32, riid_: ?*const Guid, ppv_obj_: ?*?*anyopaque) HRESULT {
                return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IITDatabase, @ptrCast(self)), dw_obj_instance_, riid_, ppv_obj_);
            }
            pub inline fn getObjectPersistence(self: *const T, lpwsz_object_: ?[*:0]const u16, dw_obj_instance_: u32, ppv_persistence_: ?*?*anyopaque, f_stream_: BOOL) HRESULT {
                return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).GetObjectPersistence(@as(*const IITDatabase, @ptrCast(self)), lpwsz_object_, dw_obj_instance_, ppv_persistence_, f_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IITGroup = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IITQuery = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IITWordWheel_Value = Guid.initString("8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IITWordWheel = &IID_IITWordWheel_Value;
pub const IITWordWheel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const IITWordWheel,
            lp_i_t_d_b: ?*IITDatabase,
            lpsz_moniker: ?[*:0]const u16,
            dw_flags: WORD_WHEEL_OPEN_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IITWordWheel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfo: *const fn (
            self: *const IITWordWheel,
            pdw_code_page_i_d: ?*u32,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSorterInstance: *const fn (
            self: *const IITWordWheel,
            pdw_obj_instance: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Count: *const fn (
            self: *const IITWordWheel,
            pc_entries: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup: *const fn (
            self: *const IITWordWheel,
            lpcv_prefix: ?*const anyopaque,
            f_exact_match: BOOL,
            pl_entry: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup1: *const fn (
            self: *const IITWordWheel,
            l_entry: i32,
            lp_i_t_result: ?*IITResultSet,
            c_entries: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup2: *const fn (
            self: *const IITWordWheel,
            l_entry: i32,
            lpv_key_buf: ?*anyopaque,
            cb_key_buf: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroup: *const fn (
            self: *const IITWordWheel,
            piit_group: ?*IITGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroup: *const fn (
            self: *const IITWordWheel,
            ppiit_group: ?*?*IITGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataCount: *const fn (
            self: *const IITWordWheel,
            l_entry: i32,
            pdw_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: *const fn (
            self: *const IITWordWheel,
            l_entry: i32,
            lp_i_t_result: ?*IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataColumns: *const fn (
            self: *const IITWordWheel,
            p_r_s: ?*IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T, lp_i_t_d_b_: ?*IITDatabase, lpsz_moniker_: ?[*:0]const u16, dw_flags_: WORD_WHEEL_OPEN_FLAGS) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Open(@as(*const IITWordWheel, @ptrCast(self)), lp_i_t_d_b_, lpsz_moniker_, dw_flags_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Close(@as(*const IITWordWheel, @ptrCast(self)));
            }
            pub inline fn getLocaleInfo(self: *const T, pdw_code_page_i_d_: ?*u32, plcid_: ?*u32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IITWordWheel, @ptrCast(self)), pdw_code_page_i_d_, plcid_);
            }
            pub inline fn getSorterInstance(self: *const T, pdw_obj_instance_: ?*u32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetSorterInstance(@as(*const IITWordWheel, @ptrCast(self)), pdw_obj_instance_);
            }
            pub inline fn count(self: *const T, pc_entries_: ?*i32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Count(@as(*const IITWordWheel, @ptrCast(self)), pc_entries_);
            }
            pub inline fn lookup(self: *const T, lpcv_prefix_: ?*const anyopaque, f_exact_match_: BOOL, pl_entry_: ?*i32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), lpcv_prefix_, f_exact_match_, pl_entry_);
            }
            pub inline fn lookup1(self: *const T, l_entry_: i32, lp_i_t_result_: ?*IITResultSet, c_entries_: i32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), l_entry_, lp_i_t_result_, c_entries_);
            }
            pub inline fn lookup2(self: *const T, l_entry_: i32, lpv_key_buf_: ?*anyopaque, cb_key_buf_: u32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), l_entry_, lpv_key_buf_, cb_key_buf_);
            }
            pub inline fn setGroup(self: *const T, piit_group_: ?*IITGroup) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).SetGroup(@as(*const IITWordWheel, @ptrCast(self)), piit_group_);
            }
            pub inline fn getGroup(self: *const T, ppiit_group_: ?*?*IITGroup) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetGroup(@as(*const IITWordWheel, @ptrCast(self)), ppiit_group_);
            }
            pub inline fn getDataCount(self: *const T, l_entry_: i32, pdw_count_: ?*u32) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetDataCount(@as(*const IITWordWheel, @ptrCast(self)), l_entry_, pdw_count_);
            }
            pub inline fn getData(self: *const T, l_entry_: i32, lp_i_t_result_: ?*IITResultSet) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetData(@as(*const IITWordWheel, @ptrCast(self)), l_entry_, lp_i_t_result_);
            }
            pub inline fn getDataColumns(self: *const T, p_r_s_: ?*IITResultSet) HRESULT {
                return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetDataColumns(@as(*const IITWordWheel, @ptrCast(self)), p_r_s_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStemSink_Value = Guid.initString("fe77c330-7f42-11ce-be57-00aa0051fe20");
pub const IID_IStemSink = &IID_IStemSink_Value;
pub const IStemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: *const fn (
            self: *const IStemSink,
            pwc_in_buf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutWord: *const fn (
            self: *const IStemSink,
            pwc_in_buf: ?[*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putAltWord(self: *const T, pwc_in_buf_: ?[*:0]const u16, cwc_: u32) HRESULT {
                return @as(*const IStemSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IStemSink, @ptrCast(self)), pwc_in_buf_, cwc_);
            }
            pub inline fn putWord(self: *const T, pwc_in_buf_: ?[*:0]const u16, cwc_: u32) HRESULT {
                return @as(*const IStemSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IStemSink, @ptrCast(self)), pwc_in_buf_, cwc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStemmerConfig_Value = Guid.initString("8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IStemmerConfig = &IID_IStemmerConfig_Value;
pub const IStemmerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfo: *const fn (
            self: *const IStemmerConfig,
            dw_code_page_i_d: u32,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfo: *const fn (
            self: *const IStemmerConfig,
            pdw_code_page_i_d: ?*u32,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlInfo: *const fn (
            self: *const IStemmerConfig,
            grf_stem_flags: u32,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInfo: *const fn (
            self: *const IStemmerConfig,
            pgrf_stem_flags: ?*u32,
            pdw_reserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadExternalStemmerData: *const fn (
            self: *const IStemmerConfig,
            p_stream: ?*IStream,
            dw_ext_data_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setLocaleInfo(self: *const T, dw_code_page_i_d_: u32, lcid_: u32) HRESULT {
                return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).SetLocaleInfo(@as(*const IStemmerConfig, @ptrCast(self)), dw_code_page_i_d_, lcid_);
            }
            pub inline fn getLocaleInfo(self: *const T, pdw_code_page_i_d_: ?*u32, plcid_: ?*u32) HRESULT {
                return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IStemmerConfig, @ptrCast(self)), pdw_code_page_i_d_, plcid_);
            }
            pub inline fn setControlInfo(self: *const T, grf_stem_flags_: u32, dw_reserved_: u32) HRESULT {
                return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).SetControlInfo(@as(*const IStemmerConfig, @ptrCast(self)), grf_stem_flags_, dw_reserved_);
            }
            pub inline fn getControlInfo(self: *const T, pgrf_stem_flags_: ?*u32, pdw_reserved_: ?*u32) HRESULT {
                return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).GetControlInfo(@as(*const IStemmerConfig, @ptrCast(self)), pgrf_stem_flags_, pdw_reserved_);
            }
            pub inline fn loadExternalStemmerData(self: *const T, p_stream_: ?*IStream, dw_ext_data_type_: u32) HRESULT {
                return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).LoadExternalStemmerData(@as(*const IStemmerConfig, @ptrCast(self)), p_stream_, dw_ext_data_type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IITStopWordList = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IWordBreakerConfig_Value = Guid.initString("8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IWordBreakerConfig = &IID_IWordBreakerConfig_Value;
pub const IWordBreakerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfo: *const fn (
            self: *const IWordBreakerConfig,
            dw_code_page_i_d: u32,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfo: *const fn (
            self: *const IWordBreakerConfig,
            pdw_code_page_i_d: ?*u32,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakWordType: *const fn (
            self: *const IWordBreakerConfig,
            dw_break_word_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakWordType: *const fn (
            self: *const IWordBreakerConfig,
            pdw_break_word_type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlInfo: *const fn (
            self: *const IWordBreakerConfig,
            grf_break_flags: u32,
            dw_reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInfo: *const fn (
            self: *const IWordBreakerConfig,
            pgrf_break_flags: ?*u32,
            pdw_reserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadExternalBreakerData: *const fn (
            self: *const IWordBreakerConfig,
            p_stream: ?*IStream,
            dw_ext_data_type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWordStemmer: *const fn (
            self: *const IWordBreakerConfig,
            rclsid: ?*const Guid,
            p_stemmer: ?*IStemmer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWordStemmer: *const fn (
            self: *const IWordBreakerConfig,
            pp_stemmer: ?*?*IStemmer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setLocaleInfo(self: *const T, dw_code_page_i_d_: u32, lcid_: u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetLocaleInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), dw_code_page_i_d_, lcid_);
            }
            pub inline fn getLocaleInfo(self: *const T, pdw_code_page_i_d_: ?*u32, plcid_: ?*u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), pdw_code_page_i_d_, plcid_);
            }
            pub inline fn setBreakWordType(self: *const T, dw_break_word_type_: u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetBreakWordType(@as(*const IWordBreakerConfig, @ptrCast(self)), dw_break_word_type_);
            }
            pub inline fn getBreakWordType(self: *const T, pdw_break_word_type_: ?*u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetBreakWordType(@as(*const IWordBreakerConfig, @ptrCast(self)), pdw_break_word_type_);
            }
            pub inline fn setControlInfo(self: *const T, grf_break_flags_: u32, dw_reserved_: u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetControlInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), grf_break_flags_, dw_reserved_);
            }
            pub inline fn getControlInfo(self: *const T, pgrf_break_flags_: ?*u32, pdw_reserved_: ?*u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetControlInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), pgrf_break_flags_, pdw_reserved_);
            }
            pub inline fn loadExternalBreakerData(self: *const T, p_stream_: ?*IStream, dw_ext_data_type_: u32) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).LoadExternalBreakerData(@as(*const IWordBreakerConfig, @ptrCast(self)), p_stream_, dw_ext_data_type_);
            }
            pub inline fn setWordStemmer(self: *const T, rclsid_: ?*const Guid, p_stemmer_: ?*IStemmer) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetWordStemmer(@as(*const IWordBreakerConfig, @ptrCast(self)), rclsid_, p_stemmer_);
            }
            pub inline fn getWordStemmer(self: *const T, pp_stemmer_: ?*?*IStemmer) HRESULT {
                return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetWordStemmer(@as(*const IWordBreakerConfig, @ptrCast(self)), pp_stemmer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY = enum(i32) {
    LOW = 0,
    NORMAL = 1,
    HIGH = 2,
};
pub const PRIORITY_LOW = PRIORITY.LOW;
pub const PRIORITY_NORMAL = PRIORITY.NORMAL;
pub const PRIORITY_HIGH = PRIORITY.HIGH;

pub const ROWSTATUS = extern struct {
    lRowFirst: i32,
    cRows: i32,
    cProperties: i32,
    cRowsTotal: i32,
};

pub const COLUMNSTATUS = extern struct {
    cPropCount: i32,
    cPropsLoaded: i32,
};

pub const PFNCOLHEAPFREE = *const fn (
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

const IID_IITResultSet_Value = Guid.initString("3bb91d41-998b-11d0-a850-00aa006c7d01");
pub const IID_IITResultSet = &IID_IITResultSet_Value;
pub const IITResultSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnPriority: *const fn (
            self: *const IITResultSet,
            l_column_index: i32,
            column_priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnHeap: *const fn (
            self: *const IITResultSet,
            l_column_index: i32,
            lpv_heap: ?*anyopaque,
            pfn_col_heap_free: ?PFNCOLHEAPFREE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeyProp: *const fn (
            self: *const IITResultSet,
            prop_i_d: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IITResultSet,
            prop_i_d: u32,
            dw_default_data: u32,
            priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add1: *const fn (
            self: *const IITResultSet,
            prop_i_d: u32,
            lpszw_default: ?[*:0]const u16,
            priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add2: *const fn (
            self: *const IITResultSet,
            prop_i_d: u32,
            lpv_default_data: ?*anyopaque,
            cb_data: u32,
            priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add3: *const fn (
            self: *const IITResultSet,
            lpv_hdr: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: *const fn (
            self: *const IITResultSet,
            lpv_hdr: ?*anyopaque,
            lpv_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: *const fn (
            self: *const IITResultSet,
            l_row_index: i32,
            l_column_index: i32,
            lpv_data: ?*anyopaque,
            cb_data: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set1: *const fn (
            self: *const IITResultSet,
            l_row_index: i32,
            l_column_index: i32,
            lpw_str: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set2: *const fn (
            self: *const IITResultSet,
            l_row_index: i32,
            l_column_index: i32,
            dw_data: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set3: *const fn (
            self: *const IITResultSet,
            l_row_index: i32,
            lpv_hdr: ?*anyopaque,
            lpv_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: *const fn (
            self: *const IITResultSet,
            p_r_s_copy: ?*IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendRows: *const fn (
            self: *const IITResultSet,
            p_res_src: ?*IITResultSet,
            l_row_src_first: i32,
            c_src_rows: i32,
            l_row_first_dest: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: *const fn (
            self: *const IITResultSet,
            l_row_index: i32,
            l_column_index: i32,
            prop: ?*CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyProp: *const fn (
            self: *const IITResultSet,
            key_prop_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnPriority: *const fn (
            self: *const IITResultSet,
            l_column_index: i32,
            column_priority: ?*PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowCount: *const fn (
            self: *const IITResultSet,
            l_number_of_rows: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnCount: *const fn (
            self: *const IITResultSet,
            l_number_of_columns: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: *const fn (
            self: *const IITResultSet,
            l_column_index: i32,
            prop_i_d: ?*u32,
            dw_type: ?*u32,
            lpv_default_value: ?*?*anyopaque,
            cb_size: ?*u32,
            column_priority: ?*PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn1: *const fn (
            self: *const IITResultSet,
            l_column_index: i32,
            prop_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnFromPropID: *const fn (
            self: *const IITResultSet,
            prop_i_d: u32,
            l_column_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: *const fn (
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearRows: *const fn (
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: *const fn (
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCompleted: *const fn (
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: *const fn (
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: *const fn (
            self: *const IITResultSet,
            f_pause: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowStatus: *const fn (
            self: *const IITResultSet,
            l_row_first: i32,
            c_rows: i32,
            lp_row_status: ?*ROWSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnStatus: *const fn (
            self: *const IITResultSet,
            lp_col_status: ?*COLUMNSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setColumnPriority(self: *const T, l_column_index_: i32, column_priority_: PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetColumnPriority(@as(*const IITResultSet, @ptrCast(self)), l_column_index_, column_priority_);
            }
            pub inline fn setColumnHeap(self: *const T, l_column_index_: i32, lpv_heap_: ?*anyopaque, pfn_col_heap_free_: ?PFNCOLHEAPFREE) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetColumnHeap(@as(*const IITResultSet, @ptrCast(self)), l_column_index_, lpv_heap_, pfn_col_heap_free_);
            }
            pub inline fn setKeyProp(self: *const T, prop_i_d_: u32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetKeyProp(@as(*const IITResultSet, @ptrCast(self)), prop_i_d_);
            }
            pub inline fn add(self: *const T, prop_i_d_: u32, dw_default_data_: u32, priority_: PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), prop_i_d_, dw_default_data_, priority_);
            }
            pub inline fn add1(self: *const T, prop_i_d_: u32, lpszw_default_: ?[*:0]const u16, priority_: PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), prop_i_d_, lpszw_default_, priority_);
            }
            pub inline fn add2(self: *const T, prop_i_d_: u32, lpv_default_data_: ?*anyopaque, cb_data_: u32, priority_: PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), prop_i_d_, lpv_default_data_, cb_data_, priority_);
            }
            pub inline fn add3(self: *const T, lpv_hdr_: ?*anyopaque) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), lpv_hdr_);
            }
            pub inline fn append(self: *const T, lpv_hdr_: ?*anyopaque, lpv_data_: ?*anyopaque) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Append(@as(*const IITResultSet, @ptrCast(self)), lpv_hdr_, lpv_data_);
            }
            pub inline fn set(self: *const T, l_row_index_: i32, l_column_index_: i32, lpv_data_: ?*anyopaque, cb_data_: u32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), l_row_index_, l_column_index_, lpv_data_, cb_data_);
            }
            pub inline fn set1(self: *const T, l_row_index_: i32, l_column_index_: i32, lpw_str_: ?[*:0]const u16) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), l_row_index_, l_column_index_, lpw_str_);
            }
            pub inline fn set2(self: *const T, l_row_index_: i32, l_column_index_: i32, dw_data_: usize) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), l_row_index_, l_column_index_, dw_data_);
            }
            pub inline fn set3(self: *const T, l_row_index_: i32, lpv_hdr_: ?*anyopaque, lpv_data_: ?*anyopaque) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), l_row_index_, lpv_hdr_, lpv_data_);
            }
            pub inline fn copy(self: *const T, p_r_s_copy_: ?*IITResultSet) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Copy(@as(*const IITResultSet, @ptrCast(self)), p_r_s_copy_);
            }
            pub inline fn appendRows(self: *const T, p_res_src_: ?*IITResultSet, l_row_src_first_: i32, c_src_rows_: i32, l_row_first_dest_: ?*i32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).AppendRows(@as(*const IITResultSet, @ptrCast(self)), p_res_src_, l_row_src_first_, c_src_rows_, l_row_first_dest_);
            }
            pub inline fn get(self: *const T, l_row_index_: i32, l_column_index_: i32, prop_: ?*CProperty) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Get(@as(*const IITResultSet, @ptrCast(self)), l_row_index_, l_column_index_, prop_);
            }
            pub inline fn getKeyProp(self: *const T, key_prop_i_d_: ?*u32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetKeyProp(@as(*const IITResultSet, @ptrCast(self)), key_prop_i_d_);
            }
            pub inline fn getColumnPriority(self: *const T, l_column_index_: i32, column_priority_: ?*PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnPriority(@as(*const IITResultSet, @ptrCast(self)), l_column_index_, column_priority_);
            }
            pub inline fn getRowCount(self: *const T, l_number_of_rows_: ?*i32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetRowCount(@as(*const IITResultSet, @ptrCast(self)), l_number_of_rows_);
            }
            pub inline fn getColumnCount(self: *const T, l_number_of_columns_: ?*i32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnCount(@as(*const IITResultSet, @ptrCast(self)), l_number_of_columns_);
            }
            pub inline fn getColumn(self: *const T, l_column_index_: i32, prop_i_d_: ?*u32, dw_type_: ?*u32, lpv_default_value_: ?*?*anyopaque, cb_size_: ?*u32, column_priority_: ?*PRIORITY) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const IITResultSet, @ptrCast(self)), l_column_index_, prop_i_d_, dw_type_, lpv_default_value_, cb_size_, column_priority_);
            }
            pub inline fn getColumn1(self: *const T, l_column_index_: i32, prop_i_d_: ?*u32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const IITResultSet, @ptrCast(self)), l_column_index_, prop_i_d_);
            }
            pub inline fn getColumnFromPropID(self: *const T, prop_i_d_: u32, l_column_index_: ?*i32) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnFromPropID(@as(*const IITResultSet, @ptrCast(self)), prop_i_d_, l_column_index_);
            }
            pub inline fn clear(self: *const T) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Clear(@as(*const IITResultSet, @ptrCast(self)));
            }
            pub inline fn clearRows(self: *const T) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).ClearRows(@as(*const IITResultSet, @ptrCast(self)));
            }
            pub inline fn free(self: *const T) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Free(@as(*const IITResultSet, @ptrCast(self)));
            }
            pub inline fn isCompleted(self: *const T) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).IsCompleted(@as(*const IITResultSet, @ptrCast(self)));
            }
            pub inline fn cancel(self: *const T) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IITResultSet, @ptrCast(self)));
            }
            pub inline fn pause(self: *const T, f_pause_: BOOL) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Pause(@as(*const IITResultSet, @ptrCast(self)), f_pause_);
            }
            pub inline fn getRowStatus(self: *const T, l_row_first_: i32, c_rows_: i32, lp_row_status_: ?*ROWSTATUS) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetRowStatus(@as(*const IITResultSet, @ptrCast(self)), l_row_first_, c_rows_, lp_row_status_);
            }
            pub inline fn getColumnStatus(self: *const T, lp_col_status_: ?*COLUMNSTATUS) HRESULT {
                return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnStatus(@as(*const IITResultSet, @ptrCast(self)), lp_col_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (15)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IPersistStreamInit = @import("../system/com.zig").IPersistStreamInit;
const IStemmer = @import("../system/search.zig").IStemmer;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const NMHDR = @import("../ui/controls.zig").NMHDR;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFNCOLHEAPFREE")) {
        _ = PFNCOLHEAPFREE;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
