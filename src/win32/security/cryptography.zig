//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (2849)
//--------------------------------------------------------------------------------
pub const CERT_COMPARE_SHIFT = @as(i32, 16);
pub const BCRYPT_OBJECT_ALIGNMENT = @as(u32, 16);
pub const BCRYPT_KDF_HASH = "HASH";
pub const BCRYPT_KDF_HMAC = "HMAC";
pub const BCRYPT_KDF_TLS_PRF = "TLS_PRF";
pub const BCRYPT_KDF_SP80056A_CONCAT = "SP800_56A_CONCAT";
pub const BCRYPT_KDF_RAW_SECRET = "TRUNCATE";
pub const BCRYPT_KDF_HKDF = "HKDF";
pub const KDF_HASH_ALGORITHM = @as(u32, 0);
pub const KDF_SECRET_PREPEND = @as(u32, 1);
pub const KDF_SECRET_APPEND = @as(u32, 2);
pub const KDF_HMAC_KEY = @as(u32, 3);
pub const KDF_TLS_PRF_LABEL = @as(u32, 4);
pub const KDF_TLS_PRF_SEED = @as(u32, 5);
pub const KDF_SECRET_HANDLE = @as(u32, 6);
pub const KDF_TLS_PRF_PROTOCOL = @as(u32, 7);
pub const KDF_ALGORITHMID = @as(u32, 8);
pub const KDF_PARTYUINFO = @as(u32, 9);
pub const KDF_PARTYVINFO = @as(u32, 10);
pub const KDF_SUPPPUBINFO = @as(u32, 11);
pub const KDF_SUPPPRIVINFO = @as(u32, 12);
pub const KDF_LABEL = @as(u32, 13);
pub const KDF_CONTEXT = @as(u32, 14);
pub const KDF_SALT = @as(u32, 15);
pub const KDF_ITERATION_COUNT = @as(u32, 16);
pub const KDF_GENERIC_PARAMETER = @as(u32, 17);
pub const KDF_KEYBITLENGTH = @as(u32, 18);
pub const KDF_HKDF_SALT = @as(u32, 19);
pub const KDF_HKDF_INFO = @as(u32, 20);
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = @as(u32, 2);
pub const BCRYPT_OPAQUE_KEY_BLOB = "OpaqueKeyBlob";
pub const BCRYPT_KEY_DATA_BLOB = "KeyDataBlob";
pub const BCRYPT_AES_WRAP_KEY_BLOB = "Rfc3565KeyWrapBlob";
pub const BCRYPT_OBJECT_LENGTH = "ObjectLength";
pub const BCRYPT_ALGORITHM_NAME = "AlgorithmName";
pub const BCRYPT_PROVIDER_HANDLE = "ProviderHandle";
pub const BCRYPT_CHAINING_MODE = "ChainingMode";
pub const BCRYPT_BLOCK_LENGTH = "BlockLength";
pub const BCRYPT_KEY_LENGTH = "KeyLength";
pub const BCRYPT_KEY_OBJECT_LENGTH = "KeyObjectLength";
pub const BCRYPT_KEY_STRENGTH = "KeyStrength";
pub const BCRYPT_KEY_LENGTHS = "KeyLengths";
pub const BCRYPT_BLOCK_SIZE_LIST = "BlockSizeList";
pub const BCRYPT_EFFECTIVE_KEY_LENGTH = "EffectiveKeyLength";
pub const BCRYPT_HASH_LENGTH = "HashDigestLength";
pub const BCRYPT_HASH_OID_LIST = "HashOIDList";
pub const BCRYPT_PADDING_SCHEMES = "PaddingSchemes";
pub const BCRYPT_SIGNATURE_LENGTH = "SignatureLength";
pub const BCRYPT_HASH_BLOCK_LENGTH = "HashBlockLength";
pub const BCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";
pub const BCRYPT_PRIMITIVE_TYPE = "PrimitiveType";
pub const BCRYPT_IS_KEYED_HASH = "IsKeyedHash";
pub const BCRYPT_IS_REUSABLE_HASH = "IsReusableHash";
pub const BCRYPT_MESSAGE_BLOCK_LENGTH = "MessageBlockLength";
pub const BCRYPT_PUBLIC_KEY_LENGTH = "PublicKeyLength";
pub const BCRYPT_PCP_PLATFORM_TYPE_PROPERTY = "PCP_PLATFORM_TYPE";
pub const BCRYPT_PCP_PROVIDER_VERSION_PROPERTY = "PCP_PROVIDER_VERSION";
pub const BCRYPT_MULTI_OBJECT_LENGTH = "MultiObjectLength";
pub const BCRYPT_IS_IFX_TPM_WEAK_KEY = "IsIfxTpmWeakKey";
pub const BCRYPT_HKDF_HASH_ALGORITHM = "HkdfHashAlgorithm";
pub const BCRYPT_HKDF_SALT_AND_FINALIZE = "HkdfSaltAndFinalize";
pub const BCRYPT_HKDF_PRK_AND_FINALIZE = "HkdfPrkAndFinalize";
pub const BCRYPT_INITIALIZATION_VECTOR = "IV";
pub const BCRYPT_CHAIN_MODE_NA = "ChainingModeN/A";
pub const BCRYPT_CHAIN_MODE_CBC = "ChainingModeCBC";
pub const BCRYPT_CHAIN_MODE_ECB = "ChainingModeECB";
pub const BCRYPT_CHAIN_MODE_CFB = "ChainingModeCFB";
pub const BCRYPT_CHAIN_MODE_CCM = "ChainingModeCCM";
pub const BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";
pub const BCRYPT_SUPPORTED_PAD_ROUTER = @as(u32, 1);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = @as(u32, 4);
pub const BCRYPT_SUPPORTED_PAD_OAEP = @as(u32, 8);
pub const BCRYPT_SUPPORTED_PAD_PSS = @as(u32, 16);
pub const BCRYPT_BLOCK_PADDING = @as(u32, 1);
pub const BCRYPT_GENERATE_IV = @as(u32, 32);
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = @as(u32, 16);
pub const BCRYPTBUFFER_VERSION = @as(u32, 0);
pub const BCRYPT_PUBLIC_KEY_BLOB = "PUBLICBLOB";
pub const BCRYPT_PRIVATE_KEY_BLOB = "PRIVATEBLOB";
pub const BCRYPT_RSAPUBLIC_BLOB = "RSAPUBLICBLOB";
pub const BCRYPT_RSAPRIVATE_BLOB = "RSAPRIVATEBLOB";
pub const LEGACY_RSAPUBLIC_BLOB = "CAPIPUBLICBLOB";
pub const LEGACY_RSAPRIVATE_BLOB = "CAPIPRIVATEBLOB";
pub const BCRYPT_RSAFULLPRIVATE_BLOB = "RSAFULLPRIVATEBLOB";
pub const BCRYPT_GLOBAL_PARAMETERS = "SecretAgreementParam";
pub const BCRYPT_PRIVATE_KEY = "PrivKeyVal";
pub const BCRYPT_ECCPUBLIC_BLOB = "ECCPUBLICBLOB";
pub const BCRYPT_ECCPRIVATE_BLOB = "ECCPRIVATEBLOB";
pub const BCRYPT_ECCFULLPUBLIC_BLOB = "ECCFULLPUBLICBLOB";
pub const BCRYPT_ECCFULLPRIVATE_BLOB = "ECCFULLPRIVATEBLOB";
pub const SSL_ECCPUBLIC_BLOB = "SSLECCPUBLICBLOB";
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC = @as(u32, 827016005);
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC = @as(u32, 843793221);
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC = @as(u32, 860570437);
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC = @as(u32, 877347653);
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC = @as(u32, 894124869);
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC = @as(u32, 910902085);
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = @as(u32, 1347109701);
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = @as(u32, 1447772997);
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = @as(u32, 827540293);
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = @as(u32, 844317509);
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = @as(u32, 861094725);
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = @as(u32, 877871941);
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = @as(u32, 894649157);
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = @as(u32, 911426373);
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = @as(u32, 1346650949);
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = @as(u32, 1447314245);
pub const BCRYPT_ECC_FULLKEY_BLOB_V1 = @as(u32, 1);
pub const BCRYPT_DH_PUBLIC_BLOB = "DHPUBLICBLOB";
pub const BCRYPT_DH_PRIVATE_BLOB = "DHPRIVATEBLOB";
pub const LEGACY_DH_PUBLIC_BLOB = "CAPIDHPUBLICBLOB";
pub const LEGACY_DH_PRIVATE_BLOB = "CAPIDHPRIVATEBLOB";
pub const BCRYPT_DH_PARAMETERS = "DHParameters";
pub const BCRYPT_DH_PARAMETERS_MAGIC = @as(u32, 1297107012);
pub const BCRYPT_DSA_PUBLIC_BLOB = "DSAPUBLICBLOB";
pub const BCRYPT_DSA_PRIVATE_BLOB = "DSAPRIVATEBLOB";
pub const LEGACY_DSA_PUBLIC_BLOB = "CAPIDSAPUBLICBLOB";
pub const LEGACY_DSA_PRIVATE_BLOB = "CAPIDSAPRIVATEBLOB";
pub const LEGACY_DSA_V2_PUBLIC_BLOB = "V2CAPIDSAPUBLICBLOB";
pub const LEGACY_DSA_V2_PRIVATE_BLOB = "V2CAPIDSAPRIVATEBLOB";
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2 = @as(u32, 843206724);
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2 = @as(u32, 844517444);
pub const BCRYPT_KEY_DATA_BLOB_MAGIC = @as(u32, 1296188491);
pub const BCRYPT_KEY_DATA_BLOB_VERSION1 = @as(u32, 1);
pub const BCRYPT_DSA_PARAMETERS = "DSAParameters";
pub const BCRYPT_DSA_PARAMETERS_MAGIC = @as(u32, 1297109828);
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = @as(u32, 843927620);
pub const BCRYPT_ECC_PARAMETERS = "ECCParameters";
pub const BCRYPT_ECC_CURVE_NAME = "ECCCurveName";
pub const BCRYPT_ECC_CURVE_NAME_LIST = "ECCCurveNameList";
pub const BCRYPT_ECC_PARAMETERS_MAGIC = @as(u32, 1346585413);
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160R1 = "brainpoolP160r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160T1 = "brainpoolP160t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192R1 = "brainpoolP192r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192T1 = "brainpoolP192t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224R1 = "brainpoolP224r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224T1 = "brainpoolP224t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256R1 = "brainpoolP256r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256T1 = "brainpoolP256t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320R1 = "brainpoolP320r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320T1 = "brainpoolP320t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384R1 = "brainpoolP384r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384T1 = "brainpoolP384t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512R1 = "brainpoolP512r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512T1 = "brainpoolP512t1";
pub const BCRYPT_ECC_CURVE_25519 = "curve25519";
pub const BCRYPT_ECC_CURVE_EC192WAPI = "ec192wapi";
pub const BCRYPT_ECC_CURVE_NISTP192 = "nistP192";
pub const BCRYPT_ECC_CURVE_NISTP224 = "nistP224";
pub const BCRYPT_ECC_CURVE_NISTP256 = "nistP256";
pub const BCRYPT_ECC_CURVE_NISTP384 = "nistP384";
pub const BCRYPT_ECC_CURVE_NISTP521 = "nistP521";
pub const BCRYPT_ECC_CURVE_NUMSP256T1 = "numsP256t1";
pub const BCRYPT_ECC_CURVE_NUMSP384T1 = "numsP384t1";
pub const BCRYPT_ECC_CURVE_NUMSP512T1 = "numsP512t1";
pub const BCRYPT_ECC_CURVE_SECP160K1 = "secP160k1";
pub const BCRYPT_ECC_CURVE_SECP160R1 = "secP160r1";
pub const BCRYPT_ECC_CURVE_SECP160R2 = "secP160r2";
pub const BCRYPT_ECC_CURVE_SECP192K1 = "secP192k1";
pub const BCRYPT_ECC_CURVE_SECP192R1 = "secP192r1";
pub const BCRYPT_ECC_CURVE_SECP224K1 = "secP224k1";
pub const BCRYPT_ECC_CURVE_SECP224R1 = "secP224r1";
pub const BCRYPT_ECC_CURVE_SECP256K1 = "secP256k1";
pub const BCRYPT_ECC_CURVE_SECP256R1 = "secP256r1";
pub const BCRYPT_ECC_CURVE_SECP384R1 = "secP384r1";
pub const BCRYPT_ECC_CURVE_SECP521R1 = "secP521r1";
pub const BCRYPT_ECC_CURVE_WTLS7 = "wtls7";
pub const BCRYPT_ECC_CURVE_WTLS9 = "wtls9";
pub const BCRYPT_ECC_CURVE_WTLS12 = "wtls12";
pub const BCRYPT_ECC_CURVE_X962P192V1 = "x962P192v1";
pub const BCRYPT_ECC_CURVE_X962P192V2 = "x962P192v2";
pub const BCRYPT_ECC_CURVE_X962P192V3 = "x962P192v3";
pub const BCRYPT_ECC_CURVE_X962P239V1 = "x962P239v1";
pub const BCRYPT_ECC_CURVE_X962P239V2 = "x962P239v2";
pub const BCRYPT_ECC_CURVE_X962P239V3 = "x962P239v3";
pub const BCRYPT_ECC_CURVE_X962P256V1 = "x962P256v1";
pub const MS_PRIMITIVE_PROVIDER = "Microsoft Primitive Provider";
pub const MS_PLATFORM_CRYPTO_PROVIDER = "Microsoft Platform Crypto Provider";
pub const BCRYPT_RSA_ALGORITHM = "RSA";
pub const BCRYPT_RSA_SIGN_ALGORITHM = "RSA_SIGN";
pub const BCRYPT_DH_ALGORITHM = "DH";
pub const BCRYPT_DSA_ALGORITHM = "DSA";
pub const BCRYPT_RC2_ALGORITHM = "RC2";
pub const BCRYPT_RC4_ALGORITHM = "RC4";
pub const BCRYPT_AES_ALGORITHM = "AES";
pub const BCRYPT_DES_ALGORITHM = "DES";
pub const BCRYPT_DESX_ALGORITHM = "DESX";
pub const BCRYPT_3DES_ALGORITHM = "3DES";
pub const BCRYPT_3DES_112_ALGORITHM = "3DES_112";
pub const BCRYPT_MD2_ALGORITHM = "MD2";
pub const BCRYPT_MD4_ALGORITHM = "MD4";
pub const BCRYPT_MD5_ALGORITHM = "MD5";
pub const BCRYPT_SHA1_ALGORITHM = "SHA1";
pub const BCRYPT_SHA256_ALGORITHM = "SHA256";
pub const BCRYPT_SHA384_ALGORITHM = "SHA384";
pub const BCRYPT_SHA512_ALGORITHM = "SHA512";
pub const BCRYPT_AES_GMAC_ALGORITHM = "AES-GMAC";
pub const BCRYPT_AES_CMAC_ALGORITHM = "AES-CMAC";
pub const BCRYPT_ECDSA_P256_ALGORITHM = "ECDSA_P256";
pub const BCRYPT_ECDSA_P384_ALGORITHM = "ECDSA_P384";
pub const BCRYPT_ECDSA_P521_ALGORITHM = "ECDSA_P521";
pub const BCRYPT_ECDH_P256_ALGORITHM = "ECDH_P256";
pub const BCRYPT_ECDH_P384_ALGORITHM = "ECDH_P384";
pub const BCRYPT_ECDH_P521_ALGORITHM = "ECDH_P521";
pub const BCRYPT_RNG_ALGORITHM = "RNG";
pub const BCRYPT_RNG_FIPS186_DSA_ALGORITHM = "FIPS186DSARNG";
pub const BCRYPT_RNG_DUAL_EC_ALGORITHM = "DUALECRNG";
pub const BCRYPT_SP800108_CTR_HMAC_ALGORITHM = "SP800_108_CTR_HMAC";
pub const BCRYPT_SP80056A_CONCAT_ALGORITHM = "SP800_56A_CONCAT";
pub const BCRYPT_PBKDF2_ALGORITHM = "PBKDF2";
pub const BCRYPT_CAPI_KDF_ALGORITHM = "CAPI_KDF";
pub const BCRYPT_TLS1_1_KDF_ALGORITHM = "TLS1_1_KDF";
pub const BCRYPT_TLS1_2_KDF_ALGORITHM = "TLS1_2_KDF";
pub const BCRYPT_ECDSA_ALGORITHM = "ECDSA";
pub const BCRYPT_ECDH_ALGORITHM = "ECDH";
pub const BCRYPT_XTS_AES_ALGORITHM = "XTS-AES";
pub const BCRYPT_HKDF_ALGORITHM = "HKDF";
pub const BCRYPT_CHACHA20_POLY1305_ALGORITHM = "CHACHA20_POLY1305";
pub const BCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const BCRYPT_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 1));
pub const BCRYPT_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 17));
pub const BCRYPT_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 33));
pub const BCRYPT_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 49));
pub const BCRYPT_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 65));
pub const BCRYPT_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 81));
pub const BCRYPT_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 97));
pub const BCRYPT_RC4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 113));
pub const BCRYPT_RNG_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 129));
pub const BCRYPT_HMAC_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 145));
pub const BCRYPT_HMAC_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 161));
pub const BCRYPT_HMAC_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 177));
pub const BCRYPT_HMAC_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 193));
pub const BCRYPT_HMAC_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 209));
pub const BCRYPT_RSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 225));
pub const BCRYPT_ECDSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 241));
pub const BCRYPT_AES_CMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 257));
pub const BCRYPT_AES_GMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 273));
pub const BCRYPT_HMAC_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 289));
pub const BCRYPT_HMAC_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 305));
pub const BCRYPT_3DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 321));
pub const BCRYPT_3DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 337));
pub const BCRYPT_3DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 353));
pub const BCRYPT_3DES_112_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 369));
pub const BCRYPT_3DES_112_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 385));
pub const BCRYPT_3DES_112_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 401));
pub const BCRYPT_AES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 417));
pub const BCRYPT_AES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 433));
pub const BCRYPT_AES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 449));
pub const BCRYPT_AES_CCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 465));
pub const BCRYPT_AES_GCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 481));
pub const BCRYPT_DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 497));
pub const BCRYPT_DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 513));
pub const BCRYPT_DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 529));
pub const BCRYPT_DESX_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 545));
pub const BCRYPT_DESX_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 561));
pub const BCRYPT_DESX_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 577));
pub const BCRYPT_RC2_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 593));
pub const BCRYPT_RC2_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 609));
pub const BCRYPT_RC2_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 625));
pub const BCRYPT_DH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 641));
pub const BCRYPT_ECDH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 657));
pub const BCRYPT_ECDH_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 673));
pub const BCRYPT_ECDH_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 689));
pub const BCRYPT_ECDH_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 705));
pub const BCRYPT_DSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 721));
pub const BCRYPT_ECDSA_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 737));
pub const BCRYPT_ECDSA_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 753));
pub const BCRYPT_ECDSA_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 769));
pub const BCRYPT_RSA_SIGN_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 785));
pub const BCRYPT_CAPI_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 801));
pub const BCRYPT_PBKDF2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 817));
pub const BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 833));
pub const BCRYPT_SP80056A_CONCAT_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 849));
pub const BCRYPT_TLS1_1_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 865));
pub const BCRYPT_TLS1_2_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 881));
pub const BCRYPT_XTS_AES_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 897));
pub const BCRYPT_HKDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 913));
pub const BCRYPT_CHACHA20_POLY1305_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 929));
pub const BCRYPT_CAPI_AES_FLAG = @as(u32, 16);
pub const BCRYPT_MULTI_FLAG = @as(u32, 64);
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = @as(u32, 4);
pub const BCRYPT_BUFFERS_LOCKED_FLAG = @as(u32, 64);
pub const BCRYPT_EXTENDED_KEYSIZE = @as(u32, 128);
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = @as(u32, 256);
pub const BCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const BCRYPT_PUBLIC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_PRIVATE_KEY_FLAG = @as(u32, 2);
pub const BCRYPT_NO_KEY_VALIDATION = @as(u32, 8);
pub const BCRYPT_KEY_VALIDATION_RANGE = @as(u32, 16);
pub const BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER = @as(u32, 24);
pub const BCRYPT_KEY_VALIDATION_REGENERATE = @as(u32, 32);
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = @as(u32, 1);
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG = @as(u32, 2);
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = @as(u32, 2);
pub const CRYPT_OVERWRITE = @as(u32, 1);
pub const CRYPT_PRIORITY_TOP = @as(u32, 0);
pub const CRYPT_PRIORITY_BOTTOM = @as(u32, 4294967295);
pub const CRYPT_DEFAULT_CONTEXT = "Default";
pub const wszXMLNS_DIGSIG = "http://www.w3.org/2000/09/xmldsig#";
pub const wszXMLNS_DIGSIG_SignatureProperties = "http://www.w3.org/2000/09/xmldsig#SignatureProperties";
pub const wszXMLNS_DIGSIG_Id = "Id";
pub const wszURI_XMLNS_DIGSIG_BASE64 = "http://www.w3.org/2000/09/xmldsig#base64";
pub const wszURI_XMLNS_DIGSIG_SHA1 = "http://www.w3.org/2000/09/xmldsig#sha1";
pub const wszURI_XMLNS_DIGSIG_SHA256 = "http://www.w3.org/2001/04/xmlenc#sha256";
pub const wszURI_XMLNS_DIGSIG_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#sha384";
pub const wszURI_XMLNS_DIGSIG_SHA512 = "http://www.w3.org/2001/04/xmlenc#sha512";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA1 = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
pub const wszURI_XMLNS_DIGSIG_DSA_SHA1 = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA1 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA1 = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512";
pub const wszURI_CANONICALIZATION_C14N = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
pub const wszURI_CANONICALIZATION_C14NC = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
pub const wszURI_CANONICALIZATION_EXSLUSIVE_C14N = "http://www.w3.org/2001/10/xml-exc-c14n#";
pub const wszURI_CANONICALIZATION_EXSLUSIVE_C14NC = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
pub const wszURI_TRANSFORM_XPATH = "http://www.w3.org/TR/1999/REC-xpath-19991116";
pub const wszURI_XMLNS_TRANSFORM_BASE64 = "http://www.w3.org/2000/09/xmldsig#base64";
pub const wszURI_XMLNS_TRANSFORM_ENVELOPED = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
pub const CRYPT_XML_BLOB_MAX = @as(u32, 2147483640);
pub const CRYPT_XML_ID_MAX = @as(u32, 256);
pub const CRYPT_XML_SIGNATURES_MAX = @as(u32, 16);
pub const CRYPT_XML_TRANSFORM_MAX = @as(u32, 16);
pub const CRYPT_XML_SIGNATURE_VALUE_MAX = @as(u32, 2048);
pub const CRYPT_XML_DIGEST_VALUE_MAX = @as(u32, 128);
pub const CRYPT_XML_OBJECTS_MAX = @as(u32, 256);
pub const CRYPT_XML_REFERENCES_MAX = @as(u32, 32760);
pub const CRYPT_XML_E_BASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885376));
pub const CRYPT_XML_E_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885375));
pub const CRYPT_XML_E_TOO_MANY_TRANSFORMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885374));
pub const CRYPT_XML_E_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885373));
pub const CRYPT_XML_E_ALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885372));
pub const CRYPT_XML_E_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885371));
pub const CRYPT_XML_E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885370));
pub const CRYPT_XML_E_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885369));
pub const CRYPT_XML_E_UNRESOLVED_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885368));
pub const CRYPT_XML_E_INVALID_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885367));
pub const CRYPT_XML_E_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885366));
pub const CRYPT_XML_E_HASH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885365));
pub const CRYPT_XML_E_SIGN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885364));
pub const CRYPT_XML_E_VERIFY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885363));
pub const CRYPT_XML_E_TOO_MANY_SIGNATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885362));
pub const CRYPT_XML_E_INVALID_KEYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885361));
pub const CRYPT_XML_E_UNEXPECTED_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885360));
pub const CRYPT_XML_E_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885359));
pub const CRYPT_XML_E_NON_UNIQUE_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT = @as(u32, 1073741824);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT = @as(u32, 536870912);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT = @as(u32, 134217728);
pub const CRYPT_XML_FLAG_ECDSA_DSIG11 = @as(u32, 67108864);
pub const CRYPT_XML_STATUS_NO_ERROR = @as(u32, 0);
pub const CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY = @as(u32, 1);
pub const CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT = @as(u32, 1);
pub const CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_HASH = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_SIGN = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI = @as(u32, 1);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID = @as(u32, 3);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID = @as(u32, 4);
pub const szFORCE_KEY_PROTECTION = "ForceKeyProtection";
pub const dwFORCE_KEY_PROTECTION_DISABLED = @as(u32, 0);
pub const dwFORCE_KEY_PROTECTION_USER_SELECT = @as(u32, 1);
pub const dwFORCE_KEY_PROTECTION_HIGH = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_RESERVED = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_STRONG = @as(u32, 8);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = @as(u32, 16);
pub const CRYPTPROTECT_UI_FORBIDDEN = @as(u32, 1);
pub const CRYPTPROTECT_LOCAL_MACHINE = @as(u32, 4);
pub const CRYPTPROTECT_CRED_SYNC = @as(u32, 8);
pub const CRYPTPROTECT_AUDIT = @as(u32, 16);
pub const CRYPTPROTECT_NO_RECOVERY = @as(u32, 32);
pub const CRYPTPROTECT_VERIFY_PROTECTION = @as(u32, 64);
pub const CRYPTPROTECT_CRED_REGENERATE = @as(u32, 128);
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = @as(u32, 268435455);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = @as(u32, 4294967295);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = @as(u32, 16);
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = @as(u32, 0);
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = @as(u32, 1);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = @as(u32, 2);
pub const NCRYPT_MAX_KEY_NAME_LENGTH = @as(u32, 512);
pub const NCRYPT_MAX_ALG_ID_LENGTH = @as(u32, 512);
pub const MS_KEY_STORAGE_PROVIDER = "Microsoft Software Key Storage Provider";
pub const MS_SMART_CARD_KEY_STORAGE_PROVIDER = "Microsoft Smart Card Key Storage Provider";
pub const MS_PLATFORM_KEY_STORAGE_PROVIDER = "Microsoft Platform Crypto Provider";
pub const MS_NGC_KEY_STORAGE_PROVIDER = "Microsoft Passport Key Storage Provider";
pub const TPM_RSA_SRK_SEAL_KEY = "MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074";
pub const NCRYPT_RSA_ALGORITHM = "RSA";
pub const NCRYPT_RSA_SIGN_ALGORITHM = "RSA_SIGN";
pub const NCRYPT_DH_ALGORITHM = "DH";
pub const NCRYPT_DSA_ALGORITHM = "DSA";
pub const NCRYPT_MD2_ALGORITHM = "MD2";
pub const NCRYPT_MD4_ALGORITHM = "MD4";
pub const NCRYPT_MD5_ALGORITHM = "MD5";
pub const NCRYPT_SHA1_ALGORITHM = "SHA1";
pub const NCRYPT_SHA256_ALGORITHM = "SHA256";
pub const NCRYPT_SHA384_ALGORITHM = "SHA384";
pub const NCRYPT_SHA512_ALGORITHM = "SHA512";
pub const NCRYPT_ECDSA_P256_ALGORITHM = "ECDSA_P256";
pub const NCRYPT_ECDSA_P384_ALGORITHM = "ECDSA_P384";
pub const NCRYPT_ECDSA_P521_ALGORITHM = "ECDSA_P521";
pub const NCRYPT_ECDH_P256_ALGORITHM = "ECDH_P256";
pub const NCRYPT_ECDH_P384_ALGORITHM = "ECDH_P384";
pub const NCRYPT_ECDH_P521_ALGORITHM = "ECDH_P521";
pub const NCRYPT_AES_ALGORITHM = "AES";
pub const NCRYPT_RC2_ALGORITHM = "RC2";
pub const NCRYPT_3DES_ALGORITHM = "3DES";
pub const NCRYPT_DES_ALGORITHM = "DES";
pub const NCRYPT_DESX_ALGORITHM = "DESX";
pub const NCRYPT_3DES_112_ALGORITHM = "3DES_112";
pub const NCRYPT_SP800108_CTR_HMAC_ALGORITHM = "SP800_108_CTR_HMAC";
pub const NCRYPT_SP80056A_CONCAT_ALGORITHM = "SP800_56A_CONCAT";
pub const NCRYPT_PBKDF2_ALGORITHM = "PBKDF2";
pub const NCRYPT_CAPI_KDF_ALGORITHM = "CAPI_KDF";
pub const NCRYPT_ECDSA_ALGORITHM = "ECDSA";
pub const NCRYPT_ECDH_ALGORITHM = "ECDH";
pub const NCRYPT_KEY_STORAGE_ALGORITHM = "KEY_STORAGE";
pub const NCRYPT_HMAC_SHA256_ALGORITHM = "HMAC-SHA256";
pub const NCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const NCRYPT_KEY_PROTECTION_INTERFACE = @as(u32, 65540);
pub const NCRYPT_RSA_ALGORITHM_GROUP = "RSA";
pub const NCRYPT_DH_ALGORITHM_GROUP = "DH";
pub const NCRYPT_DSA_ALGORITHM_GROUP = "DSA";
pub const NCRYPT_ECDSA_ALGORITHM_GROUP = "ECDSA";
pub const NCRYPT_ECDH_ALGORITHM_GROUP = "ECDH";
pub const NCRYPT_AES_ALGORITHM_GROUP = "AES";
pub const NCRYPT_RC2_ALGORITHM_GROUP = "RC2";
pub const NCRYPT_DES_ALGORITHM_GROUP = "DES";
pub const NCRYPT_KEY_DERIVATION_GROUP = "KEY_DERIVATION";
pub const NCRYPTBUFFER_VERSION = @as(u32, 0);
pub const NCRYPTBUFFER_EMPTY = @as(u32, 0);
pub const NCRYPTBUFFER_DATA = @as(u32, 1);
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = @as(u32, 3);
pub const NCRYPTBUFFER_PROTECTION_FLAGS = @as(u32, 4);
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM = @as(u32, 20);
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM = @as(u32, 21);
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION = @as(u32, 22);
pub const NCRYPTBUFFER_SSL_CLEAR_KEY = @as(u32, 23);
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA = @as(u32, 24);
pub const NCRYPTBUFFER_SSL_SESSION_HASH = @as(u32, 25);
pub const NCRYPTBUFFER_PKCS_OID = @as(u32, 40);
pub const NCRYPTBUFFER_PKCS_ALG_OID = @as(u32, 41);
pub const NCRYPTBUFFER_PKCS_ALG_PARAM = @as(u32, 42);
pub const NCRYPTBUFFER_PKCS_ALG_ID = @as(u32, 43);
pub const NCRYPTBUFFER_PKCS_ATTRS = @as(u32, 44);
pub const NCRYPTBUFFER_PKCS_KEY_NAME = @as(u32, 45);
pub const NCRYPTBUFFER_PKCS_SECRET = @as(u32, 46);
pub const NCRYPTBUFFER_CERT_BLOB = @as(u32, 47);
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = @as(u32, 48);
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = @as(u32, 49);
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = @as(u32, 50);
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = @as(u32, 51);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = @as(u32, 52);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = @as(u32, 53);
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = @as(u32, 54);
pub const NCRYPTBUFFER_ECC_CURVE_NAME = @as(u32, 60);
pub const NCRYPTBUFFER_ECC_PARAMETERS = @as(u32, 61);
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD = @as(u32, 70);
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = @as(u32, 71);
pub const NCRYPTBUFFER_TPM_SEAL_TICKET = @as(u32, 72);
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = @as(u32, 73);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = @as(u32, 80);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = @as(u32, 81);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = @as(u32, 82);
pub const NCRYPT_CIPHER_NO_PADDING_FLAG = @as(u32, 0);
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = @as(u32, 1);
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG = @as(u32, 2);
pub const NCRYPT_PLATFORM_ATTEST_MAGIC = @as(u32, 1146110288);
pub const NCRYPT_KEY_ATTEST_MAGIC = @as(u32, 1146110283);
pub const NCRYPT_CLAIM_AUTHORITY_ONLY = @as(u32, 1);
pub const NCRYPT_CLAIM_SUBJECT_ONLY = @as(u32, 2);
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = @as(u32, 258);
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = @as(u32, 3);
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = @as(u32, 4);
pub const NCRYPT_CLAIM_UNKNOWN = @as(u32, 4096);
pub const NCRYPT_CLAIM_PLATFORM = @as(u32, 65536);
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = @as(u32, 1);
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = @as(u32, 2);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = @as(u32, 0);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_PAD_CIPHER_FLAG = @as(u32, 16);
pub const NCRYPT_ATTESTATION_FLAG = @as(u32, 32);
pub const NCRYPT_SEALING_FLAG = @as(u32, 256);
pub const NCRYPT_DO_NOT_FINALIZE_FLAG = @as(u32, 1024);
pub const NCRYPT_EXPORT_LEGACY_FLAG = @as(u32, 2048);
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG = @as(u32, 4096);
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = @as(u32, 8192);
pub const NCRYPT_NO_CACHED_PASSWORD = @as(u32, 16384);
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = @as(u32, 32768);
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = @as(u32, 65536);
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = @as(u32, 131072);
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG = @as(u32, 262144);
pub const NCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const NCRYPT_AUTHORITY_KEY_FLAG = @as(u32, 256);
pub const NCRYPT_NAME_PROPERTY = "Name";
pub const NCRYPT_UNIQUE_NAME_PROPERTY = "Unique Name";
pub const NCRYPT_ALGORITHM_PROPERTY = "Algorithm Name";
pub const NCRYPT_LENGTH_PROPERTY = "Length";
pub const NCRYPT_LENGTHS_PROPERTY = "Lengths";
pub const NCRYPT_BLOCK_LENGTH_PROPERTY = "Block Length";
pub const NCRYPT_PUBLIC_LENGTH_PROPERTY = "PublicKeyLength";
pub const NCRYPT_SIGNATURE_LENGTH_PROPERTY = "SignatureLength";
pub const NCRYPT_CHAINING_MODE_PROPERTY = "Chaining Mode";
pub const NCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";
pub const NCRYPT_UI_POLICY_PROPERTY = "UI Policy";
pub const NCRYPT_EXPORT_POLICY_PROPERTY = "Export Policy";
pub const NCRYPT_WINDOW_HANDLE_PROPERTY = "HWND Handle";
pub const NCRYPT_USE_CONTEXT_PROPERTY = "Use Context";
pub const NCRYPT_IMPL_TYPE_PROPERTY = "Impl Type";
pub const NCRYPT_KEY_USAGE_PROPERTY = "Key Usage";
pub const NCRYPT_KEY_TYPE_PROPERTY = "Key Type";
pub const NCRYPT_VERSION_PROPERTY = "Version";
pub const NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY = "Security Descr Support";
pub const NCRYPT_SECURITY_DESCR_PROPERTY = "Security Descr";
pub const NCRYPT_USE_COUNT_ENABLED_PROPERTY = "Enabled Use Count";
pub const NCRYPT_USE_COUNT_PROPERTY = "Use Count";
pub const NCRYPT_LAST_MODIFIED_PROPERTY = "Modified";
pub const NCRYPT_MAX_NAME_LENGTH_PROPERTY = "Max Name Length";
pub const NCRYPT_ALGORITHM_GROUP_PROPERTY = "Algorithm Group";
pub const NCRYPT_DH_PARAMETERS_PROPERTY = "DHParameters";
pub const NCRYPT_ECC_PARAMETERS_PROPERTY = "ECCParameters";
pub const NCRYPT_ECC_CURVE_NAME_PROPERTY = "ECCCurveName";
pub const NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY = "ECCCurveNameList";
pub const NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY = "Virtual Iso";
pub const NCRYPT_USE_PER_BOOT_KEY_PROPERTY = "Per Boot Key";
pub const NCRYPT_PROVIDER_HANDLE_PROPERTY = "Provider Handle";
pub const NCRYPT_PIN_PROPERTY = "SmartCardPin";
pub const NCRYPT_READER_PROPERTY = "SmartCardReader";
pub const NCRYPT_SMARTCARD_GUID_PROPERTY = "SmartCardGuid";
pub const NCRYPT_CERTIFICATE_PROPERTY = "SmartCardKeyCertificate";
pub const NCRYPT_PIN_PROMPT_PROPERTY = "SmartCardPinPrompt";
pub const NCRYPT_USER_CERTSTORE_PROPERTY = "SmartCardUserCertStore";
pub const NCRYPT_ROOT_CERTSTORE_PROPERTY = "SmartcardRootCertStore";
pub const NCRYPT_SECURE_PIN_PROPERTY = "SmartCardSecurePin";
pub const NCRYPT_ASSOCIATED_ECDH_KEY = "SmartCardAssociatedECDHKey";
pub const NCRYPT_SCARD_PIN_ID = "SmartCardPinId";
pub const NCRYPT_SCARD_PIN_INFO = "SmartCardPinInfo";
pub const NCRYPT_READER_ICON_PROPERTY = "SmartCardReaderIcon";
pub const NCRYPT_KDF_SECRET_VALUE = "KDFKeySecret";
pub const NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY = "SmartCardDismissUITimeoutSeconds";
pub const NCRYPT_PCP_PLATFORM_TYPE_PROPERTY = "PCP_PLATFORM_TYPE";
pub const NCRYPT_PCP_PROVIDER_VERSION_PROPERTY = "PCP_PROVIDER_VERSION";
pub const NCRYPT_PCP_EKPUB_PROPERTY = "PCP_EKPUB";
pub const NCRYPT_PCP_EKCERT_PROPERTY = "PCP_EKCERT";
pub const NCRYPT_PCP_EKNVCERT_PROPERTY = "PCP_EKNVCERT";
pub const NCRYPT_PCP_RSA_EKPUB_PROPERTY = "PCP_RSA_EKPUB";
pub const NCRYPT_PCP_RSA_EKCERT_PROPERTY = "PCP_RSA_EKCERT";
pub const NCRYPT_PCP_RSA_EKNVCERT_PROPERTY = "PCP_RSA_EKNVCERT";
pub const NCRYPT_PCP_ECC_EKPUB_PROPERTY = "PCP_ECC_EKPUB";
pub const NCRYPT_PCP_ECC_EKCERT_PROPERTY = "PCP_ECC_EKCERT";
pub const NCRYPT_PCP_ECC_EKNVCERT_PROPERTY = "PCP_ECC_EKNVCERT";
pub const NCRYPT_PCP_SRKPUB_PROPERTY = "PCP_SRKPUB";
pub const NCRYPT_PCP_PCRTABLE_PROPERTY = "PCP_PCRTABLE";
pub const NCRYPT_PCP_CHANGEPASSWORD_PROPERTY = "PCP_CHANGEPASSWORD";
pub const NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY = "PCP_PASSWORD_REQUIRED";
pub const NCRYPT_PCP_USAGEAUTH_PROPERTY = "PCP_USAGEAUTH";
pub const NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY = "PCP_MIGRATIONPASSWORD";
pub const NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY = "PCP_EXPORT_ALLOWED";
pub const NCRYPT_PCP_STORAGEPARENT_PROPERTY = "PCP_STORAGEPARENT";
pub const NCRYPT_PCP_PROVIDERHANDLE_PROPERTY = "PCP_PROVIDERMHANDLE";
pub const NCRYPT_PCP_PLATFORMHANDLE_PROPERTY = "PCP_PLATFORMHANDLE";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY = "PCP_PLATFORM_BINDING_PCRMASK";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY = "PCP_PLATFORM_BINDING_PCRDIGESTLIST";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY = "PCP_PLATFORM_BINDING_PCRDIGEST";
pub const NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY = "PCP_KEY_USAGE_POLICY";
pub const NCRYPT_PCP_RSA_SCHEME_PROPERTY = "PCP_RSA_SCHEME";
pub const NCRYPT_PCP_TPM12_IDBINDING_PROPERTY = "PCP_TPM12_IDBINDING";
pub const NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY = "PCP_TPM12_IDBINDING_DYNAMIC";
pub const NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY = "PCP_TPM12_IDACTIVATION";
pub const NCRYPT_PCP_KEYATTESTATION_PROPERTY = "PCP_TPM12_KEYATTESTATION";
pub const NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = "PCP_ALTERNATE_KEY_STORAGE_LOCATION";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY = "PCP_PLATFORM_BINDING_PCRALGID";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYREF = "PCP_HMAC_AUTH_POLICYREF";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYINFO = "PCP_HMAC_AUTH_POLICYINFO";
pub const NCRYPT_PCP_HMAC_AUTH_NONCE = "PCP_HMAC_AUTH_NONCE";
pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE = "PCP_HMAC_AUTH_SIGNATURE";
pub const NCRYPT_PCP_HMAC_AUTH_TICKET = "PCP_HMAC_AUTH_TICKET";
pub const NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY = "PCP_NO_DA_PROTECTION";
pub const NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY = "PCP_TPM_MANUFACTURER_ID";
pub const NCRYPT_PCP_TPM_FW_VERSION_PROPERTY = "PCP_TPM_FW_VERSION";
pub const NCRYPT_PCP_TPM2BNAME_PROPERTY = "PCP_TPM2BNAME";
pub const NCRYPT_PCP_TPM_VERSION_PROPERTY = "PCP_TPM_VERSION";
pub const NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY = "PCP_RAW_POLICYDIGEST";
pub const NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY = "PCP_KEY_CREATIONHASH";
pub const NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY = "PCP_KEY_CREATIONTICKET";
pub const NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY = "PCP_RSA_SCHEME_HASH_ALG";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY = "PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY = "PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY";
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = @as(u32, 0);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = @as(u32, 1);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = @as(u32, 2);
pub const NCRYPT_PCP_SESSIONID_PROPERTY = "PCP_SESSIONID";
pub const NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY = "PSS Salt Size";
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = @as(u32, 0);
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = @as(u32, 1);
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = @as(u32, 2);
pub const NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY = "PCP_INTERMEDIATE_CA_EKCERT";
pub const NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY = "PCP_PCRTABLE_ALGORITHM";
pub const NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY = "PCP_SYMMETRIC_KEYBITS";
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = @as(u32, 32);
pub const NCRYPT_TPM12_PROVIDER = @as(u32, 65536);
pub const NCRYPT_PCP_SIGNATURE_KEY = @as(u32, 1);
pub const NCRYPT_PCP_ENCRYPTION_KEY = @as(u32, 2);
pub const NCRYPT_PCP_STORAGE_KEY = @as(u32, 4);
pub const NCRYPT_PCP_IDENTITY_KEY = @as(u32, 8);
pub const NCRYPT_PCP_HMACVERIFICATION_KEY = @as(u32, 16);
pub const NCRYPT_SCARD_NGC_KEY_NAME = "SmartCardNgcKeyName";
pub const NCRYPT_INITIALIZATION_VECTOR = "IV";
pub const NCRYPT_CHANGEPASSWORD_PROPERTY = "PCP_CHANGEPASSWORD";
pub const NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = "PCP_ALTERNATE_KEY_STORAGE_LOCATION";
pub const NCRYPT_KEY_ACCESS_POLICY_PROPERTY = "Key Access Policy";
pub const NCRYPT_MAX_PROPERTY_NAME = @as(u32, 64);
pub const NCRYPT_MAX_PROPERTY_DATA = @as(u32, 1048576);
pub const NCRYPT_ALLOW_EXPORT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_ARCHIVING_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_FLAG = @as(u32, 1);
pub const NCRYPT_IMPL_SOFTWARE_FLAG = @as(u32, 2);
pub const NCRYPT_IMPL_REMOVABLE_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG = @as(u32, 16);
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = @as(u32, 32);
pub const NCRYPT_ALLOW_DECRYPT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_SIGNING_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG = @as(u32, 8);
pub const NCRYPT_ALLOW_ALL_USAGES = @as(u32, 16777215);
pub const NCRYPT_UI_PROTECT_KEY_FLAG = @as(u32, 1);
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = @as(u32, 2);
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = @as(u32, 4);
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = @as(u32, 8);
pub const NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY = "PinCacheFreeApplicationTicket";
pub const NCRYPT_PIN_CACHE_FLAGS_PROPERTY = "PinCacheFlags";
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY = "PinCacheApplicationTicket";
pub const NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY = "PinCacheApplicationImage";
pub const NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY = "PinCacheApplicationStatus";
pub const NCRYPT_PIN_CACHE_PIN_PROPERTY = "PinCachePin";
pub const NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY = "PinCacheIsGestureRequired";
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = @as(u32, 90);
pub const NCRYPT_PIN_CACHE_CLEAR_PROPERTY = "PinCacheClear";
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = @as(u32, 1);
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION = @as(u32, 1);
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS = @as(u32, 1);
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC = @as(u32, 1380470851);
pub const NCRYPT_KDF_KEY_BLOB_MAGIC = @as(u32, 826688587);
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = @as(u32, 1263817296);
pub const NCRYPT_CIPHER_KEY_BLOB = "CipherKeyBlob";
pub const NCRYPT_KDF_KEY_BLOB = "KDFKeyBlob";
pub const NCRYPT_PROTECTED_KEY_BLOB = "ProtectedKeyBlob";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB = "PcpTpmProtectedKeyBlob";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = @as(u32, 1297371211);
pub const NCRYPT_PKCS7_ENVELOPE_BLOB = "PKCS7_ENVELOPE";
pub const NCRYPT_PKCS8_PRIVATE_KEY_BLOB = "PKCS8_PRIVATEKEY";
pub const NCRYPT_OPAQUETRANSPORT_BLOB = "OpaqueTransport";
pub const NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB = "ISOLATED_KEY_ENVELOPE";
pub const NCRYPT_DESCR_DELIMITER_OR = "OR";
pub const NCRYPT_DESCR_DELIMITER_AND = "AND";
pub const NCRYPT_DESCR_EQUAL = "=";
pub const MS_KEY_PROTECTION_PROVIDER = "Microsoft Key Protection Provider";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_SID = "SID";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCAL = "LOCAL";
pub const NCRYPT_KEY_PROTECTION_LOCAL_LOGON = "logon";
pub const NCRYPT_KEY_PROTECTION_LOCAL_USER = "user";
pub const NCRYPT_KEY_PROTECTION_LOCAL_MACHINE = "machine";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_SDDL = "SDDL";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_WEBCREDENTIALS = "WEBCREDENTIALS";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCKEDCREDENTIALS = "LOCKEDCREDENTIALS";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_CERTIFICATE = "CERTIFICATE";
pub const NCRYPT_KEY_PROTECTION_CERT_HASHID = "HashId";
pub const NCRYPT_KEY_PROTECTION_CERT_CERTBLOB = "CertBlob";
pub const NCRYPT_NAMED_DESCRIPTOR_FLAG = @as(u32, 1);
pub const NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING = @as(u32, 1);
pub const ALG_CLASS_ANY = @as(u32, 0);
pub const ALG_CLASS_SIGNATURE = @as(u32, 8192);
pub const ALG_CLASS_MSG_ENCRYPT = @as(u32, 16384);
pub const ALG_CLASS_DATA_ENCRYPT = @as(u32, 24576);
pub const ALG_CLASS_HASH = @as(u32, 32768);
pub const ALG_CLASS_KEY_EXCHANGE = @as(u32, 40960);
pub const ALG_CLASS_ALL = @as(u32, 57344);
pub const ALG_TYPE_ANY = @as(u32, 0);
pub const ALG_TYPE_DSS = @as(u32, 512);
pub const ALG_TYPE_RSA = @as(u32, 1024);
pub const ALG_TYPE_BLOCK = @as(u32, 1536);
pub const ALG_TYPE_STREAM = @as(u32, 2048);
pub const ALG_TYPE_DH = @as(u32, 2560);
pub const ALG_TYPE_SECURECHANNEL = @as(u32, 3072);
pub const ALG_TYPE_ECDH = @as(u32, 3584);
pub const ALG_TYPE_THIRDPARTY = @as(u32, 4096);
pub const ALG_SID_ANY = @as(u32, 0);
pub const ALG_SID_THIRDPARTY_ANY = @as(u32, 0);
pub const ALG_SID_RSA_ANY = @as(u32, 0);
pub const ALG_SID_RSA_PKCS = @as(u32, 1);
pub const ALG_SID_RSA_MSATWORK = @as(u32, 2);
pub const ALG_SID_RSA_ENTRUST = @as(u32, 3);
pub const ALG_SID_RSA_PGP = @as(u32, 4);
pub const ALG_SID_DSS_ANY = @as(u32, 0);
pub const ALG_SID_DSS_PKCS = @as(u32, 1);
pub const ALG_SID_DSS_DMS = @as(u32, 2);
pub const ALG_SID_ECDSA = @as(u32, 3);
pub const ALG_SID_DES = @as(u32, 1);
pub const ALG_SID_3DES = @as(u32, 3);
pub const ALG_SID_DESX = @as(u32, 4);
pub const ALG_SID_IDEA = @as(u32, 5);
pub const ALG_SID_CAST = @as(u32, 6);
pub const ALG_SID_SAFERSK64 = @as(u32, 7);
pub const ALG_SID_SAFERSK128 = @as(u32, 8);
pub const ALG_SID_3DES_112 = @as(u32, 9);
pub const ALG_SID_CYLINK_MEK = @as(u32, 12);
pub const ALG_SID_RC5 = @as(u32, 13);
pub const ALG_SID_AES_128 = @as(u32, 14);
pub const ALG_SID_AES_192 = @as(u32, 15);
pub const ALG_SID_AES_256 = @as(u32, 16);
pub const ALG_SID_AES = @as(u32, 17);
pub const ALG_SID_SKIPJACK = @as(u32, 10);
pub const ALG_SID_TEK = @as(u32, 11);
pub const CRYPT_MODE_CBCI = @as(u32, 6);
pub const CRYPT_MODE_CFBP = @as(u32, 7);
pub const CRYPT_MODE_OFBP = @as(u32, 8);
pub const CRYPT_MODE_CBCOFM = @as(u32, 9);
pub const CRYPT_MODE_CBCOFMI = @as(u32, 10);
pub const ALG_SID_RC2 = @as(u32, 2);
pub const ALG_SID_RC4 = @as(u32, 1);
pub const ALG_SID_SEAL = @as(u32, 2);
pub const ALG_SID_DH_SANDF = @as(u32, 1);
pub const ALG_SID_DH_EPHEM = @as(u32, 2);
pub const ALG_SID_AGREED_KEY_ANY = @as(u32, 3);
pub const ALG_SID_KEA = @as(u32, 4);
pub const ALG_SID_ECDH = @as(u32, 5);
pub const ALG_SID_ECDH_EPHEM = @as(u32, 6);
pub const ALG_SID_MD2 = @as(u32, 1);
pub const ALG_SID_MD4 = @as(u32, 2);
pub const ALG_SID_MD5 = @as(u32, 3);
pub const ALG_SID_SHA = @as(u32, 4);
pub const ALG_SID_SHA1 = @as(u32, 4);
pub const ALG_SID_MAC = @as(u32, 5);
pub const ALG_SID_RIPEMD = @as(u32, 6);
pub const ALG_SID_RIPEMD160 = @as(u32, 7);
pub const ALG_SID_SSL3SHAMD5 = @as(u32, 8);
pub const ALG_SID_HMAC = @as(u32, 9);
pub const ALG_SID_TLS1PRF = @as(u32, 10);
pub const ALG_SID_HASH_REPLACE_OWF = @as(u32, 11);
pub const ALG_SID_SHA_256 = @as(u32, 12);
pub const ALG_SID_SHA_384 = @as(u32, 13);
pub const ALG_SID_SHA_512 = @as(u32, 14);
pub const ALG_SID_SSL3_MASTER = @as(u32, 1);
pub const ALG_SID_SCHANNEL_MASTER_HASH = @as(u32, 2);
pub const ALG_SID_SCHANNEL_MAC_KEY = @as(u32, 3);
pub const ALG_SID_PCT1_MASTER = @as(u32, 4);
pub const ALG_SID_SSL2_MASTER = @as(u32, 5);
pub const ALG_SID_TLS1_MASTER = @as(u32, 6);
pub const ALG_SID_SCHANNEL_ENC_KEY = @as(u32, 7);
pub const ALG_SID_ECMQV = @as(u32, 1);
pub const ALG_SID_EXAMPLE = @as(u32, 80);
pub const SIGNATURE_RESOURCE_NUMBER = @as(u32, 666);
pub const CRYPT_VERIFYCONTEXT = @as(u32, 4026531840);
pub const CRYPT_NEWKEYSET = @as(u32, 8);
pub const CRYPT_DELETEKEYSET = @as(u32, 16);
pub const CRYPT_SILENT = @as(u32, 64);
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL = @as(u32, 128);
pub const CRYPT_UPDATE_KEY = @as(u32, 8);
pub const CRYPT_USER_PROTECTED_STRONG = @as(u32, 1048576);
pub const RSA1024BIT_KEY = @as(u32, 67108864);
pub const CRYPT_SERVER = @as(u32, 1024);
pub const KEY_LENGTH_MASK = @as(u32, 4294901760);
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = @as(u32, 32);
pub const CRYPT_SECRETDIGEST = @as(u32, 1);
pub const CRYPT_OWF_REPL_LM_HASH = @as(u32, 1);
pub const CRYPT_LITTLE_ENDIAN = @as(u32, 1);
pub const CRYPT_NOHASHOID = @as(u32, 1);
pub const CRYPT_TYPE2_FORMAT = @as(u32, 2);
pub const CRYPT_X931_FORMAT = @as(u32, 4);
pub const CRYPT_MACHINE_DEFAULT = @as(u32, 1);
pub const CRYPT_USER_DEFAULT = @as(u32, 2);
pub const CRYPT_DELETE_DEFAULT = @as(u32, 4);
pub const SIMPLEBLOB = @as(u32, 1);
pub const PUBLICKEYBLOB = @as(u32, 6);
pub const PRIVATEKEYBLOB = @as(u32, 7);
pub const PLAINTEXTKEYBLOB = @as(u32, 8);
pub const OPAQUEKEYBLOB = @as(u32, 9);
pub const PUBLICKEYBLOBEX = @as(u32, 10);
pub const SYMMETRICWRAPKEYBLOB = @as(u32, 11);
pub const KEYSTATEBLOB = @as(u32, 12);
pub const CRYPT_USERDATA = @as(u32, 1);
pub const KP_IV = @as(u32, 1);
pub const KP_PADDING = @as(u32, 3);
pub const KP_MODE = @as(u32, 4);
pub const KP_MODE_BITS = @as(u32, 5);
pub const KP_P = @as(u32, 11);
pub const KP_G = @as(u32, 12);
pub const KP_Q = @as(u32, 13);
pub const KP_X = @as(u32, 14);
pub const KP_Y = @as(u32, 15);
pub const KP_RA = @as(u32, 16);
pub const KP_RB = @as(u32, 17);
pub const KP_INFO = @as(u32, 18);
pub const KP_EFFECTIVE_KEYLEN = @as(u32, 19);
pub const KP_SCHANNEL_ALG = @as(u32, 20);
pub const KP_CLIENT_RANDOM = @as(u32, 21);
pub const KP_SERVER_RANDOM = @as(u32, 22);
pub const KP_RP = @as(u32, 23);
pub const KP_PRECOMP_MD5 = @as(u32, 24);
pub const KP_PRECOMP_SHA = @as(u32, 25);
pub const KP_CLEAR_KEY = @as(u32, 27);
pub const KP_PUB_EX_LEN = @as(u32, 28);
pub const KP_PUB_EX_VAL = @as(u32, 29);
pub const KP_KEYVAL = @as(u32, 30);
pub const KP_ADMIN_PIN = @as(u32, 31);
pub const KP_KEYEXCHANGE_PIN = @as(u32, 32);
pub const KP_SIGNATURE_PIN = @as(u32, 33);
pub const KP_PREHASH = @as(u32, 34);
pub const KP_ROUNDS = @as(u32, 35);
pub const KP_OAEP_PARAMS = @as(u32, 36);
pub const KP_CMS_KEY_INFO = @as(u32, 37);
pub const KP_CMS_DH_KEY_INFO = @as(u32, 38);
pub const KP_PUB_PARAMS = @as(u32, 39);
pub const KP_VERIFY_PARAMS = @as(u32, 40);
pub const KP_HIGHEST_VERSION = @as(u32, 41);
pub const KP_PIN_ID = @as(u32, 43);
pub const KP_PIN_INFO = @as(u32, 44);
pub const PKCS5_PADDING = @as(u32, 1);
pub const RANDOM_PADDING = @as(u32, 2);
pub const ZERO_PADDING = @as(u32, 3);
pub const CRYPT_MODE_CBC = @as(u32, 1);
pub const CRYPT_MODE_ECB = @as(u32, 2);
pub const CRYPT_MODE_OFB = @as(u32, 3);
pub const CRYPT_MODE_CFB = @as(u32, 4);
pub const CRYPT_MODE_CTS = @as(u32, 5);
pub const CRYPT_ENCRYPT = @as(u32, 1);
pub const CRYPT_DECRYPT = @as(u32, 2);
pub const CRYPT_EXPORT = @as(u32, 4);
pub const CRYPT_READ = @as(u32, 8);
pub const CRYPT_WRITE = @as(u32, 16);
pub const CRYPT_MAC = @as(u32, 32);
pub const CRYPT_EXPORT_KEY = @as(u32, 64);
pub const CRYPT_IMPORT_KEY = @as(u32, 128);
pub const CRYPT_ARCHIVE = @as(u32, 256);
pub const HP_ALGID = @as(u32, 1);
pub const HP_HASHSIZE = @as(u32, 4);
pub const HP_TLS1PRF_LABEL = @as(u32, 6);
pub const HP_TLS1PRF_SEED = @as(u32, 7);
pub const CRYPT_FAILED = @as(u32, 0);
pub const CRYPT_SUCCEED = @as(u32, 1);
pub const PP_ENUMALGS = @as(u32, 1);
pub const PP_ENUMCONTAINERS = @as(u32, 2);
pub const PP_IMPTYPE = @as(u32, 3);
pub const PP_NAME = @as(u32, 4);
pub const PP_VERSION = @as(u32, 5);
pub const PP_CONTAINER = @as(u32, 6);
pub const PP_CHANGE_PASSWORD = @as(u32, 7);
pub const PP_CERTCHAIN = @as(u32, 9);
pub const PP_KEY_TYPE_SUBTYPE = @as(u32, 10);
pub const PP_PROVTYPE = @as(u32, 16);
pub const PP_KEYSTORAGE = @as(u32, 17);
pub const PP_APPLI_CERT = @as(u32, 18);
pub const PP_SYM_KEYSIZE = @as(u32, 19);
pub const PP_SESSION_KEYSIZE = @as(u32, 20);
pub const PP_ENUMALGS_EX = @as(u32, 22);
pub const PP_ENUMMANDROOTS = @as(u32, 25);
pub const PP_ENUMELECTROOTS = @as(u32, 26);
pub const PP_KEYSET_TYPE = @as(u32, 27);
pub const PP_ADMIN_PIN = @as(u32, 31);
pub const PP_SIG_KEYSIZE_INC = @as(u32, 34);
pub const PP_KEYX_KEYSIZE_INC = @as(u32, 35);
pub const PP_UNIQUE_CONTAINER = @as(u32, 36);
pub const PP_SGC_INFO = @as(u32, 37);
pub const PP_KEYSPEC = @as(u32, 39);
pub const PP_ENUMEX_SIGNING_PROT = @as(u32, 40);
pub const PP_CRYPT_COUNT_KEY_USE = @as(u32, 41);
pub const PP_SMARTCARD_GUID = @as(u32, 45);
pub const PP_SMARTCARD_READER_ICON = @as(u32, 47);
pub const CRYPT_FIRST = @as(u32, 1);
pub const CRYPT_NEXT = @as(u32, 2);
pub const CRYPT_SGC_ENUM = @as(u32, 4);
pub const CRYPT_IMPL_HARDWARE = @as(u32, 1);
pub const CRYPT_IMPL_SOFTWARE = @as(u32, 2);
pub const CRYPT_IMPL_MIXED = @as(u32, 3);
pub const CRYPT_IMPL_UNKNOWN = @as(u32, 4);
pub const CRYPT_IMPL_REMOVABLE = @as(u32, 8);
pub const CRYPT_SEC_DESCR = @as(u32, 1);
pub const CRYPT_PSTORE = @as(u32, 2);
pub const CRYPT_UI_PROMPT = @as(u32, 4);
pub const CRYPT_FLAG_PCT1 = @as(u32, 1);
pub const CRYPT_FLAG_SSL2 = @as(u32, 2);
pub const CRYPT_FLAG_SSL3 = @as(u32, 4);
pub const CRYPT_FLAG_TLS1 = @as(u32, 8);
pub const CRYPT_FLAG_IPSEC = @as(u32, 16);
pub const CRYPT_FLAG_SIGNING = @as(u32, 32);
pub const CRYPT_SGC = @as(u32, 1);
pub const CRYPT_FASTSGC = @as(u32, 2);
pub const PP_CONTEXT_INFO = @as(u32, 11);
pub const PP_DISMISS_PIN_UI_SEC = @as(u32, 49);
pub const PROV_RSA_FULL = @as(u32, 1);
pub const PROV_RSA_SIG = @as(u32, 2);
pub const PROV_DSS = @as(u32, 3);
pub const PROV_FORTEZZA = @as(u32, 4);
pub const PROV_MS_EXCHANGE = @as(u32, 5);
pub const PROV_SSL = @as(u32, 6);
pub const PROV_RSA_SCHANNEL = @as(u32, 12);
pub const PROV_DSS_DH = @as(u32, 13);
pub const PROV_EC_ECDSA_SIG = @as(u32, 14);
pub const PROV_EC_ECNRA_SIG = @as(u32, 15);
pub const PROV_EC_ECDSA_FULL = @as(u32, 16);
pub const PROV_EC_ECNRA_FULL = @as(u32, 17);
pub const PROV_DH_SCHANNEL = @as(u32, 18);
pub const PROV_SPYRUS_LYNKS = @as(u32, 20);
pub const PROV_RNG = @as(u32, 21);
pub const PROV_INTEL_SEC = @as(u32, 22);
pub const PROV_REPLACE_OWF = @as(u32, 23);
pub const PROV_RSA_AES = @as(u32, 24);
pub const PROV_STT_MER = @as(u32, 7);
pub const PROV_STT_ACQ = @as(u32, 8);
pub const PROV_STT_BRND = @as(u32, 9);
pub const PROV_STT_ROOT = @as(u32, 10);
pub const PROV_STT_ISS = @as(u32, 11);
pub const MS_DEF_PROV_A = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_DEF_PROV_W = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV_A = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV_W = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_STRONG_PROV_A = "Microsoft Strong Cryptographic Provider";
pub const MS_STRONG_PROV_W = "Microsoft Strong Cryptographic Provider";
pub const MS_STRONG_PROV = "Microsoft Strong Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV_A = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV_W = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV_A = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV_W = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_DSS_PROV_A = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_PROV_W = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_PROV = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV_A = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV_W = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV_A = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV_W = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV_A = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV_W = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_SCARD_PROV_A = "Microsoft Base Smart Card Crypto Provider";
pub const MS_SCARD_PROV_W = "Microsoft Base Smart Card Crypto Provider";
pub const MS_SCARD_PROV = "Microsoft Base Smart Card Crypto Provider";
pub const MS_ENH_RSA_AES_PROV_A = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MS_ENH_RSA_AES_PROV_W = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MS_ENH_RSA_AES_PROV_XP_A = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV_XP_W = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV_XP = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MAXUIDLEN = @as(u32, 64);
pub const EXPO_OFFLOAD_REG_VALUE = "ExpoOffload";
pub const EXPO_OFFLOAD_FUNC_NAME = "OffloadModExpo";
pub const szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS = "Software\\Policies\\Microsoft\\Cryptography";
pub const szKEY_CACHE_ENABLED = "CachePrivateKeys";
pub const szKEY_CACHE_SECONDS = "PrivateKeyLifetimeSeconds";
pub const szPRIV_KEY_CACHE_MAX_ITEMS = "PrivKeyCacheMaxItems";
pub const cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT = @as(u32, 20);
pub const szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS = "PrivKeyCachePurgeIntervalSeconds";
pub const cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT = @as(u32, 86400);
pub const CUR_BLOB_VERSION = @as(u32, 2);
pub const SCHANNEL_MAC_KEY = @as(u32, 0);
pub const SCHANNEL_ENC_KEY = @as(u32, 1);
pub const INTERNATIONAL_USAGE = @as(u32, 1);
pub const szOID_RSA = "1.2.840.113549";
pub const szOID_PKCS = "1.2.840.113549.1";
pub const szOID_RSA_HASH = "1.2.840.113549.2";
pub const szOID_RSA_ENCRYPT = "1.2.840.113549.3";
pub const szOID_PKCS_1 = "1.2.840.113549.1.1";
pub const szOID_PKCS_2 = "1.2.840.113549.1.2";
pub const szOID_PKCS_3 = "1.2.840.113549.1.3";
pub const szOID_PKCS_4 = "1.2.840.113549.1.4";
pub const szOID_PKCS_5 = "1.2.840.113549.1.5";
pub const szOID_PKCS_6 = "1.2.840.113549.1.6";
pub const szOID_PKCS_7 = "1.2.840.113549.1.7";
pub const szOID_PKCS_8 = "1.2.840.113549.1.8";
pub const szOID_PKCS_9 = "1.2.840.113549.1.9";
pub const szOID_PKCS_10 = "1.2.840.113549.1.10";
pub const szOID_PKCS_12 = "1.2.840.113549.1.12";
pub const szOID_RSA_RSA = "1.2.840.113549.1.1.1";
pub const szOID_RSA_MD2RSA = "1.2.840.113549.1.1.2";
pub const szOID_RSA_MD4RSA = "1.2.840.113549.1.1.3";
pub const szOID_RSA_MD5RSA = "1.2.840.113549.1.1.4";
pub const szOID_RSA_SHA1RSA = "1.2.840.113549.1.1.5";
pub const szOID_RSA_SETOAEP_RSA = "1.2.840.113549.1.1.6";
pub const szOID_RSAES_OAEP = "1.2.840.113549.1.1.7";
pub const szOID_RSA_MGF1 = "1.2.840.113549.1.1.8";
pub const szOID_RSA_PSPECIFIED = "1.2.840.113549.1.1.9";
pub const szOID_RSA_SSA_PSS = "1.2.840.113549.1.1.10";
pub const szOID_RSA_SHA256RSA = "1.2.840.113549.1.1.11";
pub const szOID_RSA_SHA384RSA = "1.2.840.113549.1.1.12";
pub const szOID_RSA_SHA512RSA = "1.2.840.113549.1.1.13";
pub const szOID_RSA_DH = "1.2.840.113549.1.3.1";
pub const szOID_RSA_data = "1.2.840.113549.1.7.1";
pub const szOID_RSA_signedData = "1.2.840.113549.1.7.2";
pub const szOID_RSA_envelopedData = "1.2.840.113549.1.7.3";
pub const szOID_RSA_signEnvData = "1.2.840.113549.1.7.4";
pub const szOID_RSA_digestedData = "1.2.840.113549.1.7.5";
pub const szOID_RSA_hashedData = "1.2.840.113549.1.7.5";
pub const szOID_RSA_encryptedData = "1.2.840.113549.1.7.6";
pub const szOID_RSA_emailAddr = "1.2.840.113549.1.9.1";
pub const szOID_RSA_unstructName = "1.2.840.113549.1.9.2";
pub const szOID_RSA_contentType = "1.2.840.113549.1.9.3";
pub const szOID_RSA_messageDigest = "1.2.840.113549.1.9.4";
pub const szOID_RSA_signingTime = "1.2.840.113549.1.9.5";
pub const szOID_RSA_counterSign = "1.2.840.113549.1.9.6";
pub const szOID_RSA_challengePwd = "1.2.840.113549.1.9.7";
pub const szOID_RSA_unstructAddr = "1.2.840.113549.1.9.8";
pub const szOID_RSA_extCertAttrs = "1.2.840.113549.1.9.9";
pub const szOID_RSA_certExtensions = "1.2.840.113549.1.9.14";
pub const szOID_RSA_SMIMECapabilities = "1.2.840.113549.1.9.15";
pub const szOID_RSA_preferSignedData = "1.2.840.113549.1.9.15.1";
pub const szOID_TIMESTAMP_TOKEN = "1.2.840.113549.1.9.16.1.4";
pub const szOID_RFC3161_counterSign = "1.3.6.1.4.1.311.3.3.1";
pub const szOID_RSA_SMIMEalg = "1.2.840.113549.1.9.16.3";
pub const szOID_RSA_SMIMEalgESDH = "1.2.840.113549.1.9.16.3.5";
pub const szOID_RSA_SMIMEalgCMS3DESwrap = "1.2.840.113549.1.9.16.3.6";
pub const szOID_RSA_SMIMEalgCMSRC2wrap = "1.2.840.113549.1.9.16.3.7";
pub const szOID_RSA_MD2 = "1.2.840.113549.2.2";
pub const szOID_RSA_MD4 = "1.2.840.113549.2.4";
pub const szOID_RSA_MD5 = "1.2.840.113549.2.5";
pub const szOID_RSA_RC2CBC = "1.2.840.113549.3.2";
pub const szOID_RSA_RC4 = "1.2.840.113549.3.4";
pub const szOID_RSA_DES_EDE3_CBC = "1.2.840.113549.3.7";
pub const szOID_RSA_RC5_CBCPad = "1.2.840.113549.3.9";
pub const szOID_ANSI_X942 = "1.2.840.10046";
pub const szOID_ANSI_X942_DH = "1.2.840.10046.2.1";
pub const szOID_X957 = "1.2.840.10040";
pub const szOID_X957_DSA = "1.2.840.10040.4.1";
pub const szOID_X957_SHA1DSA = "1.2.840.10040.4.3";
pub const szOID_ECC_PUBLIC_KEY = "1.2.840.10045.2.1";
pub const szOID_ECC_CURVE_P256 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_P384 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_P521 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_BRAINPOOLP160R1 = "1.3.36.3.3.2.8.1.1.1";
pub const szOID_ECC_CURVE_BRAINPOOLP160T1 = "1.3.36.3.3.2.8.1.1.2";
pub const szOID_ECC_CURVE_BRAINPOOLP192R1 = "1.3.36.3.3.2.8.1.1.3";
pub const szOID_ECC_CURVE_BRAINPOOLP192T1 = "1.3.36.3.3.2.8.1.1.4";
pub const szOID_ECC_CURVE_BRAINPOOLP224R1 = "1.3.36.3.3.2.8.1.1.5";
pub const szOID_ECC_CURVE_BRAINPOOLP224T1 = "1.3.36.3.3.2.8.1.1.6";
pub const szOID_ECC_CURVE_BRAINPOOLP256R1 = "1.3.36.3.3.2.8.1.1.7";
pub const szOID_ECC_CURVE_BRAINPOOLP256T1 = "1.3.36.3.3.2.8.1.1.8";
pub const szOID_ECC_CURVE_BRAINPOOLP320R1 = "1.3.36.3.3.2.8.1.1.9";
pub const szOID_ECC_CURVE_BRAINPOOLP320T1 = "1.3.36.3.3.2.8.1.1.10";
pub const szOID_ECC_CURVE_BRAINPOOLP384R1 = "1.3.36.3.3.2.8.1.1.11";
pub const szOID_ECC_CURVE_BRAINPOOLP384T1 = "1.3.36.3.3.2.8.1.1.12";
pub const szOID_ECC_CURVE_BRAINPOOLP512R1 = "1.3.36.3.3.2.8.1.1.13";
pub const szOID_ECC_CURVE_BRAINPOOLP512T1 = "1.3.36.3.3.2.8.1.1.14";
pub const szOID_ECC_CURVE_EC192WAPI = "1.2.156.11235.1.1.2.1";
pub const szOID_CN_ECDSA_SHA256 = "1.2.156.11235.1.1.1";
pub const szOID_ECC_CURVE_NISTP192 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_NISTP224 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_NISTP256 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_NISTP384 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_NISTP521 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_SECP160K1 = "1.3.132.0.9";
pub const szOID_ECC_CURVE_SECP160R1 = "1.3.132.0.8";
pub const szOID_ECC_CURVE_SECP160R2 = "1.3.132.0.30";
pub const szOID_ECC_CURVE_SECP192K1 = "1.3.132.0.31";
pub const szOID_ECC_CURVE_SECP192R1 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_SECP224K1 = "1.3.132.0.32";
pub const szOID_ECC_CURVE_SECP224R1 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_SECP256K1 = "1.3.132.0.10";
pub const szOID_ECC_CURVE_SECP256R1 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_SECP384R1 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_SECP521R1 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_WTLS7 = "1.3.132.0.30";
pub const szOID_ECC_CURVE_WTLS9 = "2.23.43.1.4.9";
pub const szOID_ECC_CURVE_WTLS12 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_X962P192V1 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_X962P192V2 = "1.2.840.10045.3.1.2";
pub const szOID_ECC_CURVE_X962P192V3 = "1.2.840.10045.3.1.3";
pub const szOID_ECC_CURVE_X962P239V1 = "1.2.840.10045.3.1.4";
pub const szOID_ECC_CURVE_X962P239V2 = "1.2.840.10045.3.1.5";
pub const szOID_ECC_CURVE_X962P239V3 = "1.2.840.10045.3.1.6";
pub const szOID_ECC_CURVE_X962P256V1 = "1.2.840.10045.3.1.7";
pub const szOID_ECDSA_SHA1 = "1.2.840.10045.4.1";
pub const szOID_ECDSA_SPECIFIED = "1.2.840.10045.4.3";
pub const szOID_ECDSA_SHA256 = "1.2.840.10045.4.3.2";
pub const szOID_ECDSA_SHA384 = "1.2.840.10045.4.3.3";
pub const szOID_ECDSA_SHA512 = "1.2.840.10045.4.3.4";
pub const szOID_NIST_AES128_CBC = "2.16.840.1.101.3.4.1.2";
pub const szOID_NIST_AES192_CBC = "2.16.840.1.101.3.4.1.22";
pub const szOID_NIST_AES256_CBC = "2.16.840.1.101.3.4.1.42";
pub const szOID_NIST_AES128_WRAP = "2.16.840.1.101.3.4.1.5";
pub const szOID_NIST_AES192_WRAP = "2.16.840.1.101.3.4.1.25";
pub const szOID_NIST_AES256_WRAP = "2.16.840.1.101.3.4.1.45";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF = "1.3.133.16.840.63.0.2";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF = "1.3.132.1.11.1";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF = "1.3.132.1.11.2";
pub const szOID_DS = "2.5";
pub const szOID_DSALG = "2.5.8";
pub const szOID_DSALG_CRPT = "2.5.8.1";
pub const szOID_DSALG_HASH = "2.5.8.2";
pub const szOID_DSALG_SIGN = "2.5.8.3";
pub const szOID_DSALG_RSA = "2.5.8.1.1";
pub const szOID_OIW = "1.3.14";
pub const szOID_OIWSEC = "1.3.14.3.2";
pub const szOID_OIWSEC_md4RSA = "1.3.14.3.2.2";
pub const szOID_OIWSEC_md5RSA = "1.3.14.3.2.3";
pub const szOID_OIWSEC_md4RSA2 = "1.3.14.3.2.4";
pub const szOID_OIWSEC_desECB = "1.3.14.3.2.6";
pub const szOID_OIWSEC_desCBC = "1.3.14.3.2.7";
pub const szOID_OIWSEC_desOFB = "1.3.14.3.2.8";
pub const szOID_OIWSEC_desCFB = "1.3.14.3.2.9";
pub const szOID_OIWSEC_desMAC = "1.3.14.3.2.10";
pub const szOID_OIWSEC_rsaSign = "1.3.14.3.2.11";
pub const szOID_OIWSEC_dsa = "1.3.14.3.2.12";
pub const szOID_OIWSEC_shaDSA = "1.3.14.3.2.13";
pub const szOID_OIWSEC_mdc2RSA = "1.3.14.3.2.14";
pub const szOID_OIWSEC_shaRSA = "1.3.14.3.2.15";
pub const szOID_OIWSEC_dhCommMod = "1.3.14.3.2.16";
pub const szOID_OIWSEC_desEDE = "1.3.14.3.2.17";
pub const szOID_OIWSEC_sha = "1.3.14.3.2.18";
pub const szOID_OIWSEC_mdc2 = "1.3.14.3.2.19";
pub const szOID_OIWSEC_dsaComm = "1.3.14.3.2.20";
pub const szOID_OIWSEC_dsaCommSHA = "1.3.14.3.2.21";
pub const szOID_OIWSEC_rsaXchg = "1.3.14.3.2.22";
pub const szOID_OIWSEC_keyHashSeal = "1.3.14.3.2.23";
pub const szOID_OIWSEC_md2RSASign = "1.3.14.3.2.24";
pub const szOID_OIWSEC_md5RSASign = "1.3.14.3.2.25";
pub const szOID_OIWSEC_sha1 = "1.3.14.3.2.26";
pub const szOID_OIWSEC_dsaSHA1 = "1.3.14.3.2.27";
pub const szOID_OIWSEC_dsaCommSHA1 = "1.3.14.3.2.28";
pub const szOID_OIWSEC_sha1RSASign = "1.3.14.3.2.29";
pub const szOID_OIWDIR = "1.3.14.7.2";
pub const szOID_OIWDIR_CRPT = "1.3.14.7.2.1";
pub const szOID_OIWDIR_HASH = "1.3.14.7.2.2";
pub const szOID_OIWDIR_SIGN = "1.3.14.7.2.3";
pub const szOID_OIWDIR_md2 = "1.3.14.7.2.2.1";
pub const szOID_OIWDIR_md2RSA = "1.3.14.7.2.3.1";
pub const szOID_INFOSEC = "2.16.840.1.101.2.1";
pub const szOID_INFOSEC_sdnsSignature = "2.16.840.1.101.2.1.1.1";
pub const szOID_INFOSEC_mosaicSignature = "2.16.840.1.101.2.1.1.2";
pub const szOID_INFOSEC_sdnsConfidentiality = "2.16.840.1.101.2.1.1.3";
pub const szOID_INFOSEC_mosaicConfidentiality = "2.16.840.1.101.2.1.1.4";
pub const szOID_INFOSEC_sdnsIntegrity = "2.16.840.1.101.2.1.1.5";
pub const szOID_INFOSEC_mosaicIntegrity = "2.16.840.1.101.2.1.1.6";
pub const szOID_INFOSEC_sdnsTokenProtection = "2.16.840.1.101.2.1.1.7";
pub const szOID_INFOSEC_mosaicTokenProtection = "2.16.840.1.101.2.1.1.8";
pub const szOID_INFOSEC_sdnsKeyManagement = "2.16.840.1.101.2.1.1.9";
pub const szOID_INFOSEC_mosaicKeyManagement = "2.16.840.1.101.2.1.1.10";
pub const szOID_INFOSEC_sdnsKMandSig = "2.16.840.1.101.2.1.1.11";
pub const szOID_INFOSEC_mosaicKMandSig = "2.16.840.1.101.2.1.1.12";
pub const szOID_INFOSEC_SuiteASignature = "2.16.840.1.101.2.1.1.13";
pub const szOID_INFOSEC_SuiteAConfidentiality = "2.16.840.1.101.2.1.1.14";
pub const szOID_INFOSEC_SuiteAIntegrity = "2.16.840.1.101.2.1.1.15";
pub const szOID_INFOSEC_SuiteATokenProtection = "2.16.840.1.101.2.1.1.16";
pub const szOID_INFOSEC_SuiteAKeyManagement = "2.16.840.1.101.2.1.1.17";
pub const szOID_INFOSEC_SuiteAKMandSig = "2.16.840.1.101.2.1.1.18";
pub const szOID_INFOSEC_mosaicUpdatedSig = "2.16.840.1.101.2.1.1.19";
pub const szOID_INFOSEC_mosaicKMandUpdSig = "2.16.840.1.101.2.1.1.20";
pub const szOID_INFOSEC_mosaicUpdatedInteg = "2.16.840.1.101.2.1.1.21";
pub const szOID_NIST_sha256 = "2.16.840.1.101.3.4.2.1";
pub const szOID_NIST_sha384 = "2.16.840.1.101.3.4.2.2";
pub const szOID_NIST_sha512 = "2.16.840.1.101.3.4.2.3";
pub const szOID_COMMON_NAME = "2.5.4.3";
pub const szOID_SUR_NAME = "2.5.4.4";
pub const szOID_DEVICE_SERIAL_NUMBER = "2.5.4.5";
pub const szOID_COUNTRY_NAME = "2.5.4.6";
pub const szOID_LOCALITY_NAME = "2.5.4.7";
pub const szOID_STATE_OR_PROVINCE_NAME = "2.5.4.8";
pub const szOID_STREET_ADDRESS = "2.5.4.9";
pub const szOID_ORGANIZATION_NAME = "2.5.4.10";
pub const szOID_ORGANIZATIONAL_UNIT_NAME = "2.5.4.11";
pub const szOID_TITLE = "2.5.4.12";
pub const szOID_DESCRIPTION = "2.5.4.13";
pub const szOID_SEARCH_GUIDE = "2.5.4.14";
pub const szOID_BUSINESS_CATEGORY = "2.5.4.15";
pub const szOID_POSTAL_ADDRESS = "2.5.4.16";
pub const szOID_POSTAL_CODE = "2.5.4.17";
pub const szOID_POST_OFFICE_BOX = "2.5.4.18";
pub const szOID_PHYSICAL_DELIVERY_OFFICE_NAME = "2.5.4.19";
pub const szOID_TELEPHONE_NUMBER = "2.5.4.20";
pub const szOID_TELEX_NUMBER = "2.5.4.21";
pub const szOID_TELETEXT_TERMINAL_IDENTIFIER = "2.5.4.22";
pub const szOID_FACSIMILE_TELEPHONE_NUMBER = "2.5.4.23";
pub const szOID_X21_ADDRESS = "2.5.4.24";
pub const szOID_INTERNATIONAL_ISDN_NUMBER = "2.5.4.25";
pub const szOID_REGISTERED_ADDRESS = "2.5.4.26";
pub const szOID_DESTINATION_INDICATOR = "2.5.4.27";
pub const szOID_PREFERRED_DELIVERY_METHOD = "2.5.4.28";
pub const szOID_PRESENTATION_ADDRESS = "2.5.4.29";
pub const szOID_SUPPORTED_APPLICATION_CONTEXT = "2.5.4.30";
pub const szOID_MEMBER = "2.5.4.31";
pub const szOID_OWNER = "2.5.4.32";
pub const szOID_ROLE_OCCUPANT = "2.5.4.33";
pub const szOID_SEE_ALSO = "2.5.4.34";
pub const szOID_USER_PASSWORD = "2.5.4.35";
pub const szOID_USER_CERTIFICATE = "2.5.4.36";
pub const szOID_CA_CERTIFICATE = "2.5.4.37";
pub const szOID_AUTHORITY_REVOCATION_LIST = "2.5.4.38";
pub const szOID_CERTIFICATE_REVOCATION_LIST = "2.5.4.39";
pub const szOID_CROSS_CERTIFICATE_PAIR = "2.5.4.40";
pub const szOID_GIVEN_NAME = "2.5.4.42";
pub const szOID_INITIALS = "2.5.4.43";
pub const szOID_DN_QUALIFIER = "2.5.4.46";
pub const szOID_DOMAIN_COMPONENT = "0.9.2342.19200300.100.1.25";
pub const szOID_PKCS_12_FRIENDLY_NAME_ATTR = "1.2.840.113549.1.9.20";
pub const szOID_PKCS_12_LOCAL_KEY_ID = "1.2.840.113549.1.9.21";
pub const szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR = "1.3.6.1.4.1.311.17.1";
pub const szOID_LOCAL_MACHINE_KEYSET = "1.3.6.1.4.1.311.17.2";
pub const szOID_PKCS_12_EXTENDED_ATTRIBUTES = "1.3.6.1.4.1.311.17.3";
pub const szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = "1.3.6.1.4.1.311.17.4";
pub const szOID_KEYID_RDN = "1.3.6.1.4.1.311.10.7.1";
pub const szOID_EV_RDN_LOCALE = "1.3.6.1.4.1.311.60.2.1.1";
pub const szOID_EV_RDN_STATE_OR_PROVINCE = "1.3.6.1.4.1.311.60.2.1.2";
pub const szOID_EV_RDN_COUNTRY = "1.3.6.1.4.1.311.60.2.1.3";
pub const CERT_RDN_TYPE_MASK = @as(u32, 255);
pub const CERT_RDN_FLAGS_MASK = @as(u32, 4278190080);
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG = @as(u32, 2147483648);
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 536870912);
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = @as(u32, 1073741824);
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CERT_RSA_PUBLIC_KEY_OBJID = "1.2.840.113549.1.1.1";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_SIGN = "1.2.840.113549.1.1.1";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_XCHG = "1.2.840.113549.1.1.1";
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = @as(u32, 1);
pub const CERT_V1 = @as(u32, 0);
pub const CERT_V2 = @as(u32, 1);
pub const CERT_V3 = @as(u32, 2);
pub const CERT_INFO_VERSION_FLAG = @as(u32, 1);
pub const CERT_INFO_SERIAL_NUMBER_FLAG = @as(u32, 2);
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = @as(u32, 3);
pub const CERT_INFO_ISSUER_FLAG = @as(u32, 4);
pub const CERT_INFO_NOT_BEFORE_FLAG = @as(u32, 5);
pub const CERT_INFO_NOT_AFTER_FLAG = @as(u32, 6);
pub const CERT_INFO_SUBJECT_FLAG = @as(u32, 7);
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = @as(u32, 8);
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = @as(u32, 9);
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = @as(u32, 10);
pub const CERT_INFO_EXTENSION_FLAG = @as(u32, 11);
pub const CRL_V1 = @as(u32, 0);
pub const CRL_V2 = @as(u32, 1);
pub const CERT_BUNDLE_CERTIFICATE = @as(u32, 0);
pub const CERT_BUNDLE_CRL = @as(u32, 1);
pub const CERT_REQUEST_V1 = @as(u32, 0);
pub const CERT_KEYGEN_REQUEST_V1 = @as(u32, 0);
pub const CTL_V1 = @as(u32, 0);
pub const CERT_ENCODING_TYPE_MASK = @as(u32, 65535);
pub const CMSG_ENCODING_TYPE_MASK = @as(u32, 4294901760);
pub const CRYPT_ASN_ENCODING = @as(u32, 1);
pub const CRYPT_NDR_ENCODING = @as(u32, 2);
pub const X509_NDR_ENCODING = @as(u32, 2);
pub const PKCS_7_NDR_ENCODING = @as(u32, 131072);
pub const CRYPT_FORMAT_STR_MULTI_LINE = @as(u32, 1);
pub const CRYPT_FORMAT_STR_NO_HEX = @as(u32, 16);
pub const CRYPT_FORMAT_SIMPLE = @as(u32, 1);
pub const CRYPT_FORMAT_X509 = @as(u32, 2);
pub const CRYPT_FORMAT_OID = @as(u32, 4);
pub const CRYPT_FORMAT_RDN_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_RDN_CRLF = @as(u32, 512);
pub const CRYPT_FORMAT_RDN_UNQUOTE = @as(u32, 1024);
pub const CRYPT_FORMAT_RDN_REVERSE = @as(u32, 2048);
pub const CRYPT_FORMAT_COMMA = @as(u32, 4096);
pub const CRYPT_FORMAT_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_CRLF = @as(u32, 512);
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 65536);
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 262144);
pub const CRYPT_DECODE_NOCOPY_FLAG = @as(u32, 1);
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG = @as(u32, 2);
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG = @as(u32, 4);
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_DECODE_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 67108864);
pub const CRYPT_ENCODE_DECODE_NONE = @as(u32, 0);
pub const X509_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const X509_CERT_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const X509_CERT_CRL_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const X509_CERT_REQUEST_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const X509_EXTENSIONS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const X509_NAME_VALUE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const X509_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const X509_PUBLIC_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const X509_AUTHORITY_KEY_ID = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const X509_KEY_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const X509_KEY_USAGE_RESTRICTION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const X509_ALTERNATE_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const X509_BASIC_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const X509_KEY_USAGE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 14));
pub const X509_BASIC_CONSTRAINTS2 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 15));
pub const X509_CERT_POLICIES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 16));
pub const PKCS_UTC_TIME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 17));
pub const PKCS_TIME_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 18));
pub const RSA_CSP_PUBLICKEYBLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 19));
pub const X509_UNICODE_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 20));
pub const X509_KEYGEN_REQUEST_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 21));
pub const PKCS_ATTRIBUTE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 22));
pub const PKCS_CONTENT_INFO_SEQUENCE_OF_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 23));
pub const X509_UNICODE_NAME_VALUE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 24));
pub const X509_ANY_STRING = @as(i32, 6);
pub const X509_UNICODE_ANY_STRING = @as(i32, 24);
pub const X509_OCTET_STRING = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 25));
pub const X509_BITS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 26));
pub const X509_INTEGER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 27));
pub const X509_MULTI_BYTE_INTEGER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 28));
pub const X509_ENUMERATED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 29));
pub const X509_CHOICE_OF_TIME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 30));
pub const X509_AUTHORITY_KEY_ID2 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 31));
pub const X509_AUTHORITY_INFO_ACCESS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 32));
pub const X509_SUBJECT_INFO_ACCESS = @as(i32, 32);
pub const X509_CRL_REASON_CODE = @as(i32, 29);
pub const PKCS_CONTENT_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 33));
pub const X509_SEQUENCE_OF_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 34));
pub const X509_CRL_DIST_POINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 35));
pub const X509_ENHANCED_KEY_USAGE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 36));
pub const PKCS_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 37));
pub const X509_MULTI_BYTE_UINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 38));
pub const X509_DSS_PUBLICKEY = @as(i32, 38);
pub const X509_DSS_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 39));
pub const X509_DSS_SIGNATURE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 40));
pub const PKCS_RC2_CBC_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 41));
pub const PKCS_SMIME_CAPABILITIES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 42));
pub const X509_QC_STATEMENTS_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 42));
pub const PKCS_RSA_PRIVATE_KEY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 43));
pub const PKCS_PRIVATE_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 44));
pub const PKCS_ENCRYPTED_PRIVATE_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 45));
pub const X509_PKIX_POLICY_QUALIFIER_USERNOTICE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 46));
pub const X509_DH_PUBLICKEY = @as(i32, 38);
pub const X509_DH_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 47));
pub const PKCS_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 48));
pub const PKCS_SORTED_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 49));
pub const X509_ECC_SIGNATURE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 47));
pub const X942_DH_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 50));
pub const X509_BITS_WITHOUT_TRAILING_ZEROES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 51));
pub const X942_OTHER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 52));
pub const X509_CERT_PAIR = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 53));
pub const X509_ISSUING_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 54));
pub const X509_NAME_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 55));
pub const X509_POLICY_MAPPINGS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 56));
pub const X509_POLICY_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 57));
pub const X509_CROSS_CERT_DIST_POINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 58));
pub const CMC_DATA = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 59));
pub const CMC_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 60));
pub const CMC_STATUS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 61));
pub const CMC_ADD_EXTENSIONS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 62));
pub const CMC_ADD_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 63));
pub const X509_CERTIFICATE_TEMPLATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 64));
pub const OCSP_SIGNED_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 65));
pub const OCSP_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 66));
pub const OCSP_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 67));
pub const OCSP_BASIC_SIGNED_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 68));
pub const OCSP_BASIC_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 69));
pub const X509_LOGOTYPE_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 70));
pub const X509_BIOMETRIC_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 71));
pub const CNG_RSA_PUBLIC_KEY_BLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 72));
pub const X509_OBJECT_IDENTIFIER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 73));
pub const X509_ALGORITHM_IDENTIFIER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 74));
pub const PKCS_RSA_SSA_PSS_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 75));
pub const PKCS_RSAES_OAEP_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 76));
pub const ECC_CMS_SHARED_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 77));
pub const TIMESTAMP_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 78));
pub const TIMESTAMP_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 79));
pub const TIMESTAMP_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 80));
pub const X509_CERT_BUNDLE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 81));
pub const X509_ECC_PRIVATE_KEY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 82));
pub const CNG_RSA_PRIVATE_KEY_BLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 83));
pub const X509_SUBJECT_DIR_ATTRS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 84));
pub const X509_ECC_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 85));
pub const PKCS7_SIGNER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 500));
pub const CMS_SIGNER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 501));
pub const szOID_AUTHORITY_KEY_IDENTIFIER = "2.5.29.1";
pub const szOID_KEY_ATTRIBUTES = "2.5.29.2";
pub const szOID_CERT_POLICIES_95 = "2.5.29.3";
pub const szOID_KEY_USAGE_RESTRICTION = "2.5.29.4";
pub const szOID_SUBJECT_ALT_NAME = "2.5.29.7";
pub const szOID_ISSUER_ALT_NAME = "2.5.29.8";
pub const szOID_BASIC_CONSTRAINTS = "2.5.29.10";
pub const szOID_KEY_USAGE = "2.5.29.15";
pub const szOID_PRIVATEKEY_USAGE_PERIOD = "2.5.29.16";
pub const szOID_BASIC_CONSTRAINTS2 = "2.5.29.19";
pub const szOID_CERT_POLICIES = "2.5.29.32";
pub const szOID_ANY_CERT_POLICY = "2.5.29.32.0";
pub const szOID_INHIBIT_ANY_POLICY = "2.5.29.54";
pub const szOID_AUTHORITY_KEY_IDENTIFIER2 = "2.5.29.35";
pub const szOID_SUBJECT_KEY_IDENTIFIER = "2.5.29.14";
pub const szOID_SUBJECT_ALT_NAME2 = "2.5.29.17";
pub const szOID_ISSUER_ALT_NAME2 = "2.5.29.18";
pub const szOID_CRL_REASON_CODE = "2.5.29.21";
pub const szOID_REASON_CODE_HOLD = "2.5.29.23";
pub const szOID_CRL_DIST_POINTS = "2.5.29.31";
pub const szOID_ENHANCED_KEY_USAGE = "2.5.29.37";
pub const szOID_ANY_ENHANCED_KEY_USAGE = "2.5.29.37.0";
pub const szOID_CRL_NUMBER = "2.5.29.20";
pub const szOID_DELTA_CRL_INDICATOR = "2.5.29.27";
pub const szOID_ISSUING_DIST_POINT = "2.5.29.28";
pub const szOID_FRESHEST_CRL = "2.5.29.46";
pub const szOID_NAME_CONSTRAINTS = "2.5.29.30";
pub const szOID_POLICY_MAPPINGS = "2.5.29.33";
pub const szOID_LEGACY_POLICY_MAPPINGS = "2.5.29.5";
pub const szOID_POLICY_CONSTRAINTS = "2.5.29.36";
pub const szOID_RENEWAL_CERTIFICATE = "1.3.6.1.4.1.311.13.1";
pub const szOID_ENROLLMENT_NAME_VALUE_PAIR = "1.3.6.1.4.1.311.13.2.1";
pub const szOID_ENROLLMENT_CSP_PROVIDER = "1.3.6.1.4.1.311.13.2.2";
pub const szOID_OS_VERSION = "1.3.6.1.4.1.311.13.2.3";
pub const szOID_ENROLLMENT_AGENT = "1.3.6.1.4.1.311.20.2.1";
pub const szOID_PKIX = "1.3.6.1.5.5.7";
pub const szOID_PKIX_PE = "1.3.6.1.5.5.7.1";
pub const szOID_AUTHORITY_INFO_ACCESS = "1.3.6.1.5.5.7.1.1";
pub const szOID_SUBJECT_INFO_ACCESS = "1.3.6.1.5.5.7.1.11";
pub const szOID_BIOMETRIC_EXT = "1.3.6.1.5.5.7.1.2";
pub const szOID_QC_STATEMENTS_EXT = "1.3.6.1.5.5.7.1.3";
pub const szOID_LOGOTYPE_EXT = "1.3.6.1.5.5.7.1.12";
pub const szOID_TLS_FEATURES_EXT = "1.3.6.1.5.5.7.1.24";
pub const szOID_CERT_EXTENSIONS = "1.3.6.1.4.1.311.2.1.14";
pub const szOID_NEXT_UPDATE_LOCATION = "1.3.6.1.4.1.311.10.2";
pub const szOID_REMOVE_CERTIFICATE = "1.3.6.1.4.1.311.10.8.1";
pub const szOID_CROSS_CERT_DIST_POINTS = "1.3.6.1.4.1.311.10.9.1";
pub const szOID_CTL = "1.3.6.1.4.1.311.10.1";
pub const szOID_SORTED_CTL = "1.3.6.1.4.1.311.10.1.1";
pub const szOID_SERIALIZED = "1.3.6.1.4.1.311.10.3.3.1";
pub const szOID_NT_PRINCIPAL_NAME = "1.3.6.1.4.1.311.20.2.3";
pub const szOID_INTERNATIONALIZED_EMAIL_ADDRESS = "1.3.6.1.4.1.311.20.2.4";
pub const szOID_PRODUCT_UPDATE = "1.3.6.1.4.1.311.31.1";
pub const szOID_ANY_APPLICATION_POLICY = "1.3.6.1.4.1.311.10.12.1";
pub const szOID_AUTO_ENROLL_CTL_USAGE = "1.3.6.1.4.1.311.20.1";
pub const szOID_ENROLL_CERTTYPE_EXTENSION = "1.3.6.1.4.1.311.20.2";
pub const szOID_CERT_MANIFOLD = "1.3.6.1.4.1.311.20.3";
pub const szOID_CERTSRV_CA_VERSION = "1.3.6.1.4.1.311.21.1";
pub const szOID_CERTSRV_PREVIOUS_CERT_HASH = "1.3.6.1.4.1.311.21.2";
pub const szOID_CRL_VIRTUAL_BASE = "1.3.6.1.4.1.311.21.3";
pub const szOID_CRL_NEXT_PUBLISH = "1.3.6.1.4.1.311.21.4";
pub const szOID_KP_CA_EXCHANGE = "1.3.6.1.4.1.311.21.5";
pub const szOID_KP_PRIVACY_CA = "1.3.6.1.4.1.311.21.36";
pub const szOID_KP_KEY_RECOVERY_AGENT = "1.3.6.1.4.1.311.21.6";
pub const szOID_CERTIFICATE_TEMPLATE = "1.3.6.1.4.1.311.21.7";
pub const szOID_ENTERPRISE_OID_ROOT = "1.3.6.1.4.1.311.21.8";
pub const szOID_RDN_DUMMY_SIGNER = "1.3.6.1.4.1.311.21.9";
pub const szOID_APPLICATION_CERT_POLICIES = "1.3.6.1.4.1.311.21.10";
pub const szOID_APPLICATION_POLICY_MAPPINGS = "1.3.6.1.4.1.311.21.11";
pub const szOID_APPLICATION_POLICY_CONSTRAINTS = "1.3.6.1.4.1.311.21.12";
pub const szOID_ARCHIVED_KEY_ATTR = "1.3.6.1.4.1.311.21.13";
pub const szOID_CRL_SELF_CDP = "1.3.6.1.4.1.311.21.14";
pub const szOID_REQUIRE_CERT_CHAIN_POLICY = "1.3.6.1.4.1.311.21.15";
pub const szOID_ARCHIVED_KEY_CERT_HASH = "1.3.6.1.4.1.311.21.16";
pub const szOID_ISSUED_CERT_HASH = "1.3.6.1.4.1.311.21.17";
pub const szOID_DS_EMAIL_REPLICATION = "1.3.6.1.4.1.311.21.19";
pub const szOID_REQUEST_CLIENT_INFO = "1.3.6.1.4.1.311.21.20";
pub const szOID_ENCRYPTED_KEY_HASH = "1.3.6.1.4.1.311.21.21";
pub const szOID_CERTSRV_CROSSCA_VERSION = "1.3.6.1.4.1.311.21.22";
pub const szOID_NTDS_REPLICATION = "1.3.6.1.4.1.311.25.1";
pub const szOID_SUBJECT_DIR_ATTRS = "2.5.29.9";
pub const szOID_PKIX_KP = "1.3.6.1.5.5.7.3";
pub const szOID_PKIX_KP_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";
pub const szOID_PKIX_KP_CLIENT_AUTH = "1.3.6.1.5.5.7.3.2";
pub const szOID_PKIX_KP_CODE_SIGNING = "1.3.6.1.5.5.7.3.3";
pub const szOID_PKIX_KP_EMAIL_PROTECTION = "1.3.6.1.5.5.7.3.4";
pub const szOID_PKIX_KP_IPSEC_END_SYSTEM = "1.3.6.1.5.5.7.3.5";
pub const szOID_PKIX_KP_IPSEC_TUNNEL = "1.3.6.1.5.5.7.3.6";
pub const szOID_PKIX_KP_IPSEC_USER = "1.3.6.1.5.5.7.3.7";
pub const szOID_PKIX_KP_TIMESTAMP_SIGNING = "1.3.6.1.5.5.7.3.8";
pub const szOID_PKIX_KP_OCSP_SIGNING = "1.3.6.1.5.5.7.3.9";
pub const szOID_PKIX_OCSP_NOCHECK = "1.3.6.1.5.5.7.48.1.5";
pub const szOID_PKIX_OCSP_NONCE = "1.3.6.1.5.5.7.48.1.2";
pub const szOID_IPSEC_KP_IKE_INTERMEDIATE = "1.3.6.1.5.5.8.2.2";
pub const szOID_PKINIT_KP_KDC = "1.3.6.1.5.2.3.5";
pub const szOID_KP_CTL_USAGE_SIGNING = "1.3.6.1.4.1.311.10.3.1";
pub const szOID_KP_TIME_STAMP_SIGNING = "1.3.6.1.4.1.311.10.3.2";
pub const szOID_SERVER_GATED_CRYPTO = "1.3.6.1.4.1.311.10.3.3";
pub const szOID_SGC_NETSCAPE = "2.16.840.1.113730.4.1";
pub const szOID_KP_EFS = "1.3.6.1.4.1.311.10.3.4";
pub const szOID_EFS_RECOVERY = "1.3.6.1.4.1.311.10.3.4.1";
pub const szOID_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5";
pub const szOID_ATTEST_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5.1";
pub const szOID_NT5_CRYPTO = "1.3.6.1.4.1.311.10.3.6";
pub const szOID_OEM_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.7";
pub const szOID_EMBEDDED_NT_CRYPTO = "1.3.6.1.4.1.311.10.3.8";
pub const szOID_ROOT_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.9";
pub const szOID_KP_QUALIFIED_SUBORDINATION = "1.3.6.1.4.1.311.10.3.10";
pub const szOID_KP_KEY_RECOVERY = "1.3.6.1.4.1.311.10.3.11";
pub const szOID_KP_DOCUMENT_SIGNING = "1.3.6.1.4.1.311.10.3.12";
pub const szOID_KP_LIFETIME_SIGNING = "1.3.6.1.4.1.311.10.3.13";
pub const szOID_KP_MOBILE_DEVICE_SOFTWARE = "1.3.6.1.4.1.311.10.3.14";
pub const szOID_KP_SMART_DISPLAY = "1.3.6.1.4.1.311.10.3.15";
pub const szOID_KP_CSP_SIGNATURE = "1.3.6.1.4.1.311.10.3.16";
pub const szOID_KP_FLIGHT_SIGNING = "1.3.6.1.4.1.311.10.3.27";
pub const szOID_PLATFORM_MANIFEST_BINARY_ID = "1.3.6.1.4.1.311.10.3.28";
pub const szOID_DRM = "1.3.6.1.4.1.311.10.5.1";
pub const szOID_DRM_INDIVIDUALIZATION = "1.3.6.1.4.1.311.10.5.2";
pub const szOID_LICENSES = "1.3.6.1.4.1.311.10.6.1";
pub const szOID_LICENSE_SERVER = "1.3.6.1.4.1.311.10.6.2";
pub const szOID_KP_SMARTCARD_LOGON = "1.3.6.1.4.1.311.20.2.2";
pub const szOID_KP_KERNEL_MODE_CODE_SIGNING = "1.3.6.1.4.1.311.61.1.1";
pub const szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = "1.3.6.1.4.1.311.61.4.1";
pub const szOID_REVOKED_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.19";
pub const szOID_WINDOWS_KITS_SIGNER = "1.3.6.1.4.1.311.10.3.20";
pub const szOID_WINDOWS_RT_SIGNER = "1.3.6.1.4.1.311.10.3.21";
pub const szOID_PROTECTED_PROCESS_LIGHT_SIGNER = "1.3.6.1.4.1.311.10.3.22";
pub const szOID_WINDOWS_TCB_SIGNER = "1.3.6.1.4.1.311.10.3.23";
pub const szOID_PROTECTED_PROCESS_SIGNER = "1.3.6.1.4.1.311.10.3.24";
pub const szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER = "1.3.6.1.4.1.311.10.3.25";
pub const szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER = "1.3.6.1.4.1.311.10.3.26";
pub const szOID_DISALLOWED_LIST = "1.3.6.1.4.1.311.10.3.30";
pub const szOID_PIN_RULES_SIGNER = "1.3.6.1.4.1.311.10.3.31";
pub const szOID_PIN_RULES_CTL = "1.3.6.1.4.1.311.10.3.32";
pub const szOID_PIN_RULES_EXT = "1.3.6.1.4.1.311.10.3.33";
pub const szOID_PIN_RULES_DOMAIN_NAME = "1.3.6.1.4.1.311.10.3.34";
pub const szOID_PIN_RULES_LOG_END_DATE_EXT = "1.3.6.1.4.1.311.10.3.35";
pub const szOID_IUM_SIGNING = "1.3.6.1.4.1.311.10.3.37";
pub const szOID_EV_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.39";
pub const szOID_BIOMETRIC_SIGNING = "1.3.6.1.4.1.311.10.3.41";
pub const szOID_ENCLAVE_SIGNING = "1.3.6.1.4.1.311.10.3.42";
pub const szOID_SYNC_ROOT_CTL_EXT = "1.3.6.1.4.1.311.10.3.50";
pub const szOID_HPKP_DOMAIN_NAME_CTL = "1.3.6.1.4.1.311.10.3.60";
pub const szOID_HPKP_HEADER_VALUE_CTL = "1.3.6.1.4.1.311.10.3.61";
pub const szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = "1.3.6.1.4.1.311.61.5.1";
pub const szOID_WINDOWS_STORE_SIGNER = "1.3.6.1.4.1.311.76.3.1";
pub const szOID_DYNAMIC_CODE_GEN_SIGNER = "1.3.6.1.4.1.311.76.5.1";
pub const szOID_MICROSOFT_PUBLISHER_SIGNER = "1.3.6.1.4.1.311.76.8.1";
pub const szOID_YESNO_TRUST_ATTR = "1.3.6.1.4.1.311.10.4.1";
pub const szOID_SITE_PIN_RULES_INDEX_ATTR = "1.3.6.1.4.1.311.10.4.2";
pub const szOID_SITE_PIN_RULES_FLAGS_ATTR = "1.3.6.1.4.1.311.10.4.3";
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = @as(u32, 1);
pub const szOID_PKIX_POLICY_QUALIFIER_CPS = "1.3.6.1.5.5.7.2.1";
pub const szOID_PKIX_POLICY_QUALIFIER_USERNOTICE = "1.3.6.1.5.5.7.2.2";
pub const szOID_ROOT_PROGRAM_FLAGS = "1.3.6.1.4.1.311.60.1.1";
pub const CERT_ROOT_PROGRAM_FLAG_OU = @as(u32, 16);
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS = @as(u32, 8);
pub const szOID_CERT_POLICIES_95_QUALIFIER1 = "2.16.840.1.113733.1.7.1.1";
pub const szOID_RDN_TPM_MANUFACTURER = "2.23.133.2.1";
pub const szOID_RDN_TPM_MODEL = "2.23.133.2.2";
pub const szOID_RDN_TPM_VERSION = "2.23.133.2.3";
pub const szOID_RDN_TCG_PLATFORM_MANUFACTURER = "2.23.133.2.4";
pub const szOID_RDN_TCG_PLATFORM_MODEL = "2.23.133.2.5";
pub const szOID_RDN_TCG_PLATFORM_VERSION = "2.23.133.2.6";
pub const szOID_CT_CERT_SCTLIST = "1.3.6.1.4.1.11129.2.4.2";
pub const szOID_ENROLL_EK_INFO = "1.3.6.1.4.1.311.21.23";
pub const szOID_ENROLL_AIK_INFO = "1.3.6.1.4.1.311.21.39";
pub const szOID_ENROLL_ATTESTATION_STATEMENT = "1.3.6.1.4.1.311.21.24";
pub const szOID_ENROLL_KSP_NAME = "1.3.6.1.4.1.311.21.25";
pub const szOID_ENROLL_EKPUB_CHALLENGE = "1.3.6.1.4.1.311.21.26";
pub const szOID_ENROLL_CAXCHGCERT_HASH = "1.3.6.1.4.1.311.21.27";
pub const szOID_ENROLL_ATTESTATION_CHALLENGE = "1.3.6.1.4.1.311.21.28";
pub const szOID_ENROLL_ENCRYPTION_ALGORITHM = "1.3.6.1.4.1.311.21.29";
pub const szOID_KP_TPM_EK_CERTIFICATE = "2.23.133.8.1";
pub const szOID_KP_TPM_PLATFORM_CERTIFICATE = "2.23.133.8.2";
pub const szOID_KP_TPM_AIK_CERTIFICATE = "2.23.133.8.3";
pub const szOID_ENROLL_EKVERIFYKEY = "1.3.6.1.4.1.311.21.30";
pub const szOID_ENROLL_EKVERIFYCERT = "1.3.6.1.4.1.311.21.31";
pub const szOID_ENROLL_EKVERIFYCREDS = "1.3.6.1.4.1.311.21.32";
pub const szOID_ENROLL_SCEP_ERROR = "1.3.6.1.4.1.311.21.33";
pub const szOID_ENROLL_SCEP_SERVER_STATE = "1.3.6.1.4.1.311.21.34";
pub const szOID_ENROLL_SCEP_CHALLENGE_ANSWER = "1.3.6.1.4.1.311.21.35";
pub const szOID_ENROLL_SCEP_CLIENT_REQUEST = "1.3.6.1.4.1.311.21.37";
pub const szOID_ENROLL_SCEP_SERVER_MESSAGE = "1.3.6.1.4.1.311.21.38";
pub const szOID_ENROLL_SCEP_SERVER_SECRET = "1.3.6.1.4.1.311.21.40";
pub const szOID_ENROLL_KEY_AFFINITY = "1.3.6.1.4.1.311.21.41";
pub const szOID_ENROLL_SCEP_SIGNER_HASH = "1.3.6.1.4.1.311.21.42";
pub const szOID_ENROLL_EK_CA_KEYID = "1.3.6.1.4.1.311.21.43";
pub const szOID_ATTR_SUPPORTED_ALGORITHMS = "2.5.4.52";
pub const szOID_ATTR_TPM_SPECIFICATION = "2.23.133.2.16";
pub const szOID_ATTR_PLATFORM_SPECIFICATION = "2.23.133.2.17";
pub const szOID_ATTR_TPM_SECURITY_ASSERTIONS = "2.23.133.2.18";
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK = @as(u32, 1023);
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = @as(u32, 22);
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK = @as(u32, 63);
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE = @as(u32, 128);
pub const CERT_NON_REPUDIATION_KEY_USAGE = @as(u32, 64);
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE = @as(u32, 32);
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE = @as(u32, 16);
pub const CERT_KEY_AGREEMENT_KEY_USAGE = @as(u32, 8);
pub const CERT_KEY_CERT_SIGN_KEY_USAGE = @as(u32, 4);
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_ENCIPHER_ONLY_KEY_USAGE = @as(u32, 1);
pub const CERT_DECIPHER_ONLY_KEY_USAGE = @as(u32, 128);
pub const CERT_ALT_NAME_X400_ADDRESS = @as(u32, 4);
pub const CERT_ALT_NAME_EDI_PARTY_NAME = @as(u32, 6);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = @as(u32, 255);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_CA_SUBJECT_FLAG = @as(u32, 128);
pub const CERT_END_ENTITY_SUBJECT_FLAG = @as(u32, 64);
pub const szOID_PKIX_ACC_DESCR = "1.3.6.1.5.5.7.48";
pub const szOID_PKIX_OCSP = "1.3.6.1.5.5.7.48.1";
pub const szOID_PKIX_CA_ISSUERS = "1.3.6.1.5.5.7.48.2";
pub const szOID_PKIX_TIME_STAMPING = "1.3.6.1.5.5.7.48.3";
pub const szOID_PKIX_CA_REPOSITORY = "1.3.6.1.5.5.7.48.5";
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = @as(u32, 9);
pub const CRL_REASON_AA_COMPROMISE = @as(u32, 10);
pub const CRL_DIST_POINT_NO_NAME = @as(u32, 0);
pub const CRL_DIST_POINT_FULL_NAME = @as(u32, 1);
pub const CRL_DIST_POINT_ISSUER_RDN_NAME = @as(u32, 2);
pub const CRL_REASON_UNUSED_FLAG = @as(u32, 128);
pub const CRL_REASON_KEY_COMPROMISE_FLAG = @as(u32, 64);
pub const CRL_REASON_CA_COMPROMISE_FLAG = @as(u32, 32);
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG = @as(u32, 16);
pub const CRL_REASON_SUPERSEDED_FLAG = @as(u32, 8);
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG = @as(u32, 4);
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG = @as(u32, 2);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = @as(u32, 1);
pub const CRL_REASON_AA_COMPROMISE_FLAG = @as(u32, 128);
pub const CRL_DIST_POINT_ERR_INDEX_MASK = @as(u32, 127);
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = @as(i32, -2147483648);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = @as(u32, 255);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CERT_EXCLUDED_SUBTREE_BIT = @as(i32, -2147483648);
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 1);
pub const CERT_DSS_R_LEN = @as(u32, 20);
pub const CERT_DSS_S_LEN = @as(u32, 20);
pub const CRYPT_X942_COUNTER_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_RC2_40BIT_VERSION = @as(u32, 160);
pub const CRYPT_RC2_56BIT_VERSION = @as(u32, 52);
pub const CRYPT_RC2_64BIT_VERSION = @as(u32, 120);
pub const CRYPT_RC2_128BIT_VERSION = @as(u32, 58);
pub const szOID_QC_EU_COMPLIANCE = "0.4.0.1862.1.1";
pub const szOID_QC_SSCD = "0.4.0.1862.1.4";
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = @as(u32, 1);
pub const szOID_VERISIGN_PRIVATE_6_9 = "2.16.840.1.113733.1.6.9";
pub const szOID_VERISIGN_ONSITE_JURISDICTION_HASH = "2.16.840.1.113733.1.6.11";
pub const szOID_VERISIGN_BITSTRING_6_13 = "2.16.840.1.113733.1.6.13";
pub const szOID_VERISIGN_ISS_STRONG_CRYPTO = "2.16.840.1.113733.1.8.1";
pub const szOIDVerisign_MessageType = "2.16.840.1.113733.1.9.2";
pub const szOIDVerisign_PkiStatus = "2.16.840.1.113733.1.9.3";
pub const szOIDVerisign_FailInfo = "2.16.840.1.113733.1.9.4";
pub const szOIDVerisign_SenderNonce = "2.16.840.1.113733.1.9.5";
pub const szOIDVerisign_RecipientNonce = "2.16.840.1.113733.1.9.6";
pub const szOIDVerisign_TransactionID = "2.16.840.1.113733.1.9.7";
pub const szOID_NETSCAPE = "2.16.840.1.113730";
pub const szOID_NETSCAPE_CERT_EXTENSION = "2.16.840.1.113730.1";
pub const szOID_NETSCAPE_CERT_TYPE = "2.16.840.1.113730.1.1";
pub const szOID_NETSCAPE_BASE_URL = "2.16.840.1.113730.1.2";
pub const szOID_NETSCAPE_REVOCATION_URL = "2.16.840.1.113730.1.3";
pub const szOID_NETSCAPE_CA_REVOCATION_URL = "2.16.840.1.113730.1.4";
pub const szOID_NETSCAPE_CERT_RENEWAL_URL = "2.16.840.1.113730.1.7";
pub const szOID_NETSCAPE_CA_POLICY_URL = "2.16.840.1.113730.1.8";
pub const szOID_NETSCAPE_SSL_SERVER_NAME = "2.16.840.1.113730.1.12";
pub const szOID_NETSCAPE_COMMENT = "2.16.840.1.113730.1.13";
pub const szOID_NETSCAPE_DATA_TYPE = "2.16.840.1.113730.2";
pub const szOID_NETSCAPE_CERT_SEQUENCE = "2.16.840.1.113730.2.5";
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = @as(u32, 128);
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = @as(u32, 64);
pub const NETSCAPE_SMIME_CERT_TYPE = @as(u32, 32);
pub const NETSCAPE_SIGN_CERT_TYPE = @as(u32, 16);
pub const NETSCAPE_SSL_CA_CERT_TYPE = @as(u32, 4);
pub const NETSCAPE_SMIME_CA_CERT_TYPE = @as(u32, 2);
pub const NETSCAPE_SIGN_CA_CERT_TYPE = @as(u32, 1);
pub const szOID_CT_PKI_DATA = "1.3.6.1.5.5.7.12.2";
pub const szOID_CT_PKI_RESPONSE = "1.3.6.1.5.5.7.12.3";
pub const szOID_PKIX_NO_SIGNATURE = "1.3.6.1.5.5.7.6.2";
pub const szOID_CMC = "1.3.6.1.5.5.7.7";
pub const szOID_CMC_STATUS_INFO = "1.3.6.1.5.5.7.7.1";
pub const szOID_CMC_IDENTIFICATION = "1.3.6.1.5.5.7.7.2";
pub const szOID_CMC_IDENTITY_PROOF = "1.3.6.1.5.5.7.7.3";
pub const szOID_CMC_DATA_RETURN = "1.3.6.1.5.5.7.7.4";
pub const szOID_CMC_TRANSACTION_ID = "1.3.6.1.5.5.7.7.5";
pub const szOID_CMC_SENDER_NONCE = "1.3.6.1.5.5.7.7.6";
pub const szOID_CMC_RECIPIENT_NONCE = "1.3.6.1.5.5.7.7.7";
pub const szOID_CMC_ADD_EXTENSIONS = "1.3.6.1.5.5.7.7.8";
pub const szOID_CMC_ENCRYPTED_POP = "1.3.6.1.5.5.7.7.9";
pub const szOID_CMC_DECRYPTED_POP = "1.3.6.1.5.5.7.7.10";
pub const szOID_CMC_LRA_POP_WITNESS = "1.3.6.1.5.5.7.7.11";
pub const szOID_CMC_GET_CERT = "1.3.6.1.5.5.7.7.15";
pub const szOID_CMC_GET_CRL = "1.3.6.1.5.5.7.7.16";
pub const szOID_CMC_REVOKE_REQUEST = "1.3.6.1.5.5.7.7.17";
pub const szOID_CMC_REG_INFO = "1.3.6.1.5.5.7.7.18";
pub const szOID_CMC_RESPONSE_INFO = "1.3.6.1.5.5.7.7.19";
pub const szOID_CMC_QUERY_PENDING = "1.3.6.1.5.5.7.7.21";
pub const szOID_CMC_ID_POP_LINK_RANDOM = "1.3.6.1.5.5.7.7.22";
pub const szOID_CMC_ID_POP_LINK_WITNESS = "1.3.6.1.5.5.7.7.23";
pub const szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = "1.3.6.1.5.5.7.7.24";
pub const szOID_CMC_ADD_ATTRIBUTES = "1.3.6.1.4.1.311.10.10.1";
pub const CMC_TAGGED_CERT_REQUEST_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_NO_CHOICE = @as(u32, 0);
pub const CMC_OTHER_INFO_FAIL_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_PEND_CHOICE = @as(u32, 2);
pub const CMC_STATUS_SUCCESS = @as(u32, 0);
pub const CMC_STATUS_FAILED = @as(u32, 2);
pub const CMC_STATUS_PENDING = @as(u32, 3);
pub const CMC_STATUS_NO_SUPPORT = @as(u32, 4);
pub const CMC_STATUS_CONFIRM_REQUIRED = @as(u32, 5);
pub const CMC_FAIL_BAD_ALG = @as(u32, 0);
pub const CMC_FAIL_BAD_MESSAGE_CHECK = @as(u32, 1);
pub const CMC_FAIL_BAD_REQUEST = @as(u32, 2);
pub const CMC_FAIL_BAD_TIME = @as(u32, 3);
pub const CMC_FAIL_BAD_CERT_ID = @as(u32, 4);
pub const CMC_FAIL_UNSUPORTED_EXT = @as(u32, 5);
pub const CMC_FAIL_MUST_ARCHIVE_KEYS = @as(u32, 6);
pub const CMC_FAIL_BAD_IDENTITY = @as(u32, 7);
pub const CMC_FAIL_POP_REQUIRED = @as(u32, 8);
pub const CMC_FAIL_POP_FAILED = @as(u32, 9);
pub const CMC_FAIL_NO_KEY_REUSE = @as(u32, 10);
pub const CMC_FAIL_INTERNAL_CA_ERROR = @as(u32, 11);
pub const CMC_FAIL_TRY_LATER = @as(u32, 12);
pub const szOID_LOYALTY_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.1";
pub const szOID_BACKGROUND_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.2";
pub const CERT_BIOMETRIC_PICTURE_TYPE = @as(u32, 0);
pub const CERT_BIOMETRIC_SIGNATURE_TYPE = @as(u32, 1);
pub const OCSP_REQUEST_V1 = @as(u32, 0);
pub const OCSP_SUCCESSFUL_RESPONSE = @as(u32, 0);
pub const OCSP_MALFORMED_REQUEST_RESPONSE = @as(u32, 1);
pub const OCSP_INTERNAL_ERROR_RESPONSE = @as(u32, 2);
pub const OCSP_TRY_LATER_RESPONSE = @as(u32, 3);
pub const OCSP_SIG_REQUIRED_RESPONSE = @as(u32, 5);
pub const OCSP_UNAUTHORIZED_RESPONSE = @as(u32, 6);
pub const szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = "1.3.6.1.5.5.7.48.1.1";
pub const OCSP_BASIC_GOOD_CERT_STATUS = @as(u32, 0);
pub const OCSP_BASIC_REVOKED_CERT_STATUS = @as(u32, 1);
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS = @as(u32, 2);
pub const OCSP_BASIC_RESPONSE_V1 = @as(u32, 0);
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID = @as(u32, 1);
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID = @as(u32, 2);
pub const CRYPT_OID_ENCODE_OBJECT_FUNC = "CryptDllEncodeObject";
pub const CRYPT_OID_DECODE_OBJECT_FUNC = "CryptDllDecodeObject";
pub const CRYPT_OID_ENCODE_OBJECT_EX_FUNC = "CryptDllEncodeObjectEx";
pub const CRYPT_OID_DECODE_OBJECT_EX_FUNC = "CryptDllDecodeObjectEx";
pub const CRYPT_OID_CREATE_COM_OBJECT_FUNC = "CryptDllCreateCOMObject";
pub const CRYPT_OID_VERIFY_REVOCATION_FUNC = "CertDllVerifyRevocation";
pub const CRYPT_OID_VERIFY_CTL_USAGE_FUNC = "CertDllVerifyCTLUsage";
pub const CRYPT_OID_FORMAT_OBJECT_FUNC = "CryptDllFormatObject";
pub const CRYPT_OID_FIND_OID_INFO_FUNC = "CryptDllFindOIDInfo";
pub const CRYPT_OID_FIND_LOCALIZED_NAME_FUNC = "CryptDllFindLocalizedName";
pub const CRYPT_OID_REGPATH = "Software\\Microsoft\\Cryptography\\OID";
pub const CRYPT_OID_REG_ENCODING_TYPE_PREFIX = "EncodingType ";
pub const CRYPT_OID_REG_DLL_VALUE_NAME = "Dll";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME = "FuncName";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A = "FuncName";
pub const CRYPT_OID_REG_FLAGS_VALUE_NAME = "CryptFlags";
pub const CRYPT_DEFAULT_OID = "DEFAULT";
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = @as(u32, 1);
pub const CRYPT_REGISTER_FIRST_INDEX = @as(u32, 0);
pub const CRYPT_REGISTER_LAST_INDEX = @as(u32, 4294967295);
pub const CRYPT_MATCH_ANY_ENCODING_TYPE = @as(u32, 4294967295);
pub const CALG_OID_INFO_CNG_ONLY = @as(u32, 4294967295);
pub const CALG_OID_INFO_PARAMETERS = @as(u32, 4294967294);
pub const CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM = "CryptOIDInfoHashParameters";
pub const CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM = "CryptOIDInfoECCParameters";
pub const CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM = "CryptOIDInfoMgf1Parameters";
pub const CRYPT_OID_INFO_NO_SIGN_ALGORITHM = "CryptOIDInfoNoSign";
pub const CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM = "CryptOIDInfoOAEPParameters";
pub const CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM = "CryptOIDInfoECCWrapParameters";
pub const CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM = "CryptOIDInfoNoParameters";
pub const CRYPT_HASH_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = @as(u32, 2);
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID = @as(u32, 3);
pub const CRYPT_SIGN_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_RDN_ATTR_OID_GROUP_ID = @as(u32, 5);
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = @as(u32, 6);
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = @as(u32, 7);
pub const CRYPT_POLICY_OID_GROUP_ID = @as(u32, 8);
pub const CRYPT_TEMPLATE_OID_GROUP_ID = @as(u32, 9);
pub const CRYPT_KDF_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_LAST_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_FIRST_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_LAST_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = @as(u32, 1);
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = @as(u32, 2);
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = @as(u32, 4);
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = @as(u32, 536870912);
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = @as(u32, 268435456);
pub const CRYPT_OID_INFO_OID_KEY = @as(u32, 1);
pub const CRYPT_OID_INFO_NAME_KEY = @as(u32, 2);
pub const CRYPT_OID_INFO_ALGID_KEY = @as(u32, 3);
pub const CRYPT_OID_INFO_SIGN_KEY = @as(u32, 4);
pub const CRYPT_OID_INFO_CNG_ALGID_KEY = @as(u32, 5);
pub const CRYPT_OID_INFO_CNG_SIGN_KEY = @as(u32, 6);
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = @as(u32, 4294901760);
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PREFER_CNG_ALGID_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = @as(u32, 268369920);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = @as(u32, 16);
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = @as(u32, 0);
pub const CRYPT_LOCALIZED_NAME_OID = "LocalizedNames";
pub const CERT_STRONG_SIGN_ECDSA_ALGORITHM = "ECDSA";
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = @as(u32, 1);
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE = @as(u32, 2);
pub const szOID_CERT_STRONG_SIGN_OS_PREFIX = "1.3.6.1.4.1.311.72.1.";
pub const szOID_CERT_STRONG_SIGN_OS_1 = "1.3.6.1.4.1.311.72.1.1";
pub const szOID_CERT_STRONG_SIGN_OS_CURRENT = "1.3.6.1.4.1.311.72.1.1";
pub const szOID_CERT_STRONG_KEY_OS_PREFIX = "1.3.6.1.4.1.311.72.2.";
pub const szOID_CERT_STRONG_KEY_OS_1 = "1.3.6.1.4.1.311.72.2.1";
pub const szOID_CERT_STRONG_KEY_OS_CURRENT = "1.3.6.1.4.1.311.72.2.1";
pub const szOID_PKCS_7_DATA = "1.2.840.113549.1.7.1";
pub const szOID_PKCS_7_SIGNED = "1.2.840.113549.1.7.2";
pub const szOID_PKCS_7_ENVELOPED = "1.2.840.113549.1.7.3";
pub const szOID_PKCS_7_SIGNEDANDENVELOPED = "1.2.840.113549.1.7.4";
pub const szOID_PKCS_7_DIGESTED = "1.2.840.113549.1.7.5";
pub const szOID_PKCS_7_ENCRYPTED = "1.2.840.113549.1.7.6";
pub const szOID_PKCS_9_CONTENT_TYPE = "1.2.840.113549.1.9.3";
pub const szOID_PKCS_9_MESSAGE_DIGEST = "1.2.840.113549.1.9.4";
pub const CMSG_ENCRYPTED = @as(u32, 6);
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = @as(u32, 1);
pub const CMSG_KEY_TRANS_RECIPIENT = @as(u32, 1);
pub const CMSG_KEY_AGREE_RECIPIENT = @as(u32, 2);
pub const CMSG_MAIL_LIST_RECIPIENT = @as(u32, 3);
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = @as(u32, 2147483648);
pub const CMSG_RC4_NO_SALT_FLAG = @as(u32, 1073741824);
pub const CMSG_INDEFINITE_LENGTH = @as(u32, 4294967295);
pub const CMSG_BARE_CONTENT_FLAG = @as(u32, 1);
pub const CMSG_LENGTH_ONLY_FLAG = @as(u32, 2);
pub const CMSG_DETACHED_FLAG = @as(u32, 4);
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = @as(u32, 8);
pub const CMSG_CONTENTS_OCTETS_FLAG = @as(u32, 16);
pub const CMSG_MAX_LENGTH_FLAG = @as(u32, 32);
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = @as(u32, 64);
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG = @as(u32, 128);
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_TYPE_PARAM = @as(u32, 1);
pub const CMSG_CONTENT_PARAM = @as(u32, 2);
pub const CMSG_BARE_CONTENT_PARAM = @as(u32, 3);
pub const CMSG_INNER_CONTENT_TYPE_PARAM = @as(u32, 4);
pub const CMSG_SIGNER_COUNT_PARAM = @as(u32, 5);
pub const CMSG_SIGNER_INFO_PARAM = @as(u32, 6);
pub const CMSG_SIGNER_CERT_INFO_PARAM = @as(u32, 7);
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM = @as(u32, 8);
pub const CMSG_SIGNER_AUTH_ATTR_PARAM = @as(u32, 9);
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM = @as(u32, 10);
pub const CMSG_CERT_COUNT_PARAM = @as(u32, 11);
pub const CMSG_CERT_PARAM = @as(u32, 12);
pub const CMSG_CRL_COUNT_PARAM = @as(u32, 13);
pub const CMSG_CRL_PARAM = @as(u32, 14);
pub const CMSG_ENVELOPE_ALGORITHM_PARAM = @as(u32, 15);
pub const CMSG_RECIPIENT_COUNT_PARAM = @as(u32, 17);
pub const CMSG_RECIPIENT_INDEX_PARAM = @as(u32, 18);
pub const CMSG_RECIPIENT_INFO_PARAM = @as(u32, 19);
pub const CMSG_HASH_ALGORITHM_PARAM = @as(u32, 20);
pub const CMSG_HASH_DATA_PARAM = @as(u32, 21);
pub const CMSG_COMPUTED_HASH_PARAM = @as(u32, 22);
pub const CMSG_ENCRYPT_PARAM = @as(u32, 26);
pub const CMSG_ENCRYPTED_DIGEST = @as(u32, 27);
pub const CMSG_ENCODED_SIGNER = @as(u32, 28);
pub const CMSG_ENCODED_MESSAGE = @as(u32, 29);
pub const CMSG_VERSION_PARAM = @as(u32, 30);
pub const CMSG_ATTR_CERT_COUNT_PARAM = @as(u32, 31);
pub const CMSG_ATTR_CERT_PARAM = @as(u32, 32);
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM = @as(u32, 33);
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM = @as(u32, 34);
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = @as(u32, 35);
pub const CMSG_CMS_RECIPIENT_INFO_PARAM = @as(u32, 36);
pub const CMSG_UNPROTECTED_ATTR_PARAM = @as(u32, 37);
pub const CMSG_SIGNER_CERT_ID_PARAM = @as(u32, 38);
pub const CMSG_CMS_SIGNER_INFO_PARAM = @as(u32, 39);
pub const CMSG_SIGNED_DATA_V1 = @as(u32, 1);
pub const CMSG_SIGNED_DATA_V3 = @as(u32, 3);
pub const CMSG_SIGNED_DATA_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNED_DATA_CMS_VERSION = @as(u32, 3);
pub const CMSG_SIGNER_INFO_V1 = @as(u32, 1);
pub const CMSG_SIGNER_INFO_V3 = @as(u32, 3);
pub const CMSG_SIGNER_INFO_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNER_INFO_CMS_VERSION = @as(u32, 3);
pub const CMSG_HASHED_DATA_V0 = @as(u32, 0);
pub const CMSG_HASHED_DATA_V2 = @as(u32, 2);
pub const CMSG_HASHED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_HASHED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_RECIPIENT_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V3 = @as(u32, 3);
pub const CMSG_ENVELOPED_RECIPIENT_V4 = @as(u32, 4);
pub const CMSG_KEY_TRANS_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_KEY_TRANS_CMS_VERSION = @as(u32, 2);
pub const CMSG_KEY_AGREE_VERSION = @as(u32, 3);
pub const CMSG_MAIL_LIST_VERSION = @as(u32, 4);
pub const CMSG_CTRL_VERIFY_SIGNATURE = @as(u32, 1);
pub const CMSG_CTRL_DECRYPT = @as(u32, 2);
pub const CMSG_CTRL_VERIFY_HASH = @as(u32, 5);
pub const CMSG_CTRL_ADD_SIGNER = @as(u32, 6);
pub const CMSG_CTRL_DEL_SIGNER = @as(u32, 7);
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = @as(u32, 8);
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = @as(u32, 9);
pub const CMSG_CTRL_ADD_CERT = @as(u32, 10);
pub const CMSG_CTRL_DEL_CERT = @as(u32, 11);
pub const CMSG_CTRL_ADD_CRL = @as(u32, 12);
pub const CMSG_CTRL_DEL_CRL = @as(u32, 13);
pub const CMSG_CTRL_ADD_ATTR_CERT = @as(u32, 14);
pub const CMSG_CTRL_DEL_ATTR_CERT = @as(u32, 15);
pub const CMSG_CTRL_KEY_TRANS_DECRYPT = @as(u32, 16);
pub const CMSG_CTRL_KEY_AGREE_DECRYPT = @as(u32, 17);
pub const CMSG_CTRL_MAIL_LIST_DECRYPT = @as(u32, 18);
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX = @as(u32, 19);
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO = @as(u32, 20);
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = @as(u32, 21);
pub const CMSG_VERIFY_SIGNER_PUBKEY = @as(u32, 1);
pub const CMSG_VERIFY_SIGNER_CERT = @as(u32, 2);
pub const CMSG_VERIFY_SIGNER_CHAIN = @as(u32, 3);
pub const CMSG_VERIFY_SIGNER_NULL = @as(u32, 4);
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = @as(u32, 1);
pub const CMSG_OID_GEN_ENCRYPT_KEY_FUNC = "CryptMsgDllGenEncryptKey";
pub const CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllExportEncryptKey";
pub const CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllImportEncryptKey";
pub const CMSG_DEFAULT_INSTALLABLE_FUNC_OID = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllGenContentEncryptKey";
pub const CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllGenContentEncryptKey";
pub const CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGGenContentEncryptKey";
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_OID_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllExportKeyTrans";
pub const CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllExportKeyTrans";
pub const CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGExportKeyTrans";
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = @as(u32, 4);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = @as(u32, 8);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = @as(u32, 16);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 32);
pub const CMSG_OID_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllExportKeyAgree";
pub const CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllExportKeyAgree";
pub const CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGExportKeyAgree";
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_OID_EXPORT_MAIL_LIST_FUNC = "CryptMsgDllExportMailList";
pub const CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC = "CryptMsgDllExportMailList";
pub const CMSG_OID_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllImportKeyTrans";
pub const CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllImportKeyTrans";
pub const CMSG_OID_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllImportKeyAgree";
pub const CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllImportKeyAgree";
pub const CMSG_OID_IMPORT_MAIL_LIST_FUNC = "CryptMsgDllImportMailList";
pub const CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC = "CryptMsgDllImportMailList";
pub const CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGImportKeyTrans";
pub const CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGImportKeyAgree";
pub const CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGImportContentEncryptKey";
pub const CERT_KEY_PROV_HANDLE_PROP_ID = @as(u32, 1);
pub const CERT_KEY_PROV_INFO_PROP_ID = @as(u32, 2);
pub const CERT_SHA1_HASH_PROP_ID = @as(u32, 3);
pub const CERT_MD5_HASH_PROP_ID = @as(u32, 4);
pub const CERT_HASH_PROP_ID = @as(u32, 3);
pub const CERT_KEY_CONTEXT_PROP_ID = @as(u32, 5);
pub const CERT_KEY_SPEC_PROP_ID = @as(u32, 6);
pub const CERT_IE30_RESERVED_PROP_ID = @as(u32, 7);
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID = @as(u32, 8);
pub const CERT_ENHKEY_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_CTL_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID = @as(u32, 10);
pub const CERT_FRIENDLY_NAME_PROP_ID = @as(u32, 11);
pub const CERT_PVK_FILE_PROP_ID = @as(u32, 12);
pub const CERT_DESCRIPTION_PROP_ID = @as(u32, 13);
pub const CERT_ACCESS_STATE_PROP_ID = @as(u32, 14);
pub const CERT_SIGNATURE_HASH_PROP_ID = @as(u32, 15);
pub const CERT_SMART_CARD_DATA_PROP_ID = @as(u32, 16);
pub const CERT_EFS_PROP_ID = @as(u32, 17);
pub const CERT_FORTEZZA_DATA_PROP_ID = @as(u32, 18);
pub const CERT_ARCHIVED_PROP_ID = @as(u32, 19);
pub const CERT_KEY_IDENTIFIER_PROP_ID = @as(u32, 20);
pub const CERT_AUTO_ENROLL_PROP_ID = @as(u32, 21);
pub const CERT_PUBKEY_ALG_PARA_PROP_ID = @as(u32, 22);
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = @as(u32, 23);
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 24);
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 25);
pub const CERT_ENROLLMENT_PROP_ID = @as(u32, 26);
pub const CERT_DATE_STAMP_PROP_ID = @as(u32, 27);
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = @as(u32, 28);
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = @as(u32, 29);
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID = @as(u32, 30);
pub const CERT_RENEWAL_PROP_ID = @as(u32, 64);
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID = @as(u32, 65);
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID = @as(u32, 66);
pub const CERT_AIA_URL_RETRIEVED_PROP_ID = @as(u32, 67);
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 68);
pub const CERT_BACKED_UP_PROP_ID = @as(u32, 69);
pub const CERT_OCSP_RESPONSE_PROP_ID = @as(u32, 70);
pub const CERT_REQUEST_ORIGINATOR_PROP_ID = @as(u32, 71);
pub const CERT_SOURCE_LOCATION_PROP_ID = @as(u32, 72);
pub const CERT_SOURCE_URL_PROP_ID = @as(u32, 73);
pub const CERT_NEW_KEY_PROP_ID = @as(u32, 74);
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID = @as(u32, 75);
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID = @as(u32, 76);
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = @as(u32, 77);
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 78);
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 79);
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID = @as(u32, 80);
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 81);
pub const CERT_CA_DISABLE_CRL_PROP_ID = @as(u32, 82);
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = @as(u32, 83);
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = @as(u32, 84);
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 85);
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID = @as(u32, 86);
pub const CERT_CEP_PROP_ID = @as(u32, 87);
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 89);
pub const CERT_SCARD_PIN_ID_PROP_ID = @as(u32, 90);
pub const CERT_SCARD_PIN_INFO_PROP_ID = @as(u32, 91);
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 92);
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 93);
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 94);
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 95);
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 96);
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = @as(u32, 97);
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = @as(u32, 98);
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = @as(u32, 99);
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID = @as(u32, 100);
pub const CERT_SMART_CARD_READER_PROP_ID = @as(u32, 101);
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = @as(u32, 102);
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = @as(u32, 103);
pub const CERT_DISALLOWED_FILETIME_PROP_ID = @as(u32, 104);
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = @as(u32, 105);
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = @as(u32, 106);
pub const CERT_SHA256_HASH_PROP_ID = @as(u32, 107);
pub const CERT_SCEP_SERVER_CERTS_PROP_ID = @as(u32, 108);
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = @as(u32, 109);
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = @as(u32, 110);
pub const CERT_SCEP_CA_CERT_PROP_ID = @as(u32, 111);
pub const CERT_SCEP_SIGNER_CERT_PROP_ID = @as(u32, 112);
pub const CERT_SCEP_NONCE_PROP_ID = @as(u32, 113);
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = @as(u32, 114);
pub const CERT_SCEP_FLAGS_PROP_ID = @as(u32, 115);
pub const CERT_SCEP_GUID_PROP_ID = @as(u32, 116);
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = @as(u32, 117);
pub const CERT_ISOLATED_KEY_PROP_ID = @as(u32, 118);
pub const CERT_SERIAL_CHAIN_PROP_ID = @as(u32, 119);
pub const CERT_KEY_CLASSIFICATION_PROP_ID = @as(u32, 120);
pub const CERT_OCSP_MUST_STAPLE_PROP_ID = @as(u32, 121);
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = @as(u32, 122);
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = @as(u32, 123);
pub const CERT_PIN_SHA256_HASH_PROP_ID = @as(u32, 124);
pub const CERT_CLR_DELETE_KEY_PROP_ID = @as(u32, 125);
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID = @as(u32, 126);
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = @as(u32, 127);
pub const CERT_FIRST_RESERVED_PROP_ID = @as(u32, 128);
pub const CERT_LAST_RESERVED_PROP_ID = @as(u32, 32767);
pub const CERT_FIRST_USER_PROP_ID = @as(u32, 32768);
pub const CERT_LAST_USER_PROP_ID = @as(u32, 65535);
pub const szOID_CERT_PROP_ID_PREFIX = "1.3.6.1.4.1.311.10.11.";
pub const szOID_CERT_KEY_IDENTIFIER_PROP_ID = "1.3.6.1.4.1.311.10.11.20";
pub const szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.28";
pub const szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.29";
pub const szOID_CERT_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.4";
pub const szOID_CERT_SIGNATURE_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.15";
pub const szOID_DISALLOWED_HASH = "1.3.6.1.4.1.311.10.11.15";
pub const szOID_CERT_DISALLOWED_FILETIME_PROP_ID = "1.3.6.1.4.1.311.10.11.104";
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = @as(u32, 1);
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = @as(u32, 2);
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = @as(u32, 4);
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = @as(u32, 8);
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG = @as(u32, 16);
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = "1.3.6.1.4.1.311.60.3.1";
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = "1.3.6.1.4.1.311.60.3.2";
pub const szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = "1.3.6.1.4.1.311.60.3.3";
pub const CERT_STORE_PROV_MSG = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_STORE_PROV_MEMORY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_STORE_PROV_FILE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_STORE_PROV_REG = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CERT_STORE_PROV_PKCS7 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CERT_STORE_PROV_SERIALIZED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CERT_STORE_PROV_FILENAME_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const CERT_STORE_PROV_FILENAME_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const CERT_STORE_PROV_FILENAME = @as(i32, 8);
pub const CERT_STORE_PROV_SYSTEM_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const CERT_STORE_PROV_SYSTEM_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const CERT_STORE_PROV_SYSTEM = @as(i32, 10);
pub const CERT_STORE_PROV_COLLECTION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY = @as(i32, 13);
pub const CERT_STORE_PROV_PHYSICAL_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 14));
pub const CERT_STORE_PROV_PHYSICAL = @as(i32, 14);
pub const CERT_STORE_PROV_SMART_CARD_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 15));
pub const CERT_STORE_PROV_SMART_CARD = @as(i32, 15);
pub const CERT_STORE_PROV_LDAP_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 16));
pub const CERT_STORE_PROV_LDAP = @as(i32, 16);
pub const CERT_STORE_PROV_PKCS12 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 17));
pub const sz_CERT_STORE_PROV_MEMORY = "Memory";
pub const sz_CERT_STORE_PROV_FILENAME_W = "File";
pub const sz_CERT_STORE_PROV_FILENAME = "File";
pub const sz_CERT_STORE_PROV_SYSTEM_W = "System";
pub const sz_CERT_STORE_PROV_SYSTEM = "System";
pub const sz_CERT_STORE_PROV_PKCS7 = "PKCS7";
pub const sz_CERT_STORE_PROV_PKCS12 = "PKCS12";
pub const sz_CERT_STORE_PROV_SERIALIZED = "Serialized";
pub const sz_CERT_STORE_PROV_COLLECTION = "Collection";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W = "SystemRegistry";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY = "SystemRegistry";
pub const sz_CERT_STORE_PROV_PHYSICAL_W = "Physical";
pub const sz_CERT_STORE_PROV_PHYSICAL = "Physical";
pub const sz_CERT_STORE_PROV_SMART_CARD_W = "SmartCard";
pub const sz_CERT_STORE_PROV_SMART_CARD = "SmartCard";
pub const sz_CERT_STORE_PROV_LDAP_W = "Ldap";
pub const sz_CERT_STORE_PROV_LDAP = "Ldap";
pub const CERT_STORE_SIGNATURE_FLAG = @as(u32, 1);
pub const CERT_STORE_TIME_VALIDITY_FLAG = @as(u32, 2);
pub const CERT_STORE_REVOCATION_FLAG = @as(u32, 4);
pub const CERT_STORE_NO_CRL_FLAG = @as(u32, 65536);
pub const CERT_STORE_NO_ISSUER_FLAG = @as(u32, 131072);
pub const CERT_STORE_BASE_CRL_FLAG = @as(u32, 256);
pub const CERT_STORE_DELTA_CRL_FLAG = @as(u32, 512);
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG = @as(u32, 32);
pub const CERT_STORE_SHARE_STORE_FLAG = @as(u32, 64);
pub const CERT_STORE_MANIFOLD_FLAG = @as(u32, 256);
pub const CERT_SYSTEM_STORE_MASK = @as(u32, 4294901760);
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = @as(u32, 1073741824);
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG = @as(u32, 536870912);
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT = @as(u32, 16);
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID = @as(u32, 1);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = @as(u32, 2);
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = @as(u32, 4);
pub const CERT_SYSTEM_STORE_SERVICES_ID = @as(u32, 5);
pub const CERT_SYSTEM_STORE_USERS_ID = @as(u32, 6);
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = @as(u32, 7);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = @as(u32, 8);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = @as(u32, 9);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = @as(u32, 10);
pub const CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH = "Software\\Policies\\Microsoft\\SystemCertificates";
pub const CERT_EFSBLOB_VALUE_NAME = "EFSBlob";
pub const CERT_PROT_ROOT_FLAGS_VALUE_NAME = "Flags";
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = @as(u32, 1);
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = @as(u32, 2);
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = @as(u32, 4);
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = @as(u32, 16);
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = @as(u32, 32);
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST = @as(u32, 65536);
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME = "PeerUsages";
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A = "PeerUsages";
pub const CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH = "Software\\Microsoft\\SystemCertificates";
pub const CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME = "AuthenticodeFlags";
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK = @as(u32, 3);
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = @as(u32, 0);
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = @as(u32, 1);
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = @as(u32, 2);
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = @as(u32, 256);
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = @as(u32, 512);
pub const CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";
pub const CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME = "RootAutoUpdate";
pub const CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME = "DisableRootAutoUpdate";
pub const CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME = "EnableDisallowedCertAutoUpdate";
pub const CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME = "DisablePinRulesAutoUpdate";
pub const CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = "RootDirUrl";
pub const CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME = "SyncFromDirUrl";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = "RootDirUrl";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "SyncDeltaTime";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME = "Flags";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = @as(u32, 1);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = @as(u32, 2);
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = @as(u32, 4);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "LastSyncTime";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "EncodedCtl";
pub const CERT_AUTH_ROOT_CTL_FILENAME = "authroot.stl";
pub const CERT_AUTH_ROOT_CTL_FILENAME_A = "authroot.stl";
pub const CERT_AUTH_ROOT_CAB_FILENAME = "authrootstl.cab";
pub const CERT_AUTH_ROOT_SEQ_FILENAME = "authrootseq.txt";
pub const CERT_AUTH_ROOT_CERT_EXT = ".crt";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "DisallowedCertSyncDeltaTime";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "DisallowedCertLastSyncTime";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "DisallowedCertEncodedCtl";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME = "disallowedcert.stl";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME_A = "disallowedcert.stl";
pub const CERT_DISALLOWED_CERT_CAB_FILENAME = "disallowedcertstl.cab";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER = "DisallowedCert_AutoUpdate_1";
pub const CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "PinRulesSyncDeltaTime";
pub const CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "PinRulesLastSyncTime";
pub const CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "PinRulesEncodedCtl";
pub const CERT_PIN_RULES_CTL_FILENAME = "pinrules.stl";
pub const CERT_PIN_RULES_CTL_FILENAME_A = "pinrules.stl";
pub const CERT_PIN_RULES_CAB_FILENAME = "pinrulesstl.cab";
pub const CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER = "PinRules_AutoUpdate_1";
pub const CERT_REGISTRY_STORE_REMOTE_FLAG = @as(u32, 65536);
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG = @as(u32, 131072);
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = @as(u32, 2147483648);
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG = @as(u32, 16777216);
pub const CERT_REGISTRY_STORE_ROAMING_FLAG = @as(u32, 262144);
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = @as(u32, 524288);
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG = @as(u32, 1048576);
pub const CERT_IE_DIRTY_FLAGS_REGPATH = "Software\\Microsoft\\Cryptography\\IEDirtyFlags";
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_SIGN_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = @as(u32, 131072);
pub const CERT_LDAP_STORE_OPENED_FLAG = @as(u32, 262144);
pub const CERT_LDAP_STORE_UNBIND_FLAG = @as(u32, 524288);
pub const CRYPT_OID_OPEN_STORE_PROV_FUNC = "CertDllOpenStoreProv";
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = @as(u32, 32);
pub const CERT_STORE_PROV_SHARED_USER_FLAG = @as(u32, 64);
pub const CERT_STORE_PROV_CLOSE_FUNC = @as(u32, 0);
pub const CERT_STORE_PROV_READ_CERT_FUNC = @as(u32, 1);
pub const CERT_STORE_PROV_WRITE_CERT_FUNC = @as(u32, 2);
pub const CERT_STORE_PROV_DELETE_CERT_FUNC = @as(u32, 3);
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = @as(u32, 4);
pub const CERT_STORE_PROV_READ_CRL_FUNC = @as(u32, 5);
pub const CERT_STORE_PROV_WRITE_CRL_FUNC = @as(u32, 6);
pub const CERT_STORE_PROV_DELETE_CRL_FUNC = @as(u32, 7);
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = @as(u32, 8);
pub const CERT_STORE_PROV_READ_CTL_FUNC = @as(u32, 9);
pub const CERT_STORE_PROV_WRITE_CTL_FUNC = @as(u32, 10);
pub const CERT_STORE_PROV_DELETE_CTL_FUNC = @as(u32, 11);
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = @as(u32, 12);
pub const CERT_STORE_PROV_CONTROL_FUNC = @as(u32, 13);
pub const CERT_STORE_PROV_FIND_CERT_FUNC = @as(u32, 14);
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = @as(u32, 15);
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = @as(u32, 16);
pub const CERT_STORE_PROV_FIND_CRL_FUNC = @as(u32, 17);
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = @as(u32, 18);
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = @as(u32, 19);
pub const CERT_STORE_PROV_FIND_CTL_FUNC = @as(u32, 20);
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = @as(u32, 21);
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = @as(u32, 22);
pub const CERT_STORE_PROV_WRITE_ADD_FLAG = @as(u32, 1);
pub const CERT_STORE_SAVE_AS_PKCS12 = @as(u32, 3);
pub const CERT_CLOSE_STORE_FORCE_FLAG = @as(u32, 1);
pub const CERT_CLOSE_STORE_CHECK_FLAG = @as(u32, 2);
pub const CERT_COMPARE_MASK = @as(u32, 65535);
pub const CERT_COMPARE_ANY = @as(u32, 0);
pub const CERT_COMPARE_SHA1_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME = @as(u32, 2);
pub const CERT_COMPARE_ATTR = @as(u32, 3);
pub const CERT_COMPARE_MD5_HASH = @as(u32, 4);
pub const CERT_COMPARE_PROPERTY = @as(u32, 5);
pub const CERT_COMPARE_PUBLIC_KEY = @as(u32, 6);
pub const CERT_COMPARE_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME_STR_A = @as(u32, 7);
pub const CERT_COMPARE_NAME_STR_W = @as(u32, 8);
pub const CERT_COMPARE_KEY_SPEC = @as(u32, 9);
pub const CERT_COMPARE_ENHKEY_USAGE = @as(u32, 10);
pub const CERT_COMPARE_CTL_USAGE = @as(u32, 10);
pub const CERT_COMPARE_SUBJECT_CERT = @as(u32, 11);
pub const CERT_COMPARE_ISSUER_OF = @as(u32, 12);
pub const CERT_COMPARE_EXISTING = @as(u32, 13);
pub const CERT_COMPARE_SIGNATURE_HASH = @as(u32, 14);
pub const CERT_COMPARE_KEY_IDENTIFIER = @as(u32, 15);
pub const CERT_COMPARE_CERT_ID = @as(u32, 16);
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS = @as(u32, 17);
pub const CERT_COMPARE_PUBKEY_MD5_HASH = @as(u32, 18);
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS = @as(u32, 19);
pub const CERT_COMPARE_HASH_STR = @as(u32, 20);
pub const CERT_COMPARE_HAS_PRIVATE_KEY = @as(u32, 21);
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = @as(u32, 2147483648);
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = @as(u32, 1073741824);
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = @as(u32, 1);
pub const CRL_FIND_ANY = @as(u32, 0);
pub const CRL_FIND_ISSUED_BY = @as(u32, 1);
pub const CRL_FIND_EXISTING = @as(u32, 2);
pub const CRL_FIND_ISSUED_FOR = @as(u32, 3);
pub const CRL_FIND_ISSUED_BY_AKI_FLAG = @as(u32, 1);
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = @as(u32, 2);
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG = @as(u32, 4);
pub const CRL_FIND_ISSUED_BY_BASE_FLAG = @as(u32, 8);
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = @as(u32, 16);
pub const CERT_STORE_ADD_NEW = @as(u32, 1);
pub const CERT_STORE_ADD_USE_EXISTING = @as(u32, 2);
pub const CERT_STORE_ADD_REPLACE_EXISTING = @as(u32, 3);
pub const CERT_STORE_ADD_ALWAYS = @as(u32, 4);
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = @as(u32, 5);
pub const CERT_STORE_ADD_NEWER = @as(u32, 6);
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = @as(u32, 7);
pub const CERT_STORE_CERTIFICATE_CONTEXT = @as(u32, 1);
pub const CERT_STORE_CRL_CONTEXT = @as(u32, 2);
pub const CERT_STORE_CTL_CONTEXT = @as(u32, 3);
pub const CTL_ANY_SUBJECT_TYPE = @as(u32, 1);
pub const CTL_CERT_SUBJECT_TYPE = @as(u32, 2);
pub const CTL_FIND_NO_LIST_ID_CBDATA = @as(u32, 4294967295);
pub const CERT_STORE_CTRL_RESYNC = @as(u32, 1);
pub const CERT_STORE_CTRL_NOTIFY_CHANGE = @as(u32, 2);
pub const CERT_STORE_CTRL_COMMIT = @as(u32, 3);
pub const CERT_STORE_CTRL_AUTO_RESYNC = @as(u32, 4);
pub const CERT_STORE_CTRL_CANCEL_NOTIFY = @as(u32, 5);
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID = @as(u32, 4096);
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG = @as(u32, 1);
pub const CERT_CREATE_CONTEXT_SORTED_FLAG = @as(u32, 2);
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = @as(u32, 4);
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = @as(u32, 2);
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = @as(u32, 4);
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_DEFAULT_NAME = ".Default";
pub const CERT_PHYSICAL_STORE_GROUP_POLICY_NAME = ".GroupPolicy";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME = ".LocalMachine";
pub const CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME = ".UserCertificate";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME = ".LocalMachineGroupPolicy";
pub const CERT_PHYSICAL_STORE_ENTERPRISE_NAME = ".Enterprise";
pub const CERT_PHYSICAL_STORE_AUTH_ROOT_NAME = ".AuthRoot";
pub const CERT_PHYSICAL_STORE_SMART_CARD_NAME = ".SmartCard";
pub const CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC = "CertDllOpenSystemStoreProv";
pub const CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC = "CertDllRegisterSystemStore";
pub const CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC = "CertDllUnregisterSystemStore";
pub const CRYPT_OID_ENUM_SYSTEM_STORE_FUNC = "CertDllEnumSystemStore";
pub const CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC = "CertDllRegisterPhysicalStore";
pub const CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC = "CertDllUnregisterPhysicalStore";
pub const CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC = "CertDllEnumPhysicalStore";
pub const CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME = "SystemStoreLocation";
pub const CMSG_TRUSTED_SIGNER_FLAG = @as(u32, 1);
pub const CMSG_SIGNER_ONLY_FLAG = @as(u32, 2);
pub const CMSG_USE_SIGNER_INDEX_FLAG = @as(u32, 4);
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG = @as(u32, 32768);
pub const CMSG_ENCODE_SORTED_CTL_FLAG = @as(u32, 1);
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 2);
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = @as(u32, 1);
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = @as(u32, 2);
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG = @as(u32, 4);
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = @as(u32, 8);
pub const CERT_VERIFY_UPDATED_CTL_FLAG = @as(u32, 1);
pub const CERT_CONTEXT_REVOCATION_TYPE = @as(u32, 1);
pub const CERT_VERIFY_REV_CHAIN_FLAG = @as(u32, 1);
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = @as(u32, 2);
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = @as(u32, 4);
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG = @as(u32, 8);
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = @as(u32, 16);
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = @as(u32, 32);
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG = @as(u32, 1);
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = @as(u32, 8);
pub const CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = "CryptDllExtractEncodedSignatureParameters";
pub const CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC = "CryptDllSignAndEncodeHash";
pub const CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC = "CryptDllVerifyEncodedSignature";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllExportPublicKeyInfoEx";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = "CryptDllExportPublicKeyInfoEx2";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = "CryptDllExportPublicKeyInfoFromBCryptKeyHandle";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllImportPublicKeyInfoEx";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = "CryptDllImportPublicKeyInfoEx2";
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = @as(u32, 128);
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = @as(u32, 458752);
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = @as(u32, 65536);
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = @as(u32, 131072);
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = @as(u32, 262144);
pub const CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllImportPrivateKeyInfoEx";
pub const CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllExportPrivateKeyInfoEx";
pub const CRYPT_DELETE_KEYSET = @as(u32, 16);
pub const CERT_XML_NAME_STR = @as(u32, 4);
pub const CERT_NAME_STR_SEMICOLON_FLAG = @as(u32, 1073741824);
pub const CERT_NAME_STR_NO_PLUS_FLAG = @as(u32, 536870912);
pub const CERT_NAME_STR_NO_QUOTING_FLAG = @as(u32, 268435456);
pub const CERT_NAME_STR_CRLF_FLAG = @as(u32, 134217728);
pub const CERT_NAME_STR_COMMA_FLAG = @as(u32, 67108864);
pub const CERT_NAME_STR_REVERSE_FLAG = @as(u32, 33554432);
pub const CERT_NAME_STR_FORWARD_FLAG = @as(u32, 16777216);
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = @as(u32, 131072);
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 262144);
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = @as(u32, 524288);
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = @as(u32, 1048576);
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = @as(u32, 2097152);
pub const CERT_NAME_EMAIL_TYPE = @as(u32, 1);
pub const CERT_NAME_RDN_TYPE = @as(u32, 2);
pub const CERT_NAME_ATTR_TYPE = @as(u32, 3);
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE = @as(u32, 4);
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE = @as(u32, 5);
pub const CERT_NAME_DNS_TYPE = @as(u32, 6);
pub const CERT_NAME_URL_TYPE = @as(u32, 7);
pub const CERT_NAME_UPN_TYPE = @as(u32, 8);
pub const CERT_NAME_ISSUER_FLAG = @as(u32, 1);
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = @as(u32, 1);
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = @as(u32, 4);
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = @as(u32, 64);
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = @as(u32, 4);
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS = @as(i32, 2);
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC = "SchemeDllRetrieveEncodedObject";
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC = "SchemeDllRetrieveEncodedObjectW";
pub const CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC = "ContextDllCreateObjectContext";
pub const CONTEXT_OID_CERTIFICATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CONTEXT_OID_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CONTEXT_OID_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CONTEXT_OID_PKCS7 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CONTEXT_OID_CAPI2_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CONTEXT_OID_OCSP_RESP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = @as(u32, 1);
pub const CRYPT_CACHE_ONLY_RETRIEVAL = @as(u32, 2);
pub const CRYPT_WIRE_ONLY_RETRIEVAL = @as(u32, 4);
pub const CRYPT_DONT_CACHE_RESULT = @as(u32, 8);
pub const CRYPT_ASYNC_RETRIEVAL = @as(u32, 16);
pub const CRYPT_STICKY_CACHE_RETRIEVAL = @as(u32, 4096);
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = @as(u32, 8192);
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL = @as(u32, 16384);
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = @as(u32, 32768);
pub const CRYPT_LDAP_SIGN_RETRIEVAL = @as(u32, 65536);
pub const CRYPT_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = @as(u32, 262144);
pub const CRYPT_AIA_RETRIEVAL = @as(u32, 524288);
pub const CRYPT_HTTP_POST_RETRIEVAL = @as(u32, 1048576);
pub const CRYPT_PROXY_CACHE_RETRIEVAL = @as(u32, 2097152);
pub const CRYPT_NOT_MODIFIED_RETRIEVAL = @as(u32, 4194304);
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = @as(u32, 8388608);
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = @as(u32, 67108864);
pub const CRYPT_ENABLE_FILE_RETRIEVAL = @as(u32, 134217728);
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY = @as(u32, 268435456);
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const CRYPT_VERIFY_DATA_HASH = @as(u32, 64);
pub const CRYPT_KEEP_TIME_VALID = @as(u32, 128);
pub const CRYPT_DONT_VERIFY_SIGNATURE = @as(u32, 256);
pub const CRYPT_DONT_CHECK_TIME_VALIDITY = @as(u32, 512);
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = @as(u32, 1024);
pub const CRYPT_ACCUMULATIVE_TIMEOUT = @as(u32, 2048);
pub const CRYPT_OCSP_ONLY_RETRIEVAL = @as(u32, 16777216);
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = @as(u32, 33554432);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = @as(u32, 2);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = @as(u32, 3);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = @as(u32, 5);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = @as(u32, 6);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = @as(u32, 7);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = @as(u32, 32768);
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = @as(u32, 4096);
pub const CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const URL_OID_GET_OBJECT_URL_FUNC = "UrlDllGetObjectUrl";
pub const URL_OID_CERTIFICATE_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const URL_OID_CTL_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const URL_OID_CTL_NEXT_UPDATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const URL_OID_CRL_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const URL_OID_CERTIFICATE_FRESHEST_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const URL_OID_CRL_FRESHEST_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const URL_OID_CROSS_CERT_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const URL_OID_CERTIFICATE_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const URL_OID_CERTIFICATE_ONLY_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const TIME_VALID_OID_GET_OBJECT_FUNC = "TimeValidDllGetObject";
pub const TIME_VALID_OID_GET_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const TIME_VALID_OID_GET_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const TIME_VALID_OID_GET_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const TIME_VALID_OID_FLUSH_OBJECT_FUNC = "TimeValidDllFlushObject";
pub const TIME_VALID_OID_FLUSH_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const TIME_VALID_OID_FLUSH_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const TIME_VALID_OID_FLUSH_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CRYPT_KEYID_MACHINE_FLAG = @as(u32, 32);
pub const CRYPT_KEYID_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_KEYID_DELETE_FLAG = @as(u32, 16);
pub const CRYPT_KEYID_SET_NEW_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_CONFIG_REGPATH = "Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config";
pub const CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = "MaxUrlRetrievalByteCount";
pub const CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME = "ChainCacheResyncFiletime";
pub const CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME = "DisableMandatoryBasicConstraints";
pub const CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME = "DisableCANameConstraints";
pub const CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME = "DisableUnsupportedCriticalExtensions";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME = "MaxAIAUrlCountInCert";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME = "MaxAIAUrlRetrievalCountPerChain";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = @as(u32, 3);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = "MaxAIAUrlRetrievalByteCount";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = @as(u32, 100000);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME = "MaxAIAUrlRetrievalCertCount";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = @as(u32, 10);
pub const CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME = "OcspValiditySeconds";
pub const CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME = "DisableSerialChain";
pub const CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME = "SerialChainLogFileName";
pub const CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME = "DisableSyncWithSslTime";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME = "MaxSslTimeUpdatedEventCount";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME = "SslHandshakeLogFileName";
pub const CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME = "EnableWeakSignatureFlags";
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = @as(u32, 1);
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = @as(u32, 2);
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = @as(u32, 4);
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = @as(u32, 8);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME = "MinRsaPubKeyBitLength";
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = @as(u32, 1023);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME = "WeakRsaPubKeyTime";
pub const CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME = "WeakSignatureLogDir";
pub const CERT_CHAIN_DEFAULT_CONFIG_SUBDIR = "Default";
pub const CERT_CHAIN_WEAK_PREFIX_NAME = "Weak";
pub const CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME = "ThirdParty";
pub const CERT_CHAIN_WEAK_ALL_CONFIG_NAME = "All";
pub const CERT_CHAIN_WEAK_FLAGS_NAME = "Flags";
pub const CERT_CHAIN_WEAK_HYGIENE_NAME = "Hygiene";
pub const CERT_CHAIN_WEAK_AFTER_TIME_NAME = "AfterTime";
pub const CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME = "FileHashAfterTime";
pub const CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME = "TimestampHashAfterTime";
pub const CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME = "MinBitLength";
pub const CERT_CHAIN_WEAK_SHA256_ALLOW_NAME = "Sha256Allow";
pub const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = @as(u32, 2147483648);
pub const CERT_CHAIN_DISABLE_ECC_PARA_FLAG = @as(u32, 16);
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = @as(u32, 65536);
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = @as(u32, 131072);
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = @as(u32, 262144);
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = @as(u32, 1048576);
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = @as(u32, 2097152);
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = @as(u32, 4194304);
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = @as(u32, 8388608);
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 16777216);
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 33554432);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = @as(u32, 134217728);
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = @as(u32, 268435456);
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = @as(u32, 536870912);
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = @as(u32, 1073741824);
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 16384);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_FLAGS = @as(u32, 262144);
pub const CERT_CHAIN_AUTO_CURRENT_USER = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE = @as(u32, 2);
pub const CERT_CHAIN_AUTO_IMPERSONATED = @as(u32, 3);
pub const CERT_CHAIN_AUTO_PROCESS_INFO = @as(u32, 4);
pub const CERT_CHAIN_AUTO_PINRULE_INFO = @as(u32, 5);
pub const CERT_CHAIN_AUTO_NETWORK_INFO = @as(u32, 6);
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = @as(u32, 7);
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLAGS_VALUE_NAME = "AutoFlags";
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = @as(u32, 2);
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG = @as(u32, 4);
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME = "AutoFlushFirstDeltaSeconds";
pub const CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME = "AutoFlushNextDeltaSeconds";
pub const CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME = "AutoLogFileName";
pub const CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME = "DisableAutoFlushProcessNameList";
pub const CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME = "SrvOcspRespMinValiditySeconds";
pub const CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "SrvOcspRespUrlRetrievalTimeoutMilliseconds";
pub const CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMaxBeforeNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMinBeforeNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMinAfterNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME = "SrvOcspRespMinSyncCertFileSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT = @as(u32, 5);
pub const CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME = "SrvOcspRespMaxSyncCertFileSeconds";
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME = "CryptnetMaxCachedOcspPerCrlCount";
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT = @as(u32, 500);
pub const CRYPTNET_OCSP_AFTER_CRL_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME = "CryptnetDefaultFlushExemptSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME = "CryptnetPreFetchMinMaxAgeSeconds";
pub const CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME = "CryptnetPreFetchMaxMaxAgeSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinOcspValidityPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchAfterPublishPreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchBeforeNextUpdatePreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 20);
pub const CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds";
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchTriggerPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME = "CryptnetPreFetchScanAfterTriggerDelaySeconds";
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT = @as(u32, 60);
pub const CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME = "CryptnetPreFetchRetrievalTimeoutSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME = "ProcessNameList";
pub const CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME = "PreFetchUrlList";
pub const CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME = "DisableInformationEvents";
pub const CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME = "LogFileName";
pub const CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME = "TimeoutSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME = "MaxAgeSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "PublishBeforeNextUpdateSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME = "PublishRandomIntervalSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "MinBeforeNextUpdateSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = "MinAfterNextUpdateSeconds";
pub const CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "ChainUrlRetrievalTimeoutMilliseconds";
pub const CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds";
pub const CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME = "EnableInetUnknownAuth";
pub const CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME = "EnableInetLocal";
pub const CERT_RETR_BEHAVIOR_FILE_VALUE_NAME = "AllowFileUrlScheme";
pub const CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME = "DisableLDAPSignAndEncrypt";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME = "CryptnetCachedOcspSwitchToCrlCount";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT = @as(u32, 50);
pub const CRYPTNET_CRL_BEFORE_OCSP_ENABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME = "DisableAIAUrlRetrieval";
pub const CERT_CHAIN_OPTIONS_VALUE_NAME = "Options";
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = @as(u32, 2);
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME = "CrossCertDownloadIntervalHours";
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME = "CRLValidityExtensionPeriod";
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = @as(u32, 12);
pub const CERT_CHAIN_CACHE_END_CERT = @as(u32, 1);
pub const CERT_CHAIN_THREAD_STORE_SYNC = @as(u32, 2);
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = @as(u32, 8);
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = @as(u32, 16);
pub const CERT_CHAIN_ENABLE_SHARE_STORE = @as(u32, 32);
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = @as(u32, 1);
pub const CERT_TRUST_NO_ERROR = @as(u32, 0);
pub const CERT_TRUST_IS_NOT_TIME_VALID = @as(u32, 1);
pub const CERT_TRUST_IS_NOT_TIME_NESTED = @as(u32, 2);
pub const CERT_TRUST_IS_REVOKED = @as(u32, 4);
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID = @as(u32, 8);
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = @as(u32, 16);
pub const CERT_TRUST_IS_UNTRUSTED_ROOT = @as(u32, 32);
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = @as(u32, 64);
pub const CERT_TRUST_IS_CYCLIC = @as(u32, 128);
pub const CERT_TRUST_INVALID_EXTENSION = @as(u32, 256);
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = @as(u32, 512);
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS = @as(u32, 2048);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = @as(u32, 4096);
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = @as(u32, 8192);
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = @as(u32, 16384);
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = @as(u32, 32768);
pub const CERT_TRUST_IS_OFFLINE_REVOCATION = @as(u32, 16777216);
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = @as(u32, 33554432);
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST = @as(u32, 67108864);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = @as(u32, 134217728);
pub const CERT_TRUST_HAS_WEAK_SIGNATURE = @as(u32, 1048576);
pub const CERT_TRUST_HAS_WEAK_HYGIENE = @as(u32, 2097152);
pub const CERT_TRUST_IS_PARTIAL_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID = @as(u32, 131072);
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = @as(u32, 262144);
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = @as(u32, 524288);
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = @as(u32, 1);
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER = @as(u32, 2);
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER = @as(u32, 4);
pub const CERT_TRUST_IS_SELF_SIGNED = @as(u32, 8);
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = @as(u32, 16);
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = @as(u32, 32);
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = @as(u32, 64);
pub const CERT_TRUST_IS_KEY_ROLLOVER = @as(u32, 128);
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP = @as(u32, 262144);
pub const CERT_TRUST_SSL_TIME_VALID_OCSP = @as(u32, 524288);
pub const CERT_TRUST_SSL_RECONNECT_OCSP = @as(u32, 1048576);
pub const CERT_TRUST_HAS_PREFERRED_ISSUER = @as(u32, 256);
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = @as(u32, 512);
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_IS_PEER_TRUSTED = @as(u32, 2048);
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = @as(u32, 4096);
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = @as(u32, 8192);
pub const CERT_TRUST_IS_CA_TRUSTED = @as(u32, 16384);
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = @as(u32, 32768);
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = @as(u32, 131072);
pub const CERT_TRUST_IS_COMPLEX_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_SSL_TIME_VALID = @as(u32, 16777216);
pub const CERT_TRUST_NO_TIME_CHECK = @as(u32, 33554432);
pub const USAGE_MATCH_TYPE_AND = @as(u32, 0);
pub const USAGE_MATCH_TYPE_OR = @as(u32, 1);
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = @as(u32, 1);
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT = @as(u32, 268435456);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN = @as(u32, 536870912);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = @as(u32, 1073741824);
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = @as(u32, 2147483648);
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = @as(u32, 134217728);
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = @as(u32, 64);
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = @as(u32, 128);
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = @as(u32, 256);
pub const CERT_CHAIN_TIMESTAMP_TIME = @as(u32, 512);
pub const CERT_CHAIN_ENABLE_PEER_TRUST = @as(u32, 1024);
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST = @as(u32, 2048);
pub const CERT_CHAIN_DISABLE_MD2_MD4 = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_AIA = @as(u32, 8192);
pub const CERT_CHAIN_HAS_MOTW = @as(u32, 16384);
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = @as(u32, 65536);
pub const REVOCATION_OID_CRL_REVOCATION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_CHAIN_FIND_BY_ISSUER = @as(u32, 1);
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = @as(u32, 134217728);
pub const CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC = "CertDllVerifyCertificateChainPolicy";
pub const CERT_CHAIN_POLICY_BASE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_CHAIN_POLICY_AUTHENTICODE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_CHAIN_POLICY_AUTHENTICODE_TS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_CHAIN_POLICY_SSL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CERT_CHAIN_POLICY_NT_AUTH = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CERT_CHAIN_POLICY_MICROSOFT_ROOT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const CERT_CHAIN_POLICY_EV = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const CERT_CHAIN_POLICY_SSL_F12 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const CERT_CHAIN_POLICY_SSL_HPKP_HEADER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const CERT_CHAIN_POLICY_THIRD_PARTY_ROOT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = @as(u32, 2147483648);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = @as(u32, 1073741824);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = @as(u32, 65536);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = @as(u32, 131072);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = @as(u32, 262144);
pub const SSL_F12_ERROR_TEXT_LENGTH = @as(u32, 256);
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = @as(u32, 2);
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = @as(u32, 2);
pub const SSL_HPKP_PKP_HEADER_INDEX = @as(u32, 0);
pub const SSL_HPKP_PKP_RO_HEADER_INDEX = @as(u32, 1);
pub const SSL_HPKP_HEADER_COUNT = @as(u32, 2);
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH = @as(u32, 512);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = @as(i32, -2);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = @as(i32, -1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = @as(u32, 2);
pub const CRYPT_STRING_BASE64URI = @as(u32, 13);
pub const CRYPT_STRING_ENCODEMASK = @as(u32, 255);
pub const CRYPT_STRING_RESERVED100 = @as(u32, 256);
pub const CRYPT_STRING_RESERVED200 = @as(u32, 512);
pub const CRYPT_STRING_PERCENTESCAPE = @as(u32, 134217728);
pub const CRYPT_STRING_HASHDATA = @as(u32, 268435456);
pub const CRYPT_STRING_NOCRLF = @as(u32, 1073741824);
pub const CRYPT_STRING_NOCR = @as(u32, 2147483648);
pub const szOID_PKCS_12_PbeIds = "1.2.840.113549.1.12.1";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC4 = "1.2.840.113549.1.12.1.1";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC4 = "1.2.840.113549.1.12.1.2";
pub const szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES = "1.2.840.113549.1.12.1.3";
pub const szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES = "1.2.840.113549.1.12.1.4";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC2 = "1.2.840.113549.1.12.1.5";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC2 = "1.2.840.113549.1.12.1.6";
pub const szOID_PKCS_5_PBKDF2 = "1.2.840.113549.1.5.12";
pub const szOID_PKCS_5_PBES2 = "1.2.840.113549.1.5.13";
pub const PKCS12_IMPORT_SILENT = @as(u32, 64);
pub const PKCS12_ONLY_CERTIFICATES = @as(u32, 1024);
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = @as(u32, 2048);
pub const PKCS12_VIRTUAL_ISOLATION_KEY = @as(u32, 65536);
pub const PKCS12_IMPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = @as(u32, 0);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME = "PfxProvider";
pub const PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME = "PfxContainer";
pub const REPORT_NO_PRIVATE_KEY = @as(u32, 1);
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = @as(u32, 2);
pub const EXPORT_PRIVATE_KEYS = @as(u32, 4);
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS = @as(u32, 32);
pub const PKCS12_EXPORT_SILENT = @as(u32, 64);
pub const PKCS12_EXPORT_PBES2_PARAMS = @as(u32, 128);
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = @as(u32, 256);
pub const PKCS12_ENCRYPT_CERTIFICATES = @as(u32, 512);
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = @as(u32, 4096);
pub const PKCS12_EXPORT_ECC_CURVE_OID = @as(u32, 8192);
pub const PKCS12_EXPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_PBKDF2_ID_HMAC_SHA1 = "1.2.840.113549.2.7";
pub const PKCS12_PBKDF2_ID_HMAC_SHA256 = "1.2.840.113549.2.9";
pub const PKCS12_PBKDF2_ID_HMAC_SHA384 = "1.2.840.113549.2.10";
pub const PKCS12_PBKDF2_ID_HMAC_SHA512 = "1.2.840.113549.2.11";
pub const PKCS12_PBES2_ALG_AES256_SHA256 = "AES256-SHA256";
pub const PKCS12_CONFIG_REGPATH = "Software\\Microsoft\\Windows\\CurrentVersion\\PFX";
pub const PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME = "EncryptCertificates";
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = @as(u32, 1);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = @as(u32, 2);
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = @as(u32, 1);
pub const CERT_RETRIEVE_ISSUER_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_RETRIEVE_SUBJECT_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_RETRIEVE_COMMUNITY_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1000));
pub const CERT_SELECT_MAX_PARA = @as(u32, 500);
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME = @as(u32, 12);
pub const CERT_SELECT_BY_FRIENDLYNAME = @as(u32, 13);
pub const CERT_SELECT_BY_THUMBPRINT = @as(u32, 14);
pub const CERT_SELECT_ALLOW_EXPIRED = @as(u32, 1);
pub const CERT_SELECT_TRUSTED_ROOT = @as(u32, 2);
pub const CERT_SELECT_DISALLOW_SELFSIGNED = @as(u32, 4);
pub const CERT_SELECT_HAS_PRIVATE_KEY = @as(u32, 8);
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = @as(u32, 16);
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = @as(u32, 32);
pub const CERT_SELECT_HARDWARE_ONLY = @as(u32, 64);
pub const CERT_SELECT_ALLOW_DUPLICATES = @as(u32, 128);
pub const CERT_SELECT_IGNORE_AUTOSELECT = @as(u32, 256);
pub const TIMESTAMP_FAILURE_BAD_ALG = @as(u32, 0);
pub const TIMESTAMP_FAILURE_BAD_REQUEST = @as(u32, 2);
pub const TIMESTAMP_FAILURE_BAD_FORMAT = @as(u32, 5);
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = @as(u32, 14);
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = @as(u32, 15);
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = @as(u32, 16);
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = @as(u32, 17);
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE = @as(u32, 25);
pub const TIMESTAMP_DONT_HASH_DATA = @as(u32, 1);
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const TIMESTAMP_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = @as(u32, 1);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = @as(u32, 32);
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = @as(u32, 33);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = @as(u32, 65535);
pub const SSL_OBJECT_LOCATOR_PFX_FUNC = "SslObjectLocatorInitializePfx";
pub const SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC = "SslObjectLocatorInitializeIssuerList";
pub const SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC = "SslObjectLocatorInitializeCertValidationConfig";
pub const CERT_FILE_HASH_USE_TYPE = @as(u32, 1);
pub const CERT_TIMESTAMP_HASH_USE_TYPE = @as(u32, 2);
pub const RECIPIENTPOLICYV1 = @as(u32, 1);
pub const RECIPIENTPOLICYV2 = @as(u32, 2);
pub const E_ICARD_COMMUNICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413888));
pub const E_ICARD_DATA_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413887));
pub const E_ICARD_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413886));
pub const E_ICARD_IDENTITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413885));
pub const E_ICARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413884));
pub const E_ICARD_ARGUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413883));
pub const E_ICARD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413882));
pub const E_ICARD_INFORMATIONCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413881));
pub const E_ICARD_STOREKEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413880));
pub const E_ICARD_LOGOVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413879));
pub const E_ICARD_PASSWORDVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413878));
pub const E_ICARD_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413877));
pub const E_ICARD_PROCESSDIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413876));
pub const E_ICARD_SERVICEBUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413875));
pub const E_ICARD_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413874));
pub const E_ICARD_SHUTTINGDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413873));
pub const E_ICARD_TOKENCREATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413872));
pub const E_ICARD_TRUSTEXCHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413871));
pub const E_ICARD_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413870));
pub const E_ICARD_USERCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413869));
pub const E_ICARD_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413868));
pub const E_ICARD_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413867));
pub const E_ICARD_UI_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413862));
pub const E_ICARD_REFRESH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413760));
pub const E_ICARD_MISSING_APPLIESTO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413759));
pub const E_ICARD_INVALID_PROOF_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413758));
pub const E_ICARD_UNKNOWN_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413757));
pub const E_ICARD_FAILED_REQUIRED_CLAIMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413756));
pub const AUDIT_CARD_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070016));
pub const AUDIT_CARD_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070017));
pub const AUDIT_CARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070018));
pub const AUDIT_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070019));
pub const AUDIT_STORE_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070020));
pub const AUDIT_STORE_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070021));
pub const AUDIT_SERVICE_IDLE_STOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070022));

//--------------------------------------------------------------------------------
// Section: Types (583)
//--------------------------------------------------------------------------------
pub const BCRYPT_OPERATION = enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    RNG_OPERATION = 32,
    _,
    pub fn initFlags(o: struct {
        CIPHER_OPERATION: u1 = 0,
        HASH_OPERATION: u1 = 0,
        ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
        SECRET_AGREEMENT_OPERATION: u1 = 0,
        SIGNATURE_OPERATION: u1 = 0,
        RNG_OPERATION: u1 = 0,
    }) BCRYPT_OPERATION {
        return @as(BCRYPT_OPERATION, @enumFromInt((if (o.CIPHER_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.CIPHER_OPERATION) else 0) | (if (o.HASH_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.HASH_OPERATION) else 0) | (if (o.ASYMMETRIC_ENCRYPTION_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION) else 0) | (if (o.SECRET_AGREEMENT_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION) else 0) | (if (o.SIGNATURE_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.SIGNATURE_OPERATION) else 0) | (if (o.RNG_OPERATION == 1) @intFromEnum(BCRYPT_OPERATION.RNG_OPERATION) else 0)));
    }
};
pub const BCRYPT_CIPHER_OPERATION = BCRYPT_OPERATION.CIPHER_OPERATION;
pub const BCRYPT_HASH_OPERATION = BCRYPT_OPERATION.HASH_OPERATION;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = BCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const BCRYPT_SECRET_AGREEMENT_OPERATION = BCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const BCRYPT_SIGNATURE_OPERATION = BCRYPT_OPERATION.SIGNATURE_OPERATION;
pub const BCRYPT_RNG_OPERATION = BCRYPT_OPERATION.RNG_OPERATION;

pub const NCRYPT_OPERATION = enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    _,
    pub fn initFlags(o: struct {
        CIPHER_OPERATION: u1 = 0,
        HASH_OPERATION: u1 = 0,
        ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
        SECRET_AGREEMENT_OPERATION: u1 = 0,
        SIGNATURE_OPERATION: u1 = 0,
    }) NCRYPT_OPERATION {
        return @as(NCRYPT_OPERATION, @enumFromInt((if (o.CIPHER_OPERATION == 1) @intFromEnum(NCRYPT_OPERATION.CIPHER_OPERATION) else 0) | (if (o.HASH_OPERATION == 1) @intFromEnum(NCRYPT_OPERATION.HASH_OPERATION) else 0) | (if (o.ASYMMETRIC_ENCRYPTION_OPERATION == 1) @intFromEnum(NCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION) else 0) | (if (o.SECRET_AGREEMENT_OPERATION == 1) @intFromEnum(NCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION) else 0) | (if (o.SIGNATURE_OPERATION == 1) @intFromEnum(NCRYPT_OPERATION.SIGNATURE_OPERATION) else 0)));
    }
};
pub const NCRYPT_CIPHER_OPERATION = NCRYPT_OPERATION.CIPHER_OPERATION;
pub const NCRYPT_HASH_OPERATION = NCRYPT_OPERATION.HASH_OPERATION;
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = NCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const NCRYPT_SECRET_AGREEMENT_OPERATION = NCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const NCRYPT_SIGNATURE_OPERATION = NCRYPT_OPERATION.SIGNATURE_OPERATION;

pub const CERT_FIND_FLAGS = enum(u32) {
    ANY = 0,
    CERT_ID = 1048576,
    CTL_USAGE = 655360,
    // ENHKEY_USAGE = 655360, this enum value conflicts with CTL_USAGE
    EXISTING = 851968,
    HASH = 65536,
    HAS_PRIVATE_KEY = 1376256,
    ISSUER_ATTR = 196612,
    ISSUER_NAME = 131076,
    ISSUER_OF = 786432,
    ISSUER_STR = 524292,
    KEY_IDENTIFIER = 983040,
    KEY_SPEC = 589824,
    MD5_HASH = 262144,
    PROPERTY = 327680,
    PUBLIC_KEY = 393216,
    // SHA1_HASH = 65536, this enum value conflicts with HASH
    SIGNATURE_HASH = 917504,
    SUBJECT_ATTR = 196615,
    SUBJECT_CERT = 720896,
    SUBJECT_NAME = 131079,
    SUBJECT_STR = 524295,
    CROSS_CERT_DIST_POINTS = 1114112,
    PUBKEY_MD5_HASH = 1179648,
    SUBJECT_STR_A = 458759,
    // SUBJECT_STR_W = 524295, this enum value conflicts with SUBJECT_STR
    ISSUER_STR_A = 458756,
    // ISSUER_STR_W = 524292, this enum value conflicts with ISSUER_STR
    SUBJECT_INFO_ACCESS = 1245184,
    HASH_STR = 1310720,
    OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    EXT_ONLY_ENHKEY_USAGE_FLAG = 2,
    PROP_ONLY_ENHKEY_USAGE_FLAG = 4,
    NO_ENHKEY_USAGE_FLAG = 8,
    OR_ENHKEY_USAGE_FLAG = 16,
    VALID_ENHKEY_USAGE_FLAG = 32,
    // OPTIONAL_CTL_USAGE_FLAG = 1, this enum value conflicts with OPTIONAL_ENHKEY_USAGE_FLAG
    // EXT_ONLY_CTL_USAGE_FLAG = 2, this enum value conflicts with EXT_ONLY_ENHKEY_USAGE_FLAG
    // PROP_ONLY_CTL_USAGE_FLAG = 4, this enum value conflicts with PROP_ONLY_ENHKEY_USAGE_FLAG
    // NO_CTL_USAGE_FLAG = 8, this enum value conflicts with NO_ENHKEY_USAGE_FLAG
    // OR_CTL_USAGE_FLAG = 16, this enum value conflicts with OR_ENHKEY_USAGE_FLAG
    // VALID_CTL_USAGE_FLAG = 32, this enum value conflicts with VALID_ENHKEY_USAGE_FLAG
    _,
    pub fn initFlags(o: struct {
        ANY: u1 = 0,
        CERT_ID: u1 = 0,
        CTL_USAGE: u1 = 0,
        EXISTING: u1 = 0,
        HASH: u1 = 0,
        HAS_PRIVATE_KEY: u1 = 0,
        ISSUER_ATTR: u1 = 0,
        ISSUER_NAME: u1 = 0,
        ISSUER_OF: u1 = 0,
        ISSUER_STR: u1 = 0,
        KEY_IDENTIFIER: u1 = 0,
        KEY_SPEC: u1 = 0,
        MD5_HASH: u1 = 0,
        PROPERTY: u1 = 0,
        PUBLIC_KEY: u1 = 0,
        SIGNATURE_HASH: u1 = 0,
        SUBJECT_ATTR: u1 = 0,
        SUBJECT_CERT: u1 = 0,
        SUBJECT_NAME: u1 = 0,
        SUBJECT_STR: u1 = 0,
        CROSS_CERT_DIST_POINTS: u1 = 0,
        PUBKEY_MD5_HASH: u1 = 0,
        SUBJECT_STR_A: u1 = 0,
        ISSUER_STR_A: u1 = 0,
        SUBJECT_INFO_ACCESS: u1 = 0,
        HASH_STR: u1 = 0,
        OPTIONAL_ENHKEY_USAGE_FLAG: u1 = 0,
        EXT_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
        PROP_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
        NO_ENHKEY_USAGE_FLAG: u1 = 0,
        OR_ENHKEY_USAGE_FLAG: u1 = 0,
        VALID_ENHKEY_USAGE_FLAG: u1 = 0,
    }) CERT_FIND_FLAGS {
        return @as(CERT_FIND_FLAGS, @enumFromInt((if (o.ANY == 1) @intFromEnum(CERT_FIND_FLAGS.ANY) else 0) | (if (o.CERT_ID == 1) @intFromEnum(CERT_FIND_FLAGS.CERT_ID) else 0) | (if (o.CTL_USAGE == 1) @intFromEnum(CERT_FIND_FLAGS.CTL_USAGE) else 0) | (if (o.EXISTING == 1) @intFromEnum(CERT_FIND_FLAGS.EXISTING) else 0) | (if (o.HASH == 1) @intFromEnum(CERT_FIND_FLAGS.HASH) else 0) | (if (o.HAS_PRIVATE_KEY == 1) @intFromEnum(CERT_FIND_FLAGS.HAS_PRIVATE_KEY) else 0) | (if (o.ISSUER_ATTR == 1) @intFromEnum(CERT_FIND_FLAGS.ISSUER_ATTR) else 0) | (if (o.ISSUER_NAME == 1) @intFromEnum(CERT_FIND_FLAGS.ISSUER_NAME) else 0) | (if (o.ISSUER_OF == 1) @intFromEnum(CERT_FIND_FLAGS.ISSUER_OF) else 0) | (if (o.ISSUER_STR == 1) @intFromEnum(CERT_FIND_FLAGS.ISSUER_STR) else 0) | (if (o.KEY_IDENTIFIER == 1) @intFromEnum(CERT_FIND_FLAGS.KEY_IDENTIFIER) else 0) | (if (o.KEY_SPEC == 1) @intFromEnum(CERT_FIND_FLAGS.KEY_SPEC) else 0) | (if (o.MD5_HASH == 1) @intFromEnum(CERT_FIND_FLAGS.MD5_HASH) else 0) | (if (o.PROPERTY == 1) @intFromEnum(CERT_FIND_FLAGS.PROPERTY) else 0) | (if (o.PUBLIC_KEY == 1) @intFromEnum(CERT_FIND_FLAGS.PUBLIC_KEY) else 0) | (if (o.SIGNATURE_HASH == 1) @intFromEnum(CERT_FIND_FLAGS.SIGNATURE_HASH) else 0) | (if (o.SUBJECT_ATTR == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_ATTR) else 0) | (if (o.SUBJECT_CERT == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_CERT) else 0) | (if (o.SUBJECT_NAME == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_NAME) else 0) | (if (o.SUBJECT_STR == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_STR) else 0) | (if (o.CROSS_CERT_DIST_POINTS == 1) @intFromEnum(CERT_FIND_FLAGS.CROSS_CERT_DIST_POINTS) else 0) | (if (o.PUBKEY_MD5_HASH == 1) @intFromEnum(CERT_FIND_FLAGS.PUBKEY_MD5_HASH) else 0) | (if (o.SUBJECT_STR_A == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_STR_A) else 0) | (if (o.ISSUER_STR_A == 1) @intFromEnum(CERT_FIND_FLAGS.ISSUER_STR_A) else 0) | (if (o.SUBJECT_INFO_ACCESS == 1) @intFromEnum(CERT_FIND_FLAGS.SUBJECT_INFO_ACCESS) else 0) | (if (o.HASH_STR == 1) @intFromEnum(CERT_FIND_FLAGS.HASH_STR) else 0) | (if (o.OPTIONAL_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG) else 0) | (if (o.EXT_ONLY_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG) else 0) | (if (o.PROP_ONLY_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG) else 0) | (if (o.NO_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG) else 0) | (if (o.OR_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG) else 0) | (if (o.VALID_ENHKEY_USAGE_FLAG == 1) @intFromEnum(CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG) else 0)));
    }
};
pub const CERT_FIND_ANY = CERT_FIND_FLAGS.ANY;
pub const CERT_FIND_CERT_ID = CERT_FIND_FLAGS.CERT_ID;
pub const CERT_FIND_CTL_USAGE = CERT_FIND_FLAGS.CTL_USAGE;
pub const CERT_FIND_ENHKEY_USAGE = CERT_FIND_FLAGS.CTL_USAGE;
pub const CERT_FIND_EXISTING = CERT_FIND_FLAGS.EXISTING;
pub const CERT_FIND_HASH = CERT_FIND_FLAGS.HASH;
pub const CERT_FIND_HAS_PRIVATE_KEY = CERT_FIND_FLAGS.HAS_PRIVATE_KEY;
pub const CERT_FIND_ISSUER_ATTR = CERT_FIND_FLAGS.ISSUER_ATTR;
pub const CERT_FIND_ISSUER_NAME = CERT_FIND_FLAGS.ISSUER_NAME;
pub const CERT_FIND_ISSUER_OF = CERT_FIND_FLAGS.ISSUER_OF;
pub const CERT_FIND_ISSUER_STR = CERT_FIND_FLAGS.ISSUER_STR;
pub const CERT_FIND_KEY_IDENTIFIER = CERT_FIND_FLAGS.KEY_IDENTIFIER;
pub const CERT_FIND_KEY_SPEC = CERT_FIND_FLAGS.KEY_SPEC;
pub const CERT_FIND_MD5_HASH = CERT_FIND_FLAGS.MD5_HASH;
pub const CERT_FIND_PROPERTY = CERT_FIND_FLAGS.PROPERTY;
pub const CERT_FIND_PUBLIC_KEY = CERT_FIND_FLAGS.PUBLIC_KEY;
pub const CERT_FIND_SHA1_HASH = CERT_FIND_FLAGS.HASH;
pub const CERT_FIND_SIGNATURE_HASH = CERT_FIND_FLAGS.SIGNATURE_HASH;
pub const CERT_FIND_SUBJECT_ATTR = CERT_FIND_FLAGS.SUBJECT_ATTR;
pub const CERT_FIND_SUBJECT_CERT = CERT_FIND_FLAGS.SUBJECT_CERT;
pub const CERT_FIND_SUBJECT_NAME = CERT_FIND_FLAGS.SUBJECT_NAME;
pub const CERT_FIND_SUBJECT_STR = CERT_FIND_FLAGS.SUBJECT_STR;
pub const CERT_FIND_CROSS_CERT_DIST_POINTS = CERT_FIND_FLAGS.CROSS_CERT_DIST_POINTS;
pub const CERT_FIND_PUBKEY_MD5_HASH = CERT_FIND_FLAGS.PUBKEY_MD5_HASH;
pub const CERT_FIND_SUBJECT_STR_A = CERT_FIND_FLAGS.SUBJECT_STR_A;
pub const CERT_FIND_SUBJECT_STR_W = CERT_FIND_FLAGS.SUBJECT_STR;
pub const CERT_FIND_ISSUER_STR_A = CERT_FIND_FLAGS.ISSUER_STR_A;
pub const CERT_FIND_ISSUER_STR_W = CERT_FIND_FLAGS.ISSUER_STR;
pub const CERT_FIND_SUBJECT_INFO_ACCESS = CERT_FIND_FLAGS.SUBJECT_INFO_ACCESS;
pub const CERT_FIND_HASH_STR = CERT_FIND_FLAGS.HASH_STR;
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_NO_CTL_USAGE_FLAG = CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OR_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_VALID_CTL_USAGE_FLAG = CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG;

pub const CERT_QUERY_OBJECT_TYPE = enum(u32) {
    FILE = 1,
    BLOB = 2,
};
pub const CERT_QUERY_OBJECT_FILE = CERT_QUERY_OBJECT_TYPE.FILE;
pub const CERT_QUERY_OBJECT_BLOB = CERT_QUERY_OBJECT_TYPE.BLOB;

pub const CERT_QUERY_CONTENT_TYPE = enum(u32) {
    CERT = 1,
    CTL = 2,
    CRL = 3,
    SERIALIZED_STORE = 4,
    SERIALIZED_CERT = 5,
    SERIALIZED_CTL = 6,
    SERIALIZED_CRL = 7,
    PKCS7_SIGNED = 8,
    PKCS7_UNSIGNED = 9,
    PKCS7_SIGNED_EMBED = 10,
    PKCS10 = 11,
    PFX = 12,
    CERT_PAIR = 13,
    PFX_AND_LOAD = 14,
};
pub const CERT_QUERY_CONTENT_CERT = CERT_QUERY_CONTENT_TYPE.CERT;
pub const CERT_QUERY_CONTENT_CTL = CERT_QUERY_CONTENT_TYPE.CTL;
pub const CERT_QUERY_CONTENT_CRL = CERT_QUERY_CONTENT_TYPE.CRL;
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_PKCS10 = CERT_QUERY_CONTENT_TYPE.PKCS10;
pub const CERT_QUERY_CONTENT_PFX = CERT_QUERY_CONTENT_TYPE.PFX;
pub const CERT_QUERY_CONTENT_CERT_PAIR = CERT_QUERY_CONTENT_TYPE.CERT_PAIR;
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE.PFX_AND_LOAD;

pub const CERT_QUERY_CONTENT_TYPE_FLAGS = enum(u32) {
    CERT = 2,
    CTL = 4,
    CRL = 8,
    SERIALIZED_STORE = 16,
    SERIALIZED_CERT = 32,
    SERIALIZED_CTL = 64,
    SERIALIZED_CRL = 128,
    PKCS7_SIGNED = 256,
    PKCS7_UNSIGNED = 512,
    PKCS7_SIGNED_EMBED = 1024,
    PKCS10 = 2048,
    PFX = 4096,
    CERT_PAIR = 8192,
    PFX_AND_LOAD = 16384,
    ALL = 16382,
    ALL_ISSUER_CERT = 818,
};
pub const CERT_QUERY_CONTENT_FLAG_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT;
pub const CERT_QUERY_CONTENT_FLAG_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.CTL;
pub const CERT_QUERY_CONTENT_FLAG_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.CRL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS10 = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS10;
pub const CERT_QUERY_CONTENT_FLAG_PFX = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX;
pub const CERT_QUERY_CONTENT_FLAG_CERT_PAIR = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT_PAIR;
pub const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX_AND_LOAD;
pub const CERT_QUERY_CONTENT_FLAG_ALL = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL;
pub const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL_ISSUER_CERT;

pub const CERT_QUERY_FORMAT_TYPE = enum(u32) {
    BINARY = 1,
    BASE64_ENCODED = 2,
    ASN_ASCII_HEX_ENCODED = 3,
};
pub const CERT_QUERY_FORMAT_BINARY = CERT_QUERY_FORMAT_TYPE.BINARY;
pub const CERT_QUERY_FORMAT_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE.ASN_ASCII_HEX_ENCODED;

pub const CERT_QUERY_FORMAT_TYPE_FLAGS = enum(u32) {
    BINARY = 2,
    BASE64_ENCODED = 4,
    ASN_ASCII_HEX_ENCODED = 8,
    ALL = 14,
};
pub const CERT_QUERY_FORMAT_FLAG_BINARY = CERT_QUERY_FORMAT_TYPE_FLAGS.BINARY;
pub const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.ASN_ASCII_HEX_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ALL = CERT_QUERY_FORMAT_TYPE_FLAGS.ALL;

pub const CERT_QUERY_ENCODING_TYPE = enum(u32) {
    X509_ASN_ENCODING = 1,
    PKCS_7_ASN_ENCODING = 65536,
};
pub const X509_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.X509_ASN_ENCODING;
pub const PKCS_7_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.PKCS_7_ASN_ENCODING;

pub const CERT_RDN_ATTR_VALUE_TYPE = enum(u32) {
    ANY_TYPE = 0,
    NUMERIC_STRING = 3,
    PRINTABLE_STRING = 4,
    T61_STRING = 5,
    VIDEOTEX_STRING = 6,
    IA5_STRING = 7,
    GRAPHIC_STRING = 8,
    ISO646_STRING = 9,
    GENERAL_STRING = 10,
    INT4_STRING = 11,
    UNICODE_STRING = 12,
    // BMP_STRING = 12, this enum value conflicts with UNICODE_STRING
    ENCODED_BLOB = 1,
    OCTET_STRING = 2,
    // TELETEX_STRING = 5, this enum value conflicts with T61_STRING
    // UNIVERSAL_STRING = 11, this enum value conflicts with INT4_STRING
    UTF8_STRING = 13,
    // VISIBLE_STRING = 9, this enum value conflicts with ISO646_STRING
};
pub const CERT_RDN_ANY_TYPE = CERT_RDN_ATTR_VALUE_TYPE.ANY_TYPE;
pub const CERT_RDN_NUMERIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.NUMERIC_STRING;
pub const CERT_RDN_PRINTABLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.PRINTABLE_STRING;
pub const CERT_RDN_T61_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_VIDEOTEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.VIDEOTEX_STRING;
pub const CERT_RDN_IA5_STRING = CERT_RDN_ATTR_VALUE_TYPE.IA5_STRING;
pub const CERT_RDN_GRAPHIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.GRAPHIC_STRING;
pub const CERT_RDN_ISO646_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;
pub const CERT_RDN_GENERAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.GENERAL_STRING;
pub const CERT_RDN_INT4_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UNICODE_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_BMP_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_ENCODED_BLOB = CERT_RDN_ATTR_VALUE_TYPE.ENCODED_BLOB;
pub const CERT_RDN_OCTET_STRING = CERT_RDN_ATTR_VALUE_TYPE.OCTET_STRING;
pub const CERT_RDN_TELETEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_UNIVERSAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UTF8_STRING = CERT_RDN_ATTR_VALUE_TYPE.UTF8_STRING;
pub const CERT_RDN_VISIBLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;

pub const CERT_STRING_TYPE = enum(u32) {
    SIMPLE_NAME_STR = 1,
    OID_NAME_STR = 2,
    X500_NAME_STR = 3,
};
pub const CERT_SIMPLE_NAME_STR = CERT_STRING_TYPE.SIMPLE_NAME_STR;
pub const CERT_OID_NAME_STR = CERT_STRING_TYPE.OID_NAME_STR;
pub const CERT_X500_NAME_STR = CERT_STRING_TYPE.X500_NAME_STR;

pub const BCRYPT_TABLE = enum(u32) {
    LOCAL = 1,
    DOMAIN = 2,
};
pub const CRYPT_LOCAL = BCRYPT_TABLE.LOCAL;
pub const CRYPT_DOMAIN = BCRYPT_TABLE.DOMAIN;

pub const CERT_KEY_SPEC = enum(u32) {
    AT_KEYEXCHANGE = 1,
    AT_SIGNATURE = 2,
    CERT_NCRYPT_KEY_SPEC = 4294967295,
};
pub const AT_KEYEXCHANGE = CERT_KEY_SPEC.AT_KEYEXCHANGE;
pub const AT_SIGNATURE = CERT_KEY_SPEC.AT_SIGNATURE;
pub const CERT_NCRYPT_KEY_SPEC = CERT_KEY_SPEC.CERT_NCRYPT_KEY_SPEC;

pub const BCRYPT_INTERFACE = enum(u32) {
    BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    BCRYPT_CIPHER_INTERFACE = 1,
    BCRYPT_HASH_INTERFACE = 2,
    BCRYPT_RNG_INTERFACE = 6,
    BCRYPT_SECRET_AGREEMENT_INTERFACE = 4,
    BCRYPT_SIGNATURE_INTERFACE = 5,
    NCRYPT_KEY_STORAGE_INTERFACE = 65537,
    NCRYPT_SCHANNEL_INTERFACE = 65538,
    NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539,
};
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = BCRYPT_INTERFACE.BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const BCRYPT_CIPHER_INTERFACE = BCRYPT_INTERFACE.BCRYPT_CIPHER_INTERFACE;
pub const BCRYPT_HASH_INTERFACE = BCRYPT_INTERFACE.BCRYPT_HASH_INTERFACE;
pub const BCRYPT_RNG_INTERFACE = BCRYPT_INTERFACE.BCRYPT_RNG_INTERFACE;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SECRET_AGREEMENT_INTERFACE;
pub const BCRYPT_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SIGNATURE_INTERFACE;
pub const NCRYPT_KEY_STORAGE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_KEY_STORAGE_INTERFACE;
pub const NCRYPT_SCHANNEL_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_INTERFACE;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_SIGNATURE_INTERFACE;

pub const NCRYPT_FLAGS = enum(u32) {
    BCRYPT_PAD_NONE = 1,
    BCRYPT_PAD_OAEP = 4,
    BCRYPT_PAD_PKCS1 = 2,
    BCRYPT_PAD_PSS = 8,
    NCRYPT_SILENT_FLAG = 64,
    // NCRYPT_NO_PADDING_FLAG = 1, this enum value conflicts with BCRYPT_PAD_NONE
    // NCRYPT_PAD_OAEP_FLAG = 4, this enum value conflicts with BCRYPT_PAD_OAEP
    // NCRYPT_PAD_PKCS1_FLAG = 2, this enum value conflicts with BCRYPT_PAD_PKCS1
    // NCRYPT_REGISTER_NOTIFY_FLAG = 1, this enum value conflicts with BCRYPT_PAD_NONE
    // NCRYPT_UNREGISTER_NOTIFY_FLAG = 2, this enum value conflicts with BCRYPT_PAD_PKCS1
    NCRYPT_MACHINE_KEY_FLAG = 32,
    // NCRYPT_UNPROTECT_NO_DECRYPT = 1, this enum value conflicts with BCRYPT_PAD_NONE
    NCRYPT_OVERWRITE_KEY_FLAG = 128,
    // NCRYPT_NO_KEY_VALIDATION = 8, this enum value conflicts with BCRYPT_PAD_PSS
    NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 512,
    // NCRYPT_PAD_PSS_FLAG = 8, this enum value conflicts with BCRYPT_PAD_PSS
    NCRYPT_PERSIST_FLAG = 2147483648,
    NCRYPT_PERSIST_ONLY_FLAG = 1073741824,
    _,
    pub fn initFlags(o: struct {
        BCRYPT_PAD_NONE: u1 = 0,
        BCRYPT_PAD_OAEP: u1 = 0,
        BCRYPT_PAD_PKCS1: u1 = 0,
        BCRYPT_PAD_PSS: u1 = 0,
        NCRYPT_SILENT_FLAG: u1 = 0,
        NCRYPT_MACHINE_KEY_FLAG: u1 = 0,
        NCRYPT_OVERWRITE_KEY_FLAG: u1 = 0,
        NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG: u1 = 0,
        NCRYPT_PERSIST_FLAG: u1 = 0,
        NCRYPT_PERSIST_ONLY_FLAG: u1 = 0,
    }) NCRYPT_FLAGS {
        return @as(NCRYPT_FLAGS, @enumFromInt((if (o.BCRYPT_PAD_NONE == 1) @intFromEnum(NCRYPT_FLAGS.BCRYPT_PAD_NONE) else 0) | (if (o.BCRYPT_PAD_OAEP == 1) @intFromEnum(NCRYPT_FLAGS.BCRYPT_PAD_OAEP) else 0) | (if (o.BCRYPT_PAD_PKCS1 == 1) @intFromEnum(NCRYPT_FLAGS.BCRYPT_PAD_PKCS1) else 0) | (if (o.BCRYPT_PAD_PSS == 1) @intFromEnum(NCRYPT_FLAGS.BCRYPT_PAD_PSS) else 0) | (if (o.NCRYPT_SILENT_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_SILENT_FLAG) else 0) | (if (o.NCRYPT_MACHINE_KEY_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_MACHINE_KEY_FLAG) else 0) | (if (o.NCRYPT_OVERWRITE_KEY_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_OVERWRITE_KEY_FLAG) else 0) | (if (o.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG) else 0) | (if (o.NCRYPT_PERSIST_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_PERSIST_FLAG) else 0) | (if (o.NCRYPT_PERSIST_ONLY_FLAG == 1) @intFromEnum(NCRYPT_FLAGS.NCRYPT_PERSIST_ONLY_FLAG) else 0)));
    }
};
pub const BCRYPT_PAD_NONE = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const BCRYPT_PAD_OAEP = NCRYPT_FLAGS.BCRYPT_PAD_OAEP;
pub const BCRYPT_PAD_PKCS1 = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const BCRYPT_PAD_PSS = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_SILENT_FLAG = NCRYPT_FLAGS.NCRYPT_SILENT_FLAG;
pub const NCRYPT_NO_PADDING_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_PAD_OAEP_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_OAEP;
pub const NCRYPT_PAD_PKCS1_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const NCRYPT_REGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const NCRYPT_MACHINE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_MACHINE_KEY_FLAG;
pub const NCRYPT_UNPROTECT_NO_DECRYPT = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_OVERWRITE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_OVERWRITE_KEY_FLAG;
pub const NCRYPT_NO_KEY_VALIDATION = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = NCRYPT_FLAGS.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG;
pub const NCRYPT_PAD_PSS_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_PERSIST_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_FLAG;
pub const NCRYPT_PERSIST_ONLY_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_ONLY_FLAG;

pub const CRYPT_STRING = enum(u32) {
    BASE64HEADER = 0,
    BASE64 = 1,
    BINARY = 2,
    BASE64REQUESTHEADER = 3,
    HEX = 4,
    HEXASCII = 5,
    BASE64X509CRLHEADER = 9,
    HEXADDR = 10,
    HEXASCIIADDR = 11,
    HEXRAW = 12,
    STRICT = 536870912,
    BASE64_ANY = 6,
    ANY = 7,
    HEX_ANY = 8,
};
pub const CRYPT_STRING_BASE64HEADER = CRYPT_STRING.BASE64HEADER;
pub const CRYPT_STRING_BASE64 = CRYPT_STRING.BASE64;
pub const CRYPT_STRING_BINARY = CRYPT_STRING.BINARY;
pub const CRYPT_STRING_BASE64REQUESTHEADER = CRYPT_STRING.BASE64REQUESTHEADER;
pub const CRYPT_STRING_HEX = CRYPT_STRING.HEX;
pub const CRYPT_STRING_HEXASCII = CRYPT_STRING.HEXASCII;
pub const CRYPT_STRING_BASE64X509CRLHEADER = CRYPT_STRING.BASE64X509CRLHEADER;
pub const CRYPT_STRING_HEXADDR = CRYPT_STRING.HEXADDR;
pub const CRYPT_STRING_HEXASCIIADDR = CRYPT_STRING.HEXASCIIADDR;
pub const CRYPT_STRING_HEXRAW = CRYPT_STRING.HEXRAW;
pub const CRYPT_STRING_STRICT = CRYPT_STRING.STRICT;
pub const CRYPT_STRING_BASE64_ANY = CRYPT_STRING.BASE64_ANY;
pub const CRYPT_STRING_ANY = CRYPT_STRING.ANY;
pub const CRYPT_STRING_HEX_ANY = CRYPT_STRING.HEX_ANY;

pub const CRYPT_IMPORT_PUBLIC_KEY_FLAGS = enum(u32) {
    SIGN_KEY_FLAG = 2147483648,
    ENCRYPT_KEY_FLAG = 1073741824,
    _,
    pub fn initFlags(o: struct {
        SIGN_KEY_FLAG: u1 = 0,
        ENCRYPT_KEY_FLAG: u1 = 0,
    }) CRYPT_IMPORT_PUBLIC_KEY_FLAGS {
        return @as(CRYPT_IMPORT_PUBLIC_KEY_FLAGS, @enumFromInt((if (o.SIGN_KEY_FLAG == 1) @intFromEnum(CRYPT_IMPORT_PUBLIC_KEY_FLAGS.SIGN_KEY_FLAG) else 0) | (if (o.ENCRYPT_KEY_FLAG == 1) @intFromEnum(CRYPT_IMPORT_PUBLIC_KEY_FLAGS.ENCRYPT_KEY_FLAG) else 0)));
    }
};
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.SIGN_KEY_FLAG;
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.ENCRYPT_KEY_FLAG;

pub const CRYPT_XML_FLAGS = enum(u32) {
    FLAG_DISABLE_EXTENSIONS = 268435456,
    FLAG_NO_SERIALIZE = 2147483648,
    SIGN_ADD_KEYVALUE = 1,
};
pub const CRYPT_XML_FLAG_DISABLE_EXTENSIONS = CRYPT_XML_FLAGS.FLAG_DISABLE_EXTENSIONS;
pub const CRYPT_XML_FLAG_NO_SERIALIZE = CRYPT_XML_FLAGS.FLAG_NO_SERIALIZE;
pub const CRYPT_XML_SIGN_ADD_KEYVALUE = CRYPT_XML_FLAGS.SIGN_ADD_KEYVALUE;

pub const CRYPT_ENCODE_OBJECT_FLAGS = enum(u32) {
    ENCODE_ALLOC_FLAG = 32768,
    ENCODE_ENABLE_PUNYCODE_FLAG = 131072,
    UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = 1073741824,
    UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = 2147483648,
    UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = 536870912,
    _,
    pub fn initFlags(o: struct {
        ENCODE_ALLOC_FLAG: u1 = 0,
        ENCODE_ENABLE_PUNYCODE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG: u1 = 0,
    }) CRYPT_ENCODE_OBJECT_FLAGS {
        return @as(CRYPT_ENCODE_OBJECT_FLAGS, @enumFromInt((if (o.ENCODE_ALLOC_FLAG == 1) @intFromEnum(CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ALLOC_FLAG) else 0) | (if (o.ENCODE_ENABLE_PUNYCODE_FLAG == 1) @intFromEnum(CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ENABLE_PUNYCODE_FLAG) else 0) | (if (o.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG == 1) @intFromEnum(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) else 0) | (if (o.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG == 1) @intFromEnum(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG) else 0) | (if (o.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG == 1) @intFromEnum(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG) else 0)));
    }
};
pub const CRYPT_ENCODE_ALLOC_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ALLOC_FLAG;
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ENABLE_PUNYCODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG;

pub const CRYPT_OBJECT_LOCATOR_RELEASE_REASON = enum(u32) {
    SYSTEM_SHUTDOWN = 1,
    SERVICE_STOP = 2,
    PROCESS_EXIT = 3,
    DLL_UNLOAD = 4,
};
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SYSTEM_SHUTDOWN;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SERVICE_STOP;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.PROCESS_EXIT;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.DLL_UNLOAD;

pub const CRYPT_ACQUIRE_FLAGS = enum(u32) {
    CACHE_FLAG = 1,
    COMPARE_KEY_FLAG = 4,
    NO_HEALING = 8,
    SILENT_FLAG = 64,
    USE_PROV_INFO_FLAG = 2,
    _,
    pub fn initFlags(o: struct {
        CACHE_FLAG: u1 = 0,
        COMPARE_KEY_FLAG: u1 = 0,
        NO_HEALING: u1 = 0,
        SILENT_FLAG: u1 = 0,
        USE_PROV_INFO_FLAG: u1 = 0,
    }) CRYPT_ACQUIRE_FLAGS {
        return @as(CRYPT_ACQUIRE_FLAGS, @enumFromInt((if (o.CACHE_FLAG == 1) @intFromEnum(CRYPT_ACQUIRE_FLAGS.CACHE_FLAG) else 0) | (if (o.COMPARE_KEY_FLAG == 1) @intFromEnum(CRYPT_ACQUIRE_FLAGS.COMPARE_KEY_FLAG) else 0) | (if (o.NO_HEALING == 1) @intFromEnum(CRYPT_ACQUIRE_FLAGS.NO_HEALING) else 0) | (if (o.SILENT_FLAG == 1) @intFromEnum(CRYPT_ACQUIRE_FLAGS.SILENT_FLAG) else 0) | (if (o.USE_PROV_INFO_FLAG == 1) @intFromEnum(CRYPT_ACQUIRE_FLAGS.USE_PROV_INFO_FLAG) else 0)));
    }
};
pub const CRYPT_ACQUIRE_CACHE_FLAG = CRYPT_ACQUIRE_FLAGS.CACHE_FLAG;
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = CRYPT_ACQUIRE_FLAGS.COMPARE_KEY_FLAG;
pub const CRYPT_ACQUIRE_NO_HEALING = CRYPT_ACQUIRE_FLAGS.NO_HEALING;
pub const CRYPT_ACQUIRE_SILENT_FLAG = CRYPT_ACQUIRE_FLAGS.SILENT_FLAG;
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = CRYPT_ACQUIRE_FLAGS.USE_PROV_INFO_FLAG;

pub const CRYPT_GET_URL_FLAGS = enum(u32) {
    PROPERTY = 1,
    EXTENSION = 2,
    UNAUTH_ATTRIBUTE = 4,
    AUTH_ATTRIBUTE = 8,
    _,
    pub fn initFlags(o: struct {
        PROPERTY: u1 = 0,
        EXTENSION: u1 = 0,
        UNAUTH_ATTRIBUTE: u1 = 0,
        AUTH_ATTRIBUTE: u1 = 0,
    }) CRYPT_GET_URL_FLAGS {
        return @as(CRYPT_GET_URL_FLAGS, @enumFromInt((if (o.PROPERTY == 1) @intFromEnum(CRYPT_GET_URL_FLAGS.PROPERTY) else 0) | (if (o.EXTENSION == 1) @intFromEnum(CRYPT_GET_URL_FLAGS.EXTENSION) else 0) | (if (o.UNAUTH_ATTRIBUTE == 1) @intFromEnum(CRYPT_GET_URL_FLAGS.UNAUTH_ATTRIBUTE) else 0) | (if (o.AUTH_ATTRIBUTE == 1) @intFromEnum(CRYPT_GET_URL_FLAGS.AUTH_ATTRIBUTE) else 0)));
    }
};
pub const CRYPT_GET_URL_FROM_PROPERTY = CRYPT_GET_URL_FLAGS.PROPERTY;
pub const CRYPT_GET_URL_FROM_EXTENSION = CRYPT_GET_URL_FLAGS.EXTENSION;
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.UNAUTH_ATTRIBUTE;
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.AUTH_ATTRIBUTE;

pub const CERT_STORE_SAVE_AS = enum(u32) {
    PKCS7 = 2,
    STORE = 1,
};
pub const CERT_STORE_SAVE_AS_PKCS7 = CERT_STORE_SAVE_AS.PKCS7;
pub const CERT_STORE_SAVE_AS_STORE = CERT_STORE_SAVE_AS.STORE;

pub const BCRYPT_QUERY_PROVIDER_MODE = enum(u32) {
    ANY = 4,
    UM = 1,
    KM = 2,
    MM = 3,
};
pub const CRYPT_ANY = BCRYPT_QUERY_PROVIDER_MODE.ANY;
pub const CRYPT_UM = BCRYPT_QUERY_PROVIDER_MODE.UM;
pub const CRYPT_KM = BCRYPT_QUERY_PROVIDER_MODE.KM;
pub const CRYPT_MM = BCRYPT_QUERY_PROVIDER_MODE.MM;

pub const CERT_FIND_CHAIN_IN_STORE_FLAGS = enum(u32) {
    COMPARE_KEY_FLAG = 1,
    COMPLEX_CHAIN_FLAG = 2,
    CACHE_ONLY_FLAG = 32768,
    CACHE_ONLY_URL_FLAG = 4,
    LOCAL_MACHINE_FLAG = 8,
    NO_KEY_FLAG = 16384,
    _,
    pub fn initFlags(o: struct {
        COMPARE_KEY_FLAG: u1 = 0,
        COMPLEX_CHAIN_FLAG: u1 = 0,
        CACHE_ONLY_FLAG: u1 = 0,
        CACHE_ONLY_URL_FLAG: u1 = 0,
        LOCAL_MACHINE_FLAG: u1 = 0,
        NO_KEY_FLAG: u1 = 0,
    }) CERT_FIND_CHAIN_IN_STORE_FLAGS {
        return @as(CERT_FIND_CHAIN_IN_STORE_FLAGS, @enumFromInt((if (o.COMPARE_KEY_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPARE_KEY_FLAG) else 0) | (if (o.COMPLEX_CHAIN_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPLEX_CHAIN_FLAG) else 0) | (if (o.CACHE_ONLY_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_FLAG) else 0) | (if (o.CACHE_ONLY_URL_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_URL_FLAG) else 0) | (if (o.LOCAL_MACHINE_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.LOCAL_MACHINE_FLAG) else 0) | (if (o.NO_KEY_FLAG == 1) @intFromEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS.NO_KEY_FLAG) else 0)));
    }
};
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPARE_KEY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPLEX_CHAIN_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_URL_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.LOCAL_MACHINE_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.NO_KEY_FLAG;

pub const CERT_CONTROL_STORE_FLAGS = enum(u32) {
    COMMIT_FORCE_FLAG = 1,
    COMMIT_CLEAR_FLAG = 2,
    // INHIBIT_DUPLICATE_HANDLE_FLAG = 1, this enum value conflicts with COMMIT_FORCE_FLAG
};
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_CLEAR_FLAG;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;

pub const BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS = enum(u32) {
    ALG_HANDLE_HMAC_FLAG = 8,
    PROV_DISPATCH = 1,
    HASH_REUSABLE_FLAG = 32,
    _,
    pub fn initFlags(o: struct {
        ALG_HANDLE_HMAC_FLAG: u1 = 0,
        PROV_DISPATCH: u1 = 0,
        HASH_REUSABLE_FLAG: u1 = 0,
    }) BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS {
        return @as(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS, @enumFromInt((if (o.ALG_HANDLE_HMAC_FLAG == 1) @intFromEnum(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.ALG_HANDLE_HMAC_FLAG) else 0) | (if (o.PROV_DISPATCH == 1) @intFromEnum(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.PROV_DISPATCH) else 0) | (if (o.HASH_REUSABLE_FLAG == 1) @intFromEnum(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.HASH_REUSABLE_FLAG) else 0)));
    }
};
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.ALG_HANDLE_HMAC_FLAG;
pub const BCRYPT_PROV_DISPATCH = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.PROV_DISPATCH;
pub const BCRYPT_HASH_REUSABLE_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.HASH_REUSABLE_FLAG;

pub const CERT_STORE_SAVE_TO = enum(u32) {
    FILE = 1,
    FILENAME = 4,
    FILENAME_A = 3,
    // FILENAME_W = 4, this enum value conflicts with FILENAME
    MEMORY = 2,
};
pub const CERT_STORE_SAVE_TO_FILE = CERT_STORE_SAVE_TO.FILE;
pub const CERT_STORE_SAVE_TO_FILENAME = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_FILENAME_A = CERT_STORE_SAVE_TO.FILENAME_A;
pub const CERT_STORE_SAVE_TO_FILENAME_W = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_MEMORY = CERT_STORE_SAVE_TO.MEMORY;

pub const CRYPT_SET_PROV_PARAM_ID = enum(u32) {
    CLIENT_HWND = 1,
    DELETEKEY = 24,
    KEYEXCHANGE_ALG = 14,
    KEYEXCHANGE_PIN = 32,
    KEYEXCHANGE_KEYSIZE = 12,
    KEYSET_SEC_DESCR = 8,
    PIN_PROMPT_STRING = 44,
    ROOT_CERTSTORE = 46,
    SIGNATURE_ALG = 15,
    SIGNATURE_PIN = 33,
    SIGNATURE_KEYSIZE = 13,
    UI_PROMPT = 21,
    USE_HARDWARE_RNG = 38,
    USER_CERTSTORE = 42,
    SECURE_KEYEXCHANGE_PIN = 47,
    SECURE_SIGNATURE_PIN = 48,
    SMARTCARD_READER = 43,
};
pub const PP_CLIENT_HWND = CRYPT_SET_PROV_PARAM_ID.CLIENT_HWND;
pub const PP_DELETEKEY = CRYPT_SET_PROV_PARAM_ID.DELETEKEY;
pub const PP_KEYEXCHANGE_ALG = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_ALG;
pub const PP_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_PIN;
pub const PP_KEYEXCHANGE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_KEYSIZE;
pub const PP_KEYSET_SEC_DESCR = CRYPT_SET_PROV_PARAM_ID.KEYSET_SEC_DESCR;
pub const PP_PIN_PROMPT_STRING = CRYPT_SET_PROV_PARAM_ID.PIN_PROMPT_STRING;
pub const PP_ROOT_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.ROOT_CERTSTORE;
pub const PP_SIGNATURE_ALG = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_ALG;
pub const PP_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_PIN;
pub const PP_SIGNATURE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_KEYSIZE;
pub const PP_UI_PROMPT = CRYPT_SET_PROV_PARAM_ID.UI_PROMPT;
pub const PP_USE_HARDWARE_RNG = CRYPT_SET_PROV_PARAM_ID.USE_HARDWARE_RNG;
pub const PP_USER_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.USER_CERTSTORE;
pub const PP_SECURE_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_KEYEXCHANGE_PIN;
pub const PP_SECURE_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_SIGNATURE_PIN;
pub const PP_SMARTCARD_READER = CRYPT_SET_PROV_PARAM_ID.SMARTCARD_READER;

pub const CRYPT_KEY_PARAM_ID = enum(u32) {
    ALGID = 7,
    CERTIFICATE = 26,
    PERMISSIONS = 6,
    SALT = 2,
    SALT_EX = 10,
    BLOCKLEN = 8,
    GET_USE_COUNT = 42,
    KEYLEN = 9,
};
pub const KP_ALGID = CRYPT_KEY_PARAM_ID.ALGID;
pub const KP_CERTIFICATE = CRYPT_KEY_PARAM_ID.CERTIFICATE;
pub const KP_PERMISSIONS = CRYPT_KEY_PARAM_ID.PERMISSIONS;
pub const KP_SALT = CRYPT_KEY_PARAM_ID.SALT;
pub const KP_SALT_EX = CRYPT_KEY_PARAM_ID.SALT_EX;
pub const KP_BLOCKLEN = CRYPT_KEY_PARAM_ID.BLOCKLEN;
pub const KP_GET_USE_COUNT = CRYPT_KEY_PARAM_ID.GET_USE_COUNT;
pub const KP_KEYLEN = CRYPT_KEY_PARAM_ID.KEYLEN;

pub const CRYPT_KEY_FLAGS = enum(u32) {
    CRYPT_EXPORTABLE = 1,
    CRYPT_USER_PROTECTED = 2,
    CRYPT_ARCHIVABLE = 16384,
    CRYPT_CREATE_IV = 512,
    CRYPT_CREATE_SALT = 4,
    CRYPT_DATA_KEY = 2048,
    CRYPT_FORCE_KEY_PROTECTION_HIGH = 32768,
    CRYPT_KEK = 1024,
    CRYPT_INITIATOR = 64,
    CRYPT_NO_SALT = 16,
    CRYPT_ONLINE = 128,
    // CRYPT_PREGEN = 64, this enum value conflicts with CRYPT_INITIATOR
    // CRYPT_RECIPIENT = 16, this enum value conflicts with CRYPT_NO_SALT
    CRYPT_SF = 256,
    CRYPT_SGCKEY = 8192,
    CRYPT_VOLATILE = 4096,
    CRYPT_MACHINE_KEYSET = 32,
    // CRYPT_USER_KEYSET = 4096, this enum value conflicts with CRYPT_VOLATILE
    // PKCS12_PREFER_CNG_KSP = 256, this enum value conflicts with CRYPT_SF
    // PKCS12_ALWAYS_CNG_KSP = 512, this enum value conflicts with CRYPT_CREATE_IV
    // PKCS12_ALLOW_OVERWRITE_KEY = 16384, this enum value conflicts with CRYPT_ARCHIVABLE
    // PKCS12_NO_PERSIST_KEY = 32768, this enum value conflicts with CRYPT_FORCE_KEY_PROTECTION_HIGH
    // PKCS12_INCLUDE_EXTENDED_PROPERTIES = 16, this enum value conflicts with CRYPT_NO_SALT
    // CRYPT_OAEP = 64, this enum value conflicts with CRYPT_INITIATOR
    // CRYPT_BLOB_VER3 = 128, this enum value conflicts with CRYPT_ONLINE
    // CRYPT_DESTROYKEY = 4, this enum value conflicts with CRYPT_CREATE_SALT
    // CRYPT_SSL2_FALLBACK = 2, this enum value conflicts with CRYPT_USER_PROTECTED
    // CRYPT_Y_ONLY = 1, this enum value conflicts with CRYPT_EXPORTABLE
    // CRYPT_IPSEC_HMAC_KEY = 256, this enum value conflicts with CRYPT_SF
    // CERT_SET_KEY_PROV_HANDLE_PROP_ID = 1, this enum value conflicts with CRYPT_EXPORTABLE
    // CERT_SET_KEY_CONTEXT_PROP_ID = 1, this enum value conflicts with CRYPT_EXPORTABLE
    _,
    pub fn initFlags(o: struct {
        CRYPT_EXPORTABLE: u1 = 0,
        CRYPT_USER_PROTECTED: u1 = 0,
        CRYPT_ARCHIVABLE: u1 = 0,
        CRYPT_CREATE_IV: u1 = 0,
        CRYPT_CREATE_SALT: u1 = 0,
        CRYPT_DATA_KEY: u1 = 0,
        CRYPT_FORCE_KEY_PROTECTION_HIGH: u1 = 0,
        CRYPT_KEK: u1 = 0,
        CRYPT_INITIATOR: u1 = 0,
        CRYPT_NO_SALT: u1 = 0,
        CRYPT_ONLINE: u1 = 0,
        CRYPT_SF: u1 = 0,
        CRYPT_SGCKEY: u1 = 0,
        CRYPT_VOLATILE: u1 = 0,
        CRYPT_MACHINE_KEYSET: u1 = 0,
    }) CRYPT_KEY_FLAGS {
        return @as(CRYPT_KEY_FLAGS, @enumFromInt((if (o.CRYPT_EXPORTABLE == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE) else 0) | (if (o.CRYPT_USER_PROTECTED == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED) else 0) | (if (o.CRYPT_ARCHIVABLE == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE) else 0) | (if (o.CRYPT_CREATE_IV == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_CREATE_IV) else 0) | (if (o.CRYPT_CREATE_SALT == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT) else 0) | (if (o.CRYPT_DATA_KEY == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_DATA_KEY) else 0) | (if (o.CRYPT_FORCE_KEY_PROTECTION_HIGH == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH) else 0) | (if (o.CRYPT_KEK == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_KEK) else 0) | (if (o.CRYPT_INITIATOR == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_INITIATOR) else 0) | (if (o.CRYPT_NO_SALT == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_NO_SALT) else 0) | (if (o.CRYPT_ONLINE == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_ONLINE) else 0) | (if (o.CRYPT_SF == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_SF) else 0) | (if (o.CRYPT_SGCKEY == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_SGCKEY) else 0) | (if (o.CRYPT_VOLATILE == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_VOLATILE) else 0) | (if (o.CRYPT_MACHINE_KEYSET == 1) @intFromEnum(CRYPT_KEY_FLAGS.CRYPT_MACHINE_KEYSET) else 0)));
    }
};
pub const CRYPT_EXPORTABLE = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CRYPT_USER_PROTECTED = CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED;
pub const CRYPT_ARCHIVABLE = CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE;
pub const CRYPT_CREATE_IV = CRYPT_KEY_FLAGS.CRYPT_CREATE_IV;
pub const CRYPT_CREATE_SALT = CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT;
pub const CRYPT_DATA_KEY = CRYPT_KEY_FLAGS.CRYPT_DATA_KEY;
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH = CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH;
pub const CRYPT_KEK = CRYPT_KEY_FLAGS.CRYPT_KEK;
pub const CRYPT_INITIATOR = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_NO_SALT = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_ONLINE = CRYPT_KEY_FLAGS.CRYPT_ONLINE;
pub const CRYPT_PREGEN = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_RECIPIENT = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_SF = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const CRYPT_SGCKEY = CRYPT_KEY_FLAGS.CRYPT_SGCKEY;
pub const CRYPT_VOLATILE = CRYPT_KEY_FLAGS.CRYPT_VOLATILE;
pub const CRYPT_MACHINE_KEYSET = CRYPT_KEY_FLAGS.CRYPT_MACHINE_KEYSET;
pub const CRYPT_USER_KEYSET = CRYPT_KEY_FLAGS.CRYPT_VOLATILE;
pub const PKCS12_PREFER_CNG_KSP = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const PKCS12_ALWAYS_CNG_KSP = CRYPT_KEY_FLAGS.CRYPT_CREATE_IV;
pub const PKCS12_ALLOW_OVERWRITE_KEY = CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE;
pub const PKCS12_NO_PERSIST_KEY = CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH;
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_OAEP = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_BLOB_VER3 = CRYPT_KEY_FLAGS.CRYPT_ONLINE;
pub const CRYPT_DESTROYKEY = CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT;
pub const CRYPT_SSL2_FALLBACK = CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED;
pub const CRYPT_Y_ONLY = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CRYPT_IPSEC_HMAC_KEY = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const CERT_SET_KEY_PROV_HANDLE_PROP_ID = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CERT_SET_KEY_CONTEXT_PROP_ID = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;

pub const CRYPT_MSG_TYPE = enum(u32) {
    DATA = 1,
    SIGNED = 2,
    ENVELOPED = 3,
    SIGNED_AND_ENVELOPED = 4,
    HASHED = 5,
};
pub const CMSG_DATA = CRYPT_MSG_TYPE.DATA;
pub const CMSG_SIGNED = CRYPT_MSG_TYPE.SIGNED;
pub const CMSG_ENVELOPED = CRYPT_MSG_TYPE.ENVELOPED;
pub const CMSG_SIGNED_AND_ENVELOPED = CRYPT_MSG_TYPE.SIGNED_AND_ENVELOPED;
pub const CMSG_HASHED = CRYPT_MSG_TYPE.HASHED;

pub const CERT_OPEN_STORE_FLAGS = enum(u32) {
    BACKUP_RESTORE_FLAG = 2048,
    CREATE_NEW_FLAG = 8192,
    DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4,
    DELETE_FLAG = 16,
    ENUM_ARCHIVED_FLAG = 512,
    MAXIMUM_ALLOWED_FLAG = 4096,
    NO_CRYPT_RELEASE_FLAG = 1,
    OPEN_EXISTING_FLAG = 16384,
    READONLY_FLAG = 32768,
    SET_LOCALIZED_NAME_FLAG = 2,
    SHARE_CONTEXT_FLAG = 128,
    UPDATE_KEYID_FLAG = 1024,
};
pub const CERT_STORE_BACKUP_RESTORE_FLAG = CERT_OPEN_STORE_FLAGS.BACKUP_RESTORE_FLAG;
pub const CERT_STORE_CREATE_NEW_FLAG = CERT_OPEN_STORE_FLAGS.CREATE_NEW_FLAG;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = CERT_OPEN_STORE_FLAGS.DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
pub const CERT_STORE_DELETE_FLAG = CERT_OPEN_STORE_FLAGS.DELETE_FLAG;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG = CERT_OPEN_STORE_FLAGS.ENUM_ARCHIVED_FLAG;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG = CERT_OPEN_STORE_FLAGS.MAXIMUM_ALLOWED_FLAG;
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG = CERT_OPEN_STORE_FLAGS.NO_CRYPT_RELEASE_FLAG;
pub const CERT_STORE_OPEN_EXISTING_FLAG = CERT_OPEN_STORE_FLAGS.OPEN_EXISTING_FLAG;
pub const CERT_STORE_READONLY_FLAG = CERT_OPEN_STORE_FLAGS.READONLY_FLAG;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG = CERT_OPEN_STORE_FLAGS.SET_LOCALIZED_NAME_FLAG;
pub const CERT_STORE_SHARE_CONTEXT_FLAG = CERT_OPEN_STORE_FLAGS.SHARE_CONTEXT_FLAG;
pub const CERT_STORE_UPDATE_KEYID_FLAG = CERT_OPEN_STORE_FLAGS.UPDATE_KEYID_FLAG;

pub const CRYPT_DEFAULT_CONTEXT_FLAGS = enum(u32) {
    AUTO_RELEASE_FLAG = 1,
    PROCESS_FLAG = 2,
    _,
    pub fn initFlags(o: struct {
        AUTO_RELEASE_FLAG: u1 = 0,
        PROCESS_FLAG: u1 = 0,
    }) CRYPT_DEFAULT_CONTEXT_FLAGS {
        return @as(CRYPT_DEFAULT_CONTEXT_FLAGS, @enumFromInt((if (o.AUTO_RELEASE_FLAG == 1) @intFromEnum(CRYPT_DEFAULT_CONTEXT_FLAGS.AUTO_RELEASE_FLAG) else 0) | (if (o.PROCESS_FLAG == 1) @intFromEnum(CRYPT_DEFAULT_CONTEXT_FLAGS.PROCESS_FLAG) else 0)));
    }
};
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.AUTO_RELEASE_FLAG;
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.PROCESS_FLAG;

pub const CRYPT_VERIFY_CERT_FLAGS = enum(u32) {
    DISABLE_MD2_MD4_FLAG = 1,
    SET_STRONG_PROPERTIES_FLAG = 2,
    RETURN_STRONG_PROPERTIES_FLAG = 4,
};
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = CRYPT_VERIFY_CERT_FLAGS.DISABLE_MD2_MD4_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.SET_STRONG_PROPERTIES_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.RETURN_STRONG_PROPERTIES_FLAG;

pub const CRYPT_SET_HASH_PARAM = enum(u32) {
    MAC_INFO = 5,
    ASHVAL = 2,
};
pub const HP_HMAC_INFO = CRYPT_SET_HASH_PARAM.MAC_INFO;
pub const HP_HASHVAL = CRYPT_SET_HASH_PARAM.ASHVAL;

pub const CERT_SYSTEM_STORE_FLAGS = enum(u32) {
    LOCATION_MASK = 16711680,
    RELOCATE_FLAG = 2147483648,
};
pub const CERT_SYSTEM_STORE_LOCATION_MASK = CERT_SYSTEM_STORE_FLAGS.LOCATION_MASK;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG = CERT_SYSTEM_STORE_FLAGS.RELOCATE_FLAG;

pub const CERT_CREATE_SELFSIGN_FLAGS = enum(u32) {
    KEY_INFO = 2,
    SIGN = 1,
    _,
    pub fn initFlags(o: struct {
        KEY_INFO: u1 = 0,
        SIGN: u1 = 0,
    }) CERT_CREATE_SELFSIGN_FLAGS {
        return @as(CERT_CREATE_SELFSIGN_FLAGS, @enumFromInt((if (o.KEY_INFO == 1) @intFromEnum(CERT_CREATE_SELFSIGN_FLAGS.KEY_INFO) else 0) | (if (o.SIGN == 1) @intFromEnum(CERT_CREATE_SELFSIGN_FLAGS.SIGN) else 0)));
    }
};
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO = CERT_CREATE_SELFSIGN_FLAGS.KEY_INFO;
pub const CERT_CREATE_SELFSIGN_NO_SIGN = CERT_CREATE_SELFSIGN_FLAGS.SIGN;

pub const CRYPT_DEFAULT_CONTEXT_TYPE = enum(u32) {
    CERT_SIGN_OID = 1,
    MULTI_CERT_SIGN_OID = 2,
};
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.CERT_SIGN_OID;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.MULTI_CERT_SIGN_OID;

pub const BCRYPT_RESOLVE_PROVIDERS_FLAGS = enum(u32) {
    FUNCTIONS = 1,
    PROVIDERS = 2,
    _,
    pub fn initFlags(o: struct {
        FUNCTIONS: u1 = 0,
        PROVIDERS: u1 = 0,
    }) BCRYPT_RESOLVE_PROVIDERS_FLAGS {
        return @as(BCRYPT_RESOLVE_PROVIDERS_FLAGS, @enumFromInt((if (o.FUNCTIONS == 1) @intFromEnum(BCRYPT_RESOLVE_PROVIDERS_FLAGS.FUNCTIONS) else 0) | (if (o.PROVIDERS == 1) @intFromEnum(BCRYPT_RESOLVE_PROVIDERS_FLAGS.PROVIDERS) else 0)));
    }
};
pub const CRYPT_ALL_FUNCTIONS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.FUNCTIONS;
pub const CRYPT_ALL_PROVIDERS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.PROVIDERS;

pub const CERT_FIND_TYPE = enum(u32) {
    ANY = 0,
    SHA1_HASH = 1,
    MD5_HASH = 2,
    USAGE = 3,
    // SAME_USAGE_FLAG = 1, this enum value conflicts with SHA1_HASH
    EXISTING = 5,
    SUBJECT = 4,
};
pub const CTL_FIND_ANY = CERT_FIND_TYPE.ANY;
pub const CTL_FIND_SHA1_HASH = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_MD5_HASH = CERT_FIND_TYPE.MD5_HASH;
pub const CTL_FIND_USAGE = CERT_FIND_TYPE.USAGE;
pub const CTL_FIND_SAME_USAGE_FLAG = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_EXISTING = CERT_FIND_TYPE.EXISTING;
pub const CTL_FIND_SUBJECT = CERT_FIND_TYPE.SUBJECT;

pub const CRYPT_FIND_FLAGS = enum(u32) {
    USER_KEYSET_FLAG = 1,
    MACHINE_KEYSET_FLAG = 2,
    SILENT_KEYSET_FLAG = 64,
};
pub const CRYPT_FIND_USER_KEYSET_FLAG = CRYPT_FIND_FLAGS.USER_KEYSET_FLAG;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG = CRYPT_FIND_FLAGS.MACHINE_KEYSET_FLAG;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG = CRYPT_FIND_FLAGS.SILENT_KEYSET_FLAG;

pub const CRYPT_IMAGE_REF_FLAGS = enum(u32) {
    MIN_DEPENDENCIES = 1,
    PROCESS_ISOLATE = 65536,
    _,
    pub fn initFlags(o: struct {
        MIN_DEPENDENCIES: u1 = 0,
        PROCESS_ISOLATE: u1 = 0,
    }) CRYPT_IMAGE_REF_FLAGS {
        return @as(CRYPT_IMAGE_REF_FLAGS, @enumFromInt((if (o.MIN_DEPENDENCIES == 1) @intFromEnum(CRYPT_IMAGE_REF_FLAGS.MIN_DEPENDENCIES) else 0) | (if (o.PROCESS_ISOLATE == 1) @intFromEnum(CRYPT_IMAGE_REF_FLAGS.PROCESS_ISOLATE) else 0)));
    }
};
pub const CRYPT_MIN_DEPENDENCIES = CRYPT_IMAGE_REF_FLAGS.MIN_DEPENDENCIES;
pub const CRYPT_PROCESS_ISOLATE = CRYPT_IMAGE_REF_FLAGS.PROCESS_ISOLATE;

pub const CERT_REVOCATION_STATUS_REASON = enum(u32) {
    UNSPECIFIED = 0,
    KEY_COMPROMISE = 1,
    CA_COMPROMISE = 2,
    AFFILIATION_CHANGED = 3,
    SUPERSEDED = 4,
    CESSATION_OF_OPERATION = 5,
    CERTIFICATE_HOLD = 6,
    REMOVE_FROM_CRL = 8,
};
pub const CRL_REASON_UNSPECIFIED = CERT_REVOCATION_STATUS_REASON.UNSPECIFIED;
pub const CRL_REASON_KEY_COMPROMISE = CERT_REVOCATION_STATUS_REASON.KEY_COMPROMISE;
pub const CRL_REASON_CA_COMPROMISE = CERT_REVOCATION_STATUS_REASON.CA_COMPROMISE;
pub const CRL_REASON_AFFILIATION_CHANGED = CERT_REVOCATION_STATUS_REASON.AFFILIATION_CHANGED;
pub const CRL_REASON_SUPERSEDED = CERT_REVOCATION_STATUS_REASON.SUPERSEDED;
pub const CRL_REASON_CESSATION_OF_OPERATION = CERT_REVOCATION_STATUS_REASON.CESSATION_OF_OPERATION;
pub const CRL_REASON_CERTIFICATE_HOLD = CERT_REVOCATION_STATUS_REASON.CERTIFICATE_HOLD;
pub const CRL_REASON_REMOVE_FROM_CRL = CERT_REVOCATION_STATUS_REASON.REMOVE_FROM_CRL;

pub const CERT_ROOT_PROGRAM_FLAGS = enum(u32) {
    LSC = 64,
    ORG = 128,
    SUBJECT_LOGO = 32,
    _,
    pub fn initFlags(o: struct {
        LSC: u1 = 0,
        ORG: u1 = 0,
        SUBJECT_LOGO: u1 = 0,
    }) CERT_ROOT_PROGRAM_FLAGS {
        return @as(CERT_ROOT_PROGRAM_FLAGS, @enumFromInt((if (o.LSC == 1) @intFromEnum(CERT_ROOT_PROGRAM_FLAGS.LSC) else 0) | (if (o.ORG == 1) @intFromEnum(CERT_ROOT_PROGRAM_FLAGS.ORG) else 0) | (if (o.SUBJECT_LOGO == 1) @intFromEnum(CERT_ROOT_PROGRAM_FLAGS.SUBJECT_LOGO) else 0)));
    }
};
pub const CERT_ROOT_PROGRAM_FLAG_LSC = CERT_ROOT_PROGRAM_FLAGS.LSC;
pub const CERT_ROOT_PROGRAM_FLAG_ORG = CERT_ROOT_PROGRAM_FLAGS.ORG;
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = CERT_ROOT_PROGRAM_FLAGS.SUBJECT_LOGO;

pub const CRYPT_XML_KEY_VALUE_TYPE = enum(u32) {
    DSA = 1,
    RSA = 2,
    ECDSA = 3,
    CUSTOM = 4,
};
pub const CRYPT_XML_KEY_VALUE_TYPE_DSA = CRYPT_XML_KEY_VALUE_TYPE.DSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_RSA = CRYPT_XML_KEY_VALUE_TYPE.RSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_ECDSA = CRYPT_XML_KEY_VALUE_TYPE.ECDSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_CUSTOM = CRYPT_XML_KEY_VALUE_TYPE.CUSTOM;

pub const CERT_LOGOTYPE_CHOICE = enum(u32) {
    NO_IMAGE_RESOLUTION_CHOICE = 0,
    BITS_IMAGE_RESOLUTION_CHOICE = 1,
    TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2,
};
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.NO_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.BITS_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.TABLE_SIZE_IMAGE_RESOLUTION_CHOICE;

pub const CMSG_KEY_AGREE_OPTION = enum(u32) {
    EPHEMERAL_KEY_CHOICE = 1,
    STATIC_KEY_CHOICE = 2,
};
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.EPHEMERAL_KEY_CHOICE;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.STATIC_KEY_CHOICE;

pub const CERT_LOGOTYPE_OPTION = enum(u32) {
    DIRECT_INFO_CHOICE = 1,
    INDIRECT_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.DIRECT_INFO_CHOICE;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.INDIRECT_INFO_CHOICE;

pub const CERT_STORE_PROV_FLAGS = enum(u32) {
    EXTERNAL_FLAG = 1,
    DELETED_FLAG = 2,
    NO_PERSIST_FLAG = 4,
    SYSTEM_STORE_FLAG = 8,
    LM_SYSTEM_STORE_FLAG = 16,
    _,
    pub fn initFlags(o: struct {
        EXTERNAL_FLAG: u1 = 0,
        DELETED_FLAG: u1 = 0,
        NO_PERSIST_FLAG: u1 = 0,
        SYSTEM_STORE_FLAG: u1 = 0,
        LM_SYSTEM_STORE_FLAG: u1 = 0,
    }) CERT_STORE_PROV_FLAGS {
        return @as(CERT_STORE_PROV_FLAGS, @enumFromInt((if (o.EXTERNAL_FLAG == 1) @intFromEnum(CERT_STORE_PROV_FLAGS.EXTERNAL_FLAG) else 0) | (if (o.DELETED_FLAG == 1) @intFromEnum(CERT_STORE_PROV_FLAGS.DELETED_FLAG) else 0) | (if (o.NO_PERSIST_FLAG == 1) @intFromEnum(CERT_STORE_PROV_FLAGS.NO_PERSIST_FLAG) else 0) | (if (o.SYSTEM_STORE_FLAG == 1) @intFromEnum(CERT_STORE_PROV_FLAGS.SYSTEM_STORE_FLAG) else 0) | (if (o.LM_SYSTEM_STORE_FLAG == 1) @intFromEnum(CERT_STORE_PROV_FLAGS.LM_SYSTEM_STORE_FLAG) else 0)));
    }
};
pub const CERT_STORE_PROV_EXTERNAL_FLAG = CERT_STORE_PROV_FLAGS.EXTERNAL_FLAG;
pub const CERT_STORE_PROV_DELETED_FLAG = CERT_STORE_PROV_FLAGS.DELETED_FLAG;
pub const CERT_STORE_PROV_NO_PERSIST_FLAG = CERT_STORE_PROV_FLAGS.NO_PERSIST_FLAG;
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.SYSTEM_STORE_FLAG;
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.LM_SYSTEM_STORE_FLAG;

pub const CMSG_KEY_AGREE_ORIGINATOR = enum(u32) {
    CERT = 1,
    PUBLIC_KEY = 2,
};
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT = CMSG_KEY_AGREE_ORIGINATOR.CERT;
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = CMSG_KEY_AGREE_ORIGINATOR.PUBLIC_KEY;

pub const CRYPT_CONTEXT_CONFIG_FLAGS = enum(u32) {
    EXCLUSIVE = 1,
    OVERRIDE = 65536,
    _,
    pub fn initFlags(o: struct {
        EXCLUSIVE: u1 = 0,
        OVERRIDE: u1 = 0,
    }) CRYPT_CONTEXT_CONFIG_FLAGS {
        return @as(CRYPT_CONTEXT_CONFIG_FLAGS, @enumFromInt((if (o.EXCLUSIVE == 1) @intFromEnum(CRYPT_CONTEXT_CONFIG_FLAGS.EXCLUSIVE) else 0) | (if (o.OVERRIDE == 1) @intFromEnum(CRYPT_CONTEXT_CONFIG_FLAGS.OVERRIDE) else 0)));
    }
};
pub const CRYPT_EXCLUSIVE = CRYPT_CONTEXT_CONFIG_FLAGS.EXCLUSIVE;
pub const CRYPT_OVERRIDE = CRYPT_CONTEXT_CONFIG_FLAGS.OVERRIDE;

pub const BCRYPT_DSA_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112560452,
    RIVATE_MAGIC = 1448104772,
};
pub const BCRYPT_DSA_PUBLIC_MAGIC = BCRYPT_DSA_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DSA_PRIVATE_MAGIC = BCRYPT_DSA_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_X509DATA_TYPE = enum(u32) {
    ISSUER_SERIAL = 1,
    SKI = 2,
    SUBJECT_NAME = 3,
    CERTIFICATE = 4,
    CRL = 5,
    CUSTOM = 6,
};
pub const CRYPT_XML_X509DATA_TYPE_ISSUER_SERIAL = CRYPT_XML_X509DATA_TYPE.ISSUER_SERIAL;
pub const CRYPT_XML_X509DATA_TYPE_SKI = CRYPT_XML_X509DATA_TYPE.SKI;
pub const CRYPT_XML_X509DATA_TYPE_SUBJECT_NAME = CRYPT_XML_X509DATA_TYPE.SUBJECT_NAME;
pub const CRYPT_XML_X509DATA_TYPE_CERTIFICATE = CRYPT_XML_X509DATA_TYPE.CERTIFICATE;
pub const CRYPT_XML_X509DATA_TYPE_CRL = CRYPT_XML_X509DATA_TYPE.CRL;
pub const CRYPT_XML_X509DATA_TYPE_CUSTOM = CRYPT_XML_X509DATA_TYPE.CUSTOM;

pub const CERT_BIOMETRIC_DATA_TYPE = enum(u32) {
    PREDEFINED_DATA_CHOICE = 1,
    OID_DATA_CHOICE = 2,
};
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.PREDEFINED_DATA_CHOICE;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.OID_DATA_CHOICE;

pub const CERT_CHAIN_POLICY_FLAGS = enum(u32) {
    IGNORE_NOT_TIME_VALID_FLAG = 1,
    IGNORE_CTL_NOT_TIME_VALID_FLAG = 2,
    IGNORE_NOT_TIME_NESTED_FLAG = 4,
    IGNORE_ALL_NOT_TIME_VALID_FLAGS = 7,
    IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8,
    ALLOW_UNKNOWN_CA_FLAG = 16,
    IGNORE_WRONG_USAGE_FLAG = 32,
    IGNORE_INVALID_NAME_FLAG = 64,
    IGNORE_INVALID_POLICY_FLAG = 128,
    IGNORE_END_REV_UNKNOWN_FLAG = 256,
    IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512,
    IGNORE_CA_REV_UNKNOWN_FLAG = 1024,
    IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048,
    IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840,
    ALLOW_TESTROOT_FLAG = 32768,
    TRUST_TESTROOT_FLAG = 16384,
    IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192,
    IGNORE_PEER_TRUST_FLAG = 4096,
};
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_NESTED_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_NOT_TIME_VALID_FLAGS;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_UNKNOWN_CA_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_WRONG_USAGE_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_NAME_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_POLICY_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_END_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CA_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_ROOT_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_REV_UNKNOWN_FLAGS;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.TRUST_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_PEER_TRUST_FLAG;

pub const CERT_STRONG_SIGN_FLAGS = enum(u32) {
    CRL_CHECK = 1,
    OCSP_CHECK = 2,
    _,
    pub fn initFlags(o: struct {
        CRL_CHECK: u1 = 0,
        OCSP_CHECK: u1 = 0,
    }) CERT_STRONG_SIGN_FLAGS {
        return @as(CERT_STRONG_SIGN_FLAGS, @enumFromInt((if (o.CRL_CHECK == 1) @intFromEnum(CERT_STRONG_SIGN_FLAGS.CRL_CHECK) else 0) | (if (o.OCSP_CHECK == 1) @intFromEnum(CERT_STRONG_SIGN_FLAGS.OCSP_CHECK) else 0)));
    }
};
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = CERT_STRONG_SIGN_FLAGS.CRL_CHECK;
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = CERT_STRONG_SIGN_FLAGS.OCSP_CHECK;

pub const CERT_LOGOTYPE_IMAGE_INFO_TYPE = enum(u32) {
    GRAY_SCALE_IMAGE_INFO_CHOICE = 1,
    COLOR_IMAGE_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.GRAY_SCALE_IMAGE_INFO_CHOICE;
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.COLOR_IMAGE_INFO_CHOICE;

pub const CRYPT_XML_STATUS_INFO_STATUS = enum(u32) {
    INTERNAL_REFERENCE = 1,
    KEY_AVAILABLE = 2,
    DIGESTING = 4,
    DIGEST_VALID = 8,
    SIGNATURE_VALID = 65536,
    OPENED_TO_ENCODE = 2147483648,
};
pub const CRYPT_XML_STATUS_INTERNAL_REFERENCE = CRYPT_XML_STATUS_INFO_STATUS.INTERNAL_REFERENCE;
pub const CRYPT_XML_STATUS_KEY_AVAILABLE = CRYPT_XML_STATUS_INFO_STATUS.KEY_AVAILABLE;
pub const CRYPT_XML_STATUS_DIGESTING = CRYPT_XML_STATUS_INFO_STATUS.DIGESTING;
pub const CRYPT_XML_STATUS_DIGEST_VALID = CRYPT_XML_STATUS_INFO_STATUS.DIGEST_VALID;
pub const CRYPT_XML_STATUS_SIGNATURE_VALID = CRYPT_XML_STATUS_INFO_STATUS.SIGNATURE_VALID;
pub const CRYPT_XML_STATUS_OPENED_TO_ENCODE = CRYPT_XML_STATUS_INFO_STATUS.OPENED_TO_ENCODE;

pub const CRYPT_XML_TRANSFORM_FLAGS = enum(u32) {
    ON_STREAM = 1,
    ON_NODESET = 2,
    URI_QUERY_STRING = 3,
    _,
    pub fn initFlags(o: struct {
        ON_STREAM: u1 = 0,
        ON_NODESET: u1 = 0,
        URI_QUERY_STRING: u1 = 0,
    }) CRYPT_XML_TRANSFORM_FLAGS {
        return @as(CRYPT_XML_TRANSFORM_FLAGS, @enumFromInt((if (o.ON_STREAM == 1) @intFromEnum(CRYPT_XML_TRANSFORM_FLAGS.ON_STREAM) else 0) | (if (o.ON_NODESET == 1) @intFromEnum(CRYPT_XML_TRANSFORM_FLAGS.ON_NODESET) else 0) | (if (o.URI_QUERY_STRING == 1) @intFromEnum(CRYPT_XML_TRANSFORM_FLAGS.URI_QUERY_STRING) else 0)));
    }
};
pub const CRYPT_XML_TRANSFORM_ON_STREAM = CRYPT_XML_TRANSFORM_FLAGS.ON_STREAM;
pub const CRYPT_XML_TRANSFORM_ON_NODESET = CRYPT_XML_TRANSFORM_FLAGS.ON_NODESET;
pub const CRYPT_XML_TRANSFORM_URI_QUERY_STRING = CRYPT_XML_TRANSFORM_FLAGS.URI_QUERY_STRING;

pub const CRYPT_XML_GROUP_ID = enum(u32) {
    HASH_________ = 1,
    SIGN_________ = 2,
};
pub const CRYPT_XML_GROUP_ID_HASH_________ = CRYPT_XML_GROUP_ID.HASH_________;
pub const CRYPT_XML_GROUP_ID_SIGN_________ = CRYPT_XML_GROUP_ID.SIGN_________;

pub const CERT_SELECT_CRITERIA_TYPE = enum(u32) {
    ENHKEY_USAGE = 1,
    KEY_USAGE = 2,
    POLICY_OID = 3,
    PROV_NAME = 4,
    EXTENSION = 5,
    SUBJECT_HOST_NAME = 6,
    ISSUER_ATTR = 7,
    SUBJECT_ATTR = 8,
    ISSUER_NAME = 9,
    PUBLIC_KEY = 10,
    TLS_SIGNATURES = 11,
};
pub const CERT_SELECT_BY_ENHKEY_USAGE = CERT_SELECT_CRITERIA_TYPE.ENHKEY_USAGE;
pub const CERT_SELECT_BY_KEY_USAGE = CERT_SELECT_CRITERIA_TYPE.KEY_USAGE;
pub const CERT_SELECT_BY_POLICY_OID = CERT_SELECT_CRITERIA_TYPE.POLICY_OID;
pub const CERT_SELECT_BY_PROV_NAME = CERT_SELECT_CRITERIA_TYPE.PROV_NAME;
pub const CERT_SELECT_BY_EXTENSION = CERT_SELECT_CRITERIA_TYPE.EXTENSION;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME = CERT_SELECT_CRITERIA_TYPE.SUBJECT_HOST_NAME;
pub const CERT_SELECT_BY_ISSUER_ATTR = CERT_SELECT_CRITERIA_TYPE.ISSUER_ATTR;
pub const CERT_SELECT_BY_SUBJECT_ATTR = CERT_SELECT_CRITERIA_TYPE.SUBJECT_ATTR;
pub const CERT_SELECT_BY_ISSUER_NAME = CERT_SELECT_CRITERIA_TYPE.ISSUER_NAME;
pub const CERT_SELECT_BY_PUBLIC_KEY = CERT_SELECT_CRITERIA_TYPE.PUBLIC_KEY;
pub const CERT_SELECT_BY_TLS_SIGNATURES = CERT_SELECT_CRITERIA_TYPE.TLS_SIGNATURES;

pub const BCRYPT_RSAKEY_BLOB_MAGIC = enum(u32) {
    PUBLIC_MAGIC = 826364754,
    PRIVATE_MAGIC = 843141970,
    FULLPRIVATE_MAGIC = 859919186,
};
pub const BCRYPT_RSAPUBLIC_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PUBLIC_MAGIC;
pub const BCRYPT_RSAPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PRIVATE_MAGIC;
pub const BCRYPT_RSAFULLPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.FULLPRIVATE_MAGIC;

pub const CRYPT_XML_KEYINFO_TYPE = enum(u32) {
    KEYNAME = 1,
    KEYVALUE = 2,
    RETRIEVAL = 3,
    X509DATA = 4,
    CUSTOM = 5,
};
pub const CRYPT_XML_KEYINFO_TYPE_KEYNAME = CRYPT_XML_KEYINFO_TYPE.KEYNAME;
pub const CRYPT_XML_KEYINFO_TYPE_KEYVALUE = CRYPT_XML_KEYINFO_TYPE.KEYVALUE;
pub const CRYPT_XML_KEYINFO_TYPE_RETRIEVAL = CRYPT_XML_KEYINFO_TYPE.RETRIEVAL;
pub const CRYPT_XML_KEYINFO_TYPE_X509DATA = CRYPT_XML_KEYINFO_TYPE.X509DATA;
pub const CRYPT_XML_KEYINFO_TYPE_CUSTOM = CRYPT_XML_KEYINFO_TYPE.CUSTOM;

pub const CRYPT_TIMESTAMP_VERSION = enum(u32) {
    N = 1,
};
pub const TIMESTAMP_VERSION = CRYPT_TIMESTAMP_VERSION.N;

pub const CERT_ID_OPTION = enum(u32) {
    ISSUER_SERIAL_NUMBER = 1,
    KEY_IDENTIFIER = 2,
    SHA1_HASH = 3,
};
pub const CERT_ID_ISSUER_SERIAL_NUMBER = CERT_ID_OPTION.ISSUER_SERIAL_NUMBER;
pub const CERT_ID_KEY_IDENTIFIER = CERT_ID_OPTION.KEY_IDENTIFIER;
pub const CERT_ID_SHA1_HASH = CERT_ID_OPTION.SHA1_HASH;

pub const HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE = enum(u32) {
    CLIENT = 1,
    SERVER = 2,
};
pub const AUTHTYPE_CLIENT = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.CLIENT;
pub const AUTHTYPE_SERVER = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.SERVER;

pub const BCRYPT_DH_KEY_BLOB_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112557636,
    RIVATE_MAGIC = 1448101956,
};
pub const BCRYPT_DH_PUBLIC_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DH_PRIVATE_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_STATUS_ERROR_STATUS = enum(u32) {
    NOT_RESOLVED = 1,
    DIGEST_INVALID = 2,
    NOT_SUPPORTED_ALGORITHM = 5,
    NOT_SUPPORTED_TRANSFORM = 8,
    SIGNATURE_INVALID = 65536,
    KEYINFO_NOT_PARSED = 131072,
};
pub const CRYPT_XML_STATUS_ERROR_NOT_RESOLVED = CRYPT_XML_STATUS_ERROR_STATUS.NOT_RESOLVED;
pub const CRYPT_XML_STATUS_ERROR_DIGEST_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.DIGEST_INVALID;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_ALGORITHM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_ALGORITHM;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_TRANSFORM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_TRANSFORM;
pub const CRYPT_XML_STATUS_ERROR_SIGNATURE_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.SIGNATURE_INVALID;
pub const CRYPT_XML_STATUS_ERROR_KEYINFO_NOT_PARSED = CRYPT_XML_STATUS_ERROR_STATUS.KEYINFO_NOT_PARSED;

pub const CRYPT_TIMESTAMP_RESPONSE_STATUS = enum(u32) {
    GRANTED = 0,
    GRANTED_WITH_MODS = 1,
    REJECTED = 2,
    WAITING = 3,
    REVOCATION_WARNING = 4,
    REVOKED = 5,
};
pub const TIMESTAMP_STATUS_GRANTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED_WITH_MODS;
pub const TIMESTAMP_STATUS_REJECTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REJECTED;
pub const TIMESTAMP_STATUS_WAITING = CRYPT_TIMESTAMP_RESPONSE_STATUS.WAITING;
pub const TIMESTAMP_STATUS_REVOCATION_WARNING = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOCATION_WARNING;
pub const TIMESTAMP_STATUS_REVOKED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOKED;

pub const NCRYPT_ALGORITHM_NAME_CLASS = enum(u32) {
    ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    SECRET_AGREEMENT_INTERFACE = 4,
    SIGNATURE_INTERFACE = 5,
};
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SECRET_AGREEMENT_INTERFACE;
pub const NCRYPT_SIGNATURE_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SIGNATURE_INTERFACE;

// TODO: this type has a FreeFunc 'CryptCloseAsyncHandle', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTASYNC = *opaque {};

// TODO: this type has a FreeFunc 'CertFreeCertificateChainEngine', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTCHAINENGINE = *opaque {};

// TODO: this type has a FreeFunc 'BCryptCloseAlgorithmProvider', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const BCRYPT_ALG_HANDLE = isize;

// TODO: this type has a FreeFunc 'BCryptDestroyKey', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const BCRYPT_KEY_HANDLE = isize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_HANDLE = usize;

// TODO: this type has a FreeFunc 'NCryptFreeObject', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_PROV_HANDLE = usize;

// TODO: this type has a FreeFunc 'NCryptFreeObject', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_KEY_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_HASH_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_SECRET_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTPROV_LEGACY = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTSTORE = *anyopaque;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTSTOREPROV = *anyopaque;

pub const CMS_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pbOID: ?*u8,
    cbOID: u32,
};

pub const HMAC_Info = extern struct {
    HashAlgid: u32,
    pbInnerString: ?*u8,
    cbInnerString: u32,
    pbOuterString: ?*u8,
    cbOuterString: u32,
};

pub const SCHANNEL_ALG = extern struct {
    dwUse: u32,
    Algid: u32,
    cBits: u32,
    dwFlags: u32,
    dwReserved: u32,
};

pub const PROV_ENUMALGS = extern struct {
    aiAlgid: u32,
    dwBitLen: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
};

pub const PROV_ENUMALGS_EX = extern struct {
    aiAlgid: u32,
    dwDefaultLen: u32,
    dwMinLen: u32,
    dwMaxLen: u32,
    dwProtocols: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
    dwLongNameLen: u32,
    szLongName: [40]CHAR,
};

pub const PUBLICKEYSTRUC = extern struct {
    bType: u8,
    bVersion: u8,
    reserved: u16,
    aiKeyAlg: u32,
};

pub const RSAPUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
    pubexp: u32,
};

pub const PUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
};

pub const DSSSEED = extern struct {
    counter: u32,
    seed: [20]u8,
};

pub const PUBKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    DSSSeed: DSSSEED,
};

pub const PRIVKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    bitlenX: u32,
    DSSSeed: DSSSEED,
};

pub const KEY_TYPE_SUBTYPE = extern struct {
    dwKeySpec: u32,
    Type: Guid,
    Subtype: Guid,
};

pub const CERT_FORTEZZA_DATA_PROP = extern struct {
    SerialNumber: [8]u8,
    CertIndex: i32,
    CertLabel: [36]u8,
};

pub const CRYPT_RC4_KEY_STATE = extern struct {
    Key: [16]u8,
    SBox: [256]u8,
    i: u8,
    j: u8,
};

pub const CRYPT_DES_KEY_STATE = extern struct {
    Key: [8]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_3DES_KEY_STATE = extern struct {
    Key: [24]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_AES_128_KEY_STATE = extern struct {
    Key: [16]u8,
    IV: [16]u8,
    EncryptionState: [176]u8,
    DecryptionState: [176]u8,
    Feedback: [16]u8,
};

pub const CRYPT_AES_256_KEY_STATE = extern struct {
    Key: [32]u8,
    IV: [16]u8,
    EncryptionState: [240]u8,
    DecryptionState: [240]u8,
    Feedback: [16]u8,
};

pub const CRYPTOAPI_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CMS_DH_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pszContentEncObjId: ?PSTR,
    PubInfo: CRYPTOAPI_BLOB,
    pReserved: ?*anyopaque,
};

pub const BCRYPT_KEY_LENGTHS_STRUCT = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
};

pub const BCRYPT_OID = extern struct {
    cbOID: u32,
    pbOID: ?*u8,
};

pub const BCRYPT_OID_LIST = extern struct {
    dwOIDCount: u32,
    pOIDs: ?*BCRYPT_OID,
};

pub const BCRYPT_PKCS1_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
};

pub const BCRYPT_PSS_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    cbSalt: u32,
};

pub const BCRYPT_OAEP_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    pbLabel: ?*u8,
    cbLabel: u32,
};

pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = extern struct {
    cbSize: u32,
    dwInfoVersion: u32,
    pbNonce: ?*u8,
    cbNonce: u32,
    pbAuthData: ?*u8,
    cbAuthData: u32,
    pbTag: ?*u8,
    cbTag: u32,
    pbMacContext: ?*u8,
    cbMacContext: u32,
    cbAAD: u32,
    cbData: u64,
    dwFlags: u32,
};

pub const BCryptBuffer = extern struct {
    cbBuffer: u32,
    BufferType: u32,
    pvBuffer: ?*anyopaque,
};

pub const BCryptBufferDesc = extern struct {
    ulVersion: u32,
    cBuffers: u32,
    pBuffers: ?*BCryptBuffer,
};

pub const BCRYPT_KEY_BLOB = extern struct {
    Magic: u32,
};

pub const BCRYPT_RSAKEY_BLOB = extern struct {
    Magic: BCRYPT_RSAKEY_BLOB_MAGIC,
    BitLength: u32,
    cbPublicExp: u32,
    cbModulus: u32,
    cbPrime1: u32,
    cbPrime2: u32,
};

pub const BCRYPT_ECCKEY_BLOB = extern struct {
    dwMagic: u32,
    cbKey: u32,
};

pub const SSL_ECCKEY_BLOB = extern struct {
    dwCurveType: u32,
    cbKey: u32,
};

pub const ECC_CURVE_TYPE_ENUM = enum(i32) {
    SHORT_WEIERSTRASS_CURVE = 1,
    TWISTED_EDWARDS_CURVE = 2,
    MONTGOMERY_CURVE = 3,
};
pub const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = ECC_CURVE_TYPE_ENUM.SHORT_WEIERSTRASS_CURVE;
pub const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = ECC_CURVE_TYPE_ENUM.TWISTED_EDWARDS_CURVE;
pub const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = ECC_CURVE_TYPE_ENUM.MONTGOMERY_CURVE;

pub const ECC_CURVE_ALG_ID_ENUM = enum(i32) {
    D = 0,
};
pub const BCRYPT_NO_CURVE_GENERATION_ALG_ID = ECC_CURVE_ALG_ID_ENUM.D;

pub const BCRYPT_ECCFULLKEY_BLOB = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    dwCurveType: ECC_CURVE_TYPE_ENUM,
    dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    cbFieldLength: u32,
    cbSubgroupOrder: u32,
    cbCofactor: u32,
    cbSeed: u32,
};

pub const BCRYPT_DH_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DH_KEY_BLOB_MAGIC,
    cbKey: u32,
};

pub const BCRYPT_DH_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
};

pub const BCRYPT_DSA_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const HASHALGORITHM_ENUM = enum(i32) {
    @"1" = 0,
    @"256" = 1,
    @"512" = 2,
};
pub const DSA_HASH_ALGORITHM_SHA1 = HASHALGORITHM_ENUM.@"1";
pub const DSA_HASH_ALGORITHM_SHA256 = HASHALGORITHM_ENUM.@"256";
pub const DSA_HASH_ALGORITHM_SHA512 = HASHALGORITHM_ENUM.@"512";

pub const DSAFIPSVERSION_ENUM = enum(i32) {
    @"2" = 0,
    @"3" = 1,
};
pub const DSA_FIPS186_2 = DSAFIPSVERSION_ENUM.@"2";
pub const DSA_FIPS186_3 = DSAFIPSVERSION_ENUM.@"3";

pub const BCRYPT_DSA_KEY_BLOB_V2 = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_KEY_DATA_BLOB_HEADER = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    cbKeyData: u32,
};

pub const BCRYPT_DSA_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const BCRYPT_DSA_PARAMETER_HEADER_V2 = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_ECC_CURVE_NAMES = extern struct {
    dwEccCurveNames: u32,
    pEccCurveNames: ?*?PWSTR,
};

pub const BCRYPT_HASH_OPERATION_TYPE = enum(i32) {
    HASH_DATA = 1,
    FINISH_HASH = 2,
};
pub const BCRYPT_HASH_OPERATION_HASH_DATA = BCRYPT_HASH_OPERATION_TYPE.HASH_DATA;
pub const BCRYPT_HASH_OPERATION_FINISH_HASH = BCRYPT_HASH_OPERATION_TYPE.FINISH_HASH;

pub const BCRYPT_MULTI_HASH_OPERATION = extern struct {
    iHash: u32,
    hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: u32,
};

pub const BCRYPT_MULTI_OPERATION_TYPE = enum(i32) {
    H = 1,
};
pub const BCRYPT_OPERATION_TYPE_HASH = BCRYPT_MULTI_OPERATION_TYPE.H;

pub const BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = extern struct {
    cbPerObject: u32,
    cbPerElement: u32,
};

pub const BCRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszName: ?PWSTR,
    dwClass: u32,
    dwFlags: u32,
};

pub const BCRYPT_PROVIDER_NAME = extern struct {
    pszProviderName: ?PWSTR,
};

pub const BCRYPT_INTERFACE_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const CRYPT_INTERFACE_REG = extern struct {
    dwInterface: BCRYPT_INTERFACE,
    dwFlags: BCRYPT_TABLE,
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_IMAGE_REG = extern struct {
    pszImage: ?PWSTR,
    cInterfaces: u32,
    rgpInterfaces: ?*?*CRYPT_INTERFACE_REG,
};

pub const CRYPT_PROVIDER_REG = extern struct {
    cAliases: u32,
    rgpszAliases: ?*?PWSTR,
    pUM: ?*CRYPT_IMAGE_REG,
    pKM: ?*CRYPT_IMAGE_REG,
};

pub const CRYPT_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_CONFIG = extern struct {
    dwFlags: CRYPT_CONTEXT_CONFIG_FLAGS,
    dwReserved: u32,
};

pub const CRYPT_CONTEXT_FUNCTION_CONFIG = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

pub const CRYPT_CONTEXTS = extern struct {
    cContexts: u32,
    rgpszContexts: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTIONS = extern struct {
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTION_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_PROPERTY_REF = extern struct {
    pszProperty: ?PWSTR,
    cbValue: u32,
    pbValue: ?*u8,
};

pub const CRYPT_IMAGE_REF = extern struct {
    pszImage: ?PWSTR,
    dwFlags: CRYPT_IMAGE_REF_FLAGS,
};

pub const CRYPT_PROVIDER_REF = extern struct {
    dwInterface: u32,
    pszFunction: ?PWSTR,
    pszProvider: ?PWSTR,
    cProperties: u32,
    rgpProperties: ?*?*CRYPT_PROPERTY_REF,
    pUM: ?*CRYPT_IMAGE_REF,
    pKM: ?*CRYPT_IMAGE_REF,
};

pub const CRYPT_PROVIDER_REFS = extern struct {
    cProviders: u32,
    rgpProviders: ?*?*CRYPT_PROVIDER_REF,
};

pub const PFN_NCRYPT_ALLOC = *const fn (
    cb_size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_NCRYPT_FREE = *const fn (
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NCRYPT_ALLOC_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_NCRYPT_ALLOC,
    pfnFree: ?PFN_NCRYPT_FREE,
};

pub const NCRYPT_CIPHER_PADDING_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pbIV: ?*u8,
    cbIV: u32,
    pbOtherInfo: ?*u8,
    cbOtherInfo: u32,
};

pub const NCRYPT_PLATFORM_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pcrMask: u32,
};

pub const NCRYPT_KEY_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pbKeyBlob: ?*u8,
    cbKeyBlob: u32,
    pbKeyAuth: ?*u8,
    cbKeyAuth: u32,
};

pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = extern struct {
    Version: u32,
    Flags: u32,
    cbPublicKeyBlob: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    cbSignature: u32,
    cbReport: u32,
    cbAttributes: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = extern struct {
    Version: u32,
    TrustletId: u64,
    MinSvn: u32,
    FlagsMask: u32,
    FlagsExpected: u32,
    _bitfield: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = extern struct {
    Version: u32,
    KeyUsage: u32,
    _bitfield: u32,
    cbAlgName: u32,
    cbNonce: u32,
    cbAuthTag: u32,
    cbWrappingKey: u32,
    cbIsolatedKey: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = extern struct {
    Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
};

pub const NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    HeaderSize: u32,
    cbCertifyInfo: u32,
    cbSignature: u32,
    cbTpmPublic: u32,
};

pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    pcrAlg: u32,
    cbSignature: u32,
    cbQuote: u32,
    cbPcrs: u32,
};

pub const NCryptAlgorithmName = extern struct {
    pszName: ?PWSTR,
    dwClass: NCRYPT_ALGORITHM_NAME_CLASS,
    dwAlgOperations: NCRYPT_OPERATION,
    dwFlags: u32,
};

pub const NCryptKeyName = extern struct {
    pszName: ?PWSTR,
    pszAlgid: ?PWSTR,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: u32,
};

pub const NCryptProviderName = extern struct {
    pszName: ?PWSTR,
    pszComment: ?PWSTR,
};

pub const NCRYPT_UI_POLICY = extern struct {
    dwVersion: u32,
    dwFlags: u32,
    pszCreationTitle: ?[*:0]const u16,
    pszFriendlyName: ?[*:0]const u16,
    pszDescription: ?[*:0]const u16,
};

pub const NCRYPT_KEY_ACCESS_POLICY_BLOB = extern struct {
    dwVersion: u32,
    dwPolicyFlags: u32,
    cbUserSid: u32,
    cbApplicationSid: u32,
};

pub const NCRYPT_SUPPORTED_LENGTHS = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
    dwDefaultLength: u32,
};

pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = extern struct {
    dwVersion: u32,
    iExpiration: i32,
    pabNonce: [32]u8,
    pabPolicyRef: [32]u8,
    pabHMAC: [32]u8,
};

pub const NCRYPT_PCP_TPM_FW_VERSION_INFO = extern struct {
    major1: u16,
    major2: u16,
    minor1: u16,
    minor2: u16,
};

pub const NCRYPT_PCP_RAW_POLICYDIGEST = extern struct {
    dwVersion: u32,
    cbDigest: u32,
};

pub const NCRYPT_KEY_BLOB_HEADER = extern struct {
    cbSize: u32,
    dwMagic: u32,
    cbAlgName: u32,
    cbKeyData: u32,
};

pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = extern struct {
    magic: u32,
    cbHeader: u32,
    cbPublic: u32,
    cbPrivate: u32,
    cbName: u32,
};

pub const CRYPT_BIT_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
    cUnusedBits: u32,
};

pub const CRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_OBJID_TABLE = extern struct {
    dwAlgId: u32,
    pszObjId: ?[*:0]const u8,
};

pub const CRYPT_HASH_INFO = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
};

pub const CERT_EXTENSION = extern struct {
    pszObjId: ?PSTR,
    fCritical: BOOL,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE_TYPE_VALUE = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTES = extern struct {
    cAttr: u32,
    rgAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_RDN_ATTR = extern struct {
    pszObjId: ?PSTR,
    dwValueType: CERT_RDN_ATTR_VALUE_TYPE,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_RDN = extern struct {
    cRDNAttr: u32,
    rgRDNAttr: ?*CERT_RDN_ATTR,
};

pub const CERT_NAME_INFO = extern struct {
    cRDN: u32,
    rgRDN: ?*CERT_RDN,
};

pub const CERT_NAME_VALUE = extern struct {
    dwValueType: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_PUBLIC_KEY_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_ECC_PRIVATE_KEY_INFO = extern struct {
    dwVersion: u32,
    PrivateKey: CRYPTOAPI_BLOB,
    szCurveOid: ?PSTR,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_PRIVATE_KEY_INFO = extern struct {
    Version: u32,
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PrivateKey: CRYPTOAPI_BLOB,
    pAttributes: ?*CRYPT_ATTRIBUTES,
};

pub const CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = extern struct {
    EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
};

pub const PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = *const fn (
    algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    encrypted_private_key: CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pb_clear_text_key: ?*u8,
    pcb_clear_text_key: ?*u32,
    p_void_decrypt_func: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = *const fn (
    p_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    p_clear_text_private_key: ?*CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pb_encrypted_key: ?*u8,
    pcb_encrypted_key: ?*u32,
    p_void_encrypt_func: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_RESOLVE_HCRYPTPROV_FUNC = *const fn (
    p_private_key_info: ?*CRYPT_PRIVATE_KEY_INFO,
    ph_crypt_prov: ?*usize,
    p_void_resolve_func: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PKCS8_IMPORT_PARAMS = extern struct {
    PrivateKey: CRYPTOAPI_BLOB,
    pResolvehCryptProvFunc: ?PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pVoidResolveFunc: ?*anyopaque,
    pDecryptPrivateKeyFunc: ?PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pVoidDecryptFunc: ?*anyopaque,
};

pub const CRYPT_PKCS8_EXPORT_PARAMS = extern struct {
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    pEncryptPrivateKeyFunc: ?PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pVoidEncryptFunc: ?*anyopaque,
};

pub const CERT_INFO = extern struct {
    dwVersion: u32,
    SerialNumber: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    NotBefore: FILETIME,
    NotAfter: FILETIME,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    IssuerUniqueId: CRYPT_BIT_BLOB,
    SubjectUniqueId: CRYPT_BIT_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_ENTRY = extern struct {
    SerialNumber: CRYPTOAPI_BLOB,
    RevocationDate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_INFO = extern struct {
    dwVersion: u32,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cCRLEntry: u32,
    rgCRLEntry: ?*CRL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_OR_CRL_BLOB = extern struct {
    dwChoice: u32,
    cbEncoded: u32,
    pbEncoded: ?*u8,
};

pub const CERT_OR_CRL_BUNDLE = extern struct {
    cItem: u32,
    rgItem: ?*CERT_OR_CRL_BLOB,
};

pub const CERT_REQUEST_INFO = extern struct {
    dwVersion: u32,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_KEYGEN_REQUEST_INFO = extern struct {
    dwVersion: u32,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pwszChallengeString: ?PWSTR,
};

pub const CERT_SIGNED_CONTENT_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
};

pub const CTL_USAGE = extern struct {
    cUsageIdentifier: u32,
    rgpszUsageIdentifier: ?*?PSTR,
};

pub const CTL_ENTRY = extern struct {
    SubjectIdentifier: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CTL_INFO = extern struct {
    dwVersion: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    SequenceNumber: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cCTLEntry: u32,
    rgCTLEntry: ?*CTL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIME_STAMP_REQUEST_INFO = extern struct {
    pszTimeStampAlgorithm: ?PSTR,
    pszContentType: ?PSTR,
    Content: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CRYPT_ENROLLMENT_NAME_VALUE_PAIR = extern struct {
    pwszName: ?PWSTR,
    pwszValue: ?PWSTR,
};

pub const CRYPT_CSP_PROVIDER = extern struct {
    dwKeySpec: u32,
    pwszProviderName: ?PWSTR,
    Signature: CRYPT_BIT_BLOB,
};

pub const PFN_CRYPT_ALLOC = *const fn (
    cb_size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CRYPT_FREE = *const fn (
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ENCODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CRYPT_DECODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CERT_EXTENSIONS = extern struct {
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_AUTHORITY_KEY_ID_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    CertIssuer: CRYPTOAPI_BLOB,
    CertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_PRIVATE_KEY_VALIDITY = extern struct {
    NotBefore: FILETIME,
    NotAfter: FILETIME,
};

pub const CERT_KEY_ATTRIBUTES_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    pPrivateKeyUsagePeriod: ?*CERT_PRIVATE_KEY_VALIDITY,
};

pub const CERT_POLICY_ID = extern struct {
    cCertPolicyElementId: u32,
    rgpszCertPolicyElementId: ?*?PSTR,
};

pub const CERT_KEY_USAGE_RESTRICTION_INFO = extern struct {
    cCertPolicyId: u32,
    rgCertPolicyId: ?*CERT_POLICY_ID,
    RestrictedKeyUsage: CRYPT_BIT_BLOB,
};

pub const CERT_OTHER_NAME = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_ALT_NAME_ENTRY = extern struct {
    dwAltNameChoice: u32,
    Anonymous: extern union {
        pOtherName: ?*CERT_OTHER_NAME,
        pwszRfc822Name: ?PWSTR,
        pwszDNSName: ?PWSTR,
        DirectoryName: CRYPTOAPI_BLOB,
        pwszURL: ?PWSTR,
        IPAddress: CRYPTOAPI_BLOB,
        pszRegisteredID: ?PSTR,
    },
};

pub const CERT_ALT_NAME_INFO = extern struct {
    cAltEntry: u32,
    rgAltEntry: ?*CERT_ALT_NAME_ENTRY,
};

pub const CERT_BASIC_CONSTRAINTS_INFO = extern struct {
    SubjectType: CRYPT_BIT_BLOB,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
    cSubtreesConstraint: u32,
    rgSubtreesConstraint: ?*CRYPTOAPI_BLOB,
};

pub const CERT_BASIC_CONSTRAINTS2_INFO = extern struct {
    fCA: BOOL,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
};

pub const CERT_POLICY_QUALIFIER_INFO = extern struct {
    pszPolicyQualifierId: ?PSTR,
    Qualifier: CRYPTOAPI_BLOB,
};

pub const CERT_POLICY_INFO = extern struct {
    pszPolicyIdentifier: ?PSTR,
    cPolicyQualifier: u32,
    rgPolicyQualifier: ?*CERT_POLICY_QUALIFIER_INFO,
};

pub const CERT_POLICIES_INFO = extern struct {
    cPolicyInfo: u32,
    rgPolicyInfo: ?*CERT_POLICY_INFO,
};

pub const CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = extern struct {
    pszOrganization: ?PSTR,
    cNoticeNumbers: u32,
    rgNoticeNumbers: ?*i32,
};

pub const CERT_POLICY_QUALIFIER_USER_NOTICE = extern struct {
    pNoticeReference: ?*CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pszDisplayText: ?PWSTR,
};

pub const CPS_URLS = extern struct {
    pszURL: ?PWSTR,
    pAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pDigest: ?*CRYPTOAPI_BLOB,
};

pub const CERT_POLICY95_QUALIFIER1 = extern struct {
    pszPracticesReference: ?PWSTR,
    pszNoticeIdentifier: ?PSTR,
    pszNSINoticeIdentifier: ?PSTR,
    cCPSURLs: u32,
    rgCPSURLs: ?*CPS_URLS,
};

pub const CERT_POLICY_MAPPING = extern struct {
    pszIssuerDomainPolicy: ?PSTR,
    pszSubjectDomainPolicy: ?PSTR,
};

pub const CERT_POLICY_MAPPINGS_INFO = extern struct {
    cPolicyMapping: u32,
    rgPolicyMapping: ?*CERT_POLICY_MAPPING,
};

pub const CERT_POLICY_CONSTRAINTS_INFO = extern struct {
    fRequireExplicitPolicy: BOOL,
    dwRequireExplicitPolicySkipCerts: u32,
    fInhibitPolicyMapping: BOOL,
    dwInhibitPolicyMappingSkipCerts: u32,
};

pub const CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CONTENT_INFO = extern struct {
    pszObjId: ?PSTR,
    Content: CRYPTOAPI_BLOB,
};

pub const CRYPT_SEQUENCE_OF_ANY = extern struct {
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CERT_AUTHORITY_KEY_ID2_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    AuthorityCertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ACCESS_DESCRIPTION = extern struct {
    pszAccessMethod: ?PSTR,
    AccessLocation: CERT_ALT_NAME_ENTRY,
};

pub const CERT_AUTHORITY_INFO_ACCESS = extern struct {
    cAccDescr: u32,
    rgAccDescr: ?*CERT_ACCESS_DESCRIPTION,
};

pub const CRL_DIST_POINT_NAME = extern struct {
    dwDistPointNameChoice: u32,
    Anonymous: extern union {
        FullName: CERT_ALT_NAME_INFO,
    },
};

pub const CRL_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    ReasonFlags: CRYPT_BIT_BLOB,
    CRLIssuer: CERT_ALT_NAME_INFO,
};

pub const CRL_DIST_POINTS_INFO = extern struct {
    cDistPoint: u32,
    rgDistPoint: ?*CRL_DIST_POINT,
};

pub const CROSS_CERT_DIST_POINTS_INFO = extern struct {
    dwSyncDeltaTime: u32,
    cDistPoint: u32,
    rgDistPoint: ?*CERT_ALT_NAME_INFO,
};

pub const CERT_PAIR = extern struct {
    Forward: CRYPTOAPI_BLOB,
    Reverse: CRYPTOAPI_BLOB,
};

pub const CRL_ISSUING_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    fOnlyContainsUserCerts: BOOL,
    fOnlyContainsCACerts: BOOL,
    OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    fIndirectCRL: BOOL,
};

pub const CERT_GENERAL_SUBTREE = extern struct {
    Base: CERT_ALT_NAME_ENTRY,
    dwMinimum: u32,
    fMaximum: BOOL,
    dwMaximum: u32,
};

pub const CERT_NAME_CONSTRAINTS_INFO = extern struct {
    cPermittedSubtree: u32,
    rgPermittedSubtree: ?*CERT_GENERAL_SUBTREE,
    cExcludedSubtree: u32,
    rgExcludedSubtree: ?*CERT_GENERAL_SUBTREE,
};

pub const CERT_DSS_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_ECC_SIGNATURE = extern struct {
    r: CRYPTOAPI_BLOB,
    s: CRYPTOAPI_BLOB,
};

pub const CERT_X942_DH_VALIDATION_PARAMS = extern struct {
    seed: CRYPT_BIT_BLOB,
    pgenCounter: u32,
};

pub const CERT_X942_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    j: CRYPTOAPI_BLOB,
    pValidationParams: ?*CERT_X942_DH_VALIDATION_PARAMS,
};

pub const CRYPT_X942_OTHER_INFO = extern struct {
    pszContentEncryptionObjId: ?PSTR,
    rgbCounter: [4]u8,
    rgbKeyLength: [4]u8,
    PubInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_ECC_CMS_SHARED_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EntityUInfo: CRYPTOAPI_BLOB,
    rgbSuppPubInfo: [4]u8,
};

pub const CRYPT_RC2_CBC_PARAMETERS = extern struct {
    dwVersion: u32,
    fIV: BOOL,
    rgbIV: [8]u8,
};

pub const CRYPT_SMIME_CAPABILITY = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_SMIME_CAPABILITIES = extern struct {
    cCapability: u32,
    rgCapability: ?*CRYPT_SMIME_CAPABILITY,
};

pub const CERT_QC_STATEMENT = extern struct {
    pszStatementId: ?PSTR,
    StatementInfo: CRYPTOAPI_BLOB,
};

pub const CERT_QC_STATEMENTS_EXT_INFO = extern struct {
    cStatement: u32,
    rgStatement: ?*CERT_QC_STATEMENT,
};

pub const CRYPT_MASK_GEN_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_RSA_SSA_PSS_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    dwSaltLength: u32,
    dwTrailerField: u32,
};

pub const CRYPT_PSOURCE_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    EncodingParameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_RSAES_OAEP_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
};

pub const CMC_TAGGED_ATTRIBUTE = extern struct {
    dwBodyPartID: u32,
    Attribute: CRYPT_ATTRIBUTE,
};

pub const CMC_TAGGED_CERT_REQUEST = extern struct {
    dwBodyPartID: u32,
    SignedCertRequest: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_REQUEST = extern struct {
    dwTaggedRequestChoice: u32,
    Anonymous: extern union {
        pTaggedCertRequest: ?*CMC_TAGGED_CERT_REQUEST,
    },
};

pub const CMC_TAGGED_CONTENT_INFO = extern struct {
    dwBodyPartID: u32,
    EncodedContentInfo: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_OTHER_MSG = extern struct {
    dwBodyPartID: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CMC_DATA_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedRequest: u32,
    rgTaggedRequest: ?*CMC_TAGGED_REQUEST,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_RESPONSE_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_PEND_INFO = extern struct {
    PendToken: CRYPTOAPI_BLOB,
    PendTime: FILETIME,
};

pub const CMC_STATUS_INFO = extern struct {
    dwStatus: u32,
    cBodyList: u32,
    rgdwBodyList: ?*u32,
    pwszStatusString: ?PWSTR,
    dwOtherInfoChoice: u32,
    Anonymous: extern union {
        dwFailInfo: u32,
        pPendInfo: ?*CMC_PEND_INFO,
    },
};

pub const CMC_ADD_EXTENSIONS_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CMC_ADD_ATTRIBUTES_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_TEMPLATE_EXT = extern struct {
    pszObjId: ?PSTR,
    dwMajorVersion: u32,
    fMinorVersion: BOOL,
    dwMinorVersion: u32,
};

pub const CERT_HASHED_URL = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
    pwszUrl: ?PWSTR,
};

pub const CERT_LOGOTYPE_DETAILS = extern struct {
    pwszMimeType: ?PWSTR,
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_REFERENCE = extern struct {
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_IMAGE_INFO = extern struct {
    dwLogotypeImageInfoChoice: CERT_LOGOTYPE_IMAGE_INFO_TYPE,
    dwFileSize: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwLogotypeImageResolutionChoice: CERT_LOGOTYPE_CHOICE,
    Anonymous: extern union {
        dwNumBits: u32,
        dwTableSize: u32,
    },
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_IMAGE = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeImageInfo: ?*CERT_LOGOTYPE_IMAGE_INFO,
};

pub const CERT_LOGOTYPE_AUDIO_INFO = extern struct {
    dwFileSize: u32,
    dwPlayTime: u32,
    dwChannels: u32,
    dwSampleRate: u32,
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_AUDIO = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeAudioInfo: ?*CERT_LOGOTYPE_AUDIO_INFO,
};

pub const CERT_LOGOTYPE_DATA = extern struct {
    cLogotypeImage: u32,
    rgLogotypeImage: ?*CERT_LOGOTYPE_IMAGE,
    cLogotypeAudio: u32,
    rgLogotypeAudio: ?*CERT_LOGOTYPE_AUDIO,
};

pub const CERT_LOGOTYPE_INFO = extern struct {
    dwLogotypeInfoChoice: CERT_LOGOTYPE_OPTION,
    Anonymous: extern union {
        pLogotypeDirectInfo: ?*CERT_LOGOTYPE_DATA,
        pLogotypeIndirectInfo: ?*CERT_LOGOTYPE_REFERENCE,
    },
};

pub const CERT_OTHER_LOGOTYPE_INFO = extern struct {
    pszObjId: ?PSTR,
    LogotypeInfo: CERT_LOGOTYPE_INFO,
};

pub const CERT_LOGOTYPE_EXT_INFO = extern struct {
    cCommunityLogo: u32,
    rgCommunityLogo: ?*CERT_LOGOTYPE_INFO,
    pIssuerLogo: ?*CERT_LOGOTYPE_INFO,
    pSubjectLogo: ?*CERT_LOGOTYPE_INFO,
    cOtherLogo: u32,
    rgOtherLogo: ?*CERT_OTHER_LOGOTYPE_INFO,
};

pub const CERT_BIOMETRIC_DATA = extern struct {
    dwTypeOfBiometricDataChoice: CERT_BIOMETRIC_DATA_TYPE,
    Anonymous: extern union {
        dwPredefined: u32,
        pszObjId: ?PSTR,
    },
    HashedUrl: CERT_HASHED_URL,
};

pub const CERT_BIOMETRIC_EXT_INFO = extern struct {
    cBiometricData: u32,
    rgBiometricData: ?*CERT_BIOMETRIC_DATA,
};

pub const OCSP_SIGNATURE_INFO = extern struct {
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
};

pub const OCSP_SIGNED_REQUEST_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    pOptionalSignatureInfo: ?*OCSP_SIGNATURE_INFO,
};

pub const OCSP_CERT_ID = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IssuerNameHash: CRYPTOAPI_BLOB,
    IssuerKeyHash: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const OCSP_REQUEST_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_REQUEST_INFO = extern struct {
    dwVersion: u32,
    pRequestorName: ?*CERT_ALT_NAME_ENTRY,
    cRequestEntry: u32,
    rgRequestEntry: ?*OCSP_REQUEST_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_RESPONSE_INFO = extern struct {
    dwStatus: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const OCSP_BASIC_SIGNED_RESPONSE_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureInfo: OCSP_SIGNATURE_INFO,
};

pub const OCSP_BASIC_REVOKED_INFO = extern struct {
    RevocationDate: FILETIME,
    dwCrlReasonCode: CERT_REVOCATION_STATUS_REASON,
};

pub const OCSP_BASIC_RESPONSE_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    dwCertStatus: u32,
    Anonymous: extern union {
        pRevokedInfo: ?*OCSP_BASIC_REVOKED_INFO,
    },
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_BASIC_RESPONSE_INFO = extern struct {
    dwVersion: u32,
    dwResponderIdChoice: u32,
    Anonymous: extern union {
        ByNameResponderId: CRYPTOAPI_BLOB,
        ByKeyResponderId: CRYPTOAPI_BLOB,
    },
    ProducedAt: FILETIME,
    cResponseEntry: u32,
    rgResponseEntry: ?*OCSP_BASIC_RESPONSE_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_SUPPORTED_ALGORITHM_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    IntendedCertPolicies: CERT_POLICIES_INFO,
};

pub const CERT_TPM_SPECIFICATION_INFO = extern struct {
    pwszFamily: ?PWSTR,
    dwLevel: u32,
    dwRevision: u32,
};

pub const CRYPT_OID_FUNC_ENTRY = extern struct {
    pszOID: ?[*:0]const u8,
    pvFuncAddr: ?*anyopaque,
};

pub const PFN_CRYPT_ENUM_OID_FUNC = *const fn (
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
    c_value: u32,
    rgdw_value_type: [*]const u32,
    rgpwsz_value_name: [*]const ?[*:0]const u16,
    rgpb_value_data: [*]const ?*const u8,
    rgcb_value_data: [*]const u32,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_OID_INFO = extern struct {
    cbSize: u32,
    pszOID: ?[*:0]const u8,
    pwszName: ?[*:0]const u16,
    dwGroupId: u32,
    Anonymous: extern union {
        dwValue: u32,
        Algid: u32,
        dwLength: u32,
    },
    ExtraInfo: CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_OID_INFO = *const fn (
    p_info: ?*CRYPT_OID_INFO,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STRONG_SIGN_SERIALIZED_INFO = extern struct {
    dwFlags: CERT_STRONG_SIGN_FLAGS,
    pwszCNGSignHashAlgids: ?PWSTR,
    pwszCNGPubKeyMinBitLengths: ?PWSTR,
};

pub const CERT_STRONG_SIGN_PARA = extern struct {
    cbSize: u32,
    dwInfoChoice: u32,
    Anonymous: extern union {
        pvInfo: ?*anyopaque,
        pSerializedInfo: ?*CERT_STRONG_SIGN_SERIALIZED_INFO,
        pszOID: ?PSTR,
    },
};

pub const CERT_ISSUER_SERIAL_NUMBER = extern struct {
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ID = extern struct {
    dwIdChoice: CERT_ID_OPTION,
    Anonymous: extern union {
        IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
        KeyId: CRYPTOAPI_BLOB,
        HashId: CRYPTOAPI_BLOB,
    },
};

pub const CMSG_SIGNER_ENCODE_INFO = extern struct {
    cbSize: u32,
    pCertInfo: ?*CERT_INFO,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CMSG_SIGNED_ENCODE_INFO = extern struct {
    cbSize: u32,
    cSigners: u32,
    rgSigners: ?*CMSG_SIGNER_ENCODE_INFO,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
    cCrlEncoded: u32,
    rgCrlEncoded: ?*CRYPTOAPI_BLOB,
};

pub const CMSG_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgpRecipients: ?*?*CERT_INFO,
};

pub const CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: HCRYPTPROV_LEGACY,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = extern struct {
    cbSize: u32,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyWrapAuxInfo: ?*anyopaque,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwKeySpec: u32,
    dwKeyChoice: CMSG_KEY_AGREE_OPTION,
    Anonymous: extern union {
        pEphemeralAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
        pSenderId: ?*CERT_ID,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: usize,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
    KeyId: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_RECIPIENT_ENCODE_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    },
};

pub const CMSG_RC2_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SP3_COMPATIBLE_AUX_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const CMSG_RC4_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
};

pub const CMSG_HASHED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CMSG_ENCRYPTED_ENCODE_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
};

pub const PFN_CMSG_STREAM_OUTPUT = *const fn (
    pv_arg: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*u8,
    cb_data: u32,
    f_final: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_STREAM_INFO = extern struct {
    cbContent: u32,
    pfnStreamOutput: ?PFN_CMSG_STREAM_OUTPUT,
    pvArg: ?*anyopaque,
};

pub const CMSG_SIGNER_INFO = extern struct {
    dwVersion: u32,
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_CMS_SIGNER_INFO = extern struct {
    dwVersion: u32,
    SignerId: CERT_ID,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_KEY_TRANS_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    RecipientId: CERT_ID,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = extern struct {
    RecipientId: CERT_ID,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    KeyId: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_CMS_RECIPIENT_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    },
};

pub const CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwSignerIndex: u32,
    dwSignerType: u32,
    pvSigner: ?*anyopaque,
};

pub const CMSG_CTRL_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwRecipientEncryptedKeyIndex: u32,
    OriginatorPublicKey: CRYPT_BIT_BLOB,
};

pub const CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
};

pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    blob: CRYPTOAPI_BLOB,
};

pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    dwUnauthAttrIndex: u32,
};

pub const PFN_CMSG_ALLOC = *const fn (
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CMSG_FREE = *const fn (
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CMSG_GEN_ENCRYPT_KEY = *const fn (
    ph_crypt_prov: ?*usize,
    pai_encrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pv_encrypt_aux_info: ?*anyopaque,
    p_public_key_info: ?*CERT_PUBLIC_KEY_INFO,
    pfn_alloc: ?PFN_CMSG_ALLOC,
    ph_encrypt_key: ?*usize,
    ppb_encrypt_parameters: ?*?*u8,
    pcb_encrypt_parameters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_EXPORT_ENCRYPT_KEY = *const fn (
    h_crypt_prov: usize,
    h_encrypt_key: usize,
    p_public_key_info: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 4?
    pb_data: ?*u8,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_ENCRYPT_KEY = *const fn (
    h_crypt_prov: usize,
    dw_key_spec: u32,
    pai_encrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pai_pub_key: ?*CRYPT_ALGORITHM_IDENTIFIER,
    // TODO: what to do with BytesParamIndex 5?
    pb_encoded_key: ?*u8,
    cb_encoded_key: u32,
    ph_encrypt_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CONTENT_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgCmsRecipients: ?*CMSG_RECIPIENT_ENCODE_INFO,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    dwEncryptFlags: u32,
    Anonymous: extern union {
        hContentEncryptKey: usize,
        hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    },
    dwFlags: u32,
    fCNG: BOOL,
    pbCNGContentEncryptKeyObject: ?*u8,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
};

pub const PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = *const fn (
    p_content_encrypt_info: ?*CMSG_CONTENT_ENCRYPT_INFO,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_TRANS_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_TRANS = *const fn (
    p_content_encrypt_info: ?*CMSG_CONTENT_ENCRYPT_INFO,
    p_key_trans_encode_info: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    p_key_trans_encrypt_info: ?*CMSG_KEY_TRANS_ENCRYPT_INFO,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_KEY_AGREE_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    cKeyAgreeKeyEncryptInfo: u32,
    rgpKeyAgreeKeyEncryptInfo: ?*?*CMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_AGREE = *const fn (
    p_content_encrypt_info: ?*CMSG_CONTENT_ENCRYPT_INFO,
    p_key_agree_encode_info: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    p_key_agree_encrypt_info: ?*CMSG_KEY_AGREE_ENCRYPT_INFO,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_MAIL_LIST_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_MAIL_LIST = *const fn (
    p_content_encrypt_info: ?*CMSG_CONTENT_ENCRYPT_INFO,
    p_mail_list_encode_info: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    p_mail_list_encrypt_info: ?*CMSG_MAIL_LIST_ENCRYPT_INFO,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_TRANS = *const fn (
    p_content_encryption_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    p_key_trans_decrypt_para: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    ph_content_encrypt_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_AGREE = *const fn (
    p_content_encryption_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    p_key_agree_decrypt_para: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    ph_content_encrypt_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_MAIL_LIST = *const fn (
    p_content_encryption_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    p_mail_list_decrypt_para: ?*CMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    ph_content_encrypt_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CNG_CONTENT_DECRYPT_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    hNCryptKey: NCRYPT_KEY_HANDLE,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
    hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pbCNGContentEncryptKeyObject: ?*u8,
};

pub const PFN_CMSG_CNG_IMPORT_KEY_TRANS = *const fn (
    p_c_n_g_content_decrypt_info: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    p_key_trans_decrypt_para: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_KEY_AGREE = *const fn (
    p_c_n_g_content_decrypt_info: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    p_key_agree_decrypt_para: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = *const fn (
    p_c_n_g_content_decrypt_info: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCertEncoded: ?*u8,
    cbCertEncoded: u32,
    pCertInfo: ?*CERT_INFO,
    hCertStore: ?HCERTSTORE,
};

pub const CRL_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCrlEncoded: ?*u8,
    cbCrlEncoded: u32,
    pCrlInfo: ?*CRL_INFO,
    hCertStore: ?HCERTSTORE,
};

pub const CTL_CONTEXT = extern struct {
    dwMsgAndCertEncodingType: u32,
    pbCtlEncoded: ?*u8,
    cbCtlEncoded: u32,
    pCtlInfo: ?*CTL_INFO,
    hCertStore: ?HCERTSTORE,
    hCryptMsg: ?*anyopaque,
    pbCtlContent: ?*u8,
    cbCtlContent: u32,
};

pub const CertKeyType = enum(u32) {
    Other = 0,
    VirtualSmartCard = 1,
    PhysicalSmartCard = 2,
    Passport = 3,
    PassportRemote = 4,
    PassportSmartCard = 5,
    Hardware = 6,
    Software = 7,
    SelfSigned = 8,
};
pub const KeyTypeOther = CertKeyType.Other;
pub const KeyTypeVirtualSmartCard = CertKeyType.VirtualSmartCard;
pub const KeyTypePhysicalSmartCard = CertKeyType.PhysicalSmartCard;
pub const KeyTypePassport = CertKeyType.Passport;
pub const KeyTypePassportRemote = CertKeyType.PassportRemote;
pub const KeyTypePassportSmartCard = CertKeyType.PassportSmartCard;
pub const KeyTypeHardware = CertKeyType.Hardware;
pub const KeyTypeSoftware = CertKeyType.Software;
pub const KeyTypeSelfSigned = CertKeyType.SelfSigned;

pub const CRYPT_KEY_PROV_PARAM = extern struct {
    dwParam: u32,
    pbData: ?*u8,
    cbData: u32,
    dwFlags: u32,
};

pub const CRYPT_KEY_PROV_INFO = extern struct {
    pwszContainerName: ?PWSTR,
    pwszProvName: ?PWSTR,
    dwProvType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    cProvParam: u32,
    rgProvParam: ?*CRYPT_KEY_PROV_PARAM,
    dwKeySpec: u32,
};

pub const CERT_KEY_CONTEXT = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
};

pub const ROOT_INFO_LUID = extern struct {
    LowPart: u32,
    HighPart: i32,
};

pub const CRYPT_SMART_CARD_ROOT_INFO = extern struct {
    rgbCardID: [16]u8,
    luid: ROOT_INFO_LUID,
};

pub const CERT_SYSTEM_STORE_RELOCATE_PARA = extern struct {
    Anonymous1: extern union {
        hKeyBase: ?HKEY,
        pvBase: ?*anyopaque,
    },
    Anonymous2: extern union {
        pvSystemStore: ?*anyopaque,
        pszSystemStore: ?[*:0]const u8,
        pwszSystemStore: ?[*:0]const u16,
    },
};

pub const CERT_REGISTRY_STORE_CLIENT_GPT_PARA = extern struct {
    hKeyBase: ?HKEY,
    pwszRegPath: ?PWSTR,
};

pub const CERT_REGISTRY_STORE_ROAMING_PARA = extern struct {
    hKey: ?HKEY,
    pwszStoreDirectory: ?PWSTR,
};

pub const CERT_LDAP_STORE_OPENED_PARA = extern struct {
    pvLdapSessionHandle: ?*anyopaque,
    pwszLdapUrl: ?[*:0]const u16,
};

pub const CERT_STORE_PROV_INFO = extern struct {
    cbSize: u32,
    cStoreProvFunc: u32,
    rgpvStoreProvFunc: ?*?*anyopaque,
    hStoreProv: ?HCERTSTOREPROV,
    dwStoreProvFlags: CERT_STORE_PROV_FLAGS,
    hStoreProvFuncAddr2: ?*anyopaque,
};

pub const PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = *const fn (
    lpsz_store_provider: ?[*:0]const u8,
    dw_encoding_type: CERT_QUERY_ENCODING_TYPE,
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_flags: CERT_OPEN_STORE_FLAGS,
    pv_para: ?*const anyopaque,
    h_cert_store: ?HCERTSTORE,
    p_store_prov_info: ?*CERT_STORE_PROV_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CLOSE = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CERT_STORE_PROV_READ_CERT = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_store_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
    pp_prov_cert_context: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CERT = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CERT = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CRL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_store_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
    pp_prov_crl_context: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CRL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CRL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_crl_context: ?*CRL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CTL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_store_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
    pp_prov_ctl_context: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CTL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CTL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CONTROL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    dw_flags: u32,
    dw_ctrl_type: u32,
    pv_ctrl_para: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STORE_PROV_FIND_INFO = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
};

pub const PFN_CERT_STORE_PROV_FIND_CERT = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_find_info: ?*CERT_STORE_PROV_FIND_INFO,
    p_prev_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
    ppv_store_prov_find_info: ?*?*anyopaque,
    pp_prov_cert_context: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CERT = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_cert_context: ?*const CERT_CONTEXT,
    pv_store_prov_find_info: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CRL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_find_info: ?*CERT_STORE_PROV_FIND_INFO,
    p_prev_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
    ppv_store_prov_find_info: ?*?*anyopaque,
    pp_prov_crl_context: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CRL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_crl_context: ?*CRL_CONTEXT,
    pv_store_prov_find_info: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_crl_context: ?*CRL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CTL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_find_info: ?*CERT_STORE_PROV_FIND_INFO,
    p_prev_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
    ppv_store_prov_find_info: ?*?*anyopaque,
    pp_prov_ctl_context: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CTL = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_ctl_context: ?*CTL_CONTEXT,
    pv_store_prov_find_info: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = *const fn (
    h_store_prov: ?HCERTSTOREPROV,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRL_FIND_ISSUED_FOR_PARA = extern struct {
    pSubjectCert: ?*const CERT_CONTEXT,
    pIssuerCert: ?*const CERT_CONTEXT,
};

pub const CTL_ANY_SUBJECT_INFO = extern struct {
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    SubjectIdentifier: CRYPTOAPI_BLOB,
};

pub const CTL_FIND_USAGE_PARA = extern struct {
    cbSize: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    pSigner: ?*CERT_INFO,
};

pub const CTL_FIND_SUBJECT_PARA = extern struct {
    cbSize: u32,
    pUsagePara: ?*CTL_FIND_USAGE_PARA,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
};

pub const PFN_CERT_CREATE_CONTEXT_SORT_FUNC = *const fn (
    cb_total_encoded: u32,
    cb_remain_encoded: u32,
    c_entry: u32,
    pv_sort: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CREATE_CONTEXT_PARA = extern struct {
    cbSize: u32,
    pfnFree: ?PFN_CRYPT_FREE,
    pvFree: ?*anyopaque,
    pfnSort: ?PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pvSort: ?*anyopaque,
};

pub const CERT_SYSTEM_STORE_INFO = extern struct {
    cbSize: u32,
};

pub const CERT_PHYSICAL_STORE_INFO = extern struct {
    cbSize: u32,
    pszOpenStoreProvider: ?PSTR,
    dwOpenEncodingType: u32,
    dwOpenFlags: u32,
    OpenParameters: CRYPTOAPI_BLOB,
    dwFlags: u32,
    dwPriority: u32,
};

pub const PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = *const fn (
    pwsz_store_location: ?[*:0]const u16,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_SYSTEM_STORE = *const fn (
    pv_system_store: ?*const anyopaque,
    dw_flags: CERT_SYSTEM_STORE_FLAGS,
    p_store_info: ?*CERT_SYSTEM_STORE_INFO,
    pv_reserved: ?*anyopaque,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_PHYSICAL_STORE = *const fn (
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
    pwsz_store_name: ?[*:0]const u16,
    p_store_info: ?*CERT_PHYSICAL_STORE_INFO,
    pv_reserved: ?*anyopaque,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CTL_VERIFY_USAGE_PARA = extern struct {
    cbSize: u32,
    ListIdentifier: CRYPTOAPI_BLOB,
    cCtlStore: u32,
    rghCtlStore: ?*?HCERTSTORE,
    cSignerStore: u32,
    rghSignerStore: ?*?HCERTSTORE,
};

pub const CTL_VERIFY_USAGE_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    dwFlags: u32,
    ppCtl: ?*?*CTL_CONTEXT,
    dwCtlEntryIndex: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    dwSignerIndex: u32,
};

pub const CERT_REVOCATION_CRL_INFO = extern struct {
    cbSize: u32,
    pBaseCrlContext: ?*CRL_CONTEXT,
    pDeltaCrlContext: ?*CRL_CONTEXT,
    pCrlEntry: ?*CRL_ENTRY,
    fDeltaCrlEntry: BOOL,
};

pub const CERT_REVOCATION_PARA = extern struct {
    cbSize: u32,
    pIssuerCert: ?*const CERT_CONTEXT,
    cCertStore: u32,
    rgCertStore: ?*?HCERTSTORE,
    hCrlStore: ?HCERTSTORE,
    pftTimeToUse: ?*FILETIME,
};

pub const CERT_REVOCATION_STATUS = extern struct {
    cbSize: u32,
    dwIndex: u32,
    dwError: u32,
    dwReason: CERT_REVOCATION_STATUS_REASON,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
};

pub const CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = extern struct {
    CertSignHashCNGAlgPropData: CRYPTOAPI_BLOB,
    CertIssuerPubKeyBitLengthPropData: CRYPTOAPI_BLOB,
};

pub const CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = extern struct {
    cCNGHashAlgid: u32,
    rgpwszCNGHashAlgid: ?*?PWSTR,
    dwWeakIndex: u32,
};

pub const PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = *const fn (
    dw_cert_encoding_type: u32,
    p_signature_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    ppv_decoded_sign_para: ?*?*anyopaque,
    ppwsz_c_n_g_hash_algid: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = *const fn (
    h_key: NCRYPT_KEY_HANDLE,
    dw_cert_encoding_type: u32,
    p_signature_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pv_decoded_sign_para: ?*anyopaque,
    pwsz_c_n_g_pub_key_algid: ?[*:0]const u16,
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pb_computed_hash: ?*u8,
    cb_computed_hash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pb_signature: ?*u8,
    pcb_signature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = *const fn (
    dw_cert_encoding_type: u32,
    p_pub_key_info: ?*CERT_PUBLIC_KEY_INFO,
    p_signature_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pv_decoded_sign_para: ?*anyopaque,
    pwsz_c_n_g_pub_key_algid: ?[*:0]const u16,
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pb_computed_hash: ?*u8,
    cb_computed_hash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pb_signature: ?*u8,
    cb_signature: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = extern struct {
    cOID: u32,
    rgpszOID: ?*?PSTR,
};

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = *const fn (
    h_n_crypt_key: NCRYPT_KEY_HANDLE,
    dw_cert_encoding_type: u32,
    psz_public_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    pcb_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = *const fn (
    h_b_crypt_key: BCRYPT_KEY_HANDLE,
    dw_cert_encoding_type: u32,
    psz_public_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    pcb_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = *const fn (
    dw_cert_encoding_type: u32,
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    ph_key: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PRIV_KEY_FUNC = *const fn (
    h_crypt_prov: usize,
    p_private_key_info: ?*CRYPT_PRIVATE_KEY_INFO,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_EXPORT_PRIV_KEY_FUNC = *const fn (
    h_crypt_prov: usize,
    dw_key_spec: u32,
    psz_private_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    p_private_key_info: ?*CRYPT_PRIVATE_KEY_INFO,
    pcb_private_key_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_GET_SIGNER_CERTIFICATE = *const fn (
    pv_get_arg: ?*anyopaque,
    dw_cert_encoding_type: u32,
    p_signer_id: ?*CERT_INFO,
    h_msg_cert_store: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

pub const CRYPT_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    pSigningCert: ?*const CERT_CONTEXT,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cMsgCert: u32,
    rgpMsgCert: ?*?*CERT_CONTEXT,
    cMsgCrl: u32,
    rgpMsgCrl: ?*?*CRL_CONTEXT,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    pfnGetSignerCertificate: ?PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pvGetArg: ?*anyopaque,
};

pub const CRYPT_ENCRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_DECRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    cCertStore: u32,
    rghCertStore: ?*?HCERTSTORE,
};

pub const CRYPT_HASH_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CRYPT_KEY_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: CERT_KEY_SPEC,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_KEY_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
};

pub const CERT_CHAIN = extern struct {
    cCerts: u32,
    certs: ?*CRYPTOAPI_BLOB,
    keyLocatorInfo: CRYPT_KEY_PROV_INFO,
};

pub const PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = *const fn (
    psz_param_oid: ?PSTR,
    pv_param: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_BLOB_ARRAY = extern struct {
    cBlob: u32,
    rgBlob: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CREDENTIALS = extern struct {
    cbSize: u32,
    pszCredentialsOid: ?[*:0]const u8,
    pvCredentials: ?*anyopaque,
};

pub const CRYPT_PASSWORD_CREDENTIALSA = extern struct {
    cbSize: u32,
    pszUsername: ?PSTR,
    pszPassword: ?PSTR,
};

pub const CRYPT_PASSWORD_CREDENTIALSW = extern struct {
    cbSize: u32,
    pszUsername: ?PWSTR,
    pszPassword: ?PWSTR,
};

pub const PFN_FREE_ENCODED_OBJECT_FUNC = *const fn (
    psz_object_oid: ?[*:0]const u8,
    p_object: ?*CRYPT_BLOB_ARRAY,
    pv_free_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPTNET_URL_CACHE_PRE_FETCH_INFO = extern struct {
    cbSize: u32,
    dwObjectType: u32,
    dwError: u32,
    dwReserved: u32,
    ThisUpdateTime: FILETIME,
    NextUpdateTime: FILETIME,
    PublishTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_FLUSH_INFO = extern struct {
    cbSize: u32,
    dwExemptSeconds: u32,
    ExpireTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_RESPONSE_INFO = extern struct {
    cbSize: u32,
    wResponseType: u16,
    wResponseFlags: u16,
    LastModifiedTime: FILETIME,
    dwMaxAge: u32,
    pwszETag: ?[*:0]const u16,
    dwProxyId: u32,
};

pub const CRYPT_RETRIEVE_AUX_INFO = extern struct {
    cbSize: u32,
    pLastSyncTime: ?*FILETIME,
    dwMaxUrlRetrievalByteCount: u32,
    pPreFetchInfo: ?*CRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pFlushInfo: ?*CRYPTNET_URL_CACHE_FLUSH_INFO,
    ppResponseInfo: ?*?*CRYPTNET_URL_CACHE_RESPONSE_INFO,
    pwszCacheFileNamePrefix: ?PWSTR,
    pftCacheResync: ?*FILETIME,
    fProxyCacheRetrieval: BOOL,
    dwHttpStatusCode: u32,
    ppwszErrorResponseHeaders: ?*?PWSTR,
    ppErrorContentBlob: ?*?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_CANCEL_RETRIEVAL = *const fn (
    dw_flags: u32,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = *const fn (
    pv_completion: ?*anyopaque,
    dw_completion_code: u32,
    psz_url: ?[*:0]const u8,
    psz_object_oid: ?PSTR,
    pv_object: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ASYNC_RETRIEVAL_COMPLETION = extern struct {
    pfnCompletion: ?PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pvCompletion: ?*anyopaque,
};

pub const PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = *const fn (
    h_async_retrieve: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_URL_ARRAY = extern struct {
    cUrl: u32,
    rgwszUrl: ?*?PWSTR,
};

pub const CRYPT_URL_INFO = extern struct {
    cbSize: u32,
    dwSyncDeltaTime: u32,
    cGroup: u32,
    rgcGroupEntry: ?*u32,
};

pub const CERT_CRL_CONTEXT_PAIR = extern struct {
    pCertContext: ?*const CERT_CONTEXT,
    pCrlContext: ?*CRL_CONTEXT,
};

pub const CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = extern struct {
    cbSize: u32,
    iDeltaCrlIndicator: i32,
    pftCacheResync: ?*FILETIME,
    pLastSyncTime: ?*FILETIME,
    pMaxAgeTime: ?*FILETIME,
    pChainPara: ?*CERT_REVOCATION_CHAIN_PARA,
    pDeltaCrlIndicator: ?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_KEYID_PROP = *const fn (
    p_key_identifier: ?*const CRYPTOAPI_BLOB,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    pv_arg: ?*anyopaque,
    c_prop: u32,
    rgdw_prop_id: [*]u32,
    rgpv_data: [*]?*anyopaque,
    rgcb_data: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_ENGINE_CONFIG = extern struct {
    cbSize: u32,
    hRestrictedRoot: ?HCERTSTORE,
    hRestrictedTrust: ?HCERTSTORE,
    hRestrictedOther: ?HCERTSTORE,
    cAdditionalStore: u32,
    rghAdditionalStore: ?*?HCERTSTORE,
    dwFlags: u32,
    dwUrlRetrievalTimeout: u32,
    MaximumCachedCertificates: u32,
    CycleDetectionModulus: u32,
    hExclusiveRoot: ?HCERTSTORE,
    hExclusiveTrustedPeople: ?HCERTSTORE,
    dwExclusiveFlags: u32,
};

pub const CERT_TRUST_STATUS = extern struct {
    dwErrorStatus: u32,
    dwInfoStatus: u32,
};

pub const CERT_REVOCATION_INFO = extern struct {
    cbSize: u32,
    dwRevocationResult: u32,
    pszRevocationOid: ?[*:0]const u8,
    pvOidSpecificInfo: ?*anyopaque,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
    pCrlInfo: ?*CERT_REVOCATION_CRL_INFO,
};

pub const CERT_TRUST_LIST_INFO = extern struct {
    cbSize: u32,
    pCtlEntry: ?*CTL_ENTRY,
    pCtlContext: ?*CTL_CONTEXT,
};

pub const CERT_CHAIN_ELEMENT = extern struct {
    cbSize: u32,
    pCertContext: ?*const CERT_CONTEXT,
    TrustStatus: CERT_TRUST_STATUS,
    pRevocationInfo: ?*CERT_REVOCATION_INFO,
    pIssuanceUsage: ?*CTL_USAGE,
    pApplicationUsage: ?*CTL_USAGE,
    pwszExtendedErrorInfo: ?[*:0]const u16,
};

pub const CERT_SIMPLE_CHAIN = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cElement: u32,
    rgpElement: ?*?*CERT_CHAIN_ELEMENT,
    pTrustListInfo: ?*CERT_TRUST_LIST_INFO,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
};

pub const CERT_CHAIN_CONTEXT = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cChain: u32,
    rgpChain: ?*?*CERT_SIMPLE_CHAIN,
    cLowerQualityChainContext: u32,
    rgpLowerQualityChainContext: ?*?*CERT_CHAIN_CONTEXT,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
    dwCreateFlags: u32,
    ChainId: Guid,
};

pub const CERT_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CTL_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CERT_CHAIN_PARA = extern struct {
    cbSize: u32,
    RequestedUsage: CERT_USAGE_MATCH,
};

pub const CERT_REVOCATION_CHAIN_PARA = extern struct {
    cbSize: u32,
    hChainEngine: ?HCERTCHAINENGINE,
    hAdditionalStore: ?HCERTSTORE,
    dwChainFlags: u32,
    dwUrlRetrievalTimeout: u32,
    pftCurrentTime: ?*FILETIME,
    pftCacheResync: ?*FILETIME,
    cbMaxUrlRetrievalByteCount: u32,
};

pub const CRL_REVOCATION_INFO = extern struct {
    pCrlEntry: ?*CRL_ENTRY,
    pCrlContext: ?*CRL_CONTEXT,
    pCrlIssuerChain: ?*CERT_CHAIN_CONTEXT,
};

pub const PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = *const fn (
    p_cert: ?*const CERT_CONTEXT,
    pv_find_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_FIND_BY_ISSUER_PARA = extern struct {
    cbSize: u32,
    pszUsageIdentifier: ?[*:0]const u8,
    dwKeySpec: u32,
    dwAcquirePrivateKeyFlags: u32,
    cIssuer: u32,
    rgIssuer: ?*CRYPTOAPI_BLOB,
    pfnFindCallback: ?PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pvFindArg: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwFlags: CERT_CHAIN_POLICY_FLAGS,
    pvExtraPolicyPara: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    lChainIndex: i32,
    lElementIndex: i32,
    pvExtraPolicyStatus: ?*anyopaque,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    pSignerInfo: ?*CMSG_SIGNER_INFO,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    fCommercial: BOOL,
};

pub const AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    fCommercial: BOOL,
};

pub const HTTPSPolicyCallbackData = extern struct {
    Anonymous: extern union {
        cbStruct: u32,
        cbSize: u32,
    },
    dwAuthType: HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE,
    fdwChecks: u32,
    pwszServerName: ?PWSTR,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRootProgramQualifierFlags: CERT_ROOT_PROGRAM_FLAGS,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwQualifiers: u32,
    dwIssuanceUsageIndex: u32,
};

pub const SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwErrorLevel: u32,
    dwErrorCategory: u32,
    dwReserved: u32,
    wszErrorText: [256]u16,
};

pub const SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?PWSTR,
    rgpszHpkpValue: [2]?PSTR,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?[*:0]const u16,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    lError: i32,
    wszErrorText: [512]u16,
};

pub const CRYPT_PKCS12_PBE_PARAMS = extern struct {
    iIterations: i32,
    cbSalt: u32,
};

pub const PKCS12_PBES2_EXPORT_PARAMS = extern struct {
    dwSize: u32,
    hNcryptDescriptor: ?*anyopaque,
    pwszPbes2Alg: ?PWSTR,
};

pub const CERT_SERVER_OCSP_RESPONSE_CONTEXT = extern struct {
    cbSize: u32,
    pbEncodedOcspResponse: ?*u8,
    cbEncodedOcspResponse: u32,
};

pub const PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = *const fn (
    p_chain_context: ?*CERT_CHAIN_CONTEXT,
    p_server_ocsp_response_context: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
    p_new_crl_context: ?*CRL_CONTEXT,
    p_prev_crl_context: ?*CRL_CONTEXT,
    pv_arg: ?*anyopaque,
    dw_write_ocsp_file_error: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pcbUsedSize: ?*u32,
    pwszOcspDirectory: ?PWSTR,
    pfnUpdateCallback: ?PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pvUpdateCallbackArg: ?*anyopaque,
};

pub const CERT_SELECT_CHAIN_PARA = extern struct {
    hChainEngine: ?HCERTCHAINENGINE,
    pTime: ?*FILETIME,
    hAdditionalStore: ?HCERTSTORE,
    pChainPara: ?*CERT_CHAIN_PARA,
    dwFlags: u32,
};

pub const CERT_SELECT_CRITERIA = extern struct {
    dwType: CERT_SELECT_CRITERIA_TYPE,
    cPara: u32,
    ppPara: ?*?*anyopaque,
};

pub const CRYPT_TIMESTAMP_REQUEST = extern struct {
    dwVersion: CRYPT_TIMESTAMP_VERSION,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    pszTSAPolicyId: ?PSTR,
    Nonce: CRYPTOAPI_BLOB,
    fCertReq: BOOL,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_RESPONSE = extern struct {
    dwStatus: CRYPT_TIMESTAMP_RESPONSE_STATUS,
    cFreeText: u32,
    rgFreeText: ?*?PWSTR,
    FailureInfo: CRYPT_BIT_BLOB,
    ContentInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_TIMESTAMP_ACCURACY = extern struct {
    dwSeconds: u32,
    dwMillis: u32,
    dwMicros: u32,
};

pub const CRYPT_TIMESTAMP_INFO = extern struct {
    dwVersion: u32,
    pszTSAPolicyId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    ftTime: FILETIME,
    pvAccuracy: ?*CRYPT_TIMESTAMP_ACCURACY,
    fOrdering: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    Tsa: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_CONTEXT = extern struct {
    cbEncoded: u32,
    pbEncoded: ?*u8,
    pTimeStamp: ?*CRYPT_TIMESTAMP_INFO,
};

pub const CRYPT_TIMESTAMP_PARA = extern struct {
    pszTSAPolicyId: ?[*:0]const u8,
    fRequestCerts: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = *const fn (
    p_context: ?*anyopaque,
    rg_identifier_or_name_list: [*]?*CRYPTOAPI_BLOB,
    dw_identifier_or_name_list_count: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = *const fn (
    p_plugin_context: ?*anyopaque,
    p_identifier: ?*CRYPTOAPI_BLOB,
    dw_name_type: u32,
    p_name_blob: ?*CRYPTOAPI_BLOB,
    ppb_content: ?*?*u8,
    pcb_content: ?*u32,
    ppwsz_password: ?*?PWSTR,
    pp_identifier: ?*?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE = *const fn (
    dw_reason: CRYPT_OBJECT_LOCATOR_RELEASE_REASON,
    p_plugin_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD = *const fn (
    p_plugin_context: ?*anyopaque,
    pwsz_password: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE = *const fn (
    p_plugin_context: ?*anyopaque,
    pb_data: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = *const fn (
    p_plugin_context: ?*anyopaque,
    p_identifier: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = extern struct {
    cbSize: u32,
    pfnGet: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pfnRelease: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pfnFreePassword: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pfnFree: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pfnFreeIdentifier: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = *const fn (
    pfn_flush: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
    p_context: ?*anyopaque,
    pdw_expected_object_count: ?*u32,
    pp_func_table: ?*?*CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
    pp_plugin_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_IS_WEAK_HASH = *const fn (
    dw_hash_use_type: u32,
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    dw_chain_flags: u32,
    p_signer_chain_context: ?*CERT_CHAIN_CONTEXT,
    p_time_stamp: ?*FILETIME,
    pwsz_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: u32,
    dwPromptFlags: u32,
    hwndApp: ?HWND,
    szPrompt: ?[*:0]const u16,
};

pub const PFNCryptStreamOutputCallback = *const fn (
    pv_callback_ctxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: usize,
    f_final: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const NCRYPT_PROTECT_STREAM_INFO = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallback,
    pvCallbackCtxt: ?*anyopaque,
};

pub const PFNCryptStreamOutputCallbackEx = *const fn (
    pv_callback_ctxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: usize,
    h_descriptor: NCRYPT_DESCRIPTOR_HANDLE,
    f_final: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const NCRYPT_PROTECT_STREAM_INFO_EX = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallbackEx,
    pvCallbackCtxt: ?*anyopaque,
};

pub const CRYPT_XML_CHARSET = enum(i32) {
    AUTO = 0,
    UTF8 = 1,
    UTF16LE = 2,
    UTF16BE = 3,
};
pub const CRYPT_XML_CHARSET_AUTO = CRYPT_XML_CHARSET.AUTO;
pub const CRYPT_XML_CHARSET_UTF8 = CRYPT_XML_CHARSET.UTF8;
pub const CRYPT_XML_CHARSET_UTF16LE = CRYPT_XML_CHARSET.UTF16LE;
pub const CRYPT_XML_CHARSET_UTF16BE = CRYPT_XML_CHARSET.UTF16BE;

pub const CRYPT_XML_BLOB = extern struct {
    dwCharset: CRYPT_XML_CHARSET,
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_DATA_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_PROPERTY_ID = enum(i32) {
    MAX_HEAP_SIZE = 1,
    SIGNATURE_LOCATION = 2,
    MAX_SIGNATURES = 3,
    DOC_DECLARATION = 4,
    XML_OUTPUT_CHARSET = 5,
};
pub const CRYPT_XML_PROPERTY_MAX_HEAP_SIZE = CRYPT_XML_PROPERTY_ID.MAX_HEAP_SIZE;
pub const CRYPT_XML_PROPERTY_SIGNATURE_LOCATION = CRYPT_XML_PROPERTY_ID.SIGNATURE_LOCATION;
pub const CRYPT_XML_PROPERTY_MAX_SIGNATURES = CRYPT_XML_PROPERTY_ID.MAX_SIGNATURES;
pub const CRYPT_XML_PROPERTY_DOC_DECLARATION = CRYPT_XML_PROPERTY_ID.DOC_DECLARATION;
pub const CRYPT_XML_PROPERTY_XML_OUTPUT_CHARSET = CRYPT_XML_PROPERTY_ID.XML_OUTPUT_CHARSET;

pub const CRYPT_XML_PROPERTY = extern struct {
    dwPropId: CRYPT_XML_PROPERTY_ID,
    pvValue: ?*const anyopaque,
    cbValue: u32,
};

pub const PFN_CRYPT_XML_WRITE_CALLBACK = *const fn (
    pv_callback_state: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_READ = *const fn (
    pv_callback_state: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*u8,
    cb_data: u32,
    pcb_read: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_CLOSE = *const fn (
    pv_callback_state: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_DATA_PROVIDER = extern struct {
    pvCallbackState: ?*anyopaque,
    cbBufferSize: u32,
    pfnRead: ?PFN_CRYPT_XML_DATA_PROVIDER_READ,
    pfnClose: ?PFN_CRYPT_XML_DATA_PROVIDER_CLOSE,
};

pub const PFN_CRYPT_XML_CREATE_TRANSFORM = *const fn (
    p_transform: ?*const CRYPT_XML_ALGORITHM,
    p_provider_in: ?*CRYPT_XML_DATA_PROVIDER,
    p_provider_out: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_STATUS = extern struct {
    cbSize: u32,
    dwErrorStatus: CRYPT_XML_STATUS_ERROR_STATUS,
    dwInfoStatus: CRYPT_XML_STATUS_INFO_STATUS,
};

pub const CRYPT_XML_ALGORITHM = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_TRANSFORM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    cbBufferSize: u32,
    dwFlags: CRYPT_XML_TRANSFORM_FLAGS,
    pfnCreateTransform: ?PFN_CRYPT_XML_CREATE_TRANSFORM,
};

pub const CRYPT_XML_TRANSFORM_CHAIN_CONFIG = extern struct {
    cbSize: u32,
    cTransformInfo: u32,
    rgpTransformInfo: ?*?*CRYPT_XML_TRANSFORM_INFO,
};

pub const CRYPT_XML_KEY_DSA_KEY_VALUE = extern struct {
    P: CRYPT_XML_DATA_BLOB,
    Q: CRYPT_XML_DATA_BLOB,
    G: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    J: CRYPT_XML_DATA_BLOB,
    Seed: CRYPT_XML_DATA_BLOB,
    Counter: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_ECDSA_KEY_VALUE = extern struct {
    wszNamedCurve: ?[*:0]const u16,
    X: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    ExplicitPara: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_KEY_RSA_KEY_VALUE = extern struct {
    Modulus: CRYPT_XML_DATA_BLOB,
    Exponent: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_VALUE = extern struct {
    dwType: CRYPT_XML_KEY_VALUE_TYPE,
    Anonymous: extern union {
        DSAKeyValue: CRYPT_XML_KEY_DSA_KEY_VALUE,
        RSAKeyValue: CRYPT_XML_KEY_RSA_KEY_VALUE,
        ECDSAKeyValue: CRYPT_XML_KEY_ECDSA_KEY_VALUE,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_ISSUER_SERIAL = extern struct {
    wszIssuer: ?[*:0]const u16,
    wszSerial: ?[*:0]const u16,
};

pub const CRYPT_XML_X509DATA_ITEM = extern struct {
    dwType: CRYPT_XML_X509DATA_TYPE,
    Anonymous: extern union {
        IssuerSerial: CRYPT_XML_ISSUER_SERIAL,
        SKI: CRYPT_XML_DATA_BLOB,
        wszSubjectName: ?[*:0]const u16,
        Certificate: CRYPT_XML_DATA_BLOB,
        CRL: CRYPT_XML_DATA_BLOB,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_X509DATA = extern struct {
    cX509Data: u32,
    rgX509Data: ?*CRYPT_XML_X509DATA_ITEM,
};

pub const CRYPT_XML_KEY_INFO_ITEM = extern struct {
    dwType: CRYPT_XML_KEYINFO_TYPE,
    Anonymous: extern union {
        wszKeyName: ?[*:0]const u16,
        KeyValue: CRYPT_XML_KEY_VALUE,
        RetrievalMethod: CRYPT_XML_BLOB,
        X509Data: CRYPT_XML_X509DATA,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_KEY_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    cKeyInfo: u32,
    rgKeyInfo: ?*CRYPT_XML_KEY_INFO_ITEM,
    hVerifyKey: BCRYPT_KEY_HANDLE,
};

pub const CRYPT_XML_REFERENCE = extern struct {
    cbSize: u32,
    hReference: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszUri: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    DigestMethod: CRYPT_XML_ALGORITHM,
    DigestValue: CRYPTOAPI_BLOB,
    cTransform: u32,
    rgTransform: ?*CRYPT_XML_ALGORITHM,
};

pub const CRYPT_XML_REFERENCES = extern struct {
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
};

pub const CRYPT_XML_SIGNED_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    Canonicalization: CRYPT_XML_ALGORITHM,
    SignatureMethod: CRYPT_XML_ALGORITHM,
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_OBJECT = extern struct {
    cbSize: u32,
    hObject: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszMimeType: ?[*:0]const u16,
    wszEncoding: ?[*:0]const u16,
    Manifest: CRYPT_XML_REFERENCES,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_SIGNATURE = extern struct {
    cbSize: u32,
    hSignature: ?*anyopaque,
    wszId: ?[*:0]const u16,
    SignedInfo: CRYPT_XML_SIGNED_INFO,
    SignatureValue: CRYPTOAPI_BLOB,
    pKeyInfo: ?*CRYPT_XML_KEY_INFO,
    cObject: u32,
    rgpObject: ?*?*CRYPT_XML_OBJECT,
};

pub const CRYPT_XML_DOC_CTXT = extern struct {
    cbSize: u32,
    hDocCtxt: ?*anyopaque,
    pTransformsConfig: ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    cSignature: u32,
    rgpSignature: ?*?*CRYPT_XML_SIGNATURE,
};

pub const CRYPT_XML_KEYINFO_PARAM = extern struct {
    wszId: ?[*:0]const u16,
    wszKeyName: ?[*:0]const u16,
    SKI: CRYPTOAPI_BLOB,
    wszSubjectName: ?[*:0]const u16,
    cCertificate: u32,
    rgCertificate: ?*CRYPTOAPI_BLOB,
    cCRL: u32,
    rgCRL: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_XML_KEYINFO_SPEC = enum(i32) {
    NONE = 0,
    ENCODED = 1,
    PARAM = 2,
};
pub const CRYPT_XML_KEYINFO_SPEC_NONE = CRYPT_XML_KEYINFO_SPEC.NONE;
pub const CRYPT_XML_KEYINFO_SPEC_ENCODED = CRYPT_XML_KEYINFO_SPEC.ENCODED;
pub const CRYPT_XML_KEYINFO_SPEC_PARAM = CRYPT_XML_KEYINFO_SPEC.PARAM;

pub const CRYPT_XML_ALGORITHM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithmURI: ?PWSTR,
    wszName: ?PWSTR,
    dwGroupId: CRYPT_XML_GROUP_ID,
    wszCNGAlgid: ?PWSTR,
    wszCNGExtraAlgid: ?PWSTR,
    dwSignFlags: u32,
    dwVerifyFlags: u32,
    pvPaddingInfo: ?*anyopaque,
    pvExtraInfo: ?*anyopaque,
};

pub const PFN_CRYPT_XML_ENUM_ALG_INFO = *const fn (
    p_info: ?*const CRYPT_XML_ALGORITHM_INFO,
    pv_arg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CryptXmlDllGetInterface = *const fn (
    dw_flags: u32,
    p_method: ?*const CRYPT_XML_ALGORITHM_INFO,
    p_interface: ?*CRYPT_XML_CRYPTOGRAPHIC_INTERFACE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllEncodeAlgorithm = *const fn (
    p_alg_info: ?*const CRYPT_XML_ALGORITHM_INFO,
    dw_charset: CRYPT_XML_CHARSET,
    pv_callback_state: ?*anyopaque,
    pfn_write: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateDigest = *const fn (
    p_digest_method: ?*const CRYPT_XML_ALGORITHM,
    pcb_size: ?*u32,
    ph_digest: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllDigestData = *const fn (
    h_digest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllFinalizeDigest = *const fn (
    h_digest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_digest: ?*u8,
    cb_digest: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCloseDigest = *const fn (
    h_digest: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllSignData = *const fn (
    p_signature_method: ?*const CRYPT_XML_ALGORITHM,
    h_crypt_prov_or_n_crypt_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dw_key_spec: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_input: ?*const u8,
    cb_input: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllVerifySignature = *const fn (
    p_signature_method: ?*const CRYPT_XML_ALGORITHM,
    h_key: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pb_input: ?*const u8,
    cb_input: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*const u8,
    cb_signature: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllGetAlgorithmInfo = *const fn (
    p_xml_algorithm: ?*const CRYPT_XML_ALGORITHM,
    pp_alg_info: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_CRYPTOGRAPHIC_INTERFACE = extern struct {
    cbSize: u32,
    fpCryptXmlEncodeAlgorithm: ?CryptXmlDllEncodeAlgorithm,
    fpCryptXmlCreateDigest: ?CryptXmlDllCreateDigest,
    fpCryptXmlDigestData: ?CryptXmlDllDigestData,
    fpCryptXmlFinalizeDigest: ?CryptXmlDllFinalizeDigest,
    fpCryptXmlCloseDigest: ?CryptXmlDllCloseDigest,
    fpCryptXmlSignData: ?CryptXmlDllSignData,
    fpCryptXmlVerifySignature: ?CryptXmlDllVerifySignature,
    fpCryptXmlGetAlgorithmInfo: ?CryptXmlDllGetAlgorithmInfo,
};

pub const CryptXmlDllEncodeKeyValue = *const fn (
    h_key: NCRYPT_KEY_HANDLE,
    dw_charset: CRYPT_XML_CHARSET,
    pv_callback_state: ?*anyopaque,
    pfn_write: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateKey = *const fn (
    p_encoded: ?*const CRYPT_XML_BLOB,
    ph_key: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const HandleType = enum(i32) {
    Asymmetric = 1,
    Symmetric = 2,
    Transform = 3,
    Hash = 4,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const PaddingMode = enum(i32) {
    None = 1,
    PKCS7 = 2,
    Zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const Direction = enum(i32) {
    Encrypt = 1,
    Decrypt = 2,
};
pub const DirectionEncrypt = Direction.Encrypt;
pub const DirectionDecrypt = Direction.Decrypt;

pub const INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    keyExchangeAlgorithm: ?PWSTR,
    signatureAlgorithm: ?PWSTR,
};

pub const INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    blockSize: i32,
    feedbackSize: i32,
};

pub const INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS = extern struct {
    inputBlockSize: i32,
    outputBlockSize: i32,
    canTransformMultipleBlocks: BOOL,
    canReuseTransform: BOOL,
};

pub const INFORMATIONCARD_HASH_CRYPTO_PARAMETERS = extern struct {
    hashSize: i32,
    transform: INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS,
};

pub const INFORMATIONCARD_CRYPTO_HANDLE = extern struct {
    type: HandleType,
    expiration: i64,
    cryptoParameters: ?*anyopaque,
};

pub const GENERIC_XML_TOKEN = extern struct {
    createDate: FILETIME align(1),
    expiryDate: FILETIME align(1),
    xmlToken: ?PWSTR align(1),
    internalTokenReference: ?PWSTR align(1),
    externalTokenReference: ?PWSTR align(1),
};

pub const POLICY_ELEMENT = extern struct {
    targetEndpointAddress: ?[*:0]const u16,
    issuerEndpointAddress: ?[*:0]const u16,
    issuedTokenParameters: ?[*:0]const u16,
    privacyNoticeLink: ?[*:0]const u16,
    privacyNoticeVersion: u32,
    useManagedPresentation: BOOL,
};

pub const ENDPOINTADDRESS = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    rawCertificate: CRYPTOAPI_BLOB,
};

pub const ENDPOINTADDRESS2 = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    identityType: u32,
    identityBytes: ?*anyopaque,
};

pub const CERTIFICATE_CHAIN_BLOB = extern struct {
    certCount: u32,
    rawCertificates: ?*CRYPTOAPI_BLOB,
};

pub const CLAIMLIST = extern struct {
    count: u32,
    claims: ?*?PWSTR,
};

pub const RECIPIENTPOLICY = extern struct {
    recipient: ENDPOINTADDRESS,
    issuer: ENDPOINTADDRESS,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

pub const RECIPIENTPOLICY2 = extern struct {
    recipient: ENDPOINTADDRESS2,
    issuer: ENDPOINTADDRESS2,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

const CLSID_CCertSrvSetupKeyInformation_Value = Guid.initString("38373906-5433-4633-b0fb-29b7e78262e1");
pub const CLSID_CCertSrvSetupKeyInformation = &CLSID_CCertSrvSetupKeyInformation_Value;

const CLSID_CCertSrvSetup_Value = Guid.initString("961f180f-f55c-413d-a9b3-7d2af4d8e42f");
pub const CLSID_CCertSrvSetup = &CLSID_CCertSrvSetup_Value;

const CLSID_CMSCEPSetup_Value = Guid.initString("aa4f5c02-8e7c-49c4-94fa-67a5cc5eadb4");
pub const CLSID_CMSCEPSetup = &CLSID_CMSCEPSetup_Value;

const CLSID_CCertificateEnrollmentServerSetup_Value = Guid.initString("9902f3bc-88af-4cf8-ae62-7140531552b6");
pub const CLSID_CCertificateEnrollmentServerSetup = &CLSID_CCertificateEnrollmentServerSetup_Value;

const CLSID_CCertificateEnrollmentPolicyServerSetup_Value = Guid.initString("afe2fa32-41b1-459d-a5de-49add8a72182");
pub const CLSID_CCertificateEnrollmentPolicyServerSetup = &CLSID_CCertificateEnrollmentPolicyServerSetup_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformation_Value = Guid.initString("6ba73778-36da-4c39-8a85-bcfa7d000793");
pub const IID_ICertSrvSetupKeyInformation = &IID_ICertSrvSetupKeyInformation_Value;
pub const ICertSrvSetupKeyInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            bstr_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            l_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            b_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            bstr_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            bstr_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExistingCACertificate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExistingCACertificate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformation,
            var_val: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getProviderName(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_ProviderName(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putProviderName(self: *const T, bstr_val_: ?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_ProviderName(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), bstr_val_);
            }
            pub inline fn getLength(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_Length(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putLength(self: *const T, l_val_: i32) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_Length(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), l_val_);
            }
            pub inline fn getExisting(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_Existing(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putExisting(self: *const T, b_val_: i16) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_Existing(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), b_val_);
            }
            pub inline fn getContainerName(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_ContainerName(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putContainerName(self: *const T, bstr_val_: ?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_ContainerName(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), bstr_val_);
            }
            pub inline fn getHashAlgorithm(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_HashAlgorithm(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putHashAlgorithm(self: *const T, bstr_val_: ?BSTR) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_HashAlgorithm(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), bstr_val_);
            }
            pub inline fn getExistingCACertificate(self: *const T, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).get_ExistingCACertificate(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), p_val_);
            }
            pub inline fn putExistingCACertificate(self: *const T, var_val_: VARIANT) HRESULT {
                return @as(*const ICertSrvSetupKeyInformation.VTable, @ptrCast(self.vtable)).put_ExistingCACertificate(@as(*const ICertSrvSetupKeyInformation, @ptrCast(self)), var_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformationCollection_Value = Guid.initString("e65c8b00-e58f-41f9-a9ec-a28d7427c844");
pub const IID_ICertSrvSetupKeyInformationCollection = &IID_ICertSrvSetupKeyInformationCollection_Value;
pub const ICertSrvSetupKeyInformationCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformationCollection,
            pp_val: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformationCollection,
            index: i32,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetupKeyInformationCollection,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const ICertSrvSetupKeyInformationCollection,
            p_i_key_information: ?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, pp_val_: ?*?*IUnknown) HRESULT {
                return @as(*const ICertSrvSetupKeyInformationCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ICertSrvSetupKeyInformationCollection, @ptrCast(self)), pp_val_);
            }
            pub inline fn getItem(self: *const T, index_: i32, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetupKeyInformationCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ICertSrvSetupKeyInformationCollection, @ptrCast(self)), index_, p_val_);
            }
            pub inline fn getCount(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const ICertSrvSetupKeyInformationCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ICertSrvSetupKeyInformationCollection, @ptrCast(self)), p_val_);
            }
            pub inline fn add(self: *const T, p_i_key_information_: ?*ICertSrvSetupKeyInformation) HRESULT {
                return @as(*const ICertSrvSetupKeyInformationCollection.VTable, @ptrCast(self.vtable)).Add(@as(*const ICertSrvSetupKeyInformationCollection, @ptrCast(self)), p_i_key_information_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CASetupProperty = enum(i32) {
    INVALID = -1,
    CATYPE = 0,
    CAKEYINFORMATION = 1,
    INTERACTIVE = 2,
    CANAME = 3,
    CADSSUFFIX = 4,
    VALIDITYPERIOD = 5,
    VALIDITYPERIODUNIT = 6,
    EXPIRATIONDATE = 7,
    PRESERVEDATABASE = 8,
    DATABASEDIRECTORY = 9,
    LOGDIRECTORY = 10,
    SHAREDFOLDER = 11,
    PARENTCAMACHINE = 12,
    PARENTCANAME = 13,
    REQUESTFILE = 14,
    WEBCAMACHINE = 15,
    WEBCANAME = 16,
};
pub const ENUM_SETUPPROP_INVALID = CASetupProperty.INVALID;
pub const ENUM_SETUPPROP_CATYPE = CASetupProperty.CATYPE;
pub const ENUM_SETUPPROP_CAKEYINFORMATION = CASetupProperty.CAKEYINFORMATION;
pub const ENUM_SETUPPROP_INTERACTIVE = CASetupProperty.INTERACTIVE;
pub const ENUM_SETUPPROP_CANAME = CASetupProperty.CANAME;
pub const ENUM_SETUPPROP_CADSSUFFIX = CASetupProperty.CADSSUFFIX;
pub const ENUM_SETUPPROP_VALIDITYPERIOD = CASetupProperty.VALIDITYPERIOD;
pub const ENUM_SETUPPROP_VALIDITYPERIODUNIT = CASetupProperty.VALIDITYPERIODUNIT;
pub const ENUM_SETUPPROP_EXPIRATIONDATE = CASetupProperty.EXPIRATIONDATE;
pub const ENUM_SETUPPROP_PRESERVEDATABASE = CASetupProperty.PRESERVEDATABASE;
pub const ENUM_SETUPPROP_DATABASEDIRECTORY = CASetupProperty.DATABASEDIRECTORY;
pub const ENUM_SETUPPROP_LOGDIRECTORY = CASetupProperty.LOGDIRECTORY;
pub const ENUM_SETUPPROP_SHAREDFOLDER = CASetupProperty.SHAREDFOLDER;
pub const ENUM_SETUPPROP_PARENTCAMACHINE = CASetupProperty.PARENTCAMACHINE;
pub const ENUM_SETUPPROP_PARENTCANAME = CASetupProperty.PARENTCANAME;
pub const ENUM_SETUPPROP_REQUESTFILE = CASetupProperty.REQUESTFILE;
pub const ENUM_SETUPPROP_WEBCAMACHINE = CASetupProperty.WEBCAMACHINE;
pub const ENUM_SETUPPROP_WEBCANAME = CASetupProperty.WEBCANAME;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetup_Value = Guid.initString("b760a1bb-4784-44c0-8f12-555f0780ff25");
pub const IID_ICertSrvSetup = &IID_ICertSrvSetup_Value;
pub const ICertSrvSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetup,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertSrvSetup,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: *const fn (
            self: *const ICertSrvSetup,
            b_server: i16,
            b_client: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASetupProperty: *const fn (
            self: *const ICertSrvSetup,
            property_id: CASetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCASetupProperty: *const fn (
            self: *const ICertSrvSetup,
            property_id: CASetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPropertyEditable: *const fn (
            self: *const ICertSrvSetup,
            property_id: CASetupProperty,
            pb_editable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedCATypes: *const fn (
            self: *const ICertSrvSetup,
            p_c_a_types: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: *const fn (
            self: *const ICertSrvSetup,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: *const fn (
            self: *const ICertSrvSetup,
            bstr_provider_name: ?BSTR,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithmList: *const fn (
            self: *const ICertSrvSetup,
            bstr_provider_name: ?BSTR,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyContainerList: *const fn (
            self: *const ICertSrvSetup,
            bstr_provider_name: ?BSTR,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExistingCACertificates: *const fn (
            self: *const ICertSrvSetup,
            pp_val: ?*?*ICertSrvSetupKeyInformationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CAImportPFX: *const fn (
            self: *const ICertSrvSetup,
            bstr_file_name: ?BSTR,
            bstr_passwd: ?BSTR,
            b_overwrite_existing_key: i16,
            pp_val: ?*?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCADistinguishedName: *const fn (
            self: *const ICertSrvSetup,
            bstr_c_a_d_n: ?BSTR,
            b_ignore_unicode: i16,
            b_overwrite_existing_key: i16,
            b_overwrite_existing_c_a_in_d_s: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDatabaseInformation: *const fn (
            self: *const ICertSrvSetup,
            bstr_d_b_directory: ?BSTR,
            bstr_log_directory: ?BSTR,
            bstr_shared_folder: ?BSTR,
            b_force_overwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParentCAInformation: *const fn (
            self: *const ICertSrvSetup,
            bstr_c_a_configuration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWebCAInformation: *const fn (
            self: *const ICertSrvSetup,
            bstr_c_a_configuration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn (
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: *const fn (
            self: *const ICertSrvSetup,
            b_client_only: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: *const fn (
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getCAErrorId(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).get_CAErrorId(@as(*const ICertSrvSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn getCAErrorString(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).get_CAErrorString(@as(*const ICertSrvSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn initializeDefaults(self: *const T, b_server_: i16, b_client_: i16) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).InitializeDefaults(@as(*const ICertSrvSetup, @ptrCast(self)), b_server_, b_client_);
            }
            pub inline fn getCASetupProperty(self: *const T, property_id_: CASetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetCASetupProperty(@as(*const ICertSrvSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn setCASetupProperty(self: *const T, property_id_: CASetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).SetCASetupProperty(@as(*const ICertSrvSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn isPropertyEditable(self: *const T, property_id_: CASetupProperty, pb_editable_: ?*i16) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).IsPropertyEditable(@as(*const ICertSrvSetup, @ptrCast(self)), property_id_, pb_editable_);
            }
            pub inline fn getSupportedCATypes(self: *const T, p_c_a_types_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetSupportedCATypes(@as(*const ICertSrvSetup, @ptrCast(self)), p_c_a_types_);
            }
            pub inline fn getProviderNameList(self: *const T, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetProviderNameList(@as(*const ICertSrvSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn getKeyLengthList(self: *const T, bstr_provider_name_: ?BSTR, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetKeyLengthList(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_provider_name_, p_val_);
            }
            pub inline fn getHashAlgorithmList(self: *const T, bstr_provider_name_: ?BSTR, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetHashAlgorithmList(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_provider_name_, p_val_);
            }
            pub inline fn getPrivateKeyContainerList(self: *const T, bstr_provider_name_: ?BSTR, p_val_: ?*VARIANT) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetPrivateKeyContainerList(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_provider_name_, p_val_);
            }
            pub inline fn getExistingCACertificates(self: *const T, pp_val_: ?*?*ICertSrvSetupKeyInformationCollection) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).GetExistingCACertificates(@as(*const ICertSrvSetup, @ptrCast(self)), pp_val_);
            }
            pub inline fn caImportPFX(self: *const T, bstr_file_name_: ?BSTR, bstr_passwd_: ?BSTR, b_overwrite_existing_key_: i16, pp_val_: ?*?*ICertSrvSetupKeyInformation) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).CAImportPFX(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_file_name_, bstr_passwd_, b_overwrite_existing_key_, pp_val_);
            }
            pub inline fn setCADistinguishedName(self: *const T, bstr_c_a_d_n_: ?BSTR, b_ignore_unicode_: i16, b_overwrite_existing_key_: i16, b_overwrite_existing_c_a_in_d_s_: i16) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).SetCADistinguishedName(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_c_a_d_n_, b_ignore_unicode_, b_overwrite_existing_key_, b_overwrite_existing_c_a_in_d_s_);
            }
            pub inline fn setDatabaseInformation(self: *const T, bstr_d_b_directory_: ?BSTR, bstr_log_directory_: ?BSTR, bstr_shared_folder_: ?BSTR, b_force_overwrite_: i16) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).SetDatabaseInformation(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_d_b_directory_, bstr_log_directory_, bstr_shared_folder_, b_force_overwrite_);
            }
            pub inline fn setParentCAInformation(self: *const T, bstr_c_a_configuration_: ?BSTR) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).SetParentCAInformation(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_c_a_configuration_);
            }
            pub inline fn setWebCAInformation(self: *const T, bstr_c_a_configuration_: ?BSTR) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).SetWebCAInformation(@as(*const ICertSrvSetup, @ptrCast(self)), bstr_c_a_configuration_);
            }
            pub inline fn install(self: *const T) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).Install(@as(*const ICertSrvSetup, @ptrCast(self)));
            }
            pub inline fn preUnInstall(self: *const T, b_client_only_: i16) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).PreUnInstall(@as(*const ICertSrvSetup, @ptrCast(self)), b_client_only_);
            }
            pub inline fn postUnInstall(self: *const T) HRESULT {
                return @as(*const ICertSrvSetup.VTable, @ptrCast(self.vtable)).PostUnInstall(@as(*const ICertSrvSetup, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MSCEPSetupProperty = enum(i32) {
    USELOCALSYSTEM = 0,
    USECHALLENGE = 1,
    RANAME_CN = 2,
    RANAME_EMAIL = 3,
    RANAME_COMPANY = 4,
    RANAME_DEPT = 5,
    RANAME_CITY = 6,
    RANAME_STATE = 7,
    RANAME_COUNTRY = 8,
    SIGNINGKEYINFORMATION = 9,
    EXCHANGEKEYINFORMATION = 10,
    CAINFORMATION = 11,
    MSCEPURL = 12,
    CHALLENGEURL = 13,
};
pub const ENUM_CEPSETUPPROP_USELOCALSYSTEM = MSCEPSetupProperty.USELOCALSYSTEM;
pub const ENUM_CEPSETUPPROP_USECHALLENGE = MSCEPSetupProperty.USECHALLENGE;
pub const ENUM_CEPSETUPPROP_RANAME_CN = MSCEPSetupProperty.RANAME_CN;
pub const ENUM_CEPSETUPPROP_RANAME_EMAIL = MSCEPSetupProperty.RANAME_EMAIL;
pub const ENUM_CEPSETUPPROP_RANAME_COMPANY = MSCEPSetupProperty.RANAME_COMPANY;
pub const ENUM_CEPSETUPPROP_RANAME_DEPT = MSCEPSetupProperty.RANAME_DEPT;
pub const ENUM_CEPSETUPPROP_RANAME_CITY = MSCEPSetupProperty.RANAME_CITY;
pub const ENUM_CEPSETUPPROP_RANAME_STATE = MSCEPSetupProperty.RANAME_STATE;
pub const ENUM_CEPSETUPPROP_RANAME_COUNTRY = MSCEPSetupProperty.RANAME_COUNTRY;
pub const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = MSCEPSetupProperty.SIGNINGKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = MSCEPSetupProperty.EXCHANGEKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_CAINFORMATION = MSCEPSetupProperty.CAINFORMATION;
pub const ENUM_CEPSETUPPROP_MSCEPURL = MSCEPSetupProperty.MSCEPURL;
pub const ENUM_CEPSETUPPROP_CHALLENGEURL = MSCEPSetupProperty.CHALLENGEURL;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IMSCEPSetup_Value = Guid.initString("4f7761bb-9f3b-4592-9ee0-9a73259c313e");
pub const IID_IMSCEPSetup = &IID_IMSCEPSetup_Value;
pub const IMSCEPSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSCEPSetup,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMSCEPSetup,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: *const fn (
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMSCEPSetupProperty: *const fn (
            self: *const IMSCEPSetup,
            property_id: MSCEPSetupProperty,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMSCEPSetupProperty: *const fn (
            self: *const IMSCEPSetup,
            property_id: MSCEPSetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: *const fn (
            self: *const IMSCEPSetup,
            bstr_user_name: ?BSTR,
            bstr_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMSCEPStoreEmpty: *const fn (
            self: *const IMSCEPSetup,
            pb_empty: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: *const fn (
            self: *const IMSCEPSetup,
            b_exchange: i16,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: *const fn (
            self: *const IMSCEPSetup,
            b_exchange: i16,
            bstr_provider_name: ?BSTR,
            p_val: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn (
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: *const fn (
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: *const fn (
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getMSCEPErrorId(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).get_MSCEPErrorId(@as(*const IMSCEPSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn getMSCEPErrorString(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).get_MSCEPErrorString(@as(*const IMSCEPSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn initializeDefaults(self: *const T) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).InitializeDefaults(@as(*const IMSCEPSetup, @ptrCast(self)));
            }
            pub inline fn getMSCEPSetupProperty(self: *const T, property_id_: MSCEPSetupProperty, p_val_: ?*VARIANT) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).GetMSCEPSetupProperty(@as(*const IMSCEPSetup, @ptrCast(self)), property_id_, p_val_);
            }
            pub inline fn setMSCEPSetupProperty(self: *const T, property_id_: MSCEPSetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).SetMSCEPSetupProperty(@as(*const IMSCEPSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn setAccountInformation(self: *const T, bstr_user_name_: ?BSTR, bstr_password_: ?BSTR) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).SetAccountInformation(@as(*const IMSCEPSetup, @ptrCast(self)), bstr_user_name_, bstr_password_);
            }
            pub inline fn isMSCEPStoreEmpty(self: *const T, pb_empty_: ?*i16) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).IsMSCEPStoreEmpty(@as(*const IMSCEPSetup, @ptrCast(self)), pb_empty_);
            }
            pub inline fn getProviderNameList(self: *const T, b_exchange_: i16, p_val_: ?*VARIANT) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).GetProviderNameList(@as(*const IMSCEPSetup, @ptrCast(self)), b_exchange_, p_val_);
            }
            pub inline fn getKeyLengthList(self: *const T, b_exchange_: i16, bstr_provider_name_: ?BSTR, p_val_: ?*VARIANT) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).GetKeyLengthList(@as(*const IMSCEPSetup, @ptrCast(self)), b_exchange_, bstr_provider_name_, p_val_);
            }
            pub inline fn install(self: *const T) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).Install(@as(*const IMSCEPSetup, @ptrCast(self)));
            }
            pub inline fn preUnInstall(self: *const T) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).PreUnInstall(@as(*const IMSCEPSetup, @ptrCast(self)));
            }
            pub inline fn postUnInstall(self: *const T) HRESULT {
                return @as(*const IMSCEPSetup.VTable, @ptrCast(self.vtable)).PostUnInstall(@as(*const IMSCEPSetup, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CESSetupProperty = enum(i32) {
    USE_IISAPPPOOLIDENTITY = 0,
    CACONFIG = 1,
    AUTHENTICATION = 2,
    SSLCERTHASH = 3,
    URL = 4,
    RENEWALONLY = 5,
    ALLOW_KEYBASED_RENEWAL = 6,
};
pub const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = CESSetupProperty.USE_IISAPPPOOLIDENTITY;
pub const ENUM_CESSETUPPROP_CACONFIG = CESSetupProperty.CACONFIG;
pub const ENUM_CESSETUPPROP_AUTHENTICATION = CESSetupProperty.AUTHENTICATION;
pub const ENUM_CESSETUPPROP_SSLCERTHASH = CESSetupProperty.SSLCERTHASH;
pub const ENUM_CESSETUPPROP_URL = CESSetupProperty.URL;
pub const ENUM_CESSETUPPROP_RENEWALONLY = CESSetupProperty.RENEWALONLY;
pub const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = CESSetupProperty.ALLOW_KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentServerSetup_Value = Guid.initString("70027fdb-9dd9-4921-8944-b35cb31bd2ec");
pub const IID_ICertificateEnrollmentServerSetup = &IID_ICertificateEnrollmentServerSetup_Value;
pub const ICertificateEnrollmentServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertificateEnrollmentServerSetup,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
            property_id: CESSetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
            property_id: CESSetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationPoolCredentials: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
            bstr_username: ?BSTR,
            bstr_password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: *const fn (
            self: *const ICertificateEnrollmentServerSetup,
            p_c_a_config: ?*VARIANT,
            p_authentication: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getErrorString(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).get_ErrorString(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn initializeInstallDefaults(self: *const T) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).InitializeInstallDefaults(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)));
            }
            pub inline fn getProperty(self: *const T, property_id_: CESSetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn setProperty(self: *const T, property_id_: CESSetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn setApplicationPoolCredentials(self: *const T, bstr_username_: ?BSTR, bstr_password_: ?BSTR) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).SetApplicationPoolCredentials(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)), bstr_username_, bstr_password_);
            }
            pub inline fn install(self: *const T) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).Install(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)));
            }
            pub inline fn unInstall(self: *const T, p_c_a_config_: ?*VARIANT, p_authentication_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentServerSetup.VTable, @ptrCast(self.vtable)).UnInstall(@as(*const ICertificateEnrollmentServerSetup, @ptrCast(self)), p_c_a_config_, p_authentication_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CEPSetupProperty = enum(i32) {
    AUTHENTICATION = 0,
    SSLCERTHASH = 1,
    URL = 2,
    KEYBASED_RENEWAL = 3,
};
pub const ENUM_CEPSETUPPROP_AUTHENTICATION = CEPSetupProperty.AUTHENTICATION;
pub const ENUM_CEPSETUPPROP_SSLCERTHASH = CEPSetupProperty.SSLCERTHASH;
pub const ENUM_CEPSETUPPROP_URL = CEPSetupProperty.URL;
pub const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = CEPSetupProperty.KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentPolicyServerSetup_Value = Guid.initString("859252cc-238c-4a88-b8fd-a37e7d04e68b");
pub const IID_ICertificateEnrollmentPolicyServerSetup = &IID_ICertificateEnrollmentPolicyServerSetup_Value;
pub const ICertificateEnrollmentPolicyServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ICertificateEnrollmentPolicyServerSetup,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: *const fn (
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const ICertificateEnrollmentPolicyServerSetup,
            property_id: CEPSetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn (
            self: *const ICertificateEnrollmentPolicyServerSetup,
            property_id: CEPSetupProperty,
            p_property_value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn (
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: *const fn (
            self: *const ICertificateEnrollmentPolicyServerSetup,
            p_auth_key_based_renewal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getErrorString(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).get_ErrorString(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)), p_val_);
            }
            pub inline fn initializeInstallDefaults(self: *const T) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).InitializeInstallDefaults(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)));
            }
            pub inline fn getProperty(self: *const T, property_id_: CEPSetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn setProperty(self: *const T, property_id_: CEPSetupProperty, p_property_value_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)), property_id_, p_property_value_);
            }
            pub inline fn install(self: *const T) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).Install(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)));
            }
            pub inline fn unInstall(self: *const T, p_auth_key_based_renewal_: ?*VARIANT) HRESULT {
                return @as(*const ICertificateEnrollmentPolicyServerSetup.VTable, @ptrCast(self.vtable)).UnInstall(@as(*const ICertificateEnrollmentPolicyServerSetup, @ptrCast(self)), p_auth_key_based_renewal_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (397)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptAcquireContextA(
    ph_prov: ?*usize,
    sz_container: ?[*:0]const u8,
    sz_provider: ?[*:0]const u8,
    dw_prov_type: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptAcquireContextW(
    ph_prov: ?*usize,
    sz_container: ?[*:0]const u16,
    sz_provider: ?[*:0]const u16,
    dw_prov_type: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptReleaseContext(
    h_prov: usize,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGenKey(
    h_prov: usize,
    algid: u32,
    dw_flags: CRYPT_KEY_FLAGS,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDeriveKey(
    h_prov: usize,
    algid: u32,
    h_base_data: usize,
    dw_flags: u32,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDestroyKey(
    h_key: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetKeyParam(
    h_key: usize,
    dw_param: CRYPT_KEY_PARAM_ID,
    pb_data: ?*const u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetKeyParam(
    h_key: usize,
    dw_param: CRYPT_KEY_PARAM_ID,
    // TODO: what to do with BytesParamIndex 3?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetHashParam(
    h_hash: usize,
    dw_param: CRYPT_SET_HASH_PARAM,
    pb_data: ?*const u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetHashParam(
    h_hash: usize,
    dw_param: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProvParam(
    h_prov: usize,
    dw_param: CRYPT_SET_PROV_PARAM_ID,
    pb_data: ?*const u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetProvParam(
    h_prov: usize,
    dw_param: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGenRandom(
    h_prov: usize,
    dw_len: u32,
    // TODO: what to do with BytesParamIndex 1?
    pb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetUserKey(
    h_prov: usize,
    dw_key_spec: u32,
    ph_user_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptExportKey(
    h_key: usize,
    h_exp_key: usize,
    dw_blob_type: u32,
    dw_flags: CRYPT_KEY_FLAGS,
    // TODO: what to do with BytesParamIndex 5?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptImportKey(
    h_prov: usize,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    dw_data_len: u32,
    h_pub_key: usize,
    dw_flags: CRYPT_KEY_FLAGS,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEncrypt(
    h_key: usize,
    h_hash: usize,
    final: BOOL,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
    dw_buf_len: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDecrypt(
    h_key: usize,
    h_hash: usize,
    final: BOOL,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_data: ?*u8,
    pdw_data_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptCreateHash(
    h_prov: usize,
    algid: u32,
    h_key: usize,
    dw_flags: u32,
    ph_hash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptHashData(
    h_hash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    dw_data_len: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptHashSessionKey(
    h_hash: usize,
    h_key: usize,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDestroyHash(
    h_hash: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSignHashA(
    h_hash: usize,
    dw_key_spec: u32,
    sz_description: ?[*:0]const u8,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*u8,
    pdw_sig_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSignHashW(
    h_hash: usize,
    dw_key_spec: u32,
    sz_description: ?[*:0]const u16,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*u8,
    pdw_sig_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptVerifySignatureA(
    h_hash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pb_signature: ?*const u8,
    dw_sig_len: u32,
    h_pub_key: usize,
    sz_description: ?[*:0]const u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptVerifySignatureW(
    h_hash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pb_signature: ?*const u8,
    dw_sig_len: u32,
    h_pub_key: usize,
    sz_description: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderA(
    psz_prov_name: ?[*:0]const u8,
    dw_prov_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderW(
    psz_prov_name: ?[*:0]const u16,
    dw_prov_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderExA(
    psz_prov_name: ?[*:0]const u8,
    dw_prov_type: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderExW(
    psz_prov_name: ?[*:0]const u16,
    dw_prov_type: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetDefaultProviderA(
    dw_prov_type: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 4?
    psz_prov_name: ?PSTR,
    pcb_prov_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetDefaultProviderW(
    dw_prov_type: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 4?
    psz_prov_name: ?PWSTR,
    pcb_prov_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProviderTypesA(
    dw_index: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    pdw_prov_type: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    sz_type_name: ?PSTR,
    pcb_type_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProviderTypesW(
    dw_index: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    pdw_prov_type: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    sz_type_name: ?PWSTR,
    pcb_type_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProvidersA(
    dw_index: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    pdw_prov_type: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    sz_prov_name: ?PSTR,
    pcb_prov_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProvidersW(
    dw_index: u32,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    pdw_prov_type: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    sz_prov_name: ?PWSTR,
    pcb_prov_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptContextAddRef(
    h_prov: usize,
    pdw_reserved: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDuplicateKey(
    h_key: usize,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDuplicateHash(
    h_hash: usize,
    pdw_reserved: ?*u32,
    dw_flags: u32,
    ph_hash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptOpenAlgorithmProvider(
    ph_algorithm: ?*BCRYPT_ALG_HANDLE,
    psz_alg_id: ?[*:0]const u16,
    psz_implementation: ?[*:0]const u16,
    dw_flags: BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumAlgorithms(
    dw_alg_operations: BCRYPT_OPERATION,
    p_alg_count: ?*u32,
    pp_alg_list: ?*?*BCRYPT_ALGORITHM_IDENTIFIER,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumProviders(
    psz_alg_id: ?[*:0]const u16,
    p_impl_count: ?*u32,
    pp_impl_list: ?*?*BCRYPT_PROVIDER_NAME,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetProperty(
    h_object: ?*anyopaque,
    psz_property: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetProperty(
    h_object: ?*anyopaque,
    psz_property: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_input: ?*u8,
    cb_input: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCloseAlgorithmProvider(
    h_algorithm: BCRYPT_ALG_HANDLE,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFreeBuffer(
    pv_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateSymmetricKey(
    h_algorithm: BCRYPT_ALG_HANDLE,
    ph_key: ?*BCRYPT_KEY_HANDLE,
    pb_key_object: ?*u8,
    cb_key_object: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_secret: ?*u8,
    cb_secret: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateKeyPair(
    h_algorithm: BCRYPT_ALG_HANDLE,
    ph_key: ?*BCRYPT_KEY_HANDLE,
    dw_length: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEncrypt(
    h_key: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_input: ?*u8,
    cb_input: u32,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_i_v: ?*u8,
    cb_i_v: u32,
    // TODO: what to do with BytesParamIndex 7?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDecrypt(
    h_key: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_input: ?*u8,
    cb_input: u32,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_i_v: ?*u8,
    cb_i_v: u32,
    // TODO: what to do with BytesParamIndex 7?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptExportKey(
    h_key: BCRYPT_KEY_HANDLE,
    h_export_key: BCRYPT_KEY_HANDLE,
    psz_blob_type: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKey(
    h_algorithm: BCRYPT_ALG_HANDLE,
    h_import_key: BCRYPT_KEY_HANDLE,
    psz_blob_type: ?[*:0]const u16,
    ph_key: ?*BCRYPT_KEY_HANDLE,
    pb_key_object: ?*u8,
    cb_key_object: u32,
    // TODO: what to do with BytesParamIndex 7?
    pb_input: ?*u8,
    cb_input: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKeyPair(
    h_algorithm: BCRYPT_ALG_HANDLE,
    h_import_key: BCRYPT_KEY_HANDLE,
    psz_blob_type: ?[*:0]const u16,
    ph_key: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 5?
    pb_input: ?*u8,
    cb_input: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateKey(
    h_key: BCRYPT_KEY_HANDLE,
    ph_new_key: ?*BCRYPT_KEY_HANDLE,
    pb_key_object: ?*u8,
    cb_key_object: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinalizeKeyPair(
    h_key: BCRYPT_KEY_HANDLE,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyKey(
    h_key: BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroySecret(
    h_secret: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSignHash(
    h_key: BCRYPT_KEY_HANDLE,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pb_input: ?*u8,
    cb_input: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptVerifySignature(
    h_key: BCRYPT_KEY_HANDLE,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pb_hash: ?*u8,
    cb_hash: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*u8,
    cb_signature: u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSecretAgreement(
    h_priv_key: BCRYPT_KEY_HANDLE,
    h_pub_key: BCRYPT_KEY_HANDLE,
    ph_agreed_secret: ?*?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeriveKey(
    h_shared_secret: ?*anyopaque,
    pwsz_k_d_f: ?[*:0]const u16,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptKeyDerivation(
    h_key: BCRYPT_KEY_HANDLE,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateHash(
    h_algorithm: BCRYPT_ALG_HANDLE,
    ph_hash: ?*?*anyopaque,
    pb_hash_object: ?*u8,
    cb_hash_object: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_secret: ?*u8,
    cb_secret: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptHashData(
    h_hash: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_input: ?*u8,
    cb_input: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinishHash(
    h_hash: ?*anyopaque,
    pb_output: ?*u8,
    cb_output: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptCreateMultiHash(
    h_algorithm: BCRYPT_ALG_HANDLE,
    ph_hash: ?*?*anyopaque,
    n_hashes: u32,
    pb_hash_object: ?*u8,
    cb_hash_object: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_secret: ?*u8,
    cb_secret: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptProcessMultiOperations(
    h_object: ?*anyopaque,
    operation_type: BCRYPT_MULTI_OPERATION_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    p_operations: ?*anyopaque,
    cb_operations: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateHash(
    h_hash: ?*anyopaque,
    ph_new_hash: ?*?*anyopaque,
    pb_hash_object: ?*u8,
    cb_hash_object: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyHash(
    h_hash: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "bcrypt" fn BCryptHash(
    h_algorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_secret: ?*u8,
    cb_secret: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_input: ?*u8,
    cb_input: u32,
    pb_output: ?*u8,
    cb_output: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenRandom(
    h_algorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_buffer: ?*u8,
    cb_buffer: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyCapi(
    h_hash: ?*anyopaque,
    h_target_alg: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyPBKDF2(
    h_prf: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_password: ?*u8,
    cb_password: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_salt: ?*u8,
    cb_salt: u32,
    c_iterations: u64,
    // TODO: what to do with BytesParamIndex 7?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryProviderRegistration(
    psz_provider: ?[*:0]const u16,
    dw_mode: BCRYPT_QUERY_PROVIDER_MODE,
    dw_interface: BCRYPT_INTERFACE,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pp_buffer: ?*?*CRYPT_PROVIDER_REG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumRegisteredProviders(
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    pp_buffer: ?*?*CRYPT_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateContext(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    p_config: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeleteContext(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContexts(
    dw_table: BCRYPT_TABLE,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    pp_buffer: ?*?*CRYPT_CONTEXTS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContext(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    p_config: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextConfiguration(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    pp_buffer: ?*?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptAddContextFunction(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    dw_position: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRemoveContextFunction(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctions(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pp_buffer: ?*?*CRYPT_CONTEXT_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContextFunction(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    p_config: ?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionConfiguration(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pp_buffer: ?*?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctionProviders(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pp_buffer: ?*?*CRYPT_CONTEXT_FUNCTION_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetContextFunctionProperty(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    psz_property: ?[*:0]const u16,
    cb_value: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_value: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionProperty(
    dw_table: BCRYPT_TABLE,
    psz_context: ?[*:0]const u16,
    dw_interface: BCRYPT_INTERFACE,
    psz_function: ?[*:0]const u16,
    psz_property: ?[*:0]const u16,
    pcb_value: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    ppb_value: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRegisterConfigChangeNotify(
    ph_event: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptUnregisterConfigChangeNotify(
    h_event: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptResolveProviders(
    psz_context: ?[*:0]const u16,
    dw_interface: u32,
    psz_function: ?[*:0]const u16,
    psz_provider: ?[*:0]const u16,
    dw_mode: BCRYPT_QUERY_PROVIDER_MODE,
    dw_flags: BCRYPT_RESOLVE_PROVIDERS_FLAGS,
    pcb_buffer: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pp_buffer: ?*?*CRYPT_PROVIDER_REFS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetFipsAlgorithmMode(
    pf_enabled: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptOpenStorageProvider(
    ph_provider: ?*NCRYPT_PROV_HANDLE,
    psz_provider_name: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumAlgorithms(
    h_provider: NCRYPT_PROV_HANDLE,
    dw_alg_operations: NCRYPT_OPERATION,
    pdw_alg_count: ?*u32,
    pp_alg_list: ?*?*NCryptAlgorithmName,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsAlgSupported(
    h_provider: NCRYPT_PROV_HANDLE,
    psz_alg_id: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumKeys(
    h_provider: NCRYPT_PROV_HANDLE,
    psz_scope: ?[*:0]const u16,
    pp_key_name: ?*?*NCryptKeyName,
    pp_enum_state: ?*?*anyopaque,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumStorageProviders(
    pdw_provider_count: ?*u32,
    pp_provider_list: ?*?*NCryptProviderName,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeBuffer(
    pv_input: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptOpenKey() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptCreatePersistedKey(
    h_provider: NCRYPT_PROV_HANDLE,
    ph_key: ?*NCRYPT_KEY_HANDLE,
    psz_alg_id: ?[*:0]const u16,
    psz_key_name: ?[*:0]const u16,
    dw_legacy_key_spec: CERT_KEY_SPEC,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptGetProperty(
    h_object: NCRYPT_HANDLE,
    psz_property: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: OBJECT_SECURITY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSetProperty(
    h_object: NCRYPT_HANDLE,
    psz_property: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_input: ?*u8,
    cb_input: u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFinalizeKey(
    h_key: NCRYPT_KEY_HANDLE,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEncrypt(
    h_key: NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_input: ?*u8,
    cb_input: u32,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDecrypt(
    h_key: NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_input: ?*u8,
    cb_input: u32,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptImportKey(
    h_provider: NCRYPT_PROV_HANDLE,
    h_import_key: NCRYPT_KEY_HANDLE,
    psz_blob_type: ?[*:0]const u16,
    p_parameter_list: ?*BCryptBufferDesc,
    ph_key: ?*NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 6?
    pb_data: ?*u8,
    cb_data: u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptExportKey(
    h_key: NCRYPT_KEY_HANDLE,
    h_export_key: NCRYPT_KEY_HANDLE,
    psz_blob_type: ?[*:0]const u16,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pb_output: ?*u8,
    cb_output: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSignHash(
    h_key: NCRYPT_KEY_HANDLE,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pb_hash_value: ?*u8,
    cb_hash_value: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*u8,
    cb_signature: u32,
    pcb_result: ?*u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptVerifySignature(
    h_key: NCRYPT_KEY_HANDLE,
    p_padding_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pb_hash_value: ?*u8,
    cb_hash_value: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signature: ?*u8,
    cb_signature: u32,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeleteKey(
    h_key: NCRYPT_KEY_HANDLE,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeObject(
    h_object: NCRYPT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsKeyHandle(
    h_key: NCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptTranslateHandle() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptNotifyChangeKey(
    h_provider: NCRYPT_PROV_HANDLE,
    ph_event: ?*?HANDLE,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSecretAgreement(
    h_priv_key: NCRYPT_KEY_HANDLE,
    h_pub_key: NCRYPT_KEY_HANDLE,
    ph_agreed_secret: ?*NCRYPT_SECRET_HANDLE,
    dw_flags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeriveKey(
    h_shared_secret: NCRYPT_SECRET_HANDLE,
    pwsz_k_d_f: ?[*:0]const u16,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptKeyDerivation(
    h_key: NCRYPT_KEY_HANDLE,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pb_derived_key: ?*u8,
    cb_derived_key: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptCreateClaim(
    h_subject_key: NCRYPT_KEY_HANDLE,
    h_authority_key: NCRYPT_KEY_HANDLE,
    dw_claim_type: u32,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pb_claim_blob: ?*u8,
    cb_claim_blob: u32,
    pcb_result: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptVerifyClaim(
    h_subject_key: NCRYPT_KEY_HANDLE,
    h_authority_key: NCRYPT_KEY_HANDLE,
    dw_claim_type: u32,
    p_parameter_list: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pb_claim_blob: ?*u8,
    cb_claim_blob: u32,
    p_output: ?*BCryptBufferDesc,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFormatObject(
    dw_cert_encoding_type: u32,
    dw_format_type: u32,
    dw_format_str_type: u32,
    p_format_struct: ?*anyopaque,
    lpsz_struct_type: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 6?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    // TODO: what to do with BytesParamIndex 8?
    pb_format: ?*anyopaque,
    pcb_format: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncodeObjectEx(
    dw_cert_encoding_type: CERT_QUERY_ENCODING_TYPE,
    lpsz_struct_type: ?[*:0]const u8,
    pv_struct_info: ?*const anyopaque,
    dw_flags: CRYPT_ENCODE_OBJECT_FLAGS,
    p_encode_para: ?*CRYPT_ENCODE_PARA,
    pv_encoded: ?*anyopaque,
    pcb_encoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncodeObject(
    dw_cert_encoding_type: u32,
    lpsz_struct_type: ?[*:0]const u8,
    pv_struct_info: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pb_encoded: ?*u8,
    pcb_encoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeObjectEx(
    dw_cert_encoding_type: u32,
    lpsz_struct_type: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    dw_flags: u32,
    p_decode_para: ?*CRYPT_DECODE_PARA,
    pv_struct_info: ?*anyopaque,
    pcb_struct_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeObject(
    dw_cert_encoding_type: u32,
    lpsz_struct_type: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pv_struct_info: ?*anyopaque,
    pcb_struct_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInstallOIDFunctionAddress(
    h_module: ?HINSTANCE,
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    c_func_entry: u32,
    rg_func_entry: [*]const CRYPT_OID_FUNC_ENTRY,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInitOIDFunctionSet(
    psz_func_name: ?[*:0]const u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetOIDFunctionAddress(
    h_func_set: ?*anyopaque,
    dw_encoding_type: u32,
    psz_o_i_d: ?[*:0]const u8,
    dw_flags: u32,
    ppv_func_addr: ?*?*anyopaque,
    ph_func_addr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetDefaultOIDDllList(
    h_func_set: ?*anyopaque,
    dw_encoding_type: u32,
    pwsz_dll_list: ?[*:0]u16,
    pcch_dll_list: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetDefaultOIDFunctionAddress(
    h_func_set: ?*anyopaque,
    dw_encoding_type: u32,
    pwsz_dll: ?[*:0]const u16,
    dw_flags: u32,
    ppv_func_addr: ?*?*anyopaque,
    ph_func_addr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFreeOIDFunctionAddress(
    h_func_addr: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterOIDFunction(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
    pwsz_dll: ?[*:0]const u16,
    psz_override_func_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterOIDFunction(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterDefaultOIDFunction(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    dw_index: u32,
    pwsz_dll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterDefaultOIDFunction(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    pwsz_dll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSetOIDFunctionValue(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
    pwsz_value_name: ?[*:0]const u16,
    dw_value_type: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 6?
    pb_value_data: ?*const u8,
    cb_value_data: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetOIDFunctionValue(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
    pwsz_value_name: ?[*:0]const u16,
    pdw_value_type: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_value_data: ?*u8,
    pcb_value_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumOIDFunction(
    dw_encoding_type: u32,
    psz_func_name: ?[*:0]const u8,
    psz_o_i_d: ?[*:0]const u8,
    dw_flags: u32,
    pv_arg: ?*anyopaque,
    pfn_enum_o_i_d_func: ?PFN_CRYPT_ENUM_OID_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindOIDInfo(
    dw_key_type: u32,
    pv_key: ?*anyopaque,
    dw_group_id: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_OID_INFO;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterOIDInfo(
    p_info: ?*CRYPT_OID_INFO,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterOIDInfo(
    p_info: ?*CRYPT_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumOIDInfo(
    dw_group_id: u32,
    dw_flags: u32,
    pv_arg: ?*anyopaque,
    pfn_enum_o_i_d_info: ?PFN_CRYPT_ENUM_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindLocalizedName(
    pwsz_crypt_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgOpenToEncode(
    dw_msg_encoding_type: u32,
    dw_flags: u32,
    dw_msg_type: CRYPT_MSG_TYPE,
    pv_msg_encode_info: ?*const anyopaque,
    psz_inner_content_obj_i_d: ?PSTR,
    p_stream_info: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCalculateEncodedLength(
    dw_msg_encoding_type: u32,
    dw_flags: u32,
    dw_msg_type: u32,
    pv_msg_encode_info: ?*const anyopaque,
    psz_inner_content_obj_i_d: ?PSTR,
    cb_data: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgOpenToDecode(
    dw_msg_encoding_type: u32,
    dw_flags: u32,
    dw_msg_type: u32,
    h_crypt_prov: HCRYPTPROV_LEGACY,
    p_recipient_info: ?*CERT_INFO,
    p_stream_info: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgDuplicate(
    h_crypt_msg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgClose(
    h_crypt_msg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgUpdate(
    h_crypt_msg: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: u32,
    f_final: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgGetParam(
    h_crypt_msg: ?*anyopaque,
    dw_param_type: u32,
    dw_index: u32,
    // TODO: what to do with BytesParamIndex 4?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgControl(
    h_crypt_msg: ?*anyopaque,
    dw_flags: u32,
    dw_ctrl_type: u32,
    pv_ctrl_para: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncoded(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_signer_info: ?*u8,
    cb_signer_info: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signer_info_countersignature: ?*u8,
    cb_signer_info_countersignature: u32,
    pci_countersigner: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncodedEx(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_signer_info: ?*u8,
    cb_signer_info: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_signer_info_countersignature: ?*u8,
    cb_signer_info_countersignature: u32,
    dw_signer_type: u32,
    pv_signer: ?*anyopaque,
    dw_flags: u32,
    pv_extra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCountersign(
    h_crypt_msg: ?*anyopaque,
    dw_index: u32,
    c_countersigners: u32,
    rg_countersigners: [*]CMSG_SIGNER_ENCODE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCountersignEncoded(
    dw_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_signer_info: ?*u8,
    cb_signer_info: u32,
    c_countersigners: u32,
    rg_countersigners: [*]CMSG_SIGNER_ENCODE_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pb_countersignature: ?*u8,
    pcb_countersignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenStore(
    lpsz_store_provider: ?[*:0]const u8,
    dw_encoding_type: CERT_QUERY_ENCODING_TYPE,
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_flags: CERT_OPEN_STORE_FLAGS,
    pv_para: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateStore(
    h_cert_store: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSaveStore(
    h_cert_store: ?HCERTSTORE,
    dw_encoding_type: CERT_QUERY_ENCODING_TYPE,
    dw_save_as: CERT_STORE_SAVE_AS,
    dw_save_to: CERT_STORE_SAVE_TO,
    pv_save_to_para: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCloseStore(
    h_cert_store: ?HCERTSTORE,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetSubjectCertificateFromStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    p_cert_id: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCertificatesInStore(
    h_cert_store: ?HCERTSTORE,
    p_prev_cert_context: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCertificateInStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    dw_find_flags: u32,
    dw_find_type: CERT_FIND_FLAGS,
    pv_find_para: ?*const anyopaque,
    p_prev_cert_context: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetIssuerCertificateFromStore(
    h_cert_store: ?HCERTSTORE,
    p_subject_context: ?*const CERT_CONTEXT,
    p_prev_issuer_context: ?*const CERT_CONTEXT,
    pdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifySubjectCertificateContext(
    p_subject: ?*const CERT_CONTEXT,
    p_issuer: ?*const CERT_CONTEXT,
    pdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCertificateContext(
    p_cert_context: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCertificateContext(
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_cert_encoded: ?*const u8,
    cb_cert_encoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateContext(
    p_cert_context: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCertificateContextProperty(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCertificateContextProperty(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_prop_id: u32,
    // TODO: what to do with BytesParamIndex 3?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCertificateContextProperties(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_prop_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCTLEntryFromCertificateContextProperties(
    p_cert_context: ?*const CERT_CONTEXT,
    c_opt_attr: u32,
    rg_opt_attr: ?[*]CRYPT_ATTRIBUTE,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    p_ctl_entry: ?*CTL_ENTRY,
    pcb_ctl_entry: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCertificateContextPropertiesFromCTLEntry(
    p_cert_context: ?*const CERT_CONTEXT,
    p_ctl_entry: ?*CTL_ENTRY,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCRLFromStore(
    h_cert_store: ?HCERTSTORE,
    p_issuer_context: ?*const CERT_CONTEXT,
    p_prev_crl_context: ?*CRL_CONTEXT,
    pdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCRLsInStore(
    h_cert_store: ?HCERTSTORE,
    p_prev_crl_context: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCRLInStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    dw_find_flags: u32,
    dw_find_type: u32,
    pv_find_para: ?*const anyopaque,
    p_prev_crl_context: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCRLContext(
    p_crl_context: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCRLContext(
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_crl_encoded: ?*const u8,
    cb_crl_encoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCRLContext(
    p_crl_context: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCRLContextProperty(
    p_crl_context: ?*CRL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCRLContextProperty(
    p_crl_context: ?*CRL_CONTEXT,
    dw_prop_id: u32,
    // TODO: what to do with BytesParamIndex 3?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCRLContextProperties(
    p_crl_context: ?*CRL_CONTEXT,
    dw_prop_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCertificateInCRL(
    p_cert: ?*const CERT_CONTEXT,
    p_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    pp_crl_entry: ?*?*CRL_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertIsValidCRLForCertificate(
    p_cert: ?*const CERT_CONTEXT,
    p_crl: ?*CRL_CONTEXT,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_cert_encoded: ?*const u8,
    cb_cert_encoded: u32,
    dw_add_disposition: u32,
    pp_cert_context: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCertificateContextToStore(
    h_cert_store: ?HCERTSTORE,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddSerializedElementToStore(
    h_cert_store: ?HCERTSTORE,
    // TODO: what to do with BytesParamIndex 2?
    pb_element: ?*const u8,
    cb_element: u32,
    dw_add_disposition: u32,
    dw_flags: u32,
    dw_context_type_flags: u32,
    pdw_context_type: ?*u32,
    ppv_context: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCertificateFromStore(
    p_cert_context: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCRLToStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_crl_encoded: ?*const u8,
    cb_crl_encoded: u32,
    dw_add_disposition: u32,
    pp_crl_context: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCRLContextToStore(
    h_cert_store: ?HCERTSTORE,
    p_crl_context: ?*CRL_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCRLFromStore(
    p_crl_context: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCertificateStoreElement(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_element: ?*u8,
    pcb_element: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCRLStoreElement(
    p_crl_context: ?*CRL_CONTEXT,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_element: ?*u8,
    pcb_element: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCTLContext(
    p_ctl_context: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCTLContext(
    dw_msg_and_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_ctl_encoded: ?*const u8,
    cb_ctl_encoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCTLContext(
    p_ctl_context: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCTLContextProperty(
    p_ctl_context: ?*CTL_CONTEXT,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCTLContextProperty(
    p_ctl_context: ?*CTL_CONTEXT,
    dw_prop_id: u32,
    // TODO: what to do with BytesParamIndex 3?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCTLContextProperties(
    p_ctl_context: ?*CTL_CONTEXT,
    dw_prop_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCTLsInStore(
    h_cert_store: ?HCERTSTORE,
    p_prev_ctl_context: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindSubjectInCTL(
    dw_encoding_type: u32,
    dw_subject_type: u32,
    pv_subject: ?*anyopaque,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCTLInStore(
    h_cert_store: ?HCERTSTORE,
    dw_msg_and_cert_encoding_type: u32,
    dw_find_flags: u32,
    dw_find_type: CERT_FIND_TYPE,
    pv_find_para: ?*const anyopaque,
    p_prev_ctl_context: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCTLToStore(
    h_cert_store: ?HCERTSTORE,
    dw_msg_and_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_ctl_encoded: ?*const u8,
    cb_ctl_encoded: u32,
    dw_add_disposition: u32,
    pp_ctl_context: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCTLContextToStore(
    h_cert_store: ?HCERTSTORE,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCTLStoreElement(
    p_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_element: ?*u8,
    pcb_element: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCTLFromStore(
    p_ctl_context: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCertificateLinkToStore(
    h_cert_store: ?HCERTSTORE,
    p_cert_context: ?*const CERT_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCRLLinkToStore(
    h_cert_store: ?HCERTSTORE,
    p_crl_context: ?*CRL_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCTLLinkToStore(
    h_cert_store: ?HCERTSTORE,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_add_disposition: u32,
    pp_store_context: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddStoreToCollection(
    h_collection_store: ?HCERTSTORE,
    h_sibling_store: ?HCERTSTORE,
    dw_update_flags: u32,
    dw_priority: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRemoveStoreFromCollection(
    h_collection_store: ?HCERTSTORE,
    h_sibling_store: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertControlStore(
    h_cert_store: ?HCERTSTORE,
    dw_flags: CERT_CONTROL_STORE_FLAGS,
    dw_ctrl_type: u32,
    pv_ctrl_para: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetStoreProperty(
    h_cert_store: ?HCERTSTORE,
    dw_prop_id: u32,
    dw_flags: u32,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetStoreProperty(
    h_cert_store: ?HCERTSTORE,
    dw_prop_id: u32,
    // TODO: what to do with BytesParamIndex 3?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateContext(
    dw_context_type: u32,
    dw_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    dw_flags: u32,
    p_create_para: ?*CERT_CREATE_CONTEXT_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRegisterSystemStore(
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
    p_store_info: ?*CERT_SYSTEM_STORE_INFO,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRegisterPhysicalStore(
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
    pwsz_store_name: ?[*:0]const u16,
    p_store_info: ?*CERT_PHYSICAL_STORE_INFO,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertUnregisterSystemStore(
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertUnregisterPhysicalStore(
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
    pwsz_store_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSystemStoreLocation(
    dw_flags: u32,
    pv_arg: ?*anyopaque,
    pfn_enum: ?PFN_CERT_ENUM_SYSTEM_STORE_LOCATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSystemStore(
    dw_flags: u32,
    pv_system_store_location_para: ?*anyopaque,
    pv_arg: ?*anyopaque,
    pfn_enum: ?PFN_CERT_ENUM_SYSTEM_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumPhysicalStore(
    pv_system_store: ?*const anyopaque,
    dw_flags: u32,
    pv_arg: ?*anyopaque,
    pfn_enum: ?PFN_CERT_ENUM_PHYSICAL_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetEnhancedKeyUsage(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 3?
    p_usage: ?*CTL_USAGE,
    pcb_usage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetEnhancedKeyUsage(
    p_cert_context: ?*const CERT_CONTEXT,
    p_usage: ?*CTL_USAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEnhancedKeyUsageIdentifier(
    p_cert_context: ?*const CERT_CONTEXT,
    psz_usage_identifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRemoveEnhancedKeyUsageIdentifier(
    p_cert_context: ?*const CERT_CONTEXT,
    psz_usage_identifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetValidUsages(
    c_certs: u32,
    rgh_certs: [*]?*CERT_CONTEXT,
    c_num_o_i_ds: ?*i32,
    // TODO: what to do with BytesParamIndex 4?
    rgh_o_i_ds: ?*?PSTR,
    pcb_o_i_ds: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgGetAndVerifySigner(
    h_crypt_msg: ?*anyopaque,
    c_signer_store: u32,
    rgh_signer_store: ?[*]?HCERTSTORE,
    dw_flags: u32,
    pp_signer: ?*?*CERT_CONTEXT,
    pdw_signer_index: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgSignCTL(
    dw_msg_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_ctl_content: ?*u8,
    cb_ctl_content: u32,
    p_sign_info: ?*CMSG_SIGNED_ENCODE_INFO,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_encoded: ?*u8,
    pcb_encoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgEncodeAndSignCTL(
    dw_msg_encoding_type: u32,
    p_ctl_info: ?*CTL_INFO,
    p_sign_info: ?*CMSG_SIGNED_ENCODE_INFO,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_encoded: ?*u8,
    pcb_encoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindSubjectInSortedCTL(
    p_subject_identifier: ?*CRYPTOAPI_BLOB,
    p_ctl_context: ?*CTL_CONTEXT,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    p_encoded_attributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSubjectInSortedCTL(
    p_ctl_context: ?*CTL_CONTEXT,
    ppv_next_subject: ?*?*anyopaque,
    p_subject_identifier: ?*CRYPTOAPI_BLOB,
    p_encoded_attributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCTLUsage(
    dw_encoding_type: u32,
    dw_subject_type: u32,
    pv_subject: ?*anyopaque,
    p_subject_usage: ?*CTL_USAGE,
    dw_flags: u32,
    p_verify_usage_para: ?*CTL_VERIFY_USAGE_PARA,
    p_verify_usage_status: ?*CTL_VERIFY_USAGE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyRevocation(
    dw_encoding_type: u32,
    dw_rev_type: u32,
    c_context: u32,
    rgpv_context: [*]?*anyopaque,
    dw_flags: u32,
    p_rev_para: ?*CERT_REVOCATION_PARA,
    p_rev_status: ?*CERT_REVOCATION_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareIntegerBlob(
    p_int1: ?*CRYPTOAPI_BLOB,
    p_int2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareCertificate(
    dw_cert_encoding_type: u32,
    p_cert_id1: ?*CERT_INFO,
    p_cert_id2: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareCertificateName(
    dw_cert_encoding_type: u32,
    p_cert_name1: ?*CRYPTOAPI_BLOB,
    p_cert_name2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertIsRDNAttrsInCertificateName(
    dw_cert_encoding_type: u32,
    dw_flags: u32,
    p_cert_name: ?*CRYPTOAPI_BLOB,
    p_r_d_n: ?*CERT_RDN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertComparePublicKeyInfo(
    dw_cert_encoding_type: u32,
    p_public_key1: ?*CERT_PUBLIC_KEY_INFO,
    p_public_key2: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetPublicKeyLength(
    dw_cert_encoding_type: u32,
    p_public_key: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyCertificateSignature(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    p_public_key: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyCertificateSignatureEx(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_cert_encoding_type: u32,
    dw_subject_type: u32,
    pv_subject: ?*anyopaque,
    dw_issuer_type: u32,
    pv_issuer: ?*anyopaque,
    dw_flags: CRYPT_VERIFY_CERT_FLAGS,
    pv_extra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "crypt32" fn CertIsStrongHashToSign(
    p_strong_sign_para: ?*CERT_STRONG_SIGN_PARA,
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    p_signing_cert: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashToBeSigned(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashCertificate(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    algid: u32,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptHashCertificate2(
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pb_encoded: ?*const u8,
    cb_encoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignCertificate(
    h_crypt_prov_or_n_crypt_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dw_key_spec: u32,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_encoded_to_be_signed: ?*const u8,
    cb_encoded_to_be_signed: u32,
    p_signature_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pv_hash_aux_info: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 8?
    pb_signature: ?*u8,
    pcb_signature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
// This function from dll 'CRYPT32' is being skipped because it has some sort of issue
pub fn CryptSignAndEncodeCertificate() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyTimeValidity(
    p_time_to_verify: ?*FILETIME,
    p_cert_info: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCRLTimeValidity(
    p_time_to_verify: ?*FILETIME,
    p_crl_info: ?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyValidityNesting(
    p_subject_info: ?*CERT_INFO,
    p_issuer_info: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCRLRevocation(
    dw_cert_encoding_type: u32,
    p_cert_id: ?*CERT_INFO,
    c_crl_info: u32,
    rgp_crl_info: [*]?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAlgIdToOID(
    dw_alg_id: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOIDToAlgId(
    psz_obj_id: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindExtension(
    psz_obj_id: ?[*:0]const u8,
    c_extensions: u32,
    rg_extensions: [*]CERT_EXTENSION,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_EXTENSION;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindAttribute(
    psz_obj_id: ?[*:0]const u8,
    c_attr: u32,
    rg_attr: [*]CRYPT_ATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_ATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindRDNAttr(
    psz_obj_id: ?[*:0]const u8,
    p_name: ?*CERT_NAME_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_RDN_ATTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetIntendedKeyUsage(
    dw_cert_encoding_type: u32,
    p_cert_info: ?*CERT_INFO,
    pb_key_usage: ?*u8,
    cb_key_usage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInstallDefaultContext(
    h_crypt_prov: usize,
    dw_default_type: CRYPT_DEFAULT_CONTEXT_TYPE,
    pv_default_para: ?*const anyopaque,
    dw_flags: CRYPT_DEFAULT_CONTEXT_FLAGS,
    pv_reserved: ?*anyopaque,
    ph_default_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUninstallDefaultContext(
    h_default_context: ?*anyopaque,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPublicKeyInfo(
    h_crypt_prov_or_n_crypt_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dw_key_spec: u32,
    dw_cert_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 4?
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    pcb_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPublicKeyInfoEx(
    h_crypt_prov_or_n_crypt_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dw_key_spec: u32,
    dw_cert_encoding_type: u32,
    psz_public_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    pcb_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptExportPublicKeyInfoFromBCryptKeyHandle(
    h_b_crypt_key: BCRYPT_KEY_HANDLE,
    dw_cert_encoding_type: u32,
    psz_public_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    pcb_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPublicKeyInfo(
    h_crypt_prov: usize,
    dw_cert_encoding_type: u32,
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPublicKeyInfoEx(
    h_crypt_prov: usize,
    dw_cert_encoding_type: u32,
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    ai_key_alg: u32,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    ph_key: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptImportPublicKeyInfoEx2(
    dw_cert_encoding_type: u32,
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    dw_flags: CRYPT_IMPORT_PUBLIC_KEY_FLAGS,
    pv_aux_info: ?*anyopaque,
    ph_key: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptAcquireCertificatePrivateKey(
    p_cert: ?*const CERT_CONTEXT,
    dw_flags: CRYPT_ACQUIRE_FLAGS,
    pv_parameters: ?*anyopaque,
    ph_crypt_prov_or_n_crypt_key: ?*HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    pdw_key_spec: ?*CERT_KEY_SPEC,
    pf_caller_free_prov_or_n_crypt_key: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindCertificateKeyProvInfo(
    p_cert: ?*const CERT_CONTEXT,
    dw_flags: CRYPT_FIND_FLAGS,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPKCS8(
    s_private_key_and_params: CRYPT_PKCS8_IMPORT_PARAMS,
    dw_flags: CRYPT_KEY_FLAGS,
    ph_crypt_prov: ?*usize,
    pv_aux_info: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPKCS8(
    h_crypt_prov: usize,
    dw_key_spec: u32,
    psz_private_key_obj_id: ?PSTR,
    dw_flags: u32,
    pv_aux_info: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pb_private_key_blob: ?*u8,
    pcb_private_key_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashPublicKeyInfo(
    h_crypt_prov: HCRYPTPROV_LEGACY,
    algid: u32,
    dw_flags: u32,
    dw_cert_encoding_type: u32,
    p_info: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRDNValueToStrA(
    dw_value_type: u32,
    p_value: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRDNValueToStrW(
    dw_value_type: u32,
    p_value: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertNameToStrA(
    dw_cert_encoding_type: u32,
    p_name: ?*CRYPTOAPI_BLOB,
    dw_str_type: CERT_STRING_TYPE,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertNameToStrW(
    dw_cert_encoding_type: u32,
    p_name: ?*CRYPTOAPI_BLOB,
    dw_str_type: CERT_STRING_TYPE,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertStrToNameA(
    dw_cert_encoding_type: u32,
    psz_x500: ?[*:0]const u8,
    dw_str_type: CERT_STRING_TYPE,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_encoded: ?*u8,
    pcb_encoded: ?*u32,
    ppsz_error: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertStrToNameW(
    dw_cert_encoding_type: u32,
    psz_x500: ?[*:0]const u16,
    dw_str_type: CERT_STRING_TYPE,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pb_encoded: ?*u8,
    pcb_encoded: ?*u32,
    ppsz_error: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetNameStringA(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_type: u32,
    dw_flags: u32,
    pv_type_para: ?*anyopaque,
    psz_name_string: ?[*:0]u8,
    cch_name_string: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetNameStringW(
    p_cert_context: ?*const CERT_CONTEXT,
    dw_type: u32,
    dw_flags: u32,
    pv_type_para: ?*anyopaque,
    psz_name_string: ?[*:0]u16,
    cch_name_string: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignMessage(
    p_sign_para: ?*CRYPT_SIGN_MESSAGE_PARA,
    f_detached_signature: BOOL,
    c_to_be_signed: u32,
    rgpb_to_be_signed: ?[*]const ?*const u8,
    rgcb_to_be_signed: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_signed_blob: ?*u8,
    pcb_signed_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageSignature(
    p_verify_para: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dw_signer_index: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_signed_blob: ?*const u8,
    cb_signed_blob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_decoded: ?*u8,
    pcb_decoded: ?*u32,
    pp_signer_cert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetMessageSignerCount(
    dw_msg_encoding_type: u32,
    // TODO: what to do with BytesParamIndex 2?
    pb_signed_blob: ?*const u8,
    cb_signed_blob: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetMessageCertificates(
    dw_msg_and_cert_encoding_type: u32,
    h_crypt_prov: HCRYPTPROV_LEGACY,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_signed_blob: ?*const u8,
    cb_signed_blob: u32,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyDetachedMessageSignature(
    p_verify_para: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dw_signer_index: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_detached_sign_blob: ?*const u8,
    cb_detached_sign_blob: u32,
    c_to_be_signed: u32,
    rgpb_to_be_signed: [*]const ?*const u8,
    rgcb_to_be_signed: [*]u32,
    pp_signer_cert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncryptMessage(
    p_encrypt_para: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    c_recipient_cert: u32,
    rgp_recipient_cert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pb_to_be_encrypted: ?*const u8,
    cb_to_be_encrypted: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_encrypted_blob: ?*u8,
    pcb_encrypted_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecryptMessage(
    p_decrypt_para: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pb_encrypted_blob: ?*const u8,
    cb_encrypted_blob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_decrypted: ?*u8,
    pcb_decrypted: ?*u32,
    pp_xchg_cert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignAndEncryptMessage(
    p_sign_para: ?*CRYPT_SIGN_MESSAGE_PARA,
    p_encrypt_para: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    c_recipient_cert: u32,
    rgp_recipient_cert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 5?
    pb_to_be_signed_and_encrypted: ?*const u8,
    cb_to_be_signed_and_encrypted: u32,
    // TODO: what to do with BytesParamIndex 7?
    pb_signed_and_encrypted_blob: ?*u8,
    pcb_signed_and_encrypted_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecryptAndVerifyMessageSignature(
    p_decrypt_para: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    p_verify_para: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dw_signer_index: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_encrypted_blob: ?*const u8,
    cb_encrypted_blob: u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_decrypted: ?*u8,
    pcb_decrypted: ?*u32,
    pp_xchg_cert: ?*?*CERT_CONTEXT,
    pp_signer_cert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeMessage(
    dw_msg_type_flags: u32,
    p_decrypt_para: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    p_verify_para: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dw_signer_index: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_encoded_blob: ?*const u8,
    cb_encoded_blob: u32,
    dw_prev_inner_content_type: u32,
    pdw_msg_type: ?*u32,
    pdw_inner_content_type: ?*u32,
    // TODO: what to do with BytesParamIndex 10?
    pb_decoded: ?*u8,
    pcb_decoded: ?*u32,
    pp_xchg_cert: ?*?*CERT_CONTEXT,
    pp_signer_cert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashMessage(
    p_hash_para: ?*CRYPT_HASH_MESSAGE_PARA,
    f_detached_hash: BOOL,
    c_to_be_hashed: u32,
    rgpb_to_be_hashed: [*]const ?*const u8,
    rgcb_to_be_hashed: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_hashed_blob: ?*u8,
    pcb_hashed_blob: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageHash(
    p_hash_para: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pb_hashed_blob: ?*u8,
    cb_hashed_blob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_to_be_hashed: ?*u8,
    pcb_to_be_hashed: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyDetachedMessageHash(
    p_hash_para: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pb_detached_hash_blob: ?*u8,
    cb_detached_hash_blob: u32,
    c_to_be_hashed: u32,
    rgpb_to_be_hashed: [*]const ?*const u8,
    rgcb_to_be_hashed: [*]u32,
    // TODO: what to do with BytesParamIndex 7?
    pb_computed_hash: ?*u8,
    pcb_computed_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignMessageWithKey(
    p_sign_para: ?*CRYPT_KEY_SIGN_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pb_to_be_signed: ?*const u8,
    cb_to_be_signed: u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_signed_blob: ?*u8,
    pcb_signed_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageSignatureWithKey(
    p_verify_para: ?*CRYPT_KEY_VERIFY_MESSAGE_PARA,
    p_public_key_info: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 3?
    pb_signed_blob: ?*const u8,
    cb_signed_blob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pb_decoded: ?*u8,
    pcb_decoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenSystemStoreA(
    h_prov: HCRYPTPROV_LEGACY,
    sz_subsystem_protocol: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenSystemStoreW(
    h_prov: HCRYPTPROV_LEGACY,
    sz_subsystem_protocol: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreA(
    sz_cert_store_name: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pb_cert_encoded: ?*const u8,
    cb_cert_encoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreW(
    sz_cert_store_name: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pb_cert_encoded: ?*const u8,
    cb_cert_encoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wintrust" fn FindCertsByIssuer(
    // TODO: what to do with BytesParamIndex 1?
    p_cert_chains: ?*CERT_CHAIN,
    pcb_cert_chains: ?*u32,
    pc_cert_chains: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pb_encoded_issuer_name: ?*u8,
    cb_encoded_issuer_name: u32,
    pwsz_purpose: ?[*:0]const u16,
    dw_key_spec: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptQueryObject(
    dw_object_type: CERT_QUERY_OBJECT_TYPE,
    pv_object: ?*const anyopaque,
    dw_expected_content_type_flags: CERT_QUERY_CONTENT_TYPE_FLAGS,
    dw_expected_format_type_flags: CERT_QUERY_FORMAT_TYPE_FLAGS,
    dw_flags: u32,
    pdw_msg_and_cert_encoding_type: ?*CERT_QUERY_ENCODING_TYPE,
    pdw_content_type: ?*CERT_QUERY_CONTENT_TYPE,
    pdw_format_type: ?*CERT_QUERY_FORMAT_TYPE,
    ph_cert_store: ?*?HCERTSTORE,
    ph_msg: ?*?*anyopaque,
    ppv_context: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemAlloc(
    cb_size: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemRealloc(
    pv: ?*anyopaque,
    cb_size: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "crypt32" fn CryptCreateAsyncHandle(
    dw_flags: u32,
    ph_async: ?*?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptSetAsyncParam(
    h_async: ?HCRYPTASYNC,
    psz_param_oid: ?PSTR,
    pv_param: ?*anyopaque,
    pfn_free: ?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptGetAsyncParam(
    h_async: ?HCRYPTASYNC,
    psz_param_oid: ?PSTR,
    ppv_param: ?*?*anyopaque,
    ppfn_free: ?*?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptCloseAsyncHandle(
    h_async: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptRetrieveObjectByUrlA(
    psz_url: ?[*:0]const u8,
    psz_object_oid: ?[*:0]const u8,
    dw_retrieval_flags: u32,
    dw_timeout: u32,
    ppv_object: ?*?*anyopaque,
    h_async_retrieve: ?HCRYPTASYNC,
    p_credentials: ?*CRYPT_CREDENTIALS,
    pv_verify: ?*anyopaque,
    p_aux_info: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptRetrieveObjectByUrlW(
    psz_url: ?[*:0]const u16,
    psz_object_oid: ?[*:0]const u8,
    dw_retrieval_flags: u32,
    dw_timeout: u32,
    ppv_object: ?*?*anyopaque,
    h_async_retrieve: ?HCRYPTASYNC,
    p_credentials: ?*CRYPT_CREDENTIALS,
    pv_verify: ?*anyopaque,
    p_aux_info: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "cryptnet" fn CryptInstallCancelRetrieval(
    pfn_cancel: ?PFN_CRYPT_CANCEL_RETRIEVAL,
    pv_arg: ?*const anyopaque,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "cryptnet" fn CryptUninstallCancelRetrieval(
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptGetObjectUrl(
    psz_url_oid: ?[*:0]const u8,
    pv_para: ?*anyopaque,
    dw_flags: CRYPT_GET_URL_FLAGS,
    // TODO: what to do with BytesParamIndex 4?
    p_url_array: ?*CRYPT_URL_ARRAY,
    pcb_url_array: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    p_url_info: ?*CRYPT_URL_INFO,
    pcb_url_info: ?*u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateSelfSignCertificate(
    h_crypt_prov_or_n_crypt_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    p_subject_issuer_blob: ?*CRYPTOAPI_BLOB,
    dw_flags: CERT_CREATE_SELFSIGN_FLAGS,
    p_key_prov_info: ?*CRYPT_KEY_PROV_INFO,
    p_signature_algorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    p_start_time: ?*SYSTEMTIME,
    p_end_time: ?*SYSTEMTIME,
    p_extensions: ?*CERT_EXTENSIONS,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetKeyIdentifierProperty(
    p_key_identifier: ?*const CRYPTOAPI_BLOB,
    dw_prop_id: u32,
    dw_flags: u32,
    pwsz_computer_name: ?[*:0]const u16,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pv_data: ?*anyopaque,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSetKeyIdentifierProperty(
    p_key_identifier: ?*const CRYPTOAPI_BLOB,
    dw_prop_id: u32,
    dw_flags: u32,
    pwsz_computer_name: ?[*:0]const u16,
    pv_reserved: ?*anyopaque,
    pv_data: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumKeyIdentifierProperties(
    p_key_identifier: ?*const CRYPTOAPI_BLOB,
    dw_prop_id: u32,
    dw_flags: u32,
    pwsz_computer_name: ?[*:0]const u16,
    pv_reserved: ?*anyopaque,
    pv_arg: ?*anyopaque,
    pfn_enum: ?PFN_CRYPT_ENUM_KEYID_PROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptCreateKeyIdentifierFromCSP(
    dw_cert_encoding_type: u32,
    psz_pub_key_o_i_d: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    p_pub_key_struc: ?*const PUBLICKEYSTRUC,
    cb_pub_key_struc: u32,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    pb_hash: ?*u8,
    pcb_hash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCertificateChainEngine(
    p_config: ?*CERT_CHAIN_ENGINE_CONFIG,
    ph_chain_engine: ?*?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateChainEngine(
    h_chain_engine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "crypt32" fn CertResyncCertificateChainEngine(
    h_chain_engine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCertificateChain(
    h_chain_engine: ?HCERTCHAINENGINE,
    p_cert_context: ?*const CERT_CONTEXT,
    p_time: ?*FILETIME,
    h_additional_store: ?HCERTSTORE,
    p_chain_para: ?*CERT_CHAIN_PARA,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    pp_chain_context: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateChain(
    p_chain_context: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCertificateChain(
    p_chain_context: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindChainInStore(
    h_cert_store: ?HCERTSTORE,
    dw_cert_encoding_type: u32,
    dw_find_flags: CERT_FIND_CHAIN_IN_STORE_FLAGS,
    dw_find_type: u32,
    pv_find_para: ?*const anyopaque,
    p_prev_chain_context: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCertificateChainPolicy(
    psz_policy_o_i_d: ?[*:0]const u8,
    p_chain_context: ?*CERT_CHAIN_CONTEXT,
    p_policy_para: ?*CERT_CHAIN_POLICY_PARA,
    p_policy_status: ?*CERT_CHAIN_POLICY_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptStringToBinaryA(
    psz_string: [*:0]const u8,
    cch_string: u32,
    dw_flags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pb_binary: ?*u8,
    pcb_binary: ?*u32,
    pdw_skip: ?*u32,
    pdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptStringToBinaryW(
    psz_string: [*:0]const u16,
    cch_string: u32,
    dw_flags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pb_binary: ?*u8,
    pcb_binary: ?*u32,
    pdw_skip: ?*u32,
    pdw_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptBinaryToStringA(
    // TODO: what to do with BytesParamIndex 1?
    pb_binary: ?*const u8,
    cb_binary: u32,
    dw_flags: CRYPT_STRING,
    psz_string: ?[*:0]u8,
    pcch_string: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptBinaryToStringW(
    // TODO: what to do with BytesParamIndex 1?
    pb_binary: ?*const u8,
    cb_binary: u32,
    dw_flags: CRYPT_STRING,
    psz_string: ?[*:0]u16,
    pcch_string: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXImportCertStore(
    p_p_f_x: ?*CRYPTOAPI_BLOB,
    sz_password: ?[*:0]const u16,
    dw_flags: CRYPT_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXIsPFXBlob(
    p_p_f_x: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXVerifyPassword(
    p_p_f_x: ?*CRYPTOAPI_BLOB,
    sz_password: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXExportCertStoreEx(
    h_store: ?HCERTSTORE,
    p_p_f_x: ?*CRYPTOAPI_BLOB,
    sz_password: ?[*:0]const u16,
    pv_para: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXExportCertStore(
    h_store: ?HCERTSTORE,
    p_p_f_x: ?*CRYPTOAPI_BLOB,
    sz_password: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertOpenServerOcspResponse(
    p_chain_context: ?*CERT_CHAIN_CONTEXT,
    dw_flags: u32,
    p_open_para: ?*CERT_SERVER_OCSP_RESPONSE_OPEN_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertAddRefServerOcspResponse(
    h_server_ocsp_response: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertCloseServerOcspResponse(
    h_server_ocsp_response: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertGetServerOcspResponseContext(
    h_server_ocsp_response: ?*anyopaque,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertAddRefServerOcspResponseContext(
    p_server_ocsp_response_context: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertFreeServerOcspResponseContext(
    p_server_ocsp_response_context: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertRetrieveLogoOrBiometricInfo(
    p_cert_context: ?*const CERT_CONTEXT,
    lpsz_logo_or_biometric_type: ?[*:0]const u8,
    dw_retrieval_flags: u32,
    dw_timeout: u32,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
    ppb_data: ?*?*u8,
    pcb_data: ?*u32,
    ppwsz_mime_type: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CertSelectCertificateChains(
    p_selection_context: ?*const Guid,
    dw_flags: u32,
    p_chain_parameters: ?*CERT_SELECT_CHAIN_PARA,
    c_criteria: u32,
    rgp_criteria: ?[*]CERT_SELECT_CRITERIA,
    h_store: ?HCERTSTORE,
    pc_selection: ?*u32,
    pprgp_selection: ?*?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CertFreeCertificateChainList(
    prgp_selection: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptRetrieveTimeStamp(
    wsz_url: ?[*:0]const u16,
    dw_retrieval_flags: u32,
    dw_timeout: u32,
    psz_hash_id: ?[*:0]const u8,
    p_para: ?*const CRYPT_TIMESTAMP_PARA,
    // TODO: what to do with BytesParamIndex 6?
    pb_data: ?*const u8,
    cb_data: u32,
    pp_ts_context: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    pp_ts_signer: ?*?*CERT_CONTEXT,
    ph_store: ?*?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptVerifyTimeStampSignature(
    // TODO: what to do with BytesParamIndex 1?
    pb_t_s_content_info: ?*const u8,
    cb_t_s_content_info: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_data: ?*const u8,
    cb_data: u32,
    h_additional_store: ?HCERTSTORE,
    pp_ts_context: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    pp_ts_signer: ?*?*CERT_CONTEXT,
    ph_store: ?*?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CertIsWeakHash(
    dw_hash_use_type: u32,
    pwsz_c_n_g_hash_algid: ?[*:0]const u16,
    dw_chain_flags: u32,
    p_signer_chain_context: ?*CERT_CHAIN_CONTEXT,
    p_time_stamp: ?*FILETIME,
    pwsz_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptProtectData(
    p_data_in: ?*CRYPTOAPI_BLOB,
    sz_data_descr: ?[*:0]const u16,
    p_optional_entropy: ?*CRYPTOAPI_BLOB,
    pv_reserved: ?*anyopaque,
    p_prompt_struct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dw_flags: u32,
    p_data_out: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnprotectData(
    p_data_in: ?*CRYPTOAPI_BLOB,
    ppsz_data_descr: ?*?PWSTR,
    p_optional_entropy: ?*CRYPTOAPI_BLOB,
    pv_reserved: ?*anyopaque,
    p_prompt_struct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dw_flags: u32,
    p_data_out: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptUpdateProtectedState(
    p_old_sid: ?PSID,
    pwsz_old_password: ?[*:0]const u16,
    dw_flags: u32,
    pdw_success_count: ?*u32,
    pdw_failure_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptProtectMemory(
    p_data_in: ?*anyopaque,
    cb_data_in: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptUnprotectMemory(
    p_data_in: ?*anyopaque,
    cb_data_in: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptRegisterProtectionDescriptorName(
    pwsz_name: ?[*:0]const u16,
    pwsz_descriptor_string: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptQueryProtectionDescriptorName(
    pwsz_name: ?[*:0]const u16,
    pwsz_descriptor_string: ?[*:0]u16,
    pc_descriptor_string: ?*usize,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCreateProtectionDescriptor(
    pwsz_descriptor_string: ?[*:0]const u16,
    dw_flags: u32,
    ph_descriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCloseProtectionDescriptor(
    h_descriptor: NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptGetProtectionDescriptorInfo(
    h_descriptor: NCRYPT_DESCRIPTOR_HANDLE,
    p_mem_para: ?*const NCRYPT_ALLOC_PARA,
    dw_info_type: u32,
    ppv_info: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptProtectSecret(
    h_descriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dw_flags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pb_data: ?*const u8,
    cb_data: u32,
    p_mem_para: ?*const NCRYPT_ALLOC_PARA,
    h_wnd: ?HWND,
    ppb_protected_blob: ?*?*u8,
    pcb_protected_blob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptUnprotectSecret(
    ph_descriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
    dw_flags: NCRYPT_FLAGS,
    // TODO: what to do with BytesParamIndex 3?
    pb_protected_blob: ?*const u8,
    cb_protected_blob: u32,
    p_mem_para: ?*const NCRYPT_ALLOC_PARA,
    h_wnd: ?HWND,
    ppb_data: ?*?*u8,
    pcb_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToProtect(
    h_descriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dw_flags: u32,
    h_wnd: ?HWND,
    p_stream_info: ?*NCRYPT_PROTECT_STREAM_INFO,
    ph_stream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToUnprotect(
    p_stream_info: ?*NCRYPT_PROTECT_STREAM_INFO,
    dw_flags: u32,
    h_wnd: ?HWND,
    ph_stream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ncrypt" fn NCryptStreamOpenToUnprotectEx(
    p_stream_info: ?*NCRYPT_PROTECT_STREAM_INFO_EX,
    dw_flags: u32,
    h_wnd: ?HWND,
    ph_stream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamUpdate(
    h_stream: NCRYPT_STREAM_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*const u8,
    cb_data: usize,
    f_final: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamClose(
    h_stream: NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlClose(
    h_crypt_xml: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetTransforms(
    pp_config: ?*const ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlOpenToEncode(
    p_config: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dw_flags: CRYPT_XML_FLAGS,
    wsz_id: ?[*:0]const u16,
    rg_property: ?[*]const CRYPT_XML_PROPERTY,
    c_property: u32,
    p_encoded: ?*const CRYPT_XML_BLOB,
    ph_signature: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlOpenToDecode(
    p_config: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dw_flags: CRYPT_XML_FLAGS,
    rg_property: ?[*]const CRYPT_XML_PROPERTY,
    c_property: u32,
    p_encoded: ?*const CRYPT_XML_BLOB,
    ph_crypt_xml: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlAddObject(
    h_signature_or_object: ?*anyopaque,
    dw_flags: u32,
    rg_property: ?[*]const CRYPT_XML_PROPERTY,
    c_property: u32,
    p_encoded: ?*const CRYPT_XML_BLOB,
    pp_object: ?*const ?*CRYPT_XML_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlCreateReference(
    h_crypt_xml: ?*anyopaque,
    dw_flags: u32,
    wsz_id: ?[*:0]const u16,
    wsz_u_r_i: ?[*:0]const u16,
    wsz_type: ?[*:0]const u16,
    p_digest_method: ?*const CRYPT_XML_ALGORITHM,
    c_transform: u32,
    rg_transform: ?[*]const CRYPT_XML_ALGORITHM,
    ph_reference: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlDigestReference(
    h_reference: ?*anyopaque,
    dw_flags: u32,
    p_data_provider_in: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlSetHMACSecret(
    h_signature: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pb_secret: ?*const u8,
    cb_secret: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlSign(
    h_signature: ?*anyopaque,
    h_key: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dw_key_spec: CERT_KEY_SPEC,
    dw_flags: CRYPT_XML_FLAGS,
    dw_key_info_spec: CRYPT_XML_KEYINFO_SPEC,
    pv_key_info_spec: ?*const anyopaque,
    p_signature_method: ?*const CRYPT_XML_ALGORITHM,
    p_canonicalization: ?*const CRYPT_XML_ALGORITHM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlImportPublicKey(
    dw_flags: CRYPT_XML_FLAGS,
    p_key_value: ?*const CRYPT_XML_KEY_VALUE,
    ph_key: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlVerifySignature(
    h_signature: ?*anyopaque,
    h_key: BCRYPT_KEY_HANDLE,
    dw_flags: CRYPT_XML_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetDocContext(
    h_crypt_xml: ?*anyopaque,
    pp_struct: ?*const ?*CRYPT_XML_DOC_CTXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetSignature(
    h_crypt_xml: ?*anyopaque,
    pp_struct: ?*const ?*CRYPT_XML_SIGNATURE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetReference(
    h_crypt_xml: ?*anyopaque,
    pp_struct: ?*const ?*CRYPT_XML_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetStatus(
    h_crypt_xml: ?*anyopaque,
    p_status: ?*CRYPT_XML_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlEncode(
    h_crypt_xml: ?*anyopaque,
    dw_charset: CRYPT_XML_CHARSET,
    rg_property: ?[*]const CRYPT_XML_PROPERTY,
    c_property: u32,
    pv_callback_state: ?*anyopaque,
    pfn_write: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetAlgorithmInfo(
    p_xml_algorithm: ?*const CRYPT_XML_ALGORITHM,
    dw_flags: CRYPT_XML_FLAGS,
    pp_alg_info: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "cryptxml" fn CryptXmlFindAlgorithmInfo(
    dw_find_by_type: u32,
    pv_find_by: ?*const anyopaque,
    dw_group_id: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_XML_ALGORITHM_INFO;

pub extern "cryptxml" fn CryptXmlEnumAlgorithmInfo(
    dw_group_id: u32,
    dw_flags: u32,
    pv_arg: ?*anyopaque,
    pfn_enum_alg_info: ?PFN_CRYPT_XML_ENUM_ALG_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetToken(
    c_policy_chain: u32,
    p_policy_chain: [*]POLICY_ELEMENT,
    security_token: ?*?*GENERIC_XML_TOKEN,
    ph_proof_token_crypto: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ManageCardSpace() callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ImportInformationCard(
    file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Encrypt(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    f_o_a_e_p: BOOL,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 2?
    p_in_data: ?*u8,
    pcb_out_data: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pp_out_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Decrypt(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    f_o_a_e_p: BOOL,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 2?
    p_in_data: ?*u8,
    pcb_out_data: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pp_out_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn SignHash(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_hash: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_hash: ?*u8,
    hash_alg_oid: ?[*:0]const u16,
    pcb_sig: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pp_sig: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn VerifyHash(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_hash: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_hash: ?*u8,
    hash_alg_oid: ?[*:0]const u16,
    cb_sig: u32,
    // TODO: what to do with BytesParamIndex 4?
    p_sig: ?*u8,
    pf_verified: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetCryptoTransform(
    h_symmetric_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    mode: u32,
    padding: PaddingMode,
    feedback_size: u32,
    direction: Direction,
    cb_i_v: u32,
    // TODO: what to do with BytesParamIndex 5?
    p_i_v: ?*u8,
    pph_transform: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetKeyedHash(
    h_symmetric_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    pph_hash: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformBlock(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_in_data: ?*u8,
    pcb_out_data: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pp_out_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformFinalBlock(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_in_data: ?*u8,
    pcb_out_data: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pp_out_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashCore(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_in_data: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashFinal(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_in_data: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_in_data: ?*u8,
    pcb_out_data: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pp_out_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn FreeToken(
    p_alloc_memory: ?*GENERIC_XML_TOKEN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "infocardapi" fn CloseCryptoHandle(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GenerateDerivedKey(
    h_crypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cb_label: u32,
    // TODO: what to do with BytesParamIndex 1?
    p_label: ?*u8,
    cb_nonce: u32,
    // TODO: what to do with BytesParamIndex 3?
    p_nonce: ?*u8,
    derived_key_length: u32,
    offset: u32,
    alg_id: ?[*:0]const u16,
    pcb_key: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pp_key: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetBrowserToken(
    dw_param_type: u32,
    p_param: ?*anyopaque,
    pcb_token: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    pp_token: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (18)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = thismodule.CRYPT_PASSWORD_CREDENTIALSA;
        pub const CryptAcquireContext = thismodule.CryptAcquireContextA;
        pub const CryptSignHash = thismodule.CryptSignHashA;
        pub const CryptVerifySignature = thismodule.CryptVerifySignatureA;
        pub const CryptSetProvider = thismodule.CryptSetProviderA;
        pub const CryptSetProviderEx = thismodule.CryptSetProviderExA;
        pub const CryptGetDefaultProvider = thismodule.CryptGetDefaultProviderA;
        pub const CryptEnumProviderTypes = thismodule.CryptEnumProviderTypesA;
        pub const CryptEnumProviders = thismodule.CryptEnumProvidersA;
        pub const CertRDNValueToStr = thismodule.CertRDNValueToStrA;
        pub const CertNameToStr = thismodule.CertNameToStrA;
        pub const CertStrToName = thismodule.CertStrToNameA;
        pub const CertGetNameString = thismodule.CertGetNameStringA;
        pub const CertOpenSystemStore = thismodule.CertOpenSystemStoreA;
        pub const CertAddEncodedCertificateToSystemStore = thismodule.CertAddEncodedCertificateToSystemStoreA;
        pub const CryptRetrieveObjectByUrl = thismodule.CryptRetrieveObjectByUrlA;
        pub const CryptStringToBinary = thismodule.CryptStringToBinaryA;
        pub const CryptBinaryToString = thismodule.CryptBinaryToStringA;
    },
    .wide => struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = thismodule.CRYPT_PASSWORD_CREDENTIALSW;
        pub const CryptAcquireContext = thismodule.CryptAcquireContextW;
        pub const CryptSignHash = thismodule.CryptSignHashW;
        pub const CryptVerifySignature = thismodule.CryptVerifySignatureW;
        pub const CryptSetProvider = thismodule.CryptSetProviderW;
        pub const CryptSetProviderEx = thismodule.CryptSetProviderExW;
        pub const CryptGetDefaultProvider = thismodule.CryptGetDefaultProviderW;
        pub const CryptEnumProviderTypes = thismodule.CryptEnumProviderTypesW;
        pub const CryptEnumProviders = thismodule.CryptEnumProvidersW;
        pub const CertRDNValueToStr = thismodule.CertRDNValueToStrW;
        pub const CertNameToStr = thismodule.CertNameToStrW;
        pub const CertStrToName = thismodule.CertStrToNameW;
        pub const CertGetNameString = thismodule.CertGetNameStringW;
        pub const CertOpenSystemStore = thismodule.CertOpenSystemStoreW;
        pub const CertAddEncodedCertificateToSystemStore = thismodule.CertAddEncodedCertificateToSystemStoreW;
        pub const CryptRetrieveObjectByUrl = thismodule.CryptRetrieveObjectByUrlW;
        pub const CryptStringToBinary = thismodule.CryptStringToBinaryW;
        pub const CryptBinaryToString = thismodule.CryptBinaryToStringW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = *opaque {};
        pub const CryptAcquireContext = *opaque {};
        pub const CryptSignHash = *opaque {};
        pub const CryptVerifySignature = *opaque {};
        pub const CryptSetProvider = *opaque {};
        pub const CryptSetProviderEx = *opaque {};
        pub const CryptGetDefaultProvider = *opaque {};
        pub const CryptEnumProviderTypes = *opaque {};
        pub const CryptEnumProviders = *opaque {};
        pub const CertRDNValueToStr = *opaque {};
        pub const CertNameToStr = *opaque {};
        pub const CertStrToName = *opaque {};
        pub const CertGetNameString = *opaque {};
        pub const CertOpenSystemStore = *opaque {};
        pub const CertAddEncodedCertificateToSystemStore = *opaque {};
        pub const CryptRetrieveObjectByUrl = *opaque {};
        pub const CryptStringToBinary = *opaque {};
        pub const CryptBinaryToString = *opaque {};
    } else struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = @compileError("'CRYPT_PASSWORD_CREDENTIALS' requires that UNICODE be set to true or false in the root module");
        pub const CryptAcquireContext = @compileError("'CryptAcquireContext' requires that UNICODE be set to true or false in the root module");
        pub const CryptSignHash = @compileError("'CryptSignHash' requires that UNICODE be set to true or false in the root module");
        pub const CryptVerifySignature = @compileError("'CryptVerifySignature' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProvider = @compileError("'CryptSetProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProviderEx = @compileError("'CryptSetProviderEx' requires that UNICODE be set to true or false in the root module");
        pub const CryptGetDefaultProvider = @compileError("'CryptGetDefaultProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviderTypes = @compileError("'CryptEnumProviderTypes' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviders = @compileError("'CryptEnumProviders' requires that UNICODE be set to true or false in the root module");
        pub const CertRDNValueToStr = @compileError("'CertRDNValueToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertNameToStr = @compileError("'CertNameToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertStrToName = @compileError("'CertStrToName' requires that UNICODE be set to true or false in the root module");
        pub const CertGetNameString = @compileError("'CertGetNameString' requires that UNICODE be set to true or false in the root module");
        pub const CertOpenSystemStore = @compileError("'CertOpenSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CertAddEncodedCertificateToSystemStore = @compileError("'CertAddEncodedCertificateToSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CryptRetrieveObjectByUrl = @compileError("'CryptRetrieveObjectByUrl' requires that UNICODE be set to true or false in the root module");
        pub const CryptStringToBinary = @compileError("'CryptStringToBinary' requires that UNICODE be set to true or false in the root module");
        pub const CryptBinaryToString = @compileError("'CryptBinaryToString' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (22)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const NCRYPT_DESCRIPTOR_HANDLE = @import("../security.zig").NCRYPT_DESCRIPTOR_HANDLE;
const NCRYPT_STREAM_HANDLE = @import("../security.zig").NCRYPT_STREAM_HANDLE;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OBJECT_SECURITY_INFORMATION = @import("../security.zig").OBJECT_SECURITY_INFORMATION;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const REG_VALUE_TYPE = @import("../system/registry.zig").REG_VALUE_TYPE;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_NCRYPT_ALLOC")) {
        _ = PFN_NCRYPT_ALLOC;
    }
    if (@hasDecl(@This(), "PFN_NCRYPT_FREE")) {
        _ = PFN_NCRYPT_FREE;
    }
    if (@hasDecl(@This(), "PCRYPT_DECRYPT_PRIVATE_KEY_FUNC")) {
        _ = PCRYPT_DECRYPT_PRIVATE_KEY_FUNC;
    }
    if (@hasDecl(@This(), "PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC")) {
        _ = PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC;
    }
    if (@hasDecl(@This(), "PCRYPT_RESOLVE_HCRYPTPROV_FUNC")) {
        _ = PCRYPT_RESOLVE_HCRYPTPROV_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ALLOC")) {
        _ = PFN_CRYPT_ALLOC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_FREE")) {
        _ = PFN_CRYPT_FREE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_FUNC")) {
        _ = PFN_CRYPT_ENUM_OID_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_INFO")) {
        _ = PFN_CRYPT_ENUM_OID_INFO;
    }
    if (@hasDecl(@This(), "PFN_CMSG_STREAM_OUTPUT")) {
        _ = PFN_CMSG_STREAM_OUTPUT;
    }
    if (@hasDecl(@This(), "PFN_CMSG_ALLOC")) {
        _ = PFN_CMSG_ALLOC;
    }
    if (@hasDecl(@This(), "PFN_CMSG_FREE")) {
        _ = PFN_CMSG_FREE;
    }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_ENCRYPT_KEY")) {
        _ = PFN_CMSG_GEN_ENCRYPT_KEY;
    }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_ENCRYPT_KEY")) {
        _ = PFN_CMSG_EXPORT_ENCRYPT_KEY;
    }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_ENCRYPT_KEY")) {
        _ = PFN_CMSG_IMPORT_ENCRYPT_KEY;
    }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY")) {
        _ = PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY;
    }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_TRANS")) {
        _ = PFN_CMSG_EXPORT_KEY_TRANS;
    }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_AGREE")) {
        _ = PFN_CMSG_EXPORT_KEY_AGREE;
    }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_MAIL_LIST")) {
        _ = PFN_CMSG_EXPORT_MAIL_LIST;
    }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_TRANS")) {
        _ = PFN_CMSG_IMPORT_KEY_TRANS;
    }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_AGREE")) {
        _ = PFN_CMSG_IMPORT_KEY_AGREE;
    }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_MAIL_LIST")) {
        _ = PFN_CMSG_IMPORT_MAIL_LIST;
    }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_TRANS")) {
        _ = PFN_CMSG_CNG_IMPORT_KEY_TRANS;
    }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_AGREE")) {
        _ = PFN_CMSG_CNG_IMPORT_KEY_AGREE;
    }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY")) {
        _ = PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY;
    }
    if (@hasDecl(@This(), "PFN_CERT_DLL_OPEN_STORE_PROV_FUNC")) {
        _ = PFN_CERT_DLL_OPEN_STORE_PROV_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CLOSE")) {
        _ = PFN_CERT_STORE_PROV_CLOSE;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CERT")) {
        _ = PFN_CERT_STORE_PROV_READ_CERT;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CERT")) {
        _ = PFN_CERT_STORE_PROV_WRITE_CERT;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CERT")) {
        _ = PFN_CERT_STORE_PROV_DELETE_CERT;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CERT_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_SET_CERT_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CRL")) {
        _ = PFN_CERT_STORE_PROV_READ_CRL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CRL")) {
        _ = PFN_CERT_STORE_PROV_WRITE_CRL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CRL")) {
        _ = PFN_CERT_STORE_PROV_DELETE_CRL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CRL_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_SET_CRL_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CTL")) {
        _ = PFN_CERT_STORE_PROV_READ_CTL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CTL")) {
        _ = PFN_CERT_STORE_PROV_WRITE_CTL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CTL")) {
        _ = PFN_CERT_STORE_PROV_DELETE_CTL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CTL_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_SET_CTL_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CONTROL")) {
        _ = PFN_CERT_STORE_PROV_CONTROL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CERT")) {
        _ = PFN_CERT_STORE_PROV_FIND_CERT;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CERT")) {
        _ = PFN_CERT_STORE_PROV_FREE_FIND_CERT;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CERT_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_GET_CERT_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CRL")) {
        _ = PFN_CERT_STORE_PROV_FIND_CRL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CRL")) {
        _ = PFN_CERT_STORE_PROV_FREE_FIND_CRL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CRL_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_GET_CRL_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CTL")) {
        _ = PFN_CERT_STORE_PROV_FIND_CTL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CTL")) {
        _ = PFN_CERT_STORE_PROV_FREE_FIND_CTL;
    }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CTL_PROPERTY")) {
        _ = PFN_CERT_STORE_PROV_GET_CTL_PROPERTY;
    }
    if (@hasDecl(@This(), "PFN_CERT_CREATE_CONTEXT_SORT_FUNC")) {
        _ = PFN_CERT_CREATE_CONTEXT_SORT_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE_LOCATION")) {
        _ = PFN_CERT_ENUM_SYSTEM_STORE_LOCATION;
    }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE")) {
        _ = PFN_CERT_ENUM_SYSTEM_STORE;
    }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_PHYSICAL_STORE")) {
        _ = PFN_CERT_ENUM_PHYSICAL_STORE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC")) {
        _ = PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC")) {
        _ = PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC")) {
        _ = PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC")) {
        _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC")) {
        _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC;
    }
    if (@hasDecl(@This(), "PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC")) {
        _ = PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC;
    }
    if (@hasDecl(@This(), "PFN_IMPORT_PRIV_KEY_FUNC")) {
        _ = PFN_IMPORT_PRIV_KEY_FUNC;
    }
    if (@hasDecl(@This(), "PFN_EXPORT_PRIV_KEY_FUNC")) {
        _ = PFN_EXPORT_PRIV_KEY_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_GET_SIGNER_CERTIFICATE")) {
        _ = PFN_CRYPT_GET_SIGNER_CERTIFICATE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_PARAM_FREE_FUNC")) {
        _ = PFN_CRYPT_ASYNC_PARAM_FREE_FUNC;
    }
    if (@hasDecl(@This(), "PFN_FREE_ENCODED_OBJECT_FUNC")) {
        _ = PFN_FREE_ENCODED_OBJECT_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_CANCEL_RETRIEVAL")) {
        _ = PFN_CRYPT_CANCEL_RETRIEVAL;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC")) {
        _ = PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CANCEL_ASYNC_RETRIEVAL_FUNC")) {
        _ = PFN_CANCEL_ASYNC_RETRIEVAL_FUNC;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_KEYID_PROP")) {
        _ = PFN_CRYPT_ENUM_KEYID_PROP;
    }
    if (@hasDecl(@This(), "PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK")) {
        _ = PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK;
    }
    if (@hasDecl(@This(), "PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK")) {
        _ = PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE")) {
        _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE;
    }
    if (@hasDecl(@This(), "PFN_CERT_IS_WEAK_HASH")) {
        _ = PFN_CERT_IS_WEAK_HASH;
    }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallback")) {
        _ = PFNCryptStreamOutputCallback;
    }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallbackEx")) {
        _ = PFNCryptStreamOutputCallbackEx;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_WRITE_CALLBACK")) {
        _ = PFN_CRYPT_XML_WRITE_CALLBACK;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_READ")) {
        _ = PFN_CRYPT_XML_DATA_PROVIDER_READ;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_CLOSE")) {
        _ = PFN_CRYPT_XML_DATA_PROVIDER_CLOSE;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_CREATE_TRANSFORM")) {
        _ = PFN_CRYPT_XML_CREATE_TRANSFORM;
    }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_ENUM_ALG_INFO")) {
        _ = PFN_CRYPT_XML_ENUM_ALG_INFO;
    }
    if (@hasDecl(@This(), "CryptXmlDllGetInterface")) {
        _ = CryptXmlDllGetInterface;
    }
    if (@hasDecl(@This(), "CryptXmlDllEncodeAlgorithm")) {
        _ = CryptXmlDllEncodeAlgorithm;
    }
    if (@hasDecl(@This(), "CryptXmlDllCreateDigest")) {
        _ = CryptXmlDllCreateDigest;
    }
    if (@hasDecl(@This(), "CryptXmlDllDigestData")) {
        _ = CryptXmlDllDigestData;
    }
    if (@hasDecl(@This(), "CryptXmlDllFinalizeDigest")) {
        _ = CryptXmlDllFinalizeDigest;
    }
    if (@hasDecl(@This(), "CryptXmlDllCloseDigest")) {
        _ = CryptXmlDllCloseDigest;
    }
    if (@hasDecl(@This(), "CryptXmlDllSignData")) {
        _ = CryptXmlDllSignData;
    }
    if (@hasDecl(@This(), "CryptXmlDllVerifySignature")) {
        _ = CryptXmlDllVerifySignature;
    }
    if (@hasDecl(@This(), "CryptXmlDllGetAlgorithmInfo")) {
        _ = CryptXmlDllGetAlgorithmInfo;
    }
    if (@hasDecl(@This(), "CryptXmlDllEncodeKeyValue")) {
        _ = CryptXmlDllEncodeKeyValue;
    }
    if (@hasDecl(@This(), "CryptXmlDllCreateKey")) {
        _ = CryptXmlDllCreateKey;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (4)
//--------------------------------------------------------------------------------
pub const catalog = @import("cryptography/catalog.zig");
pub const certificates = @import("cryptography/certificates.zig");
pub const sip = @import("cryptography/sip.zig");
pub const ui = @import("cryptography/ui.zig");
