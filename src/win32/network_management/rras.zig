//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (720)
//--------------------------------------------------------------------------------
pub const RASNAP_ProbationTime = @as(u32, 1);
pub const RASTUNNELENDPOINT_UNKNOWN = @as(u32, 0);
pub const RASTUNNELENDPOINT_IPv4 = @as(u32, 1);
pub const RASTUNNELENDPOINT_IPv6 = @as(u32, 2);
pub const RAS_MaxDeviceType = @as(u32, 16);
pub const RAS_MaxPhoneNumber = @as(u32, 128);
pub const RAS_MaxIpAddress = @as(u32, 15);
pub const RAS_MaxIpxAddress = @as(u32, 21);
pub const RAS_MaxEntryName = @as(u32, 256);
pub const RAS_MaxDeviceName = @as(u32, 128);
pub const RAS_MaxCallbackNumber = @as(u32, 128);
pub const RAS_MaxAreaCode = @as(u32, 10);
pub const RAS_MaxPadType = @as(u32, 32);
pub const RAS_MaxX25Address = @as(u32, 200);
pub const RAS_MaxFacilities = @as(u32, 200);
pub const RAS_MaxUserData = @as(u32, 200);
pub const RAS_MaxReplyMessage = @as(u32, 1024);
pub const RAS_MaxDnsSuffix = @as(u32, 256);
pub const RASCF_AllUsers = @as(u32, 1);
pub const RASCF_GlobalCreds = @as(u32, 2);
pub const RASCF_OwnerKnown = @as(u32, 4);
pub const RASCF_OwnerMatch = @as(u32, 8);
pub const RAS_MaxIDSize = @as(u32, 256);
pub const RASCS_PAUSED = @as(u32, 4096);
pub const RASCS_DONE = @as(u32, 8192);
pub const RASCSS_DONE = @as(u32, 8192);
pub const RDEOPT_UsePrefixSuffix = @as(u32, 1);
pub const RDEOPT_PausedStates = @as(u32, 2);
pub const RDEOPT_IgnoreModemSpeaker = @as(u32, 4);
pub const RDEOPT_SetModemSpeaker = @as(u32, 8);
pub const RDEOPT_IgnoreSoftwareCompression = @as(u32, 16);
pub const RDEOPT_SetSoftwareCompression = @as(u32, 32);
pub const RDEOPT_DisableConnectedUI = @as(u32, 64);
pub const RDEOPT_DisableReconnectUI = @as(u32, 128);
pub const RDEOPT_DisableReconnect = @as(u32, 256);
pub const RDEOPT_NoUser = @as(u32, 512);
pub const RDEOPT_PauseOnScript = @as(u32, 1024);
pub const RDEOPT_Router = @as(u32, 2048);
pub const RDEOPT_CustomDial = @as(u32, 4096);
pub const RDEOPT_UseCustomScripting = @as(u32, 8192);
pub const RDEOPT_InvokeAutoTriggerCredentialUI = @as(u32, 16384);
pub const RDEOPT_EapInfoCryptInCapable = @as(u32, 32768);
pub const REN_User = @as(u32, 0);
pub const REN_AllUsers = @as(u32, 1);
pub const RASIPO_VJ = @as(u32, 1);
pub const RASLCPO_PFC = @as(u32, 1);
pub const RASLCPO_ACFC = @as(u32, 2);
pub const RASLCPO_SSHF = @as(u32, 4);
pub const RASLCPO_DES_56 = @as(u32, 8);
pub const RASLCPO_3_DES = @as(u32, 16);
pub const RASLCPO_AES_128 = @as(u32, 32);
pub const RASLCPO_AES_256 = @as(u32, 64);
pub const RASLCPO_AES_192 = @as(u32, 128);
pub const RASLCPO_GCM_AES_128 = @as(u32, 256);
pub const RASLCPO_GCM_AES_192 = @as(u32, 512);
pub const RASLCPO_GCM_AES_256 = @as(u32, 1024);
pub const RASCCPCA_MPPC = @as(u32, 6);
pub const RASCCPCA_STAC = @as(u32, 5);
pub const RASCCPO_Compression = @as(u32, 1);
pub const RASCCPO_HistoryLess = @as(u32, 2);
pub const RASCCPO_Encryption56bit = @as(u32, 16);
pub const RASCCPO_Encryption40bit = @as(u32, 32);
pub const RASCCPO_Encryption128bit = @as(u32, 64);
pub const RASIKEv2_AUTH_MACHINECERTIFICATES = @as(u32, 1);
pub const RASIKEv2_AUTH_EAP = @as(u32, 2);
pub const RASIKEv2_AUTH_PSK = @as(u32, 3);
pub const RASDIALEVENT = "RasDialEvent";
pub const WM_RASDIALEVENT = @as(u32, 52429);
pub const ET_None = @as(u32, 0);
pub const ET_Require = @as(u32, 1);
pub const ET_RequireMax = @as(u32, 2);
pub const ET_Optional = @as(u32, 3);
pub const VS_Default = @as(u32, 0);
pub const VS_PptpOnly = @as(u32, 1);
pub const VS_PptpFirst = @as(u32, 2);
pub const VS_L2tpOnly = @as(u32, 3);
pub const VS_L2tpFirst = @as(u32, 4);
pub const VS_SstpOnly = @as(u32, 5);
pub const VS_SstpFirst = @as(u32, 6);
pub const VS_Ikev2Only = @as(u32, 7);
pub const VS_Ikev2First = @as(u32, 8);
pub const VS_GREOnly = @as(u32, 9);
pub const VS_PptpSstp = @as(u32, 12);
pub const VS_L2tpSstp = @as(u32, 13);
pub const VS_Ikev2Sstp = @as(u32, 14);
pub const VS_ProtocolList = @as(u32, 15);
pub const RASEO_UseCountryAndAreaCodes = @as(u32, 1);
pub const RASEO_SpecificIpAddr = @as(u32, 2);
pub const RASEO_SpecificNameServers = @as(u32, 4);
pub const RASEO_IpHeaderCompression = @as(u32, 8);
pub const RASEO_RemoteDefaultGateway = @as(u32, 16);
pub const RASEO_DisableLcpExtensions = @as(u32, 32);
pub const RASEO_TerminalBeforeDial = @as(u32, 64);
pub const RASEO_TerminalAfterDial = @as(u32, 128);
pub const RASEO_ModemLights = @as(u32, 256);
pub const RASEO_SwCompression = @as(u32, 512);
pub const RASEO_RequireEncryptedPw = @as(u32, 1024);
pub const RASEO_RequireMsEncryptedPw = @as(u32, 2048);
pub const RASEO_RequireDataEncryption = @as(u32, 4096);
pub const RASEO_NetworkLogon = @as(u32, 8192);
pub const RASEO_UseLogonCredentials = @as(u32, 16384);
pub const RASEO_PromoteAlternates = @as(u32, 32768);
pub const RASEO_SecureLocalFiles = @as(u32, 65536);
pub const RASEO_RequireEAP = @as(u32, 131072);
pub const RASEO_RequirePAP = @as(u32, 262144);
pub const RASEO_RequireSPAP = @as(u32, 524288);
pub const RASEO_Custom = @as(u32, 1048576);
pub const RASEO_PreviewPhoneNumber = @as(u32, 2097152);
pub const RASEO_SharedPhoneNumbers = @as(u32, 8388608);
pub const RASEO_PreviewUserPw = @as(u32, 16777216);
pub const RASEO_PreviewDomain = @as(u32, 33554432);
pub const RASEO_ShowDialingProgress = @as(u32, 67108864);
pub const RASEO_RequireCHAP = @as(u32, 134217728);
pub const RASEO_RequireMsCHAP = @as(u32, 268435456);
pub const RASEO_RequireMsCHAP2 = @as(u32, 536870912);
pub const RASEO_RequireW95MSCHAP = @as(u32, 1073741824);
pub const RASEO_CustomScript = @as(u32, 2147483648);
pub const RASEO2_SecureFileAndPrint = @as(u32, 1);
pub const RASEO2_SecureClientForMSNet = @as(u32, 2);
pub const RASEO2_DontNegotiateMultilink = @as(u32, 4);
pub const RASEO2_DontUseRasCredentials = @as(u32, 8);
pub const RASEO2_UsePreSharedKey = @as(u32, 16);
pub const RASEO2_Internet = @as(u32, 32);
pub const RASEO2_DisableNbtOverIP = @as(u32, 64);
pub const RASEO2_UseGlobalDeviceSettings = @as(u32, 128);
pub const RASEO2_ReconnectIfDropped = @as(u32, 256);
pub const RASEO2_SharePhoneNumbers = @as(u32, 512);
pub const RASEO2_SecureRoutingCompartment = @as(u32, 1024);
pub const RASEO2_UseTypicalSettings = @as(u32, 2048);
pub const RASEO2_IPv6SpecificNameServers = @as(u32, 4096);
pub const RASEO2_IPv6RemoteDefaultGateway = @as(u32, 8192);
pub const RASEO2_RegisterIpWithDNS = @as(u32, 16384);
pub const RASEO2_UseDNSSuffixForRegistration = @as(u32, 32768);
pub const RASEO2_IPv4ExplicitMetric = @as(u32, 65536);
pub const RASEO2_IPv6ExplicitMetric = @as(u32, 131072);
pub const RASEO2_DisableIKENameEkuCheck = @as(u32, 262144);
pub const RASEO2_DisableClassBasedStaticRoute = @as(u32, 524288);
pub const RASEO2_SpecificIPv6Addr = @as(u32, 1048576);
pub const RASEO2_DisableMobility = @as(u32, 2097152);
pub const RASEO2_RequireMachineCertificates = @as(u32, 4194304);
pub const RASEO2_UsePreSharedKeyForIkev2Initiator = @as(u32, 8388608);
pub const RASEO2_UsePreSharedKeyForIkev2Responder = @as(u32, 16777216);
pub const RASEO2_CacheCredentials = @as(u32, 33554432);
pub const RASEO2_AutoTriggerCapable = @as(u32, 67108864);
pub const RASEO2_IsThirdPartyProfile = @as(u32, 134217728);
pub const RASEO2_AuthTypeIsOtp = @as(u32, 268435456);
pub const RASEO2_IsAlwaysOn = @as(u32, 536870912);
pub const RASEO2_IsPrivateNetwork = @as(u32, 1073741824);
pub const RASEO2_PlumbIKEv2TSAsRoutes = @as(u32, 2147483648);
pub const RASNP_NetBEUI = @as(u32, 1);
pub const RASNP_Ipx = @as(u32, 2);
pub const RASNP_Ip = @as(u32, 4);
pub const RASNP_Ipv6 = @as(u32, 8);
pub const RASFP_Ppp = @as(u32, 1);
pub const RASFP_Slip = @as(u32, 2);
pub const RASFP_Ras = @as(u32, 4);
pub const RASDT_Modem = "modem";
pub const RASDT_Isdn = "isdn";
pub const RASDT_X25 = "x25";
pub const RASDT_Vpn = "vpn";
pub const RASDT_Pad = "pad";
pub const RASDT_Generic = "GENERIC";
pub const RASDT_Serial = "SERIAL";
pub const RASDT_FrameRelay = "FRAMERELAY";
pub const RASDT_Atm = "ATM";
pub const RASDT_Sonet = "SONET";
pub const RASDT_SW56 = "SW56";
pub const RASDT_Irda = "IRDA";
pub const RASDT_Parallel = "PARALLEL";
pub const RASDT_PPPoE = "PPPoE";
pub const RASET_Phone = @as(u32, 1);
pub const RASET_Vpn = @as(u32, 2);
pub const RASET_Direct = @as(u32, 3);
pub const RASET_Internet = @as(u32, 4);
pub const RASET_Broadband = @as(u32, 5);
pub const RASCN_Connection = @as(u32, 1);
pub const RASCN_Disconnection = @as(u32, 2);
pub const RASCN_BandwidthAdded = @as(u32, 4);
pub const RASCN_BandwidthRemoved = @as(u32, 8);
pub const RASCN_Dormant = @as(u32, 16);
pub const RASCN_ReConnection = @as(u32, 32);
pub const RASCN_EPDGPacketArrival = @as(u32, 64);
pub const RASIDS_Disabled = @as(u32, 4294967295);
pub const RASIDS_UseGlobalValue = @as(u32, 0);
pub const RASADFLG_PositionDlg = @as(u32, 1);
pub const RASCM_UserName = @as(u32, 1);
pub const RASCM_Password = @as(u32, 2);
pub const RASCM_Domain = @as(u32, 4);
pub const RASCM_DefaultCreds = @as(u32, 8);
pub const RASCM_PreSharedKey = @as(u32, 16);
pub const RASCM_ServerPreSharedKey = @as(u32, 32);
pub const RASCM_DDMPreSharedKey = @as(u32, 64);
pub const RASADP_DisableConnectionQuery = @as(u32, 0);
pub const RASADP_LoginSessionDisable = @as(u32, 1);
pub const RASADP_SavedAddressesLimit = @as(u32, 2);
pub const RASADP_FailedConnectionTimeout = @as(u32, 3);
pub const RASADP_ConnectionQueryTimeout = @as(u32, 4);
pub const RASEAPF_NonInteractive = @as(u32, 2);
pub const RASEAPF_Logon = @as(u32, 4);
pub const RASEAPF_Preview = @as(u32, 8);
pub const RCD_SingleUser = @as(u32, 0);
pub const RCD_AllUsers = @as(u32, 1);
pub const RCD_Eap = @as(u32, 2);
pub const RCD_Logon = @as(u32, 4);
pub const RASPBDEVENT_AddEntry = @as(u32, 1);
pub const RASPBDEVENT_EditEntry = @as(u32, 2);
pub const RASPBDEVENT_RemoveEntry = @as(u32, 3);
pub const RASPBDEVENT_DialEntry = @as(u32, 4);
pub const RASPBDEVENT_EditGlobals = @as(u32, 5);
pub const RASPBDEVENT_NoUser = @as(u32, 6);
pub const RASPBDEVENT_NoUserEdit = @as(u32, 7);
pub const RASNOUSER_SmartCard = @as(u32, 1);
pub const RASPBDFLAG_PositionDlg = @as(u32, 1);
pub const RASPBDFLAG_ForceCloseOnDial = @as(u32, 2);
pub const RASPBDFLAG_NoUser = @as(u32, 16);
pub const RASPBDFLAG_UpdateDefaults = @as(u32, 2147483648);
pub const RASEDFLAG_PositionDlg = @as(u32, 1);
pub const RASEDFLAG_NewEntry = @as(u32, 2);
pub const RASEDFLAG_CloneEntry = @as(u32, 4);
pub const RASEDFLAG_NoRename = @as(u32, 8);
pub const RASEDFLAG_ShellOwned = @as(u32, 1073741824);
pub const RASEDFLAG_NewPhoneEntry = @as(u32, 16);
pub const RASEDFLAG_NewTunnelEntry = @as(u32, 32);
pub const RASEDFLAG_NewDirectEntry = @as(u32, 64);
pub const RASEDFLAG_NewBroadbandEntry = @as(u32, 128);
pub const RASEDFLAG_InternetEntry = @as(u32, 256);
pub const RASEDFLAG_NAT = @as(u32, 512);
pub const RASEDFLAG_IncomingConnection = @as(u32, 1024);
pub const RASDDFLAG_PositionDlg = @as(u32, 1);
pub const RASDDFLAG_NoPrompt = @as(u32, 2);
pub const RASDDFLAG_AoacRedial = @as(u32, 4);
pub const RASDDFLAG_LinkFailure = @as(u32, 2147483648);
pub const RRAS_SERVICE_NAME = "RemoteAccess";
pub const PID_IPX = @as(u32, 43);
pub const PID_IP = @as(u32, 33);
pub const PID_IPV6 = @as(u32, 87);
pub const PID_NBF = @as(u32, 63);
pub const PID_ATALK = @as(u32, 41);
pub const MPR_INTERFACE_OUT_OF_RESOURCES = @as(u32, 1);
pub const MPR_INTERFACE_ADMIN_DISABLED = @as(u32, 2);
pub const MPR_INTERFACE_CONNECTION_FAILURE = @as(u32, 4);
pub const MPR_INTERFACE_SERVICE_PAUSED = @as(u32, 8);
pub const MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION = @as(u32, 16);
pub const MPR_INTERFACE_NO_MEDIA_SENSE = @as(u32, 32);
pub const MPR_INTERFACE_NO_DEVICE = @as(u32, 64);
pub const MPR_MaxDeviceType = @as(u32, 16);
pub const MPR_MaxPhoneNumber = @as(u32, 128);
pub const MPR_MaxIpAddress = @as(u32, 15);
pub const MPR_MaxIpxAddress = @as(u32, 21);
pub const MPR_MaxEntryName = @as(u32, 256);
pub const MPR_MaxDeviceName = @as(u32, 128);
pub const MPR_MaxCallbackNumber = @as(u32, 128);
pub const MPR_MaxAreaCode = @as(u32, 10);
pub const MPR_MaxPadType = @as(u32, 32);
pub const MPR_MaxX25Address = @as(u32, 200);
pub const MPR_MaxFacilities = @as(u32, 200);
pub const MPR_MaxUserData = @as(u32, 200);
pub const MPRIO_SpecificIpAddr = @as(u32, 2);
pub const MPRIO_SpecificNameServers = @as(u32, 4);
pub const MPRIO_IpHeaderCompression = @as(u32, 8);
pub const MPRIO_RemoteDefaultGateway = @as(u32, 16);
pub const MPRIO_DisableLcpExtensions = @as(u32, 32);
pub const MPRIO_SwCompression = @as(u32, 512);
pub const MPRIO_RequireEncryptedPw = @as(u32, 1024);
pub const MPRIO_RequireMsEncryptedPw = @as(u32, 2048);
pub const MPRIO_RequireDataEncryption = @as(u32, 4096);
pub const MPRIO_NetworkLogon = @as(u32, 8192);
pub const MPRIO_PromoteAlternates = @as(u32, 32768);
pub const MPRIO_SecureLocalFiles = @as(u32, 65536);
pub const MPRIO_RequireEAP = @as(u32, 131072);
pub const MPRIO_RequirePAP = @as(u32, 262144);
pub const MPRIO_RequireSPAP = @as(u32, 524288);
pub const MPRIO_SharedPhoneNumbers = @as(u32, 8388608);
pub const MPRIO_RequireCHAP = @as(u32, 134217728);
pub const MPRIO_RequireMsCHAP = @as(u32, 268435456);
pub const MPRIO_RequireMsCHAP2 = @as(u32, 536870912);
pub const MPRIO_IpSecPreSharedKey = @as(u32, 2147483648);
pub const MPRIO_RequireMachineCertificates = @as(u32, 16777216);
pub const MPRIO_UsePreSharedKeyForIkev2Initiator = @as(u32, 33554432);
pub const MPRIO_UsePreSharedKeyForIkev2Responder = @as(u32, 67108864);
pub const MPRNP_Ipx = @as(u32, 2);
pub const MPRNP_Ip = @as(u32, 4);
pub const MPRNP_Ipv6 = @as(u32, 8);
pub const MPRDT_Modem = "modem";
pub const MPRDT_Isdn = "isdn";
pub const MPRDT_X25 = "x25";
pub const MPRDT_Vpn = "vpn";
pub const MPRDT_Pad = "pad";
pub const MPRDT_Generic = "GENERIC";
pub const MPRDT_Serial = "SERIAL";
pub const MPRDT_FrameRelay = "FRAMERELAY";
pub const MPRDT_Atm = "ATM";
pub const MPRDT_Sonet = "SONET";
pub const MPRDT_SW56 = "SW56";
pub const MPRDT_Irda = "IRDA";
pub const MPRDT_Parallel = "PARALLEL";
pub const MPRET_Phone = @as(u32, 1);
pub const MPRET_Vpn = @as(u32, 2);
pub const MPRET_Direct = @as(u32, 3);
pub const MPRIDS_Disabled = @as(u32, 4294967295);
pub const MPRIDS_UseGlobalValue = @as(u32, 0);
pub const MPR_VS_Ikev2Only = @as(u32, 7);
pub const MPR_VS_Ikev2First = @as(u32, 8);
pub const MPR_ENABLE_RAS_ON_DEVICE = @as(u32, 1);
pub const MPR_ENABLE_ROUTING_ON_DEVICE = @as(u32, 2);
pub const IPADDRESSLEN = @as(u32, 15);
pub const IPXADDRESSLEN = @as(u32, 22);
pub const ATADDRESSLEN = @as(u32, 32);
pub const MAXIPADRESSLEN = @as(u32, 64);
pub const PPP_IPCP_VJ = @as(u32, 1);
pub const PPP_CCP_COMPRESSION = @as(u32, 1);
pub const PPP_CCP_ENCRYPTION40BITOLD = @as(u32, 16);
pub const PPP_CCP_ENCRYPTION40BIT = @as(u32, 32);
pub const PPP_CCP_ENCRYPTION128BIT = @as(u32, 64);
pub const PPP_CCP_ENCRYPTION56BIT = @as(u32, 128);
pub const PPP_CCP_HISTORYLESS = @as(u32, 16777216);
pub const PPP_LCP_MULTILINK_FRAMING = @as(u32, 1);
pub const PPP_LCP_PFC = @as(u32, 2);
pub const PPP_LCP_ACFC = @as(u32, 4);
pub const PPP_LCP_SSHF = @as(u32, 8);
pub const PPP_LCP_DES_56 = @as(u32, 16);
pub const PPP_LCP_3_DES = @as(u32, 32);
pub const PPP_LCP_AES_128 = @as(u32, 64);
pub const PPP_LCP_AES_256 = @as(u32, 128);
pub const PPP_LCP_AES_192 = @as(u32, 256);
pub const PPP_LCP_GCM_AES_128 = @as(u32, 512);
pub const PPP_LCP_GCM_AES_192 = @as(u32, 1024);
pub const PPP_LCP_GCM_AES_256 = @as(u32, 2048);
pub const RAS_FLAGS_RAS_CONNECTION = @as(u32, 4);
pub const RASPRIV_NoCallback = @as(u32, 1);
pub const RASPRIV_AdminSetCallback = @as(u32, 2);
pub const RASPRIV_CallerSetCallback = @as(u32, 4);
pub const RASPRIV_DialinPrivilege = @as(u32, 8);
pub const RASPRIV2_DialinPolicy = @as(u32, 1);
pub const MPRAPI_IKEV2_AUTH_USING_CERT = @as(u32, 1);
pub const MPRAPI_IKEV2_AUTH_USING_EAP = @as(u32, 2);
pub const MPRAPI_PPP_PROJECTION_INFO_TYPE = @as(u32, 1);
pub const MPRAPI_IKEV2_PROJECTION_INFO_TYPE = @as(u32, 2);
pub const MPRAPI_RAS_CONNECTION_OBJECT_REVISION_1 = @as(u32, 1);
pub const MPRAPI_MPR_IF_CUSTOM_CONFIG_OBJECT_REVISION_1 = @as(u32, 1);
pub const MPRAPI_IF_CUSTOM_CONFIG_FOR_IKEV2 = @as(u32, 1);
pub const MPRAPI_MPR_IF_CUSTOM_CONFIG_OBJECT_REVISION_3 = @as(u32, 3);
pub const MPRAPI_MPR_IF_CUSTOM_CONFIG_OBJECT_REVISION_2 = @as(u32, 2);
pub const MPRAPI_IKEV2_SET_TUNNEL_CONFIG_PARAMS = @as(u32, 1);
pub const MPRAPI_L2TP_SET_TUNNEL_CONFIG_PARAMS = @as(u32, 1);
pub const MAX_SSTP_HASH_SIZE = @as(u32, 32);
pub const MPRAPI_MPR_SERVER_OBJECT_REVISION_1 = @as(u32, 1);
pub const MPRAPI_MPR_SERVER_OBJECT_REVISION_2 = @as(u32, 2);
pub const MPRAPI_MPR_SERVER_OBJECT_REVISION_3 = @as(u32, 3);
pub const MPRAPI_MPR_SERVER_OBJECT_REVISION_4 = @as(u32, 4);
pub const MPRAPI_MPR_SERVER_OBJECT_REVISION_5 = @as(u32, 5);
pub const MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_1 = @as(u32, 1);
pub const MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_2 = @as(u32, 2);
pub const MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_3 = @as(u32, 3);
pub const MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_4 = @as(u32, 4);
pub const MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_5 = @as(u32, 5);
pub const MPRAPI_SET_CONFIG_PROTOCOL_FOR_PPTP = @as(u32, 1);
pub const MPRAPI_SET_CONFIG_PROTOCOL_FOR_L2TP = @as(u32, 2);
pub const MPRAPI_SET_CONFIG_PROTOCOL_FOR_SSTP = @as(u32, 4);
pub const MPRAPI_SET_CONFIG_PROTOCOL_FOR_IKEV2 = @as(u32, 8);
pub const MPRAPI_SET_CONFIG_PROTOCOL_FOR_GRE = @as(u32, 16);
pub const ALLOW_NO_AUTH = @as(u32, 1);
pub const DO_NOT_ALLOW_NO_AUTH = @as(u32, 0);
pub const MPRAPI_RAS_UPDATE_CONNECTION_OBJECT_REVISION_1 = @as(u32, 1);
pub const MPRAPI_ADMIN_DLL_VERSION_1 = @as(u32, 1);
pub const MPRAPI_ADMIN_DLL_VERSION_2 = @as(u32, 2);
pub const MGM_JOIN_STATE_FLAG = @as(u32, 1);
pub const MGM_FORWARD_STATE_FLAG = @as(u32, 2);
pub const MGM_MFE_STATS_0 = @as(u32, 1);
pub const MGM_MFE_STATS_1 = @as(u32, 2);
pub const RTM_MAX_ADDRESS_SIZE = @as(u32, 16);
pub const RTM_MAX_VIEWS = @as(u32, 32);
pub const RTM_VIEW_ID_UCAST = @as(u32, 0);
pub const RTM_VIEW_ID_MCAST = @as(u32, 1);
pub const RTM_VIEW_MASK_SIZE = @as(u32, 32);
pub const RTM_VIEW_MASK_NONE = @as(u32, 0);
pub const RTM_VIEW_MASK_ANY = @as(u32, 0);
pub const RTM_VIEW_MASK_UCAST = @as(u32, 1);
pub const RTM_VIEW_MASK_MCAST = @as(u32, 2);
pub const RTM_VIEW_MASK_ALL = @as(u32, 4294967295);
pub const IPV6_ADDRESS_LEN_IN_BYTES = @as(u32, 16);
pub const RTM_DEST_FLAG_NATURAL_NET = @as(u32, 1);
pub const RTM_DEST_FLAG_FWD_ENGIN_ADD = @as(u32, 2);
pub const RTM_DEST_FLAG_DONT_FORWARD = @as(u32, 4);
pub const RTM_ROUTE_STATE_CREATED = @as(u32, 0);
pub const RTM_ROUTE_STATE_DELETING = @as(u32, 1);
pub const RTM_ROUTE_STATE_DELETED = @as(u32, 2);
pub const RTM_ROUTE_FLAGS_MARTIAN = @as(u32, 1);
pub const RTM_ROUTE_FLAGS_BLACKHOLE = @as(u32, 2);
pub const RTM_ROUTE_FLAGS_DISCARD = @as(u32, 4);
pub const RTM_ROUTE_FLAGS_INACTIVE = @as(u32, 8);
pub const RTM_ROUTE_FLAGS_LOCAL = @as(u32, 16);
pub const RTM_ROUTE_FLAGS_REMOTE = @as(u32, 32);
pub const RTM_ROUTE_FLAGS_MYSELF = @as(u32, 64);
pub const RTM_ROUTE_FLAGS_LOOPBACK = @as(u32, 128);
pub const RTM_ROUTE_FLAGS_MCAST = @as(u32, 256);
pub const RTM_ROUTE_FLAGS_LOCAL_MCAST = @as(u32, 512);
pub const RTM_ROUTE_FLAGS_LIMITED_BC = @as(u32, 1024);
pub const RTM_ROUTE_FLAGS_ZEROS_NETBC = @as(u32, 4096);
pub const RTM_ROUTE_FLAGS_ZEROS_SUBNETBC = @as(u32, 8192);
pub const RTM_ROUTE_FLAGS_ONES_NETBC = @as(u32, 16384);
pub const RTM_ROUTE_FLAGS_ONES_SUBNETBC = @as(u32, 32768);
pub const RTM_NEXTHOP_STATE_CREATED = @as(u32, 0);
pub const RTM_NEXTHOP_STATE_DELETED = @as(u32, 1);
pub const RTM_NEXTHOP_FLAGS_REMOTE = @as(u32, 1);
pub const RTM_NEXTHOP_FLAGS_DOWN = @as(u32, 2);
pub const METHOD_TYPE_ALL_METHODS = @as(u32, 4294967295);
pub const METHOD_RIP2_NEIGHBOUR_ADDR = @as(u32, 1);
pub const METHOD_RIP2_OUTBOUND_INTF = @as(u32, 2);
pub const METHOD_RIP2_ROUTE_TAG = @as(u32, 4);
pub const METHOD_RIP2_ROUTE_TIMESTAMP = @as(u32, 8);
pub const METHOD_BGP4_AS_PATH = @as(u32, 1);
pub const METHOD_BGP4_PEER_ID = @as(u32, 2);
pub const METHOD_BGP4_PA_ORIGIN = @as(u32, 4);
pub const METHOD_BGP4_NEXTHOP_ATTR = @as(u32, 8);
pub const RTM_RESUME_METHODS = @as(u32, 0);
pub const RTM_BLOCK_METHODS = @as(u32, 1);
pub const RTM_ROUTE_CHANGE_FIRST = @as(u32, 1);
pub const RTM_ROUTE_CHANGE_NEW = @as(u32, 2);
pub const RTM_ROUTE_CHANGE_BEST = @as(u32, 65536);
pub const RTM_NEXTHOP_CHANGE_NEW = @as(u32, 1);
pub const RTM_MATCH_NONE = @as(u32, 0);
pub const RTM_MATCH_OWNER = @as(u32, 1);
pub const RTM_MATCH_NEIGHBOUR = @as(u32, 2);
pub const RTM_MATCH_PREF = @as(u32, 4);
pub const RTM_MATCH_NEXTHOP = @as(u32, 8);
pub const RTM_MATCH_INTERFACE = @as(u32, 16);
pub const RTM_MATCH_FULL = @as(u32, 65535);
pub const RTM_ENUM_START = @as(u32, 0);
pub const RTM_ENUM_NEXT = @as(u32, 1);
pub const RTM_ENUM_RANGE = @as(u32, 2);
pub const RTM_ENUM_ALL_DESTS = @as(u32, 0);
pub const RTM_ENUM_OWN_DESTS = @as(u32, 16777216);
pub const RTM_ENUM_ALL_ROUTES = @as(u32, 0);
pub const RTM_ENUM_OWN_ROUTES = @as(u32, 65536);
pub const RTM_NUM_CHANGE_TYPES = @as(u32, 3);
pub const RTM_CHANGE_TYPE_ALL = @as(u32, 1);
pub const RTM_CHANGE_TYPE_BEST = @as(u32, 2);
pub const RTM_CHANGE_TYPE_FORWARDING = @as(u32, 4);
pub const RTM_NOTIFY_ONLY_MARKED_DESTS = @as(u32, 65536);
pub const RASBASE = @as(u32, 600);
pub const PENDING = @as(u32, 600);
pub const ERROR_INVALID_PORT_HANDLE = @as(u32, 601);
pub const ERROR_PORT_ALREADY_OPEN = @as(u32, 602);
pub const ERROR_BUFFER_TOO_SMALL = @as(u32, 603);
pub const ERROR_WRONG_INFO_SPECIFIED = @as(u32, 604);
pub const ERROR_CANNOT_SET_PORT_INFO = @as(u32, 605);
pub const ERROR_PORT_NOT_CONNECTED = @as(u32, 606);
pub const ERROR_EVENT_INVALID = @as(u32, 607);
pub const ERROR_DEVICE_DOES_NOT_EXIST = @as(u32, 608);
pub const ERROR_DEVICETYPE_DOES_NOT_EXIST = @as(u32, 609);
pub const ERROR_BUFFER_INVALID = @as(u32, 610);
pub const ERROR_ROUTE_NOT_AVAILABLE = @as(u32, 611);
pub const ERROR_ROUTE_NOT_ALLOCATED = @as(u32, 612);
pub const ERROR_INVALID_COMPRESSION_SPECIFIED = @as(u32, 613);
pub const ERROR_OUT_OF_BUFFERS = @as(u32, 614);
pub const ERROR_PORT_NOT_FOUND = @as(u32, 615);
pub const ERROR_ASYNC_REQUEST_PENDING = @as(u32, 616);
pub const ERROR_ALREADY_DISCONNECTING = @as(u32, 617);
pub const ERROR_PORT_NOT_OPEN = @as(u32, 618);
pub const ERROR_PORT_DISCONNECTED = @as(u32, 619);
pub const ERROR_NO_ENDPOINTS = @as(u32, 620);
pub const ERROR_CANNOT_OPEN_PHONEBOOK = @as(u32, 621);
pub const ERROR_CANNOT_LOAD_PHONEBOOK = @as(u32, 622);
pub const ERROR_CANNOT_FIND_PHONEBOOK_ENTRY = @as(u32, 623);
pub const ERROR_CANNOT_WRITE_PHONEBOOK = @as(u32, 624);
pub const ERROR_CORRUPT_PHONEBOOK = @as(u32, 625);
pub const ERROR_CANNOT_LOAD_STRING = @as(u32, 626);
pub const ERROR_KEY_NOT_FOUND = @as(u32, 627);
pub const ERROR_DISCONNECTION = @as(u32, 628);
pub const ERROR_REMOTE_DISCONNECTION = @as(u32, 629);
pub const ERROR_HARDWARE_FAILURE = @as(u32, 630);
pub const ERROR_USER_DISCONNECTION = @as(u32, 631);
pub const ERROR_INVALID_SIZE = @as(u32, 632);
pub const ERROR_PORT_NOT_AVAILABLE = @as(u32, 633);
pub const ERROR_CANNOT_PROJECT_CLIENT = @as(u32, 634);
pub const ERROR_UNKNOWN = @as(u32, 635);
pub const ERROR_WRONG_DEVICE_ATTACHED = @as(u32, 636);
pub const ERROR_BAD_STRING = @as(u32, 637);
pub const ERROR_REQUEST_TIMEOUT = @as(u32, 638);
pub const ERROR_CANNOT_GET_LANA = @as(u32, 639);
pub const ERROR_NETBIOS_ERROR = @as(u32, 640);
pub const ERROR_SERVER_OUT_OF_RESOURCES = @as(u32, 641);
pub const ERROR_NAME_EXISTS_ON_NET = @as(u32, 642);
pub const ERROR_SERVER_GENERAL_NET_FAILURE = @as(u32, 643);
pub const WARNING_MSG_ALIAS_NOT_ADDED = @as(u32, 644);
pub const ERROR_AUTH_INTERNAL = @as(u32, 645);
pub const ERROR_RESTRICTED_LOGON_HOURS = @as(u32, 646);
pub const ERROR_ACCT_DISABLED = @as(u32, 647);
pub const ERROR_PASSWD_EXPIRED = @as(u32, 648);
pub const ERROR_NO_DIALIN_PERMISSION = @as(u32, 649);
pub const ERROR_SERVER_NOT_RESPONDING = @as(u32, 650);
pub const ERROR_FROM_DEVICE = @as(u32, 651);
pub const ERROR_UNRECOGNIZED_RESPONSE = @as(u32, 652);
pub const ERROR_MACRO_NOT_FOUND = @as(u32, 653);
pub const ERROR_MACRO_NOT_DEFINED = @as(u32, 654);
pub const ERROR_MESSAGE_MACRO_NOT_FOUND = @as(u32, 655);
pub const ERROR_DEFAULTOFF_MACRO_NOT_FOUND = @as(u32, 656);
pub const ERROR_FILE_COULD_NOT_BE_OPENED = @as(u32, 657);
pub const ERROR_DEVICENAME_TOO_LONG = @as(u32, 658);
pub const ERROR_DEVICENAME_NOT_FOUND = @as(u32, 659);
pub const ERROR_NO_RESPONSES = @as(u32, 660);
pub const ERROR_NO_COMMAND_FOUND = @as(u32, 661);
pub const ERROR_WRONG_KEY_SPECIFIED = @as(u32, 662);
pub const ERROR_UNKNOWN_DEVICE_TYPE = @as(u32, 663);
pub const ERROR_ALLOCATING_MEMORY = @as(u32, 664);
pub const ERROR_PORT_NOT_CONFIGURED = @as(u32, 665);
pub const ERROR_DEVICE_NOT_READY = @as(u32, 666);
pub const ERROR_READING_INI_FILE = @as(u32, 667);
pub const ERROR_NO_CONNECTION = @as(u32, 668);
pub const ERROR_BAD_USAGE_IN_INI_FILE = @as(u32, 669);
pub const ERROR_READING_SECTIONNAME = @as(u32, 670);
pub const ERROR_READING_DEVICETYPE = @as(u32, 671);
pub const ERROR_READING_DEVICENAME = @as(u32, 672);
pub const ERROR_READING_USAGE = @as(u32, 673);
pub const ERROR_READING_MAXCONNECTBPS = @as(u32, 674);
pub const ERROR_READING_MAXCARRIERBPS = @as(u32, 675);
pub const ERROR_LINE_BUSY = @as(u32, 676);
pub const ERROR_VOICE_ANSWER = @as(u32, 677);
pub const ERROR_NO_ANSWER = @as(u32, 678);
pub const ERROR_NO_CARRIER = @as(u32, 679);
pub const ERROR_NO_DIALTONE = @as(u32, 680);
pub const ERROR_IN_COMMAND = @as(u32, 681);
pub const ERROR_WRITING_SECTIONNAME = @as(u32, 682);
pub const ERROR_WRITING_DEVICETYPE = @as(u32, 683);
pub const ERROR_WRITING_DEVICENAME = @as(u32, 684);
pub const ERROR_WRITING_MAXCONNECTBPS = @as(u32, 685);
pub const ERROR_WRITING_MAXCARRIERBPS = @as(u32, 686);
pub const ERROR_WRITING_USAGE = @as(u32, 687);
pub const ERROR_WRITING_DEFAULTOFF = @as(u32, 688);
pub const ERROR_READING_DEFAULTOFF = @as(u32, 689);
pub const ERROR_EMPTY_INI_FILE = @as(u32, 690);
pub const ERROR_AUTHENTICATION_FAILURE = @as(u32, 691);
pub const ERROR_PORT_OR_DEVICE = @as(u32, 692);
pub const ERROR_NOT_BINARY_MACRO = @as(u32, 693);
pub const ERROR_DCB_NOT_FOUND = @as(u32, 694);
pub const ERROR_STATE_MACHINES_NOT_STARTED = @as(u32, 695);
pub const ERROR_STATE_MACHINES_ALREADY_STARTED = @as(u32, 696);
pub const ERROR_PARTIAL_RESPONSE_LOOPING = @as(u32, 697);
pub const ERROR_UNKNOWN_RESPONSE_KEY = @as(u32, 698);
pub const ERROR_RECV_BUF_FULL = @as(u32, 699);
pub const ERROR_CMD_TOO_LONG = @as(u32, 700);
pub const ERROR_UNSUPPORTED_BPS = @as(u32, 701);
pub const ERROR_UNEXPECTED_RESPONSE = @as(u32, 702);
pub const ERROR_INTERACTIVE_MODE = @as(u32, 703);
pub const ERROR_BAD_CALLBACK_NUMBER = @as(u32, 704);
pub const ERROR_INVALID_AUTH_STATE = @as(u32, 705);
pub const ERROR_WRITING_INITBPS = @as(u32, 706);
pub const ERROR_X25_DIAGNOSTIC = @as(u32, 707);
pub const ERROR_ACCT_EXPIRED = @as(u32, 708);
pub const ERROR_CHANGING_PASSWORD = @as(u32, 709);
pub const ERROR_OVERRUN = @as(u32, 710);
pub const ERROR_RASMAN_CANNOT_INITIALIZE = @as(u32, 711);
pub const ERROR_BIPLEX_PORT_NOT_AVAILABLE = @as(u32, 712);
pub const ERROR_NO_ACTIVE_ISDN_LINES = @as(u32, 713);
pub const ERROR_NO_ISDN_CHANNELS_AVAILABLE = @as(u32, 714);
pub const ERROR_TOO_MANY_LINE_ERRORS = @as(u32, 715);
pub const ERROR_IP_CONFIGURATION = @as(u32, 716);
pub const ERROR_NO_IP_ADDRESSES = @as(u32, 717);
pub const ERROR_PPP_TIMEOUT = @as(u32, 718);
pub const ERROR_PPP_REMOTE_TERMINATED = @as(u32, 719);
pub const ERROR_PPP_NO_PROTOCOLS_CONFIGURED = @as(u32, 720);
pub const ERROR_PPP_NO_RESPONSE = @as(u32, 721);
pub const ERROR_PPP_INVALID_PACKET = @as(u32, 722);
pub const ERROR_PHONE_NUMBER_TOO_LONG = @as(u32, 723);
pub const ERROR_IPXCP_NO_DIALOUT_CONFIGURED = @as(u32, 724);
pub const ERROR_IPXCP_NO_DIALIN_CONFIGURED = @as(u32, 725);
pub const ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE = @as(u32, 726);
pub const ERROR_ACCESSING_TCPCFGDLL = @as(u32, 727);
pub const ERROR_NO_IP_RAS_ADAPTER = @as(u32, 728);
pub const ERROR_SLIP_REQUIRES_IP = @as(u32, 729);
pub const ERROR_PROJECTION_NOT_COMPLETE = @as(u32, 730);
pub const ERROR_PROTOCOL_NOT_CONFIGURED = @as(u32, 731);
pub const ERROR_PPP_NOT_CONVERGING = @as(u32, 732);
pub const ERROR_PPP_CP_REJECTED = @as(u32, 733);
pub const ERROR_PPP_LCP_TERMINATED = @as(u32, 734);
pub const ERROR_PPP_REQUIRED_ADDRESS_REJECTED = @as(u32, 735);
pub const ERROR_PPP_NCP_TERMINATED = @as(u32, 736);
pub const ERROR_PPP_LOOPBACK_DETECTED = @as(u32, 737);
pub const ERROR_PPP_NO_ADDRESS_ASSIGNED = @as(u32, 738);
pub const ERROR_CANNOT_USE_LOGON_CREDENTIALS = @as(u32, 739);
pub const ERROR_TAPI_CONFIGURATION = @as(u32, 740);
pub const ERROR_NO_LOCAL_ENCRYPTION = @as(u32, 741);
pub const ERROR_NO_REMOTE_ENCRYPTION = @as(u32, 742);
pub const ERROR_REMOTE_REQUIRES_ENCRYPTION = @as(u32, 743);
pub const ERROR_IPXCP_NET_NUMBER_CONFLICT = @as(u32, 744);
pub const ERROR_INVALID_SMM = @as(u32, 745);
pub const ERROR_SMM_UNINITIALIZED = @as(u32, 746);
pub const ERROR_NO_MAC_FOR_PORT = @as(u32, 747);
pub const ERROR_SMM_TIMEOUT = @as(u32, 748);
pub const ERROR_BAD_PHONE_NUMBER = @as(u32, 749);
pub const ERROR_WRONG_MODULE = @as(u32, 750);
pub const ERROR_INVALID_CALLBACK_NUMBER = @as(u32, 751);
pub const ERROR_SCRIPT_SYNTAX = @as(u32, 752);
pub const ERROR_HANGUP_FAILED = @as(u32, 753);
pub const ERROR_BUNDLE_NOT_FOUND = @as(u32, 754);
pub const ERROR_CANNOT_DO_CUSTOMDIAL = @as(u32, 755);
pub const ERROR_DIAL_ALREADY_IN_PROGRESS = @as(u32, 756);
pub const ERROR_RASAUTO_CANNOT_INITIALIZE = @as(u32, 757);
pub const ERROR_CONNECTION_ALREADY_SHARED = @as(u32, 758);
pub const ERROR_SHARING_CHANGE_FAILED = @as(u32, 759);
pub const ERROR_SHARING_ROUTER_INSTALL = @as(u32, 760);
pub const ERROR_SHARE_CONNECTION_FAILED = @as(u32, 761);
pub const ERROR_SHARING_PRIVATE_INSTALL = @as(u32, 762);
pub const ERROR_CANNOT_SHARE_CONNECTION = @as(u32, 763);
pub const ERROR_NO_SMART_CARD_READER = @as(u32, 764);
pub const ERROR_SHARING_ADDRESS_EXISTS = @as(u32, 765);
pub const ERROR_NO_CERTIFICATE = @as(u32, 766);
pub const ERROR_SHARING_MULTIPLE_ADDRESSES = @as(u32, 767);
pub const ERROR_FAILED_TO_ENCRYPT = @as(u32, 768);
pub const ERROR_BAD_ADDRESS_SPECIFIED = @as(u32, 769);
pub const ERROR_CONNECTION_REJECT = @as(u32, 770);
pub const ERROR_CONGESTION = @as(u32, 771);
pub const ERROR_INCOMPATIBLE = @as(u32, 772);
pub const ERROR_NUMBERCHANGED = @as(u32, 773);
pub const ERROR_TEMPFAILURE = @as(u32, 774);
pub const ERROR_BLOCKED = @as(u32, 775);
pub const ERROR_DONOTDISTURB = @as(u32, 776);
pub const ERROR_OUTOFORDER = @as(u32, 777);
pub const ERROR_UNABLE_TO_AUTHENTICATE_SERVER = @as(u32, 778);
pub const ERROR_SMART_CARD_REQUIRED = @as(u32, 779);
pub const ERROR_INVALID_FUNCTION_FOR_ENTRY = @as(u32, 780);
pub const ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND = @as(u32, 781);
pub const ERROR_SHARING_RRAS_CONFLICT = @as(u32, 782);
pub const ERROR_SHARING_NO_PRIVATE_LAN = @as(u32, 783);
pub const ERROR_NO_DIFF_USER_AT_LOGON = @as(u32, 784);
pub const ERROR_NO_REG_CERT_AT_LOGON = @as(u32, 785);
pub const ERROR_OAKLEY_NO_CERT = @as(u32, 786);
pub const ERROR_OAKLEY_AUTH_FAIL = @as(u32, 787);
pub const ERROR_OAKLEY_ATTRIB_FAIL = @as(u32, 788);
pub const ERROR_OAKLEY_GENERAL_PROCESSING = @as(u32, 789);
pub const ERROR_OAKLEY_NO_PEER_CERT = @as(u32, 790);
pub const ERROR_OAKLEY_NO_POLICY = @as(u32, 791);
pub const ERROR_OAKLEY_TIMED_OUT = @as(u32, 792);
pub const ERROR_OAKLEY_ERROR = @as(u32, 793);
pub const ERROR_UNKNOWN_FRAMED_PROTOCOL = @as(u32, 794);
pub const ERROR_WRONG_TUNNEL_TYPE = @as(u32, 795);
pub const ERROR_UNKNOWN_SERVICE_TYPE = @as(u32, 796);
pub const ERROR_CONNECTING_DEVICE_NOT_FOUND = @as(u32, 797);
pub const ERROR_NO_EAPTLS_CERTIFICATE = @as(u32, 798);
pub const ERROR_SHARING_HOST_ADDRESS_CONFLICT = @as(u32, 799);
pub const ERROR_AUTOMATIC_VPN_FAILED = @as(u32, 800);
pub const ERROR_VALIDATING_SERVER_CERT = @as(u32, 801);
pub const ERROR_READING_SCARD = @as(u32, 802);
pub const ERROR_INVALID_PEAP_COOKIE_CONFIG = @as(u32, 803);
pub const ERROR_INVALID_PEAP_COOKIE_USER = @as(u32, 804);
pub const ERROR_INVALID_MSCHAPV2_CONFIG = @as(u32, 805);
pub const ERROR_VPN_GRE_BLOCKED = @as(u32, 806);
pub const ERROR_VPN_DISCONNECT = @as(u32, 807);
pub const ERROR_VPN_REFUSED = @as(u32, 808);
pub const ERROR_VPN_TIMEOUT = @as(u32, 809);
pub const ERROR_VPN_BAD_CERT = @as(u32, 810);
pub const ERROR_VPN_BAD_PSK = @as(u32, 811);
pub const ERROR_SERVER_POLICY = @as(u32, 812);
pub const ERROR_BROADBAND_ACTIVE = @as(u32, 813);
pub const ERROR_BROADBAND_NO_NIC = @as(u32, 814);
pub const ERROR_BROADBAND_TIMEOUT = @as(u32, 815);
pub const ERROR_FEATURE_DEPRECATED = @as(u32, 816);
pub const ERROR_CANNOT_DELETE = @as(u32, 817);
pub const ERROR_RASQEC_RESOURCE_CREATION_FAILED = @as(u32, 818);
pub const ERROR_RASQEC_NAPAGENT_NOT_ENABLED = @as(u32, 819);
pub const ERROR_RASQEC_NAPAGENT_NOT_CONNECTED = @as(u32, 820);
pub const ERROR_RASQEC_CONN_DOESNOTEXIST = @as(u32, 821);
pub const ERROR_RASQEC_TIMEOUT = @as(u32, 822);
pub const ERROR_PEAP_CRYPTOBINDING_INVALID = @as(u32, 823);
pub const ERROR_PEAP_CRYPTOBINDING_NOTRECEIVED = @as(u32, 824);
pub const ERROR_INVALID_VPNSTRATEGY = @as(u32, 825);
pub const ERROR_EAPTLS_CACHE_CREDENTIALS_INVALID = @as(u32, 826);
pub const ERROR_IPSEC_SERVICE_STOPPED = @as(u32, 827);
pub const ERROR_IDLE_TIMEOUT = @as(u32, 828);
pub const ERROR_LINK_FAILURE = @as(u32, 829);
pub const ERROR_USER_LOGOFF = @as(u32, 830);
pub const ERROR_FAST_USER_SWITCH = @as(u32, 831);
pub const ERROR_HIBERNATION = @as(u32, 832);
pub const ERROR_SYSTEM_SUSPENDED = @as(u32, 833);
pub const ERROR_RASMAN_SERVICE_STOPPED = @as(u32, 834);
pub const ERROR_INVALID_SERVER_CERT = @as(u32, 835);
pub const ERROR_NOT_NAP_CAPABLE = @as(u32, 836);
pub const ERROR_INVALID_TUNNELID = @as(u32, 837);
pub const ERROR_UPDATECONNECTION_REQUEST_IN_PROCESS = @as(u32, 838);
pub const ERROR_PROTOCOL_ENGINE_DISABLED = @as(u32, 839);
pub const ERROR_INTERNAL_ADDRESS_FAILURE = @as(u32, 840);
pub const ERROR_FAILED_CP_REQUIRED = @as(u32, 841);
pub const ERROR_TS_UNACCEPTABLE = @as(u32, 842);
pub const ERROR_MOBIKE_DISABLED = @as(u32, 843);
pub const ERROR_CANNOT_INITIATE_MOBIKE_UPDATE = @as(u32, 844);
pub const ERROR_PEAP_SERVER_REJECTED_CLIENT_TLV = @as(u32, 845);
pub const ERROR_INVALID_PREFERENCES = @as(u32, 846);
pub const ERROR_EAPTLS_SCARD_CACHE_CREDENTIALS_INVALID = @as(u32, 847);
pub const ERROR_SSTP_COOKIE_SET_FAILURE = @as(u32, 848);
pub const ERROR_INVALID_PEAP_COOKIE_ATTRIBUTES = @as(u32, 849);
pub const ERROR_EAP_METHOD_NOT_INSTALLED = @as(u32, 850);
pub const ERROR_EAP_METHOD_DOES_NOT_SUPPORT_SSO = @as(u32, 851);
pub const ERROR_EAP_METHOD_OPERATION_NOT_SUPPORTED = @as(u32, 852);
pub const ERROR_EAP_USER_CERT_INVALID = @as(u32, 853);
pub const ERROR_EAP_USER_CERT_EXPIRED = @as(u32, 854);
pub const ERROR_EAP_USER_CERT_REVOKED = @as(u32, 855);
pub const ERROR_EAP_USER_CERT_OTHER_ERROR = @as(u32, 856);
pub const ERROR_EAP_SERVER_CERT_INVALID = @as(u32, 857);
pub const ERROR_EAP_SERVER_CERT_EXPIRED = @as(u32, 858);
pub const ERROR_EAP_SERVER_CERT_REVOKED = @as(u32, 859);
pub const ERROR_EAP_SERVER_CERT_OTHER_ERROR = @as(u32, 860);
pub const ERROR_EAP_USER_ROOT_CERT_NOT_FOUND = @as(u32, 861);
pub const ERROR_EAP_USER_ROOT_CERT_INVALID = @as(u32, 862);
pub const ERROR_EAP_USER_ROOT_CERT_EXPIRED = @as(u32, 863);
pub const ERROR_EAP_SERVER_ROOT_CERT_NOT_FOUND = @as(u32, 864);
pub const ERROR_EAP_SERVER_ROOT_CERT_INVALID = @as(u32, 865);
pub const ERROR_EAP_SERVER_ROOT_CERT_NAME_REQUIRED = @as(u32, 866);
pub const ERROR_PEAP_IDENTITY_MISMATCH = @as(u32, 867);
pub const ERROR_DNSNAME_NOT_RESOLVABLE = @as(u32, 868);
pub const ERROR_EAPTLS_PASSWD_INVALID = @as(u32, 869);
pub const ERROR_IKEV2_PSK_INTERFACE_ALREADY_EXISTS = @as(u32, 870);
pub const ERROR_INVALID_DESTINATION_IP = @as(u32, 871);
pub const ERROR_INVALID_INTERFACE_CONFIG = @as(u32, 872);
pub const ERROR_VPN_PLUGIN_GENERIC = @as(u32, 873);
pub const ERROR_SSO_CERT_MISSING = @as(u32, 874);
pub const ERROR_DEVICE_COMPLIANCE = @as(u32, 875);
pub const ERROR_PLUGIN_NOT_INSTALLED = @as(u32, 876);
pub const ERROR_ACTION_REQUIRED = @as(u32, 877);
pub const RASBASEEND = @as(u32, 877);

//--------------------------------------------------------------------------------
// Section: Types (224)
//--------------------------------------------------------------------------------
pub const MPR_INTERFACE_DIAL_MODE = enum(u32) {
    First = 0,
    All = 1,
    AsNeeded = 2,
};
pub const MPRDM_DialFirst = MPR_INTERFACE_DIAL_MODE.First;
pub const MPRDM_DialAll = MPR_INTERFACE_DIAL_MODE.All;
pub const MPRDM_DialAsNeeded = MPR_INTERFACE_DIAL_MODE.AsNeeded;

pub const RASENTRY_DIAL_MODE = enum(u32) {
    ll = 1,
    sNeeded = 2,
};
pub const RASEDM_DialAll = RASENTRY_DIAL_MODE.ll;
pub const RASEDM_DialAsNeeded = RASENTRY_DIAL_MODE.sNeeded;

pub const RAS_FLAGS = enum(u32) {
    PPP_CONNECTION = 1,
    MESSENGER_PRESENT = 2,
    QUARANTINE_PRESENT = 8,
    ARAP_CONNECTION = 16,
    // IKEV2_CONNECTION = 16, this enum value conflicts with ARAP_CONNECTION
    DORMANT = 32,
};
pub const RAS_FLAGS_PPP_CONNECTION = RAS_FLAGS.PPP_CONNECTION;
pub const RAS_FLAGS_MESSENGER_PRESENT = RAS_FLAGS.MESSENGER_PRESENT;
pub const RAS_FLAGS_QUARANTINE_PRESENT = RAS_FLAGS.QUARANTINE_PRESENT;
pub const RAS_FLAGS_ARAP_CONNECTION = RAS_FLAGS.ARAP_CONNECTION;
pub const RAS_FLAGS_IKEV2_CONNECTION = RAS_FLAGS.ARAP_CONNECTION;
pub const RAS_FLAGS_DORMANT = RAS_FLAGS.DORMANT;

pub const MPR_ET = enum(u32) {
    None = 0,
    Require = 1,
    RequireMax = 2,
    Optional = 3,
};
pub const MPR_ET_None = MPR_ET.None;
pub const MPR_ET_Require = MPR_ET.Require;
pub const MPR_ET_RequireMax = MPR_ET.RequireMax;
pub const MPR_ET_Optional = MPR_ET.Optional;

pub const RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA = enum(u32) {
    D5 = 5,
    S = 128,
    SV2 = 129,
};
pub const RASLCPAD_CHAP_MD5 = RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA.D5;
pub const RASLCPAD_CHAP_MS = RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA.S;
pub const RASLCPAD_CHAP_MSV2 = RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA.SV2;

pub const PPP_LCP = enum(u32) {
    PAP = 49187,
    CHAP = 49699,
    EAP = 49703,
    SPAP = 49191,
};
pub const PPP_LCP_PAP = PPP_LCP.PAP;
pub const PPP_LCP_CHAP = PPP_LCP.CHAP;
pub const PPP_LCP_EAP = PPP_LCP.EAP;
pub const PPP_LCP_SPAP = PPP_LCP.SPAP;

pub const RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL = enum(u32) {
    PAP = 49187,
    SPAP = 49191,
    CHAP = 49699,
    EAP = 49703,
};
pub const RASLCPAP_PAP = RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL.PAP;
pub const RASLCPAP_SPAP = RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL.SPAP;
pub const RASLCPAP_CHAP = RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL.CHAP;
pub const RASLCPAP_EAP = RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL.EAP;

pub const PPP_LCP_INFO_AUTH_DATA = enum(u32) {
    D5 = 5,
    S = 128,
    SV2 = 129,
};
pub const PPP_LCP_CHAP_MD5 = PPP_LCP_INFO_AUTH_DATA.D5;
pub const PPP_LCP_CHAP_MS = PPP_LCP_INFO_AUTH_DATA.S;
pub const PPP_LCP_CHAP_MSV2 = PPP_LCP_INFO_AUTH_DATA.SV2;

pub const RASIKEV_PROJECTION_INFO_FLAGS = enum(u32) {
    MOBIKESUPPORTED = 1,
    BEHIND_NAT = 2,
    SERVERBEHIND_NAT = 4,
    _,
    pub fn initFlags(o: struct {
        MOBIKESUPPORTED: u1 = 0,
        BEHIND_NAT: u1 = 0,
        SERVERBEHIND_NAT: u1 = 0,
    }) RASIKEV_PROJECTION_INFO_FLAGS {
        return @as(RASIKEV_PROJECTION_INFO_FLAGS, @enumFromInt((if (o.MOBIKESUPPORTED == 1) @intFromEnum(RASIKEV_PROJECTION_INFO_FLAGS.MOBIKESUPPORTED) else 0) | (if (o.BEHIND_NAT == 1) @intFromEnum(RASIKEV_PROJECTION_INFO_FLAGS.BEHIND_NAT) else 0) | (if (o.SERVERBEHIND_NAT == 1) @intFromEnum(RASIKEV_PROJECTION_INFO_FLAGS.SERVERBEHIND_NAT) else 0)));
    }
};
pub const RASIKEv2_FLAGS_MOBIKESUPPORTED = RASIKEV_PROJECTION_INFO_FLAGS.MOBIKESUPPORTED;
pub const RASIKEv2_FLAGS_BEHIND_NAT = RASIKEV_PROJECTION_INFO_FLAGS.BEHIND_NAT;
pub const RASIKEv2_FLAGS_SERVERBEHIND_NAT = RASIKEV_PROJECTION_INFO_FLAGS.SERVERBEHIND_NAT;

pub const MPR_VS = enum(u32) {
    Default = 0,
    PptpOnly = 1,
    PptpFirst = 2,
    L2tpOnly = 3,
    L2tpFirst = 4,
};
pub const MPR_VS_Default = MPR_VS.Default;
pub const MPR_VS_PptpOnly = MPR_VS.PptpOnly;
pub const MPR_VS_PptpFirst = MPR_VS.PptpFirst;
pub const MPR_VS_L2tpOnly = MPR_VS.L2tpOnly;
pub const MPR_VS_L2tpFirst = MPR_VS.L2tpFirst;

pub const SECURITY_MESSAGE_MSG_ID = enum(u32) {
    SUCCESS = 1,
    FAILURE = 2,
    ERROR = 3,
};
pub const SECURITYMSG_SUCCESS = SECURITY_MESSAGE_MSG_ID.SUCCESS;
pub const SECURITYMSG_FAILURE = SECURITY_MESSAGE_MSG_ID.FAILURE;
pub const SECURITYMSG_ERROR = SECURITY_MESSAGE_MSG_ID.ERROR;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HRASCONN = *opaque {};

pub const RASAPIVERSION = enum(i32) {
    @"500" = 1,
    @"501" = 2,
    @"600" = 3,
    @"601" = 4,
};
pub const RASAPIVERSION_500 = RASAPIVERSION.@"500";
pub const RASAPIVERSION_501 = RASAPIVERSION.@"501";
pub const RASAPIVERSION_600 = RASAPIVERSION.@"600";
pub const RASAPIVERSION_601 = RASAPIVERSION.@"601";

pub const RASIPADDR = extern struct {
    a: u8,
    b: u8,
    c: u8,
    d: u8,
};

pub const RASTUNNELENDPOINT = extern struct {
    dwType: u32,
    Anonymous: extern union {
        ipv4: IN_ADDR,
        ipv6: IN6_ADDR,
    },
};

pub const RASCONNW = extern struct {
    dwSize: u32 align(4),
    hrasconn: ?HRASCONN align(4),
    szEntryName: [257]u16 align(4),
    szDeviceType: [17]u16 align(4),
    szDeviceName: [129]u16 align(4),
    szPhonebook: [260]u16 align(4),
    dwSubEntry: u32 align(4),
    guidEntry: Guid align(4),
    dwFlags: u32 align(4),
    luid: LUID align(4),
    guidCorrelationId: Guid align(4),
};

pub const RASCONNA = extern struct {
    dwSize: u32 align(4),
    hrasconn: ?HRASCONN align(4),
    szEntryName: [257]CHAR align(4),
    szDeviceType: [17]CHAR align(4),
    szDeviceName: [129]CHAR align(4),
    szPhonebook: [260]CHAR align(4),
    dwSubEntry: u32 align(4),
    guidEntry: Guid align(4),
    dwFlags: u32 align(4),
    luid: LUID align(4),
    guidCorrelationId: Guid align(4),
};

pub const RASCONNSTATE = enum(i32) {
    OpenPort = 0,
    PortOpened = 1,
    ConnectDevice = 2,
    DeviceConnected = 3,
    AllDevicesConnected = 4,
    Authenticate = 5,
    AuthNotify = 6,
    AuthRetry = 7,
    AuthCallback = 8,
    AuthChangePassword = 9,
    AuthProject = 10,
    AuthLinkSpeed = 11,
    AuthAck = 12,
    ReAuthenticate = 13,
    Authenticated = 14,
    PrepareForCallback = 15,
    WaitForModemReset = 16,
    WaitForCallback = 17,
    Projected = 18,
    StartAuthentication = 19,
    CallbackComplete = 20,
    LogonNetwork = 21,
    SubEntryConnected = 22,
    SubEntryDisconnected = 23,
    ApplySettings = 24,
    Interactive = 4096,
    RetryAuthentication = 4097,
    CallbackSetByCaller = 4098,
    PasswordExpired = 4099,
    InvokeEapUI = 4100,
    Connected = 8192,
    Disconnected = 8193,
};
pub const RASCS_OpenPort = RASCONNSTATE.OpenPort;
pub const RASCS_PortOpened = RASCONNSTATE.PortOpened;
pub const RASCS_ConnectDevice = RASCONNSTATE.ConnectDevice;
pub const RASCS_DeviceConnected = RASCONNSTATE.DeviceConnected;
pub const RASCS_AllDevicesConnected = RASCONNSTATE.AllDevicesConnected;
pub const RASCS_Authenticate = RASCONNSTATE.Authenticate;
pub const RASCS_AuthNotify = RASCONNSTATE.AuthNotify;
pub const RASCS_AuthRetry = RASCONNSTATE.AuthRetry;
pub const RASCS_AuthCallback = RASCONNSTATE.AuthCallback;
pub const RASCS_AuthChangePassword = RASCONNSTATE.AuthChangePassword;
pub const RASCS_AuthProject = RASCONNSTATE.AuthProject;
pub const RASCS_AuthLinkSpeed = RASCONNSTATE.AuthLinkSpeed;
pub const RASCS_AuthAck = RASCONNSTATE.AuthAck;
pub const RASCS_ReAuthenticate = RASCONNSTATE.ReAuthenticate;
pub const RASCS_Authenticated = RASCONNSTATE.Authenticated;
pub const RASCS_PrepareForCallback = RASCONNSTATE.PrepareForCallback;
pub const RASCS_WaitForModemReset = RASCONNSTATE.WaitForModemReset;
pub const RASCS_WaitForCallback = RASCONNSTATE.WaitForCallback;
pub const RASCS_Projected = RASCONNSTATE.Projected;
pub const RASCS_StartAuthentication = RASCONNSTATE.StartAuthentication;
pub const RASCS_CallbackComplete = RASCONNSTATE.CallbackComplete;
pub const RASCS_LogonNetwork = RASCONNSTATE.LogonNetwork;
pub const RASCS_SubEntryConnected = RASCONNSTATE.SubEntryConnected;
pub const RASCS_SubEntryDisconnected = RASCONNSTATE.SubEntryDisconnected;
pub const RASCS_ApplySettings = RASCONNSTATE.ApplySettings;
pub const RASCS_Interactive = RASCONNSTATE.Interactive;
pub const RASCS_RetryAuthentication = RASCONNSTATE.RetryAuthentication;
pub const RASCS_CallbackSetByCaller = RASCONNSTATE.CallbackSetByCaller;
pub const RASCS_PasswordExpired = RASCONNSTATE.PasswordExpired;
pub const RASCS_InvokeEapUI = RASCONNSTATE.InvokeEapUI;
pub const RASCS_Connected = RASCONNSTATE.Connected;
pub const RASCS_Disconnected = RASCONNSTATE.Disconnected;

pub const RASCONNSUBSTATE = enum(i32) {
    None = 0,
    Dormant = 1,
    Reconnecting = 2,
    Reconnected = 8192,
};
pub const RASCSS_None = RASCONNSUBSTATE.None;
pub const RASCSS_Dormant = RASCONNSUBSTATE.Dormant;
pub const RASCSS_Reconnecting = RASCONNSUBSTATE.Reconnecting;
pub const RASCSS_Reconnected = RASCONNSUBSTATE.Reconnected;

pub const RASCONNSTATUSW = extern struct {
    dwSize: u32,
    rasconnstate: RASCONNSTATE,
    dwError: u32,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szPhoneNumber: [129]u16,
    localEndPoint: RASTUNNELENDPOINT,
    remoteEndPoint: RASTUNNELENDPOINT,
    rasconnsubstate: RASCONNSUBSTATE,
};

pub const RASCONNSTATUSA = extern struct {
    dwSize: u32,
    rasconnstate: RASCONNSTATE,
    dwError: u32,
    szDeviceType: [17]CHAR,
    szDeviceName: [129]CHAR,
    szPhoneNumber: [129]CHAR,
    localEndPoint: RASTUNNELENDPOINT,
    remoteEndPoint: RASTUNNELENDPOINT,
    rasconnsubstate: RASCONNSUBSTATE,
};

pub const RASDIALPARAMSW = extern struct {
    dwSize: u32 align(4),
    szEntryName: [257]u16 align(4),
    szPhoneNumber: [129]u16 align(4),
    szCallbackNumber: [129]u16 align(4),
    szUserName: [257]u16 align(4),
    szPassword: [257]u16 align(4),
    szDomain: [16]u16 align(4),
    dwSubEntry: u32 align(4),
    dwCallbackId: usize align(4),
    dwIfIndex: u32 align(4),
    szEncPassword: ?PWSTR align(4),
};

pub const RASDIALPARAMSA = extern struct {
    dwSize: u32 align(4),
    szEntryName: [257]CHAR align(4),
    szPhoneNumber: [129]CHAR align(4),
    szCallbackNumber: [129]CHAR align(4),
    szUserName: [257]CHAR align(4),
    szPassword: [257]CHAR align(4),
    szDomain: [16]CHAR align(4),
    dwSubEntry: u32 align(4),
    dwCallbackId: usize align(4),
    dwIfIndex: u32 align(4),
    szEncPassword: ?PSTR align(4),
};

pub const RASEAPINFO = extern struct {
    dwSizeofEapInfo: u32 align(4),
    pbEapInfo: ?*u8 align(4),
};

pub const RASDEVSPECIFICINFO = extern struct {
    dwSize: u32 align(4),
    pbDevSpecificInfo: ?*u8 align(4),
};

pub const RASDIALEXTENSIONS = extern struct {
    dwSize: u32 align(4),
    dwfOptions: u32 align(4),
    hwndParent: ?HWND align(4),
    reserved: usize align(4),
    reserved1: usize align(4),
    RasEapInfo: RASEAPINFO align(4),
    fSkipPppAuth: BOOL align(4),
    RasDevSpecificInfo: RASDEVSPECIFICINFO align(4),
};

pub const RASENTRYNAMEW = extern struct {
    dwSize: u32,
    szEntryName: [257]u16,
    dwFlags: u32,
    szPhonebookPath: [261]u16,
};

pub const RASENTRYNAMEA = extern struct {
    dwSize: u32,
    szEntryName: [257]CHAR,
    dwFlags: u32,
    szPhonebookPath: [261]CHAR,
};

pub const RASPROJECTION = enum(i32) {
    Amb = 65536,
    PppNbf = 32831,
    PppIpx = 32811,
    PppIp = 32801,
    PppCcp = 33021,
    PppLcp = 49185,
    PppIpv6 = 32855,
};
pub const RASP_Amb = RASPROJECTION.Amb;
pub const RASP_PppNbf = RASPROJECTION.PppNbf;
pub const RASP_PppIpx = RASPROJECTION.PppIpx;
pub const RASP_PppIp = RASPROJECTION.PppIp;
pub const RASP_PppCcp = RASPROJECTION.PppCcp;
pub const RASP_PppLcp = RASPROJECTION.PppLcp;
pub const RASP_PppIpv6 = RASPROJECTION.PppIpv6;

pub const RASAMBW = extern struct {
    dwSize: u32,
    dwError: u32,
    szNetBiosError: [17]u16,
    bLana: u8,
};

pub const RASAMBA = extern struct {
    dwSize: u32,
    dwError: u32,
    szNetBiosError: [17]CHAR,
    bLana: u8,
};

pub const RASPPPNBFW = extern struct {
    dwSize: u32,
    dwError: u32,
    dwNetBiosError: u32,
    szNetBiosError: [17]u16,
    szWorkstationName: [17]u16,
    bLana: u8,
};

pub const RASPPPNBFA = extern struct {
    dwSize: u32,
    dwError: u32,
    dwNetBiosError: u32,
    szNetBiosError: [17]CHAR,
    szWorkstationName: [17]CHAR,
    bLana: u8,
};

pub const RASIPXW = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpxAddress: [22]u16,
};

pub const RASPPPIPXA = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpxAddress: [22]CHAR,
};

pub const RASPPPIPW = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpAddress: [16]u16,
    szServerIpAddress: [16]u16,
    dwOptions: u32,
    dwServerOptions: u32,
};

pub const RASPPPIPA = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpAddress: [16]CHAR,
    szServerIpAddress: [16]CHAR,
    dwOptions: u32,
    dwServerOptions: u32,
};

pub const RASPPPIPV6 = extern struct {
    dwSize: u32,
    dwError: u32,
    bLocalInterfaceIdentifier: [8]u8,
    bPeerInterfaceIdentifier: [8]u8,
    bLocalCompressionProtocol: [2]u8,
    bPeerCompressionProtocol: [2]u8,
};

pub const RASPPPLCPW = extern struct {
    dwSize: u32,
    fBundled: BOOL,
    dwError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwEapTypeId: u32,
    dwServerAuthenticationProtocol: u32,
    dwServerAuthenticationData: u32,
    dwServerEapTypeId: u32,
    fMultilink: BOOL,
    dwTerminateReason: u32,
    dwServerTerminateReason: u32,
    szReplyMessage: [1024]u16,
    dwOptions: u32,
    dwServerOptions: u32,
};

pub const RASPPPLCPA = extern struct {
    dwSize: u32,
    fBundled: BOOL,
    dwError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwEapTypeId: u32,
    dwServerAuthenticationProtocol: u32,
    dwServerAuthenticationData: u32,
    dwServerEapTypeId: u32,
    fMultilink: BOOL,
    dwTerminateReason: u32,
    dwServerTerminateReason: u32,
    szReplyMessage: [1024]CHAR,
    dwOptions: u32,
    dwServerOptions: u32,
};

pub const RASPPPCCP = extern struct {
    dwSize: u32,
    dwError: u32,
    dwCompressionAlgorithm: u32,
    dwOptions: u32,
    dwServerCompressionAlgorithm: u32,
    dwServerOptions: u32,
};

pub const RASPPP_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    ipv4Address: IN_ADDR,
    ipv4ServerAddress: IN_ADDR,
    dwIPv4Options: u32,
    dwIPv4ServerOptions: u32,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: [8]u8,
    bServerInterfaceIdentifier: [8]u8,
    fBundled: BOOL,
    fMultilink: BOOL,
    dwAuthenticationProtocol: RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL,
    dwAuthenticationData: RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA,
    dwServerAuthenticationProtocol: RASPPP_PROJECTION_INFO_SERVER_AUTH_PROTOCOL,
    dwServerAuthenticationData: RASPPP_PROJECTION_INFO_SERVER_AUTH_DATA,
    dwEapTypeId: u32,
    dwServerEapTypeId: u32,
    dwLcpOptions: u32,
    dwLcpServerOptions: u32,
    dwCcpError: u32,
    dwCcpCompressionAlgorithm: u32,
    dwCcpServerCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwCcpServerOptions: u32,
};

pub const RASIKEV2_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32 align(4),
    ipv4Address: IN_ADDR align(4),
    ipv4ServerAddress: IN_ADDR align(4),
    dwIPv6NegotiationError: u32 align(4),
    ipv6Address: IN6_ADDR align(4),
    ipv6ServerAddress: IN6_ADDR align(4),
    dwPrefixLength: u32 align(4),
    dwAuthenticationProtocol: u32 align(4),
    dwEapTypeId: u32 align(4),
    dwFlags: RASIKEV_PROJECTION_INFO_FLAGS align(4),
    dwEncryptionMethod: u32 align(4),
    numIPv4ServerAddresses: u32 align(4),
    ipv4ServerAddresses: ?*IN_ADDR align(4),
    numIPv6ServerAddresses: u32 align(4),
    ipv6ServerAddresses: ?*IN6_ADDR align(4),
};

pub const RASPROJECTION_INFO_TYPE = enum(i32) {
    PPP = 1,
    IKEv2 = 2,
};
pub const PROJECTION_INFO_TYPE_PPP = RASPROJECTION_INFO_TYPE.PPP;
pub const PROJECTION_INFO_TYPE_IKEv2 = RASPROJECTION_INFO_TYPE.IKEv2;

pub const IKEV2_ID_PAYLOAD_TYPE = enum(i32) {
    INVALID = 0,
    IPV4_ADDR = 1,
    FQDN = 2,
    RFC822_ADDR = 3,
    RESERVED1 = 4,
    ID_IPV6_ADDR = 5,
    RESERVED2 = 6,
    RESERVED3 = 7,
    RESERVED4 = 8,
    DER_ASN1_DN = 9,
    DER_ASN1_GN = 10,
    KEY_ID = 11,
    MAX = 12,
};
pub const IKEV2_ID_PAYLOAD_TYPE_INVALID = IKEV2_ID_PAYLOAD_TYPE.INVALID;
pub const IKEV2_ID_PAYLOAD_TYPE_IPV4_ADDR = IKEV2_ID_PAYLOAD_TYPE.IPV4_ADDR;
pub const IKEV2_ID_PAYLOAD_TYPE_FQDN = IKEV2_ID_PAYLOAD_TYPE.FQDN;
pub const IKEV2_ID_PAYLOAD_TYPE_RFC822_ADDR = IKEV2_ID_PAYLOAD_TYPE.RFC822_ADDR;
pub const IKEV2_ID_PAYLOAD_TYPE_RESERVED1 = IKEV2_ID_PAYLOAD_TYPE.RESERVED1;
pub const IKEV2_ID_PAYLOAD_TYPE_ID_IPV6_ADDR = IKEV2_ID_PAYLOAD_TYPE.ID_IPV6_ADDR;
pub const IKEV2_ID_PAYLOAD_TYPE_RESERVED2 = IKEV2_ID_PAYLOAD_TYPE.RESERVED2;
pub const IKEV2_ID_PAYLOAD_TYPE_RESERVED3 = IKEV2_ID_PAYLOAD_TYPE.RESERVED3;
pub const IKEV2_ID_PAYLOAD_TYPE_RESERVED4 = IKEV2_ID_PAYLOAD_TYPE.RESERVED4;
pub const IKEV2_ID_PAYLOAD_TYPE_DER_ASN1_DN = IKEV2_ID_PAYLOAD_TYPE.DER_ASN1_DN;
pub const IKEV2_ID_PAYLOAD_TYPE_DER_ASN1_GN = IKEV2_ID_PAYLOAD_TYPE.DER_ASN1_GN;
pub const IKEV2_ID_PAYLOAD_TYPE_KEY_ID = IKEV2_ID_PAYLOAD_TYPE.KEY_ID;
pub const IKEV2_ID_PAYLOAD_TYPE_MAX = IKEV2_ID_PAYLOAD_TYPE.MAX;

pub const RAS_PROJECTION_INFO = extern struct {
    version: RASAPIVERSION,
    type: RASPROJECTION_INFO_TYPE,
    Anonymous: extern union {
        ppp: RASPPP_PROJECTION_INFO,
        ikev2: RASIKEV2_PROJECTION_INFO,
    },
};

pub const RASDIALFUNC = *const fn (
    param0: u32,
    param1: RASCONNSTATE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RASDIALFUNC1 = *const fn (
    param0: ?HRASCONN,
    param1: u32,
    param2: RASCONNSTATE,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RASDIALFUNC2 = *const fn (
    param0: usize,
    param1: u32,
    param2: ?HRASCONN,
    param3: u32,
    param4: RASCONNSTATE,
    param5: u32,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RASDEVINFOW = extern struct {
    dwSize: u32,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
};

pub const RASDEVINFOA = extern struct {
    dwSize: u32,
    szDeviceType: [17]CHAR,
    szDeviceName: [129]CHAR,
};

pub const RASCTRYINFO = extern struct {
    dwSize: u32,
    dwCountryID: u32,
    dwNextCountryID: u32,
    dwCountryCode: u32,
    dwCountryNameOffset: u32,
};

pub const RASENTRYA = extern struct {
    dwSize: u32,
    dwfOptions: u32,
    dwCountryID: u32,
    dwCountryCode: u32,
    szAreaCode: [11]CHAR,
    szLocalPhoneNumber: [129]CHAR,
    dwAlternateOffset: u32,
    ipaddr: RASIPADDR,
    ipaddrDns: RASIPADDR,
    ipaddrDnsAlt: RASIPADDR,
    ipaddrWins: RASIPADDR,
    ipaddrWinsAlt: RASIPADDR,
    dwFrameSize: u32,
    dwfNetProtocols: u32,
    dwFramingProtocol: u32,
    szScript: [260]CHAR,
    szAutodialDll: [260]CHAR,
    szAutodialFunc: [260]CHAR,
    szDeviceType: [17]CHAR,
    szDeviceName: [129]CHAR,
    szX25PadType: [33]CHAR,
    szX25Address: [201]CHAR,
    szX25Facilities: [201]CHAR,
    szX25UserData: [201]CHAR,
    dwChannels: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwSubEntries: u32,
    dwDialMode: RASENTRY_DIAL_MODE,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    guidId: Guid,
    szCustomDialDll: [260]CHAR,
    dwVpnStrategy: u32,
    dwfOptions2: u32,
    dwfOptions3: u32,
    szDnsSuffix: [256]CHAR,
    dwTcpWindowSize: u32,
    szPrerequisitePbk: [260]CHAR,
    szPrerequisiteEntry: [257]CHAR,
    dwRedialCount: u32,
    dwRedialPause: u32,
    ipv6addrDns: IN6_ADDR,
    ipv6addrDnsAlt: IN6_ADDR,
    dwIPv4InterfaceMetric: u32,
    dwIPv6InterfaceMetric: u32,
    ipv6addr: IN6_ADDR,
    dwIPv6PrefixLength: u32,
    dwNetworkOutageTime: u32,
    szIDi: [257]CHAR,
    szIDr: [257]CHAR,
    fIsImsConfig: BOOL,
    IdiType: IKEV2_ID_PAYLOAD_TYPE,
    IdrType: IKEV2_ID_PAYLOAD_TYPE,
    fDisableIKEv2Fragmentation: BOOL,
};

pub const RASENTRYW = extern struct {
    dwSize: u32,
    dwfOptions: u32,
    dwCountryID: u32,
    dwCountryCode: u32,
    szAreaCode: [11]u16,
    szLocalPhoneNumber: [129]u16,
    dwAlternateOffset: u32,
    ipaddr: RASIPADDR,
    ipaddrDns: RASIPADDR,
    ipaddrDnsAlt: RASIPADDR,
    ipaddrWins: RASIPADDR,
    ipaddrWinsAlt: RASIPADDR,
    dwFrameSize: u32,
    dwfNetProtocols: u32,
    dwFramingProtocol: u32,
    szScript: [260]u16,
    szAutodialDll: [260]u16,
    szAutodialFunc: [260]u16,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szX25PadType: [33]u16,
    szX25Address: [201]u16,
    szX25Facilities: [201]u16,
    szX25UserData: [201]u16,
    dwChannels: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwSubEntries: u32,
    dwDialMode: RASENTRY_DIAL_MODE,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    guidId: Guid,
    szCustomDialDll: [260]u16,
    dwVpnStrategy: u32,
    dwfOptions2: u32,
    dwfOptions3: u32,
    szDnsSuffix: [256]u16,
    dwTcpWindowSize: u32,
    szPrerequisitePbk: [260]u16,
    szPrerequisiteEntry: [257]u16,
    dwRedialCount: u32,
    dwRedialPause: u32,
    ipv6addrDns: IN6_ADDR,
    ipv6addrDnsAlt: IN6_ADDR,
    dwIPv4InterfaceMetric: u32,
    dwIPv6InterfaceMetric: u32,
    ipv6addr: IN6_ADDR,
    dwIPv6PrefixLength: u32,
    dwNetworkOutageTime: u32,
    szIDi: [257]u16,
    szIDr: [257]u16,
    fIsImsConfig: BOOL,
    IdiType: IKEV2_ID_PAYLOAD_TYPE,
    IdrType: IKEV2_ID_PAYLOAD_TYPE,
    fDisableIKEv2Fragmentation: BOOL,
};

pub const ORASADFUNC = *const fn (
    param0: ?HWND,
    param1: ?PSTR,
    param2: u32,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RASADPARAMS = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
};

pub const RASADFUNCA = *const fn (
    param0: ?PSTR,
    param1: ?PSTR,
    param2: ?*RASADPARAMS,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RASADFUNCW = *const fn (
    param0: ?PWSTR,
    param1: ?PWSTR,
    param2: ?*RASADPARAMS,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RASSUBENTRYA = extern struct {
    dwSize: u32,
    dwfFlags: u32,
    szDeviceType: [17]CHAR,
    szDeviceName: [129]CHAR,
    szLocalPhoneNumber: [129]CHAR,
    dwAlternateOffset: u32,
};

pub const RASSUBENTRYW = extern struct {
    dwSize: u32,
    dwfFlags: u32,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szLocalPhoneNumber: [129]u16,
    dwAlternateOffset: u32,
};

pub const RASCREDENTIALSA = extern struct {
    dwSize: u32,
    dwMask: u32,
    szUserName: [257]CHAR,
    szPassword: [257]CHAR,
    szDomain: [16]CHAR,
};

pub const RASCREDENTIALSW = extern struct {
    dwSize: u32,
    dwMask: u32,
    szUserName: [257]u16,
    szPassword: [257]u16,
    szDomain: [16]u16,
};

pub const RASAUTODIALENTRYA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwDialingLocation: u32,
    szEntry: [257]CHAR,
};

pub const RASAUTODIALENTRYW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwDialingLocation: u32,
    szEntry: [257]u16,
};

pub const RASEAPUSERIDENTITYA = extern struct {
    szUserName: [257]CHAR,
    dwSizeofEapInfo: u32,
    pbEapInfo: [1]u8,
};

pub const RASEAPUSERIDENTITYW = extern struct {
    szUserName: [257]u16,
    dwSizeofEapInfo: u32,
    pbEapInfo: [1]u8,
};

pub const PFNRASGETBUFFER = *const fn (
    pp_buffer: ?*?*u8,
    pdw_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNRASFREEBUFFER = *const fn (
    p_bufer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNRASSENDBUFFER = *const fn (
    h_port: ?HANDLE,
    p_buffer: ?*u8,
    dw_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNRASRECEIVEBUFFER = *const fn (
    h_port: ?HANDLE,
    p_buffer: ?*u8,
    pdw_size: ?*u32,
    dw_time_out: u32,
    h_event: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNRASRETRIEVEBUFFER = *const fn (
    h_port: ?HANDLE,
    p_buffer: ?*u8,
    pdw_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RasCustomScriptExecuteFn = *const fn (
    h_port: ?HANDLE,
    lpsz_phonebook: ?[*:0]const u16,
    lpsz_entry_name: ?[*:0]const u16,
    pfn_ras_get_buffer: ?PFNRASGETBUFFER,
    pfn_ras_free_buffer: ?PFNRASFREEBUFFER,
    pfn_ras_send_buffer: ?PFNRASSENDBUFFER,
    pfn_ras_receive_buffer: ?PFNRASRECEIVEBUFFER,
    pfn_ras_retrieve_buffer: ?PFNRASRETRIEVEBUFFER,
    h_wnd: ?HWND,
    p_ras_dial_params: ?*RASDIALPARAMSA,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RASCOMMSETTINGS = extern struct {
    dwSize: u32,
    bParity: u8,
    bStop: u8,
    bByteSize: u8,
    bAlign: u8,
};

pub const PFNRASSETCOMMSETTINGS = *const fn (
    h_port: ?HANDLE,
    p_ras_comm_settings: ?*RASCOMMSETTINGS,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RASCUSTOMSCRIPTEXTENSIONS = extern struct {
    dwSize: u32 align(4),
    pfnRasSetCommSettings: ?PFNRASSETCOMMSETTINGS align(4),
};

pub const RAS_STATS = extern struct {
    dwSize: u32,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwBps: u32,
    dwConnectDuration: u32,
};

pub const RasCustomHangUpFn = *const fn (
    h_ras_conn: ?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RasCustomDialFn = *const fn (
    h_inst_dll: ?HINSTANCE,
    lp_ras_dial_extensions: ?*RASDIALEXTENSIONS,
    lpsz_phonebook: ?[*:0]const u16,
    lp_ras_dial_params: ?*RASDIALPARAMSA,
    dw_notifier_type: u32,
    lpv_notifier: ?*anyopaque,
    lph_ras_conn: ?*?HRASCONN,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RasCustomDeleteEntryNotifyFn = *const fn (
    lpsz_phonebook: ?[*:0]const u16,
    lpsz_entry: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RASUPDATECONN = extern struct {
    version: RASAPIVERSION,
    dwSize: u32,
    dwFlags: u32,
    dwIfIndex: u32,
    localEndPoint: RASTUNNELENDPOINT,
    remoteEndPoint: RASTUNNELENDPOINT,
};

pub const RASPBDLGFUNCW = *const fn (
    param0: usize,
    param1: u32,
    param2: ?PWSTR,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RASPBDLGFUNCA = *const fn (
    param0: usize,
    param1: u32,
    param2: ?PSTR,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RASNOUSERW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwTimeoutMs: u32,
    szUserName: [257]u16,
    szPassword: [257]u16,
    szDomain: [16]u16,
};

pub const RASNOUSERA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwTimeoutMs: u32,
    szUserName: [257]CHAR,
    szPassword: [257]CHAR,
    szDomain: [16]CHAR,
};

pub const RASPBDLGW = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
    dwCallbackId: usize align(4),
    pCallback: ?RASPBDLGFUNCW align(4),
    dwError: u32 align(4),
    reserved: usize align(4),
    reserved2: usize align(4),
};

pub const RASPBDLGA = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
    dwCallbackId: usize align(4),
    pCallback: ?RASPBDLGFUNCA align(4),
    dwError: u32 align(4),
    reserved: usize align(4),
    reserved2: usize align(4),
};

pub const RASENTRYDLGW = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
    szEntry: [257]u16 align(4),
    dwError: u32 align(4),
    reserved: usize align(4),
    reserved2: usize align(4),
};

pub const RASENTRYDLGA = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
    szEntry: [257]CHAR align(4),
    dwError: u32 align(4),
    reserved: usize align(4),
    reserved2: usize align(4),
};

pub const RASDIALDLG = extern struct {
    dwSize: u32 align(4),
    hwndOwner: ?HWND align(4),
    dwFlags: u32 align(4),
    xDlg: i32 align(4),
    yDlg: i32 align(4),
    dwSubEntry: u32 align(4),
    dwError: u32 align(4),
    reserved: usize align(4),
    reserved2: usize align(4),
};

pub const RasCustomDialDlgFn = *const fn (
    h_inst_dll: ?HINSTANCE,
    dw_flags: u32,
    lpsz_phonebook: ?PWSTR,
    lpsz_entry: ?PWSTR,
    lpsz_phone_number: ?PWSTR,
    lp_info: ?*RASDIALDLG,
    pv_info: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RasCustomEntryDlgFn = *const fn (
    h_inst_dll: ?HINSTANCE,
    lpsz_phonebook: ?PWSTR,
    lpsz_entry: ?PWSTR,
    lp_info: ?*RASENTRYDLGA,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ROUTER_INTERFACE_TYPE = enum(i32) {
    CLIENT = 0,
    HOME_ROUTER = 1,
    FULL_ROUTER = 2,
    DEDICATED = 3,
    INTERNAL = 4,
    LOOPBACK = 5,
    TUNNEL1 = 6,
    DIALOUT = 7,
    MAX = 8,
};
pub const ROUTER_IF_TYPE_CLIENT = ROUTER_INTERFACE_TYPE.CLIENT;
pub const ROUTER_IF_TYPE_HOME_ROUTER = ROUTER_INTERFACE_TYPE.HOME_ROUTER;
pub const ROUTER_IF_TYPE_FULL_ROUTER = ROUTER_INTERFACE_TYPE.FULL_ROUTER;
pub const ROUTER_IF_TYPE_DEDICATED = ROUTER_INTERFACE_TYPE.DEDICATED;
pub const ROUTER_IF_TYPE_INTERNAL = ROUTER_INTERFACE_TYPE.INTERNAL;
pub const ROUTER_IF_TYPE_LOOPBACK = ROUTER_INTERFACE_TYPE.LOOPBACK;
pub const ROUTER_IF_TYPE_TUNNEL1 = ROUTER_INTERFACE_TYPE.TUNNEL1;
pub const ROUTER_IF_TYPE_DIALOUT = ROUTER_INTERFACE_TYPE.DIALOUT;
pub const ROUTER_IF_TYPE_MAX = ROUTER_INTERFACE_TYPE.MAX;

pub const ROUTER_CONNECTION_STATE = enum(i32) {
    UNREACHABLE = 0,
    DISCONNECTED = 1,
    CONNECTING = 2,
    CONNECTED = 3,
};
pub const ROUTER_IF_STATE_UNREACHABLE = ROUTER_CONNECTION_STATE.UNREACHABLE;
pub const ROUTER_IF_STATE_DISCONNECTED = ROUTER_CONNECTION_STATE.DISCONNECTED;
pub const ROUTER_IF_STATE_CONNECTING = ROUTER_CONNECTION_STATE.CONNECTING;
pub const ROUTER_IF_STATE_CONNECTED = ROUTER_CONNECTION_STATE.CONNECTED;

pub const MPR_INTERFACE_0 = extern struct {
    wszInterfaceName: [257]u16,
    hInterface: ?HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
};

pub const MPR_IPINIP_INTERFACE_0 = extern struct {
    wszFriendlyName: [257]u16,
    Guid: Guid,
};

pub const MPR_INTERFACE_1 = extern struct {
    wszInterfaceName: [257]u16,
    hInterface: ?HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    lpwsDialoutHoursRestriction: ?PWSTR,
};

pub const MPR_INTERFACE_2 = extern struct {
    wszInterfaceName: [257]u16,
    hInterface: ?HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    dwfOptions: u32,
    szLocalPhoneNumber: [129]u16,
    szAlternates: ?[*]u16,
    ipaddr: u32,
    ipaddrDns: u32,
    ipaddrDnsAlt: u32,
    ipaddrWins: u32,
    ipaddrWinsAlt: u32,
    dwfNetProtocols: u32,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szX25PadType: [33]u16,
    szX25Address: [201]u16,
    szX25Facilities: [201]u16,
    szX25UserData: [201]u16,
    dwChannels: u32,
    dwSubEntries: u32,
    dwDialMode: MPR_INTERFACE_DIAL_MODE,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: MPR_ET,
    dwCustomAuthKey: u32,
    dwCustomAuthDataSize: u32,
    lpbCustomAuthData: ?*u8,
    guidId: Guid,
    dwVpnStrategy: MPR_VS,
};

pub const MPR_INTERFACE_3 = extern struct {
    wszInterfaceName: [257]u16,
    hInterface: ?HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    dwfOptions: u32,
    szLocalPhoneNumber: [129]u16,
    szAlternates: ?[*]u16,
    ipaddr: u32,
    ipaddrDns: u32,
    ipaddrDnsAlt: u32,
    ipaddrWins: u32,
    ipaddrWinsAlt: u32,
    dwfNetProtocols: u32,
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szX25PadType: [33]u16,
    szX25Address: [201]u16,
    szX25Facilities: [201]u16,
    szX25UserData: [201]u16,
    dwChannels: u32,
    dwSubEntries: u32,
    dwDialMode: MPR_INTERFACE_DIAL_MODE,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: MPR_ET,
    dwCustomAuthKey: u32,
    dwCustomAuthDataSize: u32,
    lpbCustomAuthData: ?*u8,
    guidId: Guid,
    dwVpnStrategy: MPR_VS,
    AddressCount: u32,
    ipv6addrDns: IN6_ADDR,
    ipv6addrDnsAlt: IN6_ADDR,
    ipv6addr: ?*IN6_ADDR,
};

pub const MPR_DEVICE_0 = extern struct {
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
};

pub const MPR_DEVICE_1 = extern struct {
    szDeviceType: [17]u16,
    szDeviceName: [129]u16,
    szLocalPhoneNumber: [129]u16,
    szAlternates: ?[*]u16,
};

pub const MPR_CREDENTIALSEX_0 = extern struct {
    dwSize: u32,
    lpbCredentialsInfo: ?*u8,
};

pub const MPR_CREDENTIALSEX_1 = extern struct {
    dwSize: u32,
    lpbCredentialsInfo: ?*u8,
};

pub const MPR_TRANSPORT_0 = extern struct {
    dwTransportId: u32,
    hTransport: ?HANDLE,
    wszTransportName: [41]u16,
};

pub const MPR_IFTRANSPORT_0 = extern struct {
    dwTransportId: u32,
    hIfTransport: ?HANDLE,
    wszIfTransportName: [41]u16,
};

pub const MPR_SERVER_0 = extern struct {
    fLanOnlyMode: BOOL,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
};

pub const MPR_SERVER_1 = extern struct {
    dwNumPptpPorts: u32,
    dwPptpPortFlags: u32,
    dwNumL2tpPorts: u32,
    dwL2tpPortFlags: u32,
};

pub const MPR_SERVER_2 = extern struct {
    dwNumPptpPorts: u32,
    dwPptpPortFlags: u32,
    dwNumL2tpPorts: u32,
    dwL2tpPortFlags: u32,
    dwNumSstpPorts: u32,
    dwSstpPortFlags: u32,
};

pub const RAS_PORT_CONDITION = enum(i32) {
    NON_OPERATIONAL = 0,
    DISCONNECTED = 1,
    CALLING_BACK = 2,
    LISTENING = 3,
    AUTHENTICATING = 4,
    AUTHENTICATED = 5,
    INITIALIZING = 6,
};
pub const RAS_PORT_NON_OPERATIONAL = RAS_PORT_CONDITION.NON_OPERATIONAL;
pub const RAS_PORT_DISCONNECTED = RAS_PORT_CONDITION.DISCONNECTED;
pub const RAS_PORT_CALLING_BACK = RAS_PORT_CONDITION.CALLING_BACK;
pub const RAS_PORT_LISTENING = RAS_PORT_CONDITION.LISTENING;
pub const RAS_PORT_AUTHENTICATING = RAS_PORT_CONDITION.AUTHENTICATING;
pub const RAS_PORT_AUTHENTICATED = RAS_PORT_CONDITION.AUTHENTICATED;
pub const RAS_PORT_INITIALIZING = RAS_PORT_CONDITION.INITIALIZING;

pub const RAS_HARDWARE_CONDITION = enum(i32) {
    OPERATIONAL = 0,
    FAILURE = 1,
};
pub const RAS_HARDWARE_OPERATIONAL = RAS_HARDWARE_CONDITION.OPERATIONAL;
pub const RAS_HARDWARE_FAILURE = RAS_HARDWARE_CONDITION.FAILURE;

pub const RAS_PORT_0 = extern struct {
    hPort: ?HANDLE,
    hConnection: ?HANDLE,
    dwPortCondition: RAS_PORT_CONDITION,
    dwTotalNumberOfCalls: u32,
    dwConnectDuration: u32,
    wszPortName: [17]u16,
    wszMediaName: [17]u16,
    wszDeviceName: [129]u16,
    wszDeviceType: [17]u16,
};

pub const RAS_PORT_1 = extern struct {
    hPort: ?HANDLE,
    hConnection: ?HANDLE,
    dwHardwareCondition: RAS_HARDWARE_CONDITION,
    dwLineSpeed: u32,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
};

pub const RAS_PORT_2 = extern struct {
    hPort: ?HANDLE,
    hConnection: ?HANDLE,
    dwConn_State: u32,
    wszPortName: [17]u16,
    wszMediaName: [17]u16,
    wszDeviceName: [129]u16,
    wszDeviceType: [17]u16,
    dwHardwareCondition: RAS_HARDWARE_CONDITION,
    dwLineSpeed: u32,
    dwCrcErr: u32,
    dwSerialOverRunErrs: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwTotalErrors: u32,
    ullBytesXmited: u64,
    ullBytesRcved: u64,
    ullFramesXmited: u64,
    ullFramesRcved: u64,
    ullBytesTxUncompressed: u64,
    ullBytesTxCompressed: u64,
    ullBytesRcvUncompressed: u64,
    ullBytesRcvCompressed: u64,
};

pub const PPP_NBFCP_INFO = extern struct {
    dwError: u32,
    wszWksta: [17]u16,
};

pub const PPP_IPCP_INFO = extern struct {
    dwError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
};

pub const PPP_IPCP_INFO2 = extern struct {
    dwError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
    dwOptions: u32,
    dwRemoteOptions: u32,
};

pub const PPP_IPXCP_INFO = extern struct {
    dwError: u32,
    wszAddress: [23]u16,
};

pub const PPP_ATCP_INFO = extern struct {
    dwError: u32,
    wszAddress: [33]u16,
};

pub const PPP_IPV6_CP_INFO = extern struct {
    dwVersion: u32,
    dwSize: u32,
    dwError: u32,
    bInterfaceIdentifier: [8]u8,
    bRemoteInterfaceIdentifier: [8]u8,
    dwOptions: u32,
    dwRemoteOptions: u32,
    bPrefix: [8]u8,
    dwPrefixLength: u32,
};

pub const PPP_INFO = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO,
    ipx: PPP_IPXCP_INFO,
    at: PPP_ATCP_INFO,
};

pub const PPP_CCP_INFO = extern struct {
    dwError: u32,
    dwCompressionAlgorithm: u32,
    dwOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwRemoteOptions: u32,
};

pub const PPP_LCP_INFO = extern struct {
    dwError: u32,
    dwAuthenticationProtocol: PPP_LCP,
    dwAuthenticationData: PPP_LCP_INFO_AUTH_DATA,
    dwRemoteAuthenticationProtocol: u32,
    dwRemoteAuthenticationData: u32,
    dwTerminateReason: u32,
    dwRemoteTerminateReason: u32,
    dwOptions: u32,
    dwRemoteOptions: u32,
    dwEapTypeId: u32,
    dwRemoteEapTypeId: u32,
};

pub const PPP_INFO_2 = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO2,
    ipx: PPP_IPXCP_INFO,
    at: PPP_ATCP_INFO,
    ccp: PPP_CCP_INFO,
    lcp: PPP_LCP_INFO,
};

pub const PPP_INFO_3 = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO2,
    ipv6: PPP_IPV6_CP_INFO,
    ccp: PPP_CCP_INFO,
    lcp: PPP_LCP_INFO,
};

pub const RAS_CONNECTION_0 = extern struct {
    hConnection: ?HANDLE,
    hInterface: ?HANDLE,
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: RAS_FLAGS,
    wszInterfaceName: [257]u16,
    wszUserName: [257]u16,
    wszLogonDomain: [16]u16,
    wszRemoteComputer: [17]u16,
};

pub const RAS_CONNECTION_1 = extern struct {
    hConnection: ?HANDLE,
    hInterface: ?HANDLE,
    PppInfo: PPP_INFO,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
};

pub const RAS_CONNECTION_2 = extern struct {
    hConnection: ?HANDLE,
    wszUserName: [257]u16,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    guid: Guid,
    PppInfo2: PPP_INFO_2,
};

pub const RAS_QUARANTINE_STATE = enum(i32) {
    NORMAL = 0,
    QUARANTINE = 1,
    PROBATION = 2,
    NOT_CAPABLE = 3,
};
pub const RAS_QUAR_STATE_NORMAL = RAS_QUARANTINE_STATE.NORMAL;
pub const RAS_QUAR_STATE_QUARANTINE = RAS_QUARANTINE_STATE.QUARANTINE;
pub const RAS_QUAR_STATE_PROBATION = RAS_QUARANTINE_STATE.PROBATION;
pub const RAS_QUAR_STATE_NOT_CAPABLE = RAS_QUARANTINE_STATE.NOT_CAPABLE;

pub const RAS_CONNECTION_3 = extern struct {
    dwVersion: u32,
    dwSize: u32,
    hConnection: ?HANDLE,
    wszUserName: [257]u16,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    guid: Guid,
    PppInfo3: PPP_INFO_3,
    rasQuarState: RAS_QUARANTINE_STATE,
    timer: FILETIME,
};

pub const RAS_USER_0 = extern struct {
    bfPrivilege: u8,
    wszPhoneNumber: [129]u16,
};

pub const RAS_USER_1 = extern struct {
    bfPrivilege: u8,
    wszPhoneNumber: [129]u16,
    bfPrivilege2: u8,
};

pub const MPR_FILTER_0 = extern struct {
    fEnable: BOOL,
};

pub const MPRAPI_OBJECT_HEADER = extern struct {
    revision: u8,
    type: u8,
    size: u16,
};

pub const MPRAPI_OBJECT_TYPE = enum(i32) {
    RAS_CONNECTION_OBJECT = 1,
    MPR_SERVER_OBJECT = 2,
    MPR_SERVER_SET_CONFIG_OBJECT = 3,
    AUTH_VALIDATION_OBJECT = 4,
    UPDATE_CONNECTION_OBJECT = 5,
    IF_CUSTOM_CONFIG_OBJECT = 6,
};
pub const MPRAPI_OBJECT_TYPE_RAS_CONNECTION_OBJECT = MPRAPI_OBJECT_TYPE.RAS_CONNECTION_OBJECT;
pub const MPRAPI_OBJECT_TYPE_MPR_SERVER_OBJECT = MPRAPI_OBJECT_TYPE.MPR_SERVER_OBJECT;
pub const MPRAPI_OBJECT_TYPE_MPR_SERVER_SET_CONFIG_OBJECT = MPRAPI_OBJECT_TYPE.MPR_SERVER_SET_CONFIG_OBJECT;
pub const MPRAPI_OBJECT_TYPE_AUTH_VALIDATION_OBJECT = MPRAPI_OBJECT_TYPE.AUTH_VALIDATION_OBJECT;
pub const MPRAPI_OBJECT_TYPE_UPDATE_CONNECTION_OBJECT = MPRAPI_OBJECT_TYPE.UPDATE_CONNECTION_OBJECT;
pub const MPRAPI_OBJECT_TYPE_IF_CUSTOM_CONFIG_OBJECT = MPRAPI_OBJECT_TYPE.IF_CUSTOM_CONFIG_OBJECT;

pub const PPP_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
    dwIPv4Options: u32,
    dwIPv4RemoteOptions: u32,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: [8]u8,
    bRemoteInterfaceIdentifier: [8]u8,
    bPrefix: [8]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwLcpError: u32,
    dwAuthenticationProtocol: PPP_LCP,
    dwAuthenticationData: PPP_LCP_INFO_AUTH_DATA,
    dwRemoteAuthenticationProtocol: PPP_LCP,
    dwRemoteAuthenticationData: PPP_LCP_INFO_AUTH_DATA,
    dwLcpTerminateReason: u32,
    dwLcpRemoteTerminateReason: u32,
    dwLcpOptions: u32,
    dwLcpRemoteOptions: u32,
    dwEapTypeId: u32,
    dwRemoteEapTypeId: u32,
    dwCcpError: u32,
    dwCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwCcpRemoteOptions: u32,
};

pub const PPP_PROJECTION_INFO2 = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
    dwIPv4Options: u32,
    dwIPv4RemoteOptions: u32,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: [8]u8,
    bRemoteInterfaceIdentifier: [8]u8,
    bPrefix: [8]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwLcpError: u32,
    dwAuthenticationProtocol: PPP_LCP,
    dwAuthenticationData: PPP_LCP_INFO_AUTH_DATA,
    dwRemoteAuthenticationProtocol: PPP_LCP,
    dwRemoteAuthenticationData: PPP_LCP_INFO_AUTH_DATA,
    dwLcpTerminateReason: u32,
    dwLcpRemoteTerminateReason: u32,
    dwLcpOptions: u32,
    dwLcpRemoteOptions: u32,
    dwEapTypeId: u32,
    dwEmbeddedEAPTypeId: u32,
    dwRemoteEapTypeId: u32,
    dwCcpError: u32,
    dwCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwCcpRemoteOptions: u32,
};

pub const IKEV2_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: [8]u8,
    bRemoteInterfaceIdentifier: [8]u8,
    bPrefix: [8]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwOptions: u32,
    dwAuthenticationProtocol: u32,
    dwEapTypeId: u32,
    dwCompressionAlgorithm: u32,
    dwEncryptionMethod: u32,
};

pub const IKEV2_PROJECTION_INFO2 = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: [16]u16,
    wszRemoteAddress: [16]u16,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: [8]u8,
    bRemoteInterfaceIdentifier: [8]u8,
    bPrefix: [8]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwOptions: u32,
    dwAuthenticationProtocol: u32,
    dwEapTypeId: u32,
    dwEmbeddedEAPTypeId: u32,
    dwCompressionAlgorithm: u32,
    dwEncryptionMethod: u32,
};

pub const PROJECTION_INFO = extern struct {
    projectionInfoType: u8,
    Anonymous: extern union {
        PppProjectionInfo: PPP_PROJECTION_INFO,
        Ikev2ProjectionInfo: IKEV2_PROJECTION_INFO,
    },
};

pub const PROJECTION_INFO2 = extern struct {
    projectionInfoType: u8,
    Anonymous: extern union {
        PppProjectionInfo: PPP_PROJECTION_INFO2,
        Ikev2ProjectionInfo: IKEV2_PROJECTION_INFO2,
    },
};

pub const RAS_CONNECTION_EX = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: RAS_FLAGS,
    wszInterfaceName: [257]u16,
    wszUserName: [257]u16,
    wszLogonDomain: [16]u16,
    wszRemoteComputer: [17]u16,
    guid: Guid,
    rasQuarState: RAS_QUARANTINE_STATE,
    probationTime: FILETIME,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwNumSwitchOvers: u32,
    wszRemoteEndpointAddress: [65]u16,
    wszLocalEndpointAddress: [65]u16,
    ProjectionInfo: PROJECTION_INFO,
    hConnection: ?HANDLE,
    hInterface: ?HANDLE,
};

pub const RAS_CONNECTION_4 = extern struct {
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: RAS_FLAGS,
    wszInterfaceName: [257]u16,
    wszUserName: [257]u16,
    wszLogonDomain: [16]u16,
    wszRemoteComputer: [17]u16,
    guid: Guid,
    rasQuarState: RAS_QUARANTINE_STATE,
    probationTime: FILETIME,
    connectionStartTime: FILETIME,
    ullBytesXmited: u64,
    ullBytesRcved: u64,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwNumSwitchOvers: u32,
    wszRemoteEndpointAddress: [65]u16,
    wszLocalEndpointAddress: [65]u16,
    ProjectionInfo: PROJECTION_INFO2,
    hConnection: ?HANDLE,
    hInterface: ?HANDLE,
    dwDeviceType: u32,
};

pub const ROUTER_CUSTOM_IKEv2_POLICY0 = extern struct {
    dwIntegrityMethod: u32,
    dwEncryptionMethod: u32,
    dwCipherTransformConstant: u32,
    dwAuthTransformConstant: u32,
    dwPfsGroup: u32,
    dwDhGroup: u32,
};

pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG0 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};

pub const MPR_IF_CUSTOMINFOEX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG0,
};

pub const MPR_CERT_EKU = extern struct {
    dwSize: u32,
    IsEKUOID: BOOL,
    pwszEKU: ?PWSTR,
};

pub const VPN_TS_IP_ADDRESS = extern struct {
    Type: u16,
    Anonymous: extern union {
        v4: IN_ADDR,
        v6: IN6_ADDR,
    },
};

pub const MPR_VPN_TS_TYPE = enum(i32) {
    @"4_ADDR_RANGE" = 7,
    @"6_ADDR_RANGE" = 8,
};
pub const MPR_VPN_TS_IPv4_ADDR_RANGE = MPR_VPN_TS_TYPE.@"4_ADDR_RANGE";
pub const MPR_VPN_TS_IPv6_ADDR_RANGE = MPR_VPN_TS_TYPE.@"6_ADDR_RANGE";

pub const _MPR_VPN_SELECTOR = extern struct {
    type: MPR_VPN_TS_TYPE,
    protocolId: u8,
    portStart: u16,
    portEnd: u16,
    tsPayloadId: u16,
    addrStart: VPN_TS_IP_ADDRESS,
    addrEnd: VPN_TS_IP_ADDRESS,
};

pub const MPR_VPN_TRAFFIC_SELECTORS = extern struct {
    numTsi: u32,
    numTsr: u32,
    tsI: ?*_MPR_VPN_SELECTOR,
    tsR: ?*_MPR_VPN_SELECTOR,
};

pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG2 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    certificateHash: CRYPTOAPI_BLOB,
    dwMmSaLifeTime: u32,
    vpnTrafficSelectors: MPR_VPN_TRAFFIC_SELECTORS,
};

pub const MPR_IF_CUSTOMINFOEX2 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG2,
};

pub const IKEV2_TUNNEL_CONFIG_PARAMS4 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwTotalEkus: u32,
    certificateEKUs: ?*MPR_CERT_EKU,
    machineCertificateHash: CRYPTOAPI_BLOB,
    dwMmSaLifeTime: u32,
};

pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG1 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    certificateHash: CRYPTOAPI_BLOB,
};

pub const MPR_IF_CUSTOMINFOEX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG1,
};

pub const IKEV2_TUNNEL_CONFIG_PARAMS3 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwTotalEkus: u32,
    certificateEKUs: ?*MPR_CERT_EKU,
    machineCertificateHash: CRYPTOAPI_BLOB,
};

pub const IKEV2_TUNNEL_CONFIG_PARAMS2 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};

pub const L2TP_TUNNEL_CONFIG_PARAMS2 = extern struct {
    dwIdleTimeout: u32,
    dwEncryptionType: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwMmSaLifeTime: u32,
};

pub const L2TP_TUNNEL_CONFIG_PARAMS1 = extern struct {
    dwIdleTimeout: u32,
    dwEncryptionType: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};

pub const IKEV2_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    dwTunnelConfigParamFlags: u32,
    TunnelConfigParams: IKEV2_TUNNEL_CONFIG_PARAMS4,
};

pub const PPTP_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};

pub const L2TP_CONFIG_PARAMS1 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    dwTunnelConfigParamFlags: u32,
    TunnelConfigParams: L2TP_TUNNEL_CONFIG_PARAMS2,
};

pub const GRE_CONFIG_PARAMS0 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};

pub const L2TP_CONFIG_PARAMS0 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};

pub const SSTP_CERT_INFO = extern struct {
    isDefault: BOOL,
    certBlob: CRYPTOAPI_BLOB,
};

pub const SSTP_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    isUseHttps: BOOL,
    certAlgorithm: u32,
    sstpCertDetails: SSTP_CERT_INFO,
};

pub const MPRAPI_TUNNEL_CONFIG_PARAMS0 = extern struct {
    IkeConfigParams: IKEV2_CONFIG_PARAMS,
    PptpConfigParams: PPTP_CONFIG_PARAMS,
    L2tpConfigParams: L2TP_CONFIG_PARAMS1,
    SstpConfigParams: SSTP_CONFIG_PARAMS,
};

pub const MPRAPI_TUNNEL_CONFIG_PARAMS1 = extern struct {
    IkeConfigParams: IKEV2_CONFIG_PARAMS,
    PptpConfigParams: PPTP_CONFIG_PARAMS,
    L2tpConfigParams: L2TP_CONFIG_PARAMS1,
    SstpConfigParams: SSTP_CONFIG_PARAMS,
    GREConfigParams: GRE_CONFIG_PARAMS0,
};

pub const MPR_SERVER_EX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    fLanOnlyMode: u32,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
    Reserved: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS0,
};

pub const MPR_SERVER_EX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    fLanOnlyMode: u32,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
    Reserved: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS1,
};

pub const MPR_SERVER_SET_CONFIG_EX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    setConfigForProtocols: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS0,
};

pub const MPR_SERVER_SET_CONFIG_EX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    setConfigForProtocols: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS1,
};

pub const AUTH_VALIDATION_EX = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    hRasConnection: ?HANDLE,
    wszUserName: [257]u16,
    wszLogonDomain: [16]u16,
    AuthInfoSize: u32,
    AuthInfo: [1]u8,
};

pub const RAS_UPDATE_CONNECTION = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwIfIndex: u32,
    wszLocalEndpointAddress: [65]u16,
    wszRemoteEndpointAddress: [65]u16,
};

pub const PMPRADMINGETIPADDRESSFORUSER = *const fn (
    param0: ?PWSTR,
    param1: ?PWSTR,
    param2: ?*u32,
    param3: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMPRADMINRELEASEIPADRESS = *const fn (
    param0: ?PWSTR,
    param1: ?PWSTR,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINGETIPV6ADDRESSFORUSER = *const fn (
    param0: ?PWSTR,
    param1: ?PWSTR,
    param2: ?*IN6_ADDR,
    param3: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMPRADMINRELEASEIPV6ADDRESSFORUSER = *const fn (
    param0: ?PWSTR,
    param1: ?PWSTR,
    param2: ?*IN6_ADDR,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINACCEPTNEWCONNECTION = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTNEWCONNECTION2 = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
    param2: ?*RAS_CONNECTION_2,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTNEWCONNECTION3 = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
    param2: ?*RAS_CONNECTION_2,
    param3: ?*RAS_CONNECTION_3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTNEWLINK = *const fn (
    param0: ?*RAS_PORT_0,
    param1: ?*RAS_PORT_1,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION2 = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
    param2: ?*RAS_CONNECTION_2,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION3 = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
    param2: ?*RAS_CONNECTION_2,
    param3: RAS_CONNECTION_3,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINLINKHANGUPNOTIFICATION = *const fn (
    param0: ?*RAS_PORT_0,
    param1: ?*RAS_PORT_1,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINTERMINATEDLL = *const fn () callconv(@import("std").os.windows.WINAPI) u32;

pub const PMPRADMINACCEPTREAUTHENTICATION = *const fn (
    param0: ?*RAS_CONNECTION_0,
    param1: ?*RAS_CONNECTION_1,
    param2: ?*RAS_CONNECTION_2,
    param3: ?*RAS_CONNECTION_3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTNEWCONNECTIONEX = *const fn (
    param0: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTREAUTHENTICATIONEX = *const fn (
    param0: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX = *const fn (
    param0: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX = *const fn (
    param0: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX = *const fn (
    param0: ?*AUTH_VALIDATION_EX,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MPRAPI_ADMIN_DLL_CALLBACKS = extern struct {
    revision: u8,
    lpfnMprAdminGetIpAddressForUser: ?PMPRADMINGETIPADDRESSFORUSER,
    lpfnMprAdminReleaseIpAddress: ?PMPRADMINRELEASEIPADRESS,
    lpfnMprAdminGetIpv6AddressForUser: ?PMPRADMINGETIPV6ADDRESSFORUSER,
    lpfnMprAdminReleaseIpV6AddressForUser: ?PMPRADMINRELEASEIPV6ADDRESSFORUSER,
    lpfnRasAdminAcceptNewLink: ?PMPRADMINACCEPTNEWLINK,
    lpfnRasAdminLinkHangupNotification: ?PMPRADMINLINKHANGUPNOTIFICATION,
    lpfnRasAdminTerminateDll: ?PMPRADMINTERMINATEDLL,
    lpfnRasAdminAcceptNewConnectionEx: ?PMPRADMINACCEPTNEWCONNECTIONEX,
    lpfnRasAdminAcceptEndpointChangeEx: ?PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX,
    lpfnRasAdminAcceptReauthenticationEx: ?PMPRADMINACCEPTREAUTHENTICATIONEX,
    lpfnRasAdminConnectionHangupNotificationEx: ?PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX,
    lpfnRASValidatePreAuthenticatedConnectionEx: ?PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX,
};

pub const SECURITY_MESSAGE = extern struct {
    dwMsgId: SECURITY_MESSAGE_MSG_ID,
    hPort: isize,
    dwError: u32,
    UserName: [257]CHAR,
    Domain: [16]CHAR,
};

pub const RAS_SECURITY_INFO = extern struct {
    LastError: u32,
    BytesReceived: u32,
    DeviceName: [129]CHAR,
};

pub const RASSECURITYPROC = *const fn () callconv(@import("std").os.windows.WINAPI) u32;

pub const MGM_IF_ENTRY = extern struct {
    dwIfIndex: u32,
    dwIfNextHopAddr: u32,
    bIGMP: BOOL,
    bIsEnabled: BOOL,
};

pub const PMGM_RPF_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    pdw_in_if_index: ?*u32,
    pdw_in_if_next_hop_addr: ?*u32,
    pdw_up_stream_nbr: ?*u32,
    dw_hdr_size: u32,
    pb_packet_hdr: ?*u8,
    pb_route: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_CREATION_ALERT_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_in_if_index: u32,
    dw_in_if_next_hop_addr: u32,
    dw_if_count: u32,
    pmie_out_if_list: ?*MGM_IF_ENTRY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_PRUNE_ALERT_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
    b_member_delete: BOOL,
    pdw_timeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_JOIN_ALERT_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    b_member_update: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_WRONG_IF_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_group_addr: u32,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
    dw_hdr_size: u32,
    pb_packet_hdr: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_LOCAL_JOIN_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_LOCAL_LEAVE_CALLBACK = *const fn (
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_DISABLE_IGMP_CALLBACK = *const fn (
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PMGM_ENABLE_IGMP_CALLBACK = *const fn (
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ROUTING_PROTOCOL_CONFIG = extern struct {
    dwCallbackFlags: u32,
    pfnRpfCallback: ?PMGM_RPF_CALLBACK,
    pfnCreationAlertCallback: ?PMGM_CREATION_ALERT_CALLBACK,
    pfnPruneAlertCallback: ?PMGM_PRUNE_ALERT_CALLBACK,
    pfnJoinAlertCallback: ?PMGM_JOIN_ALERT_CALLBACK,
    pfnWrongIfCallback: ?PMGM_WRONG_IF_CALLBACK,
    pfnLocalJoinCallback: ?PMGM_LOCAL_JOIN_CALLBACK,
    pfnLocalLeaveCallback: ?PMGM_LOCAL_LEAVE_CALLBACK,
    pfnDisableIgmpCallback: ?PMGM_DISABLE_IGMP_CALLBACK,
    pfnEnableIgmpCallback: ?PMGM_ENABLE_IGMP_CALLBACK,
};

pub const MGM_ENUM_TYPES = enum(i32) {
    NY_SOURCE = 0,
    LL_SOURCES = 1,
};
pub const ANY_SOURCE = MGM_ENUM_TYPES.NY_SOURCE;
pub const ALL_SOURCES = MGM_ENUM_TYPES.LL_SOURCES;

pub const SOURCE_GROUP_ENTRY = extern struct {
    dwSourceAddr: u32,
    dwSourceMask: u32,
    dwGroupAddr: u32,
    dwGroupMask: u32,
};

pub const RTM_REGN_PROFILE = extern struct {
    MaxNextHopsInRoute: u32,
    MaxHandlesInEnum: u32,
    ViewsSupported: u32,
    NumberOfViews: u32,
};

pub const RTM_NET_ADDRESS = extern struct {
    AddressFamily: u16,
    NumBits: u16,
    AddrBits: [16]u8,
};

pub const RTM_PREF_INFO = extern struct {
    Metric: u32,
    Preference: u32,
};

pub const RTM_NEXTHOP_LIST = extern struct {
    NumNextHops: u16,
    NextHops: [1]isize,
};

pub const RTM_DEST_INFO = extern struct {
    DestHandle: isize,
    DestAddress: RTM_NET_ADDRESS,
    LastChanged: FILETIME,
    BelongsToViews: u32,
    NumberOfViews: u32,
    ViewInfo: [1]extern struct {
        ViewId: i32,
        NumRoutes: u32,
        Route: isize,
        Owner: isize,
        DestFlags: u32,
        HoldRoute: isize,
    },
};

pub const RTM_ROUTE_INFO = extern struct {
    DestHandle: isize,
    RouteOwner: isize,
    Neighbour: isize,
    State: u8,
    Flags1: u8,
    Flags: u16,
    PrefInfo: RTM_PREF_INFO,
    BelongsToViews: u32,
    EntitySpecificInfo: ?*anyopaque,
    NextHopsList: RTM_NEXTHOP_LIST,
};

pub const RTM_NEXTHOP_INFO = extern struct {
    NextHopAddress: RTM_NET_ADDRESS,
    NextHopOwner: isize,
    InterfaceIndex: u32,
    State: u16,
    Flags: u16,
    EntitySpecificInfo: ?*anyopaque,
    RemoteNextHop: isize,
};

pub const RTM_ENTITY_ID = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            EntityProtocolId: u32,
            EntityInstanceId: u32,
        },
        EntityId: u64,
    },
};

pub const RTM_ENTITY_INFO = extern struct {
    RtmInstanceId: u16,
    AddressFamily: u16,
    EntityId: RTM_ENTITY_ID,
};

pub const RTM_EVENT_TYPE = enum(i32) {
    ENTITY_REGISTERED = 0,
    ENTITY_DEREGISTERED = 1,
    ROUTE_EXPIRED = 2,
    CHANGE_NOTIFICATION = 3,
};
pub const RTM_ENTITY_REGISTERED = RTM_EVENT_TYPE.ENTITY_REGISTERED;
pub const RTM_ENTITY_DEREGISTERED = RTM_EVENT_TYPE.ENTITY_DEREGISTERED;
pub const RTM_ROUTE_EXPIRED = RTM_EVENT_TYPE.ROUTE_EXPIRED;
pub const RTM_CHANGE_NOTIFICATION = RTM_EVENT_TYPE.CHANGE_NOTIFICATION;

pub const RTM_EVENT_CALLBACK = *const fn (
    rtm_reg_handle: isize,
    event_type: RTM_EVENT_TYPE,
    context1: ?*anyopaque,
    context2: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RTM_ENTITY_METHOD_INPUT = extern struct {
    MethodType: u32,
    InputSize: u32,
    InputData: [1]u8,
};

pub const RTM_ENTITY_METHOD_OUTPUT = extern struct {
    MethodType: u32,
    MethodStatus: u32,
    OutputSize: u32,
    OutputData: [1]u8,
};

pub const RTM_ENTITY_EXPORT_METHOD = *const fn (
    caller_handle: isize,
    callee_handle: isize,
    input: ?*RTM_ENTITY_METHOD_INPUT,
    output: ?*RTM_ENTITY_METHOD_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RTM_ENTITY_EXPORT_METHODS = extern struct {
    NumMethods: u32,
    Methods: [1]?RTM_ENTITY_EXPORT_METHOD,
};

//--------------------------------------------------------------------------------
// Section: Functions (277)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasDialA(
    param0: ?*RASDIALEXTENSIONS,
    param1: ?[*:0]const u8,
    param2: ?*RASDIALPARAMSA,
    param3: u32,
    param4: ?*anyopaque,
    param5: ?*?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasDialW(
    param0: ?*RASDIALEXTENSIONS,
    param1: ?[*:0]const u16,
    param2: ?*RASDIALPARAMSW,
    param3: u32,
    param4: ?*anyopaque,
    param5: ?*?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumConnectionsA(
    param0: ?*RASCONNA,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumConnectionsW(
    param0: ?*RASCONNW,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumEntriesA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*RASENTRYNAMEA,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumEntriesW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*RASENTRYNAMEW,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetConnectStatusA(
    param0: ?HRASCONN,
    param1: ?*RASCONNSTATUSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetConnectStatusW(
    param0: ?HRASCONN,
    param1: ?*RASCONNSTATUSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetErrorStringA(
    resource_id: u32,
    lpsz_string: [*:0]u8,
    in_buf_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetErrorStringW(
    resource_id: u32,
    lpsz_string: [*:0]u16,
    in_buf_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasHangUpA(
    param0: ?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasHangUpW(
    param0: ?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetProjectionInfoA(
    param0: ?HRASCONN,
    param1: RASPROJECTION,
    param2: ?*anyopaque,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetProjectionInfoW(
    param0: ?HRASCONN,
    param1: RASPROJECTION,
    param2: ?*anyopaque,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasCreatePhonebookEntryA(
    param0: ?HWND,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasCreatePhonebookEntryW(
    param0: ?HWND,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEditPhonebookEntryA(
    param0: ?HWND,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEditPhonebookEntryW(
    param0: ?HWND,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEntryDialParamsA(
    param0: ?[*:0]const u8,
    param1: ?*RASDIALPARAMSA,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEntryDialParamsW(
    param0: ?[*:0]const u16,
    param1: ?*RASDIALPARAMSW,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEntryDialParamsA(
    param0: ?[*:0]const u8,
    param1: ?*RASDIALPARAMSA,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEntryDialParamsW(
    param0: ?[*:0]const u16,
    param1: ?*RASDIALPARAMSW,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumDevicesA(
    param0: ?*RASDEVINFOA,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumDevicesW(
    param0: ?*RASDEVINFOW,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCountryInfoA(
    param0: ?*RASCTRYINFO,
    param1: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCountryInfoW(
    param0: ?*RASCTRYINFO,
    param1: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEntryPropertiesA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*RASENTRYA,
    param3: ?*u32,
    param4: ?*u8,
    param5: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEntryPropertiesW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*RASENTRYW,
    param3: ?*u32,
    param4: ?*u8,
    param5: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEntryPropertiesA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*RASENTRYA,
    param3: u32,
    param4: ?*u8,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEntryPropertiesW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*RASENTRYW,
    param3: u32,
    param4: ?*u8,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasRenameEntryA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasRenameEntryW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasDeleteEntryA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasDeleteEntryW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasValidateEntryNameA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasValidateEntryNameW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasConnectionNotificationA(
    param0: ?HRASCONN,
    param1: ?HANDLE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasConnectionNotificationW(
    param0: ?HRASCONN,
    param1: ?HANDLE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetSubEntryHandleA(
    param0: ?HRASCONN,
    param1: u32,
    param2: ?*?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetSubEntryHandleW(
    param0: ?HRASCONN,
    param1: u32,
    param2: ?*?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCredentialsA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*RASCREDENTIALSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCredentialsW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*RASCREDENTIALSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetCredentialsA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*RASCREDENTIALSA,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetCredentialsW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*RASCREDENTIALSW,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetSubEntryPropertiesA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*RASSUBENTRYA,
    param4: ?*u32,
    param5: ?*u8,
    param6: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetSubEntryPropertiesW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*RASSUBENTRYW,
    param4: ?*u32,
    param5: ?*u8,
    param6: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetSubEntryPropertiesA(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*RASSUBENTRYA,
    param4: u32,
    param5: ?*u8,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetSubEntryPropertiesW(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*RASSUBENTRYW,
    param4: u32,
    param5: ?*u8,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialAddressA(
    param0: ?[*:0]const u8,
    param1: ?*u32,
    param2: ?*RASAUTODIALENTRYA,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialAddressW(
    param0: ?[*:0]const u16,
    param1: ?*u32,
    param2: ?*RASAUTODIALENTRYW,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialAddressA(
    param0: ?[*:0]const u8,
    param1: u32,
    param2: ?*RASAUTODIALENTRYA,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialAddressW(
    param0: ?[*:0]const u16,
    param1: u32,
    param2: ?*RASAUTODIALENTRYW,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumAutodialAddressesA(
    // TODO: what to do with BytesParamIndex 1?
    lpp_ras_autodial_addresses: ?*?PSTR,
    lpdwcb_ras_autodial_addresses: ?*u32,
    lpdwc_ras_autodial_addresses: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasEnumAutodialAddressesW(
    // TODO: what to do with BytesParamIndex 1?
    lpp_ras_autodial_addresses: ?*?PWSTR,
    lpdwcb_ras_autodial_addresses: ?*u32,
    lpdwc_ras_autodial_addresses: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialEnableA(
    param0: u32,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialEnableW(
    param0: u32,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialEnableA(
    param0: u32,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialEnableW(
    param0: u32,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialParamA(
    param0: u32,
    param1: ?*anyopaque,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetAutodialParamW(
    param0: u32,
    param1: ?*anyopaque,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialParamA(
    param0: u32,
    param1: ?*anyopaque,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetAutodialParamW(
    param0: u32,
    param1: ?*anyopaque,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "rasapi32" fn RasGetPCscf(
    lpsz_p_cscf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasInvokeEapUI(
    param0: ?HRASCONN,
    param1: u32,
    param2: ?*RASDIALEXTENSIONS,
    param3: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetLinkStatistics(
    h_ras_conn: ?HRASCONN,
    dw_sub_entry: u32,
    lp_statistics: ?*RAS_STATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetConnectionStatistics(
    h_ras_conn: ?HRASCONN,
    lp_statistics: ?*RAS_STATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasClearLinkStatistics(
    h_ras_conn: ?HRASCONN,
    dw_sub_entry: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasClearConnectionStatistics(
    h_ras_conn: ?HRASCONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEapUserDataA(
    h_token: ?HANDLE,
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    pb_eap_data: ?*u8,
    pdw_sizeof_eap_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEapUserDataW(
    h_token: ?HANDLE,
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    pb_eap_data: ?*u8,
    pdw_sizeof_eap_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEapUserDataA(
    h_token: ?HANDLE,
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    pb_eap_data: ?*u8,
    dw_sizeof_eap_data: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetEapUserDataW(
    h_token: ?HANDLE,
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    pb_eap_data: ?*u8,
    dw_sizeof_eap_data: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCustomAuthDataA(
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pb_custom_auth_data: ?*u8,
    pdw_sizeof_custom_auth_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetCustomAuthDataW(
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_custom_auth_data: ?*u8,
    pdw_sizeof_custom_auth_data: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetCustomAuthDataA(
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pb_custom_auth_data: ?*u8,
    dw_sizeof_custom_auth_data: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasSetCustomAuthDataW(
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pb_custom_auth_data: ?*u8,
    dw_sizeof_custom_auth_data: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEapUserIdentityW(
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    dw_flags: u32,
    hwnd: ?HWND,
    pp_ras_eap_user_identity: ?*?*RASEAPUSERIDENTITYW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasGetEapUserIdentityA(
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    dw_flags: u32,
    hwnd: ?HWND,
    pp_ras_eap_user_identity: ?*?*RASEAPUSERIDENTITYA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasFreeEapUserIdentityW(
    p_ras_eap_user_identity: ?*RASEAPUSERIDENTITYW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasapi32" fn RasFreeEapUserIdentityA(
    p_ras_eap_user_identity: ?*RASEAPUSERIDENTITYA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "rasapi32" fn RasDeleteSubEntryA(
    psz_phonebook: ?[*:0]const u8,
    psz_entry: ?[*:0]const u8,
    dw_subentry_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "rasapi32" fn RasDeleteSubEntryW(
    psz_phonebook: ?[*:0]const u16,
    psz_entry: ?[*:0]const u16,
    dw_sub_entry_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "rasapi32" fn RasUpdateConnection(
    hrasconn: ?HRASCONN,
    lprasupdateconn: ?*RASUPDATECONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "rasapi32" fn RasGetProjectionInfoEx(
    hrasconn: ?HRASCONN,
    p_ras_projection: ?*RAS_PROJECTION_INFO,
    lpdw_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasPhonebookDlgA(
    lpsz_phonebook: ?PSTR,
    lpsz_entry: ?PSTR,
    lp_info: ?*RASPBDLGA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasPhonebookDlgW(
    lpsz_phonebook: ?PWSTR,
    lpsz_entry: ?PWSTR,
    lp_info: ?*RASPBDLGW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasEntryDlgA(
    lpsz_phonebook: ?PSTR,
    lpsz_entry: ?PSTR,
    lp_info: ?*RASENTRYDLGA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasEntryDlgW(
    lpsz_phonebook: ?PWSTR,
    lpsz_entry: ?PWSTR,
    lp_info: ?*RASENTRYDLGW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasDialDlgA(
    lpsz_phonebook: ?PSTR,
    lpsz_entry: ?PSTR,
    lpsz_phone_number: ?PSTR,
    lp_info: ?*RASDIALDLG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "rasdlg" fn RasDialDlgW(
    lpsz_phonebook: ?PWSTR,
    lpsz_entry: ?PWSTR,
    lpsz_phone_number: ?PWSTR,
    lp_info: ?*RASDIALDLG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mprapi" fn MprAdminConnectionEnumEx(
    h_ras_server: isize,
    p_object_header: ?*MPRAPI_OBJECT_HEADER,
    dw_prefered_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    pp_ras_conn: ?*?*RAS_CONNECTION_EX,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mprapi" fn MprAdminConnectionGetInfoEx(
    h_ras_server: isize,
    h_ras_connection: ?HANDLE,
    p_ras_connection: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprAdminServerGetInfoEx(
    h_mpr_server: isize,
    p_server_info: ?*MPR_SERVER_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprAdminServerSetInfoEx(
    h_mpr_server: isize,
    p_server_info: ?*MPR_SERVER_SET_CONFIG_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprConfigServerGetInfoEx(
    h_mpr_config: ?HANDLE,
    p_server_info: ?*MPR_SERVER_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprConfigServerSetInfoEx(
    h_mpr_config: ?HANDLE,
    p_set_server_config: ?*MPR_SERVER_SET_CONFIG_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mprapi" fn MprAdminUpdateConnection(
    h_ras_server: isize,
    h_ras_connection: ?HANDLE,
    p_ras_update_connection: ?*RAS_UPDATE_CONNECTION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprAdminIsServiceInitialized(
    lpws_server_name: ?PWSTR,
    f_is_service_initialized: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2012'
pub extern "mprapi" fn MprAdminInterfaceSetCustomInfoEx(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    p_custom_info: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2012'
pub extern "mprapi" fn MprAdminInterfaceGetCustomInfoEx(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    p_custom_info: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2012'
pub extern "mprapi" fn MprConfigInterfaceGetCustomInfoEx(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    p_custom_info: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2012'
pub extern "mprapi" fn MprConfigInterfaceSetCustomInfoEx(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    p_custom_info: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminConnectionEnum(
    h_ras_server: isize,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminPortEnum(
    h_ras_server: isize,
    dw_level: u32,
    h_ras_connection: ?HANDLE,
    lplpb_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminConnectionGetInfo(
    h_ras_server: isize,
    dw_level: u32,
    h_ras_connection: ?HANDLE,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminPortGetInfo(
    h_ras_server: isize,
    dw_level: u32,
    h_port: ?HANDLE,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminConnectionClearStats(
    h_ras_server: isize,
    h_ras_connection: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminPortClearStats(
    h_ras_server: isize,
    h_port: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminPortReset(
    h_ras_server: isize,
    h_port: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminPortDisconnect(
    h_ras_server: isize,
    h_port: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mprapi" fn MprAdminConnectionRemoveQuarantine(
    h_ras_server: ?HANDLE,
    h_ras_connection: ?HANDLE,
    f_is_ip_address: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminUserGetInfo(
    lpsz_server: ?[*:0]const u16,
    lpsz_user: ?[*:0]const u16,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminUserSetInfo(
    lpsz_server: ?[*:0]const u16,
    lpsz_user: ?[*:0]const u16,
    dw_level: u32,
    lpb_buffer: ?*const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminSendUserMessage(
    h_mpr_server: isize,
    h_connection: ?HANDLE,
    lpwsz_message: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mprapi" fn MprAdminGetPDCServer(
    lpsz_domain: ?[*:0]const u16,
    lpsz_server: ?[*:0]const u16,
    lpsz_p_d_c_server: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminIsServiceRunning(
    lpws_server_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminServerConnect(
    lpws_server_name: ?PWSTR,
    ph_mpr_server: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminServerDisconnect(
    h_mpr_server: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprAdminServerGetCredentials(
    h_mpr_server: isize,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprAdminServerSetCredentials(
    h_mpr_server: isize,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminBufferFree(
    p_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminGetErrorString(
    dw_error: u32,
    lplpws_error_string: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminServerGetInfo(
    h_mpr_server: isize,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprAdminServerSetInfo(
    h_mpr_server: isize,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprAdminEstablishDomainRasServer(
    psz_domain: ?PWSTR,
    psz_machine: ?PWSTR,
    b_enable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprAdminIsDomainRasServer(
    psz_domain: ?PWSTR,
    psz_machine: ?PWSTR,
    pb_is_ras_server: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminTransportCreate(
    h_mpr_server: isize,
    dw_transport_id: u32,
    lpws_transport_name: ?PWSTR,
    p_global_info: ?*u8,
    dw_global_info_size: u32,
    p_client_interface_info: ?*u8,
    dw_client_interface_info_size: u32,
    lpws_d_l_l_path: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminTransportSetInfo(
    h_mpr_server: isize,
    dw_transport_id: u32,
    p_global_info: ?*u8,
    dw_global_info_size: u32,
    p_client_interface_info: ?*u8,
    dw_client_interface_info_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminTransportGetInfo(
    h_mpr_server: isize,
    dw_transport_id: u32,
    pp_global_info: ?*?*u8,
    lpdw_global_info_size: ?*u32,
    pp_client_interface_info: ?*?*u8,
    lpdw_client_interface_info_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminDeviceEnum(
    h_mpr_server: isize,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
    lpdw_total_entries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceGetHandle(
    h_mpr_server: isize,
    lpws_interface_name: ?PWSTR,
    ph_interface: ?*?HANDLE,
    f_include_client_interfaces: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceCreate(
    h_mpr_server: isize,
    dw_level: u32,
    lpb_buffer: ?*u8,
    ph_interface: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceGetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceSetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceDelete(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceDeviceGetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_index: u32,
    dw_level: u32,
    lplp_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceDeviceSetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_index: u32,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceTransportRemove(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_transport_id: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceTransportAdd(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_transport_id: u32,
    p_interface_info: ?*u8,
    dw_interface_info_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceTransportGetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_transport_id: u32,
    pp_interface_info: ?*?*u8,
    lpdw_interface_info_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceTransportSetInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_transport_id: u32,
    p_interface_info: ?*u8,
    dw_interface_info_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceEnum(
    h_mpr_server: isize,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceSetCredentials(
    lpws_server: ?PWSTR,
    lpws_interface_name: ?PWSTR,
    lpws_user_name: ?PWSTR,
    lpws_domain_name: ?PWSTR,
    lpws_password: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceGetCredentials(
    lpws_server: ?PWSTR,
    lpws_interface_name: ?PWSTR,
    lpws_user_name: ?PWSTR,
    lpws_password: ?PWSTR,
    lpws_domain_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceSetCredentialsEx(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceGetCredentialsEx(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceConnect(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    h_event: ?HANDLE,
    f_synchronous: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceDisconnect(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceUpdateRoutes(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_protocol_id: u32,
    h_event: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceQueryUpdateResult(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
    dw_protocol_id: u32,
    lpdw_update_result: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminInterfaceUpdatePhonebookInfo(
    h_mpr_server: isize,
    h_interface: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminRegisterConnectionNotification(
    h_mpr_server: isize,
    h_event_notification: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminDeregisterConnectionNotification(
    h_mpr_server: isize,
    h_event_notification: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBServerConnect(
    lpws_server_name: ?PWSTR,
    ph_mib_server: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBServerDisconnect(
    h_mib_server: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntryCreate(
    h_mib_server: isize,
    dw_pid: u32,
    dw_routing_pid: u32,
    lp_entry: ?*anyopaque,
    dw_entry_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntryDelete(
    h_mib_server: isize,
    dw_protocol_id: u32,
    dw_routing_pid: u32,
    lp_entry: ?*anyopaque,
    dw_entry_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntrySet(
    h_mib_server: isize,
    dw_protocol_id: u32,
    dw_routing_pid: u32,
    lp_entry: ?*anyopaque,
    dw_entry_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntryGet(
    h_mib_server: isize,
    dw_protocol_id: u32,
    dw_routing_pid: u32,
    lp_in_entry: ?*anyopaque,
    dw_in_entry_size: u32,
    lplp_out_entry: ?*?*anyopaque,
    lp_out_entry_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntryGetFirst(
    h_mib_server: isize,
    dw_protocol_id: u32,
    dw_routing_pid: u32,
    lp_in_entry: ?*anyopaque,
    dw_in_entry_size: u32,
    lplp_out_entry: ?*?*anyopaque,
    lp_out_entry_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBEntryGetNext(
    h_mib_server: isize,
    dw_protocol_id: u32,
    dw_routing_pid: u32,
    lp_in_entry: ?*anyopaque,
    dw_in_entry_size: u32,
    lplp_out_entry: ?*?*anyopaque,
    lp_out_entry_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprAdminMIBBufferFree(
    p_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerInstall(
    dw_level: u32,
    p_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerConnect(
    lpws_server_name: ?PWSTR,
    ph_mpr_config: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerDisconnect(
    h_mpr_config: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mprapi" fn MprConfigServerRefresh(
    h_mpr_config: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigBufferFree(
    p_buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerGetInfo(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    lplpb_buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "mprapi" fn MprConfigServerSetInfo(
    h_mpr_server: isize,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerBackup(
    h_mpr_config: ?HANDLE,
    lpws_path: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigServerRestore(
    h_mpr_config: ?HANDLE,
    lpws_path: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportCreate(
    h_mpr_config: ?HANDLE,
    dw_transport_id: u32,
    lpws_transport_name: ?PWSTR,
    // TODO: what to do with BytesParamIndex 4?
    p_global_info: ?*u8,
    dw_global_info_size: u32,
    // TODO: what to do with BytesParamIndex 6?
    p_client_interface_info: ?*u8,
    dw_client_interface_info_size: u32,
    lpws_d_l_l_path: ?PWSTR,
    ph_router_transport: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportDelete(
    h_mpr_config: ?HANDLE,
    h_router_transport: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportGetHandle(
    h_mpr_config: ?HANDLE,
    dw_transport_id: u32,
    ph_router_transport: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportSetInfo(
    h_mpr_config: ?HANDLE,
    h_router_transport: ?HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    p_global_info: ?*u8,
    dw_global_info_size: u32,
    // TODO: what to do with BytesParamIndex 5?
    p_client_interface_info: ?*u8,
    dw_client_interface_info_size: u32,
    lpws_d_l_l_path: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportGetInfo(
    h_mpr_config: ?HANDLE,
    h_router_transport: ?HANDLE,
    pp_global_info: ?*?*u8,
    lpdw_global_info_size: ?*u32,
    pp_client_interface_info: ?*?*u8,
    lpdw_client_interface_info_size: ?*u32,
    lplpws_d_l_l_path: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigTransportEnum(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    lplp_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceCreate(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    lpb_buffer: ?*u8,
    ph_router_interface: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceDelete(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceGetHandle(
    h_mpr_config: ?HANDLE,
    lpws_interface_name: ?PWSTR,
    ph_router_interface: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceGetInfo(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    dw_level: u32,
    lplp_buffer: ?*?*u8,
    lpdw_buffer_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceSetInfo(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    dw_level: u32,
    lpb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceEnum(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    lplp_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportAdd(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    dw_transport_id: u32,
    lpws_transport_name: ?PWSTR,
    // TODO: what to do with BytesParamIndex 5?
    p_interface_info: ?*u8,
    dw_interface_info_size: u32,
    ph_router_if_transport: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportRemove(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    h_router_if_transport: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportGetHandle(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    dw_transport_id: u32,
    ph_router_if_transport: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportGetInfo(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    h_router_if_transport: ?HANDLE,
    pp_interface_info: ?*?*u8,
    lpdw_interface_info_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportSetInfo(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    h_router_if_transport: ?HANDLE,
    // TODO: what to do with BytesParamIndex 4?
    p_interface_info: ?*u8,
    dw_interface_info_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigInterfaceTransportEnum(
    h_mpr_config: ?HANDLE,
    h_router_interface: ?HANDLE,
    dw_level: u32,
    lplp_buffer: ?*?*u8,
    dw_pref_max_len: u32,
    lpdw_entries_read: ?*u32,
    lpdw_total_entries: ?*u32,
    lpdw_resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigGetFriendlyName(
    h_mpr_config: ?HANDLE,
    psz_guid_name: ?PWSTR,
    // TODO: what to do with BytesParamIndex 3?
    psz_buffer: ?[*]u16,
    dw_buffer_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprConfigGetGuidName(
    h_mpr_config: ?HANDLE,
    psz_friendly_name: ?PWSTR,
    // TODO: what to do with BytesParamIndex 3?
    psz_buffer: ?[*]u16,
    dw_buffer_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprConfigFilterGetInfo(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    dw_transport_id: u32,
    lp_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "mprapi" fn MprConfigFilterSetInfo(
    h_mpr_config: ?HANDLE,
    dw_level: u32,
    dw_transport_id: u32,
    lp_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoCreate(
    dw_version: u32,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoDelete(
    lp_header: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoRemoveAll(
    lp_header: ?*anyopaque,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoDuplicate(
    lp_header: ?*anyopaque,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoBlockAdd(
    lp_header: ?*anyopaque,
    dw_info_type: u32,
    dw_item_size: u32,
    dw_item_count: u32,
    lp_item_data: ?*u8,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoBlockRemove(
    lp_header: ?*anyopaque,
    dw_info_type: u32,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoBlockSet(
    lp_header: ?*anyopaque,
    dw_info_type: u32,
    dw_item_size: u32,
    dw_item_count: u32,
    lp_item_data: ?*u8,
    lplp_new_header: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoBlockFind(
    lp_header: ?*anyopaque,
    dw_info_type: u32,
    lpdw_item_size: ?*u32,
    lpdw_item_count: ?*u32,
    lplp_item_data: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "mprapi" fn MprInfoBlockQuerySize(
    lp_header: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmRegisterMProtocol(
    prpi_info: ?*ROUTING_PROTOCOL_CONFIG,
    dw_protocol_id: u32,
    dw_component_id: u32,
    ph_protocol: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmDeRegisterMProtocol(
    h_protocol: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmTakeInterfaceOwnership(
    h_protocol: ?HANDLE,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmReleaseInterfaceOwnership(
    h_protocol: ?HANDLE,
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetProtocolOnInterface(
    dw_if_index: u32,
    dw_if_next_hop_addr: u32,
    pdw_if_protocol_id: ?*u32,
    pdw_if_component_id: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmAddGroupMembershipEntry(
    h_protocol: ?HANDLE,
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_if_index: u32,
    dw_if_next_hop_i_p_addr: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmDeleteGroupMembershipEntry(
    h_protocol: ?HANDLE,
    dw_source_addr: u32,
    dw_source_mask: u32,
    dw_group_addr: u32,
    dw_group_mask: u32,
    dw_if_index: u32,
    dw_if_next_hop_i_p_addr: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetMfe(
    pimm: ?*MIB_IPMCAST_MFE,
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetFirstMfe(
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    pdw_num_entries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetNextMfe(
    pimm_start: ?*MIB_IPMCAST_MFE,
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    pdw_num_entries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetMfeStats(
    pimm: ?*MIB_IPMCAST_MFE,
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetFirstMfeStats(
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    pdw_num_entries: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGetNextMfeStats(
    pimm_start: ?*MIB_IPMCAST_MFE,
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    pdw_num_entries: ?*u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGroupEnumerationStart(
    h_protocol: ?HANDLE,
    met_enum_type: MGM_ENUM_TYPES,
    ph_enum_handle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGroupEnumerationGetNext(
    h_enum: ?HANDLE,
    pdw_buffer_size: ?*u32,
    pb_buffer: ?*u8,
    pdw_num_entries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn MgmGroupEnumerationEnd(
    h_enum: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "rtm" fn RtmConvertNetAddressToIpv6AddressAndLength(
    p_net_address: ?*RTM_NET_ADDRESS,
    p_address: ?*IN6_ADDR,
    p_length: ?*u32,
    dw_address_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "rtm" fn RtmConvertIpv6AddressAndLengthToNetAddress(
    p_net_address: ?*RTM_NET_ADDRESS,
    address: IN6_ADDR,
    dw_length: u32,
    dw_address_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmRegisterEntity(
    rtm_entity_info: ?*RTM_ENTITY_INFO,
    export_methods: ?*RTM_ENTITY_EXPORT_METHODS,
    event_callback: ?RTM_EVENT_CALLBACK,
    reserve_opaque_pointer: BOOL,
    rtm_reg_profile: ?*RTM_REGN_PROFILE,
    rtm_reg_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeregisterEntity(
    rtm_reg_handle: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetRegisteredEntities(
    rtm_reg_handle: isize,
    num_entities: ?*u32,
    entity_handles: ?*isize,
    entity_infos: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseEntities(
    rtm_reg_handle: isize,
    num_entities: u32,
    entity_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmLockDestination(
    rtm_reg_handle: isize,
    dest_handle: isize,
    exclusive: BOOL,
    lock_dest: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetOpaqueInformationPointer(
    rtm_reg_handle: isize,
    dest_handle: isize,
    opaque_info_pointer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetEntityMethods(
    rtm_reg_handle: isize,
    entity_handle: isize,
    num_methods: ?*u32,
    expt_methods: ?*?RTM_ENTITY_EXPORT_METHOD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmInvokeMethod(
    rtm_reg_handle: isize,
    entity_handle: isize,
    input: ?*RTM_ENTITY_METHOD_INPUT,
    output_size: ?*u32,
    output: ?*RTM_ENTITY_METHOD_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmBlockMethods(
    rtm_reg_handle: isize,
    target_handle: ?HANDLE,
    target_type: u8,
    blocking_flag: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetEntityInfo(
    rtm_reg_handle: isize,
    entity_handle: isize,
    entity_info: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetDestInfo(
    rtm_reg_handle: isize,
    dest_handle: isize,
    protocol_id: u32,
    target_views: u32,
    dest_info: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetRouteInfo(
    rtm_reg_handle: isize,
    route_handle: isize,
    route_info: ?*RTM_ROUTE_INFO,
    dest_address: ?*RTM_NET_ADDRESS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetNextHopInfo(
    rtm_reg_handle: isize,
    next_hop_handle: isize,
    next_hop_info: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseEntityInfo(
    rtm_reg_handle: isize,
    entity_info: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseDestInfo(
    rtm_reg_handle: isize,
    dest_info: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseRouteInfo(
    rtm_reg_handle: isize,
    route_info: ?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseNextHopInfo(
    rtm_reg_handle: isize,
    next_hop_info: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmAddRouteToDest(
    rtm_reg_handle: isize,
    route_handle: ?*isize,
    dest_address: ?*RTM_NET_ADDRESS,
    route_info: ?*RTM_ROUTE_INFO,
    time_to_live: u32,
    route_list_handle: isize,
    notify_type: u32,
    notify_handle: isize,
    change_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeleteRouteToDest(
    rtm_reg_handle: isize,
    route_handle: isize,
    change_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmHoldDestination(
    rtm_reg_handle: isize,
    dest_handle: isize,
    target_views: u32,
    hold_time: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetRoutePointer(
    rtm_reg_handle: isize,
    route_handle: isize,
    route_pointer: ?*?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmLockRoute(
    rtm_reg_handle: isize,
    route_handle: isize,
    exclusive: BOOL,
    lock_route: BOOL,
    route_pointer: ?*?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmUpdateAndUnlockRoute(
    rtm_reg_handle: isize,
    route_handle: isize,
    time_to_live: u32,
    route_list_handle: isize,
    notify_type: u32,
    notify_handle: isize,
    change_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetExactMatchDestination(
    rtm_reg_handle: isize,
    dest_address: ?*RTM_NET_ADDRESS,
    protocol_id: u32,
    target_views: u32,
    dest_info: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetMostSpecificDestination(
    rtm_reg_handle: isize,
    dest_address: ?*RTM_NET_ADDRESS,
    protocol_id: u32,
    target_views: u32,
    dest_info: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetLessSpecificDestination(
    rtm_reg_handle: isize,
    dest_handle: isize,
    protocol_id: u32,
    target_views: u32,
    dest_info: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetExactMatchRoute(
    rtm_reg_handle: isize,
    dest_address: ?*RTM_NET_ADDRESS,
    matching_flags: u32,
    route_info: ?*RTM_ROUTE_INFO,
    interface_index: u32,
    target_views: u32,
    route_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmIsBestRoute(
    rtm_reg_handle: isize,
    route_handle: isize,
    best_in_views: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmAddNextHop(
    rtm_reg_handle: isize,
    next_hop_info: ?*RTM_NEXTHOP_INFO,
    next_hop_handle: ?*isize,
    change_flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmFindNextHop(
    rtm_reg_handle: isize,
    next_hop_info: ?*RTM_NEXTHOP_INFO,
    next_hop_handle: ?*isize,
    next_hop_pointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeleteNextHop(
    rtm_reg_handle: isize,
    next_hop_handle: isize,
    next_hop_info: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetNextHopPointer(
    rtm_reg_handle: isize,
    next_hop_handle: isize,
    next_hop_pointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmLockNextHop(
    rtm_reg_handle: isize,
    next_hop_handle: isize,
    exclusive: BOOL,
    lock_next_hop: BOOL,
    next_hop_pointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmCreateDestEnum(
    rtm_reg_handle: isize,
    target_views: u32,
    enum_flags: u32,
    net_address: ?*RTM_NET_ADDRESS,
    protocol_id: u32,
    rtm_enum_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetEnumDests(
    rtm_reg_handle: isize,
    enum_handle: isize,
    num_dests: ?*u32,
    dest_infos: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseDests(
    rtm_reg_handle: isize,
    num_dests: u32,
    dest_infos: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmCreateRouteEnum(
    rtm_reg_handle: isize,
    dest_handle: isize,
    target_views: u32,
    enum_flags: u32,
    start_dest: ?*RTM_NET_ADDRESS,
    matching_flags: u32,
    criteria_route: ?*RTM_ROUTE_INFO,
    criteria_interface: u32,
    rtm_enum_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetEnumRoutes(
    rtm_reg_handle: isize,
    enum_handle: isize,
    num_routes: ?*u32,
    route_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseRoutes(
    rtm_reg_handle: isize,
    num_routes: u32,
    route_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmCreateNextHopEnum(
    rtm_reg_handle: isize,
    enum_flags: u32,
    net_address: ?*RTM_NET_ADDRESS,
    rtm_enum_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetEnumNextHops(
    rtm_reg_handle: isize,
    enum_handle: isize,
    num_next_hops: ?*u32,
    next_hop_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseNextHops(
    rtm_reg_handle: isize,
    num_next_hops: u32,
    next_hop_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeleteEnumHandle(
    rtm_reg_handle: isize,
    enum_handle: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmRegisterForChangeNotification(
    rtm_reg_handle: isize,
    target_views: u32,
    notify_flags: u32,
    notify_context: ?*anyopaque,
    notify_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetChangedDests(
    rtm_reg_handle: isize,
    notify_handle: isize,
    num_dests: ?*u32,
    changed_dests: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReleaseChangedDests(
    rtm_reg_handle: isize,
    notify_handle: isize,
    num_dests: u32,
    changed_dests: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmIgnoreChangedDests(
    rtm_reg_handle: isize,
    notify_handle: isize,
    num_dests: u32,
    changed_dests: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetChangeStatus(
    rtm_reg_handle: isize,
    notify_handle: isize,
    dest_handle: isize,
    change_status: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmMarkDestForChangeNotification(
    rtm_reg_handle: isize,
    notify_handle: isize,
    dest_handle: isize,
    mark_dest: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmIsMarkedForChangeNotification(
    rtm_reg_handle: isize,
    notify_handle: isize,
    dest_handle: isize,
    dest_marked: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeregisterFromChangeNotification(
    rtm_reg_handle: isize,
    notify_handle: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmCreateRouteList(
    rtm_reg_handle: isize,
    route_list_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmInsertInRouteList(
    rtm_reg_handle: isize,
    route_list_handle: isize,
    num_routes: u32,
    route_handles: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmCreateRouteListEnum(
    rtm_reg_handle: isize,
    route_list_handle: isize,
    rtm_enum_handle: ?*isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmGetListEnumRoutes(
    rtm_reg_handle: isize,
    enum_handle: isize,
    num_routes: ?*u32,
    route_handles: [*]isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmDeleteRouteList(
    rtm_reg_handle: isize,
    route_list_handle: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windowsServer2000'
pub extern "rtm" fn RtmReferenceHandles(
    rtm_reg_handle: isize,
    num_handles: u32,
    rtm_handles: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (60)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const RASCONN = thismodule.RASCONNA;
        pub const RASCONNSTATUS = thismodule.RASCONNSTATUSA;
        pub const RASDIALPARAMS = thismodule.RASDIALPARAMSA;
        pub const RASENTRYNAME = thismodule.RASENTRYNAMEA;
        pub const RASAMB = thismodule.RASAMBA;
        pub const RASPPPNBF = thismodule.RASPPPNBFA;
        pub const RASPPPIP = thismodule.RASPPPIPA;
        pub const RASPPPLCP = thismodule.RASPPPLCPA;
        pub const RASDEVINFO = thismodule.RASDEVINFOA;
        pub const RASENTRY = thismodule.RASENTRYA;
        pub const RASADFUNC = thismodule.RASADFUNCA;
        pub const RASSUBENTRY = thismodule.RASSUBENTRYA;
        pub const RASCREDENTIALS = thismodule.RASCREDENTIALSA;
        pub const RASAUTODIALENTRY = thismodule.RASAUTODIALENTRYA;
        pub const RASEAPUSERIDENTITY = thismodule.RASEAPUSERIDENTITYA;
        pub const RASPBDLGFUNC = thismodule.RASPBDLGFUNCA;
        pub const RASNOUSER = thismodule.RASNOUSERA;
        pub const RASPBDLG = thismodule.RASPBDLGA;
        pub const RASENTRYDLG = thismodule.RASENTRYDLGA;
        pub const RasDial = thismodule.RasDialA;
        pub const RasEnumConnections = thismodule.RasEnumConnectionsA;
        pub const RasEnumEntries = thismodule.RasEnumEntriesA;
        pub const RasGetConnectStatus = thismodule.RasGetConnectStatusA;
        pub const RasGetErrorString = thismodule.RasGetErrorStringA;
        pub const RasHangUp = thismodule.RasHangUpA;
        pub const RasGetProjectionInfo = thismodule.RasGetProjectionInfoA;
        pub const RasCreatePhonebookEntry = thismodule.RasCreatePhonebookEntryA;
        pub const RasEditPhonebookEntry = thismodule.RasEditPhonebookEntryA;
        pub const RasSetEntryDialParams = thismodule.RasSetEntryDialParamsA;
        pub const RasGetEntryDialParams = thismodule.RasGetEntryDialParamsA;
        pub const RasEnumDevices = thismodule.RasEnumDevicesA;
        pub const RasGetCountryInfo = thismodule.RasGetCountryInfoA;
        pub const RasGetEntryProperties = thismodule.RasGetEntryPropertiesA;
        pub const RasSetEntryProperties = thismodule.RasSetEntryPropertiesA;
        pub const RasRenameEntry = thismodule.RasRenameEntryA;
        pub const RasDeleteEntry = thismodule.RasDeleteEntryA;
        pub const RasValidateEntryName = thismodule.RasValidateEntryNameA;
        pub const RasConnectionNotification = thismodule.RasConnectionNotificationA;
        pub const RasGetSubEntryHandle = thismodule.RasGetSubEntryHandleA;
        pub const RasGetCredentials = thismodule.RasGetCredentialsA;
        pub const RasSetCredentials = thismodule.RasSetCredentialsA;
        pub const RasGetSubEntryProperties = thismodule.RasGetSubEntryPropertiesA;
        pub const RasSetSubEntryProperties = thismodule.RasSetSubEntryPropertiesA;
        pub const RasGetAutodialAddress = thismodule.RasGetAutodialAddressA;
        pub const RasSetAutodialAddress = thismodule.RasSetAutodialAddressA;
        pub const RasEnumAutodialAddresses = thismodule.RasEnumAutodialAddressesA;
        pub const RasGetAutodialEnable = thismodule.RasGetAutodialEnableA;
        pub const RasSetAutodialEnable = thismodule.RasSetAutodialEnableA;
        pub const RasGetAutodialParam = thismodule.RasGetAutodialParamA;
        pub const RasSetAutodialParam = thismodule.RasSetAutodialParamA;
        pub const RasGetEapUserData = thismodule.RasGetEapUserDataA;
        pub const RasSetEapUserData = thismodule.RasSetEapUserDataA;
        pub const RasGetCustomAuthData = thismodule.RasGetCustomAuthDataA;
        pub const RasSetCustomAuthData = thismodule.RasSetCustomAuthDataA;
        pub const RasGetEapUserIdentity = thismodule.RasGetEapUserIdentityA;
        pub const RasFreeEapUserIdentity = thismodule.RasFreeEapUserIdentityA;
        pub const RasDeleteSubEntry = thismodule.RasDeleteSubEntryA;
        pub const RasPhonebookDlg = thismodule.RasPhonebookDlgA;
        pub const RasEntryDlg = thismodule.RasEntryDlgA;
        pub const RasDialDlg = thismodule.RasDialDlgA;
    },
    .wide => struct {
        pub const RASCONN = thismodule.RASCONNW;
        pub const RASCONNSTATUS = thismodule.RASCONNSTATUSW;
        pub const RASDIALPARAMS = thismodule.RASDIALPARAMSW;
        pub const RASENTRYNAME = thismodule.RASENTRYNAMEW;
        pub const RASAMB = thismodule.RASAMBW;
        pub const RASPPPNBF = thismodule.RASPPPNBFW;
        pub const RASPPPIP = thismodule.RASPPPIPW;
        pub const RASPPPLCP = thismodule.RASPPPLCPW;
        pub const RASDEVINFO = thismodule.RASDEVINFOW;
        pub const RASENTRY = thismodule.RASENTRYW;
        pub const RASADFUNC = thismodule.RASADFUNCW;
        pub const RASSUBENTRY = thismodule.RASSUBENTRYW;
        pub const RASCREDENTIALS = thismodule.RASCREDENTIALSW;
        pub const RASAUTODIALENTRY = thismodule.RASAUTODIALENTRYW;
        pub const RASEAPUSERIDENTITY = thismodule.RASEAPUSERIDENTITYW;
        pub const RASPBDLGFUNC = thismodule.RASPBDLGFUNCW;
        pub const RASNOUSER = thismodule.RASNOUSERW;
        pub const RASPBDLG = thismodule.RASPBDLGW;
        pub const RASENTRYDLG = thismodule.RASENTRYDLGW;
        pub const RasDial = thismodule.RasDialW;
        pub const RasEnumConnections = thismodule.RasEnumConnectionsW;
        pub const RasEnumEntries = thismodule.RasEnumEntriesW;
        pub const RasGetConnectStatus = thismodule.RasGetConnectStatusW;
        pub const RasGetErrorString = thismodule.RasGetErrorStringW;
        pub const RasHangUp = thismodule.RasHangUpW;
        pub const RasGetProjectionInfo = thismodule.RasGetProjectionInfoW;
        pub const RasCreatePhonebookEntry = thismodule.RasCreatePhonebookEntryW;
        pub const RasEditPhonebookEntry = thismodule.RasEditPhonebookEntryW;
        pub const RasSetEntryDialParams = thismodule.RasSetEntryDialParamsW;
        pub const RasGetEntryDialParams = thismodule.RasGetEntryDialParamsW;
        pub const RasEnumDevices = thismodule.RasEnumDevicesW;
        pub const RasGetCountryInfo = thismodule.RasGetCountryInfoW;
        pub const RasGetEntryProperties = thismodule.RasGetEntryPropertiesW;
        pub const RasSetEntryProperties = thismodule.RasSetEntryPropertiesW;
        pub const RasRenameEntry = thismodule.RasRenameEntryW;
        pub const RasDeleteEntry = thismodule.RasDeleteEntryW;
        pub const RasValidateEntryName = thismodule.RasValidateEntryNameW;
        pub const RasConnectionNotification = thismodule.RasConnectionNotificationW;
        pub const RasGetSubEntryHandle = thismodule.RasGetSubEntryHandleW;
        pub const RasGetCredentials = thismodule.RasGetCredentialsW;
        pub const RasSetCredentials = thismodule.RasSetCredentialsW;
        pub const RasGetSubEntryProperties = thismodule.RasGetSubEntryPropertiesW;
        pub const RasSetSubEntryProperties = thismodule.RasSetSubEntryPropertiesW;
        pub const RasGetAutodialAddress = thismodule.RasGetAutodialAddressW;
        pub const RasSetAutodialAddress = thismodule.RasSetAutodialAddressW;
        pub const RasEnumAutodialAddresses = thismodule.RasEnumAutodialAddressesW;
        pub const RasGetAutodialEnable = thismodule.RasGetAutodialEnableW;
        pub const RasSetAutodialEnable = thismodule.RasSetAutodialEnableW;
        pub const RasGetAutodialParam = thismodule.RasGetAutodialParamW;
        pub const RasSetAutodialParam = thismodule.RasSetAutodialParamW;
        pub const RasGetEapUserData = thismodule.RasGetEapUserDataW;
        pub const RasSetEapUserData = thismodule.RasSetEapUserDataW;
        pub const RasGetCustomAuthData = thismodule.RasGetCustomAuthDataW;
        pub const RasSetCustomAuthData = thismodule.RasSetCustomAuthDataW;
        pub const RasGetEapUserIdentity = thismodule.RasGetEapUserIdentityW;
        pub const RasFreeEapUserIdentity = thismodule.RasFreeEapUserIdentityW;
        pub const RasDeleteSubEntry = thismodule.RasDeleteSubEntryW;
        pub const RasPhonebookDlg = thismodule.RasPhonebookDlgW;
        pub const RasEntryDlg = thismodule.RasEntryDlgW;
        pub const RasDialDlg = thismodule.RasDialDlgW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const RASCONN = *opaque {};
        pub const RASCONNSTATUS = *opaque {};
        pub const RASDIALPARAMS = *opaque {};
        pub const RASENTRYNAME = *opaque {};
        pub const RASAMB = *opaque {};
        pub const RASPPPNBF = *opaque {};
        pub const RASPPPIP = *opaque {};
        pub const RASPPPLCP = *opaque {};
        pub const RASDEVINFO = *opaque {};
        pub const RASENTRY = *opaque {};
        pub const RASADFUNC = *opaque {};
        pub const RASSUBENTRY = *opaque {};
        pub const RASCREDENTIALS = *opaque {};
        pub const RASAUTODIALENTRY = *opaque {};
        pub const RASEAPUSERIDENTITY = *opaque {};
        pub const RASPBDLGFUNC = *opaque {};
        pub const RASNOUSER = *opaque {};
        pub const RASPBDLG = *opaque {};
        pub const RASENTRYDLG = *opaque {};
        pub const RasDial = *opaque {};
        pub const RasEnumConnections = *opaque {};
        pub const RasEnumEntries = *opaque {};
        pub const RasGetConnectStatus = *opaque {};
        pub const RasGetErrorString = *opaque {};
        pub const RasHangUp = *opaque {};
        pub const RasGetProjectionInfo = *opaque {};
        pub const RasCreatePhonebookEntry = *opaque {};
        pub const RasEditPhonebookEntry = *opaque {};
        pub const RasSetEntryDialParams = *opaque {};
        pub const RasGetEntryDialParams = *opaque {};
        pub const RasEnumDevices = *opaque {};
        pub const RasGetCountryInfo = *opaque {};
        pub const RasGetEntryProperties = *opaque {};
        pub const RasSetEntryProperties = *opaque {};
        pub const RasRenameEntry = *opaque {};
        pub const RasDeleteEntry = *opaque {};
        pub const RasValidateEntryName = *opaque {};
        pub const RasConnectionNotification = *opaque {};
        pub const RasGetSubEntryHandle = *opaque {};
        pub const RasGetCredentials = *opaque {};
        pub const RasSetCredentials = *opaque {};
        pub const RasGetSubEntryProperties = *opaque {};
        pub const RasSetSubEntryProperties = *opaque {};
        pub const RasGetAutodialAddress = *opaque {};
        pub const RasSetAutodialAddress = *opaque {};
        pub const RasEnumAutodialAddresses = *opaque {};
        pub const RasGetAutodialEnable = *opaque {};
        pub const RasSetAutodialEnable = *opaque {};
        pub const RasGetAutodialParam = *opaque {};
        pub const RasSetAutodialParam = *opaque {};
        pub const RasGetEapUserData = *opaque {};
        pub const RasSetEapUserData = *opaque {};
        pub const RasGetCustomAuthData = *opaque {};
        pub const RasSetCustomAuthData = *opaque {};
        pub const RasGetEapUserIdentity = *opaque {};
        pub const RasFreeEapUserIdentity = *opaque {};
        pub const RasDeleteSubEntry = *opaque {};
        pub const RasPhonebookDlg = *opaque {};
        pub const RasEntryDlg = *opaque {};
        pub const RasDialDlg = *opaque {};
    } else struct {
        pub const RASCONN = @compileError("'RASCONN' requires that UNICODE be set to true or false in the root module");
        pub const RASCONNSTATUS = @compileError("'RASCONNSTATUS' requires that UNICODE be set to true or false in the root module");
        pub const RASDIALPARAMS = @compileError("'RASDIALPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const RASENTRYNAME = @compileError("'RASENTRYNAME' requires that UNICODE be set to true or false in the root module");
        pub const RASAMB = @compileError("'RASAMB' requires that UNICODE be set to true or false in the root module");
        pub const RASPPPNBF = @compileError("'RASPPPNBF' requires that UNICODE be set to true or false in the root module");
        pub const RASPPPIP = @compileError("'RASPPPIP' requires that UNICODE be set to true or false in the root module");
        pub const RASPPPLCP = @compileError("'RASPPPLCP' requires that UNICODE be set to true or false in the root module");
        pub const RASDEVINFO = @compileError("'RASDEVINFO' requires that UNICODE be set to true or false in the root module");
        pub const RASENTRY = @compileError("'RASENTRY' requires that UNICODE be set to true or false in the root module");
        pub const RASADFUNC = @compileError("'RASADFUNC' requires that UNICODE be set to true or false in the root module");
        pub const RASSUBENTRY = @compileError("'RASSUBENTRY' requires that UNICODE be set to true or false in the root module");
        pub const RASCREDENTIALS = @compileError("'RASCREDENTIALS' requires that UNICODE be set to true or false in the root module");
        pub const RASAUTODIALENTRY = @compileError("'RASAUTODIALENTRY' requires that UNICODE be set to true or false in the root module");
        pub const RASEAPUSERIDENTITY = @compileError("'RASEAPUSERIDENTITY' requires that UNICODE be set to true or false in the root module");
        pub const RASPBDLGFUNC = @compileError("'RASPBDLGFUNC' requires that UNICODE be set to true or false in the root module");
        pub const RASNOUSER = @compileError("'RASNOUSER' requires that UNICODE be set to true or false in the root module");
        pub const RASPBDLG = @compileError("'RASPBDLG' requires that UNICODE be set to true or false in the root module");
        pub const RASENTRYDLG = @compileError("'RASENTRYDLG' requires that UNICODE be set to true or false in the root module");
        pub const RasDial = @compileError("'RasDial' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumConnections = @compileError("'RasEnumConnections' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumEntries = @compileError("'RasEnumEntries' requires that UNICODE be set to true or false in the root module");
        pub const RasGetConnectStatus = @compileError("'RasGetConnectStatus' requires that UNICODE be set to true or false in the root module");
        pub const RasGetErrorString = @compileError("'RasGetErrorString' requires that UNICODE be set to true or false in the root module");
        pub const RasHangUp = @compileError("'RasHangUp' requires that UNICODE be set to true or false in the root module");
        pub const RasGetProjectionInfo = @compileError("'RasGetProjectionInfo' requires that UNICODE be set to true or false in the root module");
        pub const RasCreatePhonebookEntry = @compileError("'RasCreatePhonebookEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasEditPhonebookEntry = @compileError("'RasEditPhonebookEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEntryDialParams = @compileError("'RasSetEntryDialParams' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEntryDialParams = @compileError("'RasGetEntryDialParams' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumDevices = @compileError("'RasEnumDevices' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCountryInfo = @compileError("'RasGetCountryInfo' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEntryProperties = @compileError("'RasGetEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEntryProperties = @compileError("'RasSetEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasRenameEntry = @compileError("'RasRenameEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasDeleteEntry = @compileError("'RasDeleteEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasValidateEntryName = @compileError("'RasValidateEntryName' requires that UNICODE be set to true or false in the root module");
        pub const RasConnectionNotification = @compileError("'RasConnectionNotification' requires that UNICODE be set to true or false in the root module");
        pub const RasGetSubEntryHandle = @compileError("'RasGetSubEntryHandle' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCredentials = @compileError("'RasGetCredentials' requires that UNICODE be set to true or false in the root module");
        pub const RasSetCredentials = @compileError("'RasSetCredentials' requires that UNICODE be set to true or false in the root module");
        pub const RasGetSubEntryProperties = @compileError("'RasGetSubEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasSetSubEntryProperties = @compileError("'RasSetSubEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialAddress = @compileError("'RasGetAutodialAddress' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialAddress = @compileError("'RasSetAutodialAddress' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumAutodialAddresses = @compileError("'RasEnumAutodialAddresses' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialEnable = @compileError("'RasGetAutodialEnable' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialEnable = @compileError("'RasSetAutodialEnable' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialParam = @compileError("'RasGetAutodialParam' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialParam = @compileError("'RasSetAutodialParam' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEapUserData = @compileError("'RasGetEapUserData' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEapUserData = @compileError("'RasSetEapUserData' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCustomAuthData = @compileError("'RasGetCustomAuthData' requires that UNICODE be set to true or false in the root module");
        pub const RasSetCustomAuthData = @compileError("'RasSetCustomAuthData' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEapUserIdentity = @compileError("'RasGetEapUserIdentity' requires that UNICODE be set to true or false in the root module");
        pub const RasFreeEapUserIdentity = @compileError("'RasFreeEapUserIdentity' requires that UNICODE be set to true or false in the root module");
        pub const RasDeleteSubEntry = @compileError("'RasDeleteSubEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasPhonebookDlg = @compileError("'RasPhonebookDlg' requires that UNICODE be set to true or false in the root module");
        pub const RasEntryDlg = @compileError("'RasEntryDlg' requires that UNICODE be set to true or false in the root module");
        pub const RasDialDlg = @compileError("'RasDialDlg' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CHAR = @import("../foundation.zig").CHAR;
const CRYPTOAPI_BLOB = @import("../security/cryptography.zig").CRYPTOAPI_BLOB;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HWND = @import("../foundation.zig").HWND;
const IN6_ADDR = @import("../networking/win_sock.zig").IN6_ADDR;
const IN_ADDR = @import("../networking/win_sock.zig").IN_ADDR;
const LUID = @import("../foundation.zig").LUID;
const MIB_IPMCAST_MFE = @import("../network_management/ip_helper.zig").MIB_IPMCAST_MFE;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "RASDIALFUNC")) {
        _ = RASDIALFUNC;
    }
    if (@hasDecl(@This(), "RASDIALFUNC1")) {
        _ = RASDIALFUNC1;
    }
    if (@hasDecl(@This(), "RASDIALFUNC2")) {
        _ = RASDIALFUNC2;
    }
    if (@hasDecl(@This(), "ORASADFUNC")) {
        _ = ORASADFUNC;
    }
    if (@hasDecl(@This(), "RASADFUNCA")) {
        _ = RASADFUNCA;
    }
    if (@hasDecl(@This(), "RASADFUNCW")) {
        _ = RASADFUNCW;
    }
    if (@hasDecl(@This(), "PFNRASGETBUFFER")) {
        _ = PFNRASGETBUFFER;
    }
    if (@hasDecl(@This(), "PFNRASFREEBUFFER")) {
        _ = PFNRASFREEBUFFER;
    }
    if (@hasDecl(@This(), "PFNRASSENDBUFFER")) {
        _ = PFNRASSENDBUFFER;
    }
    if (@hasDecl(@This(), "PFNRASRECEIVEBUFFER")) {
        _ = PFNRASRECEIVEBUFFER;
    }
    if (@hasDecl(@This(), "PFNRASRETRIEVEBUFFER")) {
        _ = PFNRASRETRIEVEBUFFER;
    }
    if (@hasDecl(@This(), "RasCustomScriptExecuteFn")) {
        _ = RasCustomScriptExecuteFn;
    }
    if (@hasDecl(@This(), "PFNRASSETCOMMSETTINGS")) {
        _ = PFNRASSETCOMMSETTINGS;
    }
    if (@hasDecl(@This(), "RasCustomHangUpFn")) {
        _ = RasCustomHangUpFn;
    }
    if (@hasDecl(@This(), "RasCustomDialFn")) {
        _ = RasCustomDialFn;
    }
    if (@hasDecl(@This(), "RasCustomDeleteEntryNotifyFn")) {
        _ = RasCustomDeleteEntryNotifyFn;
    }
    if (@hasDecl(@This(), "RASPBDLGFUNCW")) {
        _ = RASPBDLGFUNCW;
    }
    if (@hasDecl(@This(), "RASPBDLGFUNCA")) {
        _ = RASPBDLGFUNCA;
    }
    if (@hasDecl(@This(), "RasCustomDialDlgFn")) {
        _ = RasCustomDialDlgFn;
    }
    if (@hasDecl(@This(), "RasCustomEntryDlgFn")) {
        _ = RasCustomEntryDlgFn;
    }
    if (@hasDecl(@This(), "PMPRADMINGETIPADDRESSFORUSER")) {
        _ = PMPRADMINGETIPADDRESSFORUSER;
    }
    if (@hasDecl(@This(), "PMPRADMINRELEASEIPADRESS")) {
        _ = PMPRADMINRELEASEIPADRESS;
    }
    if (@hasDecl(@This(), "PMPRADMINGETIPV6ADDRESSFORUSER")) {
        _ = PMPRADMINGETIPV6ADDRESSFORUSER;
    }
    if (@hasDecl(@This(), "PMPRADMINRELEASEIPV6ADDRESSFORUSER")) {
        _ = PMPRADMINRELEASEIPV6ADDRESSFORUSER;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTNEWCONNECTION")) {
        _ = PMPRADMINACCEPTNEWCONNECTION;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTNEWCONNECTION2")) {
        _ = PMPRADMINACCEPTNEWCONNECTION2;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTNEWCONNECTION3")) {
        _ = PMPRADMINACCEPTNEWCONNECTION3;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTNEWLINK")) {
        _ = PMPRADMINACCEPTNEWLINK;
    }
    if (@hasDecl(@This(), "PMPRADMINCONNECTIONHANGUPNOTIFICATION")) {
        _ = PMPRADMINCONNECTIONHANGUPNOTIFICATION;
    }
    if (@hasDecl(@This(), "PMPRADMINCONNECTIONHANGUPNOTIFICATION2")) {
        _ = PMPRADMINCONNECTIONHANGUPNOTIFICATION2;
    }
    if (@hasDecl(@This(), "PMPRADMINCONNECTIONHANGUPNOTIFICATION3")) {
        _ = PMPRADMINCONNECTIONHANGUPNOTIFICATION3;
    }
    if (@hasDecl(@This(), "PMPRADMINLINKHANGUPNOTIFICATION")) {
        _ = PMPRADMINLINKHANGUPNOTIFICATION;
    }
    if (@hasDecl(@This(), "PMPRADMINTERMINATEDLL")) {
        _ = PMPRADMINTERMINATEDLL;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTREAUTHENTICATION")) {
        _ = PMPRADMINACCEPTREAUTHENTICATION;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTNEWCONNECTIONEX")) {
        _ = PMPRADMINACCEPTNEWCONNECTIONEX;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTREAUTHENTICATIONEX")) {
        _ = PMPRADMINACCEPTREAUTHENTICATIONEX;
    }
    if (@hasDecl(@This(), "PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX")) {
        _ = PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX;
    }
    if (@hasDecl(@This(), "PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX")) {
        _ = PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX;
    }
    if (@hasDecl(@This(), "PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX")) {
        _ = PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX;
    }
    if (@hasDecl(@This(), "RASSECURITYPROC")) {
        _ = RASSECURITYPROC;
    }
    if (@hasDecl(@This(), "PMGM_RPF_CALLBACK")) {
        _ = PMGM_RPF_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_CREATION_ALERT_CALLBACK")) {
        _ = PMGM_CREATION_ALERT_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_PRUNE_ALERT_CALLBACK")) {
        _ = PMGM_PRUNE_ALERT_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_JOIN_ALERT_CALLBACK")) {
        _ = PMGM_JOIN_ALERT_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_WRONG_IF_CALLBACK")) {
        _ = PMGM_WRONG_IF_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_LOCAL_JOIN_CALLBACK")) {
        _ = PMGM_LOCAL_JOIN_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_LOCAL_LEAVE_CALLBACK")) {
        _ = PMGM_LOCAL_LEAVE_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_DISABLE_IGMP_CALLBACK")) {
        _ = PMGM_DISABLE_IGMP_CALLBACK;
    }
    if (@hasDecl(@This(), "PMGM_ENABLE_IGMP_CALLBACK")) {
        _ = PMGM_ENABLE_IGMP_CALLBACK;
    }
    if (@hasDecl(@This(), "RTM_EVENT_CALLBACK")) {
        _ = RTM_EVENT_CALLBACK;
    }
    if (@hasDecl(@This(), "RTM_ENTITY_EXPORT_METHOD")) {
        _ = RTM_ENTITY_EXPORT_METHOD;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
