//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (891)
//--------------------------------------------------------------------------------
pub const ALL_SERVICE_TYPES = @as(u32, 0);
pub const HIGHLEVEL_SERVICE_TYPES = @as(u32, 1);
pub const LOWLEVEL_SERVICE_TYPES = @as(u32, 2);
pub const ALL_SERVICES = @as(u32, 0);
pub const ONLINE_SERVICES = @as(u32, 1);
pub const OFFLINE_SERVICES = @as(u32, 2);
pub const MAX_LEADBYTES = @as(u32, 12);
pub const MAX_DEFAULTCHAR = @as(u32, 2);
pub const HIGH_SURROGATE_START = @as(u32, 55296);
pub const HIGH_SURROGATE_END = @as(u32, 56319);
pub const LOW_SURROGATE_START = @as(u32, 56320);
pub const LOW_SURROGATE_END = @as(u32, 57343);
pub const WC_COMPOSITECHECK = @as(u32, 512);
pub const WC_DISCARDNS = @as(u32, 16);
pub const WC_SEPCHARS = @as(u32, 32);
pub const WC_DEFAULTCHAR = @as(u32, 64);
pub const WC_ERR_INVALID_CHARS = @as(u32, 128);
pub const WC_NO_BEST_FIT_CHARS = @as(u32, 1024);
pub const CT_CTYPE1 = @as(u32, 1);
pub const CT_CTYPE2 = @as(u32, 2);
pub const CT_CTYPE3 = @as(u32, 4);
pub const C1_UPPER = @as(u32, 1);
pub const C1_LOWER = @as(u32, 2);
pub const C1_DIGIT = @as(u32, 4);
pub const C1_SPACE = @as(u32, 8);
pub const C1_PUNCT = @as(u32, 16);
pub const C1_CNTRL = @as(u32, 32);
pub const C1_BLANK = @as(u32, 64);
pub const C1_XDIGIT = @as(u32, 128);
pub const C1_ALPHA = @as(u32, 256);
pub const C1_DEFINED = @as(u32, 512);
pub const C2_LEFTTORIGHT = @as(u32, 1);
pub const C2_RIGHTTOLEFT = @as(u32, 2);
pub const C2_EUROPENUMBER = @as(u32, 3);
pub const C2_EUROPESEPARATOR = @as(u32, 4);
pub const C2_EUROPETERMINATOR = @as(u32, 5);
pub const C2_ARABICNUMBER = @as(u32, 6);
pub const C2_COMMONSEPARATOR = @as(u32, 7);
pub const C2_BLOCKSEPARATOR = @as(u32, 8);
pub const C2_SEGMENTSEPARATOR = @as(u32, 9);
pub const C2_WHITESPACE = @as(u32, 10);
pub const C2_OTHERNEUTRAL = @as(u32, 11);
pub const C2_NOTAPPLICABLE = @as(u32, 0);
pub const C3_NONSPACING = @as(u32, 1);
pub const C3_DIACRITIC = @as(u32, 2);
pub const C3_VOWELMARK = @as(u32, 4);
pub const C3_SYMBOL = @as(u32, 8);
pub const C3_KATAKANA = @as(u32, 16);
pub const C3_HIRAGANA = @as(u32, 32);
pub const C3_HALFWIDTH = @as(u32, 64);
pub const C3_FULLWIDTH = @as(u32, 128);
pub const C3_IDEOGRAPH = @as(u32, 256);
pub const C3_KASHIDA = @as(u32, 512);
pub const C3_LEXICAL = @as(u32, 1024);
pub const C3_HIGHSURROGATE = @as(u32, 2048);
pub const C3_LOWSURROGATE = @as(u32, 4096);
pub const C3_ALPHA = @as(u32, 32768);
pub const C3_NOTAPPLICABLE = @as(u32, 0);
pub const LCMAP_LOWERCASE = @as(u32, 256);
pub const LCMAP_UPPERCASE = @as(u32, 512);
pub const LCMAP_TITLECASE = @as(u32, 768);
pub const LCMAP_SORTKEY = @as(u32, 1024);
pub const LCMAP_BYTEREV = @as(u32, 2048);
pub const LCMAP_HIRAGANA = @as(u32, 1048576);
pub const LCMAP_KATAKANA = @as(u32, 2097152);
pub const LCMAP_HALFWIDTH = @as(u32, 4194304);
pub const LCMAP_FULLWIDTH = @as(u32, 8388608);
pub const LCMAP_LINGUISTIC_CASING = @as(u32, 16777216);
pub const LCMAP_SIMPLIFIED_CHINESE = @as(u32, 33554432);
pub const LCMAP_TRADITIONAL_CHINESE = @as(u32, 67108864);
pub const LCMAP_SORTHANDLE = @as(u32, 536870912);
pub const LCMAP_HASH = @as(u32, 262144);
pub const FIND_STARTSWITH = @as(u32, 1048576);
pub const FIND_ENDSWITH = @as(u32, 2097152);
pub const FIND_FROMSTART = @as(u32, 4194304);
pub const FIND_FROMEND = @as(u32, 8388608);
pub const LCID_ALTERNATE_SORTS = @as(u32, 4);
pub const LOCALE_ALL = @as(u32, 0);
pub const LOCALE_WINDOWS = @as(u32, 1);
pub const LOCALE_SUPPLEMENTAL = @as(u32, 2);
pub const LOCALE_ALTERNATE_SORTS = @as(u32, 4);
pub const LOCALE_REPLACEMENT = @as(u32, 8);
pub const LOCALE_NEUTRALDATA = @as(u32, 16);
pub const LOCALE_SPECIFICDATA = @as(u32, 32);
pub const CSTR_LESS_THAN = @as(u32, 1);
pub const CSTR_EQUAL = @as(u32, 2);
pub const CSTR_GREATER_THAN = @as(u32, 3);
pub const CP_ACP = @as(u32, 0);
pub const CP_OEMCP = @as(u32, 1);
pub const CP_MACCP = @as(u32, 2);
pub const CP_THREAD_ACP = @as(u32, 3);
pub const CP_SYMBOL = @as(u32, 42);
pub const CP_UTF7 = @as(u32, 65000);
pub const CP_UTF8 = @as(u32, 65001);
pub const CTRY_DEFAULT = @as(u32, 0);
pub const CTRY_ALBANIA = @as(u32, 355);
pub const CTRY_ALGERIA = @as(u32, 213);
pub const CTRY_ARGENTINA = @as(u32, 54);
pub const CTRY_ARMENIA = @as(u32, 374);
pub const CTRY_AUSTRALIA = @as(u32, 61);
pub const CTRY_AUSTRIA = @as(u32, 43);
pub const CTRY_AZERBAIJAN = @as(u32, 994);
pub const CTRY_BAHRAIN = @as(u32, 973);
pub const CTRY_BELARUS = @as(u32, 375);
pub const CTRY_BELGIUM = @as(u32, 32);
pub const CTRY_BELIZE = @as(u32, 501);
pub const CTRY_BOLIVIA = @as(u32, 591);
pub const CTRY_BRAZIL = @as(u32, 55);
pub const CTRY_BRUNEI_DARUSSALAM = @as(u32, 673);
pub const CTRY_BULGARIA = @as(u32, 359);
pub const CTRY_CANADA = @as(u32, 2);
pub const CTRY_CARIBBEAN = @as(u32, 1);
pub const CTRY_CHILE = @as(u32, 56);
pub const CTRY_COLOMBIA = @as(u32, 57);
pub const CTRY_COSTA_RICA = @as(u32, 506);
pub const CTRY_CROATIA = @as(u32, 385);
pub const CTRY_CZECH = @as(u32, 420);
pub const CTRY_DENMARK = @as(u32, 45);
pub const CTRY_DOMINICAN_REPUBLIC = @as(u32, 1);
pub const CTRY_ECUADOR = @as(u32, 593);
pub const CTRY_EGYPT = @as(u32, 20);
pub const CTRY_EL_SALVADOR = @as(u32, 503);
pub const CTRY_ESTONIA = @as(u32, 372);
pub const CTRY_FAEROE_ISLANDS = @as(u32, 298);
pub const CTRY_FINLAND = @as(u32, 358);
pub const CTRY_FRANCE = @as(u32, 33);
pub const CTRY_GEORGIA = @as(u32, 995);
pub const CTRY_GERMANY = @as(u32, 49);
pub const CTRY_GREECE = @as(u32, 30);
pub const CTRY_GUATEMALA = @as(u32, 502);
pub const CTRY_HONDURAS = @as(u32, 504);
pub const CTRY_HONG_KONG = @as(u32, 852);
pub const CTRY_HUNGARY = @as(u32, 36);
pub const CTRY_ICELAND = @as(u32, 354);
pub const CTRY_INDIA = @as(u32, 91);
pub const CTRY_INDONESIA = @as(u32, 62);
pub const CTRY_IRAN = @as(u32, 981);
pub const CTRY_IRAQ = @as(u32, 964);
pub const CTRY_IRELAND = @as(u32, 353);
pub const CTRY_ISRAEL = @as(u32, 972);
pub const CTRY_ITALY = @as(u32, 39);
pub const CTRY_JAMAICA = @as(u32, 1);
pub const CTRY_JAPAN = @as(u32, 81);
pub const CTRY_JORDAN = @as(u32, 962);
pub const CTRY_KAZAKSTAN = @as(u32, 7);
pub const CTRY_KENYA = @as(u32, 254);
pub const CTRY_KUWAIT = @as(u32, 965);
pub const CTRY_KYRGYZSTAN = @as(u32, 996);
pub const CTRY_LATVIA = @as(u32, 371);
pub const CTRY_LEBANON = @as(u32, 961);
pub const CTRY_LIBYA = @as(u32, 218);
pub const CTRY_LIECHTENSTEIN = @as(u32, 41);
pub const CTRY_LITHUANIA = @as(u32, 370);
pub const CTRY_LUXEMBOURG = @as(u32, 352);
pub const CTRY_MACAU = @as(u32, 853);
pub const CTRY_MACEDONIA = @as(u32, 389);
pub const CTRY_MALAYSIA = @as(u32, 60);
pub const CTRY_MALDIVES = @as(u32, 960);
pub const CTRY_MEXICO = @as(u32, 52);
pub const CTRY_MONACO = @as(u32, 33);
pub const CTRY_MONGOLIA = @as(u32, 976);
pub const CTRY_MOROCCO = @as(u32, 212);
pub const CTRY_NETHERLANDS = @as(u32, 31);
pub const CTRY_NEW_ZEALAND = @as(u32, 64);
pub const CTRY_NICARAGUA = @as(u32, 505);
pub const CTRY_NORWAY = @as(u32, 47);
pub const CTRY_OMAN = @as(u32, 968);
pub const CTRY_PAKISTAN = @as(u32, 92);
pub const CTRY_PANAMA = @as(u32, 507);
pub const CTRY_PARAGUAY = @as(u32, 595);
pub const CTRY_PERU = @as(u32, 51);
pub const CTRY_PHILIPPINES = @as(u32, 63);
pub const CTRY_POLAND = @as(u32, 48);
pub const CTRY_PORTUGAL = @as(u32, 351);
pub const CTRY_PRCHINA = @as(u32, 86);
pub const CTRY_PUERTO_RICO = @as(u32, 1);
pub const CTRY_QATAR = @as(u32, 974);
pub const CTRY_ROMANIA = @as(u32, 40);
pub const CTRY_RUSSIA = @as(u32, 7);
pub const CTRY_SAUDI_ARABIA = @as(u32, 966);
pub const CTRY_SERBIA = @as(u32, 381);
pub const CTRY_SINGAPORE = @as(u32, 65);
pub const CTRY_SLOVAK = @as(u32, 421);
pub const CTRY_SLOVENIA = @as(u32, 386);
pub const CTRY_SOUTH_AFRICA = @as(u32, 27);
pub const CTRY_SOUTH_KOREA = @as(u32, 82);
pub const CTRY_SPAIN = @as(u32, 34);
pub const CTRY_SWEDEN = @as(u32, 46);
pub const CTRY_SWITZERLAND = @as(u32, 41);
pub const CTRY_SYRIA = @as(u32, 963);
pub const CTRY_TAIWAN = @as(u32, 886);
pub const CTRY_TATARSTAN = @as(u32, 7);
pub const CTRY_THAILAND = @as(u32, 66);
pub const CTRY_TRINIDAD_Y_TOBAGO = @as(u32, 1);
pub const CTRY_TUNISIA = @as(u32, 216);
pub const CTRY_TURKEY = @as(u32, 90);
pub const CTRY_UAE = @as(u32, 971);
pub const CTRY_UKRAINE = @as(u32, 380);
pub const CTRY_UNITED_KINGDOM = @as(u32, 44);
pub const CTRY_UNITED_STATES = @as(u32, 1);
pub const CTRY_URUGUAY = @as(u32, 598);
pub const CTRY_UZBEKISTAN = @as(u32, 7);
pub const CTRY_VENEZUELA = @as(u32, 58);
pub const CTRY_VIET_NAM = @as(u32, 84);
pub const CTRY_YEMEN = @as(u32, 967);
pub const CTRY_ZIMBABWE = @as(u32, 263);
pub const LOCALE_NOUSEROVERRIDE = @as(u32, 2147483648);
pub const LOCALE_USE_CP_ACP = @as(u32, 1073741824);
pub const LOCALE_RETURN_NUMBER = @as(u32, 536870912);
pub const LOCALE_RETURN_GENITIVE_NAMES = @as(u32, 268435456);
pub const LOCALE_ALLOW_NEUTRAL_NAMES = @as(u32, 134217728);
pub const LOCALE_SLOCALIZEDDISPLAYNAME = @as(u32, 2);
pub const LOCALE_SENGLISHDISPLAYNAME = @as(u32, 114);
pub const LOCALE_SNATIVEDISPLAYNAME = @as(u32, 115);
pub const LOCALE_SLOCALIZEDLANGUAGENAME = @as(u32, 111);
pub const LOCALE_SENGLISHLANGUAGENAME = @as(u32, 4097);
pub const LOCALE_SNATIVELANGUAGENAME = @as(u32, 4);
pub const LOCALE_SLOCALIZEDCOUNTRYNAME = @as(u32, 6);
pub const LOCALE_SENGLISHCOUNTRYNAME = @as(u32, 4098);
pub const LOCALE_SNATIVECOUNTRYNAME = @as(u32, 8);
pub const LOCALE_IDIALINGCODE = @as(u32, 5);
pub const LOCALE_SLIST = @as(u32, 12);
pub const LOCALE_IMEASURE = @as(u32, 13);
pub const LOCALE_SDECIMAL = @as(u32, 14);
pub const LOCALE_STHOUSAND = @as(u32, 15);
pub const LOCALE_SGROUPING = @as(u32, 16);
pub const LOCALE_IDIGITS = @as(u32, 17);
pub const LOCALE_ILZERO = @as(u32, 18);
pub const LOCALE_INEGNUMBER = @as(u32, 4112);
pub const LOCALE_SNATIVEDIGITS = @as(u32, 19);
pub const LOCALE_SCURRENCY = @as(u32, 20);
pub const LOCALE_SINTLSYMBOL = @as(u32, 21);
pub const LOCALE_SMONDECIMALSEP = @as(u32, 22);
pub const LOCALE_SMONTHOUSANDSEP = @as(u32, 23);
pub const LOCALE_SMONGROUPING = @as(u32, 24);
pub const LOCALE_ICURRDIGITS = @as(u32, 25);
pub const LOCALE_ICURRENCY = @as(u32, 27);
pub const LOCALE_INEGCURR = @as(u32, 28);
pub const LOCALE_SSHORTDATE = @as(u32, 31);
pub const LOCALE_SLONGDATE = @as(u32, 32);
pub const LOCALE_STIMEFORMAT = @as(u32, 4099);
pub const LOCALE_SAM = @as(u32, 40);
pub const LOCALE_SPM = @as(u32, 41);
pub const LOCALE_ICALENDARTYPE = @as(u32, 4105);
pub const LOCALE_IOPTIONALCALENDAR = @as(u32, 4107);
pub const LOCALE_IFIRSTDAYOFWEEK = @as(u32, 4108);
pub const LOCALE_IFIRSTWEEKOFYEAR = @as(u32, 4109);
pub const LOCALE_SDAYNAME1 = @as(u32, 42);
pub const LOCALE_SDAYNAME2 = @as(u32, 43);
pub const LOCALE_SDAYNAME3 = @as(u32, 44);
pub const LOCALE_SDAYNAME4 = @as(u32, 45);
pub const LOCALE_SDAYNAME5 = @as(u32, 46);
pub const LOCALE_SDAYNAME6 = @as(u32, 47);
pub const LOCALE_SDAYNAME7 = @as(u32, 48);
pub const LOCALE_SABBREVDAYNAME1 = @as(u32, 49);
pub const LOCALE_SABBREVDAYNAME2 = @as(u32, 50);
pub const LOCALE_SABBREVDAYNAME3 = @as(u32, 51);
pub const LOCALE_SABBREVDAYNAME4 = @as(u32, 52);
pub const LOCALE_SABBREVDAYNAME5 = @as(u32, 53);
pub const LOCALE_SABBREVDAYNAME6 = @as(u32, 54);
pub const LOCALE_SABBREVDAYNAME7 = @as(u32, 55);
pub const LOCALE_SMONTHNAME1 = @as(u32, 56);
pub const LOCALE_SMONTHNAME2 = @as(u32, 57);
pub const LOCALE_SMONTHNAME3 = @as(u32, 58);
pub const LOCALE_SMONTHNAME4 = @as(u32, 59);
pub const LOCALE_SMONTHNAME5 = @as(u32, 60);
pub const LOCALE_SMONTHNAME6 = @as(u32, 61);
pub const LOCALE_SMONTHNAME7 = @as(u32, 62);
pub const LOCALE_SMONTHNAME8 = @as(u32, 63);
pub const LOCALE_SMONTHNAME9 = @as(u32, 64);
pub const LOCALE_SMONTHNAME10 = @as(u32, 65);
pub const LOCALE_SMONTHNAME11 = @as(u32, 66);
pub const LOCALE_SMONTHNAME12 = @as(u32, 67);
pub const LOCALE_SMONTHNAME13 = @as(u32, 4110);
pub const LOCALE_SABBREVMONTHNAME1 = @as(u32, 68);
pub const LOCALE_SABBREVMONTHNAME2 = @as(u32, 69);
pub const LOCALE_SABBREVMONTHNAME3 = @as(u32, 70);
pub const LOCALE_SABBREVMONTHNAME4 = @as(u32, 71);
pub const LOCALE_SABBREVMONTHNAME5 = @as(u32, 72);
pub const LOCALE_SABBREVMONTHNAME6 = @as(u32, 73);
pub const LOCALE_SABBREVMONTHNAME7 = @as(u32, 74);
pub const LOCALE_SABBREVMONTHNAME8 = @as(u32, 75);
pub const LOCALE_SABBREVMONTHNAME9 = @as(u32, 76);
pub const LOCALE_SABBREVMONTHNAME10 = @as(u32, 77);
pub const LOCALE_SABBREVMONTHNAME11 = @as(u32, 78);
pub const LOCALE_SABBREVMONTHNAME12 = @as(u32, 79);
pub const LOCALE_SABBREVMONTHNAME13 = @as(u32, 4111);
pub const LOCALE_SPOSITIVESIGN = @as(u32, 80);
pub const LOCALE_SNEGATIVESIGN = @as(u32, 81);
pub const LOCALE_IPOSSIGNPOSN = @as(u32, 82);
pub const LOCALE_INEGSIGNPOSN = @as(u32, 83);
pub const LOCALE_IPOSSYMPRECEDES = @as(u32, 84);
pub const LOCALE_IPOSSEPBYSPACE = @as(u32, 85);
pub const LOCALE_INEGSYMPRECEDES = @as(u32, 86);
pub const LOCALE_INEGSEPBYSPACE = @as(u32, 87);
pub const LOCALE_FONTSIGNATURE = @as(u32, 88);
pub const LOCALE_SISO639LANGNAME = @as(u32, 89);
pub const LOCALE_SISO3166CTRYNAME = @as(u32, 90);
pub const LOCALE_IPAPERSIZE = @as(u32, 4106);
pub const LOCALE_SENGCURRNAME = @as(u32, 4103);
pub const LOCALE_SNATIVECURRNAME = @as(u32, 4104);
pub const LOCALE_SYEARMONTH = @as(u32, 4102);
pub const LOCALE_SSORTNAME = @as(u32, 4115);
pub const LOCALE_IDIGITSUBSTITUTION = @as(u32, 4116);
pub const LOCALE_SNAME = @as(u32, 92);
pub const LOCALE_SDURATION = @as(u32, 93);
pub const LOCALE_SSHORTESTDAYNAME1 = @as(u32, 96);
pub const LOCALE_SSHORTESTDAYNAME2 = @as(u32, 97);
pub const LOCALE_SSHORTESTDAYNAME3 = @as(u32, 98);
pub const LOCALE_SSHORTESTDAYNAME4 = @as(u32, 99);
pub const LOCALE_SSHORTESTDAYNAME5 = @as(u32, 100);
pub const LOCALE_SSHORTESTDAYNAME6 = @as(u32, 101);
pub const LOCALE_SSHORTESTDAYNAME7 = @as(u32, 102);
pub const LOCALE_SISO639LANGNAME2 = @as(u32, 103);
pub const LOCALE_SISO3166CTRYNAME2 = @as(u32, 104);
pub const LOCALE_SNAN = @as(u32, 105);
pub const LOCALE_SPOSINFINITY = @as(u32, 106);
pub const LOCALE_SNEGINFINITY = @as(u32, 107);
pub const LOCALE_SSCRIPTS = @as(u32, 108);
pub const LOCALE_SPARENT = @as(u32, 109);
pub const LOCALE_SCONSOLEFALLBACKNAME = @as(u32, 110);
pub const LOCALE_IREADINGLAYOUT = @as(u32, 112);
pub const LOCALE_INEUTRAL = @as(u32, 113);
pub const LOCALE_INEGATIVEPERCENT = @as(u32, 116);
pub const LOCALE_IPOSITIVEPERCENT = @as(u32, 117);
pub const LOCALE_SPERCENT = @as(u32, 118);
pub const LOCALE_SPERMILLE = @as(u32, 119);
pub const LOCALE_SMONTHDAY = @as(u32, 120);
pub const LOCALE_SSHORTTIME = @as(u32, 121);
pub const LOCALE_SOPENTYPELANGUAGETAG = @as(u32, 122);
pub const LOCALE_SSORTLOCALE = @as(u32, 123);
pub const LOCALE_SRELATIVELONGDATE = @as(u32, 124);
pub const LOCALE_ICONSTRUCTEDLOCALE = @as(u32, 125);
pub const LOCALE_SSHORTESTAM = @as(u32, 126);
pub const LOCALE_SSHORTESTPM = @as(u32, 127);
pub const LOCALE_IUSEUTF8LEGACYACP = @as(u32, 1638);
pub const LOCALE_IUSEUTF8LEGACYOEMCP = @as(u32, 2457);
pub const LOCALE_IDEFAULTCODEPAGE = @as(u32, 11);
pub const LOCALE_IDEFAULTANSICODEPAGE = @as(u32, 4100);
pub const LOCALE_IDEFAULTMACCODEPAGE = @as(u32, 4113);
pub const LOCALE_IDEFAULTEBCDICCODEPAGE = @as(u32, 4114);
pub const LOCALE_ILANGUAGE = @as(u32, 1);
pub const LOCALE_SABBREVLANGNAME = @as(u32, 3);
pub const LOCALE_SABBREVCTRYNAME = @as(u32, 7);
pub const LOCALE_IGEOID = @as(u32, 91);
pub const LOCALE_IDEFAULTLANGUAGE = @as(u32, 9);
pub const LOCALE_IDEFAULTCOUNTRY = @as(u32, 10);
pub const LOCALE_IINTLCURRDIGITS = @as(u32, 26);
pub const LOCALE_SDATE = @as(u32, 29);
pub const LOCALE_STIME = @as(u32, 30);
pub const LOCALE_IDATE = @as(u32, 33);
pub const LOCALE_ILDATE = @as(u32, 34);
pub const LOCALE_ITIME = @as(u32, 35);
pub const LOCALE_ITIMEMARKPOSN = @as(u32, 4101);
pub const LOCALE_ICENTURY = @as(u32, 36);
pub const LOCALE_ITLZERO = @as(u32, 37);
pub const LOCALE_IDAYLZERO = @as(u32, 38);
pub const LOCALE_IMONLZERO = @as(u32, 39);
pub const LOCALE_SKEYBOARDSTOINSTALL = @as(u32, 94);
pub const LOCALE_SLANGUAGE = @as(u32, 2);
pub const LOCALE_SLANGDISPLAYNAME = @as(u32, 111);
pub const LOCALE_SENGLANGUAGE = @as(u32, 4097);
pub const LOCALE_SNATIVELANGNAME = @as(u32, 4);
pub const LOCALE_SCOUNTRY = @as(u32, 6);
pub const LOCALE_SENGCOUNTRY = @as(u32, 4098);
pub const LOCALE_SNATIVECTRYNAME = @as(u32, 8);
pub const LOCALE_ICOUNTRY = @as(u32, 5);
pub const LOCALE_S1159 = @as(u32, 40);
pub const LOCALE_S2359 = @as(u32, 41);
pub const CAL_NOUSEROVERRIDE = @as(u32, 2147483648);
pub const CAL_USE_CP_ACP = @as(u32, 1073741824);
pub const CAL_RETURN_NUMBER = @as(u32, 536870912);
pub const CAL_RETURN_GENITIVE_NAMES = @as(u32, 268435456);
pub const CAL_ICALINTVALUE = @as(u32, 1);
pub const CAL_SCALNAME = @as(u32, 2);
pub const CAL_IYEAROFFSETRANGE = @as(u32, 3);
pub const CAL_SERASTRING = @as(u32, 4);
pub const CAL_SSHORTDATE = @as(u32, 5);
pub const CAL_SLONGDATE = @as(u32, 6);
pub const CAL_SDAYNAME1 = @as(u32, 7);
pub const CAL_SDAYNAME2 = @as(u32, 8);
pub const CAL_SDAYNAME3 = @as(u32, 9);
pub const CAL_SDAYNAME4 = @as(u32, 10);
pub const CAL_SDAYNAME5 = @as(u32, 11);
pub const CAL_SDAYNAME6 = @as(u32, 12);
pub const CAL_SDAYNAME7 = @as(u32, 13);
pub const CAL_SABBREVDAYNAME1 = @as(u32, 14);
pub const CAL_SABBREVDAYNAME2 = @as(u32, 15);
pub const CAL_SABBREVDAYNAME3 = @as(u32, 16);
pub const CAL_SABBREVDAYNAME4 = @as(u32, 17);
pub const CAL_SABBREVDAYNAME5 = @as(u32, 18);
pub const CAL_SABBREVDAYNAME6 = @as(u32, 19);
pub const CAL_SABBREVDAYNAME7 = @as(u32, 20);
pub const CAL_SMONTHNAME1 = @as(u32, 21);
pub const CAL_SMONTHNAME2 = @as(u32, 22);
pub const CAL_SMONTHNAME3 = @as(u32, 23);
pub const CAL_SMONTHNAME4 = @as(u32, 24);
pub const CAL_SMONTHNAME5 = @as(u32, 25);
pub const CAL_SMONTHNAME6 = @as(u32, 26);
pub const CAL_SMONTHNAME7 = @as(u32, 27);
pub const CAL_SMONTHNAME8 = @as(u32, 28);
pub const CAL_SMONTHNAME9 = @as(u32, 29);
pub const CAL_SMONTHNAME10 = @as(u32, 30);
pub const CAL_SMONTHNAME11 = @as(u32, 31);
pub const CAL_SMONTHNAME12 = @as(u32, 32);
pub const CAL_SMONTHNAME13 = @as(u32, 33);
pub const CAL_SABBREVMONTHNAME1 = @as(u32, 34);
pub const CAL_SABBREVMONTHNAME2 = @as(u32, 35);
pub const CAL_SABBREVMONTHNAME3 = @as(u32, 36);
pub const CAL_SABBREVMONTHNAME4 = @as(u32, 37);
pub const CAL_SABBREVMONTHNAME5 = @as(u32, 38);
pub const CAL_SABBREVMONTHNAME6 = @as(u32, 39);
pub const CAL_SABBREVMONTHNAME7 = @as(u32, 40);
pub const CAL_SABBREVMONTHNAME8 = @as(u32, 41);
pub const CAL_SABBREVMONTHNAME9 = @as(u32, 42);
pub const CAL_SABBREVMONTHNAME10 = @as(u32, 43);
pub const CAL_SABBREVMONTHNAME11 = @as(u32, 44);
pub const CAL_SABBREVMONTHNAME12 = @as(u32, 45);
pub const CAL_SABBREVMONTHNAME13 = @as(u32, 46);
pub const CAL_SYEARMONTH = @as(u32, 47);
pub const CAL_ITWODIGITYEARMAX = @as(u32, 48);
pub const CAL_SSHORTESTDAYNAME1 = @as(u32, 49);
pub const CAL_SSHORTESTDAYNAME2 = @as(u32, 50);
pub const CAL_SSHORTESTDAYNAME3 = @as(u32, 51);
pub const CAL_SSHORTESTDAYNAME4 = @as(u32, 52);
pub const CAL_SSHORTESTDAYNAME5 = @as(u32, 53);
pub const CAL_SSHORTESTDAYNAME6 = @as(u32, 54);
pub const CAL_SSHORTESTDAYNAME7 = @as(u32, 55);
pub const CAL_SMONTHDAY = @as(u32, 56);
pub const CAL_SABBREVERASTRING = @as(u32, 57);
pub const CAL_SRELATIVELONGDATE = @as(u32, 58);
pub const CAL_SENGLISHERANAME = @as(u32, 59);
pub const CAL_SENGLISHABBREVERANAME = @as(u32, 60);
pub const CAL_SJAPANESEERAFIRSTYEAR = @as(u32, 61);
pub const ENUM_ALL_CALENDARS = @as(u32, 4294967295);
pub const CAL_GREGORIAN = @as(u32, 1);
pub const CAL_GREGORIAN_US = @as(u32, 2);
pub const CAL_JAPAN = @as(u32, 3);
pub const CAL_TAIWAN = @as(u32, 4);
pub const CAL_KOREA = @as(u32, 5);
pub const CAL_HIJRI = @as(u32, 6);
pub const CAL_THAI = @as(u32, 7);
pub const CAL_HEBREW = @as(u32, 8);
pub const CAL_GREGORIAN_ME_FRENCH = @as(u32, 9);
pub const CAL_GREGORIAN_ARABIC = @as(u32, 10);
pub const CAL_GREGORIAN_XLIT_ENGLISH = @as(u32, 11);
pub const CAL_GREGORIAN_XLIT_FRENCH = @as(u32, 12);
pub const CAL_PERSIAN = @as(u32, 22);
pub const CAL_UMALQURA = @as(u32, 23);
pub const LGRPID_WESTERN_EUROPE = @as(u32, 1);
pub const LGRPID_CENTRAL_EUROPE = @as(u32, 2);
pub const LGRPID_BALTIC = @as(u32, 3);
pub const LGRPID_GREEK = @as(u32, 4);
pub const LGRPID_CYRILLIC = @as(u32, 5);
pub const LGRPID_TURKIC = @as(u32, 6);
pub const LGRPID_TURKISH = @as(u32, 6);
pub const LGRPID_JAPANESE = @as(u32, 7);
pub const LGRPID_KOREAN = @as(u32, 8);
pub const LGRPID_TRADITIONAL_CHINESE = @as(u32, 9);
pub const LGRPID_SIMPLIFIED_CHINESE = @as(u32, 10);
pub const LGRPID_THAI = @as(u32, 11);
pub const LGRPID_HEBREW = @as(u32, 12);
pub const LGRPID_ARABIC = @as(u32, 13);
pub const LGRPID_VIETNAMESE = @as(u32, 14);
pub const LGRPID_INDIC = @as(u32, 15);
pub const LGRPID_GEORGIAN = @as(u32, 16);
pub const LGRPID_ARMENIAN = @as(u32, 17);
pub const MUI_LANGUAGE_ID = @as(u32, 4);
pub const MUI_LANGUAGE_NAME = @as(u32, 8);
pub const MUI_MERGE_SYSTEM_FALLBACK = @as(u32, 16);
pub const MUI_MERGE_USER_FALLBACK = @as(u32, 32);
pub const MUI_THREAD_LANGUAGES = @as(u32, 64);
pub const MUI_CONSOLE_FILTER = @as(u32, 256);
pub const MUI_COMPLEX_SCRIPT_FILTER = @as(u32, 512);
pub const MUI_RESET_FILTERS = @as(u32, 1);
pub const MUI_USER_PREFERRED_UI_LANGUAGES = @as(u32, 16);
pub const MUI_USE_INSTALLED_LANGUAGES = @as(u32, 32);
pub const MUI_USE_SEARCH_ALL_LANGUAGES = @as(u32, 64);
pub const MUI_LANG_NEUTRAL_PE_FILE = @as(u32, 256);
pub const MUI_NON_LANG_NEUTRAL_FILE = @as(u32, 512);
pub const MUI_MACHINE_LANGUAGE_SETTINGS = @as(u32, 1024);
pub const MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL = @as(u32, 1);
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN = @as(u32, 2);
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI = @as(u32, 4);
pub const MUI_QUERY_TYPE = @as(u32, 1);
pub const MUI_QUERY_CHECKSUM = @as(u32, 2);
pub const MUI_QUERY_LANGUAGE_NAME = @as(u32, 4);
pub const MUI_QUERY_RESOURCE_TYPES = @as(u32, 8);
pub const MUI_FILEINFO_VERSION = @as(u32, 1);
pub const MUI_FULL_LANGUAGE = @as(u32, 1);
pub const MUI_PARTIAL_LANGUAGE = @as(u32, 2);
pub const MUI_LIP_LANGUAGE = @as(u32, 4);
pub const MUI_LANGUAGE_INSTALLED = @as(u32, 32);
pub const MUI_LANGUAGE_LICENSED = @as(u32, 64);
pub const GEOID_NOT_AVAILABLE = @as(i32, -1);
pub const SORTING_PARADIGM_NLS = @as(u32, 0);
pub const SORTING_PARADIGM_ICU = @as(u32, 16777216);
pub const IDN_ALLOW_UNASSIGNED = @as(u32, 1);
pub const IDN_USE_STD3_ASCII_RULES = @as(u32, 2);
pub const IDN_EMAIL_ADDRESS = @as(u32, 4);
pub const IDN_RAW_PUNYCODE = @as(u32, 8);
pub const VS_ALLOW_LATIN = @as(u32, 1);
pub const GSS_ALLOW_INHERITED_COMMON = @as(u32, 1);
pub const MUI_FORMAT_REG_COMPAT = @as(u32, 1);
pub const MUI_FORMAT_INF_COMPAT = @as(u32, 2);
pub const MUI_VERIFY_FILE_EXISTS = @as(u32, 4);
pub const MUI_SKIP_STRING_CACHE = @as(u32, 8);
pub const MUI_IMMUTABLE_LOOKUP = @as(u32, 16);
pub const LOCALE_NAME_INVARIANT = null;
pub const LOCALE_NAME_SYSTEM_DEFAULT = "!x-sys-default-locale";
pub const MIN_SPELLING_NTDDI = @as(u32, 100794368);
pub const SCRIPT_UNDEFINED = @as(u32, 0);
pub const USP_E_SCRIPT_NOT_IN_FONT = @import("zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const SGCM_RTL = @as(u32, 1);
pub const SSA_PASSWORD = @as(u32, 1);
pub const SSA_TAB = @as(u32, 2);
pub const SSA_CLIP = @as(u32, 4);
pub const SSA_FIT = @as(u32, 8);
pub const SSA_DZWG = @as(u32, 16);
pub const SSA_FALLBACK = @as(u32, 32);
pub const SSA_BREAK = @as(u32, 64);
pub const SSA_GLYPHS = @as(u32, 128);
pub const SSA_RTL = @as(u32, 256);
pub const SSA_GCP = @as(u32, 512);
pub const SSA_HOTKEY = @as(u32, 1024);
pub const SSA_METAFILE = @as(u32, 2048);
pub const SSA_LINK = @as(u32, 4096);
pub const SSA_HIDEHOTKEY = @as(u32, 8192);
pub const SSA_HOTKEYONLY = @as(u32, 9216);
pub const SSA_FULLMEASURE = @as(u32, 67108864);
pub const SSA_LPKANSIFALLBACK = @as(u32, 134217728);
pub const SSA_PIDX = @as(u32, 268435456);
pub const SSA_LAYOUTRTL = @as(u32, 536870912);
pub const SSA_DONTGLYPH = @as(u32, 1073741824);
pub const SSA_NOKASHIDA = @as(u32, 2147483648);
pub const SCRIPT_DIGITSUBSTITUTE_CONTEXT = @as(u32, 0);
pub const SCRIPT_DIGITSUBSTITUTE_NONE = @as(u32, 1);
pub const SCRIPT_DIGITSUBSTITUTE_NATIONAL = @as(u32, 2);
pub const SCRIPT_DIGITSUBSTITUTE_TRADITIONAL = @as(u32, 3);
pub const UNISCRIBE_OPENTYPE = @as(u32, 256);
pub const SCRIPT_TAG_UNKNOWN = @as(u32, 0);
pub const MUI_LANGUAGE_EXACT = @as(u32, 16);
pub const NLS_CP_CPINFO = @as(u32, 268435456);
pub const NLS_CP_MBTOWC = @as(u32, 1073741824);
pub const NLS_CP_WCTOMB = @as(u32, 2147483648);
pub const U_DISABLE_RENAMING = @as(u32, 1);
pub const U_SHOW_CPLUSPLUS_API = @as(u32, 0);
pub const U_DEFAULT_SHOW_DRAFT = @as(u32, 0);
pub const U_HIDE_DRAFT_API = @as(u32, 1);
pub const U_HIDE_DEPRECATED_API = @as(u32, 1);
pub const U_HIDE_OBSOLETE_API = @as(u32, 1);
pub const U_HIDE_INTERNAL_API = @as(u32, 1);
pub const U_NO_DEFAULT_INCLUDE_UTF_HEADERS = @as(u32, 1);
pub const U_DEBUG = @as(u32, 1);
pub const UCLN_NO_AUTO_CLEANUP = @as(u32, 1);
pub const U_OVERRIDE_CXX_ALLOCATION = @as(u32, 1);
pub const U_ENABLE_TRACING = @as(u32, 0);
pub const UCONFIG_ENABLE_PLUGINS = @as(u32, 0);
pub const U_ENABLE_DYLOAD = @as(u32, 1);
pub const U_CHECK_DYLOAD = @as(u32, 1);
pub const U_HAVE_LIB_SUFFIX = @as(u32, 1);
pub const U_LIB_SUFFIX_C_NAME_STRING = null;
pub const UCONFIG_ONLY_COLLATION = @as(u32, 0);
pub const UCONFIG_NO_BREAK_ITERATION = @as(u32, 1);
pub const UCONFIG_NO_IDNA = @as(u32, 1);
pub const UCONFIG_NO_FORMATTING = @as(u32, 1);
pub const UCONFIG_NO_TRANSLITERATION = @as(u32, 1);
pub const UCONFIG_NO_REGULAR_EXPRESSIONS = @as(u32, 1);
pub const UCONFIG_NO_FILE_IO = @as(u32, 0);
pub const UCONFIG_NO_CONVERSION = @as(u32, 0);
pub const UCONFIG_NO_LEGACY_CONVERSION = @as(u32, 1);
pub const UCONFIG_ONLY_HTML_CONVERSION = @as(u32, 0);
pub const UCONFIG_NO_NORMALIZATION = @as(u32, 0);
pub const UCONFIG_NO_COLLATION = @as(u32, 1);
pub const UCONFIG_NO_SERVICE = @as(u32, 0);
pub const UCONFIG_HAVE_PARSEALLINPUT = @as(u32, 1);
pub const UCONFIG_NO_FILTERED_BREAK_ITERATION = @as(u32, 0);
pub const U_PF_UNKNOWN = @as(u32, 0);
pub const U_PF_WINDOWS = @as(u32, 1000);
pub const U_PF_MINGW = @as(u32, 1800);
pub const U_PF_CYGWIN = @as(u32, 1900);
pub const U_PF_HPUX = @as(u32, 2100);
pub const U_PF_SOLARIS = @as(u32, 2600);
pub const U_PF_BSD = @as(u32, 3000);
pub const U_PF_AIX = @as(u32, 3100);
pub const U_PF_IRIX = @as(u32, 3200);
pub const U_PF_DARWIN = @as(u32, 3500);
pub const U_PF_IPHONE = @as(u32, 3550);
pub const U_PF_QNX = @as(u32, 3700);
pub const U_PF_LINUX = @as(u32, 4000);
pub const U_PF_BROWSER_NATIVE_CLIENT = @as(u32, 4020);
pub const U_PF_ANDROID = @as(u32, 4050);
pub const U_PF_FUCHSIA = @as(u32, 4100);
pub const U_PF_EMSCRIPTEN = @as(u32, 5010);
pub const U_PF_OS390 = @as(u32, 9000);
pub const U_PF_OS400 = @as(u32, 9400);
pub const U_PLATFORM = @as(u32, 1800);
pub const U_PLATFORM_USES_ONLY_WIN32_API = @as(u32, 1);
pub const U_PLATFORM_HAS_WIN32_API = @as(u32, 1);
pub const U_PLATFORM_IMPLEMENTS_POSIX = @as(u32, 0);
pub const U_PLATFORM_IS_LINUX_BASED = @as(u32, 1);
pub const U_PLATFORM_IS_DARWIN_BASED = @as(u32, 1);
pub const U_HAVE_STDINT_H = @as(u32, 1);
pub const U_HAVE_INTTYPES_H = @as(u32, 1);
pub const U_GCC_MAJOR_MINOR = @as(u32, 0);
pub const U_IS_BIG_ENDIAN = @as(u32, 0);
pub const U_HAVE_PLACEMENT_NEW = @as(u32, 0);
pub const U_HAVE_DEBUG_LOCATION_NEW = @as(u32, 1);
pub const U_CPLUSPLUS_VERSION = @as(u32, 0);
pub const U_ASCII_FAMILY = @as(u32, 0);
pub const U_EBCDIC_FAMILY = @as(u32, 1);
pub const U_CHARSET_FAMILY = @as(u32, 1);
pub const U_CHARSET_IS_UTF8 = @as(u32, 1);
pub const U_HAVE_WCHAR_H = @as(u32, 0);
pub const U_SIZEOF_WCHAR_T = @as(u32, 1);
pub const U_HAVE_WCSCPY = @as(u32, 0);
pub const U_HAVE_CHAR16_T = @as(u32, 1);
pub const U_DEFINE_FALSE_AND_TRUE = @as(u32, 1);
pub const U_SIZEOF_UCHAR = @as(u32, 2);
pub const U_CHAR16_IS_TYPEDEF = @as(u32, 1);
pub const U_SENTINEL = @as(i32, -1);
pub const U8_LEAD3_T1_BITS = " 000000000000\x1000";
pub const U8_LEAD4_T1_BITS = "\x00\x00\x00\x00\x00\x00\x00\x00\x1e\x0f\x0f\x0f\x00\x00\x00\x00";
pub const U8_MAX_LENGTH = @as(u32, 4);
pub const U16_MAX_LENGTH = @as(u32, 2);
pub const U_HIDE_OBSOLETE_UTF_OLD_H = @as(u32, 0);
pub const UTF_SIZE = @as(u32, 16);
pub const UTF8_ERROR_VALUE_1 = @as(u32, 21);
pub const UTF8_ERROR_VALUE_2 = @as(u32, 159);
pub const UTF_ERROR_VALUE = @as(u32, 65535);
pub const UTF8_MAX_CHAR_LENGTH = @as(u32, 4);
pub const UTF16_MAX_CHAR_LENGTH = @as(u32, 2);
pub const UTF32_MAX_CHAR_LENGTH = @as(u32, 1);
pub const UTF_MAX_CHAR_LENGTH = @as(u32, 2);
pub const U_COPYRIGHT_STRING_LENGTH = @as(u32, 128);
pub const U_MAX_VERSION_LENGTH = @as(u32, 4);
pub const U_MAX_VERSION_STRING_LENGTH = @as(u32, 20);
pub const U_MILLIS_PER_SECOND = @as(u32, 1000);
pub const U_MILLIS_PER_MINUTE = @as(u32, 60000);
pub const U_MILLIS_PER_HOUR = @as(u32, 3600000);
pub const U_MILLIS_PER_DAY = @as(u32, 86400000);
pub const U_COMBINED_IMPLEMENTATION = @as(u32, 1);
pub const U_SHAPE_LENGTH_GROW_SHRINK = @as(u32, 0);
pub const U_SHAPE_LAMALEF_RESIZE = @as(u32, 0);
pub const U_SHAPE_LENGTH_FIXED_SPACES_NEAR = @as(u32, 1);
pub const U_SHAPE_LAMALEF_NEAR = @as(u32, 1);
pub const U_SHAPE_LENGTH_FIXED_SPACES_AT_END = @as(u32, 2);
pub const U_SHAPE_LAMALEF_END = @as(u32, 2);
pub const U_SHAPE_LENGTH_FIXED_SPACES_AT_BEGINNING = @as(u32, 3);
pub const U_SHAPE_LAMALEF_BEGIN = @as(u32, 3);
pub const U_SHAPE_LAMALEF_AUTO = @as(u32, 65536);
pub const U_SHAPE_LENGTH_MASK = @as(u32, 65539);
pub const U_SHAPE_LAMALEF_MASK = @as(u32, 65539);
pub const U_SHAPE_TEXT_DIRECTION_LOGICAL = @as(u32, 0);
pub const U_SHAPE_TEXT_DIRECTION_VISUAL_RTL = @as(u32, 0);
pub const U_SHAPE_TEXT_DIRECTION_VISUAL_LTR = @as(u32, 4);
pub const U_SHAPE_TEXT_DIRECTION_MASK = @as(u32, 4);
pub const U_SHAPE_LETTERS_NOOP = @as(u32, 0);
pub const U_SHAPE_LETTERS_SHAPE = @as(u32, 8);
pub const U_SHAPE_LETTERS_UNSHAPE = @as(u32, 16);
pub const U_SHAPE_LETTERS_SHAPE_TASHKEEL_ISOLATED = @as(u32, 24);
pub const U_SHAPE_LETTERS_MASK = @as(u32, 24);
pub const U_SHAPE_DIGITS_NOOP = @as(u32, 0);
pub const U_SHAPE_DIGITS_EN2AN = @as(u32, 32);
pub const U_SHAPE_DIGITS_AN2EN = @as(u32, 64);
pub const U_SHAPE_DIGITS_ALEN2AN_INIT_LR = @as(u32, 96);
pub const U_SHAPE_DIGITS_ALEN2AN_INIT_AL = @as(u32, 128);
pub const U_SHAPE_DIGITS_RESERVED = @as(u32, 160);
pub const U_SHAPE_DIGITS_MASK = @as(u32, 224);
pub const U_SHAPE_DIGIT_TYPE_AN = @as(u32, 0);
pub const U_SHAPE_DIGIT_TYPE_AN_EXTENDED = @as(u32, 256);
pub const U_SHAPE_DIGIT_TYPE_RESERVED = @as(u32, 512);
pub const U_SHAPE_DIGIT_TYPE_MASK = @as(u32, 768);
pub const U_SHAPE_AGGREGATE_TASHKEEL = @as(u32, 16384);
pub const U_SHAPE_AGGREGATE_TASHKEEL_NOOP = @as(u32, 0);
pub const U_SHAPE_AGGREGATE_TASHKEEL_MASK = @as(u32, 16384);
pub const U_SHAPE_PRESERVE_PRESENTATION = @as(u32, 32768);
pub const U_SHAPE_PRESERVE_PRESENTATION_NOOP = @as(u32, 0);
pub const U_SHAPE_PRESERVE_PRESENTATION_MASK = @as(u32, 32768);
pub const U_SHAPE_SEEN_TWOCELL_NEAR = @as(u32, 2097152);
pub const U_SHAPE_SEEN_MASK = @as(u32, 7340032);
pub const U_SHAPE_YEHHAMZA_TWOCELL_NEAR = @as(u32, 16777216);
pub const U_SHAPE_YEHHAMZA_MASK = @as(u32, 58720256);
pub const U_SHAPE_TASHKEEL_BEGIN = @as(u32, 262144);
pub const U_SHAPE_TASHKEEL_END = @as(u32, 393216);
pub const U_SHAPE_TASHKEEL_RESIZE = @as(u32, 524288);
pub const U_SHAPE_TASHKEEL_REPLACE_BY_TATWEEL = @as(u32, 786432);
pub const U_SHAPE_TASHKEEL_MASK = @as(u32, 917504);
pub const U_SHAPE_SPACES_RELATIVE_TO_TEXT_BEGIN_END = @as(u32, 67108864);
pub const U_SHAPE_SPACES_RELATIVE_TO_TEXT_MASK = @as(u32, 67108864);
pub const U_SHAPE_TAIL_NEW_UNICODE = @as(u32, 134217728);
pub const U_SHAPE_TAIL_TYPE_MASK = @as(u32, 134217728);
pub const ULOC_CHINESE = "zh";
pub const ULOC_ENGLISH = "en";
pub const ULOC_FRENCH = "fr";
pub const ULOC_GERMAN = "de";
pub const ULOC_ITALIAN = "it";
pub const ULOC_JAPANESE = "ja";
pub const ULOC_KOREAN = "ko";
pub const ULOC_SIMPLIFIED_CHINESE = "zh_CN";
pub const ULOC_TRADITIONAL_CHINESE = "zh_TW";
pub const ULOC_CANADA = "en_CA";
pub const ULOC_CANADA_FRENCH = "fr_CA";
pub const ULOC_CHINA = "zh_CN";
pub const ULOC_PRC = "zh_CN";
pub const ULOC_FRANCE = "fr_FR";
pub const ULOC_GERMANY = "de_DE";
pub const ULOC_ITALY = "it_IT";
pub const ULOC_JAPAN = "ja_JP";
pub const ULOC_KOREA = "ko_KR";
pub const ULOC_TAIWAN = "zh_TW";
pub const ULOC_UK = "en_GB";
pub const ULOC_US = "en_US";
pub const ULOC_LANG_CAPACITY = @as(u32, 12);
pub const ULOC_COUNTRY_CAPACITY = @as(u32, 4);
pub const ULOC_FULLNAME_CAPACITY = @as(u32, 157);
pub const ULOC_SCRIPT_CAPACITY = @as(u32, 6);
pub const ULOC_KEYWORDS_CAPACITY = @as(u32, 96);
pub const ULOC_KEYWORD_AND_VALUES_CAPACITY = @as(u32, 100);
pub const ULOC_KEYWORD_SEPARATOR_UNICODE = @as(u32, 64);
pub const ULOC_KEYWORD_ASSIGN_UNICODE = @as(u32, 61);
pub const ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE = @as(u32, 59);
pub const UCNV_SUB_STOP_ON_ILLEGAL = "i";
pub const UCNV_SKIP_STOP_ON_ILLEGAL = "i";
pub const UCNV_ESCAPE_JAVA = "J";
pub const UCNV_ESCAPE_C = "C";
pub const UCNV_ESCAPE_XML_DEC = "D";
pub const UCNV_ESCAPE_XML_HEX = "X";
pub const UCNV_ESCAPE_UNICODE = "U";
pub const UCNV_ESCAPE_CSS2 = "S";
pub const UCNV_MAX_CONVERTER_NAME_LENGTH = @as(u32, 60);
pub const UCNV_SI = @as(u32, 15);
pub const UCNV_SO = @as(u32, 14);
pub const UCNV_OPTION_SEP_STRING = ",";
pub const UCNV_VALUE_SEP_STRING = "=";
pub const UCNV_LOCALE_OPTION_STRING = ",locale=";
pub const UCNV_VERSION_OPTION_STRING = ",version=";
pub const UCNV_SWAP_LFNL_OPTION_STRING = ",swaplfnl";
pub const U_FOLD_CASE_DEFAULT = @as(u32, 0);
pub const U_FOLD_CASE_EXCLUDE_SPECIAL_I = @as(u32, 1);
pub const U_TITLECASE_WHOLE_STRING = @as(u32, 32);
pub const U_TITLECASE_SENTENCES = @as(u32, 64);
pub const U_TITLECASE_NO_LOWERCASE = @as(u32, 256);
pub const U_TITLECASE_NO_BREAK_ADJUSTMENT = @as(u32, 512);
pub const U_TITLECASE_ADJUST_TO_CASED = @as(u32, 1024);
pub const U_EDITS_NO_RESET = @as(u32, 8192);
pub const U_OMIT_UNCHANGED_TEXT = @as(u32, 16384);
pub const U_COMPARE_CODE_POINT_ORDER = @as(u32, 32768);
pub const U_COMPARE_IGNORE_CASE = @as(u32, 65536);
pub const UNORM_INPUT_IS_FCD = @as(u32, 131072);
pub const UCHAR_MIN_VALUE = @as(u32, 0);
pub const UCHAR_MAX_VALUE = @as(u32, 1114111);
pub const UBIDI_DEFAULT_LTR = @as(u32, 254);
pub const UBIDI_DEFAULT_RTL = @as(u32, 255);
pub const UBIDI_MAX_EXPLICIT_LEVEL = @as(u32, 125);
pub const UBIDI_LEVEL_OVERRIDE = @as(u32, 128);
pub const UBIDI_MAP_NOWHERE = @as(i32, -1);
pub const UBIDI_KEEP_BASE_COMBINING = @as(u32, 1);
pub const UBIDI_DO_MIRRORING = @as(u32, 2);
pub const UBIDI_INSERT_LRM_FOR_NUMERIC = @as(u32, 4);
pub const UBIDI_REMOVE_BIDI_CONTROLS = @as(u32, 8);
pub const UBIDI_OUTPUT_REVERSE = @as(u32, 16);
pub const USPREP_DEFAULT = @as(u32, 0);
pub const USPREP_ALLOW_UNASSIGNED = @as(u32, 1);
pub const U_ICU_VERSION_BUNDLE = "icuver";
pub const U_ICU_DATA_KEY = "DataVersion";
pub const UCAL_UNKNOWN_ZONE_ID = "Etc/Unknown";
pub const UDAT_YEAR = "y";
pub const UDAT_QUARTER = "QQQQ";
pub const UDAT_ABBR_QUARTER = "QQQ";
pub const UDAT_YEAR_QUARTER = "yQQQQ";
pub const UDAT_YEAR_ABBR_QUARTER = "yQQQ";
pub const UDAT_MONTH = "MMMM";
pub const UDAT_ABBR_MONTH = "MMM";
pub const UDAT_NUM_MONTH = "M";
pub const UDAT_YEAR_MONTH = "yMMMM";
pub const UDAT_YEAR_ABBR_MONTH = "yMMM";
pub const UDAT_YEAR_NUM_MONTH = "yM";
pub const UDAT_DAY = "d";
pub const UDAT_YEAR_MONTH_DAY = "yMMMMd";
pub const UDAT_YEAR_ABBR_MONTH_DAY = "yMMMd";
pub const UDAT_YEAR_NUM_MONTH_DAY = "yMd";
pub const UDAT_WEEKDAY = "EEEE";
pub const UDAT_ABBR_WEEKDAY = "E";
pub const UDAT_YEAR_MONTH_WEEKDAY_DAY = "yMMMMEEEEd";
pub const UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY = "yMMMEd";
pub const UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY = "yMEd";
pub const UDAT_MONTH_DAY = "MMMMd";
pub const UDAT_ABBR_MONTH_DAY = "MMMd";
pub const UDAT_NUM_MONTH_DAY = "Md";
pub const UDAT_MONTH_WEEKDAY_DAY = "MMMMEEEEd";
pub const UDAT_ABBR_MONTH_WEEKDAY_DAY = "MMMEd";
pub const UDAT_NUM_MONTH_WEEKDAY_DAY = "MEd";
pub const UDAT_HOUR = "j";
pub const UDAT_HOUR24 = "H";
pub const UDAT_MINUTE = "m";
pub const UDAT_HOUR_MINUTE = "jm";
pub const UDAT_HOUR24_MINUTE = "Hm";
pub const UDAT_SECOND = "s";
pub const UDAT_HOUR_MINUTE_SECOND = "jms";
pub const UDAT_HOUR24_MINUTE_SECOND = "Hms";
pub const UDAT_MINUTE_SECOND = "ms";
pub const UDAT_LOCATION_TZ = "VVVV";
pub const UDAT_GENERIC_TZ = "vvvv";
pub const UDAT_ABBR_GENERIC_TZ = "v";
pub const UDAT_SPECIFIC_TZ = "zzzz";
pub const UDAT_ABBR_SPECIFIC_TZ = "z";
pub const UDAT_ABBR_UTC_TZ = "ZZZZ";
pub const USEARCH_DONE = @as(i32, -1);
pub const U_HAVE_STD_STRING = @as(u32, 0);
pub const UCONFIG_FORMAT_FASTPATHS_49 = @as(u32, 1);
pub const U_PLATFORM_HAS_WINUWP_API = @as(u32, 0);
pub const U_IOSTREAM_SOURCE = @as(u32, 199711);
pub const U_HAVE_RVALUE_REFERENCES = @as(u32, 1);
pub const U_USING_ICU_NAMESPACE = @as(u32, 1);
pub const U_ICUDATA_TYPE_LETTER = "e";
pub const U_UNICODE_VERSION = "8.0";
pub const CANITER_SKIP_ZEROES = @as(u32, 1);
pub const NUMSYS_NAME_CAPACITY = @as(u32, 8);
pub const U_HAVE_RBNF = @as(u32, 0);
pub const IME_CMODE_ALPHANUMERIC = @as(u32, 0);
pub const IME_CMODE_NATIVE = @as(u32, 1);
pub const IME_CMODE_CHINESE = @as(u32, 1);
pub const IME_CMODE_HANGUL = @as(u32, 1);
pub const IME_CMODE_JAPANESE = @as(u32, 1);
pub const IME_CMODE_KATAKANA = @as(u32, 2);
pub const IME_CMODE_LANGUAGE = @as(u32, 3);
pub const IME_CMODE_FULLSHAPE = @as(u32, 8);
pub const IME_CMODE_ROMAN = @as(u32, 16);
pub const IME_CMODE_CHARCODE = @as(u32, 32);
pub const IME_CMODE_HANJACONVERT = @as(u32, 64);
pub const IME_CMODE_NATIVESYMBOL = @as(u32, 128);
pub const MAX_MIMECP_NAME = @as(u32, 64);
pub const MAX_MIMECSET_NAME = @as(u32, 50);
pub const MAX_MIMEFACE_NAME = @as(u32, 32);
pub const MAX_RFC1766_NAME = @as(u32, 6);
pub const MAX_LOCALE_NAME = @as(u32, 32);
pub const MAX_SCRIPT_NAME = @as(u32, 48);
pub const CPIOD_PEEK = @as(i32, 1073741824);
pub const CPIOD_FORCE_PROMPT = @as(i32, -2147483648);
pub const UITER_UNKNOWN_INDEX = @as(i32, -2);
pub const UCPTRIE_FAST_SHIFT = @as(i32, 6);
pub const UCPTRIE_FAST_DATA_BLOCK_LENGTH = @as(i32, 64);
pub const UCPTRIE_FAST_DATA_MASK = @as(i32, 63);
pub const UCPTRIE_SMALL_MAX = @as(i32, 4095);
pub const UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET = @as(i32, 1);
pub const UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET = @as(i32, 2);
pub const UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE = @as(i32, 1);
pub const UTEXT_PROVIDER_STABLE_CHUNKS = @as(i32, 2);
pub const UTEXT_PROVIDER_WRITABLE = @as(i32, 3);
pub const UTEXT_PROVIDER_HAS_META_DATA = @as(i32, 4);
pub const UTEXT_PROVIDER_OWNS_TEXT = @as(i32, 5);
pub const UTEXT_MAGIC = @as(i32, 878368812);
pub const USET_IGNORE_SPACE = @as(i32, 1);
pub const USET_CASE_INSENSITIVE = @as(i32, 2);
pub const USET_ADD_CASE_MAPPINGS = @as(i32, 4);
pub const USET_SERIALIZED_STATIC_ARRAY_CAPACITY = @as(i32, 8);
pub const U_PARSE_CONTEXT_LEN = @as(i32, 16);
pub const UIDNA_DEFAULT = @as(i32, 0);
pub const UIDNA_USE_STD3_RULES = @as(i32, 2);
pub const UIDNA_CHECK_BIDI = @as(i32, 4);
pub const UIDNA_CHECK_CONTEXTJ = @as(i32, 8);
pub const UIDNA_NONTRANSITIONAL_TO_ASCII = @as(i32, 16);
pub const UIDNA_NONTRANSITIONAL_TO_UNICODE = @as(i32, 32);
pub const UIDNA_CHECK_CONTEXTO = @as(i32, 64);
pub const UIDNA_ERROR_EMPTY_LABEL = @as(i32, 1);
pub const UIDNA_ERROR_LABEL_TOO_LONG = @as(i32, 2);
pub const UIDNA_ERROR_DOMAIN_NAME_TOO_LONG = @as(i32, 4);
pub const UIDNA_ERROR_LEADING_HYPHEN = @as(i32, 8);
pub const UIDNA_ERROR_TRAILING_HYPHEN = @as(i32, 16);
pub const UIDNA_ERROR_HYPHEN_3_4 = @as(i32, 32);
pub const UIDNA_ERROR_LEADING_COMBINING_MARK = @as(i32, 64);
pub const UIDNA_ERROR_DISALLOWED = @as(i32, 128);
pub const UIDNA_ERROR_PUNYCODE = @as(i32, 256);
pub const UIDNA_ERROR_LABEL_HAS_DOT = @as(i32, 512);
pub const UIDNA_ERROR_INVALID_ACE_LABEL = @as(i32, 1024);
pub const UIDNA_ERROR_BIDI = @as(i32, 2048);
pub const UIDNA_ERROR_CONTEXTJ = @as(i32, 4096);
pub const UIDNA_ERROR_CONTEXTO_PUNCTUATION = @as(i32, 8192);
pub const UIDNA_ERROR_CONTEXTO_DIGITS = @as(i32, 16384);
pub const ELS_GUID_LANGUAGE_DETECTION = Guid.initString("cf7e00b1-909b-4d95-a8f4-611f7c377702");
pub const ELS_GUID_SCRIPT_DETECTION = Guid.initString("2d64b439-6caf-4f6b-b688-e5d0f4faa7d7");
pub const ELS_GUID_TRANSLITERATION_HANT_TO_HANS = Guid.initString("a3a8333b-f4fc-42f6-a0c4-0462fe7317cb");
pub const ELS_GUID_TRANSLITERATION_HANS_TO_HANT = Guid.initString("3caccdc8-5590-42dc-9a7b-b5a6b5b3b63b");
pub const ELS_GUID_TRANSLITERATION_MALAYALAM_TO_LATIN = Guid.initString("d8b983b1-f8bf-4a2b-bcd5-5b5ea20613e1");
pub const ELS_GUID_TRANSLITERATION_DEVANAGARI_TO_LATIN = Guid.initString("c4a4dcfe-2661-4d02-9835-f48187109803");
pub const ELS_GUID_TRANSLITERATION_CYRILLIC_TO_LATIN = Guid.initString("3dd12a98-5afd-4903-a13f-e17e6c0bfe01");
pub const ELS_GUID_TRANSLITERATION_BENGALI_TO_LATIN = Guid.initString("f4dfd825-91a4-489f-855e-9ad9bee55727");
pub const ELS_GUID_TRANSLITERATION_HANGUL_DECOMPOSITION = Guid.initString("4ba2a721-e43d-41b7-b330-536ae1e48863");
pub const UMSGPAT_ARG_NAME_NOT_NUMBER = @as(i32, -1);
pub const UMSGPAT_ARG_NAME_NOT_VALID = @as(i32, -2);

//--------------------------------------------------------------------------------
// Section: Types (359)
//--------------------------------------------------------------------------------
pub const FOLD_STRING_MAP_FLAGS = enum(u32) {
    COMPOSITE = 64,
    EXPAND_LIGATURES = 8192,
    FOLDCZONE = 16,
    FOLDDIGITS = 128,
    PRECOMPOSED = 32,
    _,
    pub fn initFlags(o: struct {
        COMPOSITE: u1 = 0,
        EXPAND_LIGATURES: u1 = 0,
        FOLDCZONE: u1 = 0,
        FOLDDIGITS: u1 = 0,
        PRECOMPOSED: u1 = 0,
    }) FOLD_STRING_MAP_FLAGS {
        return @as(FOLD_STRING_MAP_FLAGS, @enumFromInt((if (o.COMPOSITE == 1) @intFromEnum(FOLD_STRING_MAP_FLAGS.COMPOSITE) else 0) | (if (o.EXPAND_LIGATURES == 1) @intFromEnum(FOLD_STRING_MAP_FLAGS.EXPAND_LIGATURES) else 0) | (if (o.FOLDCZONE == 1) @intFromEnum(FOLD_STRING_MAP_FLAGS.FOLDCZONE) else 0) | (if (o.FOLDDIGITS == 1) @intFromEnum(FOLD_STRING_MAP_FLAGS.FOLDDIGITS) else 0) | (if (o.PRECOMPOSED == 1) @intFromEnum(FOLD_STRING_MAP_FLAGS.PRECOMPOSED) else 0)));
    }
};
pub const MAP_COMPOSITE = FOLD_STRING_MAP_FLAGS.COMPOSITE;
pub const MAP_EXPAND_LIGATURES = FOLD_STRING_MAP_FLAGS.EXPAND_LIGATURES;
pub const MAP_FOLDCZONE = FOLD_STRING_MAP_FLAGS.FOLDCZONE;
pub const MAP_FOLDDIGITS = FOLD_STRING_MAP_FLAGS.FOLDDIGITS;
pub const MAP_PRECOMPOSED = FOLD_STRING_MAP_FLAGS.PRECOMPOSED;

pub const ENUM_DATE_FORMATS_FLAGS = enum(u32) {
    SHORTDATE = 1,
    LONGDATE = 2,
    YEARMONTH = 8,
    MONTHDAY = 128,
    AUTOLAYOUT = 64,
    LTRREADING = 16,
    RTLREADING = 32,
    USE_ALT_CALENDAR = 4,
};
pub const DATE_SHORTDATE = ENUM_DATE_FORMATS_FLAGS.SHORTDATE;
pub const DATE_LONGDATE = ENUM_DATE_FORMATS_FLAGS.LONGDATE;
pub const DATE_YEARMONTH = ENUM_DATE_FORMATS_FLAGS.YEARMONTH;
pub const DATE_MONTHDAY = ENUM_DATE_FORMATS_FLAGS.MONTHDAY;
pub const DATE_AUTOLAYOUT = ENUM_DATE_FORMATS_FLAGS.AUTOLAYOUT;
pub const DATE_LTRREADING = ENUM_DATE_FORMATS_FLAGS.LTRREADING;
pub const DATE_RTLREADING = ENUM_DATE_FORMATS_FLAGS.RTLREADING;
pub const DATE_USE_ALT_CALENDAR = ENUM_DATE_FORMATS_FLAGS.USE_ALT_CALENDAR;

pub const TRANSLATE_CHARSET_INFO_FLAGS = enum(u32) {
    CHARSET = 1,
    CODEPAGE = 2,
    FONTSIG = 3,
    LOCALE = 4096,
};
pub const TCI_SRCCHARSET = TRANSLATE_CHARSET_INFO_FLAGS.CHARSET;
pub const TCI_SRCCODEPAGE = TRANSLATE_CHARSET_INFO_FLAGS.CODEPAGE;
pub const TCI_SRCFONTSIG = TRANSLATE_CHARSET_INFO_FLAGS.FONTSIG;
pub const TCI_SRCLOCALE = TRANSLATE_CHARSET_INFO_FLAGS.LOCALE;

pub const TIME_FORMAT_FLAGS = enum(u32) {
    NOMINUTESORSECONDS = 1,
    NOSECONDS = 2,
    NOTIMEMARKER = 4,
    FORCE24HOURFORMAT = 8,
    _,
    pub fn initFlags(o: struct {
        NOMINUTESORSECONDS: u1 = 0,
        NOSECONDS: u1 = 0,
        NOTIMEMARKER: u1 = 0,
        FORCE24HOURFORMAT: u1 = 0,
    }) TIME_FORMAT_FLAGS {
        return @as(TIME_FORMAT_FLAGS, @enumFromInt((if (o.NOMINUTESORSECONDS == 1) @intFromEnum(TIME_FORMAT_FLAGS.NOMINUTESORSECONDS) else 0) | (if (o.NOSECONDS == 1) @intFromEnum(TIME_FORMAT_FLAGS.NOSECONDS) else 0) | (if (o.NOTIMEMARKER == 1) @intFromEnum(TIME_FORMAT_FLAGS.NOTIMEMARKER) else 0) | (if (o.FORCE24HOURFORMAT == 1) @intFromEnum(TIME_FORMAT_FLAGS.FORCE24HOURFORMAT) else 0)));
    }
};
pub const TIME_NOMINUTESORSECONDS = TIME_FORMAT_FLAGS.NOMINUTESORSECONDS;
pub const TIME_NOSECONDS = TIME_FORMAT_FLAGS.NOSECONDS;
pub const TIME_NOTIMEMARKER = TIME_FORMAT_FLAGS.NOTIMEMARKER;
pub const TIME_FORCE24HOURFORMAT = TIME_FORMAT_FLAGS.FORCE24HOURFORMAT;

pub const ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const LGRPID_INSTALLED = ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS.INSTALLED;
pub const LGRPID_SUPPORTED = ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS.SUPPORTED;

pub const MULTI_BYTE_TO_WIDE_CHAR_FLAGS = enum(u32) {
    COMPOSITE = 2,
    ERR_INVALID_CHARS = 8,
    PRECOMPOSED = 1,
    USEGLYPHCHARS = 4,
    _,
    pub fn initFlags(o: struct {
        COMPOSITE: u1 = 0,
        ERR_INVALID_CHARS: u1 = 0,
        PRECOMPOSED: u1 = 0,
        USEGLYPHCHARS: u1 = 0,
    }) MULTI_BYTE_TO_WIDE_CHAR_FLAGS {
        return @as(MULTI_BYTE_TO_WIDE_CHAR_FLAGS, @enumFromInt((if (o.COMPOSITE == 1) @intFromEnum(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.COMPOSITE) else 0) | (if (o.ERR_INVALID_CHARS == 1) @intFromEnum(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.ERR_INVALID_CHARS) else 0) | (if (o.PRECOMPOSED == 1) @intFromEnum(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.PRECOMPOSED) else 0) | (if (o.USEGLYPHCHARS == 1) @intFromEnum(MULTI_BYTE_TO_WIDE_CHAR_FLAGS.USEGLYPHCHARS) else 0)));
    }
};
pub const MB_COMPOSITE = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.COMPOSITE;
pub const MB_ERR_INVALID_CHARS = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.ERR_INVALID_CHARS;
pub const MB_PRECOMPOSED = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.PRECOMPOSED;
pub const MB_USEGLYPHCHARS = MULTI_BYTE_TO_WIDE_CHAR_FLAGS.USEGLYPHCHARS;

pub const COMPARE_STRING_FLAGS = enum(u32) {
    LINGUISTIC_IGNORECASE = 16,
    LINGUISTIC_IGNOREDIACRITIC = 32,
    NORM_IGNORECASE = 1,
    NORM_IGNOREKANATYPE = 65536,
    NORM_IGNORENONSPACE = 2,
    NORM_IGNORESYMBOLS = 4,
    NORM_IGNOREWIDTH = 131072,
    NORM_LINGUISTIC_CASING = 134217728,
    SORT_DIGITSASNUMBERS = 8,
    SORT_STRINGSORT = 4096,
    _,
    pub fn initFlags(o: struct {
        LINGUISTIC_IGNORECASE: u1 = 0,
        LINGUISTIC_IGNOREDIACRITIC: u1 = 0,
        NORM_IGNORECASE: u1 = 0,
        NORM_IGNOREKANATYPE: u1 = 0,
        NORM_IGNORENONSPACE: u1 = 0,
        NORM_IGNORESYMBOLS: u1 = 0,
        NORM_IGNOREWIDTH: u1 = 0,
        NORM_LINGUISTIC_CASING: u1 = 0,
        SORT_DIGITSASNUMBERS: u1 = 0,
        SORT_STRINGSORT: u1 = 0,
    }) COMPARE_STRING_FLAGS {
        return @as(COMPARE_STRING_FLAGS, @enumFromInt((if (o.LINGUISTIC_IGNORECASE == 1) @intFromEnum(COMPARE_STRING_FLAGS.LINGUISTIC_IGNORECASE) else 0) | (if (o.LINGUISTIC_IGNOREDIACRITIC == 1) @intFromEnum(COMPARE_STRING_FLAGS.LINGUISTIC_IGNOREDIACRITIC) else 0) | (if (o.NORM_IGNORECASE == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_IGNORECASE) else 0) | (if (o.NORM_IGNOREKANATYPE == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_IGNOREKANATYPE) else 0) | (if (o.NORM_IGNORENONSPACE == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_IGNORENONSPACE) else 0) | (if (o.NORM_IGNORESYMBOLS == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_IGNORESYMBOLS) else 0) | (if (o.NORM_IGNOREWIDTH == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_IGNOREWIDTH) else 0) | (if (o.NORM_LINGUISTIC_CASING == 1) @intFromEnum(COMPARE_STRING_FLAGS.NORM_LINGUISTIC_CASING) else 0) | (if (o.SORT_DIGITSASNUMBERS == 1) @intFromEnum(COMPARE_STRING_FLAGS.SORT_DIGITSASNUMBERS) else 0) | (if (o.SORT_STRINGSORT == 1) @intFromEnum(COMPARE_STRING_FLAGS.SORT_STRINGSORT) else 0)));
    }
};
pub const LINGUISTIC_IGNORECASE = COMPARE_STRING_FLAGS.LINGUISTIC_IGNORECASE;
pub const LINGUISTIC_IGNOREDIACRITIC = COMPARE_STRING_FLAGS.LINGUISTIC_IGNOREDIACRITIC;
pub const NORM_IGNORECASE = COMPARE_STRING_FLAGS.NORM_IGNORECASE;
pub const NORM_IGNOREKANATYPE = COMPARE_STRING_FLAGS.NORM_IGNOREKANATYPE;
pub const NORM_IGNORENONSPACE = COMPARE_STRING_FLAGS.NORM_IGNORENONSPACE;
pub const NORM_IGNORESYMBOLS = COMPARE_STRING_FLAGS.NORM_IGNORESYMBOLS;
pub const NORM_IGNOREWIDTH = COMPARE_STRING_FLAGS.NORM_IGNOREWIDTH;
pub const NORM_LINGUISTIC_CASING = COMPARE_STRING_FLAGS.NORM_LINGUISTIC_CASING;
pub const SORT_DIGITSASNUMBERS = COMPARE_STRING_FLAGS.SORT_DIGITSASNUMBERS;
pub const SORT_STRINGSORT = COMPARE_STRING_FLAGS.SORT_STRINGSORT;

pub const IS_VALID_LOCALE_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const LCID_INSTALLED = IS_VALID_LOCALE_FLAGS.INSTALLED;
pub const LCID_SUPPORTED = IS_VALID_LOCALE_FLAGS.SUPPORTED;

pub const ENUM_SYSTEM_CODE_PAGES_FLAGS = enum(u32) {
    INSTALLED = 1,
    SUPPORTED = 2,
};
pub const CP_INSTALLED = ENUM_SYSTEM_CODE_PAGES_FLAGS.INSTALLED;
pub const CP_SUPPORTED = ENUM_SYSTEM_CODE_PAGES_FLAGS.SUPPORTED;

pub const SCRIPT_IS_COMPLEX_FLAGS = enum(u32) {
    ASCIIDIGIT = 2,
    COMPLEX = 1,
    NEUTRAL = 4,
};
pub const SIC_ASCIIDIGIT = SCRIPT_IS_COMPLEX_FLAGS.ASCIIDIGIT;
pub const SIC_COMPLEX = SCRIPT_IS_COMPLEX_FLAGS.COMPLEX;
pub const SIC_NEUTRAL = SCRIPT_IS_COMPLEX_FLAGS.NEUTRAL;

pub const IS_TEXT_UNICODE_RESULT = enum(u32) {
    ASCII16 = 1,
    REVERSE_ASCII16 = 16,
    STATISTICS = 2,
    REVERSE_STATISTICS = 32,
    CONTROLS = 4,
    REVERSE_CONTROLS = 64,
    SIGNATURE = 8,
    REVERSE_SIGNATURE = 128,
    ILLEGAL_CHARS = 256,
    ODD_LENGTH = 512,
    NULL_BYTES = 4096,
    UNICODE_MASK = 15,
    REVERSE_MASK = 240,
    NOT_UNICODE_MASK = 3840,
    NOT_ASCII_MASK = 61440,
    _,
    pub fn initFlags(o: struct {
        ASCII16: u1 = 0,
        REVERSE_ASCII16: u1 = 0,
        STATISTICS: u1 = 0,
        REVERSE_STATISTICS: u1 = 0,
        CONTROLS: u1 = 0,
        REVERSE_CONTROLS: u1 = 0,
        SIGNATURE: u1 = 0,
        REVERSE_SIGNATURE: u1 = 0,
        ILLEGAL_CHARS: u1 = 0,
        ODD_LENGTH: u1 = 0,
        NULL_BYTES: u1 = 0,
        UNICODE_MASK: u1 = 0,
        REVERSE_MASK: u1 = 0,
        NOT_UNICODE_MASK: u1 = 0,
        NOT_ASCII_MASK: u1 = 0,
    }) IS_TEXT_UNICODE_RESULT {
        return @as(IS_TEXT_UNICODE_RESULT, @enumFromInt((if (o.ASCII16 == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.ASCII16) else 0) | (if (o.REVERSE_ASCII16 == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.REVERSE_ASCII16) else 0) | (if (o.STATISTICS == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.STATISTICS) else 0) | (if (o.REVERSE_STATISTICS == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.REVERSE_STATISTICS) else 0) | (if (o.CONTROLS == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.CONTROLS) else 0) | (if (o.REVERSE_CONTROLS == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.REVERSE_CONTROLS) else 0) | (if (o.SIGNATURE == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.SIGNATURE) else 0) | (if (o.REVERSE_SIGNATURE == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.REVERSE_SIGNATURE) else 0) | (if (o.ILLEGAL_CHARS == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.ILLEGAL_CHARS) else 0) | (if (o.ODD_LENGTH == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.ODD_LENGTH) else 0) | (if (o.NULL_BYTES == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.NULL_BYTES) else 0) | (if (o.UNICODE_MASK == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.UNICODE_MASK) else 0) | (if (o.REVERSE_MASK == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.REVERSE_MASK) else 0) | (if (o.NOT_UNICODE_MASK == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.NOT_UNICODE_MASK) else 0) | (if (o.NOT_ASCII_MASK == 1) @intFromEnum(IS_TEXT_UNICODE_RESULT.NOT_ASCII_MASK) else 0)));
    }
};
pub const IS_TEXT_UNICODE_ASCII16 = IS_TEXT_UNICODE_RESULT.ASCII16;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16 = IS_TEXT_UNICODE_RESULT.REVERSE_ASCII16;
pub const IS_TEXT_UNICODE_STATISTICS = IS_TEXT_UNICODE_RESULT.STATISTICS;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS = IS_TEXT_UNICODE_RESULT.REVERSE_STATISTICS;
pub const IS_TEXT_UNICODE_CONTROLS = IS_TEXT_UNICODE_RESULT.CONTROLS;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS = IS_TEXT_UNICODE_RESULT.REVERSE_CONTROLS;
pub const IS_TEXT_UNICODE_SIGNATURE = IS_TEXT_UNICODE_RESULT.SIGNATURE;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE = IS_TEXT_UNICODE_RESULT.REVERSE_SIGNATURE;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS = IS_TEXT_UNICODE_RESULT.ILLEGAL_CHARS;
pub const IS_TEXT_UNICODE_ODD_LENGTH = IS_TEXT_UNICODE_RESULT.ODD_LENGTH;
pub const IS_TEXT_UNICODE_NULL_BYTES = IS_TEXT_UNICODE_RESULT.NULL_BYTES;
pub const IS_TEXT_UNICODE_UNICODE_MASK = IS_TEXT_UNICODE_RESULT.UNICODE_MASK;
pub const IS_TEXT_UNICODE_REVERSE_MASK = IS_TEXT_UNICODE_RESULT.REVERSE_MASK;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK = IS_TEXT_UNICODE_RESULT.NOT_UNICODE_MASK;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK = IS_TEXT_UNICODE_RESULT.NOT_ASCII_MASK;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HIMC = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HIMCC = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HSAVEDUILANGUAGES = *opaque {};

pub const FONTSIGNATURE = extern struct {
    fsUsb: [4]u32,
    fsCsb: [2]u32,
};

pub const CHARSETINFO = extern struct {
    ciCharset: u32,
    ciACP: u32,
    fs: FONTSIGNATURE,
};

pub const LOCALESIGNATURE = extern struct {
    lsUsb: [4]u32,
    lsCsbDefault: [2]u32,
    lsCsbSupported: [2]u32,
};

pub const NEWTEXTMETRICEXA = extern struct {
    ntmTm: NEWTEXTMETRICA,
    ntmFontSig: FONTSIGNATURE,
};

pub const NEWTEXTMETRICEXW = extern struct {
    ntmTm: NEWTEXTMETRICW,
    ntmFontSig: FONTSIGNATURE,
};

pub const ENUMTEXTMETRICA = extern struct {
    etmNewTextMetricEx: NEWTEXTMETRICEXA,
    etmAxesList: AXESLISTA,
};

pub const ENUMTEXTMETRICW = extern struct {
    etmNewTextMetricEx: NEWTEXTMETRICEXW,
    etmAxesList: AXESLISTW,
};

pub const CPINFO = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
};

pub const CPINFOEXA = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: [260]CHAR,
};

pub const CPINFOEXW = extern struct {
    MaxCharSize: u32,
    DefaultChar: [2]u8,
    LeadByte: [12]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: [260]u16,
};

pub const NUMBERFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PSTR,
    lpThousandSep: ?PSTR,
    NegativeOrder: u32,
};

pub const NUMBERFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PWSTR,
    lpThousandSep: ?PWSTR,
    NegativeOrder: u32,
};

pub const CURRENCYFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PSTR,
    lpThousandSep: ?PSTR,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?PSTR,
};

pub const CURRENCYFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?PWSTR,
    lpThousandSep: ?PWSTR,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?PWSTR,
};

pub const SYSNLS_FUNCTION = enum(i32) {
    G = 1,
};
pub const COMPARE_STRING = SYSNLS_FUNCTION.G;

pub const NLSVERSIONINFO = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};

pub const NLSVERSIONINFOEX = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};

pub const SYSGEOTYPE = enum(i32) {
    NATION = 1,
    LATITUDE = 2,
    LONGITUDE = 3,
    ISO2 = 4,
    ISO3 = 5,
    RFC1766 = 6,
    LCID = 7,
    FRIENDLYNAME = 8,
    OFFICIALNAME = 9,
    TIMEZONES = 10,
    OFFICIALLANGUAGES = 11,
    ISO_UN_NUMBER = 12,
    PARENT = 13,
    DIALINGCODE = 14,
    CURRENCYCODE = 15,
    CURRENCYSYMBOL = 16,
    NAME = 17,
    ID = 18,
};
pub const GEO_NATION = SYSGEOTYPE.NATION;
pub const GEO_LATITUDE = SYSGEOTYPE.LATITUDE;
pub const GEO_LONGITUDE = SYSGEOTYPE.LONGITUDE;
pub const GEO_ISO2 = SYSGEOTYPE.ISO2;
pub const GEO_ISO3 = SYSGEOTYPE.ISO3;
pub const GEO_RFC1766 = SYSGEOTYPE.RFC1766;
pub const GEO_LCID = SYSGEOTYPE.LCID;
pub const GEO_FRIENDLYNAME = SYSGEOTYPE.FRIENDLYNAME;
pub const GEO_OFFICIALNAME = SYSGEOTYPE.OFFICIALNAME;
pub const GEO_TIMEZONES = SYSGEOTYPE.TIMEZONES;
pub const GEO_OFFICIALLANGUAGES = SYSGEOTYPE.OFFICIALLANGUAGES;
pub const GEO_ISO_UN_NUMBER = SYSGEOTYPE.ISO_UN_NUMBER;
pub const GEO_PARENT = SYSGEOTYPE.PARENT;
pub const GEO_DIALINGCODE = SYSGEOTYPE.DIALINGCODE;
pub const GEO_CURRENCYCODE = SYSGEOTYPE.CURRENCYCODE;
pub const GEO_CURRENCYSYMBOL = SYSGEOTYPE.CURRENCYSYMBOL;
pub const GEO_NAME = SYSGEOTYPE.NAME;
pub const GEO_ID = SYSGEOTYPE.ID;

pub const SYSGEOCLASS = enum(i32) {
    NATION = 16,
    REGION = 14,
    ALL = 0,
};
pub const GEOCLASS_NATION = SYSGEOCLASS.NATION;
pub const GEOCLASS_REGION = SYSGEOCLASS.REGION;
pub const GEOCLASS_ALL = SYSGEOCLASS.ALL;

pub const LOCALE_ENUMPROCA = *const fn (
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LOCALE_ENUMPROCW = *const fn (
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NORM_FORM = enum(i32) {
    Other = 0,
    C = 1,
    D = 2,
    KC = 5,
    KD = 6,
};
pub const NormalizationOther = NORM_FORM.Other;
pub const NormalizationC = NORM_FORM.C;
pub const NormalizationD = NORM_FORM.D;
pub const NormalizationKC = NORM_FORM.KC;
pub const NormalizationKD = NORM_FORM.KD;

pub const LANGUAGEGROUP_ENUMPROCA = *const fn (
    param0: u32,
    param1: ?PSTR,
    param2: ?PSTR,
    param3: u32,
    param4: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGGROUPLOCALE_ENUMPROCA = *const fn (
    param0: u32,
    param1: u32,
    param2: ?PSTR,
    param3: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const UILANGUAGE_ENUMPROCA = *const fn (
    param0: ?PSTR,
    param1: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CODEPAGE_ENUMPROCA = *const fn (
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCA = *const fn (
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXA = *const fn (
    param0: ?PSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCA = *const fn (
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCA = *const fn (
    param0: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCEXA = *const fn (
    param0: ?PSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGUAGEGROUP_ENUMPROCW = *const fn (
    param0: u32,
    param1: ?PWSTR,
    param2: ?PWSTR,
    param3: u32,
    param4: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LANGGROUPLOCALE_ENUMPROCW = *const fn (
    param0: u32,
    param1: u32,
    param2: ?PWSTR,
    param3: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const UILANGUAGE_ENUMPROCW = *const fn (
    param0: ?PWSTR,
    param1: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CODEPAGE_ENUMPROCW = *const fn (
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCW = *const fn (
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXW = *const fn (
    param0: ?PWSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCW = *const fn (
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCW = *const fn (
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CALINFO_ENUMPROCEXW = *const fn (
    param0: ?PWSTR,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const GEO_ENUMPROC = *const fn (
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const GEO_ENUMNAMEPROC = *const fn (
    param0: ?PWSTR,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const FILEMUIINFO = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFileType: u32,
    pChecksum: [16]u8,
    pServiceChecksum: [16]u8,
    dwLanguageNameOffset: u32,
    dwTypeIDMainSize: u32,
    dwTypeIDMainOffset: u32,
    dwTypeNameMainOffset: u32,
    dwTypeIDMUISize: u32,
    dwTypeIDMUIOffset: u32,
    dwTypeNameMUIOffset: u32,
    abBuffer: [8]u8,
};

pub const CALINFO_ENUMPROCEXEX = *const fn (
    param0: ?PWSTR,
    param1: u32,
    param2: ?PWSTR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DATEFMT_ENUMPROCEXEX = *const fn (
    param0: ?PWSTR,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TIMEFMT_ENUMPROCEX = *const fn (
    param0: ?PWSTR,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LOCALE_ENUMPROCEX = *const fn (
    param0: ?PWSTR,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_MAPPINGCALLBACKPROC = *const fn (
    p_bag: ?*MAPPING_PROPERTY_BAG,
    data: ?*anyopaque,
    dw_data_size: u32,
    result: HRESULT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MAPPING_SERVICE_INFO = extern struct {
    Size: usize,
    pszCopyright: ?PWSTR,
    wMajorVersion: u16,
    wMinorVersion: u16,
    wBuildVersion: u16,
    wStepVersion: u16,
    dwInputContentTypesCount: u32,
    prgInputContentTypes: ?*?PWSTR,
    dwOutputContentTypesCount: u32,
    prgOutputContentTypes: ?*?PWSTR,
    dwInputLanguagesCount: u32,
    prgInputLanguages: ?*?PWSTR,
    dwOutputLanguagesCount: u32,
    prgOutputLanguages: ?*?PWSTR,
    dwInputScriptsCount: u32,
    prgInputScripts: ?*?PWSTR,
    dwOutputScriptsCount: u32,
    prgOutputScripts: ?*?PWSTR,
    guid: Guid,
    pszCategory: ?PWSTR,
    pszDescription: ?PWSTR,
    dwPrivateDataSize: u32,
    pPrivateData: ?*anyopaque,
    pContext: ?*anyopaque,
    _bitfield: u32,
};

pub const MAPPING_ENUM_OPTIONS = extern struct {
    Size: usize,
    pszCategory: ?PWSTR,
    pszInputLanguage: ?PWSTR,
    pszOutputLanguage: ?PWSTR,
    pszInputScript: ?PWSTR,
    pszOutputScript: ?PWSTR,
    pszInputContentType: ?PWSTR,
    pszOutputContentType: ?PWSTR,
    pGuid: ?*Guid,
    _bitfield: u32,
};

pub const MAPPING_OPTIONS = extern struct {
    Size: usize,
    pszInputLanguage: ?PWSTR,
    pszOutputLanguage: ?PWSTR,
    pszInputScript: ?PWSTR,
    pszOutputScript: ?PWSTR,
    pszInputContentType: ?PWSTR,
    pszOutputContentType: ?PWSTR,
    pszUILanguage: ?PWSTR,
    pfnRecognizeCallback: ?PFN_MAPPINGCALLBACKPROC,
    pRecognizeCallerData: ?*anyopaque,
    dwRecognizeCallerDataSize: u32,
    pfnActionCallback: ?PFN_MAPPINGCALLBACKPROC,
    pActionCallerData: ?*anyopaque,
    dwActionCallerDataSize: u32,
    dwServiceFlag: u32,
    _bitfield: u32,
};

pub const MAPPING_DATA_RANGE = extern struct {
    dwStartIndex: u32,
    dwEndIndex: u32,
    pszDescription: ?PWSTR,
    dwDescriptionLength: u32,
    pData: ?*anyopaque,
    dwDataSize: u32,
    pszContentType: ?PWSTR,
    prgActionIds: ?*?PWSTR,
    dwActionsCount: u32,
    prgActionDisplayNames: ?*?PWSTR,
};

pub const MAPPING_PROPERTY_BAG = extern struct {
    Size: usize,
    prgResultRanges: ?*MAPPING_DATA_RANGE,
    dwRangesCount: u32,
    pServiceData: ?*anyopaque,
    dwServiceDataSize: u32,
    pCallerData: ?*anyopaque,
    dwCallerDataSize: u32,
    pContext: ?*anyopaque,
};

const CLSID_SpellCheckerFactory_Value = Guid.initString("7ab36653-1796-484b-bdfa-e74f1db7c1dc");
pub const CLSID_SpellCheckerFactory = &CLSID_SpellCheckerFactory_Value;

pub const WORDLIST_TYPE = enum(i32) {
    IGNORE = 0,
    ADD = 1,
    EXCLUDE = 2,
    AUTOCORRECT = 3,
};
pub const WORDLIST_TYPE_IGNORE = WORDLIST_TYPE.IGNORE;
pub const WORDLIST_TYPE_ADD = WORDLIST_TYPE.ADD;
pub const WORDLIST_TYPE_EXCLUDE = WORDLIST_TYPE.EXCLUDE;
pub const WORDLIST_TYPE_AUTOCORRECT = WORDLIST_TYPE.AUTOCORRECT;

pub const CORRECTIVE_ACTION = enum(i32) {
    NONE = 0,
    GET_SUGGESTIONS = 1,
    REPLACE = 2,
    DELETE = 3,
};
pub const CORRECTIVE_ACTION_NONE = CORRECTIVE_ACTION.NONE;
pub const CORRECTIVE_ACTION_GET_SUGGESTIONS = CORRECTIVE_ACTION.GET_SUGGESTIONS;
pub const CORRECTIVE_ACTION_REPLACE = CORRECTIVE_ACTION.REPLACE;
pub const CORRECTIVE_ACTION_DELETE = CORRECTIVE_ACTION.DELETE;

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellingError_Value = Guid.initString("b7c82d61-fbe8-4b47-9b27-6c0d2e0de0a3");
pub const IID_ISpellingError = &IID_ISpellingError_Value;
pub const ISpellingError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartIndex: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellingError,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellingError,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CorrectiveAction: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellingError,
            value: ?*CORRECTIVE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Replacement: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellingError,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStartIndex(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const ISpellingError.VTable, @ptrCast(self.vtable)).get_StartIndex(@as(*const ISpellingError, @ptrCast(self)), value_);
            }
            pub inline fn getLength(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const ISpellingError.VTable, @ptrCast(self.vtable)).get_Length(@as(*const ISpellingError, @ptrCast(self)), value_);
            }
            pub inline fn getCorrectiveAction(self: *const T, value_: ?*CORRECTIVE_ACTION) HRESULT {
                return @as(*const ISpellingError.VTable, @ptrCast(self.vtable)).get_CorrectiveAction(@as(*const ISpellingError, @ptrCast(self)), value_);
            }
            pub inline fn getReplacement(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellingError.VTable, @ptrCast(self.vtable)).get_Replacement(@as(*const ISpellingError, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IEnumSpellingError_Value = Guid.initString("803e3bd4-2828-4410-8290-418d1d73c762");
pub const IID_IEnumSpellingError = &IID_IEnumSpellingError_Value;
pub const IEnumSpellingError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumSpellingError,
            value: ?*?*ISpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, value_: ?*?*ISpellingError) HRESULT {
                return @as(*const IEnumSpellingError.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSpellingError, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IOptionDescription_Value = Guid.initString("432e5f85-35cf-4606-a801-6f70277e1d7a");
pub const IID_IOptionDescription = &IID_IOptionDescription_Value;
pub const IOptionDescription = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Heading: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IOptionDescription,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Labels: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IOptionDescription,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getId(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const IOptionDescription.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IOptionDescription, @ptrCast(self)), value_);
            }
            pub inline fn getHeading(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const IOptionDescription.VTable, @ptrCast(self.vtable)).get_Heading(@as(*const IOptionDescription, @ptrCast(self)), value_);
            }
            pub inline fn getDescription(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const IOptionDescription.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IOptionDescription, @ptrCast(self)), value_);
            }
            pub inline fn getLabels(self: *const T, value_: ?*?*IEnumString) HRESULT {
                return @as(*const IOptionDescription.VTable, @ptrCast(self.vtable)).get_Labels(@as(*const IOptionDescription, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckerChangedEventHandler_Value = Guid.initString("0b83a5b0-792f-4eab-9799-acf52c5ed08a");
pub const IID_ISpellCheckerChangedEventHandler = &IID_ISpellCheckerChangedEventHandler_Value;
pub const ISpellCheckerChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: *const fn (
            self: *const ISpellCheckerChangedEventHandler,
            sender: ?*ISpellChecker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn invoke(self: *const T, sender_: ?*ISpellChecker) HRESULT {
                return @as(*const ISpellCheckerChangedEventHandler.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ISpellCheckerChangedEventHandler, @ptrCast(self)), sender_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellChecker_Value = Guid.initString("b6fd0b71-e2bc-4653-8d05-f197e412770b");
pub const IID_ISpellChecker = &IID_ISpellChecker_Value;
pub const ISpellChecker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageTag: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Check: *const fn (
            self: *const ISpellChecker,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suggest: *const fn (
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Ignore: *const fn (
            self: *const ISpellChecker,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCorrect: *const fn (
            self: *const ISpellChecker,
            from: ?[*:0]const u16,
            to: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionValue: *const fn (
            self: *const ISpellChecker,
            option_id: ?[*:0]const u16,
            value: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OptionIds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalizedName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        add_SpellCheckerChanged: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            handler: ?*ISpellCheckerChangedEventHandler,
            event_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        remove_SpellCheckerChanged: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellChecker,
            event_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionDescription: *const fn (
            self: *const ISpellChecker,
            option_id: ?[*:0]const u16,
            value: ?*?*IOptionDescription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComprehensiveCheck: *const fn (
            self: *const ISpellChecker,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLanguageTag(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).get_LanguageTag(@as(*const ISpellChecker, @ptrCast(self)), value_);
            }
            pub inline fn check(self: *const T, text_: ?[*:0]const u16, value_: ?*?*IEnumSpellingError) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).Check(@as(*const ISpellChecker, @ptrCast(self)), text_, value_);
            }
            pub inline fn suggest(self: *const T, word_: ?[*:0]const u16, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).Suggest(@as(*const ISpellChecker, @ptrCast(self)), word_, value_);
            }
            pub inline fn add(self: *const T, word_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).Add(@as(*const ISpellChecker, @ptrCast(self)), word_);
            }
            pub inline fn ignore(self: *const T, word_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).Ignore(@as(*const ISpellChecker, @ptrCast(self)), word_);
            }
            pub inline fn autoCorrect(self: *const T, from_: ?[*:0]const u16, to_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).AutoCorrect(@as(*const ISpellChecker, @ptrCast(self)), from_, to_);
            }
            pub inline fn getOptionValue(self: *const T, option_id_: ?[*:0]const u16, value_: ?*u8) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).GetOptionValue(@as(*const ISpellChecker, @ptrCast(self)), option_id_, value_);
            }
            pub inline fn getOptionIds(self: *const T, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).get_OptionIds(@as(*const ISpellChecker, @ptrCast(self)), value_);
            }
            pub inline fn getId(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpellChecker, @ptrCast(self)), value_);
            }
            pub inline fn getLocalizedName(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).get_LocalizedName(@as(*const ISpellChecker, @ptrCast(self)), value_);
            }
            pub inline fn addSpellCheckerChanged(self: *const T, handler_: ?*ISpellCheckerChangedEventHandler, event_cookie_: ?*u32) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).add_SpellCheckerChanged(@as(*const ISpellChecker, @ptrCast(self)), handler_, event_cookie_);
            }
            pub inline fn removeSpellCheckerChanged(self: *const T, event_cookie_: u32) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).remove_SpellCheckerChanged(@as(*const ISpellChecker, @ptrCast(self)), event_cookie_);
            }
            pub inline fn getOptionDescription(self: *const T, option_id_: ?[*:0]const u16, value_: ?*?*IOptionDescription) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).GetOptionDescription(@as(*const ISpellChecker, @ptrCast(self)), option_id_, value_);
            }
            pub inline fn comprehensiveCheck(self: *const T, text_: ?[*:0]const u16, value_: ?*?*IEnumSpellingError) HRESULT {
                return @as(*const ISpellChecker.VTable, @ptrCast(self.vtable)).ComprehensiveCheck(@as(*const ISpellChecker, @ptrCast(self)), text_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ISpellChecker2_Value = Guid.initString("e7ed1c71-87f7-4378-a840-c9200dacee47");
pub const IID_ISpellChecker2 = &IID_ISpellChecker2_Value;
pub const ISpellChecker2 = extern struct {
    pub const VTable = extern struct {
        base: ISpellChecker.VTable,
        Remove: *const fn (
            self: *const ISpellChecker2,
            word: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpellChecker.MethodMixin(T);
            pub inline fn remove(self: *const T, word_: ?[*:0]const u16) HRESULT {
                return @as(*const ISpellChecker2.VTable, @ptrCast(self.vtable)).Remove(@as(*const ISpellChecker2, @ptrCast(self)), word_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckerFactory_Value = Guid.initString("8e018a9d-2415-4677-bf08-794ea61f94bb");
pub const IID_ISpellCheckerFactory = &IID_ISpellCheckerFactory_Value;
pub const ISpellCheckerFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckerFactory,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSupported: *const fn (
            self: *const ISpellCheckerFactory,
            language_tag: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSpellChecker: *const fn (
            self: *const ISpellCheckerFactory,
            language_tag: ?[*:0]const u16,
            value: ?*?*ISpellChecker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupportedLanguages(self: *const T, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellCheckerFactory.VTable, @ptrCast(self.vtable)).get_SupportedLanguages(@as(*const ISpellCheckerFactory, @ptrCast(self)), value_);
            }
            pub inline fn isSupported(self: *const T, language_tag_: ?[*:0]const u16, value_: ?*BOOL) HRESULT {
                return @as(*const ISpellCheckerFactory.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const ISpellCheckerFactory, @ptrCast(self)), language_tag_, value_);
            }
            pub inline fn createSpellChecker(self: *const T, language_tag_: ?[*:0]const u16, value_: ?*?*ISpellChecker) HRESULT {
                return @as(*const ISpellCheckerFactory.VTable, @ptrCast(self.vtable)).CreateSpellChecker(@as(*const ISpellCheckerFactory, @ptrCast(self)), language_tag_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUserDictionariesRegistrar_Value = Guid.initString("aa176b85-0e12-4844-8e1a-eef1da77f586");
pub const IID_IUserDictionariesRegistrar = &IID_IUserDictionariesRegistrar_Value;
pub const IUserDictionariesRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterUserDictionary: *const fn (
            self: *const IUserDictionariesRegistrar,
            dictionary_path: ?[*:0]const u16,
            language_tag: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterUserDictionary: *const fn (
            self: *const IUserDictionariesRegistrar,
            dictionary_path: ?[*:0]const u16,
            language_tag: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn registerUserDictionary(self: *const T, dictionary_path_: ?[*:0]const u16, language_tag_: ?[*:0]const u16) HRESULT {
                return @as(*const IUserDictionariesRegistrar.VTable, @ptrCast(self.vtable)).RegisterUserDictionary(@as(*const IUserDictionariesRegistrar, @ptrCast(self)), dictionary_path_, language_tag_);
            }
            pub inline fn unregisterUserDictionary(self: *const T, dictionary_path_: ?[*:0]const u16, language_tag_: ?[*:0]const u16) HRESULT {
                return @as(*const IUserDictionariesRegistrar.VTable, @ptrCast(self.vtable)).UnregisterUserDictionary(@as(*const IUserDictionariesRegistrar, @ptrCast(self)), dictionary_path_, language_tag_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckProvider_Value = Guid.initString("73e976e0-8ed4-4eb1-80d7-1be0a16b0c38");
pub const IID_ISpellCheckProvider = &IID_ISpellCheckProvider_Value;
pub const ISpellCheckProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageTag: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Check: *const fn (
            self: *const ISpellCheckProvider,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suggest: *const fn (
            self: *const ISpellCheckProvider,
            word: ?[*:0]const u16,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionValue: *const fn (
            self: *const ISpellCheckProvider,
            option_id: ?[*:0]const u16,
            value: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOptionValue: *const fn (
            self: *const ISpellCheckProvider,
            option_id: ?[*:0]const u16,
            value: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OptionIds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckProvider,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalizedName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckProvider,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionDescription: *const fn (
            self: *const ISpellCheckProvider,
            option_id: ?[*:0]const u16,
            value: ?*?*IOptionDescription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeWordlist: *const fn (
            self: *const ISpellCheckProvider,
            wordlist_type: WORDLIST_TYPE,
            words: ?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLanguageTag(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).get_LanguageTag(@as(*const ISpellCheckProvider, @ptrCast(self)), value_);
            }
            pub inline fn check(self: *const T, text_: ?[*:0]const u16, value_: ?*?*IEnumSpellingError) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).Check(@as(*const ISpellCheckProvider, @ptrCast(self)), text_, value_);
            }
            pub inline fn suggest(self: *const T, word_: ?[*:0]const u16, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).Suggest(@as(*const ISpellCheckProvider, @ptrCast(self)), word_, value_);
            }
            pub inline fn getOptionValue(self: *const T, option_id_: ?[*:0]const u16, value_: ?*u8) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).GetOptionValue(@as(*const ISpellCheckProvider, @ptrCast(self)), option_id_, value_);
            }
            pub inline fn setOptionValue(self: *const T, option_id_: ?[*:0]const u16, value_: u8) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).SetOptionValue(@as(*const ISpellCheckProvider, @ptrCast(self)), option_id_, value_);
            }
            pub inline fn getOptionIds(self: *const T, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).get_OptionIds(@as(*const ISpellCheckProvider, @ptrCast(self)), value_);
            }
            pub inline fn getId(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).get_Id(@as(*const ISpellCheckProvider, @ptrCast(self)), value_);
            }
            pub inline fn getLocalizedName(self: *const T, value_: ?*?PWSTR) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).get_LocalizedName(@as(*const ISpellCheckProvider, @ptrCast(self)), value_);
            }
            pub inline fn getOptionDescription(self: *const T, option_id_: ?[*:0]const u16, value_: ?*?*IOptionDescription) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).GetOptionDescription(@as(*const ISpellCheckProvider, @ptrCast(self)), option_id_, value_);
            }
            pub inline fn initializeWordlist(self: *const T, wordlist_type_: WORDLIST_TYPE, words_: ?*IEnumString) HRESULT {
                return @as(*const ISpellCheckProvider.VTable, @ptrCast(self.vtable)).InitializeWordlist(@as(*const ISpellCheckProvider, @ptrCast(self)), wordlist_type_, words_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IComprehensiveSpellCheckProvider_Value = Guid.initString("0c58f8de-8e94-479e-9717-70c42c4ad2c3");
pub const IID_IComprehensiveSpellCheckProvider = &IID_IComprehensiveSpellCheckProvider_Value;
pub const IComprehensiveSpellCheckProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ComprehensiveCheck: *const fn (
            self: *const IComprehensiveSpellCheckProvider,
            text: ?[*:0]const u16,
            value: ?*?*IEnumSpellingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn comprehensiveCheck(self: *const T, text_: ?[*:0]const u16, value_: ?*?*IEnumSpellingError) HRESULT {
                return @as(*const IComprehensiveSpellCheckProvider.VTable, @ptrCast(self.vtable)).ComprehensiveCheck(@as(*const IComprehensiveSpellCheckProvider, @ptrCast(self)), text_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpellCheckProviderFactory_Value = Guid.initString("9f671e11-77d6-4c92-aefb-615215e3a4be");
pub const IID_ISpellCheckProviderFactory = &IID_ISpellCheckProviderFactory_Value;
pub const ISpellCheckProviderFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const ISpellCheckProviderFactory,
            value: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSupported: *const fn (
            self: *const ISpellCheckProviderFactory,
            language_tag: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSpellCheckProvider: *const fn (
            self: *const ISpellCheckProviderFactory,
            language_tag: ?[*:0]const u16,
            value: ?*?*ISpellCheckProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getSupportedLanguages(self: *const T, value_: ?*?*IEnumString) HRESULT {
                return @as(*const ISpellCheckProviderFactory.VTable, @ptrCast(self.vtable)).get_SupportedLanguages(@as(*const ISpellCheckProviderFactory, @ptrCast(self)), value_);
            }
            pub inline fn isSupported(self: *const T, language_tag_: ?[*:0]const u16, value_: ?*BOOL) HRESULT {
                return @as(*const ISpellCheckProviderFactory.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const ISpellCheckProviderFactory, @ptrCast(self)), language_tag_, value_);
            }
            pub inline fn createSpellCheckProvider(self: *const T, language_tag_: ?[*:0]const u16, value_: ?*?*ISpellCheckProvider) HRESULT {
                return @as(*const ISpellCheckProviderFactory.VTable, @ptrCast(self.vtable)).CreateSpellCheckProvider(@as(*const ISpellCheckProviderFactory, @ptrCast(self)), language_tag_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_CONTROL = extern struct {
    _bitfield: u32,
};

pub const SCRIPT_STATE = extern struct {
    _bitfield: u16,
};

pub const SCRIPT_ANALYSIS = extern struct {
    _bitfield: u16,
    s: SCRIPT_STATE,
};

pub const SCRIPT_ITEM = extern struct {
    iCharPos: i32,
    a: SCRIPT_ANALYSIS,
};

pub const SCRIPT_JUSTIFY = enum(i32) {
    NONE = 0,
    ARABIC_BLANK = 1,
    CHARACTER = 2,
    RESERVED1 = 3,
    BLANK = 4,
    RESERVED2 = 5,
    RESERVED3 = 6,
    ARABIC_NORMAL = 7,
    ARABIC_KASHIDA = 8,
    ARABIC_ALEF = 9,
    ARABIC_HA = 10,
    ARABIC_RA = 11,
    ARABIC_BA = 12,
    ARABIC_BARA = 13,
    ARABIC_SEEN = 14,
    ARABIC_SEEN_M = 15,
};
pub const SCRIPT_JUSTIFY_NONE = SCRIPT_JUSTIFY.NONE;
pub const SCRIPT_JUSTIFY_ARABIC_BLANK = SCRIPT_JUSTIFY.ARABIC_BLANK;
pub const SCRIPT_JUSTIFY_CHARACTER = SCRIPT_JUSTIFY.CHARACTER;
pub const SCRIPT_JUSTIFY_RESERVED1 = SCRIPT_JUSTIFY.RESERVED1;
pub const SCRIPT_JUSTIFY_BLANK = SCRIPT_JUSTIFY.BLANK;
pub const SCRIPT_JUSTIFY_RESERVED2 = SCRIPT_JUSTIFY.RESERVED2;
pub const SCRIPT_JUSTIFY_RESERVED3 = SCRIPT_JUSTIFY.RESERVED3;
pub const SCRIPT_JUSTIFY_ARABIC_NORMAL = SCRIPT_JUSTIFY.ARABIC_NORMAL;
pub const SCRIPT_JUSTIFY_ARABIC_KASHIDA = SCRIPT_JUSTIFY.ARABIC_KASHIDA;
pub const SCRIPT_JUSTIFY_ARABIC_ALEF = SCRIPT_JUSTIFY.ARABIC_ALEF;
pub const SCRIPT_JUSTIFY_ARABIC_HA = SCRIPT_JUSTIFY.ARABIC_HA;
pub const SCRIPT_JUSTIFY_ARABIC_RA = SCRIPT_JUSTIFY.ARABIC_RA;
pub const SCRIPT_JUSTIFY_ARABIC_BA = SCRIPT_JUSTIFY.ARABIC_BA;
pub const SCRIPT_JUSTIFY_ARABIC_BARA = SCRIPT_JUSTIFY.ARABIC_BARA;
pub const SCRIPT_JUSTIFY_ARABIC_SEEN = SCRIPT_JUSTIFY.ARABIC_SEEN;
pub const SCRIPT_JUSTIFY_ARABIC_SEEN_M = SCRIPT_JUSTIFY.ARABIC_SEEN_M;

pub const SCRIPT_VISATTR = extern struct {
    _bitfield: u16,
};

pub const GOFFSET = extern struct {
    du: i32,
    dv: i32,
};

pub const SCRIPT_LOGATTR = extern struct {
    _bitfield: u8,
};

pub const SCRIPT_PROPERTIES = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
};

pub const SCRIPT_FONTPROPERTIES = extern struct {
    cBytes: i32,
    wgBlank: u16,
    wgDefault: u16,
    wgInvalid: u16,
    wgKashida: u16,
    iKashidaWidth: i32,
};

pub const SCRIPT_TABDEF = extern struct {
    cTabStops: i32,
    iScale: i32,
    pTabStops: ?*i32,
    iTabOrigin: i32,
};

pub const SCRIPT_DIGITSUBSTITUTE = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
    dwReserved: u32,
};

pub const opentype_feature_record = extern struct {
    tagFeature: u32,
    lParameter: i32,
};

pub const textrange_properties = extern struct {
    potfRecords: ?*opentype_feature_record,
    cotfRecords: i32,
};

pub const script_charprop = extern struct {
    _bitfield: u16,
};

pub const script_glyphprop = extern struct {
    sva: SCRIPT_VISATTR,
    reserved: u16,
};

pub const UErrorCode = enum(i32) {
    USING_FALLBACK_WARNING = -128,
    // ERROR_WARNING_START = -128, this enum value conflicts with USING_FALLBACK_WARNING
    USING_DEFAULT_WARNING = -127,
    SAFECLONE_ALLOCATED_WARNING = -126,
    STATE_OLD_WARNING = -125,
    STRING_NOT_TERMINATED_WARNING = -124,
    SORT_KEY_TOO_SHORT_WARNING = -123,
    AMBIGUOUS_ALIAS_WARNING = -122,
    DIFFERENT_UCA_VERSION = -121,
    PLUGIN_CHANGED_LEVEL_WARNING = -120,
    ZERO_ERROR = 0,
    ILLEGAL_ARGUMENT_ERROR = 1,
    MISSING_RESOURCE_ERROR = 2,
    INVALID_FORMAT_ERROR = 3,
    FILE_ACCESS_ERROR = 4,
    INTERNAL_PROGRAM_ERROR = 5,
    MESSAGE_PARSE_ERROR = 6,
    MEMORY_ALLOCATION_ERROR = 7,
    INDEX_OUTOFBOUNDS_ERROR = 8,
    PARSE_ERROR = 9,
    INVALID_CHAR_FOUND = 10,
    TRUNCATED_CHAR_FOUND = 11,
    ILLEGAL_CHAR_FOUND = 12,
    INVALID_TABLE_FORMAT = 13,
    INVALID_TABLE_FILE = 14,
    BUFFER_OVERFLOW_ERROR = 15,
    UNSUPPORTED_ERROR = 16,
    RESOURCE_TYPE_MISMATCH = 17,
    ILLEGAL_ESCAPE_SEQUENCE = 18,
    UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    NO_SPACE_AVAILABLE = 20,
    CE_NOT_FOUND_ERROR = 21,
    PRIMARY_TOO_LONG_ERROR = 22,
    STATE_TOO_OLD_ERROR = 23,
    TOO_MANY_ALIASES_ERROR = 24,
    ENUM_OUT_OF_SYNC_ERROR = 25,
    INVARIANT_CONVERSION_ERROR = 26,
    INVALID_STATE_ERROR = 27,
    COLLATOR_VERSION_MISMATCH = 28,
    USELESS_COLLATOR_ERROR = 29,
    NO_WRITE_PERMISSION = 30,
    BAD_VARIABLE_DEFINITION = 65536,
    // PARSE_ERROR_START = 65536, this enum value conflicts with BAD_VARIABLE_DEFINITION
    MALFORMED_RULE = 65537,
    MALFORMED_SET = 65538,
    MALFORMED_SYMBOL_REFERENCE = 65539,
    MALFORMED_UNICODE_ESCAPE = 65540,
    MALFORMED_VARIABLE_DEFINITION = 65541,
    MALFORMED_VARIABLE_REFERENCE = 65542,
    MISMATCHED_SEGMENT_DELIMITERS = 65543,
    MISPLACED_ANCHOR_START = 65544,
    MISPLACED_CURSOR_OFFSET = 65545,
    MISPLACED_QUANTIFIER = 65546,
    MISSING_OPERATOR = 65547,
    MISSING_SEGMENT_CLOSE = 65548,
    MULTIPLE_ANTE_CONTEXTS = 65549,
    MULTIPLE_CURSORS = 65550,
    MULTIPLE_POST_CONTEXTS = 65551,
    TRAILING_BACKSLASH = 65552,
    UNDEFINED_SEGMENT_REFERENCE = 65553,
    UNDEFINED_VARIABLE = 65554,
    UNQUOTED_SPECIAL = 65555,
    UNTERMINATED_QUOTE = 65556,
    RULE_MASK_ERROR = 65557,
    MISPLACED_COMPOUND_FILTER = 65558,
    MULTIPLE_COMPOUND_FILTERS = 65559,
    INVALID_RBT_SYNTAX = 65560,
    INVALID_PROPERTY_PATTERN = 65561,
    MALFORMED_PRAGMA = 65562,
    UNCLOSED_SEGMENT = 65563,
    ILLEGAL_CHAR_IN_SEGMENT = 65564,
    VARIABLE_RANGE_EXHAUSTED = 65565,
    VARIABLE_RANGE_OVERLAP = 65566,
    ILLEGAL_CHARACTER = 65567,
    INTERNAL_TRANSLITERATOR_ERROR = 65568,
    INVALID_ID = 65569,
    INVALID_FUNCTION = 65570,
    UNEXPECTED_TOKEN = 65792,
    // FMT_PARSE_ERROR_START = 65792, this enum value conflicts with UNEXPECTED_TOKEN
    MULTIPLE_DECIMAL_SEPARATORS = 65793,
    // MULTIPLE_DECIMAL_SEPERATORS = 65793, this enum value conflicts with MULTIPLE_DECIMAL_SEPARATORS
    MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    MALFORMED_EXPONENTIAL_PATTERN = 65795,
    MULTIPLE_PERCENT_SYMBOLS = 65796,
    MULTIPLE_PERMILL_SYMBOLS = 65797,
    MULTIPLE_PAD_SPECIFIERS = 65798,
    PATTERN_SYNTAX_ERROR = 65799,
    ILLEGAL_PAD_POSITION = 65800,
    UNMATCHED_BRACES = 65801,
    UNSUPPORTED_PROPERTY = 65802,
    UNSUPPORTED_ATTRIBUTE = 65803,
    ARGUMENT_TYPE_MISMATCH = 65804,
    DUPLICATE_KEYWORD = 65805,
    UNDEFINED_KEYWORD = 65806,
    DEFAULT_KEYWORD_MISSING = 65807,
    DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    FORMAT_INEXACT_ERROR = 65809,
    NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    BRK_INTERNAL_ERROR = 66048,
    // BRK_ERROR_START = 66048, this enum value conflicts with BRK_INTERNAL_ERROR
    BRK_HEX_DIGITS_EXPECTED = 66049,
    BRK_SEMICOLON_EXPECTED = 66050,
    BRK_RULE_SYNTAX = 66051,
    BRK_UNCLOSED_SET = 66052,
    BRK_ASSIGN_ERROR = 66053,
    BRK_VARIABLE_REDFINITION = 66054,
    BRK_MISMATCHED_PAREN = 66055,
    BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    BRK_UNDEFINED_VARIABLE = 66057,
    BRK_INIT_ERROR = 66058,
    BRK_RULE_EMPTY_SET = 66059,
    BRK_UNRECOGNIZED_OPTION = 66060,
    BRK_MALFORMED_RULE_TAG = 66061,
    REGEX_INTERNAL_ERROR = 66304,
    // REGEX_ERROR_START = 66304, this enum value conflicts with REGEX_INTERNAL_ERROR
    REGEX_RULE_SYNTAX = 66305,
    REGEX_INVALID_STATE = 66306,
    REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    REGEX_PROPERTY_SYNTAX = 66308,
    REGEX_UNIMPLEMENTED = 66309,
    REGEX_MISMATCHED_PAREN = 66310,
    REGEX_NUMBER_TOO_BIG = 66311,
    REGEX_BAD_INTERVAL = 66312,
    REGEX_MAX_LT_MIN = 66313,
    REGEX_INVALID_BACK_REF = 66314,
    REGEX_INVALID_FLAG = 66315,
    REGEX_LOOK_BEHIND_LIMIT = 66316,
    REGEX_SET_CONTAINS_STRING = 66317,
    REGEX_MISSING_CLOSE_BRACKET = 66319,
    REGEX_INVALID_RANGE = 66320,
    REGEX_STACK_OVERFLOW = 66321,
    REGEX_TIME_OUT = 66322,
    REGEX_STOPPED_BY_CALLER = 66323,
    REGEX_PATTERN_TOO_BIG = 66324,
    REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    IDNA_PROHIBITED_ERROR = 66560,
    // IDNA_ERROR_START = 66560, this enum value conflicts with IDNA_PROHIBITED_ERROR
    IDNA_UNASSIGNED_ERROR = 66561,
    IDNA_CHECK_BIDI_ERROR = 66562,
    IDNA_STD3_ASCII_RULES_ERROR = 66563,
    IDNA_ACE_PREFIX_ERROR = 66564,
    IDNA_VERIFICATION_ERROR = 66565,
    IDNA_LABEL_TOO_LONG_ERROR = 66566,
    IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    // STRINGPREP_PROHIBITED_ERROR = 66560, this enum value conflicts with IDNA_PROHIBITED_ERROR
    // STRINGPREP_UNASSIGNED_ERROR = 66561, this enum value conflicts with IDNA_UNASSIGNED_ERROR
    // STRINGPREP_CHECK_BIDI_ERROR = 66562, this enum value conflicts with IDNA_CHECK_BIDI_ERROR
    PLUGIN_ERROR_START = 66816,
    // PLUGIN_TOO_HIGH = 66816, this enum value conflicts with PLUGIN_ERROR_START
    PLUGIN_DIDNT_SET_LEVEL = 66817,
};
pub const U_USING_FALLBACK_WARNING = UErrorCode.USING_FALLBACK_WARNING;
pub const U_ERROR_WARNING_START = UErrorCode.USING_FALLBACK_WARNING;
pub const U_USING_DEFAULT_WARNING = UErrorCode.USING_DEFAULT_WARNING;
pub const U_SAFECLONE_ALLOCATED_WARNING = UErrorCode.SAFECLONE_ALLOCATED_WARNING;
pub const U_STATE_OLD_WARNING = UErrorCode.STATE_OLD_WARNING;
pub const U_STRING_NOT_TERMINATED_WARNING = UErrorCode.STRING_NOT_TERMINATED_WARNING;
pub const U_SORT_KEY_TOO_SHORT_WARNING = UErrorCode.SORT_KEY_TOO_SHORT_WARNING;
pub const U_AMBIGUOUS_ALIAS_WARNING = UErrorCode.AMBIGUOUS_ALIAS_WARNING;
pub const U_DIFFERENT_UCA_VERSION = UErrorCode.DIFFERENT_UCA_VERSION;
pub const U_PLUGIN_CHANGED_LEVEL_WARNING = UErrorCode.PLUGIN_CHANGED_LEVEL_WARNING;
pub const U_ZERO_ERROR = UErrorCode.ZERO_ERROR;
pub const U_ILLEGAL_ARGUMENT_ERROR = UErrorCode.ILLEGAL_ARGUMENT_ERROR;
pub const U_MISSING_RESOURCE_ERROR = UErrorCode.MISSING_RESOURCE_ERROR;
pub const U_INVALID_FORMAT_ERROR = UErrorCode.INVALID_FORMAT_ERROR;
pub const U_FILE_ACCESS_ERROR = UErrorCode.FILE_ACCESS_ERROR;
pub const U_INTERNAL_PROGRAM_ERROR = UErrorCode.INTERNAL_PROGRAM_ERROR;
pub const U_MESSAGE_PARSE_ERROR = UErrorCode.MESSAGE_PARSE_ERROR;
pub const U_MEMORY_ALLOCATION_ERROR = UErrorCode.MEMORY_ALLOCATION_ERROR;
pub const U_INDEX_OUTOFBOUNDS_ERROR = UErrorCode.INDEX_OUTOFBOUNDS_ERROR;
pub const U_PARSE_ERROR = UErrorCode.PARSE_ERROR;
pub const U_INVALID_CHAR_FOUND = UErrorCode.INVALID_CHAR_FOUND;
pub const U_TRUNCATED_CHAR_FOUND = UErrorCode.TRUNCATED_CHAR_FOUND;
pub const U_ILLEGAL_CHAR_FOUND = UErrorCode.ILLEGAL_CHAR_FOUND;
pub const U_INVALID_TABLE_FORMAT = UErrorCode.INVALID_TABLE_FORMAT;
pub const U_INVALID_TABLE_FILE = UErrorCode.INVALID_TABLE_FILE;
pub const U_BUFFER_OVERFLOW_ERROR = UErrorCode.BUFFER_OVERFLOW_ERROR;
pub const U_UNSUPPORTED_ERROR = UErrorCode.UNSUPPORTED_ERROR;
pub const U_RESOURCE_TYPE_MISMATCH = UErrorCode.RESOURCE_TYPE_MISMATCH;
pub const U_ILLEGAL_ESCAPE_SEQUENCE = UErrorCode.ILLEGAL_ESCAPE_SEQUENCE;
pub const U_UNSUPPORTED_ESCAPE_SEQUENCE = UErrorCode.UNSUPPORTED_ESCAPE_SEQUENCE;
pub const U_NO_SPACE_AVAILABLE = UErrorCode.NO_SPACE_AVAILABLE;
pub const U_CE_NOT_FOUND_ERROR = UErrorCode.CE_NOT_FOUND_ERROR;
pub const U_PRIMARY_TOO_LONG_ERROR = UErrorCode.PRIMARY_TOO_LONG_ERROR;
pub const U_STATE_TOO_OLD_ERROR = UErrorCode.STATE_TOO_OLD_ERROR;
pub const U_TOO_MANY_ALIASES_ERROR = UErrorCode.TOO_MANY_ALIASES_ERROR;
pub const U_ENUM_OUT_OF_SYNC_ERROR = UErrorCode.ENUM_OUT_OF_SYNC_ERROR;
pub const U_INVARIANT_CONVERSION_ERROR = UErrorCode.INVARIANT_CONVERSION_ERROR;
pub const U_INVALID_STATE_ERROR = UErrorCode.INVALID_STATE_ERROR;
pub const U_COLLATOR_VERSION_MISMATCH = UErrorCode.COLLATOR_VERSION_MISMATCH;
pub const U_USELESS_COLLATOR_ERROR = UErrorCode.USELESS_COLLATOR_ERROR;
pub const U_NO_WRITE_PERMISSION = UErrorCode.NO_WRITE_PERMISSION;
pub const U_BAD_VARIABLE_DEFINITION = UErrorCode.BAD_VARIABLE_DEFINITION;
pub const U_PARSE_ERROR_START = UErrorCode.BAD_VARIABLE_DEFINITION;
pub const U_MALFORMED_RULE = UErrorCode.MALFORMED_RULE;
pub const U_MALFORMED_SET = UErrorCode.MALFORMED_SET;
pub const U_MALFORMED_SYMBOL_REFERENCE = UErrorCode.MALFORMED_SYMBOL_REFERENCE;
pub const U_MALFORMED_UNICODE_ESCAPE = UErrorCode.MALFORMED_UNICODE_ESCAPE;
pub const U_MALFORMED_VARIABLE_DEFINITION = UErrorCode.MALFORMED_VARIABLE_DEFINITION;
pub const U_MALFORMED_VARIABLE_REFERENCE = UErrorCode.MALFORMED_VARIABLE_REFERENCE;
pub const U_MISMATCHED_SEGMENT_DELIMITERS = UErrorCode.MISMATCHED_SEGMENT_DELIMITERS;
pub const U_MISPLACED_ANCHOR_START = UErrorCode.MISPLACED_ANCHOR_START;
pub const U_MISPLACED_CURSOR_OFFSET = UErrorCode.MISPLACED_CURSOR_OFFSET;
pub const U_MISPLACED_QUANTIFIER = UErrorCode.MISPLACED_QUANTIFIER;
pub const U_MISSING_OPERATOR = UErrorCode.MISSING_OPERATOR;
pub const U_MISSING_SEGMENT_CLOSE = UErrorCode.MISSING_SEGMENT_CLOSE;
pub const U_MULTIPLE_ANTE_CONTEXTS = UErrorCode.MULTIPLE_ANTE_CONTEXTS;
pub const U_MULTIPLE_CURSORS = UErrorCode.MULTIPLE_CURSORS;
pub const U_MULTIPLE_POST_CONTEXTS = UErrorCode.MULTIPLE_POST_CONTEXTS;
pub const U_TRAILING_BACKSLASH = UErrorCode.TRAILING_BACKSLASH;
pub const U_UNDEFINED_SEGMENT_REFERENCE = UErrorCode.UNDEFINED_SEGMENT_REFERENCE;
pub const U_UNDEFINED_VARIABLE = UErrorCode.UNDEFINED_VARIABLE;
pub const U_UNQUOTED_SPECIAL = UErrorCode.UNQUOTED_SPECIAL;
pub const U_UNTERMINATED_QUOTE = UErrorCode.UNTERMINATED_QUOTE;
pub const U_RULE_MASK_ERROR = UErrorCode.RULE_MASK_ERROR;
pub const U_MISPLACED_COMPOUND_FILTER = UErrorCode.MISPLACED_COMPOUND_FILTER;
pub const U_MULTIPLE_COMPOUND_FILTERS = UErrorCode.MULTIPLE_COMPOUND_FILTERS;
pub const U_INVALID_RBT_SYNTAX = UErrorCode.INVALID_RBT_SYNTAX;
pub const U_INVALID_PROPERTY_PATTERN = UErrorCode.INVALID_PROPERTY_PATTERN;
pub const U_MALFORMED_PRAGMA = UErrorCode.MALFORMED_PRAGMA;
pub const U_UNCLOSED_SEGMENT = UErrorCode.UNCLOSED_SEGMENT;
pub const U_ILLEGAL_CHAR_IN_SEGMENT = UErrorCode.ILLEGAL_CHAR_IN_SEGMENT;
pub const U_VARIABLE_RANGE_EXHAUSTED = UErrorCode.VARIABLE_RANGE_EXHAUSTED;
pub const U_VARIABLE_RANGE_OVERLAP = UErrorCode.VARIABLE_RANGE_OVERLAP;
pub const U_ILLEGAL_CHARACTER = UErrorCode.ILLEGAL_CHARACTER;
pub const U_INTERNAL_TRANSLITERATOR_ERROR = UErrorCode.INTERNAL_TRANSLITERATOR_ERROR;
pub const U_INVALID_ID = UErrorCode.INVALID_ID;
pub const U_INVALID_FUNCTION = UErrorCode.INVALID_FUNCTION;
pub const U_UNEXPECTED_TOKEN = UErrorCode.UNEXPECTED_TOKEN;
pub const U_FMT_PARSE_ERROR_START = UErrorCode.UNEXPECTED_TOKEN;
pub const U_MULTIPLE_DECIMAL_SEPARATORS = UErrorCode.MULTIPLE_DECIMAL_SEPARATORS;
pub const U_MULTIPLE_DECIMAL_SEPERATORS = UErrorCode.MULTIPLE_DECIMAL_SEPARATORS;
pub const U_MULTIPLE_EXPONENTIAL_SYMBOLS = UErrorCode.MULTIPLE_EXPONENTIAL_SYMBOLS;
pub const U_MALFORMED_EXPONENTIAL_PATTERN = UErrorCode.MALFORMED_EXPONENTIAL_PATTERN;
pub const U_MULTIPLE_PERCENT_SYMBOLS = UErrorCode.MULTIPLE_PERCENT_SYMBOLS;
pub const U_MULTIPLE_PERMILL_SYMBOLS = UErrorCode.MULTIPLE_PERMILL_SYMBOLS;
pub const U_MULTIPLE_PAD_SPECIFIERS = UErrorCode.MULTIPLE_PAD_SPECIFIERS;
pub const U_PATTERN_SYNTAX_ERROR = UErrorCode.PATTERN_SYNTAX_ERROR;
pub const U_ILLEGAL_PAD_POSITION = UErrorCode.ILLEGAL_PAD_POSITION;
pub const U_UNMATCHED_BRACES = UErrorCode.UNMATCHED_BRACES;
pub const U_UNSUPPORTED_PROPERTY = UErrorCode.UNSUPPORTED_PROPERTY;
pub const U_UNSUPPORTED_ATTRIBUTE = UErrorCode.UNSUPPORTED_ATTRIBUTE;
pub const U_ARGUMENT_TYPE_MISMATCH = UErrorCode.ARGUMENT_TYPE_MISMATCH;
pub const U_DUPLICATE_KEYWORD = UErrorCode.DUPLICATE_KEYWORD;
pub const U_UNDEFINED_KEYWORD = UErrorCode.UNDEFINED_KEYWORD;
pub const U_DEFAULT_KEYWORD_MISSING = UErrorCode.DEFAULT_KEYWORD_MISSING;
pub const U_DECIMAL_NUMBER_SYNTAX_ERROR = UErrorCode.DECIMAL_NUMBER_SYNTAX_ERROR;
pub const U_FORMAT_INEXACT_ERROR = UErrorCode.FORMAT_INEXACT_ERROR;
pub const U_NUMBER_ARG_OUTOFBOUNDS_ERROR = UErrorCode.NUMBER_ARG_OUTOFBOUNDS_ERROR;
pub const U_NUMBER_SKELETON_SYNTAX_ERROR = UErrorCode.NUMBER_SKELETON_SYNTAX_ERROR;
pub const U_BRK_INTERNAL_ERROR = UErrorCode.BRK_INTERNAL_ERROR;
pub const U_BRK_ERROR_START = UErrorCode.BRK_INTERNAL_ERROR;
pub const U_BRK_HEX_DIGITS_EXPECTED = UErrorCode.BRK_HEX_DIGITS_EXPECTED;
pub const U_BRK_SEMICOLON_EXPECTED = UErrorCode.BRK_SEMICOLON_EXPECTED;
pub const U_BRK_RULE_SYNTAX = UErrorCode.BRK_RULE_SYNTAX;
pub const U_BRK_UNCLOSED_SET = UErrorCode.BRK_UNCLOSED_SET;
pub const U_BRK_ASSIGN_ERROR = UErrorCode.BRK_ASSIGN_ERROR;
pub const U_BRK_VARIABLE_REDFINITION = UErrorCode.BRK_VARIABLE_REDFINITION;
pub const U_BRK_MISMATCHED_PAREN = UErrorCode.BRK_MISMATCHED_PAREN;
pub const U_BRK_NEW_LINE_IN_QUOTED_STRING = UErrorCode.BRK_NEW_LINE_IN_QUOTED_STRING;
pub const U_BRK_UNDEFINED_VARIABLE = UErrorCode.BRK_UNDEFINED_VARIABLE;
pub const U_BRK_INIT_ERROR = UErrorCode.BRK_INIT_ERROR;
pub const U_BRK_RULE_EMPTY_SET = UErrorCode.BRK_RULE_EMPTY_SET;
pub const U_BRK_UNRECOGNIZED_OPTION = UErrorCode.BRK_UNRECOGNIZED_OPTION;
pub const U_BRK_MALFORMED_RULE_TAG = UErrorCode.BRK_MALFORMED_RULE_TAG;
pub const U_REGEX_INTERNAL_ERROR = UErrorCode.REGEX_INTERNAL_ERROR;
pub const U_REGEX_ERROR_START = UErrorCode.REGEX_INTERNAL_ERROR;
pub const U_REGEX_RULE_SYNTAX = UErrorCode.REGEX_RULE_SYNTAX;
pub const U_REGEX_INVALID_STATE = UErrorCode.REGEX_INVALID_STATE;
pub const U_REGEX_BAD_ESCAPE_SEQUENCE = UErrorCode.REGEX_BAD_ESCAPE_SEQUENCE;
pub const U_REGEX_PROPERTY_SYNTAX = UErrorCode.REGEX_PROPERTY_SYNTAX;
pub const U_REGEX_UNIMPLEMENTED = UErrorCode.REGEX_UNIMPLEMENTED;
pub const U_REGEX_MISMATCHED_PAREN = UErrorCode.REGEX_MISMATCHED_PAREN;
pub const U_REGEX_NUMBER_TOO_BIG = UErrorCode.REGEX_NUMBER_TOO_BIG;
pub const U_REGEX_BAD_INTERVAL = UErrorCode.REGEX_BAD_INTERVAL;
pub const U_REGEX_MAX_LT_MIN = UErrorCode.REGEX_MAX_LT_MIN;
pub const U_REGEX_INVALID_BACK_REF = UErrorCode.REGEX_INVALID_BACK_REF;
pub const U_REGEX_INVALID_FLAG = UErrorCode.REGEX_INVALID_FLAG;
pub const U_REGEX_LOOK_BEHIND_LIMIT = UErrorCode.REGEX_LOOK_BEHIND_LIMIT;
pub const U_REGEX_SET_CONTAINS_STRING = UErrorCode.REGEX_SET_CONTAINS_STRING;
pub const U_REGEX_MISSING_CLOSE_BRACKET = UErrorCode.REGEX_MISSING_CLOSE_BRACKET;
pub const U_REGEX_INVALID_RANGE = UErrorCode.REGEX_INVALID_RANGE;
pub const U_REGEX_STACK_OVERFLOW = UErrorCode.REGEX_STACK_OVERFLOW;
pub const U_REGEX_TIME_OUT = UErrorCode.REGEX_TIME_OUT;
pub const U_REGEX_STOPPED_BY_CALLER = UErrorCode.REGEX_STOPPED_BY_CALLER;
pub const U_REGEX_PATTERN_TOO_BIG = UErrorCode.REGEX_PATTERN_TOO_BIG;
pub const U_REGEX_INVALID_CAPTURE_GROUP_NAME = UErrorCode.REGEX_INVALID_CAPTURE_GROUP_NAME;
pub const U_IDNA_PROHIBITED_ERROR = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_IDNA_ERROR_START = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_IDNA_UNASSIGNED_ERROR = UErrorCode.IDNA_UNASSIGNED_ERROR;
pub const U_IDNA_CHECK_BIDI_ERROR = UErrorCode.IDNA_CHECK_BIDI_ERROR;
pub const U_IDNA_STD3_ASCII_RULES_ERROR = UErrorCode.IDNA_STD3_ASCII_RULES_ERROR;
pub const U_IDNA_ACE_PREFIX_ERROR = UErrorCode.IDNA_ACE_PREFIX_ERROR;
pub const U_IDNA_VERIFICATION_ERROR = UErrorCode.IDNA_VERIFICATION_ERROR;
pub const U_IDNA_LABEL_TOO_LONG_ERROR = UErrorCode.IDNA_LABEL_TOO_LONG_ERROR;
pub const U_IDNA_ZERO_LENGTH_LABEL_ERROR = UErrorCode.IDNA_ZERO_LENGTH_LABEL_ERROR;
pub const U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = UErrorCode.IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
pub const U_STRINGPREP_PROHIBITED_ERROR = UErrorCode.IDNA_PROHIBITED_ERROR;
pub const U_STRINGPREP_UNASSIGNED_ERROR = UErrorCode.IDNA_UNASSIGNED_ERROR;
pub const U_STRINGPREP_CHECK_BIDI_ERROR = UErrorCode.IDNA_CHECK_BIDI_ERROR;
pub const U_PLUGIN_ERROR_START = UErrorCode.PLUGIN_ERROR_START;
pub const U_PLUGIN_TOO_HIGH = UErrorCode.PLUGIN_ERROR_START;
pub const U_PLUGIN_DIDNT_SET_LEVEL = UErrorCode.PLUGIN_DIDNT_SET_LEVEL;

pub const UTraceLevel = enum(i32) {
    OFF = -1,
    ERROR = 0,
    WARNING = 3,
    OPEN_CLOSE = 5,
    INFO = 7,
    VERBOSE = 9,
};
pub const UTRACE_OFF = UTraceLevel.OFF;
pub const UTRACE_ERROR = UTraceLevel.ERROR;
pub const UTRACE_WARNING = UTraceLevel.WARNING;
pub const UTRACE_OPEN_CLOSE = UTraceLevel.OPEN_CLOSE;
pub const UTRACE_INFO = UTraceLevel.INFO;
pub const UTRACE_VERBOSE = UTraceLevel.VERBOSE;

pub const UTraceFunctionNumber = enum(i32) {
    FUNCTION_START = 0,
    // U_INIT = 0, this enum value conflicts with FUNCTION_START
    U_CLEANUP = 1,
    CONVERSION_START = 4096,
    // UCNV_OPEN = 4096, this enum value conflicts with CONVERSION_START
    UCNV_OPEN_PACKAGE = 4097,
    UCNV_OPEN_ALGORITHMIC = 4098,
    UCNV_CLONE = 4099,
    UCNV_CLOSE = 4100,
    UCNV_FLUSH_CACHE = 4101,
    UCNV_LOAD = 4102,
    UCNV_UNLOAD = 4103,
    COLLATION_START = 8192,
    // UCOL_OPEN = 8192, this enum value conflicts with COLLATION_START
    UCOL_CLOSE = 8193,
    UCOL_STRCOLL = 8194,
    UCOL_GET_SORTKEY = 8195,
    UCOL_GETLOCALE = 8196,
    UCOL_NEXTSORTKEYPART = 8197,
    UCOL_STRCOLLITER = 8198,
    UCOL_OPEN_FROM_SHORT_STRING = 8199,
    UCOL_STRCOLLUTF8 = 8200,
    UDATA_START = 12288,
    // UDATA_RESOURCE = 12288, this enum value conflicts with UDATA_START
    UDATA_BUNDLE = 12289,
    UDATA_DATA_FILE = 12290,
    UDATA_RES_FILE = 12291,
};
pub const UTRACE_FUNCTION_START = UTraceFunctionNumber.FUNCTION_START;
pub const UTRACE_U_INIT = UTraceFunctionNumber.FUNCTION_START;
pub const UTRACE_U_CLEANUP = UTraceFunctionNumber.U_CLEANUP;
pub const UTRACE_CONVERSION_START = UTraceFunctionNumber.CONVERSION_START;
pub const UTRACE_UCNV_OPEN = UTraceFunctionNumber.CONVERSION_START;
pub const UTRACE_UCNV_OPEN_PACKAGE = UTraceFunctionNumber.UCNV_OPEN_PACKAGE;
pub const UTRACE_UCNV_OPEN_ALGORITHMIC = UTraceFunctionNumber.UCNV_OPEN_ALGORITHMIC;
pub const UTRACE_UCNV_CLONE = UTraceFunctionNumber.UCNV_CLONE;
pub const UTRACE_UCNV_CLOSE = UTraceFunctionNumber.UCNV_CLOSE;
pub const UTRACE_UCNV_FLUSH_CACHE = UTraceFunctionNumber.UCNV_FLUSH_CACHE;
pub const UTRACE_UCNV_LOAD = UTraceFunctionNumber.UCNV_LOAD;
pub const UTRACE_UCNV_UNLOAD = UTraceFunctionNumber.UCNV_UNLOAD;
pub const UTRACE_COLLATION_START = UTraceFunctionNumber.COLLATION_START;
pub const UTRACE_UCOL_OPEN = UTraceFunctionNumber.COLLATION_START;
pub const UTRACE_UCOL_CLOSE = UTraceFunctionNumber.UCOL_CLOSE;
pub const UTRACE_UCOL_STRCOLL = UTraceFunctionNumber.UCOL_STRCOLL;
pub const UTRACE_UCOL_GET_SORTKEY = UTraceFunctionNumber.UCOL_GET_SORTKEY;
pub const UTRACE_UCOL_GETLOCALE = UTraceFunctionNumber.UCOL_GETLOCALE;
pub const UTRACE_UCOL_NEXTSORTKEYPART = UTraceFunctionNumber.UCOL_NEXTSORTKEYPART;
pub const UTRACE_UCOL_STRCOLLITER = UTraceFunctionNumber.UCOL_STRCOLLITER;
pub const UTRACE_UCOL_OPEN_FROM_SHORT_STRING = UTraceFunctionNumber.UCOL_OPEN_FROM_SHORT_STRING;
pub const UTRACE_UCOL_STRCOLLUTF8 = UTraceFunctionNumber.UCOL_STRCOLLUTF8;
pub const UTRACE_UDATA_START = UTraceFunctionNumber.UDATA_START;
pub const UTRACE_UDATA_RESOURCE = UTraceFunctionNumber.UDATA_START;
pub const UTRACE_UDATA_BUNDLE = UTraceFunctionNumber.UDATA_BUNDLE;
pub const UTRACE_UDATA_DATA_FILE = UTraceFunctionNumber.UDATA_DATA_FILE;
pub const UTRACE_UDATA_RES_FILE = UTraceFunctionNumber.UDATA_RES_FILE;

pub const UTraceEntry = *const fn (
    context: ?*const anyopaque,
    fn_number: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTraceExit = *const fn (
    context: ?*const anyopaque,
    fn_number: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UTraceData = *const fn (
    context: ?*const anyopaque,
    fn_number: i32,
    level: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UStringTrieResult = enum(i32) {
    NO_MATCH = 0,
    NO_VALUE = 1,
    FINAL_VALUE = 2,
    INTERMEDIATE_VALUE = 3,
};
pub const USTRINGTRIE_NO_MATCH = UStringTrieResult.NO_MATCH;
pub const USTRINGTRIE_NO_VALUE = UStringTrieResult.NO_VALUE;
pub const USTRINGTRIE_FINAL_VALUE = UStringTrieResult.FINAL_VALUE;
pub const USTRINGTRIE_INTERMEDIATE_VALUE = UStringTrieResult.INTERMEDIATE_VALUE;

pub const UScriptCode = enum(i32) {
    INVALID_CODE = -1,
    COMMON = 0,
    INHERITED = 1,
    ARABIC = 2,
    ARMENIAN = 3,
    BENGALI = 4,
    BOPOMOFO = 5,
    CHEROKEE = 6,
    COPTIC = 7,
    CYRILLIC = 8,
    DESERET = 9,
    DEVANAGARI = 10,
    ETHIOPIC = 11,
    GEORGIAN = 12,
    GOTHIC = 13,
    GREEK = 14,
    GUJARATI = 15,
    GURMUKHI = 16,
    HAN = 17,
    HANGUL = 18,
    HEBREW = 19,
    HIRAGANA = 20,
    KANNADA = 21,
    KATAKANA = 22,
    KHMER = 23,
    LAO = 24,
    LATIN = 25,
    MALAYALAM = 26,
    MONGOLIAN = 27,
    MYANMAR = 28,
    OGHAM = 29,
    OLD_ITALIC = 30,
    ORIYA = 31,
    RUNIC = 32,
    SINHALA = 33,
    SYRIAC = 34,
    TAMIL = 35,
    TELUGU = 36,
    THAANA = 37,
    THAI = 38,
    TIBETAN = 39,
    CANADIAN_ABORIGINAL = 40,
    // UCAS = 40, this enum value conflicts with CANADIAN_ABORIGINAL
    YI = 41,
    TAGALOG = 42,
    HANUNOO = 43,
    BUHID = 44,
    TAGBANWA = 45,
    BRAILLE = 46,
    CYPRIOT = 47,
    LIMBU = 48,
    LINEAR_B = 49,
    OSMANYA = 50,
    SHAVIAN = 51,
    TAI_LE = 52,
    UGARITIC = 53,
    KATAKANA_OR_HIRAGANA = 54,
    BUGINESE = 55,
    GLAGOLITIC = 56,
    KHAROSHTHI = 57,
    SYLOTI_NAGRI = 58,
    NEW_TAI_LUE = 59,
    TIFINAGH = 60,
    OLD_PERSIAN = 61,
    BALINESE = 62,
    BATAK = 63,
    BLISSYMBOLS = 64,
    BRAHMI = 65,
    CHAM = 66,
    CIRTH = 67,
    OLD_CHURCH_SLAVONIC_CYRILLIC = 68,
    DEMOTIC_EGYPTIAN = 69,
    HIERATIC_EGYPTIAN = 70,
    EGYPTIAN_HIEROGLYPHS = 71,
    KHUTSURI = 72,
    SIMPLIFIED_HAN = 73,
    TRADITIONAL_HAN = 74,
    PAHAWH_HMONG = 75,
    OLD_HUNGARIAN = 76,
    HARAPPAN_INDUS = 77,
    JAVANESE = 78,
    KAYAH_LI = 79,
    LATIN_FRAKTUR = 80,
    LATIN_GAELIC = 81,
    LEPCHA = 82,
    LINEAR_A = 83,
    MANDAIC = 84,
    // MANDAEAN = 84, this enum value conflicts with MANDAIC
    MAYAN_HIEROGLYPHS = 85,
    MEROITIC_HIEROGLYPHS = 86,
    // MEROITIC = 86, this enum value conflicts with MEROITIC_HIEROGLYPHS
    NKO = 87,
    ORKHON = 88,
    OLD_PERMIC = 89,
    PHAGS_PA = 90,
    PHOENICIAN = 91,
    MIAO = 92,
    // PHONETIC_POLLARD = 92, this enum value conflicts with MIAO
    RONGORONGO = 93,
    SARATI = 94,
    ESTRANGELO_SYRIAC = 95,
    WESTERN_SYRIAC = 96,
    EASTERN_SYRIAC = 97,
    TENGWAR = 98,
    VAI = 99,
    VISIBLE_SPEECH = 100,
    CUNEIFORM = 101,
    UNWRITTEN_LANGUAGES = 102,
    UNKNOWN = 103,
    CARIAN = 104,
    JAPANESE = 105,
    LANNA = 106,
    LYCIAN = 107,
    LYDIAN = 108,
    OL_CHIKI = 109,
    REJANG = 110,
    SAURASHTRA = 111,
    SIGN_WRITING = 112,
    SUNDANESE = 113,
    MOON = 114,
    MEITEI_MAYEK = 115,
    IMPERIAL_ARAMAIC = 116,
    AVESTAN = 117,
    CHAKMA = 118,
    KOREAN = 119,
    KAITHI = 120,
    MANICHAEAN = 121,
    INSCRIPTIONAL_PAHLAVI = 122,
    PSALTER_PAHLAVI = 123,
    BOOK_PAHLAVI = 124,
    INSCRIPTIONAL_PARTHIAN = 125,
    SAMARITAN = 126,
    TAI_VIET = 127,
    MATHEMATICAL_NOTATION = 128,
    SYMBOLS = 129,
    BAMUM = 130,
    LISU = 131,
    NAKHI_GEBA = 132,
    OLD_SOUTH_ARABIAN = 133,
    BASSA_VAH = 134,
    DUPLOYAN = 135,
    ELBASAN = 136,
    GRANTHA = 137,
    KPELLE = 138,
    LOMA = 139,
    MENDE = 140,
    MEROITIC_CURSIVE = 141,
    OLD_NORTH_ARABIAN = 142,
    NABATAEAN = 143,
    PALMYRENE = 144,
    KHUDAWADI = 145,
    // SINDHI = 145, this enum value conflicts with KHUDAWADI
    WARANG_CITI = 146,
    AFAKA = 147,
    JURCHEN = 148,
    MRO = 149,
    NUSHU = 150,
    SHARADA = 151,
    SORA_SOMPENG = 152,
    TAKRI = 153,
    TANGUT = 154,
    WOLEAI = 155,
    ANATOLIAN_HIEROGLYPHS = 156,
    KHOJKI = 157,
    TIRHUTA = 158,
    CAUCASIAN_ALBANIAN = 159,
    MAHAJANI = 160,
    AHOM = 161,
    HATRAN = 162,
    MODI = 163,
    MULTANI = 164,
    PAU_CIN_HAU = 165,
    SIDDHAM = 166,
    ADLAM = 167,
    BHAIKSUKI = 168,
    MARCHEN = 169,
    NEWA = 170,
    OSAGE = 171,
    HAN_WITH_BOPOMOFO = 172,
    JAMO = 173,
    SYMBOLS_EMOJI = 174,
    MASARAM_GONDI = 175,
    SOYOMBO = 176,
    ZANABAZAR_SQUARE = 177,
    DOGRA = 178,
    GUNJALA_GONDI = 179,
    MAKASAR = 180,
    MEDEFAIDRIN = 181,
    HANIFI_ROHINGYA = 182,
    SOGDIAN = 183,
    OLD_SOGDIAN = 184,
    ELYMAIC = 185,
    NYIAKENG_PUACHUE_HMONG = 186,
    NANDINAGARI = 187,
    WANCHO = 188,
    CHORASMIAN = 189,
    DIVES_AKURU = 190,
    KHITAN_SMALL_SCRIPT = 191,
    YEZIDI = 192,
};
pub const USCRIPT_INVALID_CODE = UScriptCode.INVALID_CODE;
pub const USCRIPT_COMMON = UScriptCode.COMMON;
pub const USCRIPT_INHERITED = UScriptCode.INHERITED;
pub const USCRIPT_ARABIC = UScriptCode.ARABIC;
pub const USCRIPT_ARMENIAN = UScriptCode.ARMENIAN;
pub const USCRIPT_BENGALI = UScriptCode.BENGALI;
pub const USCRIPT_BOPOMOFO = UScriptCode.BOPOMOFO;
pub const USCRIPT_CHEROKEE = UScriptCode.CHEROKEE;
pub const USCRIPT_COPTIC = UScriptCode.COPTIC;
pub const USCRIPT_CYRILLIC = UScriptCode.CYRILLIC;
pub const USCRIPT_DESERET = UScriptCode.DESERET;
pub const USCRIPT_DEVANAGARI = UScriptCode.DEVANAGARI;
pub const USCRIPT_ETHIOPIC = UScriptCode.ETHIOPIC;
pub const USCRIPT_GEORGIAN = UScriptCode.GEORGIAN;
pub const USCRIPT_GOTHIC = UScriptCode.GOTHIC;
pub const USCRIPT_GREEK = UScriptCode.GREEK;
pub const USCRIPT_GUJARATI = UScriptCode.GUJARATI;
pub const USCRIPT_GURMUKHI = UScriptCode.GURMUKHI;
pub const USCRIPT_HAN = UScriptCode.HAN;
pub const USCRIPT_HANGUL = UScriptCode.HANGUL;
pub const USCRIPT_HEBREW = UScriptCode.HEBREW;
pub const USCRIPT_HIRAGANA = UScriptCode.HIRAGANA;
pub const USCRIPT_KANNADA = UScriptCode.KANNADA;
pub const USCRIPT_KATAKANA = UScriptCode.KATAKANA;
pub const USCRIPT_KHMER = UScriptCode.KHMER;
pub const USCRIPT_LAO = UScriptCode.LAO;
pub const USCRIPT_LATIN = UScriptCode.LATIN;
pub const USCRIPT_MALAYALAM = UScriptCode.MALAYALAM;
pub const USCRIPT_MONGOLIAN = UScriptCode.MONGOLIAN;
pub const USCRIPT_MYANMAR = UScriptCode.MYANMAR;
pub const USCRIPT_OGHAM = UScriptCode.OGHAM;
pub const USCRIPT_OLD_ITALIC = UScriptCode.OLD_ITALIC;
pub const USCRIPT_ORIYA = UScriptCode.ORIYA;
pub const USCRIPT_RUNIC = UScriptCode.RUNIC;
pub const USCRIPT_SINHALA = UScriptCode.SINHALA;
pub const USCRIPT_SYRIAC = UScriptCode.SYRIAC;
pub const USCRIPT_TAMIL = UScriptCode.TAMIL;
pub const USCRIPT_TELUGU = UScriptCode.TELUGU;
pub const USCRIPT_THAANA = UScriptCode.THAANA;
pub const USCRIPT_THAI = UScriptCode.THAI;
pub const USCRIPT_TIBETAN = UScriptCode.TIBETAN;
pub const USCRIPT_CANADIAN_ABORIGINAL = UScriptCode.CANADIAN_ABORIGINAL;
pub const USCRIPT_UCAS = UScriptCode.CANADIAN_ABORIGINAL;
pub const USCRIPT_YI = UScriptCode.YI;
pub const USCRIPT_TAGALOG = UScriptCode.TAGALOG;
pub const USCRIPT_HANUNOO = UScriptCode.HANUNOO;
pub const USCRIPT_BUHID = UScriptCode.BUHID;
pub const USCRIPT_TAGBANWA = UScriptCode.TAGBANWA;
pub const USCRIPT_BRAILLE = UScriptCode.BRAILLE;
pub const USCRIPT_CYPRIOT = UScriptCode.CYPRIOT;
pub const USCRIPT_LIMBU = UScriptCode.LIMBU;
pub const USCRIPT_LINEAR_B = UScriptCode.LINEAR_B;
pub const USCRIPT_OSMANYA = UScriptCode.OSMANYA;
pub const USCRIPT_SHAVIAN = UScriptCode.SHAVIAN;
pub const USCRIPT_TAI_LE = UScriptCode.TAI_LE;
pub const USCRIPT_UGARITIC = UScriptCode.UGARITIC;
pub const USCRIPT_KATAKANA_OR_HIRAGANA = UScriptCode.KATAKANA_OR_HIRAGANA;
pub const USCRIPT_BUGINESE = UScriptCode.BUGINESE;
pub const USCRIPT_GLAGOLITIC = UScriptCode.GLAGOLITIC;
pub const USCRIPT_KHAROSHTHI = UScriptCode.KHAROSHTHI;
pub const USCRIPT_SYLOTI_NAGRI = UScriptCode.SYLOTI_NAGRI;
pub const USCRIPT_NEW_TAI_LUE = UScriptCode.NEW_TAI_LUE;
pub const USCRIPT_TIFINAGH = UScriptCode.TIFINAGH;
pub const USCRIPT_OLD_PERSIAN = UScriptCode.OLD_PERSIAN;
pub const USCRIPT_BALINESE = UScriptCode.BALINESE;
pub const USCRIPT_BATAK = UScriptCode.BATAK;
pub const USCRIPT_BLISSYMBOLS = UScriptCode.BLISSYMBOLS;
pub const USCRIPT_BRAHMI = UScriptCode.BRAHMI;
pub const USCRIPT_CHAM = UScriptCode.CHAM;
pub const USCRIPT_CIRTH = UScriptCode.CIRTH;
pub const USCRIPT_OLD_CHURCH_SLAVONIC_CYRILLIC = UScriptCode.OLD_CHURCH_SLAVONIC_CYRILLIC;
pub const USCRIPT_DEMOTIC_EGYPTIAN = UScriptCode.DEMOTIC_EGYPTIAN;
pub const USCRIPT_HIERATIC_EGYPTIAN = UScriptCode.HIERATIC_EGYPTIAN;
pub const USCRIPT_EGYPTIAN_HIEROGLYPHS = UScriptCode.EGYPTIAN_HIEROGLYPHS;
pub const USCRIPT_KHUTSURI = UScriptCode.KHUTSURI;
pub const USCRIPT_SIMPLIFIED_HAN = UScriptCode.SIMPLIFIED_HAN;
pub const USCRIPT_TRADITIONAL_HAN = UScriptCode.TRADITIONAL_HAN;
pub const USCRIPT_PAHAWH_HMONG = UScriptCode.PAHAWH_HMONG;
pub const USCRIPT_OLD_HUNGARIAN = UScriptCode.OLD_HUNGARIAN;
pub const USCRIPT_HARAPPAN_INDUS = UScriptCode.HARAPPAN_INDUS;
pub const USCRIPT_JAVANESE = UScriptCode.JAVANESE;
pub const USCRIPT_KAYAH_LI = UScriptCode.KAYAH_LI;
pub const USCRIPT_LATIN_FRAKTUR = UScriptCode.LATIN_FRAKTUR;
pub const USCRIPT_LATIN_GAELIC = UScriptCode.LATIN_GAELIC;
pub const USCRIPT_LEPCHA = UScriptCode.LEPCHA;
pub const USCRIPT_LINEAR_A = UScriptCode.LINEAR_A;
pub const USCRIPT_MANDAIC = UScriptCode.MANDAIC;
pub const USCRIPT_MANDAEAN = UScriptCode.MANDAIC;
pub const USCRIPT_MAYAN_HIEROGLYPHS = UScriptCode.MAYAN_HIEROGLYPHS;
pub const USCRIPT_MEROITIC_HIEROGLYPHS = UScriptCode.MEROITIC_HIEROGLYPHS;
pub const USCRIPT_MEROITIC = UScriptCode.MEROITIC_HIEROGLYPHS;
pub const USCRIPT_NKO = UScriptCode.NKO;
pub const USCRIPT_ORKHON = UScriptCode.ORKHON;
pub const USCRIPT_OLD_PERMIC = UScriptCode.OLD_PERMIC;
pub const USCRIPT_PHAGS_PA = UScriptCode.PHAGS_PA;
pub const USCRIPT_PHOENICIAN = UScriptCode.PHOENICIAN;
pub const USCRIPT_MIAO = UScriptCode.MIAO;
pub const USCRIPT_PHONETIC_POLLARD = UScriptCode.MIAO;
pub const USCRIPT_RONGORONGO = UScriptCode.RONGORONGO;
pub const USCRIPT_SARATI = UScriptCode.SARATI;
pub const USCRIPT_ESTRANGELO_SYRIAC = UScriptCode.ESTRANGELO_SYRIAC;
pub const USCRIPT_WESTERN_SYRIAC = UScriptCode.WESTERN_SYRIAC;
pub const USCRIPT_EASTERN_SYRIAC = UScriptCode.EASTERN_SYRIAC;
pub const USCRIPT_TENGWAR = UScriptCode.TENGWAR;
pub const USCRIPT_VAI = UScriptCode.VAI;
pub const USCRIPT_VISIBLE_SPEECH = UScriptCode.VISIBLE_SPEECH;
pub const USCRIPT_CUNEIFORM = UScriptCode.CUNEIFORM;
pub const USCRIPT_UNWRITTEN_LANGUAGES = UScriptCode.UNWRITTEN_LANGUAGES;
pub const USCRIPT_UNKNOWN = UScriptCode.UNKNOWN;
pub const USCRIPT_CARIAN = UScriptCode.CARIAN;
pub const USCRIPT_JAPANESE = UScriptCode.JAPANESE;
pub const USCRIPT_LANNA = UScriptCode.LANNA;
pub const USCRIPT_LYCIAN = UScriptCode.LYCIAN;
pub const USCRIPT_LYDIAN = UScriptCode.LYDIAN;
pub const USCRIPT_OL_CHIKI = UScriptCode.OL_CHIKI;
pub const USCRIPT_REJANG = UScriptCode.REJANG;
pub const USCRIPT_SAURASHTRA = UScriptCode.SAURASHTRA;
pub const USCRIPT_SIGN_WRITING = UScriptCode.SIGN_WRITING;
pub const USCRIPT_SUNDANESE = UScriptCode.SUNDANESE;
pub const USCRIPT_MOON = UScriptCode.MOON;
pub const USCRIPT_MEITEI_MAYEK = UScriptCode.MEITEI_MAYEK;
pub const USCRIPT_IMPERIAL_ARAMAIC = UScriptCode.IMPERIAL_ARAMAIC;
pub const USCRIPT_AVESTAN = UScriptCode.AVESTAN;
pub const USCRIPT_CHAKMA = UScriptCode.CHAKMA;
pub const USCRIPT_KOREAN = UScriptCode.KOREAN;
pub const USCRIPT_KAITHI = UScriptCode.KAITHI;
pub const USCRIPT_MANICHAEAN = UScriptCode.MANICHAEAN;
pub const USCRIPT_INSCRIPTIONAL_PAHLAVI = UScriptCode.INSCRIPTIONAL_PAHLAVI;
pub const USCRIPT_PSALTER_PAHLAVI = UScriptCode.PSALTER_PAHLAVI;
pub const USCRIPT_BOOK_PAHLAVI = UScriptCode.BOOK_PAHLAVI;
pub const USCRIPT_INSCRIPTIONAL_PARTHIAN = UScriptCode.INSCRIPTIONAL_PARTHIAN;
pub const USCRIPT_SAMARITAN = UScriptCode.SAMARITAN;
pub const USCRIPT_TAI_VIET = UScriptCode.TAI_VIET;
pub const USCRIPT_MATHEMATICAL_NOTATION = UScriptCode.MATHEMATICAL_NOTATION;
pub const USCRIPT_SYMBOLS = UScriptCode.SYMBOLS;
pub const USCRIPT_BAMUM = UScriptCode.BAMUM;
pub const USCRIPT_LISU = UScriptCode.LISU;
pub const USCRIPT_NAKHI_GEBA = UScriptCode.NAKHI_GEBA;
pub const USCRIPT_OLD_SOUTH_ARABIAN = UScriptCode.OLD_SOUTH_ARABIAN;
pub const USCRIPT_BASSA_VAH = UScriptCode.BASSA_VAH;
pub const USCRIPT_DUPLOYAN = UScriptCode.DUPLOYAN;
pub const USCRIPT_ELBASAN = UScriptCode.ELBASAN;
pub const USCRIPT_GRANTHA = UScriptCode.GRANTHA;
pub const USCRIPT_KPELLE = UScriptCode.KPELLE;
pub const USCRIPT_LOMA = UScriptCode.LOMA;
pub const USCRIPT_MENDE = UScriptCode.MENDE;
pub const USCRIPT_MEROITIC_CURSIVE = UScriptCode.MEROITIC_CURSIVE;
pub const USCRIPT_OLD_NORTH_ARABIAN = UScriptCode.OLD_NORTH_ARABIAN;
pub const USCRIPT_NABATAEAN = UScriptCode.NABATAEAN;
pub const USCRIPT_PALMYRENE = UScriptCode.PALMYRENE;
pub const USCRIPT_KHUDAWADI = UScriptCode.KHUDAWADI;
pub const USCRIPT_SINDHI = UScriptCode.KHUDAWADI;
pub const USCRIPT_WARANG_CITI = UScriptCode.WARANG_CITI;
pub const USCRIPT_AFAKA = UScriptCode.AFAKA;
pub const USCRIPT_JURCHEN = UScriptCode.JURCHEN;
pub const USCRIPT_MRO = UScriptCode.MRO;
pub const USCRIPT_NUSHU = UScriptCode.NUSHU;
pub const USCRIPT_SHARADA = UScriptCode.SHARADA;
pub const USCRIPT_SORA_SOMPENG = UScriptCode.SORA_SOMPENG;
pub const USCRIPT_TAKRI = UScriptCode.TAKRI;
pub const USCRIPT_TANGUT = UScriptCode.TANGUT;
pub const USCRIPT_WOLEAI = UScriptCode.WOLEAI;
pub const USCRIPT_ANATOLIAN_HIEROGLYPHS = UScriptCode.ANATOLIAN_HIEROGLYPHS;
pub const USCRIPT_KHOJKI = UScriptCode.KHOJKI;
pub const USCRIPT_TIRHUTA = UScriptCode.TIRHUTA;
pub const USCRIPT_CAUCASIAN_ALBANIAN = UScriptCode.CAUCASIAN_ALBANIAN;
pub const USCRIPT_MAHAJANI = UScriptCode.MAHAJANI;
pub const USCRIPT_AHOM = UScriptCode.AHOM;
pub const USCRIPT_HATRAN = UScriptCode.HATRAN;
pub const USCRIPT_MODI = UScriptCode.MODI;
pub const USCRIPT_MULTANI = UScriptCode.MULTANI;
pub const USCRIPT_PAU_CIN_HAU = UScriptCode.PAU_CIN_HAU;
pub const USCRIPT_SIDDHAM = UScriptCode.SIDDHAM;
pub const USCRIPT_ADLAM = UScriptCode.ADLAM;
pub const USCRIPT_BHAIKSUKI = UScriptCode.BHAIKSUKI;
pub const USCRIPT_MARCHEN = UScriptCode.MARCHEN;
pub const USCRIPT_NEWA = UScriptCode.NEWA;
pub const USCRIPT_OSAGE = UScriptCode.OSAGE;
pub const USCRIPT_HAN_WITH_BOPOMOFO = UScriptCode.HAN_WITH_BOPOMOFO;
pub const USCRIPT_JAMO = UScriptCode.JAMO;
pub const USCRIPT_SYMBOLS_EMOJI = UScriptCode.SYMBOLS_EMOJI;
pub const USCRIPT_MASARAM_GONDI = UScriptCode.MASARAM_GONDI;
pub const USCRIPT_SOYOMBO = UScriptCode.SOYOMBO;
pub const USCRIPT_ZANABAZAR_SQUARE = UScriptCode.ZANABAZAR_SQUARE;
pub const USCRIPT_DOGRA = UScriptCode.DOGRA;
pub const USCRIPT_GUNJALA_GONDI = UScriptCode.GUNJALA_GONDI;
pub const USCRIPT_MAKASAR = UScriptCode.MAKASAR;
pub const USCRIPT_MEDEFAIDRIN = UScriptCode.MEDEFAIDRIN;
pub const USCRIPT_HANIFI_ROHINGYA = UScriptCode.HANIFI_ROHINGYA;
pub const USCRIPT_SOGDIAN = UScriptCode.SOGDIAN;
pub const USCRIPT_OLD_SOGDIAN = UScriptCode.OLD_SOGDIAN;
pub const USCRIPT_ELYMAIC = UScriptCode.ELYMAIC;
pub const USCRIPT_NYIAKENG_PUACHUE_HMONG = UScriptCode.NYIAKENG_PUACHUE_HMONG;
pub const USCRIPT_NANDINAGARI = UScriptCode.NANDINAGARI;
pub const USCRIPT_WANCHO = UScriptCode.WANCHO;
pub const USCRIPT_CHORASMIAN = UScriptCode.CHORASMIAN;
pub const USCRIPT_DIVES_AKURU = UScriptCode.DIVES_AKURU;
pub const USCRIPT_KHITAN_SMALL_SCRIPT = UScriptCode.KHITAN_SMALL_SCRIPT;
pub const USCRIPT_YEZIDI = UScriptCode.YEZIDI;

pub const UScriptUsage = enum(i32) {
    NOT_ENCODED = 0,
    UNKNOWN = 1,
    EXCLUDED = 2,
    LIMITED_USE = 3,
    ASPIRATIONAL = 4,
    RECOMMENDED = 5,
};
pub const USCRIPT_USAGE_NOT_ENCODED = UScriptUsage.NOT_ENCODED;
pub const USCRIPT_USAGE_UNKNOWN = UScriptUsage.UNKNOWN;
pub const USCRIPT_USAGE_EXCLUDED = UScriptUsage.EXCLUDED;
pub const USCRIPT_USAGE_LIMITED_USE = UScriptUsage.LIMITED_USE;
pub const USCRIPT_USAGE_ASPIRATIONAL = UScriptUsage.ASPIRATIONAL;
pub const USCRIPT_USAGE_RECOMMENDED = UScriptUsage.RECOMMENDED;

pub const UReplaceableCallbacks = extern struct {
    length: isize,
    charAt: isize,
    char32At: isize,
    replace: isize,
    extract: isize,
    copy: isize,
};

pub const UFieldPosition = extern struct {
    field: i32,
    beginIndex: i32,
    endIndex: i32,
};

pub const UCharIteratorOrigin = enum(i32) {
    START = 0,
    CURRENT = 1,
    LIMIT = 2,
    ZERO = 3,
    LENGTH = 4,
};
pub const UITER_START = UCharIteratorOrigin.START;
pub const UITER_CURRENT = UCharIteratorOrigin.CURRENT;
pub const UITER_LIMIT = UCharIteratorOrigin.LIMIT;
pub const UITER_ZERO = UCharIteratorOrigin.ZERO;
pub const UITER_LENGTH = UCharIteratorOrigin.LENGTH;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorGetIndex = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorMove = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorHasNext = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorHasPrevious = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorCurrent = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorNext = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorPrevious = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorReserved = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorGetState = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UCharIteratorSetState = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const UCharIterator = extern struct {
    context: ?*const anyopaque,
    length: i32,
    start: i32,
    index: i32,
    limit: i32,
    reservedField: i32,
    getIndex: ?UCharIteratorGetIndex,
    move: ?UCharIteratorMove,
    hasNext: ?UCharIteratorHasNext,
    hasPrevious: ?UCharIteratorHasPrevious,
    current: ?UCharIteratorCurrent,
    next: ?UCharIteratorNext,
    previous: ?UCharIteratorPrevious,
    reservedFn: ?UCharIteratorReserved,
    getState: ?UCharIteratorGetState,
    setState: ?UCharIteratorSetState,
};

pub const UEnumeration = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const ULocDataLocaleType = enum(i32) {
    ACTUAL_LOCALE = 0,
    VALID_LOCALE = 1,
};
pub const ULOC_ACTUAL_LOCALE = ULocDataLocaleType.ACTUAL_LOCALE;
pub const ULOC_VALID_LOCALE = ULocDataLocaleType.VALID_LOCALE;

pub const ULocAvailableType = enum(i32) {
    DEFAULT = 0,
    ONLY_LEGACY_ALIASES = 1,
    WITH_LEGACY_ALIASES = 2,
};
pub const ULOC_AVAILABLE_DEFAULT = ULocAvailableType.DEFAULT;
pub const ULOC_AVAILABLE_ONLY_LEGACY_ALIASES = ULocAvailableType.ONLY_LEGACY_ALIASES;
pub const ULOC_AVAILABLE_WITH_LEGACY_ALIASES = ULocAvailableType.WITH_LEGACY_ALIASES;

pub const ULayoutType = enum(i32) {
    LTR = 0,
    RTL = 1,
    TTB = 2,
    BTT = 3,
    UNKNOWN = 4,
};
pub const ULOC_LAYOUT_LTR = ULayoutType.LTR;
pub const ULOC_LAYOUT_RTL = ULayoutType.RTL;
pub const ULOC_LAYOUT_TTB = ULayoutType.TTB;
pub const ULOC_LAYOUT_BTT = ULayoutType.BTT;
pub const ULOC_LAYOUT_UNKNOWN = ULayoutType.UNKNOWN;

pub const UAcceptResult = enum(i32) {
    FAILED = 0,
    VALID = 1,
    FALLBACK = 2,
};
pub const ULOC_ACCEPT_FAILED = UAcceptResult.FAILED;
pub const ULOC_ACCEPT_VALID = UAcceptResult.VALID;
pub const ULOC_ACCEPT_FALLBACK = UAcceptResult.FALLBACK;

pub const UResourceBundle = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UResType = enum(i32) {
    NONE = -1,
    STRING = 0,
    BINARY = 1,
    TABLE = 2,
    ALIAS = 3,
    INT = 7,
    ARRAY = 8,
    INT_VECTOR = 14,
};
pub const URES_NONE = UResType.NONE;
pub const URES_STRING = UResType.STRING;
pub const URES_BINARY = UResType.BINARY;
pub const URES_TABLE = UResType.TABLE;
pub const URES_ALIAS = UResType.ALIAS;
pub const URES_INT = UResType.INT;
pub const URES_ARRAY = UResType.ARRAY;
pub const URES_INT_VECTOR = UResType.INT_VECTOR;

pub const UDisplayContextType = enum(i32) {
    DIALECT_HANDLING = 0,
    CAPITALIZATION = 1,
    DISPLAY_LENGTH = 2,
    SUBSTITUTE_HANDLING = 3,
};
pub const UDISPCTX_TYPE_DIALECT_HANDLING = UDisplayContextType.DIALECT_HANDLING;
pub const UDISPCTX_TYPE_CAPITALIZATION = UDisplayContextType.CAPITALIZATION;
pub const UDISPCTX_TYPE_DISPLAY_LENGTH = UDisplayContextType.DISPLAY_LENGTH;
pub const UDISPCTX_TYPE_SUBSTITUTE_HANDLING = UDisplayContextType.SUBSTITUTE_HANDLING;

pub const UDisplayContext = enum(i32) {
    STANDARD_NAMES = 0,
    DIALECT_NAMES = 1,
    CAPITALIZATION_NONE = 256,
    CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    CAPITALIZATION_FOR_STANDALONE = 260,
    LENGTH_FULL = 512,
    LENGTH_SHORT = 513,
    SUBSTITUTE = 768,
    NO_SUBSTITUTE = 769,
};
pub const UDISPCTX_STANDARD_NAMES = UDisplayContext.STANDARD_NAMES;
pub const UDISPCTX_DIALECT_NAMES = UDisplayContext.DIALECT_NAMES;
pub const UDISPCTX_CAPITALIZATION_NONE = UDisplayContext.CAPITALIZATION_NONE;
pub const UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = UDisplayContext.CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE;
pub const UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = UDisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE;
pub const UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = UDisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU;
pub const UDISPCTX_CAPITALIZATION_FOR_STANDALONE = UDisplayContext.CAPITALIZATION_FOR_STANDALONE;
pub const UDISPCTX_LENGTH_FULL = UDisplayContext.LENGTH_FULL;
pub const UDISPCTX_LENGTH_SHORT = UDisplayContext.LENGTH_SHORT;
pub const UDISPCTX_SUBSTITUTE = UDisplayContext.SUBSTITUTE;
pub const UDISPCTX_NO_SUBSTITUTE = UDisplayContext.NO_SUBSTITUTE;

pub const UDialectHandling = enum(i32) {
    STANDARD_NAMES = 0,
    DIALECT_NAMES = 1,
};
pub const ULDN_STANDARD_NAMES = UDialectHandling.STANDARD_NAMES;
pub const ULDN_DIALECT_NAMES = UDialectHandling.DIALECT_NAMES;

pub const ULocaleDisplayNames = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCurrencyUsage = enum(i32) {
    STANDARD = 0,
    CASH = 1,
};
pub const UCURR_USAGE_STANDARD = UCurrencyUsage.STANDARD;
pub const UCURR_USAGE_CASH = UCurrencyUsage.CASH;

pub const UCurrNameStyle = enum(i32) {
    SYMBOL_NAME = 0,
    LONG_NAME = 1,
    NARROW_SYMBOL_NAME = 2,
};
pub const UCURR_SYMBOL_NAME = UCurrNameStyle.SYMBOL_NAME;
pub const UCURR_LONG_NAME = UCurrNameStyle.LONG_NAME;
pub const UCURR_NARROW_SYMBOL_NAME = UCurrNameStyle.NARROW_SYMBOL_NAME;

pub const UCurrCurrencyType = enum(i32) {
    ALL = 2147483647,
    COMMON = 1,
    UNCOMMON = 2,
    DEPRECATED = 4,
    NON_DEPRECATED = 8,
};
pub const UCURR_ALL = UCurrCurrencyType.ALL;
pub const UCURR_COMMON = UCurrCurrencyType.COMMON;
pub const UCURR_UNCOMMON = UCurrCurrencyType.UNCOMMON;
pub const UCURR_DEPRECATED = UCurrCurrencyType.DEPRECATED;
pub const UCURR_NON_DEPRECATED = UCurrCurrencyType.NON_DEPRECATED;

pub const UCPMap = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCPMapRangeOption = enum(i32) {
    NORMAL = 0,
    FIXED_LEAD_SURROGATES = 1,
    FIXED_ALL_SURROGATES = 2,
};
pub const UCPMAP_RANGE_NORMAL = UCPMapRangeOption.NORMAL;
pub const UCPMAP_RANGE_FIXED_LEAD_SURROGATES = UCPMapRangeOption.FIXED_LEAD_SURROGATES;
pub const UCPMAP_RANGE_FIXED_ALL_SURROGATES = UCPMapRangeOption.FIXED_ALL_SURROGATES;

pub const UCPMapValueFilter = *const fn (
    context: ?*const anyopaque,
    value: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const UCPTrieData = extern union {
    ptr0: ?*const anyopaque,
    ptr16: ?*const u16,
    ptr32: ?*const u32,
    ptr8: ?*const u8,
};

pub const UCPTrie = extern struct {
    index: ?*const u16,
    data: UCPTrieData,
    indexLength: i32,
    dataLength: i32,
    highStart: i32,
    shifted12HighStart: u16,
    type: i8,
    valueWidth: i8,
    reserved32: u32,
    reserved16: u16,
    index3NullOffset: u16,
    dataNullOffset: i32,
    nullValue: u32,
};

pub const UCPTrieType = enum(i32) {
    ANY = -1,
    FAST = 0,
    SMALL = 1,
};
pub const UCPTRIE_TYPE_ANY = UCPTrieType.ANY;
pub const UCPTRIE_TYPE_FAST = UCPTrieType.FAST;
pub const UCPTRIE_TYPE_SMALL = UCPTrieType.SMALL;

pub const UCPTrieValueWidth = enum(i32) {
    ANY = -1,
    @"16" = 0,
    @"32" = 1,
    @"8" = 2,
};
pub const UCPTRIE_VALUE_BITS_ANY = UCPTrieValueWidth.ANY;
pub const UCPTRIE_VALUE_BITS_16 = UCPTrieValueWidth.@"16";
pub const UCPTRIE_VALUE_BITS_32 = UCPTrieValueWidth.@"32";
pub const UCPTRIE_VALUE_BITS_8 = UCPTrieValueWidth.@"8";

pub const UMutableCPTrie = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UConverter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UConverterCallbackReason = enum(i32) {
    UNASSIGNED = 0,
    ILLEGAL = 1,
    IRREGULAR = 2,
    RESET = 3,
    CLOSE = 4,
    CLONE = 5,
};
pub const UCNV_UNASSIGNED = UConverterCallbackReason.UNASSIGNED;
pub const UCNV_ILLEGAL = UConverterCallbackReason.ILLEGAL;
pub const UCNV_IRREGULAR = UConverterCallbackReason.IRREGULAR;
pub const UCNV_RESET = UConverterCallbackReason.RESET;
pub const UCNV_CLOSE = UConverterCallbackReason.CLOSE;
pub const UCNV_CLONE = UConverterCallbackReason.CLONE;

pub const UConverterFromUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?*const u16,
    sourceLimit: ?*const u16,
    target: ?PSTR,
    targetLimit: ?[*:0]const u8,
    offsets: ?*i32,
};

pub const UConverterToUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?[*:0]const u8,
    sourceLimit: ?[*:0]const u8,
    target: ?*u16,
    targetLimit: ?*const u16,
    offsets: ?*i32,
};

pub const USet = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UConverterType = enum(i32) {
    UNSUPPORTED_CONVERTER = -1,
    SBCS = 0,
    DBCS = 1,
    MBCS = 2,
    LATIN_1 = 3,
    UTF8 = 4,
    UTF16_BigEndian = 5,
    UTF16_LittleEndian = 6,
    UTF32_BigEndian = 7,
    UTF32_LittleEndian = 8,
    EBCDIC_STATEFUL = 9,
    ISO_2022 = 10,
    LMBCS_1 = 11,
    LMBCS_2 = 12,
    LMBCS_3 = 13,
    LMBCS_4 = 14,
    LMBCS_5 = 15,
    LMBCS_6 = 16,
    LMBCS_8 = 17,
    LMBCS_11 = 18,
    LMBCS_16 = 19,
    LMBCS_17 = 20,
    LMBCS_18 = 21,
    LMBCS_19 = 22,
    // LMBCS_LAST = 22, this enum value conflicts with LMBCS_19
    HZ = 23,
    SCSU = 24,
    ISCII = 25,
    US_ASCII = 26,
    UTF7 = 27,
    BOCU1 = 28,
    UTF16 = 29,
    UTF32 = 30,
    CESU8 = 31,
    IMAP_MAILBOX = 32,
    COMPOUND_TEXT = 33,
    NUMBER_OF_SUPPORTED_CONVERTER_TYPES = 34,
};
pub const UCNV_UNSUPPORTED_CONVERTER = UConverterType.UNSUPPORTED_CONVERTER;
pub const UCNV_SBCS = UConverterType.SBCS;
pub const UCNV_DBCS = UConverterType.DBCS;
pub const UCNV_MBCS = UConverterType.MBCS;
pub const UCNV_LATIN_1 = UConverterType.LATIN_1;
pub const UCNV_UTF8 = UConverterType.UTF8;
pub const UCNV_UTF16_BigEndian = UConverterType.UTF16_BigEndian;
pub const UCNV_UTF16_LittleEndian = UConverterType.UTF16_LittleEndian;
pub const UCNV_UTF32_BigEndian = UConverterType.UTF32_BigEndian;
pub const UCNV_UTF32_LittleEndian = UConverterType.UTF32_LittleEndian;
pub const UCNV_EBCDIC_STATEFUL = UConverterType.EBCDIC_STATEFUL;
pub const UCNV_ISO_2022 = UConverterType.ISO_2022;
pub const UCNV_LMBCS_1 = UConverterType.LMBCS_1;
pub const UCNV_LMBCS_2 = UConverterType.LMBCS_2;
pub const UCNV_LMBCS_3 = UConverterType.LMBCS_3;
pub const UCNV_LMBCS_4 = UConverterType.LMBCS_4;
pub const UCNV_LMBCS_5 = UConverterType.LMBCS_5;
pub const UCNV_LMBCS_6 = UConverterType.LMBCS_6;
pub const UCNV_LMBCS_8 = UConverterType.LMBCS_8;
pub const UCNV_LMBCS_11 = UConverterType.LMBCS_11;
pub const UCNV_LMBCS_16 = UConverterType.LMBCS_16;
pub const UCNV_LMBCS_17 = UConverterType.LMBCS_17;
pub const UCNV_LMBCS_18 = UConverterType.LMBCS_18;
pub const UCNV_LMBCS_19 = UConverterType.LMBCS_19;
pub const UCNV_LMBCS_LAST = UConverterType.LMBCS_19;
pub const UCNV_HZ = UConverterType.HZ;
pub const UCNV_SCSU = UConverterType.SCSU;
pub const UCNV_ISCII = UConverterType.ISCII;
pub const UCNV_US_ASCII = UConverterType.US_ASCII;
pub const UCNV_UTF7 = UConverterType.UTF7;
pub const UCNV_BOCU1 = UConverterType.BOCU1;
pub const UCNV_UTF16 = UConverterType.UTF16;
pub const UCNV_UTF32 = UConverterType.UTF32;
pub const UCNV_CESU8 = UConverterType.CESU8;
pub const UCNV_IMAP_MAILBOX = UConverterType.IMAP_MAILBOX;
pub const UCNV_COMPOUND_TEXT = UConverterType.COMPOUND_TEXT;
pub const UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES = UConverterType.NUMBER_OF_SUPPORTED_CONVERTER_TYPES;

pub const UConverterPlatform = enum(i32) {
    UNKNOWN = -1,
    IBM = 0,
};
pub const UCNV_UNKNOWN = UConverterPlatform.UNKNOWN;
pub const UCNV_IBM = UConverterPlatform.IBM;

pub const UConverterToUCallback = *const fn (
    context: ?*const anyopaque,
    args: ?*UConverterToUnicodeArgs,
    code_units: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UConverterFromUCallback = *const fn (
    context: ?*const anyopaque,
    args: ?*UConverterFromUnicodeArgs,
    code_units: ?*const u16,
    length: i32,
    code_point: i32,
    reason: UConverterCallbackReason,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UConverterUnicodeSet = enum(i32) {
    SET = 0,
    AND_FALLBACK_SET = 1,
};
pub const UCNV_ROUNDTRIP_SET = UConverterUnicodeSet.SET;
pub const UCNV_ROUNDTRIP_AND_FALLBACK_SET = UConverterUnicodeSet.AND_FALLBACK_SET;

pub const UMemAllocFn = *const fn (
    context: ?*const anyopaque,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const UMemReallocFn = *const fn (
    context: ?*const anyopaque,
    mem: ?*anyopaque,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const UMemFreeFn = *const fn (
    context: ?*const anyopaque,
    mem: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const UProperty = enum(i32) {
    ALPHABETIC = 0,
    // BINARY_START = 0, this enum value conflicts with ALPHABETIC
    ASCII_HEX_DIGIT = 1,
    BIDI_CONTROL = 2,
    BIDI_MIRRORED = 3,
    DASH = 4,
    DEFAULT_IGNORABLE_CODE_POINT = 5,
    DEPRECATED = 6,
    DIACRITIC = 7,
    EXTENDER = 8,
    FULL_COMPOSITION_EXCLUSION = 9,
    GRAPHEME_BASE = 10,
    GRAPHEME_EXTEND = 11,
    GRAPHEME_LINK = 12,
    HEX_DIGIT = 13,
    HYPHEN = 14,
    ID_CONTINUE = 15,
    ID_START = 16,
    IDEOGRAPHIC = 17,
    IDS_BINARY_OPERATOR = 18,
    IDS_TRINARY_OPERATOR = 19,
    JOIN_CONTROL = 20,
    LOGICAL_ORDER_EXCEPTION = 21,
    LOWERCASE = 22,
    MATH = 23,
    NONCHARACTER_CODE_POINT = 24,
    QUOTATION_MARK = 25,
    RADICAL = 26,
    SOFT_DOTTED = 27,
    TERMINAL_PUNCTUATION = 28,
    UNIFIED_IDEOGRAPH = 29,
    UPPERCASE = 30,
    WHITE_SPACE = 31,
    XID_CONTINUE = 32,
    XID_START = 33,
    CASE_SENSITIVE = 34,
    S_TERM = 35,
    VARIATION_SELECTOR = 36,
    NFD_INERT = 37,
    NFKD_INERT = 38,
    NFC_INERT = 39,
    NFKC_INERT = 40,
    SEGMENT_STARTER = 41,
    PATTERN_SYNTAX = 42,
    PATTERN_WHITE_SPACE = 43,
    POSIX_ALNUM = 44,
    POSIX_BLANK = 45,
    POSIX_GRAPH = 46,
    POSIX_PRINT = 47,
    POSIX_XDIGIT = 48,
    CASED = 49,
    CASE_IGNORABLE = 50,
    CHANGES_WHEN_LOWERCASED = 51,
    CHANGES_WHEN_UPPERCASED = 52,
    CHANGES_WHEN_TITLECASED = 53,
    CHANGES_WHEN_CASEFOLDED = 54,
    CHANGES_WHEN_CASEMAPPED = 55,
    CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    EMOJI = 57,
    EMOJI_PRESENTATION = 58,
    EMOJI_MODIFIER = 59,
    EMOJI_MODIFIER_BASE = 60,
    EMOJI_COMPONENT = 61,
    REGIONAL_INDICATOR = 62,
    PREPENDED_CONCATENATION_MARK = 63,
    EXTENDED_PICTOGRAPHIC = 64,
    BIDI_CLASS = 4096,
    // INT_START = 4096, this enum value conflicts with BIDI_CLASS
    BLOCK = 4097,
    CANONICAL_COMBINING_CLASS = 4098,
    DECOMPOSITION_TYPE = 4099,
    EAST_ASIAN_WIDTH = 4100,
    GENERAL_CATEGORY = 4101,
    JOINING_GROUP = 4102,
    JOINING_TYPE = 4103,
    LINE_BREAK = 4104,
    NUMERIC_TYPE = 4105,
    SCRIPT = 4106,
    HANGUL_SYLLABLE_TYPE = 4107,
    NFD_QUICK_CHECK = 4108,
    NFKD_QUICK_CHECK = 4109,
    NFC_QUICK_CHECK = 4110,
    NFKC_QUICK_CHECK = 4111,
    LEAD_CANONICAL_COMBINING_CLASS = 4112,
    TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    GRAPHEME_CLUSTER_BREAK = 4114,
    SENTENCE_BREAK = 4115,
    WORD_BREAK = 4116,
    BIDI_PAIRED_BRACKET_TYPE = 4117,
    INDIC_POSITIONAL_CATEGORY = 4118,
    INDIC_SYLLABIC_CATEGORY = 4119,
    VERTICAL_ORIENTATION = 4120,
    GENERAL_CATEGORY_MASK = 8192,
    // MASK_START = 8192, this enum value conflicts with GENERAL_CATEGORY_MASK
    NUMERIC_VALUE = 12288,
    // DOUBLE_START = 12288, this enum value conflicts with NUMERIC_VALUE
    AGE = 16384,
    // STRING_START = 16384, this enum value conflicts with AGE
    BIDI_MIRRORING_GLYPH = 16385,
    CASE_FOLDING = 16386,
    LOWERCASE_MAPPING = 16388,
    NAME = 16389,
    SIMPLE_CASE_FOLDING = 16390,
    SIMPLE_LOWERCASE_MAPPING = 16391,
    SIMPLE_TITLECASE_MAPPING = 16392,
    SIMPLE_UPPERCASE_MAPPING = 16393,
    TITLECASE_MAPPING = 16394,
    UPPERCASE_MAPPING = 16396,
    BIDI_PAIRED_BRACKET = 16397,
    SCRIPT_EXTENSIONS = 28672,
    // OTHER_PROPERTY_START = 28672, this enum value conflicts with SCRIPT_EXTENSIONS
    INVALID_CODE = -1,
};
pub const UCHAR_ALPHABETIC = UProperty.ALPHABETIC;
pub const UCHAR_BINARY_START = UProperty.ALPHABETIC;
pub const UCHAR_ASCII_HEX_DIGIT = UProperty.ASCII_HEX_DIGIT;
pub const UCHAR_BIDI_CONTROL = UProperty.BIDI_CONTROL;
pub const UCHAR_BIDI_MIRRORED = UProperty.BIDI_MIRRORED;
pub const UCHAR_DASH = UProperty.DASH;
pub const UCHAR_DEFAULT_IGNORABLE_CODE_POINT = UProperty.DEFAULT_IGNORABLE_CODE_POINT;
pub const UCHAR_DEPRECATED = UProperty.DEPRECATED;
pub const UCHAR_DIACRITIC = UProperty.DIACRITIC;
pub const UCHAR_EXTENDER = UProperty.EXTENDER;
pub const UCHAR_FULL_COMPOSITION_EXCLUSION = UProperty.FULL_COMPOSITION_EXCLUSION;
pub const UCHAR_GRAPHEME_BASE = UProperty.GRAPHEME_BASE;
pub const UCHAR_GRAPHEME_EXTEND = UProperty.GRAPHEME_EXTEND;
pub const UCHAR_GRAPHEME_LINK = UProperty.GRAPHEME_LINK;
pub const UCHAR_HEX_DIGIT = UProperty.HEX_DIGIT;
pub const UCHAR_HYPHEN = UProperty.HYPHEN;
pub const UCHAR_ID_CONTINUE = UProperty.ID_CONTINUE;
pub const UCHAR_ID_START = UProperty.ID_START;
pub const UCHAR_IDEOGRAPHIC = UProperty.IDEOGRAPHIC;
pub const UCHAR_IDS_BINARY_OPERATOR = UProperty.IDS_BINARY_OPERATOR;
pub const UCHAR_IDS_TRINARY_OPERATOR = UProperty.IDS_TRINARY_OPERATOR;
pub const UCHAR_JOIN_CONTROL = UProperty.JOIN_CONTROL;
pub const UCHAR_LOGICAL_ORDER_EXCEPTION = UProperty.LOGICAL_ORDER_EXCEPTION;
pub const UCHAR_LOWERCASE = UProperty.LOWERCASE;
pub const UCHAR_MATH = UProperty.MATH;
pub const UCHAR_NONCHARACTER_CODE_POINT = UProperty.NONCHARACTER_CODE_POINT;
pub const UCHAR_QUOTATION_MARK = UProperty.QUOTATION_MARK;
pub const UCHAR_RADICAL = UProperty.RADICAL;
pub const UCHAR_SOFT_DOTTED = UProperty.SOFT_DOTTED;
pub const UCHAR_TERMINAL_PUNCTUATION = UProperty.TERMINAL_PUNCTUATION;
pub const UCHAR_UNIFIED_IDEOGRAPH = UProperty.UNIFIED_IDEOGRAPH;
pub const UCHAR_UPPERCASE = UProperty.UPPERCASE;
pub const UCHAR_WHITE_SPACE = UProperty.WHITE_SPACE;
pub const UCHAR_XID_CONTINUE = UProperty.XID_CONTINUE;
pub const UCHAR_XID_START = UProperty.XID_START;
pub const UCHAR_CASE_SENSITIVE = UProperty.CASE_SENSITIVE;
pub const UCHAR_S_TERM = UProperty.S_TERM;
pub const UCHAR_VARIATION_SELECTOR = UProperty.VARIATION_SELECTOR;
pub const UCHAR_NFD_INERT = UProperty.NFD_INERT;
pub const UCHAR_NFKD_INERT = UProperty.NFKD_INERT;
pub const UCHAR_NFC_INERT = UProperty.NFC_INERT;
pub const UCHAR_NFKC_INERT = UProperty.NFKC_INERT;
pub const UCHAR_SEGMENT_STARTER = UProperty.SEGMENT_STARTER;
pub const UCHAR_PATTERN_SYNTAX = UProperty.PATTERN_SYNTAX;
pub const UCHAR_PATTERN_WHITE_SPACE = UProperty.PATTERN_WHITE_SPACE;
pub const UCHAR_POSIX_ALNUM = UProperty.POSIX_ALNUM;
pub const UCHAR_POSIX_BLANK = UProperty.POSIX_BLANK;
pub const UCHAR_POSIX_GRAPH = UProperty.POSIX_GRAPH;
pub const UCHAR_POSIX_PRINT = UProperty.POSIX_PRINT;
pub const UCHAR_POSIX_XDIGIT = UProperty.POSIX_XDIGIT;
pub const UCHAR_CASED = UProperty.CASED;
pub const UCHAR_CASE_IGNORABLE = UProperty.CASE_IGNORABLE;
pub const UCHAR_CHANGES_WHEN_LOWERCASED = UProperty.CHANGES_WHEN_LOWERCASED;
pub const UCHAR_CHANGES_WHEN_UPPERCASED = UProperty.CHANGES_WHEN_UPPERCASED;
pub const UCHAR_CHANGES_WHEN_TITLECASED = UProperty.CHANGES_WHEN_TITLECASED;
pub const UCHAR_CHANGES_WHEN_CASEFOLDED = UProperty.CHANGES_WHEN_CASEFOLDED;
pub const UCHAR_CHANGES_WHEN_CASEMAPPED = UProperty.CHANGES_WHEN_CASEMAPPED;
pub const UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = UProperty.CHANGES_WHEN_NFKC_CASEFOLDED;
pub const UCHAR_EMOJI = UProperty.EMOJI;
pub const UCHAR_EMOJI_PRESENTATION = UProperty.EMOJI_PRESENTATION;
pub const UCHAR_EMOJI_MODIFIER = UProperty.EMOJI_MODIFIER;
pub const UCHAR_EMOJI_MODIFIER_BASE = UProperty.EMOJI_MODIFIER_BASE;
pub const UCHAR_EMOJI_COMPONENT = UProperty.EMOJI_COMPONENT;
pub const UCHAR_REGIONAL_INDICATOR = UProperty.REGIONAL_INDICATOR;
pub const UCHAR_PREPENDED_CONCATENATION_MARK = UProperty.PREPENDED_CONCATENATION_MARK;
pub const UCHAR_EXTENDED_PICTOGRAPHIC = UProperty.EXTENDED_PICTOGRAPHIC;
pub const UCHAR_BIDI_CLASS = UProperty.BIDI_CLASS;
pub const UCHAR_INT_START = UProperty.BIDI_CLASS;
pub const UCHAR_BLOCK = UProperty.BLOCK;
pub const UCHAR_CANONICAL_COMBINING_CLASS = UProperty.CANONICAL_COMBINING_CLASS;
pub const UCHAR_DECOMPOSITION_TYPE = UProperty.DECOMPOSITION_TYPE;
pub const UCHAR_EAST_ASIAN_WIDTH = UProperty.EAST_ASIAN_WIDTH;
pub const UCHAR_GENERAL_CATEGORY = UProperty.GENERAL_CATEGORY;
pub const UCHAR_JOINING_GROUP = UProperty.JOINING_GROUP;
pub const UCHAR_JOINING_TYPE = UProperty.JOINING_TYPE;
pub const UCHAR_LINE_BREAK = UProperty.LINE_BREAK;
pub const UCHAR_NUMERIC_TYPE = UProperty.NUMERIC_TYPE;
pub const UCHAR_SCRIPT = UProperty.SCRIPT;
pub const UCHAR_HANGUL_SYLLABLE_TYPE = UProperty.HANGUL_SYLLABLE_TYPE;
pub const UCHAR_NFD_QUICK_CHECK = UProperty.NFD_QUICK_CHECK;
pub const UCHAR_NFKD_QUICK_CHECK = UProperty.NFKD_QUICK_CHECK;
pub const UCHAR_NFC_QUICK_CHECK = UProperty.NFC_QUICK_CHECK;
pub const UCHAR_NFKC_QUICK_CHECK = UProperty.NFKC_QUICK_CHECK;
pub const UCHAR_LEAD_CANONICAL_COMBINING_CLASS = UProperty.LEAD_CANONICAL_COMBINING_CLASS;
pub const UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = UProperty.TRAIL_CANONICAL_COMBINING_CLASS;
pub const UCHAR_GRAPHEME_CLUSTER_BREAK = UProperty.GRAPHEME_CLUSTER_BREAK;
pub const UCHAR_SENTENCE_BREAK = UProperty.SENTENCE_BREAK;
pub const UCHAR_WORD_BREAK = UProperty.WORD_BREAK;
pub const UCHAR_BIDI_PAIRED_BRACKET_TYPE = UProperty.BIDI_PAIRED_BRACKET_TYPE;
pub const UCHAR_INDIC_POSITIONAL_CATEGORY = UProperty.INDIC_POSITIONAL_CATEGORY;
pub const UCHAR_INDIC_SYLLABIC_CATEGORY = UProperty.INDIC_SYLLABIC_CATEGORY;
pub const UCHAR_VERTICAL_ORIENTATION = UProperty.VERTICAL_ORIENTATION;
pub const UCHAR_GENERAL_CATEGORY_MASK = UProperty.GENERAL_CATEGORY_MASK;
pub const UCHAR_MASK_START = UProperty.GENERAL_CATEGORY_MASK;
pub const UCHAR_NUMERIC_VALUE = UProperty.NUMERIC_VALUE;
pub const UCHAR_DOUBLE_START = UProperty.NUMERIC_VALUE;
pub const UCHAR_AGE = UProperty.AGE;
pub const UCHAR_STRING_START = UProperty.AGE;
pub const UCHAR_BIDI_MIRRORING_GLYPH = UProperty.BIDI_MIRRORING_GLYPH;
pub const UCHAR_CASE_FOLDING = UProperty.CASE_FOLDING;
pub const UCHAR_LOWERCASE_MAPPING = UProperty.LOWERCASE_MAPPING;
pub const UCHAR_NAME = UProperty.NAME;
pub const UCHAR_SIMPLE_CASE_FOLDING = UProperty.SIMPLE_CASE_FOLDING;
pub const UCHAR_SIMPLE_LOWERCASE_MAPPING = UProperty.SIMPLE_LOWERCASE_MAPPING;
pub const UCHAR_SIMPLE_TITLECASE_MAPPING = UProperty.SIMPLE_TITLECASE_MAPPING;
pub const UCHAR_SIMPLE_UPPERCASE_MAPPING = UProperty.SIMPLE_UPPERCASE_MAPPING;
pub const UCHAR_TITLECASE_MAPPING = UProperty.TITLECASE_MAPPING;
pub const UCHAR_UPPERCASE_MAPPING = UProperty.UPPERCASE_MAPPING;
pub const UCHAR_BIDI_PAIRED_BRACKET = UProperty.BIDI_PAIRED_BRACKET;
pub const UCHAR_SCRIPT_EXTENSIONS = UProperty.SCRIPT_EXTENSIONS;
pub const UCHAR_OTHER_PROPERTY_START = UProperty.SCRIPT_EXTENSIONS;
pub const UCHAR_INVALID_CODE = UProperty.INVALID_CODE;

pub const UCharCategory = enum(i32) {
    UNASSIGNED = 0,
    // GENERAL_OTHER_TYPES = 0, this enum value conflicts with UNASSIGNED
    UPPERCASE_LETTER = 1,
    LOWERCASE_LETTER = 2,
    TITLECASE_LETTER = 3,
    MODIFIER_LETTER = 4,
    OTHER_LETTER = 5,
    NON_SPACING_MARK = 6,
    ENCLOSING_MARK = 7,
    COMBINING_SPACING_MARK = 8,
    DECIMAL_DIGIT_NUMBER = 9,
    LETTER_NUMBER = 10,
    OTHER_NUMBER = 11,
    SPACE_SEPARATOR = 12,
    LINE_SEPARATOR = 13,
    PARAGRAPH_SEPARATOR = 14,
    CONTROL_CHAR = 15,
    FORMAT_CHAR = 16,
    PRIVATE_USE_CHAR = 17,
    SURROGATE = 18,
    DASH_PUNCTUATION = 19,
    START_PUNCTUATION = 20,
    END_PUNCTUATION = 21,
    CONNECTOR_PUNCTUATION = 22,
    OTHER_PUNCTUATION = 23,
    MATH_SYMBOL = 24,
    CURRENCY_SYMBOL = 25,
    MODIFIER_SYMBOL = 26,
    OTHER_SYMBOL = 27,
    INITIAL_PUNCTUATION = 28,
    FINAL_PUNCTUATION = 29,
    CHAR_CATEGORY_COUNT = 30,
};
pub const U_UNASSIGNED = UCharCategory.UNASSIGNED;
pub const U_GENERAL_OTHER_TYPES = UCharCategory.UNASSIGNED;
pub const U_UPPERCASE_LETTER = UCharCategory.UPPERCASE_LETTER;
pub const U_LOWERCASE_LETTER = UCharCategory.LOWERCASE_LETTER;
pub const U_TITLECASE_LETTER = UCharCategory.TITLECASE_LETTER;
pub const U_MODIFIER_LETTER = UCharCategory.MODIFIER_LETTER;
pub const U_OTHER_LETTER = UCharCategory.OTHER_LETTER;
pub const U_NON_SPACING_MARK = UCharCategory.NON_SPACING_MARK;
pub const U_ENCLOSING_MARK = UCharCategory.ENCLOSING_MARK;
pub const U_COMBINING_SPACING_MARK = UCharCategory.COMBINING_SPACING_MARK;
pub const U_DECIMAL_DIGIT_NUMBER = UCharCategory.DECIMAL_DIGIT_NUMBER;
pub const U_LETTER_NUMBER = UCharCategory.LETTER_NUMBER;
pub const U_OTHER_NUMBER = UCharCategory.OTHER_NUMBER;
pub const U_SPACE_SEPARATOR = UCharCategory.SPACE_SEPARATOR;
pub const U_LINE_SEPARATOR = UCharCategory.LINE_SEPARATOR;
pub const U_PARAGRAPH_SEPARATOR = UCharCategory.PARAGRAPH_SEPARATOR;
pub const U_CONTROL_CHAR = UCharCategory.CONTROL_CHAR;
pub const U_FORMAT_CHAR = UCharCategory.FORMAT_CHAR;
pub const U_PRIVATE_USE_CHAR = UCharCategory.PRIVATE_USE_CHAR;
pub const U_SURROGATE = UCharCategory.SURROGATE;
pub const U_DASH_PUNCTUATION = UCharCategory.DASH_PUNCTUATION;
pub const U_START_PUNCTUATION = UCharCategory.START_PUNCTUATION;
pub const U_END_PUNCTUATION = UCharCategory.END_PUNCTUATION;
pub const U_CONNECTOR_PUNCTUATION = UCharCategory.CONNECTOR_PUNCTUATION;
pub const U_OTHER_PUNCTUATION = UCharCategory.OTHER_PUNCTUATION;
pub const U_MATH_SYMBOL = UCharCategory.MATH_SYMBOL;
pub const U_CURRENCY_SYMBOL = UCharCategory.CURRENCY_SYMBOL;
pub const U_MODIFIER_SYMBOL = UCharCategory.MODIFIER_SYMBOL;
pub const U_OTHER_SYMBOL = UCharCategory.OTHER_SYMBOL;
pub const U_INITIAL_PUNCTUATION = UCharCategory.INITIAL_PUNCTUATION;
pub const U_FINAL_PUNCTUATION = UCharCategory.FINAL_PUNCTUATION;
pub const U_CHAR_CATEGORY_COUNT = UCharCategory.CHAR_CATEGORY_COUNT;

pub const UCharDirection = enum(i32) {
    LEFT_TO_RIGHT = 0,
    RIGHT_TO_LEFT = 1,
    EUROPEAN_NUMBER = 2,
    EUROPEAN_NUMBER_SEPARATOR = 3,
    EUROPEAN_NUMBER_TERMINATOR = 4,
    ARABIC_NUMBER = 5,
    COMMON_NUMBER_SEPARATOR = 6,
    BLOCK_SEPARATOR = 7,
    SEGMENT_SEPARATOR = 8,
    WHITE_SPACE_NEUTRAL = 9,
    OTHER_NEUTRAL = 10,
    LEFT_TO_RIGHT_EMBEDDING = 11,
    LEFT_TO_RIGHT_OVERRIDE = 12,
    RIGHT_TO_LEFT_ARABIC = 13,
    RIGHT_TO_LEFT_EMBEDDING = 14,
    RIGHT_TO_LEFT_OVERRIDE = 15,
    POP_DIRECTIONAL_FORMAT = 16,
    DIR_NON_SPACING_MARK = 17,
    BOUNDARY_NEUTRAL = 18,
    FIRST_STRONG_ISOLATE = 19,
    LEFT_TO_RIGHT_ISOLATE = 20,
    RIGHT_TO_LEFT_ISOLATE = 21,
    POP_DIRECTIONAL_ISOLATE = 22,
};
pub const U_LEFT_TO_RIGHT = UCharDirection.LEFT_TO_RIGHT;
pub const U_RIGHT_TO_LEFT = UCharDirection.RIGHT_TO_LEFT;
pub const U_EUROPEAN_NUMBER = UCharDirection.EUROPEAN_NUMBER;
pub const U_EUROPEAN_NUMBER_SEPARATOR = UCharDirection.EUROPEAN_NUMBER_SEPARATOR;
pub const U_EUROPEAN_NUMBER_TERMINATOR = UCharDirection.EUROPEAN_NUMBER_TERMINATOR;
pub const U_ARABIC_NUMBER = UCharDirection.ARABIC_NUMBER;
pub const U_COMMON_NUMBER_SEPARATOR = UCharDirection.COMMON_NUMBER_SEPARATOR;
pub const U_BLOCK_SEPARATOR = UCharDirection.BLOCK_SEPARATOR;
pub const U_SEGMENT_SEPARATOR = UCharDirection.SEGMENT_SEPARATOR;
pub const U_WHITE_SPACE_NEUTRAL = UCharDirection.WHITE_SPACE_NEUTRAL;
pub const U_OTHER_NEUTRAL = UCharDirection.OTHER_NEUTRAL;
pub const U_LEFT_TO_RIGHT_EMBEDDING = UCharDirection.LEFT_TO_RIGHT_EMBEDDING;
pub const U_LEFT_TO_RIGHT_OVERRIDE = UCharDirection.LEFT_TO_RIGHT_OVERRIDE;
pub const U_RIGHT_TO_LEFT_ARABIC = UCharDirection.RIGHT_TO_LEFT_ARABIC;
pub const U_RIGHT_TO_LEFT_EMBEDDING = UCharDirection.RIGHT_TO_LEFT_EMBEDDING;
pub const U_RIGHT_TO_LEFT_OVERRIDE = UCharDirection.RIGHT_TO_LEFT_OVERRIDE;
pub const U_POP_DIRECTIONAL_FORMAT = UCharDirection.POP_DIRECTIONAL_FORMAT;
pub const U_DIR_NON_SPACING_MARK = UCharDirection.DIR_NON_SPACING_MARK;
pub const U_BOUNDARY_NEUTRAL = UCharDirection.BOUNDARY_NEUTRAL;
pub const U_FIRST_STRONG_ISOLATE = UCharDirection.FIRST_STRONG_ISOLATE;
pub const U_LEFT_TO_RIGHT_ISOLATE = UCharDirection.LEFT_TO_RIGHT_ISOLATE;
pub const U_RIGHT_TO_LEFT_ISOLATE = UCharDirection.RIGHT_TO_LEFT_ISOLATE;
pub const U_POP_DIRECTIONAL_ISOLATE = UCharDirection.POP_DIRECTIONAL_ISOLATE;

pub const UBidiPairedBracketType = enum(i32) {
    NONE = 0,
    OPEN = 1,
    CLOSE = 2,
};
pub const U_BPT_NONE = UBidiPairedBracketType.NONE;
pub const U_BPT_OPEN = UBidiPairedBracketType.OPEN;
pub const U_BPT_CLOSE = UBidiPairedBracketType.CLOSE;

pub const UBlockCode = enum(i32) {
    NO_BLOCK = 0,
    BASIC_LATIN = 1,
    LATIN_1_SUPPLEMENT = 2,
    LATIN_EXTENDED_A = 3,
    LATIN_EXTENDED_B = 4,
    IPA_EXTENSIONS = 5,
    SPACING_MODIFIER_LETTERS = 6,
    COMBINING_DIACRITICAL_MARKS = 7,
    GREEK = 8,
    CYRILLIC = 9,
    ARMENIAN = 10,
    HEBREW = 11,
    ARABIC = 12,
    SYRIAC = 13,
    THAANA = 14,
    DEVANAGARI = 15,
    BENGALI = 16,
    GURMUKHI = 17,
    GUJARATI = 18,
    ORIYA = 19,
    TAMIL = 20,
    TELUGU = 21,
    KANNADA = 22,
    MALAYALAM = 23,
    SINHALA = 24,
    THAI = 25,
    LAO = 26,
    TIBETAN = 27,
    MYANMAR = 28,
    GEORGIAN = 29,
    HANGUL_JAMO = 30,
    ETHIOPIC = 31,
    CHEROKEE = 32,
    UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = 33,
    OGHAM = 34,
    RUNIC = 35,
    KHMER = 36,
    MONGOLIAN = 37,
    LATIN_EXTENDED_ADDITIONAL = 38,
    GREEK_EXTENDED = 39,
    GENERAL_PUNCTUATION = 40,
    SUPERSCRIPTS_AND_SUBSCRIPTS = 41,
    CURRENCY_SYMBOLS = 42,
    COMBINING_MARKS_FOR_SYMBOLS = 43,
    LETTERLIKE_SYMBOLS = 44,
    NUMBER_FORMS = 45,
    ARROWS = 46,
    MATHEMATICAL_OPERATORS = 47,
    MISCELLANEOUS_TECHNICAL = 48,
    CONTROL_PICTURES = 49,
    OPTICAL_CHARACTER_RECOGNITION = 50,
    ENCLOSED_ALPHANUMERICS = 51,
    BOX_DRAWING = 52,
    BLOCK_ELEMENTS = 53,
    GEOMETRIC_SHAPES = 54,
    MISCELLANEOUS_SYMBOLS = 55,
    DINGBATS = 56,
    BRAILLE_PATTERNS = 57,
    CJK_RADICALS_SUPPLEMENT = 58,
    KANGXI_RADICALS = 59,
    IDEOGRAPHIC_DESCRIPTION_CHARACTERS = 60,
    CJK_SYMBOLS_AND_PUNCTUATION = 61,
    HIRAGANA = 62,
    KATAKANA = 63,
    BOPOMOFO = 64,
    HANGUL_COMPATIBILITY_JAMO = 65,
    KANBUN = 66,
    BOPOMOFO_EXTENDED = 67,
    ENCLOSED_CJK_LETTERS_AND_MONTHS = 68,
    CJK_COMPATIBILITY = 69,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = 70,
    CJK_UNIFIED_IDEOGRAPHS = 71,
    YI_SYLLABLES = 72,
    YI_RADICALS = 73,
    HANGUL_SYLLABLES = 74,
    HIGH_SURROGATES = 75,
    HIGH_PRIVATE_USE_SURROGATES = 76,
    LOW_SURROGATES = 77,
    PRIVATE_USE_AREA = 78,
    // PRIVATE_USE = 78, this enum value conflicts with PRIVATE_USE_AREA
    CJK_COMPATIBILITY_IDEOGRAPHS = 79,
    ALPHABETIC_PRESENTATION_FORMS = 80,
    ARABIC_PRESENTATION_FORMS_A = 81,
    COMBINING_HALF_MARKS = 82,
    CJK_COMPATIBILITY_FORMS = 83,
    SMALL_FORM_VARIANTS = 84,
    ARABIC_PRESENTATION_FORMS_B = 85,
    SPECIALS = 86,
    HALFWIDTH_AND_FULLWIDTH_FORMS = 87,
    OLD_ITALIC = 88,
    GOTHIC = 89,
    DESERET = 90,
    BYZANTINE_MUSICAL_SYMBOLS = 91,
    MUSICAL_SYMBOLS = 92,
    MATHEMATICAL_ALPHANUMERIC_SYMBOLS = 93,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = 94,
    CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = 95,
    TAGS = 96,
    CYRILLIC_SUPPLEMENT = 97,
    // CYRILLIC_SUPPLEMENTARY = 97, this enum value conflicts with CYRILLIC_SUPPLEMENT
    TAGALOG = 98,
    HANUNOO = 99,
    BUHID = 100,
    TAGBANWA = 101,
    MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = 102,
    SUPPLEMENTAL_ARROWS_A = 103,
    SUPPLEMENTAL_ARROWS_B = 104,
    MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = 105,
    SUPPLEMENTAL_MATHEMATICAL_OPERATORS = 106,
    KATAKANA_PHONETIC_EXTENSIONS = 107,
    VARIATION_SELECTORS = 108,
    SUPPLEMENTARY_PRIVATE_USE_AREA_A = 109,
    SUPPLEMENTARY_PRIVATE_USE_AREA_B = 110,
    LIMBU = 111,
    TAI_LE = 112,
    KHMER_SYMBOLS = 113,
    PHONETIC_EXTENSIONS = 114,
    MISCELLANEOUS_SYMBOLS_AND_ARROWS = 115,
    YIJING_HEXAGRAM_SYMBOLS = 116,
    LINEAR_B_SYLLABARY = 117,
    LINEAR_B_IDEOGRAMS = 118,
    AEGEAN_NUMBERS = 119,
    UGARITIC = 120,
    SHAVIAN = 121,
    OSMANYA = 122,
    CYPRIOT_SYLLABARY = 123,
    TAI_XUAN_JING_SYMBOLS = 124,
    VARIATION_SELECTORS_SUPPLEMENT = 125,
    ANCIENT_GREEK_MUSICAL_NOTATION = 126,
    ANCIENT_GREEK_NUMBERS = 127,
    ARABIC_SUPPLEMENT = 128,
    BUGINESE = 129,
    CJK_STROKES = 130,
    COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = 131,
    COPTIC = 132,
    ETHIOPIC_EXTENDED = 133,
    ETHIOPIC_SUPPLEMENT = 134,
    GEORGIAN_SUPPLEMENT = 135,
    GLAGOLITIC = 136,
    KHAROSHTHI = 137,
    MODIFIER_TONE_LETTERS = 138,
    NEW_TAI_LUE = 139,
    OLD_PERSIAN = 140,
    PHONETIC_EXTENSIONS_SUPPLEMENT = 141,
    SUPPLEMENTAL_PUNCTUATION = 142,
    SYLOTI_NAGRI = 143,
    TIFINAGH = 144,
    VERTICAL_FORMS = 145,
    NKO = 146,
    BALINESE = 147,
    LATIN_EXTENDED_C = 148,
    LATIN_EXTENDED_D = 149,
    PHAGS_PA = 150,
    PHOENICIAN = 151,
    CUNEIFORM = 152,
    CUNEIFORM_NUMBERS_AND_PUNCTUATION = 153,
    COUNTING_ROD_NUMERALS = 154,
    SUNDANESE = 155,
    LEPCHA = 156,
    OL_CHIKI = 157,
    CYRILLIC_EXTENDED_A = 158,
    VAI = 159,
    CYRILLIC_EXTENDED_B = 160,
    SAURASHTRA = 161,
    KAYAH_LI = 162,
    REJANG = 163,
    CHAM = 164,
    ANCIENT_SYMBOLS = 165,
    PHAISTOS_DISC = 166,
    LYCIAN = 167,
    CARIAN = 168,
    LYDIAN = 169,
    MAHJONG_TILES = 170,
    DOMINO_TILES = 171,
    SAMARITAN = 172,
    UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = 173,
    TAI_THAM = 174,
    VEDIC_EXTENSIONS = 175,
    LISU = 176,
    BAMUM = 177,
    COMMON_INDIC_NUMBER_FORMS = 178,
    DEVANAGARI_EXTENDED = 179,
    HANGUL_JAMO_EXTENDED_A = 180,
    JAVANESE = 181,
    MYANMAR_EXTENDED_A = 182,
    TAI_VIET = 183,
    MEETEI_MAYEK = 184,
    HANGUL_JAMO_EXTENDED_B = 185,
    IMPERIAL_ARAMAIC = 186,
    OLD_SOUTH_ARABIAN = 187,
    AVESTAN = 188,
    INSCRIPTIONAL_PARTHIAN = 189,
    INSCRIPTIONAL_PAHLAVI = 190,
    OLD_TURKIC = 191,
    RUMI_NUMERAL_SYMBOLS = 192,
    KAITHI = 193,
    EGYPTIAN_HIEROGLYPHS = 194,
    ENCLOSED_ALPHANUMERIC_SUPPLEMENT = 195,
    ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = 196,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = 197,
    MANDAIC = 198,
    BATAK = 199,
    ETHIOPIC_EXTENDED_A = 200,
    BRAHMI = 201,
    BAMUM_SUPPLEMENT = 202,
    KANA_SUPPLEMENT = 203,
    PLAYING_CARDS = 204,
    MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = 205,
    EMOTICONS = 206,
    TRANSPORT_AND_MAP_SYMBOLS = 207,
    ALCHEMICAL_SYMBOLS = 208,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = 209,
    ARABIC_EXTENDED_A = 210,
    ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS = 211,
    CHAKMA = 212,
    MEETEI_MAYEK_EXTENSIONS = 213,
    MEROITIC_CURSIVE = 214,
    MEROITIC_HIEROGLYPHS = 215,
    MIAO = 216,
    SHARADA = 217,
    SORA_SOMPENG = 218,
    SUNDANESE_SUPPLEMENT = 219,
    TAKRI = 220,
    BASSA_VAH = 221,
    CAUCASIAN_ALBANIAN = 222,
    COPTIC_EPACT_NUMBERS = 223,
    COMBINING_DIACRITICAL_MARKS_EXTENDED = 224,
    DUPLOYAN = 225,
    ELBASAN = 226,
    GEOMETRIC_SHAPES_EXTENDED = 227,
    GRANTHA = 228,
    KHOJKI = 229,
    KHUDAWADI = 230,
    LATIN_EXTENDED_E = 231,
    LINEAR_A = 232,
    MAHAJANI = 233,
    MANICHAEAN = 234,
    MENDE_KIKAKUI = 235,
    MODI = 236,
    MRO = 237,
    MYANMAR_EXTENDED_B = 238,
    NABATAEAN = 239,
    OLD_NORTH_ARABIAN = 240,
    OLD_PERMIC = 241,
    ORNAMENTAL_DINGBATS = 242,
    PAHAWH_HMONG = 243,
    PALMYRENE = 244,
    PAU_CIN_HAU = 245,
    PSALTER_PAHLAVI = 246,
    SHORTHAND_FORMAT_CONTROLS = 247,
    SIDDHAM = 248,
    SINHALA_ARCHAIC_NUMBERS = 249,
    SUPPLEMENTAL_ARROWS_C = 250,
    TIRHUTA = 251,
    WARANG_CITI = 252,
    AHOM = 253,
    ANATOLIAN_HIEROGLYPHS = 254,
    CHEROKEE_SUPPLEMENT = 255,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E = 256,
    EARLY_DYNASTIC_CUNEIFORM = 257,
    HATRAN = 258,
    MULTANI = 259,
    OLD_HUNGARIAN = 260,
    SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS = 261,
    SUTTON_SIGNWRITING = 262,
    ADLAM = 263,
    BHAIKSUKI = 264,
    CYRILLIC_EXTENDED_C = 265,
    GLAGOLITIC_SUPPLEMENT = 266,
    IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION = 267,
    MARCHEN = 268,
    MONGOLIAN_SUPPLEMENT = 269,
    NEWA = 270,
    OSAGE = 271,
    TANGUT = 272,
    TANGUT_COMPONENTS = 273,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F = 274,
    KANA_EXTENDED_A = 275,
    MASARAM_GONDI = 276,
    NUSHU = 277,
    SOYOMBO = 278,
    SYRIAC_SUPPLEMENT = 279,
    ZANABAZAR_SQUARE = 280,
    CHESS_SYMBOLS = 281,
    DOGRA = 282,
    GEORGIAN_EXTENDED = 283,
    GUNJALA_GONDI = 284,
    HANIFI_ROHINGYA = 285,
    INDIC_SIYAQ_NUMBERS = 286,
    MAKASAR = 287,
    MAYAN_NUMERALS = 288,
    MEDEFAIDRIN = 289,
    OLD_SOGDIAN = 290,
    SOGDIAN = 291,
    EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS = 292,
    ELYMAIC = 293,
    NANDINAGARI = 294,
    NYIAKENG_PUACHUE_HMONG = 295,
    OTTOMAN_SIYAQ_NUMBERS = 296,
    SMALL_KANA_EXTENSION = 297,
    SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A = 298,
    TAMIL_SUPPLEMENT = 299,
    WANCHO = 300,
    CHORASMIAN = 301,
    CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G = 302,
    DIVES_AKURU = 303,
    KHITAN_SMALL_SCRIPT = 304,
    LISU_SUPPLEMENT = 305,
    SYMBOLS_FOR_LEGACY_COMPUTING = 306,
    TANGUT_SUPPLEMENT = 307,
    YEZIDI = 308,
    INVALID_CODE = -1,
};
pub const UBLOCK_NO_BLOCK = UBlockCode.NO_BLOCK;
pub const UBLOCK_BASIC_LATIN = UBlockCode.BASIC_LATIN;
pub const UBLOCK_LATIN_1_SUPPLEMENT = UBlockCode.LATIN_1_SUPPLEMENT;
pub const UBLOCK_LATIN_EXTENDED_A = UBlockCode.LATIN_EXTENDED_A;
pub const UBLOCK_LATIN_EXTENDED_B = UBlockCode.LATIN_EXTENDED_B;
pub const UBLOCK_IPA_EXTENSIONS = UBlockCode.IPA_EXTENSIONS;
pub const UBLOCK_SPACING_MODIFIER_LETTERS = UBlockCode.SPACING_MODIFIER_LETTERS;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS = UBlockCode.COMBINING_DIACRITICAL_MARKS;
pub const UBLOCK_GREEK = UBlockCode.GREEK;
pub const UBLOCK_CYRILLIC = UBlockCode.CYRILLIC;
pub const UBLOCK_ARMENIAN = UBlockCode.ARMENIAN;
pub const UBLOCK_HEBREW = UBlockCode.HEBREW;
pub const UBLOCK_ARABIC = UBlockCode.ARABIC;
pub const UBLOCK_SYRIAC = UBlockCode.SYRIAC;
pub const UBLOCK_THAANA = UBlockCode.THAANA;
pub const UBLOCK_DEVANAGARI = UBlockCode.DEVANAGARI;
pub const UBLOCK_BENGALI = UBlockCode.BENGALI;
pub const UBLOCK_GURMUKHI = UBlockCode.GURMUKHI;
pub const UBLOCK_GUJARATI = UBlockCode.GUJARATI;
pub const UBLOCK_ORIYA = UBlockCode.ORIYA;
pub const UBLOCK_TAMIL = UBlockCode.TAMIL;
pub const UBLOCK_TELUGU = UBlockCode.TELUGU;
pub const UBLOCK_KANNADA = UBlockCode.KANNADA;
pub const UBLOCK_MALAYALAM = UBlockCode.MALAYALAM;
pub const UBLOCK_SINHALA = UBlockCode.SINHALA;
pub const UBLOCK_THAI = UBlockCode.THAI;
pub const UBLOCK_LAO = UBlockCode.LAO;
pub const UBLOCK_TIBETAN = UBlockCode.TIBETAN;
pub const UBLOCK_MYANMAR = UBlockCode.MYANMAR;
pub const UBLOCK_GEORGIAN = UBlockCode.GEORGIAN;
pub const UBLOCK_HANGUL_JAMO = UBlockCode.HANGUL_JAMO;
pub const UBLOCK_ETHIOPIC = UBlockCode.ETHIOPIC;
pub const UBLOCK_CHEROKEE = UBlockCode.CHEROKEE;
pub const UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = UBlockCode.UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS;
pub const UBLOCK_OGHAM = UBlockCode.OGHAM;
pub const UBLOCK_RUNIC = UBlockCode.RUNIC;
pub const UBLOCK_KHMER = UBlockCode.KHMER;
pub const UBLOCK_MONGOLIAN = UBlockCode.MONGOLIAN;
pub const UBLOCK_LATIN_EXTENDED_ADDITIONAL = UBlockCode.LATIN_EXTENDED_ADDITIONAL;
pub const UBLOCK_GREEK_EXTENDED = UBlockCode.GREEK_EXTENDED;
pub const UBLOCK_GENERAL_PUNCTUATION = UBlockCode.GENERAL_PUNCTUATION;
pub const UBLOCK_SUPERSCRIPTS_AND_SUBSCRIPTS = UBlockCode.SUPERSCRIPTS_AND_SUBSCRIPTS;
pub const UBLOCK_CURRENCY_SYMBOLS = UBlockCode.CURRENCY_SYMBOLS;
pub const UBLOCK_COMBINING_MARKS_FOR_SYMBOLS = UBlockCode.COMBINING_MARKS_FOR_SYMBOLS;
pub const UBLOCK_LETTERLIKE_SYMBOLS = UBlockCode.LETTERLIKE_SYMBOLS;
pub const UBLOCK_NUMBER_FORMS = UBlockCode.NUMBER_FORMS;
pub const UBLOCK_ARROWS = UBlockCode.ARROWS;
pub const UBLOCK_MATHEMATICAL_OPERATORS = UBlockCode.MATHEMATICAL_OPERATORS;
pub const UBLOCK_MISCELLANEOUS_TECHNICAL = UBlockCode.MISCELLANEOUS_TECHNICAL;
pub const UBLOCK_CONTROL_PICTURES = UBlockCode.CONTROL_PICTURES;
pub const UBLOCK_OPTICAL_CHARACTER_RECOGNITION = UBlockCode.OPTICAL_CHARACTER_RECOGNITION;
pub const UBLOCK_ENCLOSED_ALPHANUMERICS = UBlockCode.ENCLOSED_ALPHANUMERICS;
pub const UBLOCK_BOX_DRAWING = UBlockCode.BOX_DRAWING;
pub const UBLOCK_BLOCK_ELEMENTS = UBlockCode.BLOCK_ELEMENTS;
pub const UBLOCK_GEOMETRIC_SHAPES = UBlockCode.GEOMETRIC_SHAPES;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS = UBlockCode.MISCELLANEOUS_SYMBOLS;
pub const UBLOCK_DINGBATS = UBlockCode.DINGBATS;
pub const UBLOCK_BRAILLE_PATTERNS = UBlockCode.BRAILLE_PATTERNS;
pub const UBLOCK_CJK_RADICALS_SUPPLEMENT = UBlockCode.CJK_RADICALS_SUPPLEMENT;
pub const UBLOCK_KANGXI_RADICALS = UBlockCode.KANGXI_RADICALS;
pub const UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS = UBlockCode.IDEOGRAPHIC_DESCRIPTION_CHARACTERS;
pub const UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION = UBlockCode.CJK_SYMBOLS_AND_PUNCTUATION;
pub const UBLOCK_HIRAGANA = UBlockCode.HIRAGANA;
pub const UBLOCK_KATAKANA = UBlockCode.KATAKANA;
pub const UBLOCK_BOPOMOFO = UBlockCode.BOPOMOFO;
pub const UBLOCK_HANGUL_COMPATIBILITY_JAMO = UBlockCode.HANGUL_COMPATIBILITY_JAMO;
pub const UBLOCK_KANBUN = UBlockCode.KANBUN;
pub const UBLOCK_BOPOMOFO_EXTENDED = UBlockCode.BOPOMOFO_EXTENDED;
pub const UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS = UBlockCode.ENCLOSED_CJK_LETTERS_AND_MONTHS;
pub const UBLOCK_CJK_COMPATIBILITY = UBlockCode.CJK_COMPATIBILITY;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS = UBlockCode.CJK_UNIFIED_IDEOGRAPHS;
pub const UBLOCK_YI_SYLLABLES = UBlockCode.YI_SYLLABLES;
pub const UBLOCK_YI_RADICALS = UBlockCode.YI_RADICALS;
pub const UBLOCK_HANGUL_SYLLABLES = UBlockCode.HANGUL_SYLLABLES;
pub const UBLOCK_HIGH_SURROGATES = UBlockCode.HIGH_SURROGATES;
pub const UBLOCK_HIGH_PRIVATE_USE_SURROGATES = UBlockCode.HIGH_PRIVATE_USE_SURROGATES;
pub const UBLOCK_LOW_SURROGATES = UBlockCode.LOW_SURROGATES;
pub const UBLOCK_PRIVATE_USE_AREA = UBlockCode.PRIVATE_USE_AREA;
pub const UBLOCK_PRIVATE_USE = UBlockCode.PRIVATE_USE_AREA;
pub const UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS = UBlockCode.CJK_COMPATIBILITY_IDEOGRAPHS;
pub const UBLOCK_ALPHABETIC_PRESENTATION_FORMS = UBlockCode.ALPHABETIC_PRESENTATION_FORMS;
pub const UBLOCK_ARABIC_PRESENTATION_FORMS_A = UBlockCode.ARABIC_PRESENTATION_FORMS_A;
pub const UBLOCK_COMBINING_HALF_MARKS = UBlockCode.COMBINING_HALF_MARKS;
pub const UBLOCK_CJK_COMPATIBILITY_FORMS = UBlockCode.CJK_COMPATIBILITY_FORMS;
pub const UBLOCK_SMALL_FORM_VARIANTS = UBlockCode.SMALL_FORM_VARIANTS;
pub const UBLOCK_ARABIC_PRESENTATION_FORMS_B = UBlockCode.ARABIC_PRESENTATION_FORMS_B;
pub const UBLOCK_SPECIALS = UBlockCode.SPECIALS;
pub const UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS = UBlockCode.HALFWIDTH_AND_FULLWIDTH_FORMS;
pub const UBLOCK_OLD_ITALIC = UBlockCode.OLD_ITALIC;
pub const UBLOCK_GOTHIC = UBlockCode.GOTHIC;
pub const UBLOCK_DESERET = UBlockCode.DESERET;
pub const UBLOCK_BYZANTINE_MUSICAL_SYMBOLS = UBlockCode.BYZANTINE_MUSICAL_SYMBOLS;
pub const UBLOCK_MUSICAL_SYMBOLS = UBlockCode.MUSICAL_SYMBOLS;
pub const UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS = UBlockCode.MATHEMATICAL_ALPHANUMERIC_SYMBOLS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B;
pub const UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = UBlockCode.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT;
pub const UBLOCK_TAGS = UBlockCode.TAGS;
pub const UBLOCK_CYRILLIC_SUPPLEMENT = UBlockCode.CYRILLIC_SUPPLEMENT;
pub const UBLOCK_CYRILLIC_SUPPLEMENTARY = UBlockCode.CYRILLIC_SUPPLEMENT;
pub const UBLOCK_TAGALOG = UBlockCode.TAGALOG;
pub const UBLOCK_HANUNOO = UBlockCode.HANUNOO;
pub const UBLOCK_BUHID = UBlockCode.BUHID;
pub const UBLOCK_TAGBANWA = UBlockCode.TAGBANWA;
pub const UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = UBlockCode.MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_A = UBlockCode.SUPPLEMENTAL_ARROWS_A;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_B = UBlockCode.SUPPLEMENTAL_ARROWS_B;
pub const UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = UBlockCode.MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B;
pub const UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS = UBlockCode.SUPPLEMENTAL_MATHEMATICAL_OPERATORS;
pub const UBLOCK_KATAKANA_PHONETIC_EXTENSIONS = UBlockCode.KATAKANA_PHONETIC_EXTENSIONS;
pub const UBLOCK_VARIATION_SELECTORS = UBlockCode.VARIATION_SELECTORS;
pub const UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A = UBlockCode.SUPPLEMENTARY_PRIVATE_USE_AREA_A;
pub const UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B = UBlockCode.SUPPLEMENTARY_PRIVATE_USE_AREA_B;
pub const UBLOCK_LIMBU = UBlockCode.LIMBU;
pub const UBLOCK_TAI_LE = UBlockCode.TAI_LE;
pub const UBLOCK_KHMER_SYMBOLS = UBlockCode.KHMER_SYMBOLS;
pub const UBLOCK_PHONETIC_EXTENSIONS = UBlockCode.PHONETIC_EXTENSIONS;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS = UBlockCode.MISCELLANEOUS_SYMBOLS_AND_ARROWS;
pub const UBLOCK_YIJING_HEXAGRAM_SYMBOLS = UBlockCode.YIJING_HEXAGRAM_SYMBOLS;
pub const UBLOCK_LINEAR_B_SYLLABARY = UBlockCode.LINEAR_B_SYLLABARY;
pub const UBLOCK_LINEAR_B_IDEOGRAMS = UBlockCode.LINEAR_B_IDEOGRAMS;
pub const UBLOCK_AEGEAN_NUMBERS = UBlockCode.AEGEAN_NUMBERS;
pub const UBLOCK_UGARITIC = UBlockCode.UGARITIC;
pub const UBLOCK_SHAVIAN = UBlockCode.SHAVIAN;
pub const UBLOCK_OSMANYA = UBlockCode.OSMANYA;
pub const UBLOCK_CYPRIOT_SYLLABARY = UBlockCode.CYPRIOT_SYLLABARY;
pub const UBLOCK_TAI_XUAN_JING_SYMBOLS = UBlockCode.TAI_XUAN_JING_SYMBOLS;
pub const UBLOCK_VARIATION_SELECTORS_SUPPLEMENT = UBlockCode.VARIATION_SELECTORS_SUPPLEMENT;
pub const UBLOCK_ANCIENT_GREEK_MUSICAL_NOTATION = UBlockCode.ANCIENT_GREEK_MUSICAL_NOTATION;
pub const UBLOCK_ANCIENT_GREEK_NUMBERS = UBlockCode.ANCIENT_GREEK_NUMBERS;
pub const UBLOCK_ARABIC_SUPPLEMENT = UBlockCode.ARABIC_SUPPLEMENT;
pub const UBLOCK_BUGINESE = UBlockCode.BUGINESE;
pub const UBLOCK_CJK_STROKES = UBlockCode.CJK_STROKES;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = UBlockCode.COMBINING_DIACRITICAL_MARKS_SUPPLEMENT;
pub const UBLOCK_COPTIC = UBlockCode.COPTIC;
pub const UBLOCK_ETHIOPIC_EXTENDED = UBlockCode.ETHIOPIC_EXTENDED;
pub const UBLOCK_ETHIOPIC_SUPPLEMENT = UBlockCode.ETHIOPIC_SUPPLEMENT;
pub const UBLOCK_GEORGIAN_SUPPLEMENT = UBlockCode.GEORGIAN_SUPPLEMENT;
pub const UBLOCK_GLAGOLITIC = UBlockCode.GLAGOLITIC;
pub const UBLOCK_KHAROSHTHI = UBlockCode.KHAROSHTHI;
pub const UBLOCK_MODIFIER_TONE_LETTERS = UBlockCode.MODIFIER_TONE_LETTERS;
pub const UBLOCK_NEW_TAI_LUE = UBlockCode.NEW_TAI_LUE;
pub const UBLOCK_OLD_PERSIAN = UBlockCode.OLD_PERSIAN;
pub const UBLOCK_PHONETIC_EXTENSIONS_SUPPLEMENT = UBlockCode.PHONETIC_EXTENSIONS_SUPPLEMENT;
pub const UBLOCK_SUPPLEMENTAL_PUNCTUATION = UBlockCode.SUPPLEMENTAL_PUNCTUATION;
pub const UBLOCK_SYLOTI_NAGRI = UBlockCode.SYLOTI_NAGRI;
pub const UBLOCK_TIFINAGH = UBlockCode.TIFINAGH;
pub const UBLOCK_VERTICAL_FORMS = UBlockCode.VERTICAL_FORMS;
pub const UBLOCK_NKO = UBlockCode.NKO;
pub const UBLOCK_BALINESE = UBlockCode.BALINESE;
pub const UBLOCK_LATIN_EXTENDED_C = UBlockCode.LATIN_EXTENDED_C;
pub const UBLOCK_LATIN_EXTENDED_D = UBlockCode.LATIN_EXTENDED_D;
pub const UBLOCK_PHAGS_PA = UBlockCode.PHAGS_PA;
pub const UBLOCK_PHOENICIAN = UBlockCode.PHOENICIAN;
pub const UBLOCK_CUNEIFORM = UBlockCode.CUNEIFORM;
pub const UBLOCK_CUNEIFORM_NUMBERS_AND_PUNCTUATION = UBlockCode.CUNEIFORM_NUMBERS_AND_PUNCTUATION;
pub const UBLOCK_COUNTING_ROD_NUMERALS = UBlockCode.COUNTING_ROD_NUMERALS;
pub const UBLOCK_SUNDANESE = UBlockCode.SUNDANESE;
pub const UBLOCK_LEPCHA = UBlockCode.LEPCHA;
pub const UBLOCK_OL_CHIKI = UBlockCode.OL_CHIKI;
pub const UBLOCK_CYRILLIC_EXTENDED_A = UBlockCode.CYRILLIC_EXTENDED_A;
pub const UBLOCK_VAI = UBlockCode.VAI;
pub const UBLOCK_CYRILLIC_EXTENDED_B = UBlockCode.CYRILLIC_EXTENDED_B;
pub const UBLOCK_SAURASHTRA = UBlockCode.SAURASHTRA;
pub const UBLOCK_KAYAH_LI = UBlockCode.KAYAH_LI;
pub const UBLOCK_REJANG = UBlockCode.REJANG;
pub const UBLOCK_CHAM = UBlockCode.CHAM;
pub const UBLOCK_ANCIENT_SYMBOLS = UBlockCode.ANCIENT_SYMBOLS;
pub const UBLOCK_PHAISTOS_DISC = UBlockCode.PHAISTOS_DISC;
pub const UBLOCK_LYCIAN = UBlockCode.LYCIAN;
pub const UBLOCK_CARIAN = UBlockCode.CARIAN;
pub const UBLOCK_LYDIAN = UBlockCode.LYDIAN;
pub const UBLOCK_MAHJONG_TILES = UBlockCode.MAHJONG_TILES;
pub const UBLOCK_DOMINO_TILES = UBlockCode.DOMINO_TILES;
pub const UBLOCK_SAMARITAN = UBlockCode.SAMARITAN;
pub const UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = UBlockCode.UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED;
pub const UBLOCK_TAI_THAM = UBlockCode.TAI_THAM;
pub const UBLOCK_VEDIC_EXTENSIONS = UBlockCode.VEDIC_EXTENSIONS;
pub const UBLOCK_LISU = UBlockCode.LISU;
pub const UBLOCK_BAMUM = UBlockCode.BAMUM;
pub const UBLOCK_COMMON_INDIC_NUMBER_FORMS = UBlockCode.COMMON_INDIC_NUMBER_FORMS;
pub const UBLOCK_DEVANAGARI_EXTENDED = UBlockCode.DEVANAGARI_EXTENDED;
pub const UBLOCK_HANGUL_JAMO_EXTENDED_A = UBlockCode.HANGUL_JAMO_EXTENDED_A;
pub const UBLOCK_JAVANESE = UBlockCode.JAVANESE;
pub const UBLOCK_MYANMAR_EXTENDED_A = UBlockCode.MYANMAR_EXTENDED_A;
pub const UBLOCK_TAI_VIET = UBlockCode.TAI_VIET;
pub const UBLOCK_MEETEI_MAYEK = UBlockCode.MEETEI_MAYEK;
pub const UBLOCK_HANGUL_JAMO_EXTENDED_B = UBlockCode.HANGUL_JAMO_EXTENDED_B;
pub const UBLOCK_IMPERIAL_ARAMAIC = UBlockCode.IMPERIAL_ARAMAIC;
pub const UBLOCK_OLD_SOUTH_ARABIAN = UBlockCode.OLD_SOUTH_ARABIAN;
pub const UBLOCK_AVESTAN = UBlockCode.AVESTAN;
pub const UBLOCK_INSCRIPTIONAL_PARTHIAN = UBlockCode.INSCRIPTIONAL_PARTHIAN;
pub const UBLOCK_INSCRIPTIONAL_PAHLAVI = UBlockCode.INSCRIPTIONAL_PAHLAVI;
pub const UBLOCK_OLD_TURKIC = UBlockCode.OLD_TURKIC;
pub const UBLOCK_RUMI_NUMERAL_SYMBOLS = UBlockCode.RUMI_NUMERAL_SYMBOLS;
pub const UBLOCK_KAITHI = UBlockCode.KAITHI;
pub const UBLOCK_EGYPTIAN_HIEROGLYPHS = UBlockCode.EGYPTIAN_HIEROGLYPHS;
pub const UBLOCK_ENCLOSED_ALPHANUMERIC_SUPPLEMENT = UBlockCode.ENCLOSED_ALPHANUMERIC_SUPPLEMENT;
pub const UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = UBlockCode.ENCLOSED_IDEOGRAPHIC_SUPPLEMENT;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C;
pub const UBLOCK_MANDAIC = UBlockCode.MANDAIC;
pub const UBLOCK_BATAK = UBlockCode.BATAK;
pub const UBLOCK_ETHIOPIC_EXTENDED_A = UBlockCode.ETHIOPIC_EXTENDED_A;
pub const UBLOCK_BRAHMI = UBlockCode.BRAHMI;
pub const UBLOCK_BAMUM_SUPPLEMENT = UBlockCode.BAMUM_SUPPLEMENT;
pub const UBLOCK_KANA_SUPPLEMENT = UBlockCode.KANA_SUPPLEMENT;
pub const UBLOCK_PLAYING_CARDS = UBlockCode.PLAYING_CARDS;
pub const UBLOCK_MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = UBlockCode.MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS;
pub const UBLOCK_EMOTICONS = UBlockCode.EMOTICONS;
pub const UBLOCK_TRANSPORT_AND_MAP_SYMBOLS = UBlockCode.TRANSPORT_AND_MAP_SYMBOLS;
pub const UBLOCK_ALCHEMICAL_SYMBOLS = UBlockCode.ALCHEMICAL_SYMBOLS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D;
pub const UBLOCK_ARABIC_EXTENDED_A = UBlockCode.ARABIC_EXTENDED_A;
pub const UBLOCK_ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS = UBlockCode.ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS;
pub const UBLOCK_CHAKMA = UBlockCode.CHAKMA;
pub const UBLOCK_MEETEI_MAYEK_EXTENSIONS = UBlockCode.MEETEI_MAYEK_EXTENSIONS;
pub const UBLOCK_MEROITIC_CURSIVE = UBlockCode.MEROITIC_CURSIVE;
pub const UBLOCK_MEROITIC_HIEROGLYPHS = UBlockCode.MEROITIC_HIEROGLYPHS;
pub const UBLOCK_MIAO = UBlockCode.MIAO;
pub const UBLOCK_SHARADA = UBlockCode.SHARADA;
pub const UBLOCK_SORA_SOMPENG = UBlockCode.SORA_SOMPENG;
pub const UBLOCK_SUNDANESE_SUPPLEMENT = UBlockCode.SUNDANESE_SUPPLEMENT;
pub const UBLOCK_TAKRI = UBlockCode.TAKRI;
pub const UBLOCK_BASSA_VAH = UBlockCode.BASSA_VAH;
pub const UBLOCK_CAUCASIAN_ALBANIAN = UBlockCode.CAUCASIAN_ALBANIAN;
pub const UBLOCK_COPTIC_EPACT_NUMBERS = UBlockCode.COPTIC_EPACT_NUMBERS;
pub const UBLOCK_COMBINING_DIACRITICAL_MARKS_EXTENDED = UBlockCode.COMBINING_DIACRITICAL_MARKS_EXTENDED;
pub const UBLOCK_DUPLOYAN = UBlockCode.DUPLOYAN;
pub const UBLOCK_ELBASAN = UBlockCode.ELBASAN;
pub const UBLOCK_GEOMETRIC_SHAPES_EXTENDED = UBlockCode.GEOMETRIC_SHAPES_EXTENDED;
pub const UBLOCK_GRANTHA = UBlockCode.GRANTHA;
pub const UBLOCK_KHOJKI = UBlockCode.KHOJKI;
pub const UBLOCK_KHUDAWADI = UBlockCode.KHUDAWADI;
pub const UBLOCK_LATIN_EXTENDED_E = UBlockCode.LATIN_EXTENDED_E;
pub const UBLOCK_LINEAR_A = UBlockCode.LINEAR_A;
pub const UBLOCK_MAHAJANI = UBlockCode.MAHAJANI;
pub const UBLOCK_MANICHAEAN = UBlockCode.MANICHAEAN;
pub const UBLOCK_MENDE_KIKAKUI = UBlockCode.MENDE_KIKAKUI;
pub const UBLOCK_MODI = UBlockCode.MODI;
pub const UBLOCK_MRO = UBlockCode.MRO;
pub const UBLOCK_MYANMAR_EXTENDED_B = UBlockCode.MYANMAR_EXTENDED_B;
pub const UBLOCK_NABATAEAN = UBlockCode.NABATAEAN;
pub const UBLOCK_OLD_NORTH_ARABIAN = UBlockCode.OLD_NORTH_ARABIAN;
pub const UBLOCK_OLD_PERMIC = UBlockCode.OLD_PERMIC;
pub const UBLOCK_ORNAMENTAL_DINGBATS = UBlockCode.ORNAMENTAL_DINGBATS;
pub const UBLOCK_PAHAWH_HMONG = UBlockCode.PAHAWH_HMONG;
pub const UBLOCK_PALMYRENE = UBlockCode.PALMYRENE;
pub const UBLOCK_PAU_CIN_HAU = UBlockCode.PAU_CIN_HAU;
pub const UBLOCK_PSALTER_PAHLAVI = UBlockCode.PSALTER_PAHLAVI;
pub const UBLOCK_SHORTHAND_FORMAT_CONTROLS = UBlockCode.SHORTHAND_FORMAT_CONTROLS;
pub const UBLOCK_SIDDHAM = UBlockCode.SIDDHAM;
pub const UBLOCK_SINHALA_ARCHAIC_NUMBERS = UBlockCode.SINHALA_ARCHAIC_NUMBERS;
pub const UBLOCK_SUPPLEMENTAL_ARROWS_C = UBlockCode.SUPPLEMENTAL_ARROWS_C;
pub const UBLOCK_TIRHUTA = UBlockCode.TIRHUTA;
pub const UBLOCK_WARANG_CITI = UBlockCode.WARANG_CITI;
pub const UBLOCK_AHOM = UBlockCode.AHOM;
pub const UBLOCK_ANATOLIAN_HIEROGLYPHS = UBlockCode.ANATOLIAN_HIEROGLYPHS;
pub const UBLOCK_CHEROKEE_SUPPLEMENT = UBlockCode.CHEROKEE_SUPPLEMENT;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E;
pub const UBLOCK_EARLY_DYNASTIC_CUNEIFORM = UBlockCode.EARLY_DYNASTIC_CUNEIFORM;
pub const UBLOCK_HATRAN = UBlockCode.HATRAN;
pub const UBLOCK_MULTANI = UBlockCode.MULTANI;
pub const UBLOCK_OLD_HUNGARIAN = UBlockCode.OLD_HUNGARIAN;
pub const UBLOCK_SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS = UBlockCode.SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS;
pub const UBLOCK_SUTTON_SIGNWRITING = UBlockCode.SUTTON_SIGNWRITING;
pub const UBLOCK_ADLAM = UBlockCode.ADLAM;
pub const UBLOCK_BHAIKSUKI = UBlockCode.BHAIKSUKI;
pub const UBLOCK_CYRILLIC_EXTENDED_C = UBlockCode.CYRILLIC_EXTENDED_C;
pub const UBLOCK_GLAGOLITIC_SUPPLEMENT = UBlockCode.GLAGOLITIC_SUPPLEMENT;
pub const UBLOCK_IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION = UBlockCode.IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION;
pub const UBLOCK_MARCHEN = UBlockCode.MARCHEN;
pub const UBLOCK_MONGOLIAN_SUPPLEMENT = UBlockCode.MONGOLIAN_SUPPLEMENT;
pub const UBLOCK_NEWA = UBlockCode.NEWA;
pub const UBLOCK_OSAGE = UBlockCode.OSAGE;
pub const UBLOCK_TANGUT = UBlockCode.TANGUT;
pub const UBLOCK_TANGUT_COMPONENTS = UBlockCode.TANGUT_COMPONENTS;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F;
pub const UBLOCK_KANA_EXTENDED_A = UBlockCode.KANA_EXTENDED_A;
pub const UBLOCK_MASARAM_GONDI = UBlockCode.MASARAM_GONDI;
pub const UBLOCK_NUSHU = UBlockCode.NUSHU;
pub const UBLOCK_SOYOMBO = UBlockCode.SOYOMBO;
pub const UBLOCK_SYRIAC_SUPPLEMENT = UBlockCode.SYRIAC_SUPPLEMENT;
pub const UBLOCK_ZANABAZAR_SQUARE = UBlockCode.ZANABAZAR_SQUARE;
pub const UBLOCK_CHESS_SYMBOLS = UBlockCode.CHESS_SYMBOLS;
pub const UBLOCK_DOGRA = UBlockCode.DOGRA;
pub const UBLOCK_GEORGIAN_EXTENDED = UBlockCode.GEORGIAN_EXTENDED;
pub const UBLOCK_GUNJALA_GONDI = UBlockCode.GUNJALA_GONDI;
pub const UBLOCK_HANIFI_ROHINGYA = UBlockCode.HANIFI_ROHINGYA;
pub const UBLOCK_INDIC_SIYAQ_NUMBERS = UBlockCode.INDIC_SIYAQ_NUMBERS;
pub const UBLOCK_MAKASAR = UBlockCode.MAKASAR;
pub const UBLOCK_MAYAN_NUMERALS = UBlockCode.MAYAN_NUMERALS;
pub const UBLOCK_MEDEFAIDRIN = UBlockCode.MEDEFAIDRIN;
pub const UBLOCK_OLD_SOGDIAN = UBlockCode.OLD_SOGDIAN;
pub const UBLOCK_SOGDIAN = UBlockCode.SOGDIAN;
pub const UBLOCK_EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS = UBlockCode.EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS;
pub const UBLOCK_ELYMAIC = UBlockCode.ELYMAIC;
pub const UBLOCK_NANDINAGARI = UBlockCode.NANDINAGARI;
pub const UBLOCK_NYIAKENG_PUACHUE_HMONG = UBlockCode.NYIAKENG_PUACHUE_HMONG;
pub const UBLOCK_OTTOMAN_SIYAQ_NUMBERS = UBlockCode.OTTOMAN_SIYAQ_NUMBERS;
pub const UBLOCK_SMALL_KANA_EXTENSION = UBlockCode.SMALL_KANA_EXTENSION;
pub const UBLOCK_SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A = UBlockCode.SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A;
pub const UBLOCK_TAMIL_SUPPLEMENT = UBlockCode.TAMIL_SUPPLEMENT;
pub const UBLOCK_WANCHO = UBlockCode.WANCHO;
pub const UBLOCK_CHORASMIAN = UBlockCode.CHORASMIAN;
pub const UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G = UBlockCode.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G;
pub const UBLOCK_DIVES_AKURU = UBlockCode.DIVES_AKURU;
pub const UBLOCK_KHITAN_SMALL_SCRIPT = UBlockCode.KHITAN_SMALL_SCRIPT;
pub const UBLOCK_LISU_SUPPLEMENT = UBlockCode.LISU_SUPPLEMENT;
pub const UBLOCK_SYMBOLS_FOR_LEGACY_COMPUTING = UBlockCode.SYMBOLS_FOR_LEGACY_COMPUTING;
pub const UBLOCK_TANGUT_SUPPLEMENT = UBlockCode.TANGUT_SUPPLEMENT;
pub const UBLOCK_YEZIDI = UBlockCode.YEZIDI;
pub const UBLOCK_INVALID_CODE = UBlockCode.INVALID_CODE;

pub const UEastAsianWidth = enum(i32) {
    NEUTRAL = 0,
    AMBIGUOUS = 1,
    HALFWIDTH = 2,
    FULLWIDTH = 3,
    NARROW = 4,
    WIDE = 5,
};
pub const U_EA_NEUTRAL = UEastAsianWidth.NEUTRAL;
pub const U_EA_AMBIGUOUS = UEastAsianWidth.AMBIGUOUS;
pub const U_EA_HALFWIDTH = UEastAsianWidth.HALFWIDTH;
pub const U_EA_FULLWIDTH = UEastAsianWidth.FULLWIDTH;
pub const U_EA_NARROW = UEastAsianWidth.NARROW;
pub const U_EA_WIDE = UEastAsianWidth.WIDE;

pub const UCharNameChoice = enum(i32) {
    UNICODE_CHAR_NAME = 0,
    EXTENDED_CHAR_NAME = 2,
    CHAR_NAME_ALIAS = 3,
};
pub const U_UNICODE_CHAR_NAME = UCharNameChoice.UNICODE_CHAR_NAME;
pub const U_EXTENDED_CHAR_NAME = UCharNameChoice.EXTENDED_CHAR_NAME;
pub const U_CHAR_NAME_ALIAS = UCharNameChoice.CHAR_NAME_ALIAS;

pub const UPropertyNameChoice = enum(i32) {
    SHORT_PROPERTY_NAME = 0,
    LONG_PROPERTY_NAME = 1,
};
pub const U_SHORT_PROPERTY_NAME = UPropertyNameChoice.SHORT_PROPERTY_NAME;
pub const U_LONG_PROPERTY_NAME = UPropertyNameChoice.LONG_PROPERTY_NAME;

pub const UDecompositionType = enum(i32) {
    NONE = 0,
    CANONICAL = 1,
    COMPAT = 2,
    CIRCLE = 3,
    FINAL = 4,
    FONT = 5,
    FRACTION = 6,
    INITIAL = 7,
    ISOLATED = 8,
    MEDIAL = 9,
    NARROW = 10,
    NOBREAK = 11,
    SMALL = 12,
    SQUARE = 13,
    SUB = 14,
    SUPER = 15,
    VERTICAL = 16,
    WIDE = 17,
};
pub const U_DT_NONE = UDecompositionType.NONE;
pub const U_DT_CANONICAL = UDecompositionType.CANONICAL;
pub const U_DT_COMPAT = UDecompositionType.COMPAT;
pub const U_DT_CIRCLE = UDecompositionType.CIRCLE;
pub const U_DT_FINAL = UDecompositionType.FINAL;
pub const U_DT_FONT = UDecompositionType.FONT;
pub const U_DT_FRACTION = UDecompositionType.FRACTION;
pub const U_DT_INITIAL = UDecompositionType.INITIAL;
pub const U_DT_ISOLATED = UDecompositionType.ISOLATED;
pub const U_DT_MEDIAL = UDecompositionType.MEDIAL;
pub const U_DT_NARROW = UDecompositionType.NARROW;
pub const U_DT_NOBREAK = UDecompositionType.NOBREAK;
pub const U_DT_SMALL = UDecompositionType.SMALL;
pub const U_DT_SQUARE = UDecompositionType.SQUARE;
pub const U_DT_SUB = UDecompositionType.SUB;
pub const U_DT_SUPER = UDecompositionType.SUPER;
pub const U_DT_VERTICAL = UDecompositionType.VERTICAL;
pub const U_DT_WIDE = UDecompositionType.WIDE;

pub const UJoiningType = enum(i32) {
    NON_JOINING = 0,
    JOIN_CAUSING = 1,
    DUAL_JOINING = 2,
    LEFT_JOINING = 3,
    RIGHT_JOINING = 4,
    TRANSPARENT = 5,
};
pub const U_JT_NON_JOINING = UJoiningType.NON_JOINING;
pub const U_JT_JOIN_CAUSING = UJoiningType.JOIN_CAUSING;
pub const U_JT_DUAL_JOINING = UJoiningType.DUAL_JOINING;
pub const U_JT_LEFT_JOINING = UJoiningType.LEFT_JOINING;
pub const U_JT_RIGHT_JOINING = UJoiningType.RIGHT_JOINING;
pub const U_JT_TRANSPARENT = UJoiningType.TRANSPARENT;

pub const UJoiningGroup = enum(i32) {
    NO_JOINING_GROUP = 0,
    AIN = 1,
    ALAPH = 2,
    ALEF = 3,
    BEH = 4,
    BETH = 5,
    DAL = 6,
    DALATH_RISH = 7,
    E = 8,
    FEH = 9,
    FINAL_SEMKATH = 10,
    GAF = 11,
    GAMAL = 12,
    HAH = 13,
    TEH_MARBUTA_GOAL = 14,
    // HAMZA_ON_HEH_GOAL = 14, this enum value conflicts with TEH_MARBUTA_GOAL
    HE = 15,
    HEH = 16,
    HEH_GOAL = 17,
    HETH = 18,
    KAF = 19,
    KAPH = 20,
    KNOTTED_HEH = 21,
    LAM = 22,
    LAMADH = 23,
    MEEM = 24,
    MIM = 25,
    NOON = 26,
    NUN = 27,
    PE = 28,
    QAF = 29,
    QAPH = 30,
    REH = 31,
    REVERSED_PE = 32,
    SAD = 33,
    SADHE = 34,
    SEEN = 35,
    SEMKATH = 36,
    SHIN = 37,
    SWASH_KAF = 38,
    SYRIAC_WAW = 39,
    TAH = 40,
    TAW = 41,
    TEH_MARBUTA = 42,
    TETH = 43,
    WAW = 44,
    YEH = 45,
    YEH_BARREE = 46,
    YEH_WITH_TAIL = 47,
    YUDH = 48,
    YUDH_HE = 49,
    ZAIN = 50,
    FE = 51,
    KHAPH = 52,
    ZHAIN = 53,
    BURUSHASKI_YEH_BARREE = 54,
    FARSI_YEH = 55,
    NYA = 56,
    ROHINGYA_YEH = 57,
    MANICHAEAN_ALEPH = 58,
    MANICHAEAN_AYIN = 59,
    MANICHAEAN_BETH = 60,
    MANICHAEAN_DALETH = 61,
    MANICHAEAN_DHAMEDH = 62,
    MANICHAEAN_FIVE = 63,
    MANICHAEAN_GIMEL = 64,
    MANICHAEAN_HETH = 65,
    MANICHAEAN_HUNDRED = 66,
    MANICHAEAN_KAPH = 67,
    MANICHAEAN_LAMEDH = 68,
    MANICHAEAN_MEM = 69,
    MANICHAEAN_NUN = 70,
    MANICHAEAN_ONE = 71,
    MANICHAEAN_PE = 72,
    MANICHAEAN_QOPH = 73,
    MANICHAEAN_RESH = 74,
    MANICHAEAN_SADHE = 75,
    MANICHAEAN_SAMEKH = 76,
    MANICHAEAN_TAW = 77,
    MANICHAEAN_TEN = 78,
    MANICHAEAN_TETH = 79,
    MANICHAEAN_THAMEDH = 80,
    MANICHAEAN_TWENTY = 81,
    MANICHAEAN_WAW = 82,
    MANICHAEAN_YODH = 83,
    MANICHAEAN_ZAYIN = 84,
    STRAIGHT_WAW = 85,
    AFRICAN_FEH = 86,
    AFRICAN_NOON = 87,
    AFRICAN_QAF = 88,
    MALAYALAM_BHA = 89,
    MALAYALAM_JA = 90,
    MALAYALAM_LLA = 91,
    MALAYALAM_LLLA = 92,
    MALAYALAM_NGA = 93,
    MALAYALAM_NNA = 94,
    MALAYALAM_NNNA = 95,
    MALAYALAM_NYA = 96,
    MALAYALAM_RA = 97,
    MALAYALAM_SSA = 98,
    MALAYALAM_TTA = 99,
    HANIFI_ROHINGYA_KINNA_YA = 100,
    HANIFI_ROHINGYA_PA = 101,
};
pub const U_JG_NO_JOINING_GROUP = UJoiningGroup.NO_JOINING_GROUP;
pub const U_JG_AIN = UJoiningGroup.AIN;
pub const U_JG_ALAPH = UJoiningGroup.ALAPH;
pub const U_JG_ALEF = UJoiningGroup.ALEF;
pub const U_JG_BEH = UJoiningGroup.BEH;
pub const U_JG_BETH = UJoiningGroup.BETH;
pub const U_JG_DAL = UJoiningGroup.DAL;
pub const U_JG_DALATH_RISH = UJoiningGroup.DALATH_RISH;
pub const U_JG_E = UJoiningGroup.E;
pub const U_JG_FEH = UJoiningGroup.FEH;
pub const U_JG_FINAL_SEMKATH = UJoiningGroup.FINAL_SEMKATH;
pub const U_JG_GAF = UJoiningGroup.GAF;
pub const U_JG_GAMAL = UJoiningGroup.GAMAL;
pub const U_JG_HAH = UJoiningGroup.HAH;
pub const U_JG_TEH_MARBUTA_GOAL = UJoiningGroup.TEH_MARBUTA_GOAL;
pub const U_JG_HAMZA_ON_HEH_GOAL = UJoiningGroup.TEH_MARBUTA_GOAL;
pub const U_JG_HE = UJoiningGroup.HE;
pub const U_JG_HEH = UJoiningGroup.HEH;
pub const U_JG_HEH_GOAL = UJoiningGroup.HEH_GOAL;
pub const U_JG_HETH = UJoiningGroup.HETH;
pub const U_JG_KAF = UJoiningGroup.KAF;
pub const U_JG_KAPH = UJoiningGroup.KAPH;
pub const U_JG_KNOTTED_HEH = UJoiningGroup.KNOTTED_HEH;
pub const U_JG_LAM = UJoiningGroup.LAM;
pub const U_JG_LAMADH = UJoiningGroup.LAMADH;
pub const U_JG_MEEM = UJoiningGroup.MEEM;
pub const U_JG_MIM = UJoiningGroup.MIM;
pub const U_JG_NOON = UJoiningGroup.NOON;
pub const U_JG_NUN = UJoiningGroup.NUN;
pub const U_JG_PE = UJoiningGroup.PE;
pub const U_JG_QAF = UJoiningGroup.QAF;
pub const U_JG_QAPH = UJoiningGroup.QAPH;
pub const U_JG_REH = UJoiningGroup.REH;
pub const U_JG_REVERSED_PE = UJoiningGroup.REVERSED_PE;
pub const U_JG_SAD = UJoiningGroup.SAD;
pub const U_JG_SADHE = UJoiningGroup.SADHE;
pub const U_JG_SEEN = UJoiningGroup.SEEN;
pub const U_JG_SEMKATH = UJoiningGroup.SEMKATH;
pub const U_JG_SHIN = UJoiningGroup.SHIN;
pub const U_JG_SWASH_KAF = UJoiningGroup.SWASH_KAF;
pub const U_JG_SYRIAC_WAW = UJoiningGroup.SYRIAC_WAW;
pub const U_JG_TAH = UJoiningGroup.TAH;
pub const U_JG_TAW = UJoiningGroup.TAW;
pub const U_JG_TEH_MARBUTA = UJoiningGroup.TEH_MARBUTA;
pub const U_JG_TETH = UJoiningGroup.TETH;
pub const U_JG_WAW = UJoiningGroup.WAW;
pub const U_JG_YEH = UJoiningGroup.YEH;
pub const U_JG_YEH_BARREE = UJoiningGroup.YEH_BARREE;
pub const U_JG_YEH_WITH_TAIL = UJoiningGroup.YEH_WITH_TAIL;
pub const U_JG_YUDH = UJoiningGroup.YUDH;
pub const U_JG_YUDH_HE = UJoiningGroup.YUDH_HE;
pub const U_JG_ZAIN = UJoiningGroup.ZAIN;
pub const U_JG_FE = UJoiningGroup.FE;
pub const U_JG_KHAPH = UJoiningGroup.KHAPH;
pub const U_JG_ZHAIN = UJoiningGroup.ZHAIN;
pub const U_JG_BURUSHASKI_YEH_BARREE = UJoiningGroup.BURUSHASKI_YEH_BARREE;
pub const U_JG_FARSI_YEH = UJoiningGroup.FARSI_YEH;
pub const U_JG_NYA = UJoiningGroup.NYA;
pub const U_JG_ROHINGYA_YEH = UJoiningGroup.ROHINGYA_YEH;
pub const U_JG_MANICHAEAN_ALEPH = UJoiningGroup.MANICHAEAN_ALEPH;
pub const U_JG_MANICHAEAN_AYIN = UJoiningGroup.MANICHAEAN_AYIN;
pub const U_JG_MANICHAEAN_BETH = UJoiningGroup.MANICHAEAN_BETH;
pub const U_JG_MANICHAEAN_DALETH = UJoiningGroup.MANICHAEAN_DALETH;
pub const U_JG_MANICHAEAN_DHAMEDH = UJoiningGroup.MANICHAEAN_DHAMEDH;
pub const U_JG_MANICHAEAN_FIVE = UJoiningGroup.MANICHAEAN_FIVE;
pub const U_JG_MANICHAEAN_GIMEL = UJoiningGroup.MANICHAEAN_GIMEL;
pub const U_JG_MANICHAEAN_HETH = UJoiningGroup.MANICHAEAN_HETH;
pub const U_JG_MANICHAEAN_HUNDRED = UJoiningGroup.MANICHAEAN_HUNDRED;
pub const U_JG_MANICHAEAN_KAPH = UJoiningGroup.MANICHAEAN_KAPH;
pub const U_JG_MANICHAEAN_LAMEDH = UJoiningGroup.MANICHAEAN_LAMEDH;
pub const U_JG_MANICHAEAN_MEM = UJoiningGroup.MANICHAEAN_MEM;
pub const U_JG_MANICHAEAN_NUN = UJoiningGroup.MANICHAEAN_NUN;
pub const U_JG_MANICHAEAN_ONE = UJoiningGroup.MANICHAEAN_ONE;
pub const U_JG_MANICHAEAN_PE = UJoiningGroup.MANICHAEAN_PE;
pub const U_JG_MANICHAEAN_QOPH = UJoiningGroup.MANICHAEAN_QOPH;
pub const U_JG_MANICHAEAN_RESH = UJoiningGroup.MANICHAEAN_RESH;
pub const U_JG_MANICHAEAN_SADHE = UJoiningGroup.MANICHAEAN_SADHE;
pub const U_JG_MANICHAEAN_SAMEKH = UJoiningGroup.MANICHAEAN_SAMEKH;
pub const U_JG_MANICHAEAN_TAW = UJoiningGroup.MANICHAEAN_TAW;
pub const U_JG_MANICHAEAN_TEN = UJoiningGroup.MANICHAEAN_TEN;
pub const U_JG_MANICHAEAN_TETH = UJoiningGroup.MANICHAEAN_TETH;
pub const U_JG_MANICHAEAN_THAMEDH = UJoiningGroup.MANICHAEAN_THAMEDH;
pub const U_JG_MANICHAEAN_TWENTY = UJoiningGroup.MANICHAEAN_TWENTY;
pub const U_JG_MANICHAEAN_WAW = UJoiningGroup.MANICHAEAN_WAW;
pub const U_JG_MANICHAEAN_YODH = UJoiningGroup.MANICHAEAN_YODH;
pub const U_JG_MANICHAEAN_ZAYIN = UJoiningGroup.MANICHAEAN_ZAYIN;
pub const U_JG_STRAIGHT_WAW = UJoiningGroup.STRAIGHT_WAW;
pub const U_JG_AFRICAN_FEH = UJoiningGroup.AFRICAN_FEH;
pub const U_JG_AFRICAN_NOON = UJoiningGroup.AFRICAN_NOON;
pub const U_JG_AFRICAN_QAF = UJoiningGroup.AFRICAN_QAF;
pub const U_JG_MALAYALAM_BHA = UJoiningGroup.MALAYALAM_BHA;
pub const U_JG_MALAYALAM_JA = UJoiningGroup.MALAYALAM_JA;
pub const U_JG_MALAYALAM_LLA = UJoiningGroup.MALAYALAM_LLA;
pub const U_JG_MALAYALAM_LLLA = UJoiningGroup.MALAYALAM_LLLA;
pub const U_JG_MALAYALAM_NGA = UJoiningGroup.MALAYALAM_NGA;
pub const U_JG_MALAYALAM_NNA = UJoiningGroup.MALAYALAM_NNA;
pub const U_JG_MALAYALAM_NNNA = UJoiningGroup.MALAYALAM_NNNA;
pub const U_JG_MALAYALAM_NYA = UJoiningGroup.MALAYALAM_NYA;
pub const U_JG_MALAYALAM_RA = UJoiningGroup.MALAYALAM_RA;
pub const U_JG_MALAYALAM_SSA = UJoiningGroup.MALAYALAM_SSA;
pub const U_JG_MALAYALAM_TTA = UJoiningGroup.MALAYALAM_TTA;
pub const U_JG_HANIFI_ROHINGYA_KINNA_YA = UJoiningGroup.HANIFI_ROHINGYA_KINNA_YA;
pub const U_JG_HANIFI_ROHINGYA_PA = UJoiningGroup.HANIFI_ROHINGYA_PA;

pub const UGraphemeClusterBreak = enum(i32) {
    OTHER = 0,
    CONTROL = 1,
    CR = 2,
    EXTEND = 3,
    L = 4,
    LF = 5,
    LV = 6,
    LVT = 7,
    T = 8,
    V = 9,
    SPACING_MARK = 10,
    PREPEND = 11,
    REGIONAL_INDICATOR = 12,
    E_BASE = 13,
    E_BASE_GAZ = 14,
    E_MODIFIER = 15,
    GLUE_AFTER_ZWJ = 16,
    ZWJ = 17,
};
pub const U_GCB_OTHER = UGraphemeClusterBreak.OTHER;
pub const U_GCB_CONTROL = UGraphemeClusterBreak.CONTROL;
pub const U_GCB_CR = UGraphemeClusterBreak.CR;
pub const U_GCB_EXTEND = UGraphemeClusterBreak.EXTEND;
pub const U_GCB_L = UGraphemeClusterBreak.L;
pub const U_GCB_LF = UGraphemeClusterBreak.LF;
pub const U_GCB_LV = UGraphemeClusterBreak.LV;
pub const U_GCB_LVT = UGraphemeClusterBreak.LVT;
pub const U_GCB_T = UGraphemeClusterBreak.T;
pub const U_GCB_V = UGraphemeClusterBreak.V;
pub const U_GCB_SPACING_MARK = UGraphemeClusterBreak.SPACING_MARK;
pub const U_GCB_PREPEND = UGraphemeClusterBreak.PREPEND;
pub const U_GCB_REGIONAL_INDICATOR = UGraphemeClusterBreak.REGIONAL_INDICATOR;
pub const U_GCB_E_BASE = UGraphemeClusterBreak.E_BASE;
pub const U_GCB_E_BASE_GAZ = UGraphemeClusterBreak.E_BASE_GAZ;
pub const U_GCB_E_MODIFIER = UGraphemeClusterBreak.E_MODIFIER;
pub const U_GCB_GLUE_AFTER_ZWJ = UGraphemeClusterBreak.GLUE_AFTER_ZWJ;
pub const U_GCB_ZWJ = UGraphemeClusterBreak.ZWJ;

pub const UWordBreakValues = enum(i32) {
    OTHER = 0,
    ALETTER = 1,
    FORMAT = 2,
    KATAKANA = 3,
    MIDLETTER = 4,
    MIDNUM = 5,
    NUMERIC = 6,
    EXTENDNUMLET = 7,
    CR = 8,
    EXTEND = 9,
    LF = 10,
    MIDNUMLET = 11,
    NEWLINE = 12,
    REGIONAL_INDICATOR = 13,
    HEBREW_LETTER = 14,
    SINGLE_QUOTE = 15,
    DOUBLE_QUOTE = 16,
    E_BASE = 17,
    E_BASE_GAZ = 18,
    E_MODIFIER = 19,
    GLUE_AFTER_ZWJ = 20,
    ZWJ = 21,
    WSEGSPACE = 22,
};
pub const U_WB_OTHER = UWordBreakValues.OTHER;
pub const U_WB_ALETTER = UWordBreakValues.ALETTER;
pub const U_WB_FORMAT = UWordBreakValues.FORMAT;
pub const U_WB_KATAKANA = UWordBreakValues.KATAKANA;
pub const U_WB_MIDLETTER = UWordBreakValues.MIDLETTER;
pub const U_WB_MIDNUM = UWordBreakValues.MIDNUM;
pub const U_WB_NUMERIC = UWordBreakValues.NUMERIC;
pub const U_WB_EXTENDNUMLET = UWordBreakValues.EXTENDNUMLET;
pub const U_WB_CR = UWordBreakValues.CR;
pub const U_WB_EXTEND = UWordBreakValues.EXTEND;
pub const U_WB_LF = UWordBreakValues.LF;
pub const U_WB_MIDNUMLET = UWordBreakValues.MIDNUMLET;
pub const U_WB_NEWLINE = UWordBreakValues.NEWLINE;
pub const U_WB_REGIONAL_INDICATOR = UWordBreakValues.REGIONAL_INDICATOR;
pub const U_WB_HEBREW_LETTER = UWordBreakValues.HEBREW_LETTER;
pub const U_WB_SINGLE_QUOTE = UWordBreakValues.SINGLE_QUOTE;
pub const U_WB_DOUBLE_QUOTE = UWordBreakValues.DOUBLE_QUOTE;
pub const U_WB_E_BASE = UWordBreakValues.E_BASE;
pub const U_WB_E_BASE_GAZ = UWordBreakValues.E_BASE_GAZ;
pub const U_WB_E_MODIFIER = UWordBreakValues.E_MODIFIER;
pub const U_WB_GLUE_AFTER_ZWJ = UWordBreakValues.GLUE_AFTER_ZWJ;
pub const U_WB_ZWJ = UWordBreakValues.ZWJ;
pub const U_WB_WSEGSPACE = UWordBreakValues.WSEGSPACE;

pub const USentenceBreak = enum(i32) {
    OTHER = 0,
    ATERM = 1,
    CLOSE = 2,
    FORMAT = 3,
    LOWER = 4,
    NUMERIC = 5,
    OLETTER = 6,
    SEP = 7,
    SP = 8,
    STERM = 9,
    UPPER = 10,
    CR = 11,
    EXTEND = 12,
    LF = 13,
    SCONTINUE = 14,
};
pub const U_SB_OTHER = USentenceBreak.OTHER;
pub const U_SB_ATERM = USentenceBreak.ATERM;
pub const U_SB_CLOSE = USentenceBreak.CLOSE;
pub const U_SB_FORMAT = USentenceBreak.FORMAT;
pub const U_SB_LOWER = USentenceBreak.LOWER;
pub const U_SB_NUMERIC = USentenceBreak.NUMERIC;
pub const U_SB_OLETTER = USentenceBreak.OLETTER;
pub const U_SB_SEP = USentenceBreak.SEP;
pub const U_SB_SP = USentenceBreak.SP;
pub const U_SB_STERM = USentenceBreak.STERM;
pub const U_SB_UPPER = USentenceBreak.UPPER;
pub const U_SB_CR = USentenceBreak.CR;
pub const U_SB_EXTEND = USentenceBreak.EXTEND;
pub const U_SB_LF = USentenceBreak.LF;
pub const U_SB_SCONTINUE = USentenceBreak.SCONTINUE;

pub const ULineBreak = enum(i32) {
    UNKNOWN = 0,
    AMBIGUOUS = 1,
    ALPHABETIC = 2,
    BREAK_BOTH = 3,
    BREAK_AFTER = 4,
    BREAK_BEFORE = 5,
    MANDATORY_BREAK = 6,
    CONTINGENT_BREAK = 7,
    CLOSE_PUNCTUATION = 8,
    COMBINING_MARK = 9,
    CARRIAGE_RETURN = 10,
    EXCLAMATION = 11,
    GLUE = 12,
    HYPHEN = 13,
    IDEOGRAPHIC = 14,
    INSEPARABLE = 15,
    // INSEPERABLE = 15, this enum value conflicts with INSEPARABLE
    INFIX_NUMERIC = 16,
    LINE_FEED = 17,
    NONSTARTER = 18,
    NUMERIC = 19,
    OPEN_PUNCTUATION = 20,
    POSTFIX_NUMERIC = 21,
    PREFIX_NUMERIC = 22,
    QUOTATION = 23,
    COMPLEX_CONTEXT = 24,
    SURROGATE = 25,
    SPACE = 26,
    BREAK_SYMBOLS = 27,
    ZWSPACE = 28,
    NEXT_LINE = 29,
    WORD_JOINER = 30,
    H2 = 31,
    H3 = 32,
    JL = 33,
    JT = 34,
    JV = 35,
    CLOSE_PARENTHESIS = 36,
    CONDITIONAL_JAPANESE_STARTER = 37,
    HEBREW_LETTER = 38,
    REGIONAL_INDICATOR = 39,
    E_BASE = 40,
    E_MODIFIER = 41,
    ZWJ = 42,
};
pub const U_LB_UNKNOWN = ULineBreak.UNKNOWN;
pub const U_LB_AMBIGUOUS = ULineBreak.AMBIGUOUS;
pub const U_LB_ALPHABETIC = ULineBreak.ALPHABETIC;
pub const U_LB_BREAK_BOTH = ULineBreak.BREAK_BOTH;
pub const U_LB_BREAK_AFTER = ULineBreak.BREAK_AFTER;
pub const U_LB_BREAK_BEFORE = ULineBreak.BREAK_BEFORE;
pub const U_LB_MANDATORY_BREAK = ULineBreak.MANDATORY_BREAK;
pub const U_LB_CONTINGENT_BREAK = ULineBreak.CONTINGENT_BREAK;
pub const U_LB_CLOSE_PUNCTUATION = ULineBreak.CLOSE_PUNCTUATION;
pub const U_LB_COMBINING_MARK = ULineBreak.COMBINING_MARK;
pub const U_LB_CARRIAGE_RETURN = ULineBreak.CARRIAGE_RETURN;
pub const U_LB_EXCLAMATION = ULineBreak.EXCLAMATION;
pub const U_LB_GLUE = ULineBreak.GLUE;
pub const U_LB_HYPHEN = ULineBreak.HYPHEN;
pub const U_LB_IDEOGRAPHIC = ULineBreak.IDEOGRAPHIC;
pub const U_LB_INSEPARABLE = ULineBreak.INSEPARABLE;
pub const U_LB_INSEPERABLE = ULineBreak.INSEPARABLE;
pub const U_LB_INFIX_NUMERIC = ULineBreak.INFIX_NUMERIC;
pub const U_LB_LINE_FEED = ULineBreak.LINE_FEED;
pub const U_LB_NONSTARTER = ULineBreak.NONSTARTER;
pub const U_LB_NUMERIC = ULineBreak.NUMERIC;
pub const U_LB_OPEN_PUNCTUATION = ULineBreak.OPEN_PUNCTUATION;
pub const U_LB_POSTFIX_NUMERIC = ULineBreak.POSTFIX_NUMERIC;
pub const U_LB_PREFIX_NUMERIC = ULineBreak.PREFIX_NUMERIC;
pub const U_LB_QUOTATION = ULineBreak.QUOTATION;
pub const U_LB_COMPLEX_CONTEXT = ULineBreak.COMPLEX_CONTEXT;
pub const U_LB_SURROGATE = ULineBreak.SURROGATE;
pub const U_LB_SPACE = ULineBreak.SPACE;
pub const U_LB_BREAK_SYMBOLS = ULineBreak.BREAK_SYMBOLS;
pub const U_LB_ZWSPACE = ULineBreak.ZWSPACE;
pub const U_LB_NEXT_LINE = ULineBreak.NEXT_LINE;
pub const U_LB_WORD_JOINER = ULineBreak.WORD_JOINER;
pub const U_LB_H2 = ULineBreak.H2;
pub const U_LB_H3 = ULineBreak.H3;
pub const U_LB_JL = ULineBreak.JL;
pub const U_LB_JT = ULineBreak.JT;
pub const U_LB_JV = ULineBreak.JV;
pub const U_LB_CLOSE_PARENTHESIS = ULineBreak.CLOSE_PARENTHESIS;
pub const U_LB_CONDITIONAL_JAPANESE_STARTER = ULineBreak.CONDITIONAL_JAPANESE_STARTER;
pub const U_LB_HEBREW_LETTER = ULineBreak.HEBREW_LETTER;
pub const U_LB_REGIONAL_INDICATOR = ULineBreak.REGIONAL_INDICATOR;
pub const U_LB_E_BASE = ULineBreak.E_BASE;
pub const U_LB_E_MODIFIER = ULineBreak.E_MODIFIER;
pub const U_LB_ZWJ = ULineBreak.ZWJ;

pub const UNumericType = enum(i32) {
    NONE = 0,
    DECIMAL = 1,
    DIGIT = 2,
    NUMERIC = 3,
};
pub const U_NT_NONE = UNumericType.NONE;
pub const U_NT_DECIMAL = UNumericType.DECIMAL;
pub const U_NT_DIGIT = UNumericType.DIGIT;
pub const U_NT_NUMERIC = UNumericType.NUMERIC;

pub const UHangulSyllableType = enum(i32) {
    NOT_APPLICABLE = 0,
    LEADING_JAMO = 1,
    VOWEL_JAMO = 2,
    TRAILING_JAMO = 3,
    LV_SYLLABLE = 4,
    LVT_SYLLABLE = 5,
};
pub const U_HST_NOT_APPLICABLE = UHangulSyllableType.NOT_APPLICABLE;
pub const U_HST_LEADING_JAMO = UHangulSyllableType.LEADING_JAMO;
pub const U_HST_VOWEL_JAMO = UHangulSyllableType.VOWEL_JAMO;
pub const U_HST_TRAILING_JAMO = UHangulSyllableType.TRAILING_JAMO;
pub const U_HST_LV_SYLLABLE = UHangulSyllableType.LV_SYLLABLE;
pub const U_HST_LVT_SYLLABLE = UHangulSyllableType.LVT_SYLLABLE;

pub const UIndicPositionalCategory = enum(i32) {
    NA = 0,
    BOTTOM = 1,
    BOTTOM_AND_LEFT = 2,
    BOTTOM_AND_RIGHT = 3,
    LEFT = 4,
    LEFT_AND_RIGHT = 5,
    OVERSTRUCK = 6,
    RIGHT = 7,
    TOP = 8,
    TOP_AND_BOTTOM = 9,
    TOP_AND_BOTTOM_AND_RIGHT = 10,
    TOP_AND_LEFT = 11,
    TOP_AND_LEFT_AND_RIGHT = 12,
    TOP_AND_RIGHT = 13,
    VISUAL_ORDER_LEFT = 14,
    TOP_AND_BOTTOM_AND_LEFT = 15,
};
pub const U_INPC_NA = UIndicPositionalCategory.NA;
pub const U_INPC_BOTTOM = UIndicPositionalCategory.BOTTOM;
pub const U_INPC_BOTTOM_AND_LEFT = UIndicPositionalCategory.BOTTOM_AND_LEFT;
pub const U_INPC_BOTTOM_AND_RIGHT = UIndicPositionalCategory.BOTTOM_AND_RIGHT;
pub const U_INPC_LEFT = UIndicPositionalCategory.LEFT;
pub const U_INPC_LEFT_AND_RIGHT = UIndicPositionalCategory.LEFT_AND_RIGHT;
pub const U_INPC_OVERSTRUCK = UIndicPositionalCategory.OVERSTRUCK;
pub const U_INPC_RIGHT = UIndicPositionalCategory.RIGHT;
pub const U_INPC_TOP = UIndicPositionalCategory.TOP;
pub const U_INPC_TOP_AND_BOTTOM = UIndicPositionalCategory.TOP_AND_BOTTOM;
pub const U_INPC_TOP_AND_BOTTOM_AND_RIGHT = UIndicPositionalCategory.TOP_AND_BOTTOM_AND_RIGHT;
pub const U_INPC_TOP_AND_LEFT = UIndicPositionalCategory.TOP_AND_LEFT;
pub const U_INPC_TOP_AND_LEFT_AND_RIGHT = UIndicPositionalCategory.TOP_AND_LEFT_AND_RIGHT;
pub const U_INPC_TOP_AND_RIGHT = UIndicPositionalCategory.TOP_AND_RIGHT;
pub const U_INPC_VISUAL_ORDER_LEFT = UIndicPositionalCategory.VISUAL_ORDER_LEFT;
pub const U_INPC_TOP_AND_BOTTOM_AND_LEFT = UIndicPositionalCategory.TOP_AND_BOTTOM_AND_LEFT;

pub const UIndicSyllabicCategory = enum(i32) {
    OTHER = 0,
    AVAGRAHA = 1,
    BINDU = 2,
    BRAHMI_JOINING_NUMBER = 3,
    CANTILLATION_MARK = 4,
    CONSONANT = 5,
    CONSONANT_DEAD = 6,
    CONSONANT_FINAL = 7,
    CONSONANT_HEAD_LETTER = 8,
    CONSONANT_INITIAL_POSTFIXED = 9,
    CONSONANT_KILLER = 10,
    CONSONANT_MEDIAL = 11,
    CONSONANT_PLACEHOLDER = 12,
    CONSONANT_PRECEDING_REPHA = 13,
    CONSONANT_PREFIXED = 14,
    CONSONANT_SUBJOINED = 15,
    CONSONANT_SUCCEEDING_REPHA = 16,
    CONSONANT_WITH_STACKER = 17,
    GEMINATION_MARK = 18,
    INVISIBLE_STACKER = 19,
    JOINER = 20,
    MODIFYING_LETTER = 21,
    NON_JOINER = 22,
    NUKTA = 23,
    NUMBER = 24,
    NUMBER_JOINER = 25,
    PURE_KILLER = 26,
    REGISTER_SHIFTER = 27,
    SYLLABLE_MODIFIER = 28,
    TONE_LETTER = 29,
    TONE_MARK = 30,
    VIRAMA = 31,
    VISARGA = 32,
    VOWEL = 33,
    VOWEL_DEPENDENT = 34,
    VOWEL_INDEPENDENT = 35,
};
pub const U_INSC_OTHER = UIndicSyllabicCategory.OTHER;
pub const U_INSC_AVAGRAHA = UIndicSyllabicCategory.AVAGRAHA;
pub const U_INSC_BINDU = UIndicSyllabicCategory.BINDU;
pub const U_INSC_BRAHMI_JOINING_NUMBER = UIndicSyllabicCategory.BRAHMI_JOINING_NUMBER;
pub const U_INSC_CANTILLATION_MARK = UIndicSyllabicCategory.CANTILLATION_MARK;
pub const U_INSC_CONSONANT = UIndicSyllabicCategory.CONSONANT;
pub const U_INSC_CONSONANT_DEAD = UIndicSyllabicCategory.CONSONANT_DEAD;
pub const U_INSC_CONSONANT_FINAL = UIndicSyllabicCategory.CONSONANT_FINAL;
pub const U_INSC_CONSONANT_HEAD_LETTER = UIndicSyllabicCategory.CONSONANT_HEAD_LETTER;
pub const U_INSC_CONSONANT_INITIAL_POSTFIXED = UIndicSyllabicCategory.CONSONANT_INITIAL_POSTFIXED;
pub const U_INSC_CONSONANT_KILLER = UIndicSyllabicCategory.CONSONANT_KILLER;
pub const U_INSC_CONSONANT_MEDIAL = UIndicSyllabicCategory.CONSONANT_MEDIAL;
pub const U_INSC_CONSONANT_PLACEHOLDER = UIndicSyllabicCategory.CONSONANT_PLACEHOLDER;
pub const U_INSC_CONSONANT_PRECEDING_REPHA = UIndicSyllabicCategory.CONSONANT_PRECEDING_REPHA;
pub const U_INSC_CONSONANT_PREFIXED = UIndicSyllabicCategory.CONSONANT_PREFIXED;
pub const U_INSC_CONSONANT_SUBJOINED = UIndicSyllabicCategory.CONSONANT_SUBJOINED;
pub const U_INSC_CONSONANT_SUCCEEDING_REPHA = UIndicSyllabicCategory.CONSONANT_SUCCEEDING_REPHA;
pub const U_INSC_CONSONANT_WITH_STACKER = UIndicSyllabicCategory.CONSONANT_WITH_STACKER;
pub const U_INSC_GEMINATION_MARK = UIndicSyllabicCategory.GEMINATION_MARK;
pub const U_INSC_INVISIBLE_STACKER = UIndicSyllabicCategory.INVISIBLE_STACKER;
pub const U_INSC_JOINER = UIndicSyllabicCategory.JOINER;
pub const U_INSC_MODIFYING_LETTER = UIndicSyllabicCategory.MODIFYING_LETTER;
pub const U_INSC_NON_JOINER = UIndicSyllabicCategory.NON_JOINER;
pub const U_INSC_NUKTA = UIndicSyllabicCategory.NUKTA;
pub const U_INSC_NUMBER = UIndicSyllabicCategory.NUMBER;
pub const U_INSC_NUMBER_JOINER = UIndicSyllabicCategory.NUMBER_JOINER;
pub const U_INSC_PURE_KILLER = UIndicSyllabicCategory.PURE_KILLER;
pub const U_INSC_REGISTER_SHIFTER = UIndicSyllabicCategory.REGISTER_SHIFTER;
pub const U_INSC_SYLLABLE_MODIFIER = UIndicSyllabicCategory.SYLLABLE_MODIFIER;
pub const U_INSC_TONE_LETTER = UIndicSyllabicCategory.TONE_LETTER;
pub const U_INSC_TONE_MARK = UIndicSyllabicCategory.TONE_MARK;
pub const U_INSC_VIRAMA = UIndicSyllabicCategory.VIRAMA;
pub const U_INSC_VISARGA = UIndicSyllabicCategory.VISARGA;
pub const U_INSC_VOWEL = UIndicSyllabicCategory.VOWEL;
pub const U_INSC_VOWEL_DEPENDENT = UIndicSyllabicCategory.VOWEL_DEPENDENT;
pub const U_INSC_VOWEL_INDEPENDENT = UIndicSyllabicCategory.VOWEL_INDEPENDENT;

pub const UVerticalOrientation = enum(i32) {
    ROTATED = 0,
    TRANSFORMED_ROTATED = 1,
    TRANSFORMED_UPRIGHT = 2,
    UPRIGHT = 3,
};
pub const U_VO_ROTATED = UVerticalOrientation.ROTATED;
pub const U_VO_TRANSFORMED_ROTATED = UVerticalOrientation.TRANSFORMED_ROTATED;
pub const U_VO_TRANSFORMED_UPRIGHT = UVerticalOrientation.TRANSFORMED_UPRIGHT;
pub const U_VO_UPRIGHT = UVerticalOrientation.UPRIGHT;

pub const UCharEnumTypeRange = *const fn (
    context: ?*const anyopaque,
    start: i32,
    limit: i32,
    type: UCharCategory,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UEnumCharNamesFn = *const fn (
    context: ?*anyopaque,
    code: i32,
    name_choice: UCharNameChoice,
    name: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const UBiDiDirection = enum(i32) {
    LTR = 0,
    RTL = 1,
    MIXED = 2,
    NEUTRAL = 3,
};
pub const UBIDI_LTR = UBiDiDirection.LTR;
pub const UBIDI_RTL = UBiDiDirection.RTL;
pub const UBIDI_MIXED = UBiDiDirection.MIXED;
pub const UBIDI_NEUTRAL = UBiDiDirection.NEUTRAL;

pub const UBiDi = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UBiDiReorderingMode = enum(i32) {
    DEFAULT = 0,
    NUMBERS_SPECIAL = 1,
    GROUP_NUMBERS_WITH_R = 2,
    RUNS_ONLY = 3,
    INVERSE_NUMBERS_AS_L = 4,
    INVERSE_LIKE_DIRECT = 5,
    INVERSE_FOR_NUMBERS_SPECIAL = 6,
};
pub const UBIDI_REORDER_DEFAULT = UBiDiReorderingMode.DEFAULT;
pub const UBIDI_REORDER_NUMBERS_SPECIAL = UBiDiReorderingMode.NUMBERS_SPECIAL;
pub const UBIDI_REORDER_GROUP_NUMBERS_WITH_R = UBiDiReorderingMode.GROUP_NUMBERS_WITH_R;
pub const UBIDI_REORDER_RUNS_ONLY = UBiDiReorderingMode.RUNS_ONLY;
pub const UBIDI_REORDER_INVERSE_NUMBERS_AS_L = UBiDiReorderingMode.INVERSE_NUMBERS_AS_L;
pub const UBIDI_REORDER_INVERSE_LIKE_DIRECT = UBiDiReorderingMode.INVERSE_LIKE_DIRECT;
pub const UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL = UBiDiReorderingMode.INVERSE_FOR_NUMBERS_SPECIAL;

pub const UBiDiReorderingOption = enum(i32) {
    DEFAULT = 0,
    INSERT_MARKS = 1,
    REMOVE_CONTROLS = 2,
    STREAMING = 4,
};
pub const UBIDI_OPTION_DEFAULT = UBiDiReorderingOption.DEFAULT;
pub const UBIDI_OPTION_INSERT_MARKS = UBiDiReorderingOption.INSERT_MARKS;
pub const UBIDI_OPTION_REMOVE_CONTROLS = UBiDiReorderingOption.REMOVE_CONTROLS;
pub const UBIDI_OPTION_STREAMING = UBiDiReorderingOption.STREAMING;

pub const UBiDiClassCallback = *const fn (
    context: ?*const anyopaque,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub const UBiDiOrder = enum(i32) {
    LOGICAL = 0,
    VISUAL = 1,
};
pub const UBIDI_LOGICAL = UBiDiOrder.LOGICAL;
pub const UBIDI_VISUAL = UBiDiOrder.VISUAL;

pub const UBiDiMirroring = enum(i32) {
    FF = 0,
    N = 1,
};
pub const UBIDI_MIRRORING_OFF = UBiDiMirroring.FF;
pub const UBIDI_MIRRORING_ON = UBiDiMirroring.N;

pub const UBiDiTransform = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextClone = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextNativeLength = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextAccess = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextExtract = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextReplace = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextCopy = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextMapOffsetToNative = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextMapNativeIndexToUTF16 = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const UTextClose = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const UTextFuncs = extern struct {
    tableSize: i32,
    reserved1: i32,
    reserved2: i32,
    reserved3: i32,
    clone: ?UTextClone,
    nativeLength: ?UTextNativeLength,
    access: ?UTextAccess,
    extract: ?UTextExtract,
    replace: ?UTextReplace,
    copy: ?UTextCopy,
    mapOffsetToNative: ?UTextMapOffsetToNative,
    mapNativeIndexToUTF16: ?UTextMapNativeIndexToUTF16,
    close: ?UTextClose,
    spare1: ?UTextClose,
    spare2: ?UTextClose,
    spare3: ?UTextClose,
};

pub const UText = extern struct {
    magic: u32,
    flags: i32,
    providerProperties: i32,
    sizeOfStruct: i32,
    chunkNativeLimit: i64,
    extraSize: i32,
    nativeIndexingLimit: i32,
    chunkNativeStart: i64,
    chunkOffset: i32,
    chunkLength: i32,
    chunkContents: ?*const u16,
    pFuncs: ?*const UTextFuncs,
    pExtra: ?*anyopaque,
    context: ?*const anyopaque,
    p: ?*const anyopaque,
    q: ?*const anyopaque,
    r: ?*const anyopaque,
    privP: ?*anyopaque,
    a: i64,
    b: i32,
    c: i32,
    privA: i64,
    privB: i32,
    privC: i32,
};

pub const USetSpanCondition = enum(i32) {
    NOT_CONTAINED = 0,
    CONTAINED = 1,
    SIMPLE = 2,
};
pub const USET_SPAN_NOT_CONTAINED = USetSpanCondition.NOT_CONTAINED;
pub const USET_SPAN_CONTAINED = USetSpanCondition.CONTAINED;
pub const USET_SPAN_SIMPLE = USetSpanCondition.SIMPLE;

pub const USerializedSet = extern struct {
    array: ?*const u16,
    bmpLength: i32,
    length: i32,
    staticArray: [8]u16,
};

pub const UNormalization2Mode = enum(i32) {
    COMPOSE = 0,
    DECOMPOSE = 1,
    FCD = 2,
    COMPOSE_CONTIGUOUS = 3,
};
pub const UNORM2_COMPOSE = UNormalization2Mode.COMPOSE;
pub const UNORM2_DECOMPOSE = UNormalization2Mode.DECOMPOSE;
pub const UNORM2_FCD = UNormalization2Mode.FCD;
pub const UNORM2_COMPOSE_CONTIGUOUS = UNormalization2Mode.COMPOSE_CONTIGUOUS;

pub const UNormalizationCheckResult = enum(i32) {
    NO = 0,
    YES = 1,
    MAYBE = 2,
};
pub const UNORM_NO = UNormalizationCheckResult.NO;
pub const UNORM_YES = UNormalizationCheckResult.YES;
pub const UNORM_MAYBE = UNormalizationCheckResult.MAYBE;

pub const UNormalizer2 = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNormalizationMode = enum(i32) {
    NONE = 1,
    NFD = 2,
    NFKD = 3,
    NFC = 4,
    // DEFAULT = 4, this enum value conflicts with NFC
    NFKC = 5,
    FCD = 6,
    MODE_COUNT = 7,
};
pub const UNORM_NONE = UNormalizationMode.NONE;
pub const UNORM_NFD = UNormalizationMode.NFD;
pub const UNORM_NFKD = UNormalizationMode.NFKD;
pub const UNORM_NFC = UNormalizationMode.NFC;
pub const UNORM_DEFAULT = UNormalizationMode.NFC;
pub const UNORM_NFKC = UNormalizationMode.NFKC;
pub const UNORM_FCD = UNormalizationMode.FCD;
pub const UNORM_MODE_COUNT = UNormalizationMode.MODE_COUNT;

pub const UConverterSelector = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UBreakIterator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNESCAPE_CHAR_AT = *const fn (
    offset: i32,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u16;

pub const UCaseMap = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UParseError = extern struct {
    line: i32,
    offset: i32,
    preContext: [16]u16,
    postContext: [16]u16,
};

pub const UStringPrepProfile = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UStringPrepProfileType = enum(i32) {
    @"3491_NAMEPREP" = 0,
    @"3530_NFS4_CS_PREP" = 1,
    @"3530_NFS4_CS_PREP_CI" = 2,
    @"3530_NFS4_CIS_PREP" = 3,
    @"3530_NFS4_MIXED_PREP_PREFIX" = 4,
    @"3530_NFS4_MIXED_PREP_SUFFIX" = 5,
    @"3722_ISCSI" = 6,
    @"3920_NODEPREP" = 7,
    @"3920_RESOURCEPREP" = 8,
    @"4011_MIB" = 9,
    @"4013_SASLPREP" = 10,
    @"4505_TRACE" = 11,
    @"4518_LDAP" = 12,
    @"4518_LDAP_CI" = 13,
};
pub const USPREP_RFC3491_NAMEPREP = UStringPrepProfileType.@"3491_NAMEPREP";
pub const USPREP_RFC3530_NFS4_CS_PREP = UStringPrepProfileType.@"3530_NFS4_CS_PREP";
pub const USPREP_RFC3530_NFS4_CS_PREP_CI = UStringPrepProfileType.@"3530_NFS4_CS_PREP_CI";
pub const USPREP_RFC3530_NFS4_CIS_PREP = UStringPrepProfileType.@"3530_NFS4_CIS_PREP";
pub const USPREP_RFC3530_NFS4_MIXED_PREP_PREFIX = UStringPrepProfileType.@"3530_NFS4_MIXED_PREP_PREFIX";
pub const USPREP_RFC3530_NFS4_MIXED_PREP_SUFFIX = UStringPrepProfileType.@"3530_NFS4_MIXED_PREP_SUFFIX";
pub const USPREP_RFC3722_ISCSI = UStringPrepProfileType.@"3722_ISCSI";
pub const USPREP_RFC3920_NODEPREP = UStringPrepProfileType.@"3920_NODEPREP";
pub const USPREP_RFC3920_RESOURCEPREP = UStringPrepProfileType.@"3920_RESOURCEPREP";
pub const USPREP_RFC4011_MIB = UStringPrepProfileType.@"4011_MIB";
pub const USPREP_RFC4013_SASLPREP = UStringPrepProfileType.@"4013_SASLPREP";
pub const USPREP_RFC4505_TRACE = UStringPrepProfileType.@"4505_TRACE";
pub const USPREP_RFC4518_LDAP = UStringPrepProfileType.@"4518_LDAP";
pub const USPREP_RFC4518_LDAP_CI = UStringPrepProfileType.@"4518_LDAP_CI";

pub const UIDNA = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UIDNAInfo = extern struct {
    size: i16,
    isTransitionalDifferent: i8,
    reservedB3: i8,
    errors: u32,
    reservedI2: i32,
    reservedI3: i32,
};

pub const UBreakIteratorType = enum(i32) {
    CHARACTER = 0,
    WORD = 1,
    LINE = 2,
    SENTENCE = 3,
};
pub const UBRK_CHARACTER = UBreakIteratorType.CHARACTER;
pub const UBRK_WORD = UBreakIteratorType.WORD;
pub const UBRK_LINE = UBreakIteratorType.LINE;
pub const UBRK_SENTENCE = UBreakIteratorType.SENTENCE;

pub const UWordBreak = enum(i32) {
    NONE = 0,
    NONE_LIMIT = 100,
    // NUMBER = 100, this enum value conflicts with NONE_LIMIT
    NUMBER_LIMIT = 200,
    // LETTER = 200, this enum value conflicts with NUMBER_LIMIT
    LETTER_LIMIT = 300,
    // KANA = 300, this enum value conflicts with LETTER_LIMIT
    KANA_LIMIT = 400,
    // IDEO = 400, this enum value conflicts with KANA_LIMIT
    IDEO_LIMIT = 500,
};
pub const UBRK_WORD_NONE = UWordBreak.NONE;
pub const UBRK_WORD_NONE_LIMIT = UWordBreak.NONE_LIMIT;
pub const UBRK_WORD_NUMBER = UWordBreak.NONE_LIMIT;
pub const UBRK_WORD_NUMBER_LIMIT = UWordBreak.NUMBER_LIMIT;
pub const UBRK_WORD_LETTER = UWordBreak.NUMBER_LIMIT;
pub const UBRK_WORD_LETTER_LIMIT = UWordBreak.LETTER_LIMIT;
pub const UBRK_WORD_KANA = UWordBreak.LETTER_LIMIT;
pub const UBRK_WORD_KANA_LIMIT = UWordBreak.KANA_LIMIT;
pub const UBRK_WORD_IDEO = UWordBreak.KANA_LIMIT;
pub const UBRK_WORD_IDEO_LIMIT = UWordBreak.IDEO_LIMIT;

pub const ULineBreakTag = enum(i32) {
    SOFT = 0,
    SOFT_LIMIT = 100,
    // HARD = 100, this enum value conflicts with SOFT_LIMIT
    HARD_LIMIT = 200,
};
pub const UBRK_LINE_SOFT = ULineBreakTag.SOFT;
pub const UBRK_LINE_SOFT_LIMIT = ULineBreakTag.SOFT_LIMIT;
pub const UBRK_LINE_HARD = ULineBreakTag.SOFT_LIMIT;
pub const UBRK_LINE_HARD_LIMIT = ULineBreakTag.HARD_LIMIT;

pub const USentenceBreakTag = enum(i32) {
    TERM = 0,
    TERM_LIMIT = 100,
    // SEP = 100, this enum value conflicts with TERM_LIMIT
    SEP_LIMIT = 200,
};
pub const UBRK_SENTENCE_TERM = USentenceBreakTag.TERM;
pub const UBRK_SENTENCE_TERM_LIMIT = USentenceBreakTag.TERM_LIMIT;
pub const UBRK_SENTENCE_SEP = USentenceBreakTag.TERM_LIMIT;
pub const UBRK_SENTENCE_SEP_LIMIT = USentenceBreakTag.SEP_LIMIT;

pub const UCalendarType = enum(i32) {
    TRADITIONAL = 0,
    // DEFAULT = 0, this enum value conflicts with TRADITIONAL
    GREGORIAN = 1,
};
pub const UCAL_TRADITIONAL = UCalendarType.TRADITIONAL;
pub const UCAL_DEFAULT = UCalendarType.TRADITIONAL;
pub const UCAL_GREGORIAN = UCalendarType.GREGORIAN;

pub const UCalendarDateFields = enum(i32) {
    ERA = 0,
    YEAR = 1,
    MONTH = 2,
    WEEK_OF_YEAR = 3,
    WEEK_OF_MONTH = 4,
    DATE = 5,
    DAY_OF_YEAR = 6,
    DAY_OF_WEEK = 7,
    DAY_OF_WEEK_IN_MONTH = 8,
    AM_PM = 9,
    HOUR = 10,
    HOUR_OF_DAY = 11,
    MINUTE = 12,
    SECOND = 13,
    MILLISECOND = 14,
    ZONE_OFFSET = 15,
    DST_OFFSET = 16,
    YEAR_WOY = 17,
    DOW_LOCAL = 18,
    EXTENDED_YEAR = 19,
    JULIAN_DAY = 20,
    MILLISECONDS_IN_DAY = 21,
    IS_LEAP_MONTH = 22,
    FIELD_COUNT = 23,
    // DAY_OF_MONTH = 5, this enum value conflicts with DATE
};
pub const UCAL_ERA = UCalendarDateFields.ERA;
pub const UCAL_YEAR = UCalendarDateFields.YEAR;
pub const UCAL_MONTH = UCalendarDateFields.MONTH;
pub const UCAL_WEEK_OF_YEAR = UCalendarDateFields.WEEK_OF_YEAR;
pub const UCAL_WEEK_OF_MONTH = UCalendarDateFields.WEEK_OF_MONTH;
pub const UCAL_DATE = UCalendarDateFields.DATE;
pub const UCAL_DAY_OF_YEAR = UCalendarDateFields.DAY_OF_YEAR;
pub const UCAL_DAY_OF_WEEK = UCalendarDateFields.DAY_OF_WEEK;
pub const UCAL_DAY_OF_WEEK_IN_MONTH = UCalendarDateFields.DAY_OF_WEEK_IN_MONTH;
pub const UCAL_AM_PM = UCalendarDateFields.AM_PM;
pub const UCAL_HOUR = UCalendarDateFields.HOUR;
pub const UCAL_HOUR_OF_DAY = UCalendarDateFields.HOUR_OF_DAY;
pub const UCAL_MINUTE = UCalendarDateFields.MINUTE;
pub const UCAL_SECOND = UCalendarDateFields.SECOND;
pub const UCAL_MILLISECOND = UCalendarDateFields.MILLISECOND;
pub const UCAL_ZONE_OFFSET = UCalendarDateFields.ZONE_OFFSET;
pub const UCAL_DST_OFFSET = UCalendarDateFields.DST_OFFSET;
pub const UCAL_YEAR_WOY = UCalendarDateFields.YEAR_WOY;
pub const UCAL_DOW_LOCAL = UCalendarDateFields.DOW_LOCAL;
pub const UCAL_EXTENDED_YEAR = UCalendarDateFields.EXTENDED_YEAR;
pub const UCAL_JULIAN_DAY = UCalendarDateFields.JULIAN_DAY;
pub const UCAL_MILLISECONDS_IN_DAY = UCalendarDateFields.MILLISECONDS_IN_DAY;
pub const UCAL_IS_LEAP_MONTH = UCalendarDateFields.IS_LEAP_MONTH;
pub const UCAL_FIELD_COUNT = UCalendarDateFields.FIELD_COUNT;
pub const UCAL_DAY_OF_MONTH = UCalendarDateFields.DATE;

pub const UCalendarDaysOfWeek = enum(i32) {
    SUNDAY = 1,
    MONDAY = 2,
    TUESDAY = 3,
    WEDNESDAY = 4,
    THURSDAY = 5,
    FRIDAY = 6,
    SATURDAY = 7,
};
pub const UCAL_SUNDAY = UCalendarDaysOfWeek.SUNDAY;
pub const UCAL_MONDAY = UCalendarDaysOfWeek.MONDAY;
pub const UCAL_TUESDAY = UCalendarDaysOfWeek.TUESDAY;
pub const UCAL_WEDNESDAY = UCalendarDaysOfWeek.WEDNESDAY;
pub const UCAL_THURSDAY = UCalendarDaysOfWeek.THURSDAY;
pub const UCAL_FRIDAY = UCalendarDaysOfWeek.FRIDAY;
pub const UCAL_SATURDAY = UCalendarDaysOfWeek.SATURDAY;

pub const UCalendarMonths = enum(i32) {
    JANUARY = 0,
    FEBRUARY = 1,
    MARCH = 2,
    APRIL = 3,
    MAY = 4,
    JUNE = 5,
    JULY = 6,
    AUGUST = 7,
    SEPTEMBER = 8,
    OCTOBER = 9,
    NOVEMBER = 10,
    DECEMBER = 11,
    UNDECIMBER = 12,
};
pub const UCAL_JANUARY = UCalendarMonths.JANUARY;
pub const UCAL_FEBRUARY = UCalendarMonths.FEBRUARY;
pub const UCAL_MARCH = UCalendarMonths.MARCH;
pub const UCAL_APRIL = UCalendarMonths.APRIL;
pub const UCAL_MAY = UCalendarMonths.MAY;
pub const UCAL_JUNE = UCalendarMonths.JUNE;
pub const UCAL_JULY = UCalendarMonths.JULY;
pub const UCAL_AUGUST = UCalendarMonths.AUGUST;
pub const UCAL_SEPTEMBER = UCalendarMonths.SEPTEMBER;
pub const UCAL_OCTOBER = UCalendarMonths.OCTOBER;
pub const UCAL_NOVEMBER = UCalendarMonths.NOVEMBER;
pub const UCAL_DECEMBER = UCalendarMonths.DECEMBER;
pub const UCAL_UNDECIMBER = UCalendarMonths.UNDECIMBER;

pub const UCalendarAMPMs = enum(i32) {
    AM = 0,
    PM = 1,
};
pub const UCAL_AM = UCalendarAMPMs.AM;
pub const UCAL_PM = UCalendarAMPMs.PM;

pub const USystemTimeZoneType = enum(i32) {
    ANY = 0,
    CANONICAL = 1,
    CANONICAL_LOCATION = 2,
};
pub const UCAL_ZONE_TYPE_ANY = USystemTimeZoneType.ANY;
pub const UCAL_ZONE_TYPE_CANONICAL = USystemTimeZoneType.CANONICAL;
pub const UCAL_ZONE_TYPE_CANONICAL_LOCATION = USystemTimeZoneType.CANONICAL_LOCATION;

pub const UCalendarDisplayNameType = enum(i32) {
    STANDARD = 0,
    SHORT_STANDARD = 1,
    DST = 2,
    SHORT_DST = 3,
};
pub const UCAL_STANDARD = UCalendarDisplayNameType.STANDARD;
pub const UCAL_SHORT_STANDARD = UCalendarDisplayNameType.SHORT_STANDARD;
pub const UCAL_DST = UCalendarDisplayNameType.DST;
pub const UCAL_SHORT_DST = UCalendarDisplayNameType.SHORT_DST;

pub const UCalendarAttribute = enum(i32) {
    LENIENT = 0,
    FIRST_DAY_OF_WEEK = 1,
    MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    REPEATED_WALL_TIME = 3,
    SKIPPED_WALL_TIME = 4,
};
pub const UCAL_LENIENT = UCalendarAttribute.LENIENT;
pub const UCAL_FIRST_DAY_OF_WEEK = UCalendarAttribute.FIRST_DAY_OF_WEEK;
pub const UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = UCalendarAttribute.MINIMAL_DAYS_IN_FIRST_WEEK;
pub const UCAL_REPEATED_WALL_TIME = UCalendarAttribute.REPEATED_WALL_TIME;
pub const UCAL_SKIPPED_WALL_TIME = UCalendarAttribute.SKIPPED_WALL_TIME;

pub const UCalendarWallTimeOption = enum(i32) {
    LAST = 0,
    FIRST = 1,
    NEXT_VALID = 2,
};
pub const UCAL_WALLTIME_LAST = UCalendarWallTimeOption.LAST;
pub const UCAL_WALLTIME_FIRST = UCalendarWallTimeOption.FIRST;
pub const UCAL_WALLTIME_NEXT_VALID = UCalendarWallTimeOption.NEXT_VALID;

pub const UCalendarLimitType = enum(i32) {
    MINIMUM = 0,
    MAXIMUM = 1,
    GREATEST_MINIMUM = 2,
    LEAST_MAXIMUM = 3,
    ACTUAL_MINIMUM = 4,
    ACTUAL_MAXIMUM = 5,
};
pub const UCAL_MINIMUM = UCalendarLimitType.MINIMUM;
pub const UCAL_MAXIMUM = UCalendarLimitType.MAXIMUM;
pub const UCAL_GREATEST_MINIMUM = UCalendarLimitType.GREATEST_MINIMUM;
pub const UCAL_LEAST_MAXIMUM = UCalendarLimitType.LEAST_MAXIMUM;
pub const UCAL_ACTUAL_MINIMUM = UCalendarLimitType.ACTUAL_MINIMUM;
pub const UCAL_ACTUAL_MAXIMUM = UCalendarLimitType.ACTUAL_MAXIMUM;

pub const UCalendarWeekdayType = enum(i32) {
    DAY = 0,
    END = 1,
    END_ONSET = 2,
    END_CEASE = 3,
};
pub const UCAL_WEEKDAY = UCalendarWeekdayType.DAY;
pub const UCAL_WEEKEND = UCalendarWeekdayType.END;
pub const UCAL_WEEKEND_ONSET = UCalendarWeekdayType.END_ONSET;
pub const UCAL_WEEKEND_CEASE = UCalendarWeekdayType.END_CEASE;

pub const UTimeZoneTransitionType = enum(i32) {
    NEXT = 0,
    NEXT_INCLUSIVE = 1,
    PREVIOUS = 2,
    PREVIOUS_INCLUSIVE = 3,
};
pub const UCAL_TZ_TRANSITION_NEXT = UTimeZoneTransitionType.NEXT;
pub const UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = UTimeZoneTransitionType.NEXT_INCLUSIVE;
pub const UCAL_TZ_TRANSITION_PREVIOUS = UTimeZoneTransitionType.PREVIOUS;
pub const UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = UTimeZoneTransitionType.PREVIOUS_INCLUSIVE;

pub const UCollator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCollationResult = enum(i32) {
    EQUAL = 0,
    GREATER = 1,
    LESS = -1,
};
pub const UCOL_EQUAL = UCollationResult.EQUAL;
pub const UCOL_GREATER = UCollationResult.GREATER;
pub const UCOL_LESS = UCollationResult.LESS;

pub const UColAttributeValue = enum(i32) {
    DEFAULT = -1,
    PRIMARY = 0,
    SECONDARY = 1,
    TERTIARY = 2,
    // DEFAULT_STRENGTH = 2, this enum value conflicts with TERTIARY
    CE_STRENGTH_LIMIT = 3,
    // QUATERNARY = 3, this enum value conflicts with CE_STRENGTH_LIMIT
    IDENTICAL = 15,
    STRENGTH_LIMIT = 16,
    // OFF = 16, this enum value conflicts with STRENGTH_LIMIT
    ON = 17,
    SHIFTED = 20,
    NON_IGNORABLE = 21,
    LOWER_FIRST = 24,
    UPPER_FIRST = 25,
};
pub const UCOL_DEFAULT = UColAttributeValue.DEFAULT;
pub const UCOL_PRIMARY = UColAttributeValue.PRIMARY;
pub const UCOL_SECONDARY = UColAttributeValue.SECONDARY;
pub const UCOL_TERTIARY = UColAttributeValue.TERTIARY;
pub const UCOL_DEFAULT_STRENGTH = UColAttributeValue.TERTIARY;
pub const UCOL_CE_STRENGTH_LIMIT = UColAttributeValue.CE_STRENGTH_LIMIT;
pub const UCOL_QUATERNARY = UColAttributeValue.CE_STRENGTH_LIMIT;
pub const UCOL_IDENTICAL = UColAttributeValue.IDENTICAL;
pub const UCOL_STRENGTH_LIMIT = UColAttributeValue.STRENGTH_LIMIT;
pub const UCOL_OFF = UColAttributeValue.STRENGTH_LIMIT;
pub const UCOL_ON = UColAttributeValue.ON;
pub const UCOL_SHIFTED = UColAttributeValue.SHIFTED;
pub const UCOL_NON_IGNORABLE = UColAttributeValue.NON_IGNORABLE;
pub const UCOL_LOWER_FIRST = UColAttributeValue.LOWER_FIRST;
pub const UCOL_UPPER_FIRST = UColAttributeValue.UPPER_FIRST;

pub const UColReorderCode = enum(i32) {
    DEFAULT = -1,
    NONE = 103,
    // OTHERS = 103, this enum value conflicts with NONE
    SPACE = 4096,
    // FIRST = 4096, this enum value conflicts with SPACE
    PUNCTUATION = 4097,
    SYMBOL = 4098,
    CURRENCY = 4099,
    DIGIT = 4100,
};
pub const UCOL_REORDER_CODE_DEFAULT = UColReorderCode.DEFAULT;
pub const UCOL_REORDER_CODE_NONE = UColReorderCode.NONE;
pub const UCOL_REORDER_CODE_OTHERS = UColReorderCode.NONE;
pub const UCOL_REORDER_CODE_SPACE = UColReorderCode.SPACE;
pub const UCOL_REORDER_CODE_FIRST = UColReorderCode.SPACE;
pub const UCOL_REORDER_CODE_PUNCTUATION = UColReorderCode.PUNCTUATION;
pub const UCOL_REORDER_CODE_SYMBOL = UColReorderCode.SYMBOL;
pub const UCOL_REORDER_CODE_CURRENCY = UColReorderCode.CURRENCY;
pub const UCOL_REORDER_CODE_DIGIT = UColReorderCode.DIGIT;

pub const UColAttribute = enum(i32) {
    FRENCH_COLLATION = 0,
    ALTERNATE_HANDLING = 1,
    CASE_FIRST = 2,
    CASE_LEVEL = 3,
    NORMALIZATION_MODE = 4,
    // DECOMPOSITION_MODE = 4, this enum value conflicts with NORMALIZATION_MODE
    STRENGTH = 5,
    NUMERIC_COLLATION = 7,
    ATTRIBUTE_COUNT = 8,
};
pub const UCOL_FRENCH_COLLATION = UColAttribute.FRENCH_COLLATION;
pub const UCOL_ALTERNATE_HANDLING = UColAttribute.ALTERNATE_HANDLING;
pub const UCOL_CASE_FIRST = UColAttribute.CASE_FIRST;
pub const UCOL_CASE_LEVEL = UColAttribute.CASE_LEVEL;
pub const UCOL_NORMALIZATION_MODE = UColAttribute.NORMALIZATION_MODE;
pub const UCOL_DECOMPOSITION_MODE = UColAttribute.NORMALIZATION_MODE;
pub const UCOL_STRENGTH = UColAttribute.STRENGTH;
pub const UCOL_NUMERIC_COLLATION = UColAttribute.NUMERIC_COLLATION;
pub const UCOL_ATTRIBUTE_COUNT = UColAttribute.ATTRIBUTE_COUNT;

pub const UColRuleOption = enum(i32) {
    TAILORING_ONLY = 0,
    FULL_RULES = 1,
};
pub const UCOL_TAILORING_ONLY = UColRuleOption.TAILORING_ONLY;
pub const UCOL_FULL_RULES = UColRuleOption.FULL_RULES;

pub const UColBoundMode = enum(i32) {
    LOWER = 0,
    UPPER = 1,
    UPPER_LONG = 2,
};
pub const UCOL_BOUND_LOWER = UColBoundMode.LOWER;
pub const UCOL_BOUND_UPPER = UColBoundMode.UPPER;
pub const UCOL_BOUND_UPPER_LONG = UColBoundMode.UPPER_LONG;

pub const UCollationElements = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCharsetDetector = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UCharsetMatch = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFieldPositionIterator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattableType = enum(i32) {
    DATE = 0,
    DOUBLE = 1,
    LONG = 2,
    STRING = 3,
    ARRAY = 4,
    INT64 = 5,
    OBJECT = 6,
};
pub const UFMT_DATE = UFormattableType.DATE;
pub const UFMT_DOUBLE = UFormattableType.DOUBLE;
pub const UFMT_LONG = UFormattableType.LONG;
pub const UFMT_STRING = UFormattableType.STRING;
pub const UFMT_ARRAY = UFormattableType.ARRAY;
pub const UFMT_INT64 = UFormattableType.INT64;
pub const UFMT_OBJECT = UFormattableType.OBJECT;

pub const UFieldCategory = enum(i32) {
    UNDEFINED = 0,
    DATE = 1,
    NUMBER = 2,
    LIST = 3,
    RELATIVE_DATETIME = 4,
    DATE_INTERVAL = 5,
    LIST_SPAN = 4099,
    DATE_INTERVAL_SPAN = 4101,
};
pub const UFIELD_CATEGORY_UNDEFINED = UFieldCategory.UNDEFINED;
pub const UFIELD_CATEGORY_DATE = UFieldCategory.DATE;
pub const UFIELD_CATEGORY_NUMBER = UFieldCategory.NUMBER;
pub const UFIELD_CATEGORY_LIST = UFieldCategory.LIST;
pub const UFIELD_CATEGORY_RELATIVE_DATETIME = UFieldCategory.RELATIVE_DATETIME;
pub const UFIELD_CATEGORY_DATE_INTERVAL = UFieldCategory.DATE_INTERVAL;
pub const UFIELD_CATEGORY_LIST_SPAN = UFieldCategory.LIST_SPAN;
pub const UFIELD_CATEGORY_DATE_INTERVAL_SPAN = UFieldCategory.DATE_INTERVAL_SPAN;

pub const UConstrainedFieldPosition = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedValue = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UDateIntervalFormat = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedDateInterval = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UGender = enum(i32) {
    MALE = 0,
    FEMALE = 1,
    OTHER = 2,
};
pub const UGENDER_MALE = UGender.MALE;
pub const UGENDER_FEMALE = UGender.FEMALE;
pub const UGENDER_OTHER = UGender.OTHER;

pub const UGenderInfo = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UListFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedList = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UListFormatterField = enum(i32) {
    LITERAL_FIELD = 0,
    ELEMENT_FIELD = 1,
};
pub const ULISTFMT_LITERAL_FIELD = UListFormatterField.LITERAL_FIELD;
pub const ULISTFMT_ELEMENT_FIELD = UListFormatterField.ELEMENT_FIELD;

pub const UListFormatterType = enum(i32) {
    AND = 0,
    OR = 1,
    UNITS = 2,
};
pub const ULISTFMT_TYPE_AND = UListFormatterType.AND;
pub const ULISTFMT_TYPE_OR = UListFormatterType.OR;
pub const ULISTFMT_TYPE_UNITS = UListFormatterType.UNITS;

pub const UListFormatterWidth = enum(i32) {
    WIDE = 0,
    SHORT = 1,
    NARROW = 2,
};
pub const ULISTFMT_WIDTH_WIDE = UListFormatterWidth.WIDE;
pub const ULISTFMT_WIDTH_SHORT = UListFormatterWidth.SHORT;
pub const ULISTFMT_WIDTH_NARROW = UListFormatterWidth.NARROW;

pub const ULocaleData = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const ULocaleDataExemplarSetType = enum(i32) {
    STANDARD = 0,
    AUXILIARY = 1,
    INDEX = 2,
    PUNCTUATION = 3,
};
pub const ULOCDATA_ES_STANDARD = ULocaleDataExemplarSetType.STANDARD;
pub const ULOCDATA_ES_AUXILIARY = ULocaleDataExemplarSetType.AUXILIARY;
pub const ULOCDATA_ES_INDEX = ULocaleDataExemplarSetType.INDEX;
pub const ULOCDATA_ES_PUNCTUATION = ULocaleDataExemplarSetType.PUNCTUATION;

pub const ULocaleDataDelimiterType = enum(i32) {
    QUOTATION_START = 0,
    QUOTATION_END = 1,
    ALT_QUOTATION_START = 2,
    ALT_QUOTATION_END = 3,
};
pub const ULOCDATA_QUOTATION_START = ULocaleDataDelimiterType.QUOTATION_START;
pub const ULOCDATA_QUOTATION_END = ULocaleDataDelimiterType.QUOTATION_END;
pub const ULOCDATA_ALT_QUOTATION_START = ULocaleDataDelimiterType.ALT_QUOTATION_START;
pub const ULOCDATA_ALT_QUOTATION_END = ULocaleDataDelimiterType.ALT_QUOTATION_END;

pub const UMeasurementSystem = enum(i32) {
    SI = 0,
    US = 1,
    UK = 2,
};
pub const UMS_SI = UMeasurementSystem.SI;
pub const UMS_US = UMeasurementSystem.US;
pub const UMS_UK = UMeasurementSystem.UK;

pub const UNumberFormatStyle = enum(i32) {
    PATTERN_DECIMAL = 0,
    DECIMAL = 1,
    CURRENCY = 2,
    PERCENT = 3,
    SCIENTIFIC = 4,
    SPELLOUT = 5,
    ORDINAL = 6,
    DURATION = 7,
    NUMBERING_SYSTEM = 8,
    PATTERN_RULEBASED = 9,
    CURRENCY_ISO = 10,
    CURRENCY_PLURAL = 11,
    CURRENCY_ACCOUNTING = 12,
    CASH_CURRENCY = 13,
    DECIMAL_COMPACT_SHORT = 14,
    DECIMAL_COMPACT_LONG = 15,
    CURRENCY_STANDARD = 16,
    // DEFAULT = 1, this enum value conflicts with DECIMAL
    // IGNORE = 0, this enum value conflicts with PATTERN_DECIMAL
};
pub const UNUM_PATTERN_DECIMAL = UNumberFormatStyle.PATTERN_DECIMAL;
pub const UNUM_DECIMAL = UNumberFormatStyle.DECIMAL;
pub const UNUM_CURRENCY = UNumberFormatStyle.CURRENCY;
pub const UNUM_PERCENT = UNumberFormatStyle.PERCENT;
pub const UNUM_SCIENTIFIC = UNumberFormatStyle.SCIENTIFIC;
pub const UNUM_SPELLOUT = UNumberFormatStyle.SPELLOUT;
pub const UNUM_ORDINAL = UNumberFormatStyle.ORDINAL;
pub const UNUM_DURATION = UNumberFormatStyle.DURATION;
pub const UNUM_NUMBERING_SYSTEM = UNumberFormatStyle.NUMBERING_SYSTEM;
pub const UNUM_PATTERN_RULEBASED = UNumberFormatStyle.PATTERN_RULEBASED;
pub const UNUM_CURRENCY_ISO = UNumberFormatStyle.CURRENCY_ISO;
pub const UNUM_CURRENCY_PLURAL = UNumberFormatStyle.CURRENCY_PLURAL;
pub const UNUM_CURRENCY_ACCOUNTING = UNumberFormatStyle.CURRENCY_ACCOUNTING;
pub const UNUM_CASH_CURRENCY = UNumberFormatStyle.CASH_CURRENCY;
pub const UNUM_DECIMAL_COMPACT_SHORT = UNumberFormatStyle.DECIMAL_COMPACT_SHORT;
pub const UNUM_DECIMAL_COMPACT_LONG = UNumberFormatStyle.DECIMAL_COMPACT_LONG;
pub const UNUM_CURRENCY_STANDARD = UNumberFormatStyle.CURRENCY_STANDARD;
pub const UNUM_DEFAULT = UNumberFormatStyle.DECIMAL;
pub const UNUM_IGNORE = UNumberFormatStyle.PATTERN_DECIMAL;

pub const UNumberFormatRoundingMode = enum(i32) {
    CEILING = 0,
    FLOOR = 1,
    DOWN = 2,
    UP = 3,
    HALFEVEN = 4,
    HALFDOWN = 5,
    HALFUP = 6,
    UNNECESSARY = 7,
};
pub const UNUM_ROUND_CEILING = UNumberFormatRoundingMode.CEILING;
pub const UNUM_ROUND_FLOOR = UNumberFormatRoundingMode.FLOOR;
pub const UNUM_ROUND_DOWN = UNumberFormatRoundingMode.DOWN;
pub const UNUM_ROUND_UP = UNumberFormatRoundingMode.UP;
pub const UNUM_ROUND_HALFEVEN = UNumberFormatRoundingMode.HALFEVEN;
pub const UNUM_ROUND_HALFDOWN = UNumberFormatRoundingMode.HALFDOWN;
pub const UNUM_ROUND_HALFUP = UNumberFormatRoundingMode.HALFUP;
pub const UNUM_ROUND_UNNECESSARY = UNumberFormatRoundingMode.UNNECESSARY;

pub const UNumberFormatPadPosition = enum(i32) {
    BEFORE_PREFIX = 0,
    AFTER_PREFIX = 1,
    BEFORE_SUFFIX = 2,
    AFTER_SUFFIX = 3,
};
pub const UNUM_PAD_BEFORE_PREFIX = UNumberFormatPadPosition.BEFORE_PREFIX;
pub const UNUM_PAD_AFTER_PREFIX = UNumberFormatPadPosition.AFTER_PREFIX;
pub const UNUM_PAD_BEFORE_SUFFIX = UNumberFormatPadPosition.BEFORE_SUFFIX;
pub const UNUM_PAD_AFTER_SUFFIX = UNumberFormatPadPosition.AFTER_SUFFIX;

pub const UNumberCompactStyle = enum(i32) {
    SHORT = 0,
    LONG = 1,
};
pub const UNUM_SHORT = UNumberCompactStyle.SHORT;
pub const UNUM_LONG = UNumberCompactStyle.LONG;

pub const UCurrencySpacing = enum(i32) {
    MATCH = 0,
    SURROUNDING_MATCH = 1,
    INSERT = 2,
    SPACING_COUNT = 3,
};
pub const UNUM_CURRENCY_MATCH = UCurrencySpacing.MATCH;
pub const UNUM_CURRENCY_SURROUNDING_MATCH = UCurrencySpacing.SURROUNDING_MATCH;
pub const UNUM_CURRENCY_INSERT = UCurrencySpacing.INSERT;
pub const UNUM_CURRENCY_SPACING_COUNT = UCurrencySpacing.SPACING_COUNT;

pub const UNumberFormatFields = enum(i32) {
    INTEGER_FIELD = 0,
    FRACTION_FIELD = 1,
    DECIMAL_SEPARATOR_FIELD = 2,
    EXPONENT_SYMBOL_FIELD = 3,
    EXPONENT_SIGN_FIELD = 4,
    EXPONENT_FIELD = 5,
    GROUPING_SEPARATOR_FIELD = 6,
    CURRENCY_FIELD = 7,
    PERCENT_FIELD = 8,
    PERMILL_FIELD = 9,
    SIGN_FIELD = 10,
    MEASURE_UNIT_FIELD = 11,
    COMPACT_FIELD = 12,
};
pub const UNUM_INTEGER_FIELD = UNumberFormatFields.INTEGER_FIELD;
pub const UNUM_FRACTION_FIELD = UNumberFormatFields.FRACTION_FIELD;
pub const UNUM_DECIMAL_SEPARATOR_FIELD = UNumberFormatFields.DECIMAL_SEPARATOR_FIELD;
pub const UNUM_EXPONENT_SYMBOL_FIELD = UNumberFormatFields.EXPONENT_SYMBOL_FIELD;
pub const UNUM_EXPONENT_SIGN_FIELD = UNumberFormatFields.EXPONENT_SIGN_FIELD;
pub const UNUM_EXPONENT_FIELD = UNumberFormatFields.EXPONENT_FIELD;
pub const UNUM_GROUPING_SEPARATOR_FIELD = UNumberFormatFields.GROUPING_SEPARATOR_FIELD;
pub const UNUM_CURRENCY_FIELD = UNumberFormatFields.CURRENCY_FIELD;
pub const UNUM_PERCENT_FIELD = UNumberFormatFields.PERCENT_FIELD;
pub const UNUM_PERMILL_FIELD = UNumberFormatFields.PERMILL_FIELD;
pub const UNUM_SIGN_FIELD = UNumberFormatFields.SIGN_FIELD;
pub const UNUM_MEASURE_UNIT_FIELD = UNumberFormatFields.MEASURE_UNIT_FIELD;
pub const UNUM_COMPACT_FIELD = UNumberFormatFields.COMPACT_FIELD;

pub const UNumberFormatAttributeValue = enum(i32) {
    N = 0,
};
pub const UNUM_FORMAT_ATTRIBUTE_VALUE_HIDDEN = UNumberFormatAttributeValue.N;

pub const UNumberFormatAttribute = enum(i32) {
    PARSE_INT_ONLY = 0,
    GROUPING_USED = 1,
    DECIMAL_ALWAYS_SHOWN = 2,
    MAX_INTEGER_DIGITS = 3,
    MIN_INTEGER_DIGITS = 4,
    INTEGER_DIGITS = 5,
    MAX_FRACTION_DIGITS = 6,
    MIN_FRACTION_DIGITS = 7,
    FRACTION_DIGITS = 8,
    MULTIPLIER = 9,
    GROUPING_SIZE = 10,
    ROUNDING_MODE = 11,
    ROUNDING_INCREMENT = 12,
    FORMAT_WIDTH = 13,
    PADDING_POSITION = 14,
    SECONDARY_GROUPING_SIZE = 15,
    SIGNIFICANT_DIGITS_USED = 16,
    MIN_SIGNIFICANT_DIGITS = 17,
    MAX_SIGNIFICANT_DIGITS = 18,
    LENIENT_PARSE = 19,
    PARSE_ALL_INPUT = 20,
    SCALE = 21,
    MINIMUM_GROUPING_DIGITS = 22,
    CURRENCY_USAGE = 23,
    FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = 4096,
    PARSE_NO_EXPONENT = 4097,
    PARSE_DECIMAL_MARK_REQUIRED = 4098,
    PARSE_CASE_SENSITIVE = 4099,
    SIGN_ALWAYS_SHOWN = 4100,
};
pub const UNUM_PARSE_INT_ONLY = UNumberFormatAttribute.PARSE_INT_ONLY;
pub const UNUM_GROUPING_USED = UNumberFormatAttribute.GROUPING_USED;
pub const UNUM_DECIMAL_ALWAYS_SHOWN = UNumberFormatAttribute.DECIMAL_ALWAYS_SHOWN;
pub const UNUM_MAX_INTEGER_DIGITS = UNumberFormatAttribute.MAX_INTEGER_DIGITS;
pub const UNUM_MIN_INTEGER_DIGITS = UNumberFormatAttribute.MIN_INTEGER_DIGITS;
pub const UNUM_INTEGER_DIGITS = UNumberFormatAttribute.INTEGER_DIGITS;
pub const UNUM_MAX_FRACTION_DIGITS = UNumberFormatAttribute.MAX_FRACTION_DIGITS;
pub const UNUM_MIN_FRACTION_DIGITS = UNumberFormatAttribute.MIN_FRACTION_DIGITS;
pub const UNUM_FRACTION_DIGITS = UNumberFormatAttribute.FRACTION_DIGITS;
pub const UNUM_MULTIPLIER = UNumberFormatAttribute.MULTIPLIER;
pub const UNUM_GROUPING_SIZE = UNumberFormatAttribute.GROUPING_SIZE;
pub const UNUM_ROUNDING_MODE = UNumberFormatAttribute.ROUNDING_MODE;
pub const UNUM_ROUNDING_INCREMENT = UNumberFormatAttribute.ROUNDING_INCREMENT;
pub const UNUM_FORMAT_WIDTH = UNumberFormatAttribute.FORMAT_WIDTH;
pub const UNUM_PADDING_POSITION = UNumberFormatAttribute.PADDING_POSITION;
pub const UNUM_SECONDARY_GROUPING_SIZE = UNumberFormatAttribute.SECONDARY_GROUPING_SIZE;
pub const UNUM_SIGNIFICANT_DIGITS_USED = UNumberFormatAttribute.SIGNIFICANT_DIGITS_USED;
pub const UNUM_MIN_SIGNIFICANT_DIGITS = UNumberFormatAttribute.MIN_SIGNIFICANT_DIGITS;
pub const UNUM_MAX_SIGNIFICANT_DIGITS = UNumberFormatAttribute.MAX_SIGNIFICANT_DIGITS;
pub const UNUM_LENIENT_PARSE = UNumberFormatAttribute.LENIENT_PARSE;
pub const UNUM_PARSE_ALL_INPUT = UNumberFormatAttribute.PARSE_ALL_INPUT;
pub const UNUM_SCALE = UNumberFormatAttribute.SCALE;
pub const UNUM_MINIMUM_GROUPING_DIGITS = UNumberFormatAttribute.MINIMUM_GROUPING_DIGITS;
pub const UNUM_CURRENCY_USAGE = UNumberFormatAttribute.CURRENCY_USAGE;
pub const UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = UNumberFormatAttribute.FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS;
pub const UNUM_PARSE_NO_EXPONENT = UNumberFormatAttribute.PARSE_NO_EXPONENT;
pub const UNUM_PARSE_DECIMAL_MARK_REQUIRED = UNumberFormatAttribute.PARSE_DECIMAL_MARK_REQUIRED;
pub const UNUM_PARSE_CASE_SENSITIVE = UNumberFormatAttribute.PARSE_CASE_SENSITIVE;
pub const UNUM_SIGN_ALWAYS_SHOWN = UNumberFormatAttribute.SIGN_ALWAYS_SHOWN;

pub const UNumberFormatTextAttribute = enum(i32) {
    POSITIVE_PREFIX = 0,
    POSITIVE_SUFFIX = 1,
    NEGATIVE_PREFIX = 2,
    NEGATIVE_SUFFIX = 3,
    PADDING_CHARACTER = 4,
    CURRENCY_CODE = 5,
    DEFAULT_RULESET = 6,
    PUBLIC_RULESETS = 7,
};
pub const UNUM_POSITIVE_PREFIX = UNumberFormatTextAttribute.POSITIVE_PREFIX;
pub const UNUM_POSITIVE_SUFFIX = UNumberFormatTextAttribute.POSITIVE_SUFFIX;
pub const UNUM_NEGATIVE_PREFIX = UNumberFormatTextAttribute.NEGATIVE_PREFIX;
pub const UNUM_NEGATIVE_SUFFIX = UNumberFormatTextAttribute.NEGATIVE_SUFFIX;
pub const UNUM_PADDING_CHARACTER = UNumberFormatTextAttribute.PADDING_CHARACTER;
pub const UNUM_CURRENCY_CODE = UNumberFormatTextAttribute.CURRENCY_CODE;
pub const UNUM_DEFAULT_RULESET = UNumberFormatTextAttribute.DEFAULT_RULESET;
pub const UNUM_PUBLIC_RULESETS = UNumberFormatTextAttribute.PUBLIC_RULESETS;

pub const UNumberFormatSymbol = enum(i32) {
    DECIMAL_SEPARATOR_SYMBOL = 0,
    GROUPING_SEPARATOR_SYMBOL = 1,
    PATTERN_SEPARATOR_SYMBOL = 2,
    PERCENT_SYMBOL = 3,
    ZERO_DIGIT_SYMBOL = 4,
    DIGIT_SYMBOL = 5,
    MINUS_SIGN_SYMBOL = 6,
    PLUS_SIGN_SYMBOL = 7,
    CURRENCY_SYMBOL = 8,
    INTL_CURRENCY_SYMBOL = 9,
    MONETARY_SEPARATOR_SYMBOL = 10,
    EXPONENTIAL_SYMBOL = 11,
    PERMILL_SYMBOL = 12,
    PAD_ESCAPE_SYMBOL = 13,
    INFINITY_SYMBOL = 14,
    NAN_SYMBOL = 15,
    SIGNIFICANT_DIGIT_SYMBOL = 16,
    MONETARY_GROUPING_SEPARATOR_SYMBOL = 17,
    ONE_DIGIT_SYMBOL = 18,
    TWO_DIGIT_SYMBOL = 19,
    THREE_DIGIT_SYMBOL = 20,
    FOUR_DIGIT_SYMBOL = 21,
    FIVE_DIGIT_SYMBOL = 22,
    SIX_DIGIT_SYMBOL = 23,
    SEVEN_DIGIT_SYMBOL = 24,
    EIGHT_DIGIT_SYMBOL = 25,
    NINE_DIGIT_SYMBOL = 26,
    EXPONENT_MULTIPLICATION_SYMBOL = 27,
};
pub const UNUM_DECIMAL_SEPARATOR_SYMBOL = UNumberFormatSymbol.DECIMAL_SEPARATOR_SYMBOL;
pub const UNUM_GROUPING_SEPARATOR_SYMBOL = UNumberFormatSymbol.GROUPING_SEPARATOR_SYMBOL;
pub const UNUM_PATTERN_SEPARATOR_SYMBOL = UNumberFormatSymbol.PATTERN_SEPARATOR_SYMBOL;
pub const UNUM_PERCENT_SYMBOL = UNumberFormatSymbol.PERCENT_SYMBOL;
pub const UNUM_ZERO_DIGIT_SYMBOL = UNumberFormatSymbol.ZERO_DIGIT_SYMBOL;
pub const UNUM_DIGIT_SYMBOL = UNumberFormatSymbol.DIGIT_SYMBOL;
pub const UNUM_MINUS_SIGN_SYMBOL = UNumberFormatSymbol.MINUS_SIGN_SYMBOL;
pub const UNUM_PLUS_SIGN_SYMBOL = UNumberFormatSymbol.PLUS_SIGN_SYMBOL;
pub const UNUM_CURRENCY_SYMBOL = UNumberFormatSymbol.CURRENCY_SYMBOL;
pub const UNUM_INTL_CURRENCY_SYMBOL = UNumberFormatSymbol.INTL_CURRENCY_SYMBOL;
pub const UNUM_MONETARY_SEPARATOR_SYMBOL = UNumberFormatSymbol.MONETARY_SEPARATOR_SYMBOL;
pub const UNUM_EXPONENTIAL_SYMBOL = UNumberFormatSymbol.EXPONENTIAL_SYMBOL;
pub const UNUM_PERMILL_SYMBOL = UNumberFormatSymbol.PERMILL_SYMBOL;
pub const UNUM_PAD_ESCAPE_SYMBOL = UNumberFormatSymbol.PAD_ESCAPE_SYMBOL;
pub const UNUM_INFINITY_SYMBOL = UNumberFormatSymbol.INFINITY_SYMBOL;
pub const UNUM_NAN_SYMBOL = UNumberFormatSymbol.NAN_SYMBOL;
pub const UNUM_SIGNIFICANT_DIGIT_SYMBOL = UNumberFormatSymbol.SIGNIFICANT_DIGIT_SYMBOL;
pub const UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL = UNumberFormatSymbol.MONETARY_GROUPING_SEPARATOR_SYMBOL;
pub const UNUM_ONE_DIGIT_SYMBOL = UNumberFormatSymbol.ONE_DIGIT_SYMBOL;
pub const UNUM_TWO_DIGIT_SYMBOL = UNumberFormatSymbol.TWO_DIGIT_SYMBOL;
pub const UNUM_THREE_DIGIT_SYMBOL = UNumberFormatSymbol.THREE_DIGIT_SYMBOL;
pub const UNUM_FOUR_DIGIT_SYMBOL = UNumberFormatSymbol.FOUR_DIGIT_SYMBOL;
pub const UNUM_FIVE_DIGIT_SYMBOL = UNumberFormatSymbol.FIVE_DIGIT_SYMBOL;
pub const UNUM_SIX_DIGIT_SYMBOL = UNumberFormatSymbol.SIX_DIGIT_SYMBOL;
pub const UNUM_SEVEN_DIGIT_SYMBOL = UNumberFormatSymbol.SEVEN_DIGIT_SYMBOL;
pub const UNUM_EIGHT_DIGIT_SYMBOL = UNumberFormatSymbol.EIGHT_DIGIT_SYMBOL;
pub const UNUM_NINE_DIGIT_SYMBOL = UNumberFormatSymbol.NINE_DIGIT_SYMBOL;
pub const UNUM_EXPONENT_MULTIPLICATION_SYMBOL = UNumberFormatSymbol.EXPONENT_MULTIPLICATION_SYMBOL;

pub const UDateFormatStyle = enum(i32) {
    FULL = 0,
    LONG = 1,
    MEDIUM = 2,
    SHORT = 3,
    // DEFAULT = 2, this enum value conflicts with MEDIUM
    RELATIVE = 128,
    // FULL_RELATIVE = 128, this enum value conflicts with RELATIVE
    LONG_RELATIVE = 129,
    MEDIUM_RELATIVE = 130,
    SHORT_RELATIVE = 131,
    NONE = -1,
    PATTERN = -2,
};
pub const UDAT_FULL = UDateFormatStyle.FULL;
pub const UDAT_LONG = UDateFormatStyle.LONG;
pub const UDAT_MEDIUM = UDateFormatStyle.MEDIUM;
pub const UDAT_SHORT = UDateFormatStyle.SHORT;
pub const UDAT_DEFAULT = UDateFormatStyle.MEDIUM;
pub const UDAT_RELATIVE = UDateFormatStyle.RELATIVE;
pub const UDAT_FULL_RELATIVE = UDateFormatStyle.RELATIVE;
pub const UDAT_LONG_RELATIVE = UDateFormatStyle.LONG_RELATIVE;
pub const UDAT_MEDIUM_RELATIVE = UDateFormatStyle.MEDIUM_RELATIVE;
pub const UDAT_SHORT_RELATIVE = UDateFormatStyle.SHORT_RELATIVE;
pub const UDAT_NONE = UDateFormatStyle.NONE;
pub const UDAT_PATTERN = UDateFormatStyle.PATTERN;

pub const UDateFormatField = enum(i32) {
    ERA_FIELD = 0,
    YEAR_FIELD = 1,
    MONTH_FIELD = 2,
    DATE_FIELD = 3,
    HOUR_OF_DAY1_FIELD = 4,
    HOUR_OF_DAY0_FIELD = 5,
    MINUTE_FIELD = 6,
    SECOND_FIELD = 7,
    FRACTIONAL_SECOND_FIELD = 8,
    DAY_OF_WEEK_FIELD = 9,
    DAY_OF_YEAR_FIELD = 10,
    DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    WEEK_OF_YEAR_FIELD = 12,
    WEEK_OF_MONTH_FIELD = 13,
    AM_PM_FIELD = 14,
    HOUR1_FIELD = 15,
    HOUR0_FIELD = 16,
    TIMEZONE_FIELD = 17,
    YEAR_WOY_FIELD = 18,
    DOW_LOCAL_FIELD = 19,
    EXTENDED_YEAR_FIELD = 20,
    JULIAN_DAY_FIELD = 21,
    MILLISECONDS_IN_DAY_FIELD = 22,
    TIMEZONE_RFC_FIELD = 23,
    TIMEZONE_GENERIC_FIELD = 24,
    STANDALONE_DAY_FIELD = 25,
    STANDALONE_MONTH_FIELD = 26,
    QUARTER_FIELD = 27,
    STANDALONE_QUARTER_FIELD = 28,
    TIMEZONE_SPECIAL_FIELD = 29,
    YEAR_NAME_FIELD = 30,
    TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    TIMEZONE_ISO_FIELD = 32,
    TIMEZONE_ISO_LOCAL_FIELD = 33,
    AM_PM_MIDNIGHT_NOON_FIELD = 35,
    FLEXIBLE_DAY_PERIOD_FIELD = 36,
};
pub const UDAT_ERA_FIELD = UDateFormatField.ERA_FIELD;
pub const UDAT_YEAR_FIELD = UDateFormatField.YEAR_FIELD;
pub const UDAT_MONTH_FIELD = UDateFormatField.MONTH_FIELD;
pub const UDAT_DATE_FIELD = UDateFormatField.DATE_FIELD;
pub const UDAT_HOUR_OF_DAY1_FIELD = UDateFormatField.HOUR_OF_DAY1_FIELD;
pub const UDAT_HOUR_OF_DAY0_FIELD = UDateFormatField.HOUR_OF_DAY0_FIELD;
pub const UDAT_MINUTE_FIELD = UDateFormatField.MINUTE_FIELD;
pub const UDAT_SECOND_FIELD = UDateFormatField.SECOND_FIELD;
pub const UDAT_FRACTIONAL_SECOND_FIELD = UDateFormatField.FRACTIONAL_SECOND_FIELD;
pub const UDAT_DAY_OF_WEEK_FIELD = UDateFormatField.DAY_OF_WEEK_FIELD;
pub const UDAT_DAY_OF_YEAR_FIELD = UDateFormatField.DAY_OF_YEAR_FIELD;
pub const UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = UDateFormatField.DAY_OF_WEEK_IN_MONTH_FIELD;
pub const UDAT_WEEK_OF_YEAR_FIELD = UDateFormatField.WEEK_OF_YEAR_FIELD;
pub const UDAT_WEEK_OF_MONTH_FIELD = UDateFormatField.WEEK_OF_MONTH_FIELD;
pub const UDAT_AM_PM_FIELD = UDateFormatField.AM_PM_FIELD;
pub const UDAT_HOUR1_FIELD = UDateFormatField.HOUR1_FIELD;
pub const UDAT_HOUR0_FIELD = UDateFormatField.HOUR0_FIELD;
pub const UDAT_TIMEZONE_FIELD = UDateFormatField.TIMEZONE_FIELD;
pub const UDAT_YEAR_WOY_FIELD = UDateFormatField.YEAR_WOY_FIELD;
pub const UDAT_DOW_LOCAL_FIELD = UDateFormatField.DOW_LOCAL_FIELD;
pub const UDAT_EXTENDED_YEAR_FIELD = UDateFormatField.EXTENDED_YEAR_FIELD;
pub const UDAT_JULIAN_DAY_FIELD = UDateFormatField.JULIAN_DAY_FIELD;
pub const UDAT_MILLISECONDS_IN_DAY_FIELD = UDateFormatField.MILLISECONDS_IN_DAY_FIELD;
pub const UDAT_TIMEZONE_RFC_FIELD = UDateFormatField.TIMEZONE_RFC_FIELD;
pub const UDAT_TIMEZONE_GENERIC_FIELD = UDateFormatField.TIMEZONE_GENERIC_FIELD;
pub const UDAT_STANDALONE_DAY_FIELD = UDateFormatField.STANDALONE_DAY_FIELD;
pub const UDAT_STANDALONE_MONTH_FIELD = UDateFormatField.STANDALONE_MONTH_FIELD;
pub const UDAT_QUARTER_FIELD = UDateFormatField.QUARTER_FIELD;
pub const UDAT_STANDALONE_QUARTER_FIELD = UDateFormatField.STANDALONE_QUARTER_FIELD;
pub const UDAT_TIMEZONE_SPECIAL_FIELD = UDateFormatField.TIMEZONE_SPECIAL_FIELD;
pub const UDAT_YEAR_NAME_FIELD = UDateFormatField.YEAR_NAME_FIELD;
pub const UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = UDateFormatField.TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD;
pub const UDAT_TIMEZONE_ISO_FIELD = UDateFormatField.TIMEZONE_ISO_FIELD;
pub const UDAT_TIMEZONE_ISO_LOCAL_FIELD = UDateFormatField.TIMEZONE_ISO_LOCAL_FIELD;
pub const UDAT_AM_PM_MIDNIGHT_NOON_FIELD = UDateFormatField.AM_PM_MIDNIGHT_NOON_FIELD;
pub const UDAT_FLEXIBLE_DAY_PERIOD_FIELD = UDateFormatField.FLEXIBLE_DAY_PERIOD_FIELD;

pub const UDateFormatBooleanAttribute = enum(i32) {
    PARSE_ALLOW_WHITESPACE = 0,
    PARSE_ALLOW_NUMERIC = 1,
    PARSE_PARTIAL_LITERAL_MATCH = 2,
    PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    BOOLEAN_ATTRIBUTE_COUNT = 4,
};
pub const UDAT_PARSE_ALLOW_WHITESPACE = UDateFormatBooleanAttribute.PARSE_ALLOW_WHITESPACE;
pub const UDAT_PARSE_ALLOW_NUMERIC = UDateFormatBooleanAttribute.PARSE_ALLOW_NUMERIC;
pub const UDAT_PARSE_PARTIAL_LITERAL_MATCH = UDateFormatBooleanAttribute.PARSE_PARTIAL_LITERAL_MATCH;
pub const UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = UDateFormatBooleanAttribute.PARSE_MULTIPLE_PATTERNS_FOR_MATCH;
pub const UDAT_BOOLEAN_ATTRIBUTE_COUNT = UDateFormatBooleanAttribute.BOOLEAN_ATTRIBUTE_COUNT;

pub const UDateFormatSymbolType = enum(i32) {
    ERAS = 0,
    MONTHS = 1,
    SHORT_MONTHS = 2,
    WEEKDAYS = 3,
    SHORT_WEEKDAYS = 4,
    AM_PMS = 5,
    LOCALIZED_CHARS = 6,
    ERA_NAMES = 7,
    NARROW_MONTHS = 8,
    NARROW_WEEKDAYS = 9,
    STANDALONE_MONTHS = 10,
    STANDALONE_SHORT_MONTHS = 11,
    STANDALONE_NARROW_MONTHS = 12,
    STANDALONE_WEEKDAYS = 13,
    STANDALONE_SHORT_WEEKDAYS = 14,
    STANDALONE_NARROW_WEEKDAYS = 15,
    QUARTERS = 16,
    SHORT_QUARTERS = 17,
    STANDALONE_QUARTERS = 18,
    STANDALONE_SHORT_QUARTERS = 19,
    SHORTER_WEEKDAYS = 20,
    STANDALONE_SHORTER_WEEKDAYS = 21,
    CYCLIC_YEARS_WIDE = 22,
    CYCLIC_YEARS_ABBREVIATED = 23,
    CYCLIC_YEARS_NARROW = 24,
    ZODIAC_NAMES_WIDE = 25,
    ZODIAC_NAMES_ABBREVIATED = 26,
    ZODIAC_NAMES_NARROW = 27,
};
pub const UDAT_ERAS = UDateFormatSymbolType.ERAS;
pub const UDAT_MONTHS = UDateFormatSymbolType.MONTHS;
pub const UDAT_SHORT_MONTHS = UDateFormatSymbolType.SHORT_MONTHS;
pub const UDAT_WEEKDAYS = UDateFormatSymbolType.WEEKDAYS;
pub const UDAT_SHORT_WEEKDAYS = UDateFormatSymbolType.SHORT_WEEKDAYS;
pub const UDAT_AM_PMS = UDateFormatSymbolType.AM_PMS;
pub const UDAT_LOCALIZED_CHARS = UDateFormatSymbolType.LOCALIZED_CHARS;
pub const UDAT_ERA_NAMES = UDateFormatSymbolType.ERA_NAMES;
pub const UDAT_NARROW_MONTHS = UDateFormatSymbolType.NARROW_MONTHS;
pub const UDAT_NARROW_WEEKDAYS = UDateFormatSymbolType.NARROW_WEEKDAYS;
pub const UDAT_STANDALONE_MONTHS = UDateFormatSymbolType.STANDALONE_MONTHS;
pub const UDAT_STANDALONE_SHORT_MONTHS = UDateFormatSymbolType.STANDALONE_SHORT_MONTHS;
pub const UDAT_STANDALONE_NARROW_MONTHS = UDateFormatSymbolType.STANDALONE_NARROW_MONTHS;
pub const UDAT_STANDALONE_WEEKDAYS = UDateFormatSymbolType.STANDALONE_WEEKDAYS;
pub const UDAT_STANDALONE_SHORT_WEEKDAYS = UDateFormatSymbolType.STANDALONE_SHORT_WEEKDAYS;
pub const UDAT_STANDALONE_NARROW_WEEKDAYS = UDateFormatSymbolType.STANDALONE_NARROW_WEEKDAYS;
pub const UDAT_QUARTERS = UDateFormatSymbolType.QUARTERS;
pub const UDAT_SHORT_QUARTERS = UDateFormatSymbolType.SHORT_QUARTERS;
pub const UDAT_STANDALONE_QUARTERS = UDateFormatSymbolType.STANDALONE_QUARTERS;
pub const UDAT_STANDALONE_SHORT_QUARTERS = UDateFormatSymbolType.STANDALONE_SHORT_QUARTERS;
pub const UDAT_SHORTER_WEEKDAYS = UDateFormatSymbolType.SHORTER_WEEKDAYS;
pub const UDAT_STANDALONE_SHORTER_WEEKDAYS = UDateFormatSymbolType.STANDALONE_SHORTER_WEEKDAYS;
pub const UDAT_CYCLIC_YEARS_WIDE = UDateFormatSymbolType.CYCLIC_YEARS_WIDE;
pub const UDAT_CYCLIC_YEARS_ABBREVIATED = UDateFormatSymbolType.CYCLIC_YEARS_ABBREVIATED;
pub const UDAT_CYCLIC_YEARS_NARROW = UDateFormatSymbolType.CYCLIC_YEARS_NARROW;
pub const UDAT_ZODIAC_NAMES_WIDE = UDateFormatSymbolType.ZODIAC_NAMES_WIDE;
pub const UDAT_ZODIAC_NAMES_ABBREVIATED = UDateFormatSymbolType.ZODIAC_NAMES_ABBREVIATED;
pub const UDAT_ZODIAC_NAMES_NARROW = UDateFormatSymbolType.ZODIAC_NAMES_NARROW;

pub const UDateFormatSymbols = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UDateTimePatternField = enum(i32) {
    ERA_FIELD = 0,
    YEAR_FIELD = 1,
    QUARTER_FIELD = 2,
    MONTH_FIELD = 3,
    WEEK_OF_YEAR_FIELD = 4,
    WEEK_OF_MONTH_FIELD = 5,
    WEEKDAY_FIELD = 6,
    DAY_OF_YEAR_FIELD = 7,
    DAY_OF_WEEK_IN_MONTH_FIELD = 8,
    DAY_FIELD = 9,
    DAYPERIOD_FIELD = 10,
    HOUR_FIELD = 11,
    MINUTE_FIELD = 12,
    SECOND_FIELD = 13,
    FRACTIONAL_SECOND_FIELD = 14,
    ZONE_FIELD = 15,
    FIELD_COUNT = 16,
};
pub const UDATPG_ERA_FIELD = UDateTimePatternField.ERA_FIELD;
pub const UDATPG_YEAR_FIELD = UDateTimePatternField.YEAR_FIELD;
pub const UDATPG_QUARTER_FIELD = UDateTimePatternField.QUARTER_FIELD;
pub const UDATPG_MONTH_FIELD = UDateTimePatternField.MONTH_FIELD;
pub const UDATPG_WEEK_OF_YEAR_FIELD = UDateTimePatternField.WEEK_OF_YEAR_FIELD;
pub const UDATPG_WEEK_OF_MONTH_FIELD = UDateTimePatternField.WEEK_OF_MONTH_FIELD;
pub const UDATPG_WEEKDAY_FIELD = UDateTimePatternField.WEEKDAY_FIELD;
pub const UDATPG_DAY_OF_YEAR_FIELD = UDateTimePatternField.DAY_OF_YEAR_FIELD;
pub const UDATPG_DAY_OF_WEEK_IN_MONTH_FIELD = UDateTimePatternField.DAY_OF_WEEK_IN_MONTH_FIELD;
pub const UDATPG_DAY_FIELD = UDateTimePatternField.DAY_FIELD;
pub const UDATPG_DAYPERIOD_FIELD = UDateTimePatternField.DAYPERIOD_FIELD;
pub const UDATPG_HOUR_FIELD = UDateTimePatternField.HOUR_FIELD;
pub const UDATPG_MINUTE_FIELD = UDateTimePatternField.MINUTE_FIELD;
pub const UDATPG_SECOND_FIELD = UDateTimePatternField.SECOND_FIELD;
pub const UDATPG_FRACTIONAL_SECOND_FIELD = UDateTimePatternField.FRACTIONAL_SECOND_FIELD;
pub const UDATPG_ZONE_FIELD = UDateTimePatternField.ZONE_FIELD;
pub const UDATPG_FIELD_COUNT = UDateTimePatternField.FIELD_COUNT;

pub const UDateTimePGDisplayWidth = enum(i32) {
    WIDE = 0,
    ABBREVIATED = 1,
    NARROW = 2,
};
pub const UDATPG_WIDE = UDateTimePGDisplayWidth.WIDE;
pub const UDATPG_ABBREVIATED = UDateTimePGDisplayWidth.ABBREVIATED;
pub const UDATPG_NARROW = UDateTimePGDisplayWidth.NARROW;

pub const UDateTimePatternMatchOptions = enum(i32) {
    NO_OPTIONS = 0,
    HOUR_FIELD_LENGTH = 2048,
    ALL_FIELDS_LENGTH = 65535,
};
pub const UDATPG_MATCH_NO_OPTIONS = UDateTimePatternMatchOptions.NO_OPTIONS;
pub const UDATPG_MATCH_HOUR_FIELD_LENGTH = UDateTimePatternMatchOptions.HOUR_FIELD_LENGTH;
pub const UDATPG_MATCH_ALL_FIELDS_LENGTH = UDateTimePatternMatchOptions.ALL_FIELDS_LENGTH;

pub const UDateTimePatternConflict = enum(i32) {
    NO_CONFLICT = 0,
    BASE_CONFLICT = 1,
    CONFLICT = 2,
};
pub const UDATPG_NO_CONFLICT = UDateTimePatternConflict.NO_CONFLICT;
pub const UDATPG_BASE_CONFLICT = UDateTimePatternConflict.BASE_CONFLICT;
pub const UDATPG_CONFLICT = UDateTimePatternConflict.CONFLICT;

pub const UNumberUnitWidth = enum(i32) {
    NARROW = 0,
    SHORT = 1,
    FULL_NAME = 2,
    ISO_CODE = 3,
    HIDDEN = 4,
    COUNT = 5,
};
pub const UNUM_UNIT_WIDTH_NARROW = UNumberUnitWidth.NARROW;
pub const UNUM_UNIT_WIDTH_SHORT = UNumberUnitWidth.SHORT;
pub const UNUM_UNIT_WIDTH_FULL_NAME = UNumberUnitWidth.FULL_NAME;
pub const UNUM_UNIT_WIDTH_ISO_CODE = UNumberUnitWidth.ISO_CODE;
pub const UNUM_UNIT_WIDTH_HIDDEN = UNumberUnitWidth.HIDDEN;
pub const UNUM_UNIT_WIDTH_COUNT = UNumberUnitWidth.COUNT;

pub const UNumberGroupingStrategy = enum(i32) {
    OFF = 0,
    MIN2 = 1,
    AUTO = 2,
    ON_ALIGNED = 3,
    THOUSANDS = 4,
};
pub const UNUM_GROUPING_OFF = UNumberGroupingStrategy.OFF;
pub const UNUM_GROUPING_MIN2 = UNumberGroupingStrategy.MIN2;
pub const UNUM_GROUPING_AUTO = UNumberGroupingStrategy.AUTO;
pub const UNUM_GROUPING_ON_ALIGNED = UNumberGroupingStrategy.ON_ALIGNED;
pub const UNUM_GROUPING_THOUSANDS = UNumberGroupingStrategy.THOUSANDS;

pub const UNumberSignDisplay = enum(i32) {
    AUTO = 0,
    ALWAYS = 1,
    NEVER = 2,
    ACCOUNTING = 3,
    ACCOUNTING_ALWAYS = 4,
    EXCEPT_ZERO = 5,
    ACCOUNTING_EXCEPT_ZERO = 6,
    COUNT = 7,
};
pub const UNUM_SIGN_AUTO = UNumberSignDisplay.AUTO;
pub const UNUM_SIGN_ALWAYS = UNumberSignDisplay.ALWAYS;
pub const UNUM_SIGN_NEVER = UNumberSignDisplay.NEVER;
pub const UNUM_SIGN_ACCOUNTING = UNumberSignDisplay.ACCOUNTING;
pub const UNUM_SIGN_ACCOUNTING_ALWAYS = UNumberSignDisplay.ACCOUNTING_ALWAYS;
pub const UNUM_SIGN_EXCEPT_ZERO = UNumberSignDisplay.EXCEPT_ZERO;
pub const UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO = UNumberSignDisplay.ACCOUNTING_EXCEPT_ZERO;
pub const UNUM_SIGN_COUNT = UNumberSignDisplay.COUNT;

pub const UNumberDecimalSeparatorDisplay = enum(i32) {
    AUTO = 0,
    ALWAYS = 1,
    COUNT = 2,
};
pub const UNUM_DECIMAL_SEPARATOR_AUTO = UNumberDecimalSeparatorDisplay.AUTO;
pub const UNUM_DECIMAL_SEPARATOR_ALWAYS = UNumberDecimalSeparatorDisplay.ALWAYS;
pub const UNUM_DECIMAL_SEPARATOR_COUNT = UNumberDecimalSeparatorDisplay.COUNT;

pub const UNumberFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedNumber = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UNumberRangeCollapse = enum(i32) {
    AUTO = 0,
    NONE = 1,
    UNIT = 2,
    ALL = 3,
};
pub const UNUM_RANGE_COLLAPSE_AUTO = UNumberRangeCollapse.AUTO;
pub const UNUM_RANGE_COLLAPSE_NONE = UNumberRangeCollapse.NONE;
pub const UNUM_RANGE_COLLAPSE_UNIT = UNumberRangeCollapse.UNIT;
pub const UNUM_RANGE_COLLAPSE_ALL = UNumberRangeCollapse.ALL;

pub const UNumberRangeIdentityFallback = enum(i32) {
    SINGLE_VALUE = 0,
    APPROXIMATELY_OR_SINGLE_VALUE = 1,
    APPROXIMATELY = 2,
    RANGE = 3,
};
pub const UNUM_IDENTITY_FALLBACK_SINGLE_VALUE = UNumberRangeIdentityFallback.SINGLE_VALUE;
pub const UNUM_IDENTITY_FALLBACK_APPROXIMATELY_OR_SINGLE_VALUE = UNumberRangeIdentityFallback.APPROXIMATELY_OR_SINGLE_VALUE;
pub const UNUM_IDENTITY_FALLBACK_APPROXIMATELY = UNumberRangeIdentityFallback.APPROXIMATELY;
pub const UNUM_IDENTITY_FALLBACK_RANGE = UNumberRangeIdentityFallback.RANGE;

pub const UNumberRangeIdentityResult = enum(i32) {
    EQUAL_BEFORE_ROUNDING = 0,
    EQUAL_AFTER_ROUNDING = 1,
    NOT_EQUAL = 2,
};
pub const UNUM_IDENTITY_RESULT_EQUAL_BEFORE_ROUNDING = UNumberRangeIdentityResult.EQUAL_BEFORE_ROUNDING;
pub const UNUM_IDENTITY_RESULT_EQUAL_AFTER_ROUNDING = UNumberRangeIdentityResult.EQUAL_AFTER_ROUNDING;
pub const UNUM_IDENTITY_RESULT_NOT_EQUAL = UNumberRangeIdentityResult.NOT_EQUAL;

pub const UNumberingSystem = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedNumberRange = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UPluralType = enum(i32) {
    CARDINAL = 0,
    ORDINAL = 1,
};
pub const UPLURAL_TYPE_CARDINAL = UPluralType.CARDINAL;
pub const UPLURAL_TYPE_ORDINAL = UPluralType.ORDINAL;

pub const UPluralRules = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const URegularExpression = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const URegexpFlag = enum(i32) {
    CASE_INSENSITIVE = 2,
    COMMENTS = 4,
    DOTALL = 32,
    LITERAL = 16,
    MULTILINE = 8,
    UNIX_LINES = 1,
    UWORD = 256,
    ERROR_ON_UNKNOWN_ESCAPES = 512,
};
pub const UREGEX_CASE_INSENSITIVE = URegexpFlag.CASE_INSENSITIVE;
pub const UREGEX_COMMENTS = URegexpFlag.COMMENTS;
pub const UREGEX_DOTALL = URegexpFlag.DOTALL;
pub const UREGEX_LITERAL = URegexpFlag.LITERAL;
pub const UREGEX_MULTILINE = URegexpFlag.MULTILINE;
pub const UREGEX_UNIX_LINES = URegexpFlag.UNIX_LINES;
pub const UREGEX_UWORD = URegexpFlag.UWORD;
pub const UREGEX_ERROR_ON_UNKNOWN_ESCAPES = URegexpFlag.ERROR_ON_UNKNOWN_ESCAPES;

pub const URegexMatchCallback = *const fn (
    context: ?*const anyopaque,
    steps: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const URegexFindProgressCallback = *const fn (
    context: ?*const anyopaque,
    match_index: i64,
) callconv(@import("std").os.windows.WINAPI) i8;

pub const URegionType = enum(i32) {
    UNKNOWN = 0,
    TERRITORY = 1,
    WORLD = 2,
    CONTINENT = 3,
    SUBCONTINENT = 4,
    GROUPING = 5,
    DEPRECATED = 6,
};
pub const URGN_UNKNOWN = URegionType.UNKNOWN;
pub const URGN_TERRITORY = URegionType.TERRITORY;
pub const URGN_WORLD = URegionType.WORLD;
pub const URGN_CONTINENT = URegionType.CONTINENT;
pub const URGN_SUBCONTINENT = URegionType.SUBCONTINENT;
pub const URGN_GROUPING = URegionType.GROUPING;
pub const URGN_DEPRECATED = URegionType.DEPRECATED;

pub const URegion = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UDateRelativeDateTimeFormatterStyle = enum(i32) {
    LONG = 0,
    SHORT = 1,
    NARROW = 2,
};
pub const UDAT_STYLE_LONG = UDateRelativeDateTimeFormatterStyle.LONG;
pub const UDAT_STYLE_SHORT = UDateRelativeDateTimeFormatterStyle.SHORT;
pub const UDAT_STYLE_NARROW = UDateRelativeDateTimeFormatterStyle.NARROW;

pub const URelativeDateTimeUnit = enum(i32) {
    YEAR = 0,
    QUARTER = 1,
    MONTH = 2,
    WEEK = 3,
    DAY = 4,
    HOUR = 5,
    MINUTE = 6,
    SECOND = 7,
    SUNDAY = 8,
    MONDAY = 9,
    TUESDAY = 10,
    WEDNESDAY = 11,
    THURSDAY = 12,
    FRIDAY = 13,
    SATURDAY = 14,
};
pub const UDAT_REL_UNIT_YEAR = URelativeDateTimeUnit.YEAR;
pub const UDAT_REL_UNIT_QUARTER = URelativeDateTimeUnit.QUARTER;
pub const UDAT_REL_UNIT_MONTH = URelativeDateTimeUnit.MONTH;
pub const UDAT_REL_UNIT_WEEK = URelativeDateTimeUnit.WEEK;
pub const UDAT_REL_UNIT_DAY = URelativeDateTimeUnit.DAY;
pub const UDAT_REL_UNIT_HOUR = URelativeDateTimeUnit.HOUR;
pub const UDAT_REL_UNIT_MINUTE = URelativeDateTimeUnit.MINUTE;
pub const UDAT_REL_UNIT_SECOND = URelativeDateTimeUnit.SECOND;
pub const UDAT_REL_UNIT_SUNDAY = URelativeDateTimeUnit.SUNDAY;
pub const UDAT_REL_UNIT_MONDAY = URelativeDateTimeUnit.MONDAY;
pub const UDAT_REL_UNIT_TUESDAY = URelativeDateTimeUnit.TUESDAY;
pub const UDAT_REL_UNIT_WEDNESDAY = URelativeDateTimeUnit.WEDNESDAY;
pub const UDAT_REL_UNIT_THURSDAY = URelativeDateTimeUnit.THURSDAY;
pub const UDAT_REL_UNIT_FRIDAY = URelativeDateTimeUnit.FRIDAY;
pub const UDAT_REL_UNIT_SATURDAY = URelativeDateTimeUnit.SATURDAY;

pub const URelativeDateTimeFormatterField = enum(i32) {
    LITERAL_FIELD = 0,
    NUMERIC_FIELD = 1,
};
pub const UDAT_REL_LITERAL_FIELD = URelativeDateTimeFormatterField.LITERAL_FIELD;
pub const UDAT_REL_NUMERIC_FIELD = URelativeDateTimeFormatterField.NUMERIC_FIELD;

pub const URelativeDateTimeFormatter = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UFormattedRelativeDateTime = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UStringSearch = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USearchAttribute = enum(i32) {
    OVERLAP = 0,
    ELEMENT_COMPARISON = 2,
};
pub const USEARCH_OVERLAP = USearchAttribute.OVERLAP;
pub const USEARCH_ELEMENT_COMPARISON = USearchAttribute.ELEMENT_COMPARISON;

pub const USearchAttributeValue = enum(i32) {
    DEFAULT = -1,
    OFF = 0,
    ON = 1,
    STANDARD_ELEMENT_COMPARISON = 2,
    PATTERN_BASE_WEIGHT_IS_WILDCARD = 3,
    ANY_BASE_WEIGHT_IS_WILDCARD = 4,
};
pub const USEARCH_DEFAULT = USearchAttributeValue.DEFAULT;
pub const USEARCH_OFF = USearchAttributeValue.OFF;
pub const USEARCH_ON = USearchAttributeValue.ON;
pub const USEARCH_STANDARD_ELEMENT_COMPARISON = USearchAttributeValue.STANDARD_ELEMENT_COMPARISON;
pub const USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD = USearchAttributeValue.PATTERN_BASE_WEIGHT_IS_WILDCARD;
pub const USEARCH_ANY_BASE_WEIGHT_IS_WILDCARD = USearchAttributeValue.ANY_BASE_WEIGHT_IS_WILDCARD;

pub const USpoofChecker = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USpoofCheckResult = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const USpoofChecks = enum(i32) {
    SINGLE_SCRIPT_CONFUSABLE = 1,
    MIXED_SCRIPT_CONFUSABLE = 2,
    WHOLE_SCRIPT_CONFUSABLE = 4,
    CONFUSABLE = 7,
    RESTRICTION_LEVEL = 16,
    INVISIBLE = 32,
    CHAR_LIMIT = 64,
    MIXED_NUMBERS = 128,
    HIDDEN_OVERLAY = 256,
    ALL_CHECKS = 65535,
    AUX_INFO = 1073741824,
};
pub const USPOOF_SINGLE_SCRIPT_CONFUSABLE = USpoofChecks.SINGLE_SCRIPT_CONFUSABLE;
pub const USPOOF_MIXED_SCRIPT_CONFUSABLE = USpoofChecks.MIXED_SCRIPT_CONFUSABLE;
pub const USPOOF_WHOLE_SCRIPT_CONFUSABLE = USpoofChecks.WHOLE_SCRIPT_CONFUSABLE;
pub const USPOOF_CONFUSABLE = USpoofChecks.CONFUSABLE;
pub const USPOOF_RESTRICTION_LEVEL = USpoofChecks.RESTRICTION_LEVEL;
pub const USPOOF_INVISIBLE = USpoofChecks.INVISIBLE;
pub const USPOOF_CHAR_LIMIT = USpoofChecks.CHAR_LIMIT;
pub const USPOOF_MIXED_NUMBERS = USpoofChecks.MIXED_NUMBERS;
pub const USPOOF_HIDDEN_OVERLAY = USpoofChecks.HIDDEN_OVERLAY;
pub const USPOOF_ALL_CHECKS = USpoofChecks.ALL_CHECKS;
pub const USPOOF_AUX_INFO = USpoofChecks.AUX_INFO;

pub const URestrictionLevel = enum(i32) {
    ASCII = 268435456,
    SINGLE_SCRIPT_RESTRICTIVE = 536870912,
    HIGHLY_RESTRICTIVE = 805306368,
    MODERATELY_RESTRICTIVE = 1073741824,
    MINIMALLY_RESTRICTIVE = 1342177280,
    UNRESTRICTIVE = 1610612736,
    RESTRICTION_LEVEL_MASK = 2130706432,
};
pub const USPOOF_ASCII = URestrictionLevel.ASCII;
pub const USPOOF_SINGLE_SCRIPT_RESTRICTIVE = URestrictionLevel.SINGLE_SCRIPT_RESTRICTIVE;
pub const USPOOF_HIGHLY_RESTRICTIVE = URestrictionLevel.HIGHLY_RESTRICTIVE;
pub const USPOOF_MODERATELY_RESTRICTIVE = URestrictionLevel.MODERATELY_RESTRICTIVE;
pub const USPOOF_MINIMALLY_RESTRICTIVE = URestrictionLevel.MINIMALLY_RESTRICTIVE;
pub const USPOOF_UNRESTRICTIVE = URestrictionLevel.UNRESTRICTIVE;
pub const USPOOF_RESTRICTION_LEVEL_MASK = URestrictionLevel.RESTRICTION_LEVEL_MASK;

pub const UDateTimeScale = enum(i32) {
    JAVA_TIME = 0,
    UNIX_TIME = 1,
    ICU4C_TIME = 2,
    WINDOWS_FILE_TIME = 3,
    DOTNET_DATE_TIME = 4,
    MAC_OLD_TIME = 5,
    MAC_TIME = 6,
    EXCEL_TIME = 7,
    DB2_TIME = 8,
    UNIX_MICROSECONDS_TIME = 9,
};
pub const UDTS_JAVA_TIME = UDateTimeScale.JAVA_TIME;
pub const UDTS_UNIX_TIME = UDateTimeScale.UNIX_TIME;
pub const UDTS_ICU4C_TIME = UDateTimeScale.ICU4C_TIME;
pub const UDTS_WINDOWS_FILE_TIME = UDateTimeScale.WINDOWS_FILE_TIME;
pub const UDTS_DOTNET_DATE_TIME = UDateTimeScale.DOTNET_DATE_TIME;
pub const UDTS_MAC_OLD_TIME = UDateTimeScale.MAC_OLD_TIME;
pub const UDTS_MAC_TIME = UDateTimeScale.MAC_TIME;
pub const UDTS_EXCEL_TIME = UDateTimeScale.EXCEL_TIME;
pub const UDTS_DB2_TIME = UDateTimeScale.DB2_TIME;
pub const UDTS_UNIX_MICROSECONDS_TIME = UDateTimeScale.UNIX_MICROSECONDS_TIME;

pub const UTimeScaleValue = enum(i32) {
    UNITS_VALUE = 0,
    EPOCH_OFFSET_VALUE = 1,
    FROM_MIN_VALUE = 2,
    FROM_MAX_VALUE = 3,
    TO_MIN_VALUE = 4,
    TO_MAX_VALUE = 5,
};
pub const UTSV_UNITS_VALUE = UTimeScaleValue.UNITS_VALUE;
pub const UTSV_EPOCH_OFFSET_VALUE = UTimeScaleValue.EPOCH_OFFSET_VALUE;
pub const UTSV_FROM_MIN_VALUE = UTimeScaleValue.FROM_MIN_VALUE;
pub const UTSV_FROM_MAX_VALUE = UTimeScaleValue.FROM_MAX_VALUE;
pub const UTSV_TO_MIN_VALUE = UTimeScaleValue.TO_MIN_VALUE;
pub const UTSV_TO_MAX_VALUE = UTimeScaleValue.TO_MAX_VALUE;

pub const UTransDirection = enum(i32) {
    FORWARD = 0,
    REVERSE = 1,
};
pub const UTRANS_FORWARD = UTransDirection.FORWARD;
pub const UTRANS_REVERSE = UTransDirection.REVERSE;

pub const UTransPosition = extern struct {
    contextStart: i32,
    contextLimit: i32,
    start: i32,
    limit: i32,
};

pub const UHashtable = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const UStringTrieBuildOption = enum(i32) {
    FAST = 0,
    SMALL = 1,
};
pub const USTRINGTRIE_BUILD_FAST = UStringTrieBuildOption.FAST;
pub const USTRINGTRIE_BUILD_SMALL = UStringTrieBuildOption.SMALL;

pub const UStringCaseMapper = *const fn (
    csm: ?*const UCaseMap,
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const UMessagePatternApostropheMode = enum(i32) {
    OPTIONAL = 0,
    REQUIRED = 1,
};
pub const UMSGPAT_APOS_DOUBLE_OPTIONAL = UMessagePatternApostropheMode.OPTIONAL;
pub const UMSGPAT_APOS_DOUBLE_REQUIRED = UMessagePatternApostropheMode.REQUIRED;

pub const UMessagePatternPartType = enum(i32) {
    MSG_START = 0,
    MSG_LIMIT = 1,
    SKIP_SYNTAX = 2,
    INSERT_CHAR = 3,
    REPLACE_NUMBER = 4,
    ARG_START = 5,
    ARG_LIMIT = 6,
    ARG_NUMBER = 7,
    ARG_NAME = 8,
    ARG_TYPE = 9,
    ARG_STYLE = 10,
    ARG_SELECTOR = 11,
    ARG_INT = 12,
    ARG_DOUBLE = 13,
};
pub const UMSGPAT_PART_TYPE_MSG_START = UMessagePatternPartType.MSG_START;
pub const UMSGPAT_PART_TYPE_MSG_LIMIT = UMessagePatternPartType.MSG_LIMIT;
pub const UMSGPAT_PART_TYPE_SKIP_SYNTAX = UMessagePatternPartType.SKIP_SYNTAX;
pub const UMSGPAT_PART_TYPE_INSERT_CHAR = UMessagePatternPartType.INSERT_CHAR;
pub const UMSGPAT_PART_TYPE_REPLACE_NUMBER = UMessagePatternPartType.REPLACE_NUMBER;
pub const UMSGPAT_PART_TYPE_ARG_START = UMessagePatternPartType.ARG_START;
pub const UMSGPAT_PART_TYPE_ARG_LIMIT = UMessagePatternPartType.ARG_LIMIT;
pub const UMSGPAT_PART_TYPE_ARG_NUMBER = UMessagePatternPartType.ARG_NUMBER;
pub const UMSGPAT_PART_TYPE_ARG_NAME = UMessagePatternPartType.ARG_NAME;
pub const UMSGPAT_PART_TYPE_ARG_TYPE = UMessagePatternPartType.ARG_TYPE;
pub const UMSGPAT_PART_TYPE_ARG_STYLE = UMessagePatternPartType.ARG_STYLE;
pub const UMSGPAT_PART_TYPE_ARG_SELECTOR = UMessagePatternPartType.ARG_SELECTOR;
pub const UMSGPAT_PART_TYPE_ARG_INT = UMessagePatternPartType.ARG_INT;
pub const UMSGPAT_PART_TYPE_ARG_DOUBLE = UMessagePatternPartType.ARG_DOUBLE;

pub const UMessagePatternArgType = enum(i32) {
    NONE = 0,
    SIMPLE = 1,
    CHOICE = 2,
    PLURAL = 3,
    SELECT = 4,
    SELECTORDINAL = 5,
};
pub const UMSGPAT_ARG_TYPE_NONE = UMessagePatternArgType.NONE;
pub const UMSGPAT_ARG_TYPE_SIMPLE = UMessagePatternArgType.SIMPLE;
pub const UMSGPAT_ARG_TYPE_CHOICE = UMessagePatternArgType.CHOICE;
pub const UMSGPAT_ARG_TYPE_PLURAL = UMessagePatternArgType.PLURAL;
pub const UMSGPAT_ARG_TYPE_SELECT = UMessagePatternArgType.SELECT;
pub const UMSGPAT_ARG_TYPE_SELECTORDINAL = UMessagePatternArgType.SELECTORDINAL;

pub const UAlphabeticIndexLabelType = enum(i32) {
    NORMAL = 0,
    UNDERFLOW = 1,
    INFLOW = 2,
    OVERFLOW = 3,
};
pub const U_ALPHAINDEX_NORMAL = UAlphabeticIndexLabelType.NORMAL;
pub const U_ALPHAINDEX_UNDERFLOW = UAlphabeticIndexLabelType.UNDERFLOW;
pub const U_ALPHAINDEX_INFLOW = UAlphabeticIndexLabelType.INFLOW;
pub const U_ALPHAINDEX_OVERFLOW = UAlphabeticIndexLabelType.OVERFLOW;

pub const UTimeZoneNameType = enum(i32) {
    UNKNOWN = 0,
    LONG_GENERIC = 1,
    LONG_STANDARD = 2,
    LONG_DAYLIGHT = 4,
    SHORT_GENERIC = 8,
    SHORT_STANDARD = 16,
    SHORT_DAYLIGHT = 32,
    EXEMPLAR_LOCATION = 64,
};
pub const UTZNM_UNKNOWN = UTimeZoneNameType.UNKNOWN;
pub const UTZNM_LONG_GENERIC = UTimeZoneNameType.LONG_GENERIC;
pub const UTZNM_LONG_STANDARD = UTimeZoneNameType.LONG_STANDARD;
pub const UTZNM_LONG_DAYLIGHT = UTimeZoneNameType.LONG_DAYLIGHT;
pub const UTZNM_SHORT_GENERIC = UTimeZoneNameType.SHORT_GENERIC;
pub const UTZNM_SHORT_STANDARD = UTimeZoneNameType.SHORT_STANDARD;
pub const UTZNM_SHORT_DAYLIGHT = UTimeZoneNameType.SHORT_DAYLIGHT;
pub const UTZNM_EXEMPLAR_LOCATION = UTimeZoneNameType.EXEMPLAR_LOCATION;

pub const UTimeZoneFormatStyle = enum(i32) {
    GENERIC_LOCATION = 0,
    GENERIC_LONG = 1,
    GENERIC_SHORT = 2,
    SPECIFIC_LONG = 3,
    SPECIFIC_SHORT = 4,
    LOCALIZED_GMT = 5,
    LOCALIZED_GMT_SHORT = 6,
    ISO_BASIC_SHORT = 7,
    ISO_BASIC_LOCAL_SHORT = 8,
    ISO_BASIC_FIXED = 9,
    ISO_BASIC_LOCAL_FIXED = 10,
    ISO_BASIC_FULL = 11,
    ISO_BASIC_LOCAL_FULL = 12,
    ISO_EXTENDED_FIXED = 13,
    ISO_EXTENDED_LOCAL_FIXED = 14,
    ISO_EXTENDED_FULL = 15,
    ISO_EXTENDED_LOCAL_FULL = 16,
    ZONE_ID = 17,
    ZONE_ID_SHORT = 18,
    EXEMPLAR_LOCATION = 19,
};
pub const UTZFMT_STYLE_GENERIC_LOCATION = UTimeZoneFormatStyle.GENERIC_LOCATION;
pub const UTZFMT_STYLE_GENERIC_LONG = UTimeZoneFormatStyle.GENERIC_LONG;
pub const UTZFMT_STYLE_GENERIC_SHORT = UTimeZoneFormatStyle.GENERIC_SHORT;
pub const UTZFMT_STYLE_SPECIFIC_LONG = UTimeZoneFormatStyle.SPECIFIC_LONG;
pub const UTZFMT_STYLE_SPECIFIC_SHORT = UTimeZoneFormatStyle.SPECIFIC_SHORT;
pub const UTZFMT_STYLE_LOCALIZED_GMT = UTimeZoneFormatStyle.LOCALIZED_GMT;
pub const UTZFMT_STYLE_LOCALIZED_GMT_SHORT = UTimeZoneFormatStyle.LOCALIZED_GMT_SHORT;
pub const UTZFMT_STYLE_ISO_BASIC_SHORT = UTimeZoneFormatStyle.ISO_BASIC_SHORT;
pub const UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT = UTimeZoneFormatStyle.ISO_BASIC_LOCAL_SHORT;
pub const UTZFMT_STYLE_ISO_BASIC_FIXED = UTimeZoneFormatStyle.ISO_BASIC_FIXED;
pub const UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED = UTimeZoneFormatStyle.ISO_BASIC_LOCAL_FIXED;
pub const UTZFMT_STYLE_ISO_BASIC_FULL = UTimeZoneFormatStyle.ISO_BASIC_FULL;
pub const UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL = UTimeZoneFormatStyle.ISO_BASIC_LOCAL_FULL;
pub const UTZFMT_STYLE_ISO_EXTENDED_FIXED = UTimeZoneFormatStyle.ISO_EXTENDED_FIXED;
pub const UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED = UTimeZoneFormatStyle.ISO_EXTENDED_LOCAL_FIXED;
pub const UTZFMT_STYLE_ISO_EXTENDED_FULL = UTimeZoneFormatStyle.ISO_EXTENDED_FULL;
pub const UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL = UTimeZoneFormatStyle.ISO_EXTENDED_LOCAL_FULL;
pub const UTZFMT_STYLE_ZONE_ID = UTimeZoneFormatStyle.ZONE_ID;
pub const UTZFMT_STYLE_ZONE_ID_SHORT = UTimeZoneFormatStyle.ZONE_ID_SHORT;
pub const UTZFMT_STYLE_EXEMPLAR_LOCATION = UTimeZoneFormatStyle.EXEMPLAR_LOCATION;

pub const UTimeZoneFormatGMTOffsetPatternType = enum(i32) {
    POSITIVE_HM = 0,
    POSITIVE_HMS = 1,
    NEGATIVE_HM = 2,
    NEGATIVE_HMS = 3,
    POSITIVE_H = 4,
    NEGATIVE_H = 5,
    COUNT = 6,
};
pub const UTZFMT_PAT_POSITIVE_HM = UTimeZoneFormatGMTOffsetPatternType.POSITIVE_HM;
pub const UTZFMT_PAT_POSITIVE_HMS = UTimeZoneFormatGMTOffsetPatternType.POSITIVE_HMS;
pub const UTZFMT_PAT_NEGATIVE_HM = UTimeZoneFormatGMTOffsetPatternType.NEGATIVE_HM;
pub const UTZFMT_PAT_NEGATIVE_HMS = UTimeZoneFormatGMTOffsetPatternType.NEGATIVE_HMS;
pub const UTZFMT_PAT_POSITIVE_H = UTimeZoneFormatGMTOffsetPatternType.POSITIVE_H;
pub const UTZFMT_PAT_NEGATIVE_H = UTimeZoneFormatGMTOffsetPatternType.NEGATIVE_H;
pub const UTZFMT_PAT_COUNT = UTimeZoneFormatGMTOffsetPatternType.COUNT;

pub const UTimeZoneFormatTimeType = enum(i32) {
    UNKNOWN = 0,
    STANDARD = 1,
    DAYLIGHT = 2,
};
pub const UTZFMT_TIME_TYPE_UNKNOWN = UTimeZoneFormatTimeType.UNKNOWN;
pub const UTZFMT_TIME_TYPE_STANDARD = UTimeZoneFormatTimeType.STANDARD;
pub const UTZFMT_TIME_TYPE_DAYLIGHT = UTimeZoneFormatTimeType.DAYLIGHT;

pub const UTimeZoneFormatParseOption = enum(i32) {
    NONE = 0,
    ALL_STYLES = 1,
    TZ_DATABASE_ABBREVIATIONS = 2,
};
pub const UTZFMT_PARSE_OPTION_NONE = UTimeZoneFormatParseOption.NONE;
pub const UTZFMT_PARSE_OPTION_ALL_STYLES = UTimeZoneFormatParseOption.ALL_STYLES;
pub const UTZFMT_PARSE_OPTION_TZ_DATABASE_ABBREVIATIONS = UTimeZoneFormatParseOption.TZ_DATABASE_ABBREVIATIONS;

pub const UMeasureFormatWidth = enum(i32) {
    WIDE = 0,
    SHORT = 1,
    NARROW = 2,
    NUMERIC = 3,
    COUNT = 4,
};
pub const UMEASFMT_WIDTH_WIDE = UMeasureFormatWidth.WIDE;
pub const UMEASFMT_WIDTH_SHORT = UMeasureFormatWidth.SHORT;
pub const UMEASFMT_WIDTH_NARROW = UMeasureFormatWidth.NARROW;
pub const UMEASFMT_WIDTH_NUMERIC = UMeasureFormatWidth.NUMERIC;
pub const UMEASFMT_WIDTH_COUNT = UMeasureFormatWidth.COUNT;

pub const UDateRelativeUnit = enum(i32) {
    SECONDS = 0,
    MINUTES = 1,
    HOURS = 2,
    DAYS = 3,
    WEEKS = 4,
    MONTHS = 5,
    YEARS = 6,
    UNIT_COUNT = 7,
};
pub const UDAT_RELATIVE_SECONDS = UDateRelativeUnit.SECONDS;
pub const UDAT_RELATIVE_MINUTES = UDateRelativeUnit.MINUTES;
pub const UDAT_RELATIVE_HOURS = UDateRelativeUnit.HOURS;
pub const UDAT_RELATIVE_DAYS = UDateRelativeUnit.DAYS;
pub const UDAT_RELATIVE_WEEKS = UDateRelativeUnit.WEEKS;
pub const UDAT_RELATIVE_MONTHS = UDateRelativeUnit.MONTHS;
pub const UDAT_RELATIVE_YEARS = UDateRelativeUnit.YEARS;
pub const UDAT_RELATIVE_UNIT_COUNT = UDateRelativeUnit.UNIT_COUNT;

pub const UDateAbsoluteUnit = enum(i32) {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6,
    DAY = 7,
    WEEK = 8,
    MONTH = 9,
    YEAR = 10,
    NOW = 11,
    UNIT_COUNT = 12,
};
pub const UDAT_ABSOLUTE_SUNDAY = UDateAbsoluteUnit.SUNDAY;
pub const UDAT_ABSOLUTE_MONDAY = UDateAbsoluteUnit.MONDAY;
pub const UDAT_ABSOLUTE_TUESDAY = UDateAbsoluteUnit.TUESDAY;
pub const UDAT_ABSOLUTE_WEDNESDAY = UDateAbsoluteUnit.WEDNESDAY;
pub const UDAT_ABSOLUTE_THURSDAY = UDateAbsoluteUnit.THURSDAY;
pub const UDAT_ABSOLUTE_FRIDAY = UDateAbsoluteUnit.FRIDAY;
pub const UDAT_ABSOLUTE_SATURDAY = UDateAbsoluteUnit.SATURDAY;
pub const UDAT_ABSOLUTE_DAY = UDateAbsoluteUnit.DAY;
pub const UDAT_ABSOLUTE_WEEK = UDateAbsoluteUnit.WEEK;
pub const UDAT_ABSOLUTE_MONTH = UDateAbsoluteUnit.MONTH;
pub const UDAT_ABSOLUTE_YEAR = UDateAbsoluteUnit.YEAR;
pub const UDAT_ABSOLUTE_NOW = UDateAbsoluteUnit.NOW;
pub const UDAT_ABSOLUTE_UNIT_COUNT = UDateAbsoluteUnit.UNIT_COUNT;

pub const UDateDirection = enum(i32) {
    LAST_2 = 0,
    LAST = 1,
    THIS = 2,
    NEXT = 3,
    NEXT_2 = 4,
    PLAIN = 5,
    COUNT = 6,
};
pub const UDAT_DIRECTION_LAST_2 = UDateDirection.LAST_2;
pub const UDAT_DIRECTION_LAST = UDateDirection.LAST;
pub const UDAT_DIRECTION_THIS = UDateDirection.THIS;
pub const UDAT_DIRECTION_NEXT = UDateDirection.NEXT;
pub const UDAT_DIRECTION_NEXT_2 = UDateDirection.NEXT_2;
pub const UDAT_DIRECTION_PLAIN = UDateDirection.PLAIN;
pub const UDAT_DIRECTION_COUNT = UDateDirection.COUNT;

pub const USearch = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const CLSID_CMLangString_Value = Guid.initString("c04d65cf-b70d-11d0-b188-00aa0038c969");
pub const CLSID_CMLangString = &CLSID_CMLangString_Value;

const CLSID_CMLangConvertCharset_Value = Guid.initString("d66d6f99-cdaa-11d0-b822-00c04fc9b31f");
pub const CLSID_CMLangConvertCharset = &CLSID_CMLangConvertCharset_Value;

const CLSID_CMultiLanguage_Value = Guid.initString("275c23e2-3747-11d0-9fea-00aa003f8646");
pub const CLSID_CMultiLanguage = &CLSID_CMultiLanguage_Value;

const IID_IMLangStringBufW_Value = Guid.initString("d24acd21-ba72-11d0-b188-00aa0038c969");
pub const IID_IMLangStringBufW = &IID_IMLangStringBufW_Value;
pub const IMLangStringBufW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IMLangStringBufW,
            pl_flags: ?*i32,
            pcch_buf: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockBuf: *const fn (
            self: *const IMLangStringBufW,
            cch_offset: i32,
            cch_max_lock: i32,
            ppsz_buf: ?*?*u16,
            pcch_buf: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockBuf: *const fn (
            self: *const IMLangStringBufW,
            psz_buf: ?[*:0]const u16,
            cch_offset: i32,
            cch_write: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: *const fn (
            self: *const IMLangStringBufW,
            cch_offset: i32,
            cch_max_insert: i32,
            pcch_actual: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const IMLangStringBufW,
            cch_offset: i32,
            cch_delete: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, pl_flags_: ?*i32, pcch_buf_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufW.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMLangStringBufW, @ptrCast(self)), pl_flags_, pcch_buf_);
            }
            pub inline fn lockBuf(self: *const T, cch_offset_: i32, cch_max_lock_: i32, ppsz_buf_: ?*?*u16, pcch_buf_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufW.VTable, @ptrCast(self.vtable)).LockBuf(@as(*const IMLangStringBufW, @ptrCast(self)), cch_offset_, cch_max_lock_, ppsz_buf_, pcch_buf_);
            }
            pub inline fn unlockBuf(self: *const T, psz_buf_: ?[*:0]const u16, cch_offset_: i32, cch_write_: i32) HRESULT {
                return @as(*const IMLangStringBufW.VTable, @ptrCast(self.vtable)).UnlockBuf(@as(*const IMLangStringBufW, @ptrCast(self)), psz_buf_, cch_offset_, cch_write_);
            }
            pub inline fn insert(self: *const T, cch_offset_: i32, cch_max_insert_: i32, pcch_actual_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufW.VTable, @ptrCast(self.vtable)).Insert(@as(*const IMLangStringBufW, @ptrCast(self)), cch_offset_, cch_max_insert_, pcch_actual_);
            }
            pub inline fn delete(self: *const T, cch_offset_: i32, cch_delete_: i32) HRESULT {
                return @as(*const IMLangStringBufW.VTable, @ptrCast(self.vtable)).Delete(@as(*const IMLangStringBufW, @ptrCast(self)), cch_offset_, cch_delete_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangStringBufA_Value = Guid.initString("d24acd23-ba72-11d0-b188-00aa0038c969");
pub const IID_IMLangStringBufA = &IID_IMLangStringBufA_Value;
pub const IMLangStringBufA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IMLangStringBufA,
            pl_flags: ?*i32,
            pcch_buf: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockBuf: *const fn (
            self: *const IMLangStringBufA,
            cch_offset: i32,
            cch_max_lock: i32,
            ppsz_buf: ?*?*CHAR,
            pcch_buf: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockBuf: *const fn (
            self: *const IMLangStringBufA,
            psz_buf: ?[*:0]const u8,
            cch_offset: i32,
            cch_write: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: *const fn (
            self: *const IMLangStringBufA,
            cch_offset: i32,
            cch_max_insert: i32,
            pcch_actual: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn (
            self: *const IMLangStringBufA,
            cch_offset: i32,
            cch_delete: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, pl_flags_: ?*i32, pcch_buf_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufA.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMLangStringBufA, @ptrCast(self)), pl_flags_, pcch_buf_);
            }
            pub inline fn lockBuf(self: *const T, cch_offset_: i32, cch_max_lock_: i32, ppsz_buf_: ?*?*CHAR, pcch_buf_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufA.VTable, @ptrCast(self.vtable)).LockBuf(@as(*const IMLangStringBufA, @ptrCast(self)), cch_offset_, cch_max_lock_, ppsz_buf_, pcch_buf_);
            }
            pub inline fn unlockBuf(self: *const T, psz_buf_: ?[*:0]const u8, cch_offset_: i32, cch_write_: i32) HRESULT {
                return @as(*const IMLangStringBufA.VTable, @ptrCast(self.vtable)).UnlockBuf(@as(*const IMLangStringBufA, @ptrCast(self)), psz_buf_, cch_offset_, cch_write_);
            }
            pub inline fn insert(self: *const T, cch_offset_: i32, cch_max_insert_: i32, pcch_actual_: ?*i32) HRESULT {
                return @as(*const IMLangStringBufA.VTable, @ptrCast(self.vtable)).Insert(@as(*const IMLangStringBufA, @ptrCast(self)), cch_offset_, cch_max_insert_, pcch_actual_);
            }
            pub inline fn delete(self: *const T, cch_offset_: i32, cch_delete_: i32) HRESULT {
                return @as(*const IMLangStringBufA.VTable, @ptrCast(self.vtable)).Delete(@as(*const IMLangStringBufA, @ptrCast(self)), cch_offset_, cch_delete_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangString_Value = Guid.initString("c04d65ce-b70d-11d0-b188-00aa0038c969");
pub const IID_IMLangString = &IID_IMLangString_Value;
pub const IMLangString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Sync: *const fn (
            self: *const IMLangString,
            f_no_access: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: *const fn (
            self: *const IMLangString,
            pl_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMLStr: *const fn (
            self: *const IMLangString,
            l_dest_pos: i32,
            l_dest_len: i32,
            p_src_m_l_str: ?*IUnknown,
            l_src_pos: i32,
            l_src_len: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMLStr: *const fn (
            self: *const IMLangString,
            l_src_pos: i32,
            l_src_len: i32,
            p_unk_outer: ?*IUnknown,
            dw_cls_context: u32,
            piid: ?*const Guid,
            pp_dest_m_l_str: ?*?*IUnknown,
            pl_dest_pos: ?*i32,
            pl_dest_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn sync(self: *const T, f_no_access_: BOOL) HRESULT {
                return @as(*const IMLangString.VTable, @ptrCast(self.vtable)).Sync(@as(*const IMLangString, @ptrCast(self)), f_no_access_);
            }
            pub inline fn getLength(self: *const T, pl_len_: ?*i32) HRESULT {
                return @as(*const IMLangString.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMLangString, @ptrCast(self)), pl_len_);
            }
            pub inline fn setMLStr(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, p_src_m_l_str_: ?*IUnknown, l_src_pos_: i32, l_src_len_: i32) HRESULT {
                return @as(*const IMLangString.VTable, @ptrCast(self.vtable)).SetMLStr(@as(*const IMLangString, @ptrCast(self)), l_dest_pos_, l_dest_len_, p_src_m_l_str_, l_src_pos_, l_src_len_);
            }
            pub inline fn getMLStr(self: *const T, l_src_pos_: i32, l_src_len_: i32, p_unk_outer_: ?*IUnknown, dw_cls_context_: u32, piid_: ?*const Guid, pp_dest_m_l_str_: ?*?*IUnknown, pl_dest_pos_: ?*i32, pl_dest_len_: ?*i32) HRESULT {
                return @as(*const IMLangString.VTable, @ptrCast(self.vtable)).GetMLStr(@as(*const IMLangString, @ptrCast(self)), l_src_pos_, l_src_len_, p_unk_outer_, dw_cls_context_, piid_, pp_dest_m_l_str_, pl_dest_pos_, pl_dest_len_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangStringWStr_Value = Guid.initString("c04d65d0-b70d-11d0-b188-00aa0038c969");
pub const IID_IMLangStringWStr = &IID_IMLangStringWStr_Value;
pub const IMLangStringWStr = extern struct {
    pub const VTable = extern struct {
        base: IMLangString.VTable,
        SetWStr: *const fn (
            self: *const IMLangStringWStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            psz_src: [*:0]const u16,
            cch_src: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrBufW: *const fn (
            self: *const IMLangStringWStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            p_src_buf: ?*IMLangStringBufW,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWStr: *const fn (
            self: *const IMLangStringWStr,
            l_src_pos: i32,
            l_src_len: i32,
            psz_dest: ?[*:0]u16,
            cch_dest: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrBufW: *const fn (
            self: *const IMLangStringWStr,
            l_src_pos: i32,
            l_src_max_len: i32,
            pp_dest_buf: ?*?*IMLangStringBufW,
            pl_dest_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockWStr: *const fn (
            self: *const IMLangStringWStr,
            l_src_pos: i32,
            l_src_len: i32,
            l_flags: i32,
            cch_request: i32,
            ppsz_dest: ?*?PWSTR,
            pcch_dest: ?*i32,
            pl_dest_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockWStr: *const fn (
            self: *const IMLangStringWStr,
            psz_src: [*:0]const u16,
            cch_src: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocale: *const fn (
            self: *const IMLangStringWStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            locale: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocale: *const fn (
            self: *const IMLangStringWStr,
            l_src_pos: i32,
            l_src_max_len: i32,
            plocale: ?*u32,
            pl_locale_pos: ?*i32,
            pl_locale_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMLangString.MethodMixin(T);
            pub inline fn setWStr(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, psz_src_: [*:0]const u16, cch_src_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).SetWStr(@as(*const IMLangStringWStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, psz_src_, cch_src_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn setStrBufW(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, p_src_buf_: ?*IMLangStringBufW, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).SetStrBufW(@as(*const IMLangStringWStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, p_src_buf_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn getWStr(self: *const T, l_src_pos_: i32, l_src_len_: i32, psz_dest_: ?[*:0]u16, cch_dest_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).GetWStr(@as(*const IMLangStringWStr, @ptrCast(self)), l_src_pos_, l_src_len_, psz_dest_, cch_dest_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn getStrBufW(self: *const T, l_src_pos_: i32, l_src_max_len_: i32, pp_dest_buf_: ?*?*IMLangStringBufW, pl_dest_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).GetStrBufW(@as(*const IMLangStringWStr, @ptrCast(self)), l_src_pos_, l_src_max_len_, pp_dest_buf_, pl_dest_len_);
            }
            pub inline fn lockWStr(self: *const T, l_src_pos_: i32, l_src_len_: i32, l_flags_: i32, cch_request_: i32, ppsz_dest_: ?*?PWSTR, pcch_dest_: ?*i32, pl_dest_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).LockWStr(@as(*const IMLangStringWStr, @ptrCast(self)), l_src_pos_, l_src_len_, l_flags_, cch_request_, ppsz_dest_, pcch_dest_, pl_dest_len_);
            }
            pub inline fn unlockWStr(self: *const T, psz_src_: [*:0]const u16, cch_src_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).UnlockWStr(@as(*const IMLangStringWStr, @ptrCast(self)), psz_src_, cch_src_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn setLocale(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, locale_: u32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).SetLocale(@as(*const IMLangStringWStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, locale_);
            }
            pub inline fn getLocale(self: *const T, l_src_pos_: i32, l_src_max_len_: i32, plocale_: ?*u32, pl_locale_pos_: ?*i32, pl_locale_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringWStr.VTable, @ptrCast(self.vtable)).GetLocale(@as(*const IMLangStringWStr, @ptrCast(self)), l_src_pos_, l_src_max_len_, plocale_, pl_locale_pos_, pl_locale_len_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangStringAStr_Value = Guid.initString("c04d65d2-b70d-11d0-b188-00aa0038c969");
pub const IID_IMLangStringAStr = &IID_IMLangStringAStr_Value;
pub const IMLangStringAStr = extern struct {
    pub const VTable = extern struct {
        base: IMLangString.VTable,
        SetAStr: *const fn (
            self: *const IMLangStringAStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            u_code_page: u32,
            psz_src: [*:0]const u8,
            cch_src: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrBufA: *const fn (
            self: *const IMLangStringAStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            u_code_page: u32,
            p_src_buf: ?*IMLangStringBufA,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAStr: *const fn (
            self: *const IMLangStringAStr,
            l_src_pos: i32,
            l_src_len: i32,
            u_code_page_in: u32,
            pu_code_page_out: ?*u32,
            psz_dest: ?[*:0]u8,
            cch_dest: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrBufA: *const fn (
            self: *const IMLangStringAStr,
            l_src_pos: i32,
            l_src_max_len: i32,
            pu_dest_code_page: ?*u32,
            pp_dest_buf: ?*?*IMLangStringBufA,
            pl_dest_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockAStr: *const fn (
            self: *const IMLangStringAStr,
            l_src_pos: i32,
            l_src_len: i32,
            l_flags: i32,
            u_code_page_in: u32,
            cch_request: i32,
            pu_code_page_out: ?*u32,
            ppsz_dest: ?*?PSTR,
            pcch_dest: ?*i32,
            pl_dest_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockAStr: *const fn (
            self: *const IMLangStringAStr,
            psz_src: [*:0]const u8,
            cch_src: i32,
            pcch_actual: ?*i32,
            pl_actual_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocale: *const fn (
            self: *const IMLangStringAStr,
            l_dest_pos: i32,
            l_dest_len: i32,
            locale: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocale: *const fn (
            self: *const IMLangStringAStr,
            l_src_pos: i32,
            l_src_max_len: i32,
            plocale: ?*u32,
            pl_locale_pos: ?*i32,
            pl_locale_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMLangString.MethodMixin(T);
            pub inline fn setAStr(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, u_code_page_: u32, psz_src_: [*:0]const u8, cch_src_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).SetAStr(@as(*const IMLangStringAStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, u_code_page_, psz_src_, cch_src_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn setStrBufA(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, u_code_page_: u32, p_src_buf_: ?*IMLangStringBufA, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).SetStrBufA(@as(*const IMLangStringAStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, u_code_page_, p_src_buf_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn getAStr(self: *const T, l_src_pos_: i32, l_src_len_: i32, u_code_page_in_: u32, pu_code_page_out_: ?*u32, psz_dest_: ?[*:0]u8, cch_dest_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).GetAStr(@as(*const IMLangStringAStr, @ptrCast(self)), l_src_pos_, l_src_len_, u_code_page_in_, pu_code_page_out_, psz_dest_, cch_dest_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn getStrBufA(self: *const T, l_src_pos_: i32, l_src_max_len_: i32, pu_dest_code_page_: ?*u32, pp_dest_buf_: ?*?*IMLangStringBufA, pl_dest_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).GetStrBufA(@as(*const IMLangStringAStr, @ptrCast(self)), l_src_pos_, l_src_max_len_, pu_dest_code_page_, pp_dest_buf_, pl_dest_len_);
            }
            pub inline fn lockAStr(self: *const T, l_src_pos_: i32, l_src_len_: i32, l_flags_: i32, u_code_page_in_: u32, cch_request_: i32, pu_code_page_out_: ?*u32, ppsz_dest_: ?*?PSTR, pcch_dest_: ?*i32, pl_dest_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).LockAStr(@as(*const IMLangStringAStr, @ptrCast(self)), l_src_pos_, l_src_len_, l_flags_, u_code_page_in_, cch_request_, pu_code_page_out_, ppsz_dest_, pcch_dest_, pl_dest_len_);
            }
            pub inline fn unlockAStr(self: *const T, psz_src_: [*:0]const u8, cch_src_: i32, pcch_actual_: ?*i32, pl_actual_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).UnlockAStr(@as(*const IMLangStringAStr, @ptrCast(self)), psz_src_, cch_src_, pcch_actual_, pl_actual_len_);
            }
            pub inline fn setLocale(self: *const T, l_dest_pos_: i32, l_dest_len_: i32, locale_: u32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).SetLocale(@as(*const IMLangStringAStr, @ptrCast(self)), l_dest_pos_, l_dest_len_, locale_);
            }
            pub inline fn getLocale(self: *const T, l_src_pos_: i32, l_src_max_len_: i32, plocale_: ?*u32, pl_locale_pos_: ?*i32, pl_locale_len_: ?*i32) HRESULT {
                return @as(*const IMLangStringAStr.VTable, @ptrCast(self.vtable)).GetLocale(@as(*const IMLangStringAStr, @ptrCast(self)), l_src_pos_, l_src_max_len_, plocale_, pl_locale_pos_, pl_locale_len_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangLineBreakConsole_Value = Guid.initString("f5be2ee1-bfd7-11d0-b188-00aa0038c969");
pub const IID_IMLangLineBreakConsole = &IID_IMLangLineBreakConsole_Value;
pub const IMLangLineBreakConsole = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BreakLineML: *const fn (
            self: *const IMLangLineBreakConsole,
            p_src_m_l_str: ?*IMLangString,
            l_src_pos: i32,
            l_src_len: i32,
            c_min_columns: i32,
            c_max_columns: i32,
            pl_line_len: ?*i32,
            pl_skip_len: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BreakLineW: *const fn (
            self: *const IMLangLineBreakConsole,
            locale: u32,
            psz_src: [*:0]const u16,
            cch_src: i32,
            c_max_columns: i32,
            pcch_line: ?*i32,
            pcch_skip: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BreakLineA: *const fn (
            self: *const IMLangLineBreakConsole,
            locale: u32,
            u_code_page: u32,
            psz_src: [*:0]const u8,
            cch_src: i32,
            c_max_columns: i32,
            pcch_line: ?*i32,
            pcch_skip: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn breakLineML(self: *const T, p_src_m_l_str_: ?*IMLangString, l_src_pos_: i32, l_src_len_: i32, c_min_columns_: i32, c_max_columns_: i32, pl_line_len_: ?*i32, pl_skip_len_: ?*i32) HRESULT {
                return @as(*const IMLangLineBreakConsole.VTable, @ptrCast(self.vtable)).BreakLineML(@as(*const IMLangLineBreakConsole, @ptrCast(self)), p_src_m_l_str_, l_src_pos_, l_src_len_, c_min_columns_, c_max_columns_, pl_line_len_, pl_skip_len_);
            }
            pub inline fn breakLineW(self: *const T, locale_: u32, psz_src_: [*:0]const u16, cch_src_: i32, c_max_columns_: i32, pcch_line_: ?*i32, pcch_skip_: ?*i32) HRESULT {
                return @as(*const IMLangLineBreakConsole.VTable, @ptrCast(self.vtable)).BreakLineW(@as(*const IMLangLineBreakConsole, @ptrCast(self)), locale_, psz_src_, cch_src_, c_max_columns_, pcch_line_, pcch_skip_);
            }
            pub inline fn breakLineA(self: *const T, locale_: u32, u_code_page_: u32, psz_src_: [*:0]const u8, cch_src_: i32, c_max_columns_: i32, pcch_line_: ?*i32, pcch_skip_: ?*i32) HRESULT {
                return @as(*const IMLangLineBreakConsole.VTable, @ptrCast(self.vtable)).BreakLineA(@as(*const IMLangLineBreakConsole, @ptrCast(self)), locale_, u_code_page_, psz_src_, cch_src_, c_max_columns_, pcch_line_, pcch_skip_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MIMECONTF = enum(i32) {
    MAILNEWS = 1,
    BROWSER = 2,
    MINIMAL = 4,
    IMPORT = 8,
    SAVABLE_MAILNEWS = 256,
    SAVABLE_BROWSER = 512,
    EXPORT = 1024,
    PRIVCONVERTER = 65536,
    VALID = 131072,
    VALID_NLS = 262144,
    MIME_IE4 = 268435456,
    MIME_LATEST = 536870912,
    MIME_REGISTRY = 1073741824,
};
pub const MIMECONTF_MAILNEWS = MIMECONTF.MAILNEWS;
pub const MIMECONTF_BROWSER = MIMECONTF.BROWSER;
pub const MIMECONTF_MINIMAL = MIMECONTF.MINIMAL;
pub const MIMECONTF_IMPORT = MIMECONTF.IMPORT;
pub const MIMECONTF_SAVABLE_MAILNEWS = MIMECONTF.SAVABLE_MAILNEWS;
pub const MIMECONTF_SAVABLE_BROWSER = MIMECONTF.SAVABLE_BROWSER;
pub const MIMECONTF_EXPORT = MIMECONTF.EXPORT;
pub const MIMECONTF_PRIVCONVERTER = MIMECONTF.PRIVCONVERTER;
pub const MIMECONTF_VALID = MIMECONTF.VALID;
pub const MIMECONTF_VALID_NLS = MIMECONTF.VALID_NLS;
pub const MIMECONTF_MIME_IE4 = MIMECONTF.MIME_IE4;
pub const MIMECONTF_MIME_LATEST = MIMECONTF.MIME_LATEST;
pub const MIMECONTF_MIME_REGISTRY = MIMECONTF.MIME_REGISTRY;

pub const MIMECPINFO = extern struct {
    dwFlags: u32,
    uiCodePage: u32,
    uiFamilyCodePage: u32,
    wszDescription: [64]u16,
    wszWebCharset: [50]u16,
    wszHeaderCharset: [50]u16,
    wszBodyCharset: [50]u16,
    wszFixedWidthFont: [32]u16,
    wszProportionalFont: [32]u16,
    bGDICharset: u8,
};

pub const MIMECSETINFO = extern struct {
    uiCodePage: u32,
    uiInternetEncoding: u32,
    wszCharset: [50]u16,
};

const IID_IEnumCodePage_Value = Guid.initString("275c23e3-3747-11d0-9fea-00aa003f8646");
pub const IID_IEnumCodePage = &IID_IEnumCodePage_Value;
pub const IEnumCodePage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumCodePage,
            pp_enum: ?*?*IEnumCodePage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumCodePage,
            celt: u32,
            rgelt: ?*MIMECPINFO,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumCodePage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumCodePage,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumCodePage) HRESULT {
                return @as(*const IEnumCodePage.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCodePage, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, celt_: u32, rgelt_: ?*MIMECPINFO, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumCodePage.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCodePage, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumCodePage.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCodePage, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumCodePage.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCodePage, @ptrCast(self)), celt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RFC1766INFO = extern struct {
    lcid: u32,
    wszRfc1766: [6]u16,
    wszLocaleName: [32]u16,
};

const IID_IEnumRfc1766_Value = Guid.initString("3dc39d1d-c030-11d0-b81b-00c04fc9b31f");
pub const IID_IEnumRfc1766 = &IID_IEnumRfc1766_Value;
pub const IEnumRfc1766 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumRfc1766,
            pp_enum: ?*?*IEnumRfc1766,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumRfc1766,
            celt: u32,
            rgelt: ?*RFC1766INFO,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumRfc1766,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumRfc1766,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumRfc1766) HRESULT {
                return @as(*const IEnumRfc1766.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRfc1766, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, celt_: u32, rgelt_: ?*RFC1766INFO, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumRfc1766.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRfc1766, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumRfc1766.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRfc1766, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumRfc1766.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRfc1766, @ptrCast(self)), celt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPTCONTF = enum(i32) {
    Default = 0,
    Merge = 1,
    AsciiSym = 2,
    AsciiLatin = 3,
    Latin = 4,
    Greek = 5,
    Cyrillic = 6,
    Armenian = 7,
    Hebrew = 8,
    Arabic = 9,
    Devanagari = 10,
    Bengali = 11,
    Gurmukhi = 12,
    Gujarati = 13,
    Oriya = 14,
    Tamil = 15,
    Telugu = 16,
    Kannada = 17,
    Malayalam = 18,
    Thai = 19,
    Lao = 20,
    Tibetan = 21,
    Georgian = 22,
    Hangul = 23,
    Kana = 24,
    Bopomofo = 25,
    Han = 26,
    Ethiopic = 27,
    CanSyllabic = 28,
    Cherokee = 29,
    Yi = 30,
    Braille = 31,
    Runic = 32,
    Ogham = 33,
    Sinhala = 34,
    Syriac = 35,
    Burmese = 36,
    Khmer = 37,
    Thaana = 38,
    Mongolian = 39,
    UserDefined = 40,
    Lim = 41,
    // FEFirst = 23, this enum value conflicts with Hangul
    // FELast = 26, this enum value conflicts with Han
};
pub const sidDefault = SCRIPTCONTF.Default;
pub const sidMerge = SCRIPTCONTF.Merge;
pub const sidAsciiSym = SCRIPTCONTF.AsciiSym;
pub const sidAsciiLatin = SCRIPTCONTF.AsciiLatin;
pub const sidLatin = SCRIPTCONTF.Latin;
pub const sidGreek = SCRIPTCONTF.Greek;
pub const sidCyrillic = SCRIPTCONTF.Cyrillic;
pub const sidArmenian = SCRIPTCONTF.Armenian;
pub const sidHebrew = SCRIPTCONTF.Hebrew;
pub const sidArabic = SCRIPTCONTF.Arabic;
pub const sidDevanagari = SCRIPTCONTF.Devanagari;
pub const sidBengali = SCRIPTCONTF.Bengali;
pub const sidGurmukhi = SCRIPTCONTF.Gurmukhi;
pub const sidGujarati = SCRIPTCONTF.Gujarati;
pub const sidOriya = SCRIPTCONTF.Oriya;
pub const sidTamil = SCRIPTCONTF.Tamil;
pub const sidTelugu = SCRIPTCONTF.Telugu;
pub const sidKannada = SCRIPTCONTF.Kannada;
pub const sidMalayalam = SCRIPTCONTF.Malayalam;
pub const sidThai = SCRIPTCONTF.Thai;
pub const sidLao = SCRIPTCONTF.Lao;
pub const sidTibetan = SCRIPTCONTF.Tibetan;
pub const sidGeorgian = SCRIPTCONTF.Georgian;
pub const sidHangul = SCRIPTCONTF.Hangul;
pub const sidKana = SCRIPTCONTF.Kana;
pub const sidBopomofo = SCRIPTCONTF.Bopomofo;
pub const sidHan = SCRIPTCONTF.Han;
pub const sidEthiopic = SCRIPTCONTF.Ethiopic;
pub const sidCanSyllabic = SCRIPTCONTF.CanSyllabic;
pub const sidCherokee = SCRIPTCONTF.Cherokee;
pub const sidYi = SCRIPTCONTF.Yi;
pub const sidBraille = SCRIPTCONTF.Braille;
pub const sidRunic = SCRIPTCONTF.Runic;
pub const sidOgham = SCRIPTCONTF.Ogham;
pub const sidSinhala = SCRIPTCONTF.Sinhala;
pub const sidSyriac = SCRIPTCONTF.Syriac;
pub const sidBurmese = SCRIPTCONTF.Burmese;
pub const sidKhmer = SCRIPTCONTF.Khmer;
pub const sidThaana = SCRIPTCONTF.Thaana;
pub const sidMongolian = SCRIPTCONTF.Mongolian;
pub const sidUserDefined = SCRIPTCONTF.UserDefined;
pub const sidLim = SCRIPTCONTF.Lim;
pub const sidFEFirst = SCRIPTCONTF.Hangul;
pub const sidFELast = SCRIPTCONTF.Han;

pub const SCRIPTINFO = extern struct {
    ScriptId: u8,
    uiCodePage: u32,
    wszDescription: [48]u16,
    wszFixedWidthFont: [32]u16,
    wszProportionalFont: [32]u16,
};

const IID_IEnumScript_Value = Guid.initString("ae5f1430-388b-11d2-8380-00c04f8f5da1");
pub const IID_IEnumScript = &IID_IEnumScript_Value;
pub const IEnumScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: *const fn (
            self: *const IEnumScript,
            pp_enum: ?*?*IEnumScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IEnumScript,
            celt: u32,
            rgelt: ?*SCRIPTINFO,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumScript,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumScript) HRESULT {
                return @as(*const IEnumScript.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumScript, @ptrCast(self)), pp_enum_);
            }
            pub inline fn next(self: *const T, celt_: u32, rgelt_: ?*SCRIPTINFO, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumScript.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumScript, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumScript.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumScript, @ptrCast(self)));
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumScript.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumScript, @ptrCast(self)), celt_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const tagMLCONVCHARF = enum(i32) {
    AUTODETECT = 1,
    ENTITIZE = 2,
    // NCR_ENTITIZE = 2, this enum value conflicts with ENTITIZE
    NAME_ENTITIZE = 4,
    USEDEFCHAR = 8,
    NOBESTFITCHARS = 16,
    DETECTJPN = 32,
};
pub const MLCONVCHARF_AUTODETECT = tagMLCONVCHARF.AUTODETECT;
pub const MLCONVCHARF_ENTITIZE = tagMLCONVCHARF.ENTITIZE;
pub const MLCONVCHARF_NCR_ENTITIZE = tagMLCONVCHARF.ENTITIZE;
pub const MLCONVCHARF_NAME_ENTITIZE = tagMLCONVCHARF.NAME_ENTITIZE;
pub const MLCONVCHARF_USEDEFCHAR = tagMLCONVCHARF.USEDEFCHAR;
pub const MLCONVCHARF_NOBESTFITCHARS = tagMLCONVCHARF.NOBESTFITCHARS;
pub const MLCONVCHARF_DETECTJPN = tagMLCONVCHARF.DETECTJPN;

pub const tagMLCPF = enum(i32) {
    MAILNEWS = 1,
    BROWSER = 2,
    VALID = 4,
    VALID_NLS = 8,
    PRESERVE_ORDER = 16,
    PREFERRED_ONLY = 32,
    FILTER_SPECIALCHAR = 64,
    EURO_UTF8 = 128,
};
pub const MLDETECTF_MAILNEWS = tagMLCPF.MAILNEWS;
pub const MLDETECTF_BROWSER = tagMLCPF.BROWSER;
pub const MLDETECTF_VALID = tagMLCPF.VALID;
pub const MLDETECTF_VALID_NLS = tagMLCPF.VALID_NLS;
pub const MLDETECTF_PRESERVE_ORDER = tagMLCPF.PRESERVE_ORDER;
pub const MLDETECTF_PREFERRED_ONLY = tagMLCPF.PREFERRED_ONLY;
pub const MLDETECTF_FILTER_SPECIALCHAR = tagMLCPF.FILTER_SPECIALCHAR;
pub const MLDETECTF_EURO_UTF8 = tagMLCPF.EURO_UTF8;

const IID_IMLangConvertCharset_Value = Guid.initString("d66d6f98-cdaa-11d0-b822-00c04fc9b31f");
pub const IID_IMLangConvertCharset = &IID_IMLangConvertCharset_Value;
pub const IMLangConvertCharset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn (
            self: *const IMLangConvertCharset,
            ui_src_code_page: u32,
            ui_dst_code_page: u32,
            dw_property: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceCodePage: *const fn (
            self: *const IMLangConvertCharset,
            pui_src_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestinationCodePage: *const fn (
            self: *const IMLangConvertCharset,
            pui_dst_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn (
            self: *const IMLangConvertCharset,
            pdw_property: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoConversion: *const fn (
            self: *const IMLangConvertCharset,
            // TODO: what to do with BytesParamIndex 1?
            p_src_str: ?*u8,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 3?
            p_dst_str: ?*u8,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoConversionToUnicode: *const fn (
            self: *const IMLangConvertCharset,
            // TODO: what to do with BytesParamIndex 1?
            p_src_str: ?PSTR,
            pc_src_size: ?*u32,
            p_dst_str: [*:0]u16,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoConversionFromUnicode: *const fn (
            self: *const IMLangConvertCharset,
            p_src_str: [*:0]u16,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 3?
            p_dst_str: ?PSTR,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initialize(self: *const T, ui_src_code_page_: u32, ui_dst_code_page_: u32, dw_property_: u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMLangConvertCharset, @ptrCast(self)), ui_src_code_page_, ui_dst_code_page_, dw_property_);
            }
            pub inline fn getSourceCodePage(self: *const T, pui_src_code_page_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).GetSourceCodePage(@as(*const IMLangConvertCharset, @ptrCast(self)), pui_src_code_page_);
            }
            pub inline fn getDestinationCodePage(self: *const T, pui_dst_code_page_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).GetDestinationCodePage(@as(*const IMLangConvertCharset, @ptrCast(self)), pui_dst_code_page_);
            }
            pub inline fn getProperty(self: *const T, pdw_property_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IMLangConvertCharset, @ptrCast(self)), pdw_property_);
            }
            pub inline fn doConversion(self: *const T, p_src_str_: ?*u8, pc_src_size_: ?*u32, p_dst_str_: ?*u8, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).DoConversion(@as(*const IMLangConvertCharset, @ptrCast(self)), p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn doConversionToUnicode(self: *const T, p_src_str_: ?PSTR, pc_src_size_: ?*u32, p_dst_str_: [*:0]u16, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).DoConversionToUnicode(@as(*const IMLangConvertCharset, @ptrCast(self)), p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn doConversionFromUnicode(self: *const T, p_src_str_: [*:0]u16, pc_src_size_: ?*u32, p_dst_str_: ?PSTR, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMLangConvertCharset.VTable, @ptrCast(self.vtable)).DoConversionFromUnicode(@as(*const IMLangConvertCharset, @ptrCast(self)), p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMultiLanguage_Value = Guid.initString("275c23e1-3747-11d0-9fea-00aa003f8646");
pub const IID_IMultiLanguage = &IID_IMultiLanguage_Value;
pub const IMultiLanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfCodePageInfo: *const fn (
            self: *const IMultiLanguage,
            pc_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageInfo: *const fn (
            self: *const IMultiLanguage,
            ui_code_page: u32,
            p_code_page_info: ?*MIMECPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFamilyCodePage: *const fn (
            self: *const IMultiLanguage,
            ui_code_page: u32,
            pui_family_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodePages: *const fn (
            self: *const IMultiLanguage,
            grf_flags: u32,
            pp_enum_code_page: ?*?*IEnumCodePage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharsetInfo: *const fn (
            self: *const IMultiLanguage,
            charset: ?BSTR,
            p_charset_info: ?*MIMECSETINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConvertible: *const fn (
            self: *const IMultiLanguage,
            dw_src_encoding: u32,
            dw_dst_encoding: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertString: *const fn (
            self: *const IMultiLanguage,
            pdw_mode: ?*u32,
            dw_src_encoding: u32,
            dw_dst_encoding: u32,
            // TODO: what to do with BytesParamIndex 4?
            p_src_str: ?*u8,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 6?
            p_dst_str: ?*u8,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringToUnicode: *const fn (
            self: *const IMultiLanguage,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            // TODO: what to do with BytesParamIndex 3?
            p_src_str: ?PSTR,
            pc_src_size: ?*u32,
            p_dst_str: ?[*:0]u16,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringFromUnicode: *const fn (
            self: *const IMultiLanguage,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            p_src_str: ?[*:0]u16,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 5?
            p_dst_str: ?PSTR,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringReset: *const fn (
            self: *const IMultiLanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRfc1766FromLcid: *const fn (
            self: *const IMultiLanguage,
            locale: u32,
            pbstr_rfc1766: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLcidFromRfc1766: *const fn (
            self: *const IMultiLanguage,
            p_locale: ?*u32,
            bstr_rfc1766: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRfc1766: *const fn (
            self: *const IMultiLanguage,
            pp_enum_rfc1766: ?*?*IEnumRfc1766,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRfc1766Info: *const fn (
            self: *const IMultiLanguage,
            locale: u32,
            p_rfc1766_info: ?*RFC1766INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConvertCharset: *const fn (
            self: *const IMultiLanguage,
            ui_src_code_page: u32,
            ui_dst_code_page: u32,
            dw_property: u32,
            pp_m_lang_convert_charset: ?*?*IMLangConvertCharset,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumberOfCodePageInfo(self: *const T, pc_code_page_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetNumberOfCodePageInfo(@as(*const IMultiLanguage, @ptrCast(self)), pc_code_page_);
            }
            pub inline fn getCodePageInfo(self: *const T, ui_code_page_: u32, p_code_page_info_: ?*MIMECPINFO) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetCodePageInfo(@as(*const IMultiLanguage, @ptrCast(self)), ui_code_page_, p_code_page_info_);
            }
            pub inline fn getFamilyCodePage(self: *const T, ui_code_page_: u32, pui_family_code_page_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetFamilyCodePage(@as(*const IMultiLanguage, @ptrCast(self)), ui_code_page_, pui_family_code_page_);
            }
            pub inline fn enumCodePages(self: *const T, grf_flags_: u32, pp_enum_code_page_: ?*?*IEnumCodePage) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).EnumCodePages(@as(*const IMultiLanguage, @ptrCast(self)), grf_flags_, pp_enum_code_page_);
            }
            pub inline fn getCharsetInfo(self: *const T, charset_: ?BSTR, p_charset_info_: ?*MIMECSETINFO) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetCharsetInfo(@as(*const IMultiLanguage, @ptrCast(self)), charset_, p_charset_info_);
            }
            pub inline fn isConvertible(self: *const T, dw_src_encoding_: u32, dw_dst_encoding_: u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).IsConvertible(@as(*const IMultiLanguage, @ptrCast(self)), dw_src_encoding_, dw_dst_encoding_);
            }
            pub inline fn convertString(self: *const T, pdw_mode_: ?*u32, dw_src_encoding_: u32, dw_dst_encoding_: u32, p_src_str_: ?*u8, pc_src_size_: ?*u32, p_dst_str_: ?*u8, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).ConvertString(@as(*const IMultiLanguage, @ptrCast(self)), pdw_mode_, dw_src_encoding_, dw_dst_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringToUnicode(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: ?PSTR, pc_src_size_: ?*u32, p_dst_str_: ?[*:0]u16, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).ConvertStringToUnicode(@as(*const IMultiLanguage, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringFromUnicode(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: ?[*:0]u16, pc_src_size_: ?*u32, p_dst_str_: ?PSTR, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).ConvertStringFromUnicode(@as(*const IMultiLanguage, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringReset(self: *const T) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).ConvertStringReset(@as(*const IMultiLanguage, @ptrCast(self)));
            }
            pub inline fn getRfc1766FromLcid(self: *const T, locale_: u32, pbstr_rfc1766_: ?*?BSTR) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetRfc1766FromLcid(@as(*const IMultiLanguage, @ptrCast(self)), locale_, pbstr_rfc1766_);
            }
            pub inline fn getLcidFromRfc1766(self: *const T, p_locale_: ?*u32, bstr_rfc1766_: ?BSTR) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetLcidFromRfc1766(@as(*const IMultiLanguage, @ptrCast(self)), p_locale_, bstr_rfc1766_);
            }
            pub inline fn enumRfc1766(self: *const T, pp_enum_rfc1766_: ?*?*IEnumRfc1766) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).EnumRfc1766(@as(*const IMultiLanguage, @ptrCast(self)), pp_enum_rfc1766_);
            }
            pub inline fn getRfc1766Info(self: *const T, locale_: u32, p_rfc1766_info_: ?*RFC1766INFO) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).GetRfc1766Info(@as(*const IMultiLanguage, @ptrCast(self)), locale_, p_rfc1766_info_);
            }
            pub inline fn createConvertCharset(self: *const T, ui_src_code_page_: u32, ui_dst_code_page_: u32, dw_property_: u32, pp_m_lang_convert_charset_: ?*?*IMLangConvertCharset) HRESULT {
                return @as(*const IMultiLanguage.VTable, @ptrCast(self.vtable)).CreateConvertCharset(@as(*const IMultiLanguage, @ptrCast(self)), ui_src_code_page_, ui_dst_code_page_, dw_property_, pp_m_lang_convert_charset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MLDETECTCP = enum(i32) {
    NONE = 0,
    @"7BIT" = 1,
    @"8BIT" = 2,
    DBCS = 4,
    HTML = 8,
    NUMBER = 16,
};
pub const MLDETECTCP_NONE = MLDETECTCP.NONE;
pub const MLDETECTCP_7BIT = MLDETECTCP.@"7BIT";
pub const MLDETECTCP_8BIT = MLDETECTCP.@"8BIT";
pub const MLDETECTCP_DBCS = MLDETECTCP.DBCS;
pub const MLDETECTCP_HTML = MLDETECTCP.HTML;
pub const MLDETECTCP_NUMBER = MLDETECTCP.NUMBER;

pub const DetectEncodingInfo = extern struct {
    nLangID: u32,
    nCodePage: u32,
    nDocPercent: i32,
    nConfidence: i32,
};

pub const SCRIPTFONTCONTF = enum(i32) {
    FIXED_FONT = 1,
    PROPORTIONAL_FONT = 2,
    SCRIPT_USER = 65536,
    SCRIPT_HIDE = 131072,
    SCRIPT_SYSTEM = 262144,
};
pub const SCRIPTCONTF_FIXED_FONT = SCRIPTFONTCONTF.FIXED_FONT;
pub const SCRIPTCONTF_PROPORTIONAL_FONT = SCRIPTFONTCONTF.PROPORTIONAL_FONT;
pub const SCRIPTCONTF_SCRIPT_USER = SCRIPTFONTCONTF.SCRIPT_USER;
pub const SCRIPTCONTF_SCRIPT_HIDE = SCRIPTFONTCONTF.SCRIPT_HIDE;
pub const SCRIPTCONTF_SCRIPT_SYSTEM = SCRIPTFONTCONTF.SCRIPT_SYSTEM;

pub const tagSCRIPFONTINFO = extern struct {
    scripts: i64,
    wszFont: [32]u16,
};

const IID_IMultiLanguage2_Value = Guid.initString("dccfc164-2b38-11d2-b7ec-00c04f8f5d9a");
pub const IID_IMultiLanguage2 = &IID_IMultiLanguage2_Value;
pub const IMultiLanguage2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfCodePageInfo: *const fn (
            self: *const IMultiLanguage2,
            pc_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageInfo: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
            lang_id: u16,
            p_code_page_info: ?*MIMECPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFamilyCodePage: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
            pui_family_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodePages: *const fn (
            self: *const IMultiLanguage2,
            grf_flags: u32,
            lang_id: u16,
            pp_enum_code_page: ?*?*IEnumCodePage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharsetInfo: *const fn (
            self: *const IMultiLanguage2,
            charset: ?BSTR,
            p_charset_info: ?*MIMECSETINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConvertible: *const fn (
            self: *const IMultiLanguage2,
            dw_src_encoding: u32,
            dw_dst_encoding: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertString: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_src_encoding: u32,
            dw_dst_encoding: u32,
            // TODO: what to do with BytesParamIndex 4?
            p_src_str: ?*u8,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 6?
            p_dst_str: ?*u8,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringToUnicode: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            // TODO: what to do with BytesParamIndex 3?
            p_src_str: ?PSTR,
            pc_src_size: ?*u32,
            p_dst_str: ?[*:0]u16,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringFromUnicode: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            p_src_str: ?[*:0]u16,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 5?
            p_dst_str: ?PSTR,
            pc_dst_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringReset: *const fn (
            self: *const IMultiLanguage2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRfc1766FromLcid: *const fn (
            self: *const IMultiLanguage2,
            locale: u32,
            pbstr_rfc1766: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLcidFromRfc1766: *const fn (
            self: *const IMultiLanguage2,
            p_locale: ?*u32,
            bstr_rfc1766: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRfc1766: *const fn (
            self: *const IMultiLanguage2,
            lang_id: u16,
            pp_enum_rfc1766: ?*?*IEnumRfc1766,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRfc1766Info: *const fn (
            self: *const IMultiLanguage2,
            locale: u32,
            lang_id: u16,
            p_rfc1766_info: ?*RFC1766INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConvertCharset: *const fn (
            self: *const IMultiLanguage2,
            ui_src_code_page: u32,
            ui_dst_code_page: u32,
            dw_property: u32,
            pp_m_lang_convert_charset: ?*?*IMLangConvertCharset,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringInIStream: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_flag: u32,
            lp_fall_back: ?PWSTR,
            dw_src_encoding: u32,
            dw_dst_encoding: u32,
            pstm_in: ?*IStream,
            pstm_out: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringToUnicodeEx: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            // TODO: what to do with BytesParamIndex 3?
            p_src_str: ?PSTR,
            pc_src_size: ?*u32,
            p_dst_str: [*:0]u16,
            pc_dst_size: ?*u32,
            dw_flag: u32,
            lp_fall_back: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertStringFromUnicodeEx: *const fn (
            self: *const IMultiLanguage2,
            pdw_mode: ?*u32,
            dw_encoding: u32,
            p_src_str: [*:0]u16,
            pc_src_size: ?*u32,
            // TODO: what to do with BytesParamIndex 5?
            p_dst_str: ?PSTR,
            pc_dst_size: ?*u32,
            dw_flag: u32,
            lp_fall_back: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetectCodepageInIStream: *const fn (
            self: *const IMultiLanguage2,
            dw_flag: u32,
            dw_pref_win_code_page: u32,
            pstm_in: ?*IStream,
            lp_encoding: ?*DetectEncodingInfo,
            pn_scores: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetectInputCodepage: *const fn (
            self: *const IMultiLanguage2,
            dw_flag: u32,
            dw_pref_win_code_page: u32,
            // TODO: what to do with BytesParamIndex 3?
            p_src_str: ?PSTR,
            pc_src_size: ?*i32,
            lp_encoding: ?*DetectEncodingInfo,
            pn_scores: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateCodePage: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageDescription: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
            lcid: u32,
            lp_wide_char_str: [*:0]u16,
            cch_wide_char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCodePageInstallable: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMimeDBSource: *const fn (
            self: *const IMultiLanguage2,
            dw_source: MIMECONTF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfScripts: *const fn (
            self: *const IMultiLanguage2,
            pn_scripts: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumScripts: *const fn (
            self: *const IMultiLanguage2,
            dw_flags: u32,
            lang_id: u16,
            pp_enum_script: ?*?*IEnumScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateCodePageEx: *const fn (
            self: *const IMultiLanguage2,
            ui_code_page: u32,
            hwnd: ?HWND,
            dwf_i_o_d_control: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getNumberOfCodePageInfo(self: *const T, pc_code_page_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetNumberOfCodePageInfo(@as(*const IMultiLanguage2, @ptrCast(self)), pc_code_page_);
            }
            pub inline fn getCodePageInfo(self: *const T, ui_code_page_: u32, lang_id_: u16, p_code_page_info_: ?*MIMECPINFO) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetCodePageInfo(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_, lang_id_, p_code_page_info_);
            }
            pub inline fn getFamilyCodePage(self: *const T, ui_code_page_: u32, pui_family_code_page_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetFamilyCodePage(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_, pui_family_code_page_);
            }
            pub inline fn enumCodePages(self: *const T, grf_flags_: u32, lang_id_: u16, pp_enum_code_page_: ?*?*IEnumCodePage) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).EnumCodePages(@as(*const IMultiLanguage2, @ptrCast(self)), grf_flags_, lang_id_, pp_enum_code_page_);
            }
            pub inline fn getCharsetInfo(self: *const T, charset_: ?BSTR, p_charset_info_: ?*MIMECSETINFO) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetCharsetInfo(@as(*const IMultiLanguage2, @ptrCast(self)), charset_, p_charset_info_);
            }
            pub inline fn isConvertible(self: *const T, dw_src_encoding_: u32, dw_dst_encoding_: u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).IsConvertible(@as(*const IMultiLanguage2, @ptrCast(self)), dw_src_encoding_, dw_dst_encoding_);
            }
            pub inline fn convertString(self: *const T, pdw_mode_: ?*u32, dw_src_encoding_: u32, dw_dst_encoding_: u32, p_src_str_: ?*u8, pc_src_size_: ?*u32, p_dst_str_: ?*u8, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertString(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_src_encoding_, dw_dst_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringToUnicode(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: ?PSTR, pc_src_size_: ?*u32, p_dst_str_: ?[*:0]u16, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringToUnicode(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringFromUnicode(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: ?[*:0]u16, pc_src_size_: ?*u32, p_dst_str_: ?PSTR, pc_dst_size_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringFromUnicode(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_);
            }
            pub inline fn convertStringReset(self: *const T) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringReset(@as(*const IMultiLanguage2, @ptrCast(self)));
            }
            pub inline fn getRfc1766FromLcid(self: *const T, locale_: u32, pbstr_rfc1766_: ?*?BSTR) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetRfc1766FromLcid(@as(*const IMultiLanguage2, @ptrCast(self)), locale_, pbstr_rfc1766_);
            }
            pub inline fn getLcidFromRfc1766(self: *const T, p_locale_: ?*u32, bstr_rfc1766_: ?BSTR) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetLcidFromRfc1766(@as(*const IMultiLanguage2, @ptrCast(self)), p_locale_, bstr_rfc1766_);
            }
            pub inline fn enumRfc1766(self: *const T, lang_id_: u16, pp_enum_rfc1766_: ?*?*IEnumRfc1766) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).EnumRfc1766(@as(*const IMultiLanguage2, @ptrCast(self)), lang_id_, pp_enum_rfc1766_);
            }
            pub inline fn getRfc1766Info(self: *const T, locale_: u32, lang_id_: u16, p_rfc1766_info_: ?*RFC1766INFO) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetRfc1766Info(@as(*const IMultiLanguage2, @ptrCast(self)), locale_, lang_id_, p_rfc1766_info_);
            }
            pub inline fn createConvertCharset(self: *const T, ui_src_code_page_: u32, ui_dst_code_page_: u32, dw_property_: u32, pp_m_lang_convert_charset_: ?*?*IMLangConvertCharset) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).CreateConvertCharset(@as(*const IMultiLanguage2, @ptrCast(self)), ui_src_code_page_, ui_dst_code_page_, dw_property_, pp_m_lang_convert_charset_);
            }
            pub inline fn convertStringInIStream(self: *const T, pdw_mode_: ?*u32, dw_flag_: u32, lp_fall_back_: ?PWSTR, dw_src_encoding_: u32, dw_dst_encoding_: u32, pstm_in_: ?*IStream, pstm_out_: ?*IStream) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringInIStream(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_flag_, lp_fall_back_, dw_src_encoding_, dw_dst_encoding_, pstm_in_, pstm_out_);
            }
            pub inline fn convertStringToUnicodeEx(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: ?PSTR, pc_src_size_: ?*u32, p_dst_str_: [*:0]u16, pc_dst_size_: ?*u32, dw_flag_: u32, lp_fall_back_: ?PWSTR) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringToUnicodeEx(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_, dw_flag_, lp_fall_back_);
            }
            pub inline fn convertStringFromUnicodeEx(self: *const T, pdw_mode_: ?*u32, dw_encoding_: u32, p_src_str_: [*:0]u16, pc_src_size_: ?*u32, p_dst_str_: ?PSTR, pc_dst_size_: ?*u32, dw_flag_: u32, lp_fall_back_: ?PWSTR) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ConvertStringFromUnicodeEx(@as(*const IMultiLanguage2, @ptrCast(self)), pdw_mode_, dw_encoding_, p_src_str_, pc_src_size_, p_dst_str_, pc_dst_size_, dw_flag_, lp_fall_back_);
            }
            pub inline fn detectCodepageInIStream(self: *const T, dw_flag_: u32, dw_pref_win_code_page_: u32, pstm_in_: ?*IStream, lp_encoding_: ?*DetectEncodingInfo, pn_scores_: ?*i32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).DetectCodepageInIStream(@as(*const IMultiLanguage2, @ptrCast(self)), dw_flag_, dw_pref_win_code_page_, pstm_in_, lp_encoding_, pn_scores_);
            }
            pub inline fn detectInputCodepage(self: *const T, dw_flag_: u32, dw_pref_win_code_page_: u32, p_src_str_: ?PSTR, pc_src_size_: ?*i32, lp_encoding_: ?*DetectEncodingInfo, pn_scores_: ?*i32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).DetectInputCodepage(@as(*const IMultiLanguage2, @ptrCast(self)), dw_flag_, dw_pref_win_code_page_, p_src_str_, pc_src_size_, lp_encoding_, pn_scores_);
            }
            pub inline fn validateCodePage(self: *const T, ui_code_page_: u32, hwnd_: ?HWND) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ValidateCodePage(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_, hwnd_);
            }
            pub inline fn getCodePageDescription(self: *const T, ui_code_page_: u32, lcid_: u32, lp_wide_char_str_: [*:0]u16, cch_wide_char_: i32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetCodePageDescription(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_, lcid_, lp_wide_char_str_, cch_wide_char_);
            }
            pub inline fn isCodePageInstallable(self: *const T, ui_code_page_: u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).IsCodePageInstallable(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_);
            }
            pub inline fn setMimeDBSource(self: *const T, dw_source_: MIMECONTF) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).SetMimeDBSource(@as(*const IMultiLanguage2, @ptrCast(self)), dw_source_);
            }
            pub inline fn getNumberOfScripts(self: *const T, pn_scripts_: ?*u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).GetNumberOfScripts(@as(*const IMultiLanguage2, @ptrCast(self)), pn_scripts_);
            }
            pub inline fn enumScripts(self: *const T, dw_flags_: u32, lang_id_: u16, pp_enum_script_: ?*?*IEnumScript) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).EnumScripts(@as(*const IMultiLanguage2, @ptrCast(self)), dw_flags_, lang_id_, pp_enum_script_);
            }
            pub inline fn validateCodePageEx(self: *const T, ui_code_page_: u32, hwnd_: ?HWND, dwf_i_o_d_control_: u32) HRESULT {
                return @as(*const IMultiLanguage2.VTable, @ptrCast(self.vtable)).ValidateCodePageEx(@as(*const IMultiLanguage2, @ptrCast(self)), ui_code_page_, hwnd_, dwf_i_o_d_control_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangCodePages_Value = Guid.initString("359f3443-bd4a-11d0-b188-00aa0038c969");
pub const IID_IMLangCodePages = &IID_IMLangCodePages_Value;
pub const IMLangCodePages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCharCodePages: *const fn (
            self: *const IMLangCodePages,
            ch_src: u16,
            pdw_code_pages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrCodePages: *const fn (
            self: *const IMLangCodePages,
            psz_src: [*:0]const u16,
            cch_src: i32,
            dw_priority_code_pages: u32,
            pdw_code_pages: ?*u32,
            pcch_code_pages: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CodePageToCodePages: *const fn (
            self: *const IMLangCodePages,
            u_code_page: u32,
            pdw_code_pages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CodePagesToCodePage: *const fn (
            self: *const IMLangCodePages,
            dw_code_pages: u32,
            u_default_code_page: u32,
            pu_code_page: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCharCodePages(self: *const T, ch_src_: u16, pdw_code_pages_: ?*u32) HRESULT {
                return @as(*const IMLangCodePages.VTable, @ptrCast(self.vtable)).GetCharCodePages(@as(*const IMLangCodePages, @ptrCast(self)), ch_src_, pdw_code_pages_);
            }
            pub inline fn getStrCodePages(self: *const T, psz_src_: [*:0]const u16, cch_src_: i32, dw_priority_code_pages_: u32, pdw_code_pages_: ?*u32, pcch_code_pages_: ?*i32) HRESULT {
                return @as(*const IMLangCodePages.VTable, @ptrCast(self.vtable)).GetStrCodePages(@as(*const IMLangCodePages, @ptrCast(self)), psz_src_, cch_src_, dw_priority_code_pages_, pdw_code_pages_, pcch_code_pages_);
            }
            pub inline fn codePageToCodePages(self: *const T, u_code_page_: u32, pdw_code_pages_: ?*u32) HRESULT {
                return @as(*const IMLangCodePages.VTable, @ptrCast(self.vtable)).CodePageToCodePages(@as(*const IMLangCodePages, @ptrCast(self)), u_code_page_, pdw_code_pages_);
            }
            pub inline fn codePagesToCodePage(self: *const T, dw_code_pages_: u32, u_default_code_page_: u32, pu_code_page_: ?*u32) HRESULT {
                return @as(*const IMLangCodePages.VTable, @ptrCast(self.vtable)).CodePagesToCodePage(@as(*const IMLangCodePages, @ptrCast(self)), dw_code_pages_, u_default_code_page_, pu_code_page_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMLangFontLink_Value = Guid.initString("359f3441-bd4a-11d0-b188-00aa0038c969");
pub const IID_IMLangFontLink = &IID_IMLangFontLink_Value;
pub const IMLangFontLink = extern struct {
    pub const VTable = extern struct {
        base: IMLangCodePages.VTable,
        GetFontCodePages: *const fn (
            self: *const IMLangFontLink,
            h_d_c: ?HDC,
            h_font: ?HFONT,
            pdw_code_pages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapFont: *const fn (
            self: *const IMLangFontLink,
            h_d_c: ?HDC,
            dw_code_pages: u32,
            h_src_font: ?HFONT,
            ph_dest_font: ?*?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFont: *const fn (
            self: *const IMLangFontLink,
            h_font: ?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetFontMapping: *const fn (
            self: *const IMLangFontLink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMLangCodePages.MethodMixin(T);
            pub inline fn getFontCodePages(self: *const T, h_d_c_: ?HDC, h_font_: ?HFONT, pdw_code_pages_: ?*u32) HRESULT {
                return @as(*const IMLangFontLink.VTable, @ptrCast(self.vtable)).GetFontCodePages(@as(*const IMLangFontLink, @ptrCast(self)), h_d_c_, h_font_, pdw_code_pages_);
            }
            pub inline fn mapFont(self: *const T, h_d_c_: ?HDC, dw_code_pages_: u32, h_src_font_: ?HFONT, ph_dest_font_: ?*?HFONT) HRESULT {
                return @as(*const IMLangFontLink.VTable, @ptrCast(self.vtable)).MapFont(@as(*const IMLangFontLink, @ptrCast(self)), h_d_c_, dw_code_pages_, h_src_font_, ph_dest_font_);
            }
            pub inline fn releaseFont(self: *const T, h_font_: ?HFONT) HRESULT {
                return @as(*const IMLangFontLink.VTable, @ptrCast(self.vtable)).ReleaseFont(@as(*const IMLangFontLink, @ptrCast(self)), h_font_);
            }
            pub inline fn resetFontMapping(self: *const T) HRESULT {
                return @as(*const IMLangFontLink.VTable, @ptrCast(self.vtable)).ResetFontMapping(@as(*const IMLangFontLink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UNICODERANGE = extern struct {
    wcFrom: u16,
    wcTo: u16,
};

const IID_IMLangFontLink2_Value = Guid.initString("dccfc162-2b38-11d2-b7ec-00c04f8f5d9a");
pub const IID_IMLangFontLink2 = &IID_IMLangFontLink2_Value;
pub const IMLangFontLink2 = extern struct {
    pub const VTable = extern struct {
        base: IMLangCodePages.VTable,
        GetFontCodePages: *const fn (
            self: *const IMLangFontLink2,
            h_d_c: ?HDC,
            h_font: ?HFONT,
            pdw_code_pages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFont: *const fn (
            self: *const IMLangFontLink2,
            h_font: ?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetFontMapping: *const fn (
            self: *const IMLangFontLink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapFont: *const fn (
            self: *const IMLangFontLink2,
            h_d_c: ?HDC,
            dw_code_pages: u32,
            ch_src: u16,
            p_font: ?*?HFONT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontUnicodeRanges: *const fn (
            self: *const IMLangFontLink2,
            h_d_c: ?HDC,
            pui_ranges: ?*u32,
            p_uranges: ?*UNICODERANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptFontInfo: *const fn (
            self: *const IMLangFontLink2,
            sid: u8,
            dw_flags: u32,
            pui_fonts: ?*u32,
            p_script_font: ?*tagSCRIPFONTINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CodePageToScriptID: *const fn (
            self: *const IMLangFontLink2,
            ui_code_page: u32,
            p_sid: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMLangCodePages.MethodMixin(T);
            pub inline fn getFontCodePages(self: *const T, h_d_c_: ?HDC, h_font_: ?HFONT, pdw_code_pages_: ?*u32) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).GetFontCodePages(@as(*const IMLangFontLink2, @ptrCast(self)), h_d_c_, h_font_, pdw_code_pages_);
            }
            pub inline fn releaseFont(self: *const T, h_font_: ?HFONT) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).ReleaseFont(@as(*const IMLangFontLink2, @ptrCast(self)), h_font_);
            }
            pub inline fn resetFontMapping(self: *const T) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).ResetFontMapping(@as(*const IMLangFontLink2, @ptrCast(self)));
            }
            pub inline fn mapFont(self: *const T, h_d_c_: ?HDC, dw_code_pages_: u32, ch_src_: u16, p_font_: ?*?HFONT) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).MapFont(@as(*const IMLangFontLink2, @ptrCast(self)), h_d_c_, dw_code_pages_, ch_src_, p_font_);
            }
            pub inline fn getFontUnicodeRanges(self: *const T, h_d_c_: ?HDC, pui_ranges_: ?*u32, p_uranges_: ?*UNICODERANGE) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).GetFontUnicodeRanges(@as(*const IMLangFontLink2, @ptrCast(self)), h_d_c_, pui_ranges_, p_uranges_);
            }
            pub inline fn getScriptFontInfo(self: *const T, sid_: u8, dw_flags_: u32, pui_fonts_: ?*u32, p_script_font_: ?*tagSCRIPFONTINFO) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).GetScriptFontInfo(@as(*const IMLangFontLink2, @ptrCast(self)), sid_, dw_flags_, pui_fonts_, p_script_font_);
            }
            pub inline fn codePageToScriptID(self: *const T, ui_code_page_: u32, p_sid_: ?*u8) HRESULT {
                return @as(*const IMLangFontLink2.VTable, @ptrCast(self.vtable)).CodePageToScriptID(@as(*const IMLangFontLink2, @ptrCast(self)), ui_code_page_, p_sid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMultiLanguage3_Value = Guid.initString("4e5868ab-b157-4623-9acc-6a1d9caebe04");
pub const IID_IMultiLanguage3 = &IID_IMultiLanguage3_Value;
pub const IMultiLanguage3 = extern struct {
    pub const VTable = extern struct {
        base: IMultiLanguage2.VTable,
        DetectOutboundCodePage: *const fn (
            self: *const IMultiLanguage3,
            dw_flags: u32,
            lp_wide_char_str: [*:0]const u16,
            cch_wide_char: u32,
            pui_preferred_code_pages: ?[*]const u32,
            n_preferred_code_pages: u32,
            pui_detected_code_pages: [*]u32,
            pn_detected_code_pages: ?*u32,
            lp_special_char: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetectOutboundCodePageInIStream: *const fn (
            self: *const IMultiLanguage3,
            dw_flags: u32,
            p_str_in: ?*IStream,
            pui_preferred_code_pages: ?[*]const u32,
            n_preferred_code_pages: u32,
            pui_detected_code_pages: [*]u32,
            pn_detected_code_pages: ?*u32,
            lp_special_char: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMultiLanguage2.MethodMixin(T);
            pub inline fn detectOutboundCodePage(self: *const T, dw_flags_: u32, lp_wide_char_str_: [*:0]const u16, cch_wide_char_: u32, pui_preferred_code_pages_: ?[*]const u32, n_preferred_code_pages_: u32, pui_detected_code_pages_: [*]u32, pn_detected_code_pages_: ?*u32, lp_special_char_: ?[*:0]const u16) HRESULT {
                return @as(*const IMultiLanguage3.VTable, @ptrCast(self.vtable)).DetectOutboundCodePage(@as(*const IMultiLanguage3, @ptrCast(self)), dw_flags_, lp_wide_char_str_, cch_wide_char_, pui_preferred_code_pages_, n_preferred_code_pages_, pui_detected_code_pages_, pn_detected_code_pages_, lp_special_char_);
            }
            pub inline fn detectOutboundCodePageInIStream(self: *const T, dw_flags_: u32, p_str_in_: ?*IStream, pui_preferred_code_pages_: ?[*]const u32, n_preferred_code_pages_: u32, pui_detected_code_pages_: [*]u32, pn_detected_code_pages_: ?*u32, lp_special_char_: ?[*:0]const u16) HRESULT {
                return @as(*const IMultiLanguage3.VTable, @ptrCast(self.vtable)).DetectOutboundCodePageInIStream(@as(*const IMultiLanguage3, @ptrCast(self)), dw_flags_, p_str_in_, pui_preferred_code_pages_, n_preferred_code_pages_, pui_detected_code_pages_, pn_detected_code_pages_, lp_special_char_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MLSTR_FLAGS = enum(i32) {
    READ = 1,
    WRITE = 2,
};
pub const MLSTR_READ = MLSTR_FLAGS.READ;
pub const MLSTR_WRITE = MLSTR_FLAGS.WRITE;

//--------------------------------------------------------------------------------
// Section: Functions (1213)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "gdi32" fn GetTextCharset(
    hdc: ?HDC,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "gdi32" fn GetTextCharsetInfo(
    hdc: ?HDC,
    lp_sig: ?*FONTSIGNATURE,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "gdi32" fn TranslateCharsetInfo(
    lp_src: ?*u32,
    lp_cs: ?*CHARSETINFO,
    dw_flags: TRANSLATE_CHARSET_INFO_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetDateFormatA(
    locale: u32,
    dw_flags: u32,
    lp_date: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u8,
    lp_date_str: ?[*:0]u8,
    cch_date: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetDateFormatW(
    locale: u32,
    dw_flags: u32,
    lp_date: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u16,
    lp_date_str: ?[*:0]u16,
    cch_date: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetTimeFormatA(
    locale: u32,
    dw_flags: u32,
    lp_time: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u8,
    lp_time_str: ?[*:0]u8,
    cch_time: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetTimeFormatW(
    locale: u32,
    dw_flags: u32,
    lp_time: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u16,
    lp_time_str: ?[*:0]u16,
    cch_time: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetTimeFormatEx(
    lp_locale_name: ?[*:0]const u16,
    dw_flags: TIME_FORMAT_FLAGS,
    lp_time: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u16,
    lp_time_str: ?[*:0]u16,
    cch_time: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetDateFormatEx(
    lp_locale_name: ?[*:0]const u16,
    dw_flags: ENUM_DATE_FORMATS_FLAGS,
    lp_date: ?*const SYSTEMTIME,
    lp_format: ?[*:0]const u16,
    lp_date_str: ?[*:0]u16,
    cch_date: i32,
    lp_calendar: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetDurationFormatEx(
    lp_locale_name: ?[*:0]const u16,
    dw_flags: u32,
    lp_duration: ?*const SYSTEMTIME,
    ull_duration: u64,
    lp_format: ?[*:0]const u16,
    lp_duration_str: ?[*:0]u16,
    cch_duration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CompareStringEx(
    lp_locale_name: ?[*:0]const u16,
    dw_cmp_flags: COMPARE_STRING_FLAGS,
    lp_string1: [*:0]const u16,
    cch_count1: i32,
    lp_string2: [*:0]const u16,
    cch_count2: i32,
    lp_version_information: ?*NLSVERSIONINFO,
    lp_reserved: ?*anyopaque,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CompareStringOrdinal(
    lp_string1: [*:0]const u16,
    cch_count1: i32,
    lp_string2: [*:0]const u16,
    cch_count2: i32,
    b_ignore_case: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn CompareStringW(
    locale: u32,
    dw_cmp_flags: u32,
    lp_string1: [*:0]const u16,
    cch_count1: i32,
    lp_string2: [*:0]const u16,
    cch_count2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FoldStringW(
    dw_map_flags: FOLD_STRING_MAP_FLAGS,
    lp_src_str: [*:0]const u16,
    cch_src: i32,
    lp_dest_str: ?[*:0]u16,
    cch_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetStringTypeExW(
    locale: u32,
    dw_info_type: u32,
    lp_src_str: [*:0]const u16,
    cch_src: i32,
    lp_char_type: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetStringTypeW(
    dw_info_type: u32,
    lp_src_str: [*:0]const u16,
    cch_src: i32,
    lp_char_type: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn MultiByteToWideChar(
    code_page: u32,
    dw_flags: MULTI_BYTE_TO_WIDE_CHAR_FLAGS,
    lp_multi_byte_str: [*]const u8,
    cb_multi_byte: i32,
    lp_wide_char_str: ?[*:0]u16,
    cch_wide_char: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WideCharToMultiByte(
    code_page: u32,
    dw_flags: u32,
    lp_wide_char_str: [*:0]const u16,
    cch_wide_char: i32,
    // TODO: what to do with BytesParamIndex 5?
    lp_multi_byte_str: ?PSTR,
    cb_multi_byte: i32,
    lp_default_char: ?[*]const u8,
    lp_used_default_char: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn IsValidCodePage(
    code_page: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetACP() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetOEMCP() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCPInfo(
    code_page: u32,
    lp_c_p_info: ?*CPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCPInfoExA(
    code_page: u32,
    dw_flags: u32,
    lp_c_p_info_ex: ?*CPINFOEXA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCPInfoExW(
    code_page: u32,
    dw_flags: u32,
    lp_c_p_info_ex: ?*CPINFOEXW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn CompareStringA(
    locale: u32,
    dw_cmp_flags: u32,
    lp_string1: [*]i8,
    cch_count1: i32,
    lp_string2: [*]i8,
    cch_count2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindNLSString(
    locale: u32,
    dw_find_n_l_s_string_flags: u32,
    lp_string_source: [*:0]const u16,
    cch_source: i32,
    lp_string_value: [*:0]const u16,
    cch_value: i32,
    pcch_found: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn LCMapStringW(
    locale: u32,
    dw_map_flags: u32,
    lp_src_str: [*:0]const u16,
    cch_src: i32,
    lp_dest_str: ?PWSTR,
    cch_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn LCMapStringA(
    locale: u32,
    dw_map_flags: u32,
    lp_src_str: [*:0]const u8,
    cch_src: i32,
    lp_dest_str: ?PSTR,
    cch_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetLocaleInfoW(
    locale: u32,
    l_c_type: u32,
    lp_l_c_data: ?[*:0]u16,
    cch_data: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetLocaleInfoA(
    locale: u32,
    l_c_type: u32,
    lp_l_c_data: ?[*:0]u8,
    cch_data: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SetLocaleInfoA(
    locale: u32,
    l_c_type: u32,
    lp_l_c_data: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SetLocaleInfoW(
    locale: u32,
    l_c_type: u32,
    lp_l_c_data: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCalendarInfoA(
    locale: u32,
    calendar: u32,
    cal_type: u32,
    lp_cal_data: ?[*:0]u8,
    cch_data: i32,
    lp_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCalendarInfoW(
    locale: u32,
    calendar: u32,
    cal_type: u32,
    lp_cal_data: ?[*:0]u16,
    cch_data: i32,
    lp_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SetCalendarInfoA(
    locale: u32,
    calendar: u32,
    cal_type: u32,
    lp_cal_data: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SetCalendarInfoW(
    locale: u32,
    calendar: u32,
    cal_type: u32,
    lp_cal_data: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn IsDBCSLeadByte(
    test_char: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn IsDBCSLeadByteEx(
    code_page: u32,
    test_char: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn LocaleNameToLCID(
    lp_name: ?[*:0]const u16,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn LCIDToLocaleName(
    locale: u32,
    lp_name: ?[*:0]u16,
    cch_name: i32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetDurationFormat(
    locale: u32,
    dw_flags: u32,
    lp_duration: ?*const SYSTEMTIME,
    ull_duration: u64,
    lp_format: ?[*:0]const u16,
    lp_duration_str: ?[*:0]u16,
    cch_duration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetNumberFormatA(
    locale: u32,
    dw_flags: u32,
    lp_value: ?[*:0]const u8,
    lp_format: ?*const NUMBERFMTA,
    lp_number_str: ?[*:0]u8,
    cch_number: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetNumberFormatW(
    locale: u32,
    dw_flags: u32,
    lp_value: ?[*:0]const u16,
    lp_format: ?*const NUMBERFMTW,
    lp_number_str: ?[*:0]u16,
    cch_number: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCurrencyFormatA(
    locale: u32,
    dw_flags: u32,
    lp_value: ?[*:0]const u8,
    lp_format: ?*const CURRENCYFMTA,
    lp_currency_str: ?[*:0]u8,
    cch_currency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCurrencyFormatW(
    locale: u32,
    dw_flags: u32,
    lp_value: ?[*:0]const u16,
    lp_format: ?*const CURRENCYFMTW,
    lp_currency_str: ?[*:0]u16,
    cch_currency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumCalendarInfoA(
    lp_cal_info_enum_proc: ?CALINFO_ENUMPROCA,
    locale: u32,
    calendar: u32,
    cal_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumCalendarInfoW(
    lp_cal_info_enum_proc: ?CALINFO_ENUMPROCW,
    locale: u32,
    calendar: u32,
    cal_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumCalendarInfoExA(
    lp_cal_info_enum_proc_ex: ?CALINFO_ENUMPROCEXA,
    locale: u32,
    calendar: u32,
    cal_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumCalendarInfoExW(
    lp_cal_info_enum_proc_ex: ?CALINFO_ENUMPROCEXW,
    locale: u32,
    calendar: u32,
    cal_type: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumTimeFormatsA(
    lp_time_fmt_enum_proc: ?TIMEFMT_ENUMPROCA,
    locale: u32,
    dw_flags: TIME_FORMAT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumTimeFormatsW(
    lp_time_fmt_enum_proc: ?TIMEFMT_ENUMPROCW,
    locale: u32,
    dw_flags: TIME_FORMAT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumDateFormatsA(
    lp_date_fmt_enum_proc: ?DATEFMT_ENUMPROCA,
    locale: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumDateFormatsW(
    lp_date_fmt_enum_proc: ?DATEFMT_ENUMPROCW,
    locale: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumDateFormatsExA(
    lp_date_fmt_enum_proc_ex: ?DATEFMT_ENUMPROCEXA,
    locale: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumDateFormatsExW(
    lp_date_fmt_enum_proc_ex: ?DATEFMT_ENUMPROCEXW,
    locale: u32,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn IsValidLanguageGroup(
    language_group: u32,
    dw_flags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetNLSVersion(
    function: u32,
    locale: u32,
    lp_version_information: ?*NLSVERSIONINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn IsValidLocale(
    locale: u32,
    dw_flags: IS_VALID_LOCALE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetGeoInfoA(
    location: i32,
    geo_type: u32,
    lp_geo_data: ?[*:0]u8,
    cch_data: i32,
    lang_id: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetGeoInfoW(
    location: i32,
    geo_type: u32,
    lp_geo_data: ?[*:0]u16,
    cch_data: i32,
    lang_id: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "kernel32" fn GetGeoInfoEx(
    location: ?PWSTR,
    geo_type: u32,
    geo_data: ?[*:0]u16,
    geo_data_count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn EnumSystemGeoID(
    geo_class: u32,
    parent_geo_id: i32,
    lp_geo_enum_proc: ?GEO_ENUMPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "kernel32" fn EnumSystemGeoNames(
    geo_class: u32,
    geo_enum_proc: ?GEO_ENUMNAMEPROC,
    data: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetUserGeoID(
    geo_class: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "kernel32" fn GetUserDefaultGeoName(
    geo_name: [*:0]u16,
    geo_name_count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetUserGeoID(
    geo_id: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "kernel32" fn SetUserGeoName(
    geo_name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn ConvertDefaultLocale(
    locale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetSystemDefaultUILanguage() callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetThreadLocale() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SetThreadLocale(
    locale: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetUserDefaultUILanguage() callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetUserDefaultLangID() callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetSystemDefaultLangID() callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetSystemDefaultLCID() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetUserDefaultLCID() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetThreadUILanguage(
    lang_id: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetThreadUILanguage() callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn GetProcessPreferredUILanguages(
    dw_flags: u32,
    pul_num_languages: ?*u32,
    pwsz_languages_buffer: ?[*]u16,
    pcch_languages_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn SetProcessPreferredUILanguages(
    dw_flags: u32,
    pwsz_languages_buffer: ?[*]const u16,
    pul_num_languages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetUserPreferredUILanguages(
    dw_flags: u32,
    pul_num_languages: ?*u32,
    pwsz_languages_buffer: ?[*]u16,
    pcch_languages_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetSystemPreferredUILanguages(
    dw_flags: u32,
    pul_num_languages: ?*u32,
    pwsz_languages_buffer: ?[*]u16,
    pcch_languages_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetThreadPreferredUILanguages(
    dw_flags: u32,
    pul_num_languages: ?*u32,
    pwsz_languages_buffer: ?[*]u16,
    pcch_languages_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetThreadPreferredUILanguages(
    dw_flags: u32,
    pwsz_languages_buffer: ?[*]const u16,
    pul_num_languages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileMUIInfo(
    dw_flags: u32,
    pcwsz_file_path: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    p_file_m_u_i_info: ?*FILEMUIINFO,
    pcb_file_m_u_i_info: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileMUIPath(
    dw_flags: u32,
    pcwsz_file_path: ?[*:0]const u16,
    pwsz_language: ?[*:0]u16,
    pcch_language: ?*u32,
    pwsz_file_m_u_i_path: ?[*:0]u16,
    pcch_file_m_u_i_path: ?*u32,
    pulul_enumerator: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetUILanguageInfo(
    dw_flags: u32,
    pwmsz_language: ?[*]const u16,
    pwsz_fallback_languages: ?[*]u16,
    pcch_fallback_languages: ?*u32,
    p_attributes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn SetThreadPreferredUILanguages2(
    flags: u32,
    languages: ?[*]const u16,
    num_languages_set: ?*u32,
    snapshot: ?*?HSAVEDUILANGUAGES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn RestoreThreadPreferredUILanguages(
    snapshot: ?HSAVEDUILANGUAGES,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn NotifyUILanguageChange(
    dw_flags: u32,
    pcwstr_new_language: ?[*:0]const u16,
    pcwstr_previous_language: ?[*:0]const u16,
    dw_reserved: u32,
    pdw_status_rtrn: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn GetStringTypeExA(
    locale: u32,
    dw_info_type: u32,
    lp_src_str: [*:0]const u8,
    cch_src: i32,
    lp_char_type: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetStringTypeA(
    locale: u32,
    dw_info_type: u32,
    lp_src_str: [*:0]const u8,
    cch_src: i32,
    lp_char_type: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FoldStringA(
    dw_map_flags: FOLD_STRING_MAP_FLAGS,
    lp_src_str: [*:0]const u8,
    cch_src: i32,
    lp_dest_str: ?[*:0]u8,
    cch_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemLocalesA(
    lp_locale_enum_proc: ?LOCALE_ENUMPROCA,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemLocalesW(
    lp_locale_enum_proc: ?LOCALE_ENUMPROCW,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemLanguageGroupsA(
    lp_language_group_enum_proc: ?LANGUAGEGROUP_ENUMPROCA,
    dw_flags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemLanguageGroupsW(
    lp_language_group_enum_proc: ?LANGUAGEGROUP_ENUMPROCW,
    dw_flags: ENUM_SYSTEM_LANGUAGE_GROUPS_FLAGS,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumLanguageGroupLocalesA(
    lp_lang_group_locale_enum_proc: ?LANGGROUPLOCALE_ENUMPROCA,
    language_group: u32,
    dw_flags: u32,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumLanguageGroupLocalesW(
    lp_lang_group_locale_enum_proc: ?LANGGROUPLOCALE_ENUMPROCW,
    language_group: u32,
    dw_flags: u32,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumUILanguagesA(
    lp_u_i_language_enum_proc: ?UILANGUAGE_ENUMPROCA,
    dw_flags: u32,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumUILanguagesW(
    lp_u_i_language_enum_proc: ?UILANGUAGE_ENUMPROCW,
    dw_flags: u32,
    l_param: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemCodePagesA(
    lp_code_page_enum_proc: ?CODEPAGE_ENUMPROCA,
    dw_flags: ENUM_SYSTEM_CODE_PAGES_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumSystemCodePagesW(
    lp_code_page_enum_proc: ?CODEPAGE_ENUMPROCW,
    dw_flags: ENUM_SYSTEM_CODE_PAGES_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "normaliz" fn IdnToAscii(
    dw_flags: u32,
    lp_unicode_char_str: [*:0]const u16,
    cch_unicode_char: i32,
    lp_a_s_c_i_i_char_str: ?[*:0]u16,
    cch_a_s_c_i_i_char: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "normaliz" fn IdnToUnicode(
    dw_flags: u32,
    lp_a_s_c_i_i_char_str: [*:0]const u16,
    cch_a_s_c_i_i_char: i32,
    lp_unicode_char_str: ?[*:0]u16,
    cch_unicode_char: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn IdnToNameprepUnicode(
    dw_flags: u32,
    lp_unicode_char_str: [*:0]const u16,
    cch_unicode_char: i32,
    lp_nameprep_char_str: ?[*:0]u16,
    cch_nameprep_char: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn NormalizeString(
    norm_form: NORM_FORM,
    lp_src_string: [*:0]const u16,
    cw_src_length: i32,
    lp_dst_string: ?[*:0]u16,
    cw_dst_length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn IsNormalizedString(
    norm_form: NORM_FORM,
    lp_string: [*:0]const u16,
    cw_length: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn VerifyScripts(
    dw_flags: u32,
    lp_locale_scripts: ?[*:0]const u16,
    cch_locale_scripts: i32,
    lp_test_scripts: ?[*:0]const u16,
    cch_test_scripts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetStringScripts(
    dw_flags: u32,
    lp_string: ?[*:0]const u16,
    cch_string: i32,
    lp_scripts: ?[*:0]u16,
    cch_scripts: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetLocaleInfoEx(
    lp_locale_name: ?[*:0]const u16,
    l_c_type: u32,
    lp_l_c_data: ?[*:0]u16,
    cch_data: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetCalendarInfoEx(
    lp_locale_name: ?[*:0]const u16,
    calendar: u32,
    lp_reserved: ?[*:0]const u16,
    cal_type: u32,
    lp_cal_data: ?[*:0]u16,
    cch_data: i32,
    lp_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetNumberFormatEx(
    lp_locale_name: ?[*:0]const u16,
    dw_flags: u32,
    lp_value: ?[*:0]const u16,
    lp_format: ?*const NUMBERFMTW,
    lp_number_str: ?[*:0]u16,
    cch_number: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetCurrencyFormatEx(
    lp_locale_name: ?[*:0]const u16,
    dw_flags: u32,
    lp_value: ?[*:0]const u16,
    lp_format: ?*const CURRENCYFMTW,
    lp_currency_str: ?[*:0]u16,
    cch_currency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetUserDefaultLocaleName(
    lp_locale_name: [*:0]u16,
    cch_locale_name: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetSystemDefaultLocaleName(
    lp_locale_name: [*:0]u16,
    cch_locale_name: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn IsNLSDefinedString(
    function: u32,
    dw_flags: u32,
    lp_version_information: ?*NLSVERSIONINFO,
    lp_string: [*:0]const u16,
    cch_str: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetNLSVersionEx(
    function: u32,
    lp_locale_name: ?[*:0]const u16,
    lp_version_information: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn IsValidNLSVersion(
    function: u32,
    lp_locale_name: ?[*:0]const u16,
    lp_version_information: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindNLSStringEx(
    lp_locale_name: ?[*:0]const u16,
    dw_find_n_l_s_string_flags: u32,
    lp_string_source: [*:0]const u16,
    cch_source: i32,
    lp_string_value: [*:0]const u16,
    cch_value: i32,
    pcch_found: ?*i32,
    lp_version_information: ?*NLSVERSIONINFO,
    lp_reserved: ?*anyopaque,
    sort_handle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn LCMapStringEx(
    lp_locale_name: ?[*:0]const u16,
    dw_map_flags: u32,
    lp_src_str: [*:0]const u16,
    cch_src: i32,
    lp_dest_str: ?[*:0]u16,
    cch_dest: i32,
    lp_version_information: ?*NLSVERSIONINFO,
    lp_reserved: ?*anyopaque,
    sort_handle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn IsValidLocaleName(
    lp_locale_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumCalendarInfoExEx(
    p_cal_info_enum_proc_ex_ex: ?CALINFO_ENUMPROCEXEX,
    lp_locale_name: ?[*:0]const u16,
    calendar: u32,
    lp_reserved: ?[*:0]const u16,
    cal_type: u32,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumDateFormatsExEx(
    lp_date_fmt_enum_proc_ex_ex: ?DATEFMT_ENUMPROCEXEX,
    lp_locale_name: ?[*:0]const u16,
    dw_flags: ENUM_DATE_FORMATS_FLAGS,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumTimeFormatsEx(
    lp_time_fmt_enum_proc_ex: ?TIMEFMT_ENUMPROCEX,
    lp_locale_name: ?[*:0]const u16,
    dw_flags: u32,
    l_param: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumSystemLocalesEx(
    lp_locale_enum_proc_ex: ?LOCALE_ENUMPROCEX,
    dw_flags: u32,
    l_param: LPARAM,
    lp_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn ResolveLocaleName(
    lp_name_to_resolve: ?[*:0]const u16,
    lp_locale_name: ?[*:0]u16,
    cch_locale_name: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingGetServices(
    p_options: ?*MAPPING_ENUM_OPTIONS,
    prg_services: ?*?*MAPPING_SERVICE_INFO,
    pdw_services_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingFreeServices(
    p_service_info: ?*MAPPING_SERVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingRecognizeText(
    p_service_info: ?*MAPPING_SERVICE_INFO,
    psz_text: [*:0]const u16,
    dw_length: u32,
    dw_index: u32,
    p_options: ?*MAPPING_OPTIONS,
    pbag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingDoAction(
    p_bag: ?*MAPPING_PROPERTY_BAG,
    dw_range_index: u32,
    psz_action_id: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "elscore" fn MappingFreePropertyBag(
    p_bag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptFreeCache(
    psc: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptItemize(
    pwc_in_chars: [*:0]const u16,
    c_in_chars: i32,
    c_max_items: i32,
    ps_control: ?*const SCRIPT_CONTROL,
    ps_state: ?*const SCRIPT_STATE,
    p_items: [*]SCRIPT_ITEM,
    pc_items: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptLayout(
    c_runs: i32,
    pb_level: [*:0]const u8,
    pi_visual_to_logical: ?*i32,
    pi_logical_to_visual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptShape(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    pwc_chars: [*:0]const u16,
    c_chars: i32,
    c_max_glyphs: i32,
    psa: ?*SCRIPT_ANALYSIS,
    pw_out_glyphs: [*:0]u16,
    pw_log_clust: ?*u16,
    psva: [*]SCRIPT_VISATTR,
    pc_glyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptPlace(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    pw_glyphs: [*:0]const u16,
    c_glyphs: i32,
    psva: [*]const SCRIPT_VISATTR,
    psa: ?*SCRIPT_ANALYSIS,
    pi_advance: ?*i32,
    p_goffset: ?*GOFFSET,
    p_a_b_c: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptTextOut(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    x: i32,
    y: i32,
    fu_options: u32,
    lprc: ?*const RECT,
    psa: ?*const SCRIPT_ANALYSIS,
    pwc_reserved: ?[*:0]const u16,
    i_reserved: i32,
    pw_glyphs: [*:0]const u16,
    c_glyphs: i32,
    pi_advance: [*]const i32,
    pi_justify: ?[*]const i32,
    p_goffset: [*]const GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptJustify(
    psva: [*]const SCRIPT_VISATTR,
    pi_advance: [*]const i32,
    c_glyphs: i32,
    i_dx: i32,
    i_min_kashida: i32,
    pi_justify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptBreak(
    pwc_chars: [*:0]const u16,
    c_chars: i32,
    psa: ?*const SCRIPT_ANALYSIS,
    psla: ?*SCRIPT_LOGATTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptCPtoX(
    i_c_p: i32,
    f_trailing: BOOL,
    c_chars: i32,
    c_glyphs: i32,
    pw_log_clust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    pi_advance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    pi_x: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptXtoCP(
    i_x: i32,
    c_chars: i32,
    c_glyphs: i32,
    pw_log_clust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    pi_advance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    pi_c_p: ?*i32,
    pi_trailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptGetLogicalWidths(
    psa: ?*const SCRIPT_ANALYSIS,
    c_chars: i32,
    c_glyphs: i32,
    pi_glyph_width: [*]const i32,
    pw_log_clust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    pi_dx: [*]i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptApplyLogicalWidth(
    pi_dx: [*]const i32,
    c_chars: i32,
    c_glyphs: i32,
    pw_log_clust: [*:0]const u16,
    psva: [*]const SCRIPT_VISATTR,
    pi_advance: [*]const i32,
    psa: ?*const SCRIPT_ANALYSIS,
    p_a_b_c: ?*ABC,
    pi_justify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptGetCMap(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    pwc_in_chars: [*:0]const u16,
    c_chars: i32,
    dw_flags: u32,
    pw_out_glyphs: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptGetGlyphABCWidth(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    w_glyph: u16,
    p_a_b_c: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptGetProperties(
    pp_sp: ?*const ?*?*SCRIPT_PROPERTIES,
    pi_num_scripts: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptGetFontProperties(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    sfp: ?*SCRIPT_FONTPROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptCacheGetHeight(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    tm_height: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringAnalyse(
    hdc: ?HDC,
    p_string: ?*const anyopaque,
    c_string: i32,
    c_glyphs: i32,
    i_charset: i32,
    dw_flags: u32,
    i_req_width: i32,
    ps_control: ?*SCRIPT_CONTROL,
    ps_state: ?*SCRIPT_STATE,
    pi_dx: ?[*]const i32,
    p_tabdef: ?*SCRIPT_TABDEF,
    pb_in_class: ?*const u8,
    pssa: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringFree(
    pssa: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptString_pSize(
    ssa: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*SIZE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptString_pcOutChars(
    ssa: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptString_pLogAttr(
    ssa: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*SCRIPT_LOGATTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringGetOrder(
    ssa: ?*anyopaque,
    pu_order: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringCPtoX(
    ssa: ?*anyopaque,
    icp: i32,
    f_trailing: BOOL,
    p_x: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringXtoCP(
    ssa: ?*anyopaque,
    i_x: i32,
    pi_ch: ?*i32,
    pi_trailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringGetLogicalWidths(
    ssa: ?*anyopaque,
    pi_dx: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringValidate(
    ssa: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptStringOut(
    ssa: ?*anyopaque,
    i_x: i32,
    i_y: i32,
    u_options: ETO_OPTIONS,
    prc: ?*const RECT,
    i_min_sel: i32,
    i_max_sel: i32,
    f_disabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptIsComplex(
    pwc_in_chars: [*:0]const u16,
    c_in_chars: i32,
    dw_flags: SCRIPT_IS_COMPLEX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptRecordDigitSubstitution(
    locale: u32,
    psds: ?*SCRIPT_DIGITSUBSTITUTE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "usp10" fn ScriptApplyDigitSubstitution(
    psds: ?*const SCRIPT_DIGITSUBSTITUTE,
    psc: ?*SCRIPT_CONTROL,
    pss: ?*SCRIPT_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptShapeOpenType(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    rc_range_chars: ?[*]i32,
    rp_range_properties: ?[*]?*textrange_properties,
    c_ranges: i32,
    pwc_chars: [*:0]const u16,
    c_chars: i32,
    c_max_glyphs: i32,
    pw_log_clust: ?*u16,
    p_char_props: ?*script_charprop,
    pw_out_glyphs: [*:0]u16,
    p_out_glyph_props: [*]script_glyphprop,
    pc_glyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptPlaceOpenType(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    rc_range_chars: ?[*]i32,
    rp_range_properties: ?[*]?*textrange_properties,
    c_ranges: i32,
    pwc_chars: [*:0]const u16,
    pw_log_clust: [*:0]u16,
    p_char_props: [*]script_charprop,
    c_chars: i32,
    pw_glyphs: [*:0]const u16,
    p_glyph_props: [*]const script_glyphprop,
    c_glyphs: i32,
    pi_advance: ?*i32,
    p_goffset: ?*GOFFSET,
    p_a_b_c: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptItemizeOpenType(
    pwc_in_chars: [*:0]const u16,
    c_in_chars: i32,
    c_max_items: i32,
    ps_control: ?*const SCRIPT_CONTROL,
    ps_state: ?*const SCRIPT_STATE,
    p_items: [*]SCRIPT_ITEM,
    p_script_tags: [*]u32,
    pc_items: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptGetFontScriptTags(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    c_max_tags: i32,
    p_script_tags: [*]u32,
    pc_tags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptGetFontLanguageTags(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    c_max_tags: i32,
    p_langsys_tags: [*]u32,
    pc_tags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptGetFontFeatureTags(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    c_max_tags: i32,
    p_feature_tags: [*]u32,
    pc_tags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptGetFontAlternateGlyphs(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    tag_feature: u32,
    w_glyph_id: u16,
    c_max_alternates: i32,
    p_alternate_glyphs: [*:0]u16,
    pc_alternates: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptSubstituteSingleGlyph(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    tag_feature: u32,
    l_parameter: i32,
    w_glyph_id: u16,
    pw_out_glyph_id: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "usp10" fn ScriptPositionSingleGlyph(
    hdc: ?HDC,
    psc: ?*?*anyopaque,
    psa: ?*SCRIPT_ANALYSIS,
    tag_script: u32,
    tag_lang_sys: u32,
    tag_feature: u32,
    l_parameter: i32,
    w_glyph_id: u16,
    i_advance: i32,
    g_offset: GOFFSET,
    pi_out_advance: ?*i32,
    p_out_goffset: ?*GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "icu" fn utf8_nextCharSafeBody(
    s: ?*const u8,
    pi: ?*i32,
    length: i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_appendCharSafeBody(
    s: ?*u8,
    i: i32,
    length: i32,
    c: i32,
    p_is_error: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_prevCharSafeBody(
    s: ?*const u8,
    start: i32,
    pi: ?*i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utf8_back1SafeBody(
    s: ?*const u8,
    start: i32,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_versionFromString(
    version_array: ?*u8,
    version_string: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_versionFromUString(
    version_array: ?*u8,
    version_string: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_versionToString(
    version_array: ?*const u8,
    version_string: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getVersion(
    version_array: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_errorName(
    code: UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn utrace_setLevel(
    trace_level: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_getLevel() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_setFunctions(
    context: ?*const anyopaque,
    e: ?UTraceEntry,
    x: ?UTraceExit,
    d: ?UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_getFunctions(
    context: ?*const ?*anyopaque,
    e: ?*?UTraceEntry,
    x: ?*?UTraceExit,
    d: ?*?UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrace_vformat(
    out_buf: ?PSTR,
    capacity: i32,
    indent: i32,
    fmt: ?[*:0]const u8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_format(
    out_buf: ?PSTR,
    capacity: i32,
    indent: i32,
    fmt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrace_functionName(
    fn_number: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_shapeArabic(
    source: ?*const u16,
    source_length: i32,
    dest: ?*u16,
    dest_size: i32,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getCode(
    name_or_abbr_or_locale: ?[*:0]const u8,
    fill_in: ?*UScriptCode,
    capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getName(
    script_code: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uscript_getShortName(
    script_code: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uscript_getScript(
    codepoint: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UScriptCode;

pub extern "icu" fn uscript_hasScript(
    c: i32,
    sc: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_getScriptExtensions(
    c: i32,
    scripts: ?*UScriptCode,
    capacity: i32,
    error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getSampleString(
    script: UScriptCode,
    dest: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uscript_getUsage(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) UScriptUsage;

pub extern "icu" fn uscript_isRightToLeft(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_breaksBetweenLetters(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uscript_isCased(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uiter_current32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_next32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_previous32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uiter_getState(
    iter: ?*const UCharIterator,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn uiter_setState(
    iter: ?*UCharIterator,
    state: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setString(
    iter: ?*UCharIterator,
    s: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setUTF16BE(
    iter: ?*UCharIterator,
    s: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uiter_setUTF8(
    iter: ?*UCharIterator,
    s: ?[*:0]const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_close(
    en: ?*UEnumeration,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_count(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uenum_unext(
    en: ?*UEnumeration,
    result_length: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uenum_next(
    en: ?*UEnumeration,
    result_length: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uenum_reset(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uenum_openUCharStringsEnumeration(
    strings: ?*const ?*u16,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uenum_openCharStringsEnumeration(
    strings: ?*const ?*i8,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uloc_getDefault() callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_setDefault(
    locale_i_d: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uloc_getLanguage(
    locale_i_d: ?[*:0]const u8,
    language: ?PSTR,
    language_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getScript(
    locale_i_d: ?[*:0]const u8,
    script: ?PSTR,
    script_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getCountry(
    locale_i_d: ?[*:0]const u8,
    country: ?PSTR,
    country_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getVariant(
    locale_i_d: ?[*:0]const u8,
    variant: ?PSTR,
    variant_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getName(
    locale_i_d: ?[*:0]const u8,
    name: ?PSTR,
    name_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_canonicalize(
    locale_i_d: ?[*:0]const u8,
    name: ?PSTR,
    name_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getISO3Language(
    locale_i_d: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_getISO3Country(
    locale_i_d: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_getLCID(
    locale_i_d: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn uloc_getDisplayLanguage(
    locale: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    language: ?*u16,
    language_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayScript(
    locale: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    script: ?*u16,
    script_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayCountry(
    locale: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    country: ?*u16,
    country_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayVariant(
    locale: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    variant: ?*u16,
    variant_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayKeyword(
    keyword: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    dest: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayKeywordValue(
    locale: ?[*:0]const u8,
    keyword: ?[*:0]const u8,
    display_locale: ?[*:0]const u8,
    dest: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getDisplayName(
    locale_i_d: ?[*:0]const u8,
    in_locale_i_d: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getAvailable(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_openAvailableByType(
    type: ULocAvailableType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uloc_getISOLanguages() callconv(@import("std").os.windows.WINAPI) ?*?*i8;

pub extern "icu" fn uloc_getISOCountries() callconv(@import("std").os.windows.WINAPI) ?*?*i8;

pub extern "icu" fn uloc_getParent(
    locale_i_d: ?[*:0]const u8,
    parent: ?PSTR,
    parent_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getBaseName(
    locale_i_d: ?[*:0]const u8,
    name: ?PSTR,
    name_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_openKeywords(
    locale_i_d: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uloc_getKeywordValue(
    locale_i_d: ?[*:0]const u8,
    keyword_name: ?[*:0]const u8,
    buffer: ?PSTR,
    buffer_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_setKeywordValue(
    keyword_name: ?[*:0]const u8,
    keyword_value: ?[*:0]const u8,
    buffer: ?PSTR,
    buffer_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_isRightToLeft(
    locale: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uloc_getCharacterOrientation(
    locale_id: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

pub extern "icu" fn uloc_getLineOrientation(
    locale_id: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

pub extern "icu" fn uloc_acceptLanguageFromHTTP(
    result: ?PSTR,
    result_available: i32,
    out_result: ?*UAcceptResult,
    http_accept_language: ?[*:0]const u8,
    available_locales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_acceptLanguage(
    result: ?PSTR,
    result_available: i32,
    out_result: ?*UAcceptResult,
    accept_list: ?*const ?*i8,
    accept_list_count: i32,
    available_locales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_getLocaleForLCID(
    host_i_d: u32,
    locale: ?PSTR,
    locale_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_addLikelySubtags(
    locale_i_d: ?[*:0]const u8,
    maximized_locale_i_d: ?PSTR,
    maximized_locale_i_d_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_minimizeSubtags(
    locale_i_d: ?[*:0]const u8,
    minimized_locale_i_d: ?PSTR,
    minimized_locale_i_d_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_forLanguageTag(
    langtag: ?[*:0]const u8,
    locale_i_d: ?PSTR,
    locale_i_d_capacity: i32,
    parsed_length: ?*i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_toLanguageTag(
    locale_i_d: ?[*:0]const u8,
    langtag: ?PSTR,
    langtag_capacity: i32,
    strict: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uloc_toUnicodeLocaleKey(
    keyword: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toUnicodeLocaleType(
    keyword: ?[*:0]const u8,
    value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toLegacyKey(
    keyword: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uloc_toLegacyType(
    keyword: ?[*:0]const u8,
    value: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_open(
    package_name: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_openDirect(
    package_name: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_openU(
    package_name: ?*const u16,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_close(
    resource_bundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_getVersion(
    res_b: ?*const UResourceBundle,
    version_info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_getLocaleByType(
    resource_bundle: ?*const UResourceBundle,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getString(
    resource_bundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8String(
    res_b: ?*const UResourceBundle,
    dest: ?PSTR,
    length: ?*i32,
    force_copy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getBinary(
    resource_bundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "icu" fn ures_getIntVector(
    resource_bundle: ?*const UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn ures_getUInt(
    resource_bundle: ?*const UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ures_getInt(
    resource_bundle: ?*const UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ures_getSize(
    resource_bundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ures_getType(
    resource_bundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) UResType;

pub extern "icu" fn ures_getKey(
    resource_bundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_resetIterator(
    resource_bundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ures_hasNext(
    resource_bundle: ?*const UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ures_getNextResource(
    resource_bundle: ?*UResourceBundle,
    fill_in: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getNextString(
    resource_bundle: ?*UResourceBundle,
    len: ?*i32,
    key: ?*const ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getByIndex(
    resource_bundle: ?*const UResourceBundle,
    index_r: i32,
    fill_in: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getStringByIndex(
    resource_bundle: ?*const UResourceBundle,
    index_s: i32,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8StringByIndex(
    res_b: ?*const UResourceBundle,
    string_index: i32,
    dest: ?PSTR,
    p_length: ?*i32,
    force_copy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_getByKey(
    resource_bundle: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    fill_in: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn ures_getStringByKey(
    res_b: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ures_getUTF8StringByKey(
    res_b: ?*const UResourceBundle,
    key: ?[*:0]const u8,
    dest: ?PSTR,
    p_length: ?*i32,
    force_copy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ures_openAvailableLocales(
    package_name: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uldn_open(
    locale: ?[*:0]const u8,
    dialect_handling: UDialectHandling,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

pub extern "icu" fn uldn_close(
    ldn: ?*ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uldn_getLocale(
    ldn: ?*const ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uldn_getDialectHandling(
    ldn: ?*const ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) UDialectHandling;

pub extern "icu" fn uldn_localeDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    locale: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_languageDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    lang: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_scriptDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    script: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_scriptCodeDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    script_code: UScriptCode,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_regionDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    region: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_variantDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    variant: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_keyDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    key: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_keyValueDisplayName(
    ldn: ?*const ULocaleDisplayNames,
    key: ?[*:0]const u8,
    value: ?[*:0]const u8,
    result: ?*u16,
    max_result_size: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uldn_openForContext(
    locale: ?[*:0]const u8,
    contexts: ?*UDisplayContext,
    length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

pub extern "icu" fn uldn_getContext(
    ldn: ?*const ULocaleDisplayNames,
    type: UDisplayContextType,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn ucurr_forLocale(
    locale: ?[*:0]const u8,
    buff: ?*u16,
    buff_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_register(
    iso_code: ?*const u16,
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "icu" fn ucurr_unregister(
    key: ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucurr_getName(
    currency: ?*const u16,
    locale: ?[*:0]const u8,
    name_style: UCurrNameStyle,
    is_choice_format: ?*i8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucurr_getPluralName(
    currency: ?*const u16,
    locale: ?[*:0]const u8,
    is_choice_format: ?*i8,
    plural_count: ?[*:0]const u8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucurr_getDefaultFractionDigits(
    currency: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getDefaultFractionDigitsForUsage(
    currency: ?*const u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getRoundingIncrement(
    currency: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucurr_getRoundingIncrementForUsage(
    currency: ?*const u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucurr_openISOCurrencies(
    curr_type: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucurr_isAvailable(
    iso_code: ?*const u16,
    from: f64,
    to: f64,
    error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucurr_countCurrencies(
    locale: ?[*:0]const u8,
    date: f64,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_forLocaleAndDate(
    locale: ?[*:0]const u8,
    date: f64,
    index: i32,
    buff: ?*u16,
    buff_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucurr_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonly_used: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucurr_getNumericCode(
    currency: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucpmap_get(
    map: ?*const UCPMap,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucpmap_getRange(
    map: ?*const UCPMap,
    start: i32,
    option: UCPMapRangeOption,
    surrogate_value: u32,
    filter: ?*?UCPMapValueFilter,
    context: ?*const anyopaque,
    p_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucptrie_openFromBinary(
    type: UCPTrieType,
    value_width: UCPTrieValueWidth,
    data: ?*const anyopaque,
    length: i32,
    p_actual_length: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCPTrie;

pub extern "icu" fn ucptrie_close(
    trie: ?*UCPTrie,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucptrie_getType(
    trie: ?*const UCPTrie,
) callconv(@import("std").os.windows.WINAPI) UCPTrieType;

pub extern "icu" fn ucptrie_getValueWidth(
    trie: ?*const UCPTrie,
) callconv(@import("std").os.windows.WINAPI) UCPTrieValueWidth;

pub extern "icu" fn ucptrie_get(
    trie: ?*const UCPTrie,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucptrie_getRange(
    trie: ?*const UCPTrie,
    start: i32,
    option: UCPMapRangeOption,
    surrogate_value: u32,
    filter: ?*?UCPMapValueFilter,
    context: ?*const anyopaque,
    p_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucptrie_toBinary(
    trie: ?*const UCPTrie,
    data: ?*anyopaque,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucptrie_internalSmallIndex(
    trie: ?*const UCPTrie,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucptrie_internalSmallU8Index(
    trie: ?*const UCPTrie,
    lt1: i32,
    t2: u8,
    t3: u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucptrie_internalU8PrevIndex(
    trie: ?*const UCPTrie,
    c: i32,
    start: ?*const u8,
    src: ?*const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umutablecptrie_open(
    initial_value: u32,
    error_value: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UMutableCPTrie;

pub extern "icu" fn umutablecptrie_clone(
    other: ?*const UMutableCPTrie,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UMutableCPTrie;

pub extern "icu" fn umutablecptrie_close(
    trie: ?*UMutableCPTrie,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umutablecptrie_fromUCPMap(
    map: ?*const UCPMap,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UMutableCPTrie;

pub extern "icu" fn umutablecptrie_fromUCPTrie(
    trie: ?*const UCPTrie,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UMutableCPTrie;

pub extern "icu" fn umutablecptrie_get(
    trie: ?*const UMutableCPTrie,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn umutablecptrie_getRange(
    trie: ?*const UMutableCPTrie,
    start: i32,
    option: UCPMapRangeOption,
    surrogate_value: u32,
    filter: ?*?UCPMapValueFilter,
    context: ?*const anyopaque,
    p_value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umutablecptrie_set(
    trie: ?*UMutableCPTrie,
    c: i32,
    value: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umutablecptrie_setRange(
    trie: ?*UMutableCPTrie,
    start: i32,
    end: i32,
    value: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umutablecptrie_buildImmutable(
    trie: ?*UMutableCPTrie,
    type: UCPTrieType,
    value_width: UCPTrieValueWidth,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCPTrie;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_STOP(
    context: ?*const anyopaque,
    from_u_args: ?*UConverterFromUnicodeArgs,
    code_units: ?*const u16,
    length: i32,
    code_point: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_STOP(
    context: ?*const anyopaque,
    to_u_args: ?*UConverterToUnicodeArgs,
    code_units: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_SKIP(
    context: ?*const anyopaque,
    from_u_args: ?*UConverterFromUnicodeArgs,
    code_units: ?*const u16,
    length: i32,
    code_point: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_SUBSTITUTE(
    context: ?*const anyopaque,
    from_u_args: ?*UConverterFromUnicodeArgs,
    code_units: ?*const u16,
    length: i32,
    code_point: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_FROM_U_CALLBACK_ESCAPE(
    context: ?*const anyopaque,
    from_u_args: ?*UConverterFromUnicodeArgs,
    code_units: ?*const u16,
    length: i32,
    code_point: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_SKIP(
    context: ?*const anyopaque,
    to_u_args: ?*UConverterToUnicodeArgs,
    code_units: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_SUBSTITUTE(
    context: ?*const anyopaque,
    to_u_args: ?*UConverterToUnicodeArgs,
    code_units: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn UCNV_TO_U_CALLBACK_ESCAPE(
    context: ?*const anyopaque,
    to_u_args: ?*UConverterToUnicodeArgs,
    code_units: ?[*:0]const u8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_compareNames(
    name1: ?[*:0]const u8,
    name2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_open(
    converter_name: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openU(
    name: ?*const u16,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openCCSID(
    codepage: i32,
    platform: UConverterPlatform,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_openPackage(
    package_name: ?[*:0]const u8,
    converter_name: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_safeClone(
    cnv: ?*const UConverter,
    stack_buffer: ?*anyopaque,
    p_buffer_size: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

pub extern "icu" fn ucnv_close(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getSubstChars(
    converter: ?*const UConverter,
    sub_chars: ?PSTR,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setSubstChars(
    converter: ?*UConverter,
    sub_chars: ?[*:0]const u8,
    len: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setSubstString(
    cnv: ?*UConverter,
    s: ?*const u16,
    length: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getInvalidChars(
    converter: ?*const UConverter,
    err_bytes: ?PSTR,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getInvalidUChars(
    converter: ?*const UConverter,
    err_u_chars: ?*u16,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_reset(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_resetToUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_resetFromUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getMaxCharSize(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_getMinCharSize(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_getDisplayName(
    converter: ?*const UConverter,
    display_locale: ?[*:0]const u8,
    display_name: ?*u16,
    display_name_capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getName(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getCCSID(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getPlatform(
    converter: ?*const UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UConverterPlatform;

pub extern "icu" fn ucnv_getType(
    converter: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) UConverterType;

pub extern "icu" fn ucnv_getStarters(
    converter: ?*const UConverter,
    starters: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getUnicodeSet(
    cnv: ?*const UConverter,
    set_fill_in: ?*USet,
    which_set: UConverterUnicodeSet,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getToUCallBack(
    converter: ?*const UConverter,
    action: ?*?UConverterToUCallback,
    context: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_getFromUCallBack(
    converter: ?*const UConverter,
    action: ?*?UConverterFromUCallback,
    context: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setToUCallBack(
    converter: ?*UConverter,
    new_action: ?UConverterToUCallback,
    new_context: ?*const anyopaque,
    old_action: ?*?UConverterToUCallback,
    old_context: ?*const ?*anyopaque,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_setFromUCallBack(
    converter: ?*UConverter,
    new_action: ?UConverterFromUCallback,
    new_context: ?*const anyopaque,
    old_action: ?*?UConverterFromUCallback,
    old_context: ?*const ?*anyopaque,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fromUnicode(
    converter: ?*UConverter,
    target: ?*?*i8,
    target_limit: ?[*:0]const u8,
    source: ?*const ?*u16,
    source_limit: ?*const u16,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_toUnicode(
    converter: ?*UConverter,
    target: ?*?*u16,
    target_limit: ?*const u16,
    source: ?*const ?*i8,
    source_limit: ?[*:0]const u8,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fromUChars(
    cnv: ?*UConverter,
    dest: ?PSTR,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toUChars(
    cnv: ?*UConverter,
    dest: ?*u16,
    dest_capacity: i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getNextUChar(
    converter: ?*UConverter,
    source: ?*const ?*i8,
    source_limit: ?[*:0]const u8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_convertEx(
    target_cnv: ?*UConverter,
    source_cnv: ?*UConverter,
    target: ?*?*i8,
    target_limit: ?[*:0]const u8,
    source: ?*const ?*i8,
    source_limit: ?[*:0]const u8,
    pivot_start: ?*u16,
    pivot_source: ?*?*u16,
    pivot_target: ?*?*u16,
    pivot_limit: ?*const u16,
    reset: i8,
    flush: i8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_convert(
    to_converter_name: ?[*:0]const u8,
    from_converter_name: ?[*:0]const u8,
    target: ?PSTR,
    target_capacity: i32,
    source: ?[*:0]const u8,
    source_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toAlgorithmic(
    algorithmic_type: UConverterType,
    cnv: ?*UConverter,
    target: ?PSTR,
    target_capacity: i32,
    source: ?[*:0]const u8,
    source_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_fromAlgorithmic(
    cnv: ?*UConverter,
    algorithmic_type: UConverterType,
    target: ?PSTR,
    target_capacity: i32,
    source: ?[*:0]const u8,
    source_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_flushCache() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_getAvailableName(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_openAllNames(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnv_countAliases(
    alias: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "icu" fn ucnv_getAlias(
    alias: ?[*:0]const u8,
    n: u16,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getAliases(
    alias: ?[*:0]const u8,
    aliases: ?*const ?*i8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_openStandardNames(
    conv_name: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnv_countStandards() callconv(@import("std").os.windows.WINAPI) u16;

pub extern "icu" fn ucnv_getStandard(
    n: u16,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getStandardName(
    name: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getCanonicalName(
    alias: ?[*:0]const u8,
    standard: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_getDefaultName() callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_setDefaultName(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_fixFileSeparator(
    cnv: ?*const UConverter,
    source: ?*u16,
    source_len: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_isAmbiguous(
    cnv: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_setFallback(
    cnv: ?*UConverter,
    uses_fallback: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_usesFallback(
    cnv: ?*const UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_detectUnicodeSignature(
    source: ?[*:0]const u8,
    source_length: i32,
    signature_length: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucnv_fromUCountPending(
    cnv: ?*const UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_toUCountPending(
    cnv: ?*const UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnv_isFixedWidth(
    cnv: ?*UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucnv_cbFromUWriteBytes(
    args: ?*UConverterFromUnicodeArgs,
    source: ?[*:0]const u8,
    length: i32,
    offset_index: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbFromUWriteSub(
    args: ?*UConverterFromUnicodeArgs,
    offset_index: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbFromUWriteUChars(
    args: ?*UConverterFromUnicodeArgs,
    source: ?*const ?*u16,
    source_limit: ?*const u16,
    offset_index: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbToUWriteUChars(
    args: ?*UConverterToUnicodeArgs,
    source: ?*const u16,
    length: i32,
    offset_index: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnv_cbToUWriteSub(
    args: ?*UConverterToUnicodeArgs,
    offset_index: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_init(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_cleanup() callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_setMemoryFunctions(
    context: ?*const anyopaque,
    a: ?*?UMemAllocFn,
    r: ?*?UMemReallocFn,
    f: ?*?UMemFreeFn,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_catopen(
    name: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

pub extern "icu" fn u_catclose(
    catd: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_catgets(
    catd: ?*UResourceBundle,
    set_num: i32,
    msg_num: i32,
    s: ?*const u16,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_hasBinaryProperty(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_getBinaryPropertySet(
    property: UProperty,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn u_isUAlphabetic(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isULowercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isUUppercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isUWhiteSpace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_getIntPropertyValue(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getIntPropertyMinValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getIntPropertyMaxValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getIntPropertyMap(
    property: UProperty,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCPMap;

pub extern "icu" fn u_getNumericValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn u_islower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_istitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isalpha(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isalnum(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isxdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_ispunct(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isgraph(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isblank(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isdefined(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isspace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaSpaceChar(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isWhitespace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_iscntrl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isISOControl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isprint(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isbase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_charDirection(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub extern "icu" fn u_isMirrored(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_charMirror(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getBidiPairedBracket(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charType(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_enumCharTypes(
    enum_range: ?*?UCharEnumTypeRange,
    context: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getCombiningClass(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn u_charDigitValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ublock_getCode(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UBlockCode;

pub extern "icu" fn u_charName(
    code: i32,
    name_choice: UCharNameChoice,
    buffer: ?PSTR,
    buffer_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charFromName(
    name_choice: UCharNameChoice,
    name: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_enumCharNames(
    start: i32,
    limit: i32,
    @"fn": ?*?UEnumCharNamesFn,
    context: ?*anyopaque,
    name_choice: UCharNameChoice,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getPropertyName(
    property: UProperty,
    name_choice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_getPropertyEnum(
    alias: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) UProperty;

pub extern "icu" fn u_getPropertyValueName(
    property: UProperty,
    value: i32,
    name_choice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_getPropertyValueEnum(
    property: UProperty,
    alias: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_isIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isIDIgnorable(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_isJavaIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_tolower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_toupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_totitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_foldCase(
    c: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_digit(
    ch: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_forDigit(
    digit: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_charAge(
    c: i32,
    version_array: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getUnicodeVersion(
    version_array: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_getFC_NFKC_Closure(
    c: i32,
    dest: ?*u16,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_open() callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

pub extern "icu" fn ubidi_openSized(
    max_length: i32,
    max_run_count: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

pub extern "icu" fn ubidi_close(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setInverse(
    p_bi_di: ?*UBiDi,
    is_inverse: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_isInverse(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubidi_orderParagraphsLTR(
    p_bi_di: ?*UBiDi,
    order_paragraphs_l_t_r: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_isOrderParagraphsLTR(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubidi_setReorderingMode(
    p_bi_di: ?*UBiDi,
    reordering_mode: UBiDiReorderingMode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getReorderingMode(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiReorderingMode;

pub extern "icu" fn ubidi_setReorderingOptions(
    p_bi_di: ?*UBiDi,
    reordering_options: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getReorderingOptions(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ubidi_setContext(
    p_bi_di: ?*UBiDi,
    prologue: ?*const u16,
    pro_length: i32,
    epilogue: ?*const u16,
    epi_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setPara(
    p_bi_di: ?*UBiDi,
    text: ?*const u16,
    length: i32,
    para_level: u8,
    embedding_levels: ?*u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_setLine(
    p_para_bi_di: ?*const UBiDi,
    start: i32,
    limit: i32,
    p_line_bi_di: ?*UBiDi,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getDirection(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getBaseDirection(
    text: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getText(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ubidi_getLength(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParaLevel(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn ubidi_countParagraphs(
    p_bi_di: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParagraph(
    p_bi_di: ?*const UBiDi,
    char_index: i32,
    p_para_start: ?*i32,
    p_para_limit: ?*i32,
    p_para_level: ?*u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getParagraphByIndex(
    p_bi_di: ?*const UBiDi,
    para_index: i32,
    p_para_start: ?*i32,
    p_para_limit: ?*i32,
    p_para_level: ?*u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getLevelAt(
    p_bi_di: ?*const UBiDi,
    char_index: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn ubidi_getLevels(
    p_bi_di: ?*UBiDi,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "icu" fn ubidi_getLogicalRun(
    p_bi_di: ?*const UBiDi,
    logical_position: i32,
    p_logical_limit: ?*i32,
    p_level: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_countRuns(
    p_bi_di: ?*UBiDi,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getVisualRun(
    p_bi_di: ?*UBiDi,
    run_index: i32,
    p_logical_start: ?*i32,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

pub extern "icu" fn ubidi_getVisualIndex(
    p_bi_di: ?*UBiDi,
    logical_index: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getLogicalIndex(
    p_bi_di: ?*UBiDi,
    visual_index: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getLogicalMap(
    p_bi_di: ?*UBiDi,
    index_map: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getVisualMap(
    p_bi_di: ?*UBiDi,
    index_map: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_reorderLogical(
    levels: ?*const u8,
    length: i32,
    index_map: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_reorderVisual(
    levels: ?*const u8,
    length: i32,
    index_map: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_invertMap(
    src_map: ?*const i32,
    dest_map: ?*i32,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getProcessedLength(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getResultLength(
    p_bi_di: ?*const UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_getCustomizedClass(
    p_bi_di: ?*UBiDi,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

pub extern "icu" fn ubidi_setClassCallback(
    p_bi_di: ?*UBiDi,
    new_fn: ?UBiDiClassCallback,
    new_context: ?*const anyopaque,
    old_fn: ?*?UBiDiClassCallback,
    old_context: ?*const ?*anyopaque,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_getClassCallback(
    p_bi_di: ?*UBiDi,
    @"fn": ?*?UBiDiClassCallback,
    context: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubidi_writeReordered(
    p_bi_di: ?*UBiDi,
    dest: ?*u16,
    dest_size: i32,
    options: u16,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubidi_writeReverse(
    src: ?*const u16,
    src_length: i32,
    dest: ?*u16,
    dest_size: i32,
    options: u16,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubiditransform_transform(
    p_bi_di_transform: ?*UBiDiTransform,
    src: ?*const u16,
    src_length: i32,
    dest: ?*u16,
    dest_size: i32,
    in_para_level: u8,
    in_order: UBiDiOrder,
    out_para_level: u8,
    out_order: UBiDiOrder,
    do_mirroring: UBiDiMirroring,
    shaping_options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ubiditransform_open(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDiTransform;

pub extern "icu" fn ubiditransform_close(
    p_bidi_transform: ?*UBiDiTransform,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_close(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_openUTF8(
    ut: ?*UText,
    s: ?[*:0]const u8,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_openUChars(
    ut: ?*UText,
    s: ?*const u16,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_clone(
    dest: ?*UText,
    src: ?*const UText,
    deep: i8,
    read_only: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn utext_equals(
    a: ?*const UText,
    b: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_nativeLength(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_isLengthExpensive(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_char32At(
    ut: ?*UText,
    native_index: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_current32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_next32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_previous32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_next32From(
    ut: ?*UText,
    native_index: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_previous32From(
    ut: ?*UText,
    native_index: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_getNativeIndex(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_setNativeIndex(
    ut: ?*UText,
    native_index: i64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_moveIndex32(
    ut: ?*UText,
    delta: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_getPreviousNativeIndex(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utext_extract(
    ut: ?*UText,
    native_start: i64,
    native_limit: i64,
    dest: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_isWritable(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_hasMetaData(
    ut: ?*const UText,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn utext_replace(
    ut: ?*UText,
    native_start: i64,
    native_limit: i64,
    replacement_text: ?*const u16,
    replacement_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utext_copy(
    ut: ?*UText,
    native_start: i64,
    native_limit: i64,
    dest_index: i64,
    move: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_freeze(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utext_setup(
    ut: ?*UText,
    extra_space: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uset_openEmpty() callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_open(
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_openPattern(
    pattern: ?*const u16,
    pattern_length: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_openPatternOptions(
    pattern: ?*const u16,
    pattern_length: i32,
    options: u32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_close(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_clone(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_isFrozen(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_freeze(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_cloneAsThawed(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uset_set(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_applyPattern(
    set: ?*USet,
    pattern: ?*const u16,
    pattern_length: i32,
    options: u32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_applyIntPropertyValue(
    set: ?*USet,
    prop: UProperty,
    value: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_applyPropertyAlias(
    set: ?*USet,
    prop: ?*const u16,
    prop_length: i32,
    value: ?*const u16,
    value_length: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_resemblesPattern(
    pattern: ?*const u16,
    pattern_length: i32,
    pos: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_toPattern(
    set: ?*const USet,
    result: ?*u16,
    result_capacity: i32,
    escape_unprintable: i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_add(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addAll(
    set: ?*USet,
    additional_set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addString(
    set: ?*USet,
    str: ?*const u16,
    str_len: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_addAllCodePoints(
    set: ?*USet,
    str: ?*const u16,
    str_len: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_remove(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeString(
    set: ?*USet,
    str: ?*const u16,
    str_len: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeAll(
    set: ?*USet,
    remove_set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_retain(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_retainAll(
    set: ?*USet,
    retain: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_compact(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_complement(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_complementAll(
    set: ?*USet,
    complement: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_clear(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_closeOver(
    set: ?*USet,
    attributes: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_removeAllStrings(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_isEmpty(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_contains(
    set: ?*const USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsRange(
    set: ?*const USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsString(
    set: ?*const USet,
    str: ?*const u16,
    str_len: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_indexOf(
    set: ?*const USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_charAt(
    set: ?*const USet,
    char_index: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_size(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getItemCount(
    set: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getItem(
    set: ?*const USet,
    item_index: i32,
    start: ?*i32,
    end: ?*i32,
    str: ?*u16,
    str_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_containsAll(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsAllCodePoints(
    set: ?*const USet,
    str: ?*const u16,
    str_len: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsNone(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_containsSome(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_span(
    set: ?*const USet,
    s: ?*const u16,
    length: i32,
    span_condition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanBack(
    set: ?*const USet,
    s: ?*const u16,
    length: i32,
    span_condition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanUTF8(
    set: ?*const USet,
    s: ?[*:0]const u8,
    length: i32,
    span_condition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_spanBackUTF8(
    set: ?*const USet,
    s: ?[*:0]const u8,
    length: i32,
    span_condition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_equals(
    set1: ?*const USet,
    set2: ?*const USet,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_serialize(
    set: ?*const USet,
    dest: ?*u16,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getSerializedSet(
    fill_set: ?*USerializedSet,
    src: ?*const u16,
    src_length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_setSerializedToOne(
    fill_set: ?*USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uset_serializedContains(
    set: ?*const USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uset_getSerializedRangeCount(
    set: ?*const USerializedSet,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uset_getSerializedRange(
    set: ?*const USerializedSet,
    range_index: i32,
    p_start: ?*i32,
    p_end: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_getNFCInstance(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFDInstance(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKCInstance(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKDInstance(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getNFKCCasefoldInstance(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_getInstance(
    package_name: ?[*:0]const u8,
    name: ?[*:0]const u8,
    mode: UNormalization2Mode,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_openFiltered(
    norm2: ?*const UNormalizer2,
    filter_set: ?*const USet,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

pub extern "icu" fn unorm2_close(
    norm2: ?*UNormalizer2,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unorm2_normalize(
    norm2: ?*const UNormalizer2,
    src: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_normalizeSecondAndAppend(
    norm2: ?*const UNormalizer2,
    first: ?*u16,
    first_length: i32,
    first_capacity: i32,
    second: ?*const u16,
    second_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_append(
    norm2: ?*const UNormalizer2,
    first: ?*u16,
    first_length: i32,
    first_capacity: i32,
    second: ?*const u16,
    second_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getDecomposition(
    norm2: ?*const UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getRawDecomposition(
    norm2: ?*const UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_composePair(
    norm2: ?*const UNormalizer2,
    a: i32,
    b: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_getCombiningClass(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "icu" fn unorm2_isNormalized(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_quickCheck(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UNormalizationCheckResult;

pub extern "icu" fn unorm2_spanQuickCheckYes(
    norm2: ?*const UNormalizer2,
    s: ?*const u16,
    length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unorm2_hasBoundaryBefore(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_hasBoundaryAfter(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm2_isInert(
    norm2: ?*const UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unorm_compare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnvsel_open(
    converter_list: ?*const ?*i8,
    converter_list_size: i32,
    excluded_code_points: ?*const USet,
    which_set: UConverterUnicodeSet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

pub extern "icu" fn ucnvsel_close(
    sel: ?*UConverterSelector,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucnvsel_openFromSerialized(
    buffer: ?*const anyopaque,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

pub extern "icu" fn ucnvsel_serialize(
    sel: ?*const UConverterSelector,
    buffer: ?*anyopaque,
    buffer_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucnvsel_selectForString(
    sel: ?*const UConverterSelector,
    s: ?*const u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucnvsel_selectForUTF8(
    sel: ?*const UConverterSelector,
    s: ?[*:0]const u8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn u_charsToUChars(
    cs: ?[*:0]const u8,
    us: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_UCharsToChars(
    us: ?*const u16,
    cs: ?PSTR,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_strlen(
    s: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_countChar32(
    s: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strHasMoreChar32Than(
    s: ?*const u16,
    length: i32,
    number: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn u_strcat(
    dst: ?*u16,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strncat(
    dst: ?*u16,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strstr(
    s: ?*const u16,
    substring: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFindFirst(
    s: ?*const u16,
    length: i32,
    substring: ?*const u16,
    sub_length: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strchr(
    s: ?*const u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strchr32(
    s: ?*const u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrstr(
    s: ?*const u16,
    substring: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFindLast(
    s: ?*const u16,
    length: i32,
    substring: ?*const u16,
    sub_length: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrchr(
    s: ?*const u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strrchr32(
    s: ?*const u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strpbrk(
    string: ?*const u16,
    match_set: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strcspn(
    string: ?*const u16,
    match_set: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strspn(
    string: ?*const u16,
    match_set: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strtok_r(
    src: ?*u16,
    delim: ?*const u16,
    save_state: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strcmp(
    s1: ?*const u16,
    s2: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCompare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    code_point_order: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCompareIter(
    iter1: ?*UCharIterator,
    iter2: ?*UCharIterator,
    code_point_order: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strCaseCompare(
    s1: ?*const u16,
    length1: i32,
    s2: ?*const u16,
    length2: i32,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncmp(
    ucs1: ?*const u16,
    ucs2: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strncasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    n: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memcasecmp(
    s1: ?*const u16,
    s2: ?*const u16,
    length: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strcpy(
    dst: ?*u16,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strncpy(
    dst: ?*u16,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_uastrcpy(
    dst: ?*u16,
    src: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_uastrncpy(
    dst: ?*u16,
    src: ?[*:0]const u8,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_austrcpy(
    dst: ?PSTR,
    src: ?*const u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_austrncpy(
    dst: ?PSTR,
    src: ?*const u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_memcpy(
    dest: ?*u16,
    src: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memmove(
    dest: ?*u16,
    src: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memset(
    dest: ?*u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memcmp(
    buf1: ?*const u16,
    buf2: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memcmpCodePointOrder(
    s1: ?*const u16,
    s2: ?*const u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_memchr(
    s: ?*const u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memchr32(
    s: ?*const u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memrchr(
    s: ?*const u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_memrchr32(
    s: ?*const u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_unescape(
    src: ?[*:0]const u8,
    dest: ?*u16,
    dest_capacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_unescapeAt(
    char_at: ?UNESCAPE_CHAR_AT,
    offset: ?*i32,
    length: i32,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToUpper(
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    locale: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToLower(
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    locale: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToTitle(
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    title_iter: ?*UBreakIterator,
    locale: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strFoldCase(
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_strToWCS(
    dest: ?PWSTR,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "icu" fn u_strFromWCS(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?[*:0]const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF8(
    dest: ?PSTR,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromUTF8(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF8WithSub(
    dest: ?PSTR,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    subchar: i32,
    p_num_substitutions: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromUTF8WithSub(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?[*:0]const u8,
    src_length: i32,
    subchar: i32,
    p_num_substitutions: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strFromUTF8Lenient(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF32(
    dest: ?*i32,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn u_strFromUTF32(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const i32,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToUTF32WithSub(
    dest: ?*i32,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    subchar: i32,
    p_num_substitutions: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

pub extern "icu" fn u_strFromUTF32WithSub(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const i32,
    src_length: i32,
    subchar: i32,
    p_num_substitutions: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn u_strToJavaModifiedUTF8(
    dest: ?PSTR,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn u_strFromJavaModifiedUTF8WithSub(
    dest: ?*u16,
    dest_capacity: i32,
    p_dest_length: ?*i32,
    src: ?[*:0]const u8,
    src_length: i32,
    subchar: i32,
    p_num_substitutions: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucasemap_open(
    locale: ?[*:0]const u8,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCaseMap;

pub extern "icu" fn ucasemap_close(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_getLocale(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucasemap_getOptions(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucasemap_setLocale(
    csm: ?*UCaseMap,
    locale: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_setOptions(
    csm: ?*UCaseMap,
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_getBreakIterator(
    csm: ?*const UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ucasemap_setBreakIterator(
    csm: ?*UCaseMap,
    iter_to_adopt: ?*UBreakIterator,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucasemap_toTitle(
    csm: ?*UCaseMap,
    dest: ?*u16,
    dest_capacity: i32,
    src: ?*const u16,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToLower(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    dest_capacity: i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToUpper(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    dest_capacity: i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8ToTitle(
    csm: ?*UCaseMap,
    dest: ?PSTR,
    dest_capacity: i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucasemap_utf8FoldCase(
    csm: ?*const UCaseMap,
    dest: ?PSTR,
    dest_capacity: i32,
    src: ?[*:0]const u8,
    src_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usprep_open(
    path: ?[*:0]const u8,
    file_name: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

pub extern "icu" fn usprep_openByType(
    type: UStringPrepProfileType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

pub extern "icu" fn usprep_close(
    profile: ?*UStringPrepProfile,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usprep_prepare(
    prep: ?*const UStringPrepProfile,
    src: ?*const u16,
    src_length: i32,
    dest: ?*u16,
    dest_capacity: i32,
    options: i32,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_openUTS46(
    options: u32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UIDNA;

pub extern "icu" fn uidna_close(
    idna: ?*UIDNA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uidna_labelToASCII(
    idna: ?*const UIDNA,
    label: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToUnicode(
    idna: ?*const UIDNA,
    label: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToASCII(
    idna: ?*const UIDNA,
    name: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToUnicode(
    idna: ?*const UIDNA,
    name: ?*const u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToASCII_UTF8(
    idna: ?*const UIDNA,
    label: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_labelToUnicodeUTF8(
    idna: ?*const UIDNA,
    label: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToASCII_UTF8(
    idna: ?*const UIDNA,
    name: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uidna_nameToUnicodeUTF8(
    idna: ?*const UIDNA,
    name: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    capacity: i32,
    p_info: ?*UIDNAInfo,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_open(
    type: UBreakIteratorType,
    locale: ?[*:0]const u8,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_openRules(
    rules: ?*const u16,
    rules_length: i32,
    text: ?*const u16,
    text_length: i32,
    parse_err: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_openBinaryRules(
    binary_rules: ?*const u8,
    rules_length: i32,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_safeClone(
    bi: ?*const UBreakIterator,
    stack_buffer: ?*anyopaque,
    p_buffer_size: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn ubrk_close(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_setText(
    bi: ?*UBreakIterator,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_setUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_current(
    bi: ?*const UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_next(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_previous(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_first(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_last(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_preceding(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_following(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getAvailable(
    index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ubrk_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_isBoundary(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ubrk_getRuleStatus(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getRuleStatusVec(
    bi: ?*UBreakIterator,
    fill_in_vec: ?*i32,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ubrk_getLocaleByType(
    bi: ?*const UBreakIterator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ubrk_refreshUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ubrk_getBinaryRules(
    bi: ?*UBreakIterator,
    binary_rules: ?*u8,
    rules_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_getDataVersion(
    data_version_fillin: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_openTimeZoneIDEnumeration(
    zone_type: USystemTimeZoneType,
    region: ?[*:0]const u8,
    raw_offset: ?*const i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_openTimeZones(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_openCountryTimeZones(
    country: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_getDefaultTimeZone(
    result: ?*u16,
    result_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_setDefaultTimeZone(
    zone_i_d: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getHostTimeZone(
    result: ?*u16,
    result_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getDSTSavings(
    zone_i_d: ?*const u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getNow() callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_open(
    zone_i_d: ?*const u16,
    len: i32,
    locale: ?[*:0]const u8,
    type: UCalendarType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn ucal_close(
    cal: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_clone(
    cal: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn ucal_setTimeZone(
    cal: ?*?*anyopaque,
    zone_i_d: ?*const u16,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getTimeZoneID(
    cal: ?*const ?*anyopaque,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneDisplayName(
    cal: ?*const ?*anyopaque,
    type: UCalendarDisplayNameType,
    locale: ?[*:0]const u8,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_inDaylightTime(
    cal: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_setGregorianChange(
    cal: ?*?*anyopaque,
    date: f64,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getGregorianChange(
    cal: ?*const ?*anyopaque,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_getAttribute(
    cal: ?*const ?*anyopaque,
    attr: UCalendarAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_setAttribute(
    cal: ?*?*anyopaque,
    attr: UCalendarAttribute,
    new_value: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getAvailable(
    locale_index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getMillis(
    cal: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ucal_setMillis(
    cal: ?*?*anyopaque,
    date_time: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_setDate(
    cal: ?*?*anyopaque,
    year: i32,
    month: i32,
    date: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_setDateTime(
    cal: ?*?*anyopaque,
    year: i32,
    month: i32,
    date: i32,
    hour: i32,
    minute: i32,
    second: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_equivalentTo(
    cal1: ?*const ?*anyopaque,
    cal2: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_add(
    cal: ?*?*anyopaque,
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_roll(
    cal: ?*?*anyopaque,
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_get(
    cal: ?*const ?*anyopaque,
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_set(
    cal: ?*?*anyopaque,
    field: UCalendarDateFields,
    value: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_isSet(
    cal: ?*const ?*anyopaque,
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_clearField(
    cal: ?*?*anyopaque,
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_clear(
    calendar: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucal_getLimit(
    cal: ?*const ?*anyopaque,
    field: UCalendarDateFields,
    type: UCalendarLimitType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getLocaleByType(
    cal: ?*const ?*anyopaque,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getTZDataVersion(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getCanonicalTimeZoneID(
    id: ?*const u16,
    len: i32,
    result: ?*u16,
    result_capacity: i32,
    is_system_i_d: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getType(
    cal: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucal_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonly_used: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucal_getDayOfWeekType(
    cal: ?*const ?*anyopaque,
    day_of_week: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCalendarWeekdayType;

pub extern "icu" fn ucal_getWeekendTransition(
    cal: ?*const ?*anyopaque,
    day_of_week: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_isWeekend(
    cal: ?*const ?*anyopaque,
    date: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_getFieldDifference(
    cal: ?*?*anyopaque,
    target: f64,
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneTransitionDate(
    cal: ?*const ?*anyopaque,
    type: UTimeZoneTransitionType,
    transition: ?*f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucal_getWindowsTimeZoneID(
    id: ?*const u16,
    len: i32,
    winid: ?*u16,
    winid_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucal_getTimeZoneIDForWindowsID(
    winid: ?*const u16,
    len: i32,
    region: ?[*:0]const u8,
    id: ?*u16,
    id_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_open(
    loc: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_openRules(
    rules: ?*const u16,
    rules_length: i32,
    normalization_mode: UColAttributeValue,
    strength: UColAttributeValue,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_getContractionsAndExpansions(
    coll: ?*const UCollator,
    contractions: ?*USet,
    expansions: ?*USet,
    add_prefixes: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_close(
    coll: ?*UCollator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_strcoll(
    coll: ?*const UCollator,
    source: ?*const u16,
    source_length: i32,
    target: ?*const u16,
    target_length: i32,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_strcollUTF8(
    coll: ?*const UCollator,
    source: ?[*:0]const u8,
    source_length: i32,
    target: ?[*:0]const u8,
    target_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_greater(
    coll: ?*const UCollator,
    source: ?*const u16,
    source_length: i32,
    target: ?*const u16,
    target_length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_greaterOrEqual(
    coll: ?*const UCollator,
    source: ?*const u16,
    source_length: i32,
    target: ?*const u16,
    target_length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_equal(
    coll: ?*const UCollator,
    source: ?*const u16,
    source_length: i32,
    target: ?*const u16,
    target_length: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucol_strcollIter(
    coll: ?*const UCollator,
    s_iter: ?*UCharIterator,
    t_iter: ?*UCharIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

pub extern "icu" fn ucol_getStrength(
    coll: ?*const UCollator,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

pub extern "icu" fn ucol_setStrength(
    coll: ?*UCollator,
    strength: UColAttributeValue,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getReorderCodes(
    coll: ?*const UCollator,
    dest: ?*i32,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setReorderCodes(
    coll: ?*UCollator,
    reorder_codes: ?*const i32,
    reorder_codes_length: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getEquivalentReorderCodes(
    reorder_code: i32,
    dest: ?*i32,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getDisplayName(
    obj_loc: ?[*:0]const u8,
    disp_loc: ?[*:0]const u8,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getAvailable(
    locale_index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucol_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_openAvailableLocales(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywords(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywordValues(
    keyword: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getKeywordValuesForLocale(
    key: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    commonly_used: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucol_getFunctionalEquivalent(
    result: ?PSTR,
    result_capacity: i32,
    keyword: ?[*:0]const u8,
    locale: ?[*:0]const u8,
    is_available: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getRules(
    coll: ?*const UCollator,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ucol_getSortKey(
    coll: ?*const UCollator,
    source: ?*const u16,
    source_length: i32,
    result: ?*u8,
    result_length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_nextSortKeyPart(
    coll: ?*const UCollator,
    iter: ?*UCharIterator,
    state: ?*u32,
    dest: ?*u8,
    count: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getBound(
    source: ?*const u8,
    source_length: i32,
    bound_type: UColBoundMode,
    no_of_levels: u32,
    result: ?*u8,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getVersion(
    coll: ?*const UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getUCAVersion(
    coll: ?*const UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_mergeSortkeys(
    src1: ?*const u8,
    src1_length: i32,
    src2: ?*const u8,
    src2_length: i32,
    dest: ?*u8,
    dest_capacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setAttribute(
    coll: ?*UCollator,
    attr: UColAttribute,
    value: UColAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getAttribute(
    coll: ?*const UCollator,
    attr: UColAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

pub extern "icu" fn ucol_setMaxVariable(
    coll: ?*UCollator,
    group: UColReorderCode,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getMaxVariable(
    coll: ?*const UCollator,
) callconv(@import("std").os.windows.WINAPI) UColReorderCode;

pub extern "icu" fn ucol_getVariableTop(
    coll: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "icu" fn ucol_safeClone(
    coll: ?*const UCollator,
    stack_buffer: ?*anyopaque,
    p_buffer_size: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_getRulesEx(
    coll: ?*const UCollator,
    delta: UColRuleOption,
    buffer: ?*u16,
    buffer_len: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getLocaleByType(
    coll: ?*const UCollator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucol_getTailoredSet(
    coll: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn ucol_cloneBinary(
    coll: ?*const UCollator,
    buffer: ?*u8,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_openBinary(
    bin: ?*const u8,
    length: i32,
    base: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn ucol_openElements(
    coll: ?*const UCollator,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollationElements;

pub extern "icu" fn ucol_keyHashCode(
    key: ?*const u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_closeElements(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_reset(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_next(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_previous(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_getMaxExpansion(
    elems: ?*const UCollationElements,
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setText(
    elems: ?*UCollationElements,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_getOffset(
    elems: ?*const UCollationElements,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_setOffset(
    elems: ?*UCollationElements,
    offset: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucol_primaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_secondaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucol_tertiaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetDetector;

pub extern "icu" fn ucsdet_close(
    ucsd: ?*UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_setText(
    ucsd: ?*UCharsetDetector,
    text_in: ?[*:0]const u8,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_setDeclaredEncoding(
    ucsd: ?*UCharsetDetector,
    encoding: ?[*:0]const u8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucsdet_detect(
    ucsd: ?*UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetMatch;

pub extern "icu" fn ucsdet_detectAll(
    ucsd: ?*UCharsetDetector,
    matches_found: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*UCharsetMatch;

pub extern "icu" fn ucsdet_getName(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucsdet_getConfidence(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_getLanguage(
    ucsm: ?*const UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucsdet_getUChars(
    ucsm: ?*const UCharsetMatch,
    buf: ?*u16,
    cap: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucsdet_getAllDetectableCharsets(
    ucsd: ?*const UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn ucsdet_isInputFilterEnabled(
    ucsd: ?*const UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucsdet_enableInputFilter(
    ucsd: ?*UCharsetDetector,
    filter: i8,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ufieldpositer_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFieldPositionIterator;

pub extern "icu" fn ufieldpositer_close(
    fpositer: ?*UFieldPositionIterator,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ufieldpositer_next(
    fpositer: ?*UFieldPositionIterator,
    begin_index: ?*i32,
    end_index: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn ufmt_close(
    fmt: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ufmt_getType(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UFormattableType;

pub extern "icu" fn ufmt_isNumeric(
    fmt: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ufmt_getDate(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ufmt_getDouble(
    fmt: ?*?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn ufmt_getLong(
    fmt: ?*?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_getInt64(
    fmt: ?*?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn ufmt_getObject(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "icu" fn ufmt_getUChars(
    fmt: ?*?*anyopaque,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ufmt_getArrayLength(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ufmt_getArrayItemByIndex(
    fmt: ?*?*anyopaque,
    n: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn ufmt_getDecNumChars(
    fmt: ?*?*anyopaque,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn ucfpos_open(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConstrainedFieldPosition;

pub extern "icu" fn ucfpos_reset(
    ucfpos: ?*UConstrainedFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_close(
    ucfpos: ?*UConstrainedFieldPosition,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_constrainCategory(
    ucfpos: ?*UConstrainedFieldPosition,
    category: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_constrainField(
    ucfpos: ?*UConstrainedFieldPosition,
    category: i32,
    field: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_getCategory(
    ucfpos: ?*const UConstrainedFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucfpos_getField(
    ucfpos: ?*const UConstrainedFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ucfpos_getIndexes(
    ucfpos: ?*const UConstrainedFieldPosition,
    p_start: ?*i32,
    p_limit: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_getInt64IterationContext(
    ucfpos: ?*const UConstrainedFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn ucfpos_setInt64IterationContext(
    ucfpos: ?*UConstrainedFieldPosition,
    context: i64,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ucfpos_matchesField(
    ucfpos: ?*const UConstrainedFieldPosition,
    category: i32,
    field: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ucfpos_setState(
    ucfpos: ?*UConstrainedFieldPosition,
    category: i32,
    field: i32,
    start: i32,
    limit: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ufmtval_getString(
    ufmtval: ?*const UFormattedValue,
    p_length: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn ufmtval_nextPosition(
    ufmtval: ?*const UFormattedValue,
    ucfpos: ?*UConstrainedFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udtitvfmt_open(
    locale: ?[*:0]const u8,
    skeleton: ?*const u16,
    skeleton_length: i32,
    tz_i_d: ?*const u16,
    tz_i_d_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UDateIntervalFormat;

pub extern "icu" fn udtitvfmt_close(
    formatter: ?*UDateIntervalFormat,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udtitvfmt_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedDateInterval;

pub extern "icu" fn udtitvfmt_resultAsValue(
    uresult: ?*const UFormattedDateInterval,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedValue;

pub extern "icu" fn udtitvfmt_closeResult(
    uresult: ?*UFormattedDateInterval,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udtitvfmt_format(
    formatter: ?*const UDateIntervalFormat,
    from_date: f64,
    to_date: f64,
    result: ?*u16,
    result_capacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ugender_getInstance(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UGenderInfo;

pub extern "icu" fn ugender_getListGender(
    gender_info: ?*const UGenderInfo,
    genders: ?*const UGender,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UGender;

pub extern "icu" fn ulistfmt_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UListFormatter;

pub extern "icu" fn ulistfmt_openForType(
    locale: ?[*:0]const u8,
    type: UListFormatterType,
    width: UListFormatterWidth,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UListFormatter;

pub extern "icu" fn ulistfmt_close(
    listfmt: ?*UListFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulistfmt_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedList;

pub extern "icu" fn ulistfmt_resultAsValue(
    uresult: ?*const UFormattedList,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedValue;

pub extern "icu" fn ulistfmt_closeResult(
    uresult: ?*UFormattedList,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulistfmt_format(
    listfmt: ?*const UListFormatter,
    strings: ?*const ?*u16,
    string_lengths: ?*const i32,
    string_count: i32,
    result: ?*u16,
    result_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulistfmt_formatStringsToResult(
    listfmt: ?*const UListFormatter,
    strings: ?*const ?*u16,
    string_lengths: ?*const i32,
    string_count: i32,
    uresult: ?*UFormattedList,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_open(
    locale_i_d: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleData;

pub extern "icu" fn ulocdata_close(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_setNoSubstitute(
    uld: ?*ULocaleData,
    setting: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getNoSubstitute(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn ulocdata_getExemplarSet(
    uld: ?*ULocaleData,
    fill_in: ?*USet,
    options: u32,
    extype: ULocaleDataExemplarSetType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn ulocdata_getDelimiter(
    uld: ?*ULocaleData,
    type: ULocaleDataDelimiterType,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulocdata_getMeasurementSystem(
    locale_i_d: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UMeasurementSystem;

pub extern "icu" fn ulocdata_getPaperSize(
    locale_i_d: ?[*:0]const u8,
    height: ?*i32,
    width: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getCLDRVersion(
    version_array: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ulocdata_getLocaleDisplayPattern(
    uld: ?*ULocaleData,
    pattern: ?*u16,
    pattern_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ulocdata_getLocaleSeparator(
    uld: ?*ULocaleData,
    separator: ?*u16,
    separator_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_formatMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_vformatMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    result: ?*u16,
    result_length: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_parseMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    source: ?*const u16,
    source_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_vparseMessage(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    source: ?*const u16,
    source_length: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_formatMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    result: ?*u16,
    result_length: i32,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_vformatMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    result: ?*u16,
    result_length: i32,
    parse_error: ?*UParseError,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn u_parseMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    source: ?*const u16,
    source_length: i32,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn u_vparseMessageWithError(
    locale: ?[*:0]const u8,
    pattern: ?*const u16,
    pattern_length: i32,
    source: ?*const u16,
    source_length: i32,
    ap: ?*i8,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_open(
    pattern: ?*const u16,
    pattern_length: i32,
    locale: ?[*:0]const u8,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn umsg_close(
    format: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_clone(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "icu" fn umsg_setLocale(
    fmt: ?*?*anyopaque,
    locale: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_getLocale(
    fmt: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn umsg_applyPattern(
    fmt: ?*?*anyopaque,
    pattern: ?*const u16,
    pattern_length: i32,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_toPattern(
    fmt: ?*const ?*anyopaque,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_format(
    fmt: ?*const ?*anyopaque,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_vformat(
    fmt: ?*const ?*anyopaque,
    result: ?*u16,
    result_length: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn umsg_parse(
    fmt: ?*const ?*anyopaque,
    source: ?*const u16,
    source_length: i32,
    count: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_vparse(
    fmt: ?*const ?*anyopaque,
    source: ?*const u16,
    source_length: i32,
    count: ?*i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn umsg_autoQuoteApostrophe(
    pattern: ?*const u16,
    pattern_length: i32,
    dest: ?*u16,
    dest_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_open(
    style: UNumberFormatStyle,
    pattern: ?*const u16,
    pattern_length: i32,
    locale: ?[*:0]const u8,
    parse_err: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn unum_close(
    fmt: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_clone(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn unum_format(
    fmt: ?*const ?*anyopaque,
    number: i32,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatInt64(
    fmt: ?*const ?*anyopaque,
    number: i64,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDouble(
    fmt: ?*const ?*anyopaque,
    number: f64,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDoubleForFields(
    format: ?*const ?*anyopaque,
    number: f64,
    result: ?*u16,
    result_length: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDecimal(
    fmt: ?*const ?*anyopaque,
    number: ?[*:0]const u8,
    length: i32,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatDoubleCurrency(
    fmt: ?*const ?*anyopaque,
    number: f64,
    currency: ?*u16,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_formatUFormattable(
    fmt: ?*const ?*anyopaque,
    number: ?*const ?*anyopaque,
    result: ?*u16,
    result_length: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parse(
    fmt: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parseInt64(
    fmt: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn unum_parseDouble(
    fmt: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_parseDecimal(
    fmt: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    out_buf: ?PSTR,
    out_buf_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_parseDoubleCurrency(
    fmt: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    currency: ?*u16,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_parseToUFormattable(
    fmt: ?*const ?*anyopaque,
    result: ?*?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn unum_applyPattern(
    format: ?*?*anyopaque,
    localized: i8,
    pattern: ?*const u16,
    pattern_length: i32,
    parse_error: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getAvailable(
    locale_index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unum_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_getAttribute(
    fmt: ?*const ?*anyopaque,
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setAttribute(
    fmt: ?*?*anyopaque,
    attr: UNumberFormatAttribute,
    new_value: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getDoubleAttribute(
    fmt: ?*const ?*anyopaque,
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn unum_setDoubleAttribute(
    fmt: ?*?*anyopaque,
    attr: UNumberFormatAttribute,
    new_value: f64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getTextAttribute(
    fmt: ?*const ?*anyopaque,
    tag: UNumberFormatTextAttribute,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setTextAttribute(
    fmt: ?*?*anyopaque,
    tag: UNumberFormatTextAttribute,
    new_value: ?*const u16,
    new_value_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_toPattern(
    fmt: ?*const ?*anyopaque,
    is_pattern_localized: i8,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_getSymbol(
    fmt: ?*const ?*anyopaque,
    symbol: UNumberFormatSymbol,
    buffer: ?*u16,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unum_setSymbol(
    fmt: ?*?*anyopaque,
    symbol: UNumberFormatSymbol,
    value: ?*const u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getLocaleByType(
    fmt: ?*const ?*anyopaque,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unum_setContext(
    fmt: ?*?*anyopaque,
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unum_getContext(
    fmt: ?*const ?*anyopaque,
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn udat_toCalendarDateField(
    field: UDateFormatField,
) callconv(@import("std").os.windows.WINAPI) UCalendarDateFields;

pub extern "icu" fn udat_open(
    time_style: UDateFormatStyle,
    date_style: UDateFormatStyle,
    locale: ?[*:0]const u8,
    tz_i_d: ?*const u16,
    tz_i_d_length: i32,
    pattern: ?*const u16,
    pattern_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udat_close(
    format: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getBooleanAttribute(
    fmt: ?*const ?*anyopaque,
    attr: UDateFormatBooleanAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udat_setBooleanAttribute(
    fmt: ?*?*anyopaque,
    attr: UDateFormatBooleanAttribute,
    new_value: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_clone(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udat_format(
    format: ?*const ?*anyopaque,
    date_to_format: f64,
    result: ?*u16,
    result_length: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatCalendar(
    format: ?*const ?*anyopaque,
    calendar: ?*?*anyopaque,
    result: ?*u16,
    capacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatForFields(
    format: ?*const ?*anyopaque,
    date_to_format: f64,
    result: ?*u16,
    result_length: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_formatCalendarForFields(
    format: ?*const ?*anyopaque,
    calendar: ?*?*anyopaque,
    result: ?*u16,
    capacity: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_parse(
    format: ?*const ?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn udat_parseCalendar(
    format: ?*const ?*anyopaque,
    calendar: ?*?*anyopaque,
    text: ?*const u16,
    text_length: i32,
    parse_pos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_isLenient(
    fmt: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn udat_setLenient(
    fmt: ?*?*anyopaque,
    is_lenient: i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getCalendar(
    fmt: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udat_setCalendar(
    fmt: ?*?*anyopaque,
    calendar_to_set: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getNumberFormat(
    fmt: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udat_getNumberFormatForField(
    fmt: ?*const ?*anyopaque,
    field: u16,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udat_adoptNumberFormatForFields(
    fmt: ?*?*anyopaque,
    fields: ?*const u16,
    number_format_to_set: ?*?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_setNumberFormat(
    fmt: ?*?*anyopaque,
    number_format_to_set: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_adoptNumberFormat(
    fmt: ?*?*anyopaque,
    number_format_to_adopt: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getAvailable(
    locale_index: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn udat_countAvailable() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_get2DigitYearStart(
    fmt: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

pub extern "icu" fn udat_set2DigitYearStart(
    fmt: ?*?*anyopaque,
    d: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_toPattern(
    fmt: ?*const ?*anyopaque,
    localized: i8,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_applyPattern(
    format: ?*?*anyopaque,
    localized: i8,
    pattern: ?*const u16,
    pattern_length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getSymbols(
    fmt: ?*const ?*anyopaque,
    type: UDateFormatSymbolType,
    symbol_index: i32,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_countSymbols(
    fmt: ?*const ?*anyopaque,
    type: UDateFormatSymbolType,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udat_setSymbols(
    format: ?*?*anyopaque,
    type: UDateFormatSymbolType,
    symbol_index: i32,
    value: ?*u16,
    value_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getLocaleByType(
    fmt: ?*const ?*anyopaque,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn udat_setContext(
    fmt: ?*?*anyopaque,
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udat_getContext(
    fmt: ?*const ?*anyopaque,
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

pub extern "icu" fn udatpg_open(
    locale: ?[*:0]const u8,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udatpg_openEmpty(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udatpg_close(
    dtpg: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_clone(
    dtpg: ?*const ?*anyopaque,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn udatpg_getBestPattern(
    dtpg: ?*?*anyopaque,
    skeleton: ?*const u16,
    length: i32,
    best_pattern: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getBestPatternWithOptions(
    dtpg: ?*?*anyopaque,
    skeleton: ?*const u16,
    length: i32,
    options: UDateTimePatternMatchOptions,
    best_pattern: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getSkeleton(
    unused_dtpg: ?*?*anyopaque,
    pattern: ?*const u16,
    length: i32,
    skeleton: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_getBaseSkeleton(
    unused_dtpg: ?*?*anyopaque,
    pattern: ?*const u16,
    length: i32,
    base_skeleton: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_addPattern(
    dtpg: ?*?*anyopaque,
    pattern: ?*const u16,
    pattern_length: i32,
    override: i8,
    conflicting_pattern: ?*u16,
    capacity: i32,
    p_length: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDateTimePatternConflict;

pub extern "icu" fn udatpg_setAppendItemFormat(
    dtpg: ?*?*anyopaque,
    field: UDateTimePatternField,
    value: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getAppendItemFormat(
    dtpg: ?*const ?*anyopaque,
    field: UDateTimePatternField,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_setAppendItemName(
    dtpg: ?*?*anyopaque,
    field: UDateTimePatternField,
    value: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getAppendItemName(
    dtpg: ?*const ?*anyopaque,
    field: UDateTimePatternField,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_getFieldDisplayName(
    dtpg: ?*const ?*anyopaque,
    field: UDateTimePatternField,
    width: UDateTimePGDisplayWidth,
    field_name: ?*u16,
    capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_setDateTimeFormat(
    dtpg: ?*const ?*anyopaque,
    dt_format: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getDateTimeFormat(
    dtpg: ?*const ?*anyopaque,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_setDecimal(
    dtpg: ?*?*anyopaque,
    decimal: ?*const u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn udatpg_getDecimal(
    dtpg: ?*const ?*anyopaque,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn udatpg_replaceFieldTypes(
    dtpg: ?*?*anyopaque,
    pattern: ?*const u16,
    pattern_length: i32,
    skeleton: ?*const u16,
    skeleton_length: i32,
    dest: ?*u16,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_replaceFieldTypesWithOptions(
    dtpg: ?*?*anyopaque,
    pattern: ?*const u16,
    pattern_length: i32,
    skeleton: ?*const u16,
    skeleton_length: i32,
    options: UDateTimePatternMatchOptions,
    dest: ?*u16,
    dest_capacity: i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn udatpg_openSkeletons(
    dtpg: ?*const ?*anyopaque,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn udatpg_openBaseSkeletons(
    dtpg: ?*const ?*anyopaque,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn udatpg_getPatternForSkeleton(
    dtpg: ?*const ?*anyopaque,
    skeleton: ?*const u16,
    skeleton_length: i32,
    p_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn unumf_openForSkeletonAndLocale(
    skeleton: ?*const u16,
    skeleton_len: i32,
    locale: ?[*:0]const u8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberFormatter;

pub extern "icu" fn unumf_openForSkeletonAndLocaleWithError(
    skeleton: ?*const u16,
    skeleton_len: i32,
    locale: ?[*:0]const u8,
    perror: ?*UParseError,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberFormatter;

pub extern "icu" fn unumf_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedNumber;

pub extern "icu" fn unumf_formatInt(
    uformatter: ?*const UNumberFormatter,
    value: i64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_formatDouble(
    uformatter: ?*const UNumberFormatter,
    value: f64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_formatDecimal(
    uformatter: ?*const UNumberFormatter,
    value: ?[*:0]const u8,
    value_len: i32,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_resultAsValue(
    uresult: ?*const UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedValue;

pub extern "icu" fn unumf_resultToString(
    uresult: ?*const UFormattedNumber,
    buffer: ?*u16,
    buffer_capacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unumf_resultNextFieldPosition(
    uresult: ?*const UFormattedNumber,
    ufpos: ?*UFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unumf_resultGetAllFieldPositions(
    uresult: ?*const UFormattedNumber,
    ufpositer: ?*UFieldPositionIterator,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_close(
    uformatter: ?*UNumberFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumf_closeResult(
    uresult: ?*UFormattedNumber,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumsys_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

pub extern "icu" fn unumsys_openByName(
    name: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

pub extern "icu" fn unumsys_close(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn unumsys_openAvailableNames(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn unumsys_getName(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn unumsys_isAlgorithmic(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn unumsys_getRadix(
    unumsys: ?*const UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn unumsys_getDescription(
    unumsys: ?*const UNumberingSystem,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uplrules_open(
    locale: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

pub extern "icu" fn uplrules_openForType(
    locale: ?[*:0]const u8,
    type: UPluralType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

pub extern "icu" fn uplrules_close(
    uplrules: ?*UPluralRules,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uplrules_select(
    uplrules: ?*const UPluralRules,
    number: f64,
    keyword: ?*u16,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uplrules_selectFormatted(
    uplrules: ?*const UPluralRules,
    number: ?*const UFormattedNumber,
    keyword: ?*u16,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uplrules_getKeywords(
    uplrules: ?*const UPluralRules,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregex_open(
    pattern: ?*const u16,
    pattern_length: i32,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_openUText(
    pattern: ?*UText,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_openC(
    pattern: ?[*:0]const u8,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_close(
    regexp: ?*URegularExpression,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_clone(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

pub extern "icu" fn uregex_pattern(
    regexp: ?*const URegularExpression,
    pat_length: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uregex_patternUText(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_flags(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setText(
    regexp: ?*URegularExpression,
    text: ?*const u16,
    text_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getText(
    regexp: ?*URegularExpression,
    text_length: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn uregex_getUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_refreshUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_matches(
    regexp: ?*URegularExpression,
    start_index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_matches64(
    regexp: ?*URegularExpression,
    start_index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_lookingAt(
    regexp: ?*URegularExpression,
    start_index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_lookingAt64(
    regexp: ?*URegularExpression,
    start_index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_find(
    regexp: ?*URegularExpression,
    start_index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_find64(
    regexp: ?*URegularExpression,
    start_index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_findNext(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_groupCount(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupNumberFromName(
    regexp: ?*URegularExpression,
    group_name: ?*const u16,
    name_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupNumberFromCName(
    regexp: ?*URegularExpression,
    group_name: ?[*:0]const u8,
    name_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_group(
    regexp: ?*URegularExpression,
    group_num: i32,
    dest: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_groupUText(
    regexp: ?*URegularExpression,
    group_num: i32,
    dest: ?*UText,
    group_length: ?*i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_start(
    regexp: ?*URegularExpression,
    group_num: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_start64(
    regexp: ?*URegularExpression,
    group_num: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_end(
    regexp: ?*URegularExpression,
    group_num: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_end64(
    regexp: ?*URegularExpression,
    group_num: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_reset(
    regexp: ?*URegularExpression,
    index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_reset64(
    regexp: ?*URegularExpression,
    index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegion(
    regexp: ?*URegularExpression,
    region_start: i32,
    region_limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegion64(
    regexp: ?*URegularExpression,
    region_start: i64,
    region_limit: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setRegionAndStart(
    regexp: ?*URegularExpression,
    region_start: i64,
    region_limit: i64,
    start_index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_regionStart(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_regionStart64(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_regionEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_regionEnd64(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn uregex_hasTransparentBounds(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_useTransparentBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_hasAnchoringBounds(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_useAnchoringBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_hitEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_requireEnd(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregex_replaceAll(
    regexp: ?*URegularExpression,
    replacement_text: ?*const u16,
    replacement_length: i32,
    dest_buf: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_replaceAllUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_replaceFirst(
    regexp: ?*URegularExpression,
    replacement_text: ?*const u16,
    replacement_length: i32,
    dest_buf: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_replaceFirstUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_appendReplacement(
    regexp: ?*URegularExpression,
    replacement_text: ?*const u16,
    replacement_length: i32,
    dest_buf: ?*?*u16,
    dest_capacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_appendReplacementUText(
    regexp: ?*URegularExpression,
    replacement_text: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_appendTail(
    regexp: ?*URegularExpression,
    dest_buf: ?*?*u16,
    dest_capacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_appendTailUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

pub extern "icu" fn uregex_split(
    regexp: ?*URegularExpression,
    dest_buf: ?*u16,
    dest_capacity: i32,
    required_capacity: ?*i32,
    dest_fields: ?*?*u16,
    dest_fields_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_splitUText(
    regexp: ?*URegularExpression,
    dest_fields: ?*?*UText,
    dest_fields_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setTimeLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getTimeLimit(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setStackLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getStackLimit(
    regexp: ?*const URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregex_setMatchCallback(
    regexp: ?*URegularExpression,
    callback: ?URegexMatchCallback,
    context: ?*const anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getMatchCallback(
    regexp: ?*const URegularExpression,
    callback: ?*?URegexMatchCallback,
    context: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_setFindProgressCallback(
    regexp: ?*URegularExpression,
    callback: ?URegexFindProgressCallback,
    context: ?*const anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregex_getFindProgressCallback(
    regexp: ?*const URegularExpression,
    callback: ?*?URegexFindProgressCallback,
    context: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uregion_getRegionFromCode(
    region_code: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getRegionFromNumericCode(
    code: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getAvailable(
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_areEqual(
    uregion: ?*const URegion,
    other_region: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregion_getContainingRegion(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getContainingRegionOfType(
    uregion: ?*const URegion,
    type: URegionType,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

pub extern "icu" fn uregion_getContainedRegions(
    uregion: ?*const URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_getContainedRegionsOfType(
    uregion: ?*const URegion,
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_contains(
    uregion: ?*const URegion,
    other_region: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

pub extern "icu" fn uregion_getPreferredValues(
    uregion: ?*const URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn uregion_getRegionCode(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uregion_getNumericCode(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uregion_getType(
    uregion: ?*const URegion,
) callconv(@import("std").os.windows.WINAPI) URegionType;

pub extern "icu" fn ureldatefmt_open(
    locale: ?[*:0]const u8,
    nf_to_adopt: ?*?*anyopaque,
    width: UDateRelativeDateTimeFormatterStyle,
    capitalization_context: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URelativeDateTimeFormatter;

pub extern "icu" fn ureldatefmt_close(
    reldatefmt: ?*URelativeDateTimeFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ureldatefmt_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedRelativeDateTime;

pub extern "icu" fn ureldatefmt_resultAsValue(
    ufrdt: ?*const UFormattedRelativeDateTime,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedValue;

pub extern "icu" fn ureldatefmt_closeResult(
    ufrdt: ?*UFormattedRelativeDateTime,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ureldatefmt_formatNumeric(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    result_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ureldatefmt_formatNumericToResult(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*UFormattedRelativeDateTime,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ureldatefmt_format(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    result_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn ureldatefmt_formatToResult(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*UFormattedRelativeDateTime,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn ureldatefmt_combineDateAndTime(
    reldatefmt: ?*const URelativeDateTimeFormatter,
    relative_date_string: ?*const u16,
    relative_date_string_len: i32,
    time_string: ?*const u16,
    time_string_len: i32,
    result: ?*u16,
    result_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_open(
    pattern: ?*const u16,
    patternlength: i32,
    text: ?*const u16,
    textlength: i32,
    locale: ?[*:0]const u8,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

pub extern "icu" fn usearch_openFromCollator(
    pattern: ?*const u16,
    patternlength: i32,
    text: ?*const u16,
    textlength: i32,
    collator: ?*const UCollator,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

pub extern "icu" fn usearch_close(
    searchiter: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_setOffset(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getOffset(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_setAttribute(
    strsrch: ?*UStringSearch,
    attribute: USearchAttribute,
    value: USearchAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getAttribute(
    strsrch: ?*const UStringSearch,
    attribute: USearchAttribute,
) callconv(@import("std").os.windows.WINAPI) USearchAttributeValue;

pub extern "icu" fn usearch_getMatchedStart(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_getMatchedLength(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_getMatchedText(
    strsrch: ?*const UStringSearch,
    result: ?*u16,
    result_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_setBreakIterator(
    strsrch: ?*UStringSearch,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getBreakIterator(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

pub extern "icu" fn usearch_setText(
    strsrch: ?*UStringSearch,
    text: ?*const u16,
    textlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getText(
    strsrch: ?*const UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn usearch_getCollator(
    strsrch: ?*const UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

pub extern "icu" fn usearch_setCollator(
    strsrch: ?*UStringSearch,
    collator: ?*const UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_setPattern(
    strsrch: ?*UStringSearch,
    pattern: ?*const u16,
    patternlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn usearch_getPattern(
    strsrch: ?*const UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn usearch_first(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_following(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_last(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_preceding(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_next(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_previous(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn usearch_reset(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_openFromSerialized(
    data: ?*const anyopaque,
    length: i32,
    p_actual_length: ?*i32,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_openFromSource(
    confusables: ?[*:0]const u8,
    confusables_len: i32,
    confusables_whole_script: ?[*:0]const u8,
    confusables_whole_script_len: i32,
    err_type: ?*i32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_close(
    sc: ?*USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_clone(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

pub extern "icu" fn uspoof_setChecks(
    sc: ?*USpoofChecker,
    checks: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getChecks(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_setRestrictionLevel(
    sc: ?*USpoofChecker,
    restriction_level: URestrictionLevel,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getRestrictionLevel(
    sc: ?*const USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

pub extern "icu" fn uspoof_setAllowedLocales(
    sc: ?*USpoofChecker,
    locales_list: ?[*:0]const u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getAllowedLocales(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "icu" fn uspoof_setAllowedChars(
    sc: ?*USpoofChecker,
    chars: ?*const USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getAllowedChars(
    sc: ?*const USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_check(
    sc: ?*const USpoofChecker,
    id: ?*const u16,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_checkUTF8(
    sc: ?*const USpoofChecker,
    id: ?[*:0]const u8,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_check2(
    sc: ?*const USpoofChecker,
    id: ?*const u16,
    length: i32,
    check_result: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_check2UTF8(
    sc: ?*const USpoofChecker,
    id: ?[*:0]const u8,
    length: i32,
    check_result: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_openCheckResult(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofCheckResult;

pub extern "icu" fn uspoof_closeCheckResult(
    check_result: ?*USpoofCheckResult,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn uspoof_getCheckResultChecks(
    check_result: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getCheckResultRestrictionLevel(
    check_result: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

pub extern "icu" fn uspoof_getCheckResultNumerics(
    check_result: ?*const USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_areConfusable(
    sc: ?*const USpoofChecker,
    id1: ?*const u16,
    length1: i32,
    id2: ?*const u16,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_areConfusableUTF8(
    sc: ?*const USpoofChecker,
    id1: ?[*:0]const u8,
    length1: i32,
    id2: ?[*:0]const u8,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getSkeleton(
    sc: ?*const USpoofChecker,
    type: u32,
    id: ?*const u16,
    length: i32,
    dest: ?*u16,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getSkeletonUTF8(
    sc: ?*const USpoofChecker,
    type: u32,
    id: ?[*:0]const u8,
    length: i32,
    dest: ?PSTR,
    dest_capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn uspoof_getInclusionSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_getRecommendedSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "icu" fn uspoof_serialize(
    sc: ?*USpoofChecker,
    data: ?*anyopaque,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utmscale_getTimeScaleValue(
    time_scale: UDateTimeScale,
    value: UTimeScaleValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utmscale_fromInt64(
    other_time: i64,
    time_scale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utmscale_toInt64(
    universal_time: i64,
    time_scale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "icu" fn utrans_openU(
    id: ?*const u16,
    id_length: i32,
    dir: UTransDirection,
    rules: ?*const u16,
    rules_length: i32,
    parse_error: ?*UParseError,
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn utrans_openInverse(
    trans: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn utrans_clone(
    trans: ?*const ?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*anyopaque;

pub extern "icu" fn utrans_close(
    trans: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_getUnicodeID(
    trans: ?*const ?*anyopaque,
    result_length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

pub extern "icu" fn utrans_register(
    adopted_trans: ?*?*anyopaque,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_unregisterID(
    id: ?*const u16,
    id_length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_setFilter(
    trans: ?*?*anyopaque,
    filter_pattern: ?*const u16,
    filter_pattern_len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_countAvailableIDs() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrans_openIDs(
    p_error_code: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

pub extern "icu" fn utrans_trans(
    trans: ?*const ?*anyopaque,
    rep: ?*?*anyopaque,
    rep_func: ?*const UReplaceableCallbacks,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transIncremental(
    trans: ?*const ?*anyopaque,
    rep: ?*?*anyopaque,
    rep_func: ?*const UReplaceableCallbacks,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transUChars(
    trans: ?*const ?*anyopaque,
    text: ?*u16,
    text_length: ?*i32,
    text_capacity: i32,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_transIncrementalUChars(
    trans: ?*const ?*anyopaque,
    text: ?*u16,
    text_length: ?*i32,
    text_capacity: i32,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "icu" fn utrans_toRules(
    trans: ?*const ?*anyopaque,
    escape_unprintable: i8,
    result: ?*u16,
    result_length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "icu" fn utrans_getSourceSet(
    trans: ?*const ?*anyopaque,
    ignore_filter: i8,
    fill_in: ?*USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

pub extern "bcp47mrm" fn GetDistanceOfClosestLanguageInList(
    psz_language: ?[*:0]const u16,
    psz_languages_list: ?[*:0]const u16,
    wch_list_delimiter: u16,
    p_closest_distance: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "bcp47mrm" fn IsWellFormedTag(
    psz_tag: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn FindStringOrdinal(
    dw_find_string_ordinal_flags: u32,
    lp_string_source: [*:0]const u16,
    cch_source: i32,
    lp_string_value: [*:0]const u16,
    cch_value: i32,
    b_ignore_case: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcmpA(
    lp_string1: ?[*:0]const u8,
    lp_string2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcmpW(
    lp_string1: ?[*:0]const u16,
    lp_string2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcmpiA(
    lp_string1: ?[*:0]const u8,
    lp_string2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcmpiW(
    lp_string1: ?[*:0]const u16,
    lp_string2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcpynA(
    lp_string1: [*:0]u8,
    lp_string2: ?[*:0]const u8,
    i_max_length: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcpynW(
    lp_string1: [*:0]u16,
    lp_string2: ?[*:0]const u16,
    i_max_length: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcpyA(
    lp_string1: ?PSTR,
    lp_string2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcpyW(
    lp_string1: ?PWSTR,
    lp_string2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcatA(
    lp_string1: ?PSTR,
    lp_string2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrcatW(
    lp_string1: ?PWSTR,
    lp_string2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrlenA(
    lp_string: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn lstrlenW(
    lp_string: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "advapi32" fn IsTextUnicode(
    // TODO: what to do with BytesParamIndex 1?
    lpv: ?*const anyopaque,
    i_size: i32,
    lpi_result: ?*IS_TEXT_UNICODE_RESULT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (47)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("zig.zig").unicode_mode) {
    .ansi => struct {
        pub const NEWTEXTMETRICEX = thismodule.NEWTEXTMETRICEXA;
        pub const ENUMTEXTMETRIC = thismodule.ENUMTEXTMETRICA;
        pub const CPINFOEX = thismodule.CPINFOEXA;
        pub const NUMBERFMT = thismodule.NUMBERFMTA;
        pub const CURRENCYFMT = thismodule.CURRENCYFMTA;
        pub const LOCALE_ENUMPROC = thismodule.LOCALE_ENUMPROCA;
        pub const LANGUAGEGROUP_ENUMPROC = thismodule.LANGUAGEGROUP_ENUMPROCA;
        pub const LANGGROUPLOCALE_ENUMPROC = thismodule.LANGGROUPLOCALE_ENUMPROCA;
        pub const UILANGUAGE_ENUMPROC = thismodule.UILANGUAGE_ENUMPROCA;
        pub const CODEPAGE_ENUMPROC = thismodule.CODEPAGE_ENUMPROCA;
        pub const DATEFMT_ENUMPROC = thismodule.DATEFMT_ENUMPROCA;
        pub const DATEFMT_ENUMPROCEX = thismodule.DATEFMT_ENUMPROCEXA;
        pub const TIMEFMT_ENUMPROC = thismodule.TIMEFMT_ENUMPROCA;
        pub const CALINFO_ENUMPROC = thismodule.CALINFO_ENUMPROCA;
        pub const CALINFO_ENUMPROCEX = thismodule.CALINFO_ENUMPROCEXA;
        pub const IMLangStringBuf = thismodule.IMLangStringBufA;
        pub const GetDateFormat = thismodule.GetDateFormatA;
        pub const GetTimeFormat = thismodule.GetTimeFormatA;
        pub const CompareString = thismodule.CompareStringA;
        pub const FoldString = thismodule.FoldStringA;
        pub const GetStringTypeEx = thismodule.GetStringTypeExA;
        pub const GetStringType = thismodule.GetStringTypeA;
        pub const GetCPInfoEx = thismodule.GetCPInfoExA;
        pub const LCMapString = thismodule.LCMapStringA;
        pub const GetLocaleInfo = thismodule.GetLocaleInfoA;
        pub const SetLocaleInfo = thismodule.SetLocaleInfoA;
        pub const GetCalendarInfo = thismodule.GetCalendarInfoA;
        pub const SetCalendarInfo = thismodule.SetCalendarInfoA;
        pub const GetNumberFormat = thismodule.GetNumberFormatA;
        pub const GetCurrencyFormat = thismodule.GetCurrencyFormatA;
        pub const EnumCalendarInfo = thismodule.EnumCalendarInfoA;
        pub const EnumCalendarInfoEx = thismodule.EnumCalendarInfoExA;
        pub const EnumTimeFormats = thismodule.EnumTimeFormatsA;
        pub const EnumDateFormats = thismodule.EnumDateFormatsA;
        pub const EnumDateFormatsEx = thismodule.EnumDateFormatsExA;
        pub const GetGeoInfo = thismodule.GetGeoInfoA;
        pub const EnumSystemLocales = thismodule.EnumSystemLocalesA;
        pub const EnumSystemLanguageGroups = thismodule.EnumSystemLanguageGroupsA;
        pub const EnumLanguageGroupLocales = thismodule.EnumLanguageGroupLocalesA;
        pub const EnumUILanguages = thismodule.EnumUILanguagesA;
        pub const EnumSystemCodePages = thismodule.EnumSystemCodePagesA;
        pub const lstrcmp = thismodule.lstrcmpA;
        pub const lstrcmpi = thismodule.lstrcmpiA;
        pub const lstrcpyn = thismodule.lstrcpynA;
        pub const lstrcpy = thismodule.lstrcpyA;
        pub const lstrcat = thismodule.lstrcatA;
        pub const lstrlen = thismodule.lstrlenA;
    },
    .wide => struct {
        pub const NEWTEXTMETRICEX = thismodule.NEWTEXTMETRICEXW;
        pub const ENUMTEXTMETRIC = thismodule.ENUMTEXTMETRICW;
        pub const CPINFOEX = thismodule.CPINFOEXW;
        pub const NUMBERFMT = thismodule.NUMBERFMTW;
        pub const CURRENCYFMT = thismodule.CURRENCYFMTW;
        pub const LOCALE_ENUMPROC = thismodule.LOCALE_ENUMPROCW;
        pub const LANGUAGEGROUP_ENUMPROC = thismodule.LANGUAGEGROUP_ENUMPROCW;
        pub const LANGGROUPLOCALE_ENUMPROC = thismodule.LANGGROUPLOCALE_ENUMPROCW;
        pub const UILANGUAGE_ENUMPROC = thismodule.UILANGUAGE_ENUMPROCW;
        pub const CODEPAGE_ENUMPROC = thismodule.CODEPAGE_ENUMPROCW;
        pub const DATEFMT_ENUMPROC = thismodule.DATEFMT_ENUMPROCW;
        pub const DATEFMT_ENUMPROCEX = thismodule.DATEFMT_ENUMPROCEXW;
        pub const TIMEFMT_ENUMPROC = thismodule.TIMEFMT_ENUMPROCW;
        pub const CALINFO_ENUMPROC = thismodule.CALINFO_ENUMPROCW;
        pub const CALINFO_ENUMPROCEX = thismodule.CALINFO_ENUMPROCEXW;
        pub const IMLangStringBuf = thismodule.IMLangStringBufW;
        pub const GetDateFormat = thismodule.GetDateFormatW;
        pub const GetTimeFormat = thismodule.GetTimeFormatW;
        pub const CompareString = thismodule.CompareStringW;
        pub const FoldString = thismodule.FoldStringW;
        pub const GetStringTypeEx = thismodule.GetStringTypeExW;
        pub const GetStringType = thismodule.GetStringTypeW;
        pub const GetCPInfoEx = thismodule.GetCPInfoExW;
        pub const LCMapString = thismodule.LCMapStringW;
        pub const GetLocaleInfo = thismodule.GetLocaleInfoW;
        pub const SetLocaleInfo = thismodule.SetLocaleInfoW;
        pub const GetCalendarInfo = thismodule.GetCalendarInfoW;
        pub const SetCalendarInfo = thismodule.SetCalendarInfoW;
        pub const GetNumberFormat = thismodule.GetNumberFormatW;
        pub const GetCurrencyFormat = thismodule.GetCurrencyFormatW;
        pub const EnumCalendarInfo = thismodule.EnumCalendarInfoW;
        pub const EnumCalendarInfoEx = thismodule.EnumCalendarInfoExW;
        pub const EnumTimeFormats = thismodule.EnumTimeFormatsW;
        pub const EnumDateFormats = thismodule.EnumDateFormatsW;
        pub const EnumDateFormatsEx = thismodule.EnumDateFormatsExW;
        pub const GetGeoInfo = thismodule.GetGeoInfoW;
        pub const EnumSystemLocales = thismodule.EnumSystemLocalesW;
        pub const EnumSystemLanguageGroups = thismodule.EnumSystemLanguageGroupsW;
        pub const EnumLanguageGroupLocales = thismodule.EnumLanguageGroupLocalesW;
        pub const EnumUILanguages = thismodule.EnumUILanguagesW;
        pub const EnumSystemCodePages = thismodule.EnumSystemCodePagesW;
        pub const lstrcmp = thismodule.lstrcmpW;
        pub const lstrcmpi = thismodule.lstrcmpiW;
        pub const lstrcpyn = thismodule.lstrcpynW;
        pub const lstrcpy = thismodule.lstrcpyW;
        pub const lstrcat = thismodule.lstrcatW;
        pub const lstrlen = thismodule.lstrlenW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const NEWTEXTMETRICEX = *opaque {};
        pub const ENUMTEXTMETRIC = *opaque {};
        pub const CPINFOEX = *opaque {};
        pub const NUMBERFMT = *opaque {};
        pub const CURRENCYFMT = *opaque {};
        pub const LOCALE_ENUMPROC = *opaque {};
        pub const LANGUAGEGROUP_ENUMPROC = *opaque {};
        pub const LANGGROUPLOCALE_ENUMPROC = *opaque {};
        pub const UILANGUAGE_ENUMPROC = *opaque {};
        pub const CODEPAGE_ENUMPROC = *opaque {};
        pub const DATEFMT_ENUMPROC = *opaque {};
        pub const DATEFMT_ENUMPROCEX = *opaque {};
        pub const TIMEFMT_ENUMPROC = *opaque {};
        pub const CALINFO_ENUMPROC = *opaque {};
        pub const CALINFO_ENUMPROCEX = *opaque {};
        pub const IMLangStringBuf = *opaque {};
        pub const GetDateFormat = *opaque {};
        pub const GetTimeFormat = *opaque {};
        pub const CompareString = *opaque {};
        pub const FoldString = *opaque {};
        pub const GetStringTypeEx = *opaque {};
        pub const GetStringType = *opaque {};
        pub const GetCPInfoEx = *opaque {};
        pub const LCMapString = *opaque {};
        pub const GetLocaleInfo = *opaque {};
        pub const SetLocaleInfo = *opaque {};
        pub const GetCalendarInfo = *opaque {};
        pub const SetCalendarInfo = *opaque {};
        pub const GetNumberFormat = *opaque {};
        pub const GetCurrencyFormat = *opaque {};
        pub const EnumCalendarInfo = *opaque {};
        pub const EnumCalendarInfoEx = *opaque {};
        pub const EnumTimeFormats = *opaque {};
        pub const EnumDateFormats = *opaque {};
        pub const EnumDateFormatsEx = *opaque {};
        pub const GetGeoInfo = *opaque {};
        pub const EnumSystemLocales = *opaque {};
        pub const EnumSystemLanguageGroups = *opaque {};
        pub const EnumLanguageGroupLocales = *opaque {};
        pub const EnumUILanguages = *opaque {};
        pub const EnumSystemCodePages = *opaque {};
        pub const lstrcmp = *opaque {};
        pub const lstrcmpi = *opaque {};
        pub const lstrcpyn = *opaque {};
        pub const lstrcpy = *opaque {};
        pub const lstrcat = *opaque {};
        pub const lstrlen = *opaque {};
    } else struct {
        pub const NEWTEXTMETRICEX = @compileError("'NEWTEXTMETRICEX' requires that UNICODE be set to true or false in the root module");
        pub const ENUMTEXTMETRIC = @compileError("'ENUMTEXTMETRIC' requires that UNICODE be set to true or false in the root module");
        pub const CPINFOEX = @compileError("'CPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NUMBERFMT = @compileError("'NUMBERFMT' requires that UNICODE be set to true or false in the root module");
        pub const CURRENCYFMT = @compileError("'CURRENCYFMT' requires that UNICODE be set to true or false in the root module");
        pub const LOCALE_ENUMPROC = @compileError("'LOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGUAGEGROUP_ENUMPROC = @compileError("'LANGUAGEGROUP_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGGROUPLOCALE_ENUMPROC = @compileError("'LANGGROUPLOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const UILANGUAGE_ENUMPROC = @compileError("'UILANGUAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CODEPAGE_ENUMPROC = @compileError("'CODEPAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROC = @compileError("'DATEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROCEX = @compileError("'DATEFMT_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const TIMEFMT_ENUMPROC = @compileError("'TIMEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROC = @compileError("'CALINFO_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROCEX = @compileError("'CALINFO_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const IMLangStringBuf = @compileError("'IMLangStringBuf' requires that UNICODE be set to true or false in the root module");
        pub const GetDateFormat = @compileError("'GetDateFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetTimeFormat = @compileError("'GetTimeFormat' requires that UNICODE be set to true or false in the root module");
        pub const CompareString = @compileError("'CompareString' requires that UNICODE be set to true or false in the root module");
        pub const FoldString = @compileError("'FoldString' requires that UNICODE be set to true or false in the root module");
        pub const GetStringTypeEx = @compileError("'GetStringTypeEx' requires that UNICODE be set to true or false in the root module");
        pub const GetStringType = @compileError("'GetStringType' requires that UNICODE be set to true or false in the root module");
        pub const GetCPInfoEx = @compileError("'GetCPInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const LCMapString = @compileError("'LCMapString' requires that UNICODE be set to true or false in the root module");
        pub const GetLocaleInfo = @compileError("'GetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetLocaleInfo = @compileError("'SetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetCalendarInfo = @compileError("'GetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetCalendarInfo = @compileError("'SetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetNumberFormat = @compileError("'GetNumberFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrencyFormat = @compileError("'GetCurrencyFormat' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfo = @compileError("'EnumCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfoEx = @compileError("'EnumCalendarInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumTimeFormats = @compileError("'EnumTimeFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormats = @compileError("'EnumDateFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormatsEx = @compileError("'EnumDateFormatsEx' requires that UNICODE be set to true or false in the root module");
        pub const GetGeoInfo = @compileError("'GetGeoInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLocales = @compileError("'EnumSystemLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLanguageGroups = @compileError("'EnumSystemLanguageGroups' requires that UNICODE be set to true or false in the root module");
        pub const EnumLanguageGroupLocales = @compileError("'EnumLanguageGroupLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumUILanguages = @compileError("'EnumUILanguages' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemCodePages = @compileError("'EnumSystemCodePages' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmp = @compileError("'lstrcmp' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmpi = @compileError("'lstrcmpi' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpyn = @compileError("'lstrcpyn' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpy = @compileError("'lstrcpy' requires that UNICODE be set to true or false in the root module");
        pub const lstrcat = @compileError("'lstrcat' requires that UNICODE be set to true or false in the root module");
        pub const lstrlen = @compileError("'lstrlen' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (23)
//--------------------------------------------------------------------------------
const Guid = @import("zig.zig").Guid;
const ABC = @import("graphics/gdi.zig").ABC;
const AXESLISTA = @import("graphics/gdi.zig").AXESLISTA;
const AXESLISTW = @import("graphics/gdi.zig").AXESLISTW;
const BOOL = @import("foundation.zig").BOOL;
const BSTR = @import("foundation.zig").BSTR;
const CHAR = @import("foundation.zig").CHAR;
const ETO_OPTIONS = @import("graphics/gdi.zig").ETO_OPTIONS;
const HDC = @import("graphics/gdi.zig").HDC;
const HFONT = @import("graphics/gdi.zig").HFONT;
const HRESULT = @import("foundation.zig").HRESULT;
const HWND = @import("foundation.zig").HWND;
const IEnumString = @import("system/com.zig").IEnumString;
const IStream = @import("system/com.zig").IStream;
const IUnknown = @import("system/com.zig").IUnknown;
const LPARAM = @import("foundation.zig").LPARAM;
const NEWTEXTMETRICA = @import("graphics/gdi.zig").NEWTEXTMETRICA;
const NEWTEXTMETRICW = @import("graphics/gdi.zig").NEWTEXTMETRICW;
const PSTR = @import("foundation.zig").PSTR;
const PWSTR = @import("foundation.zig").PWSTR;
const RECT = @import("foundation.zig").RECT;
const SIZE = @import("foundation.zig").SIZE;
const SYSTEMTIME = @import("foundation.zig").SYSTEMTIME;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LOCALE_ENUMPROCA")) {
        _ = LOCALE_ENUMPROCA;
    }
    if (@hasDecl(@This(), "LOCALE_ENUMPROCW")) {
        _ = LOCALE_ENUMPROCW;
    }
    if (@hasDecl(@This(), "LANGUAGEGROUP_ENUMPROCA")) {
        _ = LANGUAGEGROUP_ENUMPROCA;
    }
    if (@hasDecl(@This(), "LANGGROUPLOCALE_ENUMPROCA")) {
        _ = LANGGROUPLOCALE_ENUMPROCA;
    }
    if (@hasDecl(@This(), "UILANGUAGE_ENUMPROCA")) {
        _ = UILANGUAGE_ENUMPROCA;
    }
    if (@hasDecl(@This(), "CODEPAGE_ENUMPROCA")) {
        _ = CODEPAGE_ENUMPROCA;
    }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCA")) {
        _ = DATEFMT_ENUMPROCA;
    }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXA")) {
        _ = DATEFMT_ENUMPROCEXA;
    }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCA")) {
        _ = TIMEFMT_ENUMPROCA;
    }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCA")) {
        _ = CALINFO_ENUMPROCA;
    }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXA")) {
        _ = CALINFO_ENUMPROCEXA;
    }
    if (@hasDecl(@This(), "LANGUAGEGROUP_ENUMPROCW")) {
        _ = LANGUAGEGROUP_ENUMPROCW;
    }
    if (@hasDecl(@This(), "LANGGROUPLOCALE_ENUMPROCW")) {
        _ = LANGGROUPLOCALE_ENUMPROCW;
    }
    if (@hasDecl(@This(), "UILANGUAGE_ENUMPROCW")) {
        _ = UILANGUAGE_ENUMPROCW;
    }
    if (@hasDecl(@This(), "CODEPAGE_ENUMPROCW")) {
        _ = CODEPAGE_ENUMPROCW;
    }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCW")) {
        _ = DATEFMT_ENUMPROCW;
    }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXW")) {
        _ = DATEFMT_ENUMPROCEXW;
    }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCW")) {
        _ = TIMEFMT_ENUMPROCW;
    }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCW")) {
        _ = CALINFO_ENUMPROCW;
    }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXW")) {
        _ = CALINFO_ENUMPROCEXW;
    }
    if (@hasDecl(@This(), "GEO_ENUMPROC")) {
        _ = GEO_ENUMPROC;
    }
    if (@hasDecl(@This(), "GEO_ENUMNAMEPROC")) {
        _ = GEO_ENUMNAMEPROC;
    }
    if (@hasDecl(@This(), "CALINFO_ENUMPROCEXEX")) {
        _ = CALINFO_ENUMPROCEXEX;
    }
    if (@hasDecl(@This(), "DATEFMT_ENUMPROCEXEX")) {
        _ = DATEFMT_ENUMPROCEXEX;
    }
    if (@hasDecl(@This(), "TIMEFMT_ENUMPROCEX")) {
        _ = TIMEFMT_ENUMPROCEX;
    }
    if (@hasDecl(@This(), "LOCALE_ENUMPROCEX")) {
        _ = LOCALE_ENUMPROCEX;
    }
    if (@hasDecl(@This(), "PFN_MAPPINGCALLBACKPROC")) {
        _ = PFN_MAPPINGCALLBACKPROC;
    }
    if (@hasDecl(@This(), "UTraceEntry")) {
        _ = UTraceEntry;
    }
    if (@hasDecl(@This(), "UTraceExit")) {
        _ = UTraceExit;
    }
    if (@hasDecl(@This(), "UTraceData")) {
        _ = UTraceData;
    }
    if (@hasDecl(@This(), "UCPMapValueFilter")) {
        _ = UCPMapValueFilter;
    }
    if (@hasDecl(@This(), "UConverterToUCallback")) {
        _ = UConverterToUCallback;
    }
    if (@hasDecl(@This(), "UConverterFromUCallback")) {
        _ = UConverterFromUCallback;
    }
    if (@hasDecl(@This(), "UMemAllocFn")) {
        _ = UMemAllocFn;
    }
    if (@hasDecl(@This(), "UMemReallocFn")) {
        _ = UMemReallocFn;
    }
    if (@hasDecl(@This(), "UMemFreeFn")) {
        _ = UMemFreeFn;
    }
    if (@hasDecl(@This(), "UCharEnumTypeRange")) {
        _ = UCharEnumTypeRange;
    }
    if (@hasDecl(@This(), "UEnumCharNamesFn")) {
        _ = UEnumCharNamesFn;
    }
    if (@hasDecl(@This(), "UBiDiClassCallback")) {
        _ = UBiDiClassCallback;
    }
    if (@hasDecl(@This(), "UNESCAPE_CHAR_AT")) {
        _ = UNESCAPE_CHAR_AT;
    }
    if (@hasDecl(@This(), "URegexMatchCallback")) {
        _ = URegexMatchCallback;
    }
    if (@hasDecl(@This(), "URegexFindProgressCallback")) {
        _ = URegexFindProgressCallback;
    }
    if (@hasDecl(@This(), "UStringCaseMapper")) {
        _ = UStringCaseMapper;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
