//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1)
//--------------------------------------------------------------------------------
pub const DEDUP_CHUNKLIB_MAX_CHUNKS_ENUM = @as(u32, 1024);

//--------------------------------------------------------------------------------
// Section: Types (24)
//--------------------------------------------------------------------------------
const CLSID_DedupBackupSupport_Value = Guid.initString("73d6b2ad-2984-4715-b2e3-924c149744dd");
pub const CLSID_DedupBackupSupport = &CLSID_DedupBackupSupport_Value;

pub const DEDUP_CONTAINER_EXTENT = extern struct {
    ContainerIndex: u32,
    StartOffset: i64,
    Length: i64,
};

pub const DDP_FILE_EXTENT = extern struct {
    Length: i64,
    Offset: i64,
};

pub const DEDUP_BACKUP_SUPPORT_PARAM_TYPE = enum(i32) {
    UNOPTIMIZED = 1,
    OPTIMIZED = 2,
};
pub const DEDUP_RECONSTRUCT_UNOPTIMIZED = DEDUP_BACKUP_SUPPORT_PARAM_TYPE.UNOPTIMIZED;
pub const DEDUP_RECONSTRUCT_OPTIMIZED = DEDUP_BACKUP_SUPPORT_PARAM_TYPE.OPTIMIZED;

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IDedupReadFileCallback_Value = Guid.initString("7bacc67a-2f1d-42d0-897e-6ff62dd533bb");
pub const IID_IDedupReadFileCallback = &IID_IDedupReadFileCallback_Value;
pub const IDedupReadFileCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadBackupFile: *const fn (
            self: *const IDedupReadFileCallback,
            file_full_path: ?BSTR,
            file_offset: i64,
            size_to_read: u32,
            file_buffer: [*:0]u8,
            returned_size: ?*u32,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OrderContainersRestore: *const fn (
            self: *const IDedupReadFileCallback,
            number_of_containers: u32,
            container_paths: [*]?BSTR,
            read_plan_entries: ?*u32,
            read_plan: [*]?*DEDUP_CONTAINER_EXTENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreviewContainerRead: *const fn (
            self: *const IDedupReadFileCallback,
            file_full_path: ?BSTR,
            number_of_reads: u32,
            read_offsets: [*]DDP_FILE_EXTENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn readBackupFile(self: *const T, file_full_path_: ?BSTR, file_offset_: i64, size_to_read_: u32, file_buffer_: [*:0]u8, returned_size_: ?*u32, flags_: u32) HRESULT {
                return @as(*const IDedupReadFileCallback.VTable, @ptrCast(self.vtable)).ReadBackupFile(@as(*const IDedupReadFileCallback, @ptrCast(self)), file_full_path_, file_offset_, size_to_read_, file_buffer_, returned_size_, flags_);
            }
            pub inline fn orderContainersRestore(self: *const T, number_of_containers_: u32, container_paths_: [*]?BSTR, read_plan_entries_: ?*u32, read_plan_: [*]?*DEDUP_CONTAINER_EXTENT) HRESULT {
                return @as(*const IDedupReadFileCallback.VTable, @ptrCast(self.vtable)).OrderContainersRestore(@as(*const IDedupReadFileCallback, @ptrCast(self)), number_of_containers_, container_paths_, read_plan_entries_, read_plan_);
            }
            pub inline fn previewContainerRead(self: *const T, file_full_path_: ?BSTR, number_of_reads_: u32, read_offsets_: [*]DDP_FILE_EXTENT) HRESULT {
                return @as(*const IDedupReadFileCallback.VTable, @ptrCast(self.vtable)).PreviewContainerRead(@as(*const IDedupReadFileCallback, @ptrCast(self)), file_full_path_, number_of_reads_, read_offsets_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IDedupBackupSupport_Value = Guid.initString("c719d963-2b2d-415e-acf7-7eb7ca596ff4");
pub const IID_IDedupBackupSupport = &IID_IDedupBackupSupport_Value;
pub const IDedupBackupSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RestoreFiles: *const fn (
            self: *const IDedupBackupSupport,
            number_of_files: u32,
            file_full_paths: [*]?BSTR,
            store: ?*IDedupReadFileCallback,
            flags: u32,
            file_results: [*]HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn restoreFiles(self: *const T, number_of_files_: u32, file_full_paths_: [*]?BSTR, store_: ?*IDedupReadFileCallback, flags_: u32, file_results_: [*]HRESULT) HRESULT {
                return @as(*const IDedupBackupSupport.VTable, @ptrCast(self.vtable)).RestoreFiles(@as(*const IDedupBackupSupport, @ptrCast(self)), number_of_files_, file_full_paths_, store_, flags_, file_results_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEDUP_SET_PARAM_TYPE = enum(i32) {
    MinChunkSizeBytes = 1,
    MaxChunkSizeBytes = 2,
    AvgChunkSizeBytes = 3,
    InvariantChunking = 4,
    DisableStrongHashComputation = 5,
};
pub const DEDUP_PT_MinChunkSizeBytes = DEDUP_SET_PARAM_TYPE.MinChunkSizeBytes;
pub const DEDUP_PT_MaxChunkSizeBytes = DEDUP_SET_PARAM_TYPE.MaxChunkSizeBytes;
pub const DEDUP_PT_AvgChunkSizeBytes = DEDUP_SET_PARAM_TYPE.AvgChunkSizeBytes;
pub const DEDUP_PT_InvariantChunking = DEDUP_SET_PARAM_TYPE.InvariantChunking;
pub const DEDUP_PT_DisableStrongHashComputation = DEDUP_SET_PARAM_TYPE.DisableStrongHashComputation;

pub const DEDUP_CHUNK_INFO_HASH32 = extern struct {
    ChunkFlags: u32,
    ChunkOffsetInStream: u64,
    ChunkSize: u64,
    HashVal: [32]u8,
};

const IID_IDedupChunkLibrary_Value = Guid.initString("bb5144d7-2720-4dcc-8777-78597416ec23");
pub const IID_IDedupChunkLibrary = &IID_IDedupChunkLibrary_Value;
pub const IDedupChunkLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeForPushBuffers: *const fn (
            self: *const IDedupChunkLibrary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: *const fn (
            self: *const IDedupChunkLibrary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: *const fn (
            self: *const IDedupChunkLibrary,
            dw_param_type: u32,
            v_param_value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartChunking: *const fn (
            self: *const IDedupChunkLibrary,
            iid_iterator_interface_i_d: Guid,
            pp_chunks_enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn initializeForPushBuffers(self: *const T) HRESULT {
                return @as(*const IDedupChunkLibrary.VTable, @ptrCast(self.vtable)).InitializeForPushBuffers(@as(*const IDedupChunkLibrary, @ptrCast(self)));
            }
            pub inline fn uninitialize(self: *const T) HRESULT {
                return @as(*const IDedupChunkLibrary.VTable, @ptrCast(self.vtable)).Uninitialize(@as(*const IDedupChunkLibrary, @ptrCast(self)));
            }
            pub inline fn setParameter(self: *const T, dw_param_type_: u32, v_param_value_: VARIANT) HRESULT {
                return @as(*const IDedupChunkLibrary.VTable, @ptrCast(self.vtable)).SetParameter(@as(*const IDedupChunkLibrary, @ptrCast(self)), dw_param_type_, v_param_value_);
            }
            pub inline fn startChunking(self: *const T, iid_iterator_interface_i_d_: Guid, pp_chunks_enum_: ?*?*IUnknown) HRESULT {
                return @as(*const IDedupChunkLibrary.VTable, @ptrCast(self.vtable)).StartChunking(@as(*const IDedupChunkLibrary, @ptrCast(self)), iid_iterator_interface_i_d_, pp_chunks_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDedupIterateChunksHash32_Value = Guid.initString("90b584d3-72aa-400f-9767-cad866a5a2d8");
pub const IID_IDedupIterateChunksHash32 = &IID_IDedupIterateChunksHash32_Value;
pub const IDedupIterateChunksHash32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PushBuffer: *const fn (
            self: *const IDedupIterateChunksHash32,
            p_buffer: [*:0]u8,
            ul_buffer_length: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: *const fn (
            self: *const IDedupIterateChunksHash32,
            ul_max_chunks: u32,
            p_arr_chunks: [*]DEDUP_CHUNK_INFO_HASH32,
            pul_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Drain: *const fn (
            self: *const IDedupIterateChunksHash32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IDedupIterateChunksHash32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn pushBuffer(self: *const T, p_buffer_: [*:0]u8, ul_buffer_length_: u32) HRESULT {
                return @as(*const IDedupIterateChunksHash32.VTable, @ptrCast(self.vtable)).PushBuffer(@as(*const IDedupIterateChunksHash32, @ptrCast(self)), p_buffer_, ul_buffer_length_);
            }
            pub inline fn next(self: *const T, ul_max_chunks_: u32, p_arr_chunks_: [*]DEDUP_CHUNK_INFO_HASH32, pul_fetched_: ?*u32) HRESULT {
                return @as(*const IDedupIterateChunksHash32.VTable, @ptrCast(self.vtable)).Next(@as(*const IDedupIterateChunksHash32, @ptrCast(self)), ul_max_chunks_, p_arr_chunks_, pul_fetched_);
            }
            pub inline fn drain(self: *const T) HRESULT {
                return @as(*const IDedupIterateChunksHash32.VTable, @ptrCast(self.vtable)).Drain(@as(*const IDedupIterateChunksHash32, @ptrCast(self)));
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IDedupIterateChunksHash32.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDedupIterateChunksHash32, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DedupDataPortManagerOption = enum(i32) {
    None = 0,
    AutoStart = 1,
    SkipReconciliation = 2,
};
pub const DedupDataPortManagerOption_None = DedupDataPortManagerOption.None;
pub const DedupDataPortManagerOption_AutoStart = DedupDataPortManagerOption.AutoStart;
pub const DedupDataPortManagerOption_SkipReconciliation = DedupDataPortManagerOption.SkipReconciliation;

pub const DedupDataPortVolumeStatus = enum(i32) {
    Unknown = 0,
    NotEnabled = 1,
    NotAvailable = 2,
    Initializing = 3,
    Ready = 4,
    Maintenance = 5,
    Shutdown = 6,
};
pub const DedupDataPortVolumeStatus_Unknown = DedupDataPortVolumeStatus.Unknown;
pub const DedupDataPortVolumeStatus_NotEnabled = DedupDataPortVolumeStatus.NotEnabled;
pub const DedupDataPortVolumeStatus_NotAvailable = DedupDataPortVolumeStatus.NotAvailable;
pub const DedupDataPortVolumeStatus_Initializing = DedupDataPortVolumeStatus.Initializing;
pub const DedupDataPortVolumeStatus_Ready = DedupDataPortVolumeStatus.Ready;
pub const DedupDataPortVolumeStatus_Maintenance = DedupDataPortVolumeStatus.Maintenance;
pub const DedupDataPortVolumeStatus_Shutdown = DedupDataPortVolumeStatus.Shutdown;

pub const DedupDataPortRequestStatus = enum(i32) {
    Unknown = 0,
    Queued = 1,
    Processing = 2,
    Partial = 3,
    Complete = 4,
    Failed = 5,
};
pub const DedupDataPortRequestStatus_Unknown = DedupDataPortRequestStatus.Unknown;
pub const DedupDataPortRequestStatus_Queued = DedupDataPortRequestStatus.Queued;
pub const DedupDataPortRequestStatus_Processing = DedupDataPortRequestStatus.Processing;
pub const DedupDataPortRequestStatus_Partial = DedupDataPortRequestStatus.Partial;
pub const DedupDataPortRequestStatus_Complete = DedupDataPortRequestStatus.Complete;
pub const DedupDataPortRequestStatus_Failed = DedupDataPortRequestStatus.Failed;

pub const DedupChunkFlags = enum(i32) {
    None = 0,
    Compressed = 1,
};
pub const DedupChunkFlags_None = DedupChunkFlags.None;
pub const DedupChunkFlags_Compressed = DedupChunkFlags.Compressed;

pub const DedupHash = extern struct {
    Hash: [32]u8,
};

pub const DedupChunk = extern struct {
    Hash: DedupHash,
    Flags: DedupChunkFlags,
    LogicalSize: u32,
    DataSize: u32,
};

pub const DedupStreamEntry = extern struct {
    Hash: DedupHash,
    LogicalSize: u32,
    Offset: u64,
};

pub const DedupStream = extern struct {
    Path: ?BSTR,
    Offset: u64,
    Length: u64,
    ChunkCount: u32,
};

pub const DedupChunkingAlgorithm = enum(i32) {
    Unknonwn = 0,
    V1 = 1,
};
pub const DedupChunkingAlgorithm_Unknonwn = DedupChunkingAlgorithm.Unknonwn;
pub const DedupChunkingAlgorithm_V1 = DedupChunkingAlgorithm.V1;

pub const DedupHashingAlgorithm = enum(i32) {
    Unknonwn = 0,
    V1 = 1,
};
pub const DedupHashingAlgorithm_Unknonwn = DedupHashingAlgorithm.Unknonwn;
pub const DedupHashingAlgorithm_V1 = DedupHashingAlgorithm.V1;

pub const DedupCompressionAlgorithm = enum(i32) {
    Unknonwn = 0,
    Xpress = 1,
};
pub const DedupCompressionAlgorithm_Unknonwn = DedupCompressionAlgorithm.Unknonwn;
pub const DedupCompressionAlgorithm_Xpress = DedupCompressionAlgorithm.Xpress;

const CLSID_DedupDataPort_Value = Guid.initString("8f107207-1829-48b2-a64b-e61f8e0d9acb");
pub const CLSID_DedupDataPort = &CLSID_DedupDataPort_Value;

const IID_IDedupDataPort_Value = Guid.initString("7963d734-40a9-4ea3-bbf6-5a89d26f7ae8");
pub const IID_IDedupDataPort = &IID_IDedupDataPort_Value;
pub const IDedupDataPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: *const fn (
            self: *const IDedupDataPort,
            p_status: ?*DedupDataPortVolumeStatus,
            p_data_headroom_mb: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupChunks: *const fn (
            self: *const IDedupDataPort,
            count: u32,
            p_hashes: [*]DedupHash,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertChunks: *const fn (
            self: *const IDedupDataPort,
            chunk_count: u32,
            p_chunk_metadata: [*]DedupChunk,
            data_byte_count: u32,
            p_chunk_data: [*:0]u8,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertChunksWithStream: *const fn (
            self: *const IDedupDataPort,
            chunk_count: u32,
            p_chunk_metadata: [*]DedupChunk,
            data_byte_count: u32,
            p_chunk_data_stream: ?*IStream,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitStreams: *const fn (
            self: *const IDedupDataPort,
            stream_count: u32,
            p_streams: [*]DedupStream,
            entry_count: u32,
            p_entries: [*]DedupStreamEntry,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitStreamsWithStream: *const fn (
            self: *const IDedupDataPort,
            stream_count: u32,
            p_streams: [*]DedupStream,
            entry_count: u32,
            p_entries_stream: ?*IStream,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreams: *const fn (
            self: *const IDedupDataPort,
            stream_count: u32,
            p_stream_paths: [*]?BSTR,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamsResults: *const fn (
            self: *const IDedupDataPort,
            request_id: Guid,
            max_wait_ms: u32,
            stream_entry_index: u32,
            p_stream_count: ?*u32,
            pp_streams: [*]?*DedupStream,
            p_entry_count: ?*u32,
            pp_entries: [*]?*DedupStreamEntry,
            p_status: ?*DedupDataPortRequestStatus,
            pp_item_results: [*]?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChunks: *const fn (
            self: *const IDedupDataPort,
            count: u32,
            p_hashes: [*]DedupHash,
            p_request_id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChunksResults: *const fn (
            self: *const IDedupDataPort,
            request_id: Guid,
            max_wait_ms: u32,
            chunk_index: u32,
            p_chunk_count: ?*u32,
            pp_chunk_metadata: [*]?*DedupChunk,
            p_data_byte_count: ?*u32,
            pp_chunk_data: [*]?*u8,
            p_status: ?*DedupDataPortRequestStatus,
            pp_item_results: [*]?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestStatus: *const fn (
            self: *const IDedupDataPort,
            request_id: Guid,
            p_status: ?*DedupDataPortRequestStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestResults: *const fn (
            self: *const IDedupDataPort,
            request_id: Guid,
            max_wait_ms: u32,
            p_batch_result: ?*HRESULT,
            p_batch_count: ?*u32,
            p_status: ?*DedupDataPortRequestStatus,
            pp_item_results: [*]?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStatus(self: *const T, p_status_: ?*DedupDataPortVolumeStatus, p_data_headroom_mb_: ?*u32) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IDedupDataPort, @ptrCast(self)), p_status_, p_data_headroom_mb_);
            }
            pub inline fn lookupChunks(self: *const T, count_: u32, p_hashes_: [*]DedupHash, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).LookupChunks(@as(*const IDedupDataPort, @ptrCast(self)), count_, p_hashes_, p_request_id_);
            }
            pub inline fn insertChunks(self: *const T, chunk_count_: u32, p_chunk_metadata_: [*]DedupChunk, data_byte_count_: u32, p_chunk_data_: [*:0]u8, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).InsertChunks(@as(*const IDedupDataPort, @ptrCast(self)), chunk_count_, p_chunk_metadata_, data_byte_count_, p_chunk_data_, p_request_id_);
            }
            pub inline fn insertChunksWithStream(self: *const T, chunk_count_: u32, p_chunk_metadata_: [*]DedupChunk, data_byte_count_: u32, p_chunk_data_stream_: ?*IStream, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).InsertChunksWithStream(@as(*const IDedupDataPort, @ptrCast(self)), chunk_count_, p_chunk_metadata_, data_byte_count_, p_chunk_data_stream_, p_request_id_);
            }
            pub inline fn commitStreams(self: *const T, stream_count_: u32, p_streams_: [*]DedupStream, entry_count_: u32, p_entries_: [*]DedupStreamEntry, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).CommitStreams(@as(*const IDedupDataPort, @ptrCast(self)), stream_count_, p_streams_, entry_count_, p_entries_, p_request_id_);
            }
            pub inline fn commitStreamsWithStream(self: *const T, stream_count_: u32, p_streams_: [*]DedupStream, entry_count_: u32, p_entries_stream_: ?*IStream, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).CommitStreamsWithStream(@as(*const IDedupDataPort, @ptrCast(self)), stream_count_, p_streams_, entry_count_, p_entries_stream_, p_request_id_);
            }
            pub inline fn getStreams(self: *const T, stream_count_: u32, p_stream_paths_: [*]?BSTR, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetStreams(@as(*const IDedupDataPort, @ptrCast(self)), stream_count_, p_stream_paths_, p_request_id_);
            }
            pub inline fn getStreamsResults(self: *const T, request_id_: Guid, max_wait_ms_: u32, stream_entry_index_: u32, p_stream_count_: ?*u32, pp_streams_: [*]?*DedupStream, p_entry_count_: ?*u32, pp_entries_: [*]?*DedupStreamEntry, p_status_: ?*DedupDataPortRequestStatus, pp_item_results_: [*]?*HRESULT) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetStreamsResults(@as(*const IDedupDataPort, @ptrCast(self)), request_id_, max_wait_ms_, stream_entry_index_, p_stream_count_, pp_streams_, p_entry_count_, pp_entries_, p_status_, pp_item_results_);
            }
            pub inline fn getChunks(self: *const T, count_: u32, p_hashes_: [*]DedupHash, p_request_id_: ?*Guid) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetChunks(@as(*const IDedupDataPort, @ptrCast(self)), count_, p_hashes_, p_request_id_);
            }
            pub inline fn getChunksResults(self: *const T, request_id_: Guid, max_wait_ms_: u32, chunk_index_: u32, p_chunk_count_: ?*u32, pp_chunk_metadata_: [*]?*DedupChunk, p_data_byte_count_: ?*u32, pp_chunk_data_: [*]?*u8, p_status_: ?*DedupDataPortRequestStatus, pp_item_results_: [*]?*HRESULT) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetChunksResults(@as(*const IDedupDataPort, @ptrCast(self)), request_id_, max_wait_ms_, chunk_index_, p_chunk_count_, pp_chunk_metadata_, p_data_byte_count_, pp_chunk_data_, p_status_, pp_item_results_);
            }
            pub inline fn getRequestStatus(self: *const T, request_id_: Guid, p_status_: ?*DedupDataPortRequestStatus) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetRequestStatus(@as(*const IDedupDataPort, @ptrCast(self)), request_id_, p_status_);
            }
            pub inline fn getRequestResults(self: *const T, request_id_: Guid, max_wait_ms_: u32, p_batch_result_: ?*HRESULT, p_batch_count_: ?*u32, p_status_: ?*DedupDataPortRequestStatus, pp_item_results_: [*]?*HRESULT) HRESULT {
                return @as(*const IDedupDataPort.VTable, @ptrCast(self.vtable)).GetRequestResults(@as(*const IDedupDataPort, @ptrCast(self)), request_id_, max_wait_ms_, p_batch_result_, p_batch_count_, p_status_, pp_item_results_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDedupDataPortManager_Value = Guid.initString("44677452-b90a-445e-8192-cdcfe81511fb");
pub const IID_IDedupDataPortManager = &IID_IDedupDataPortManager_Value;
pub const IDedupDataPortManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConfiguration: *const fn (
            self: *const IDedupDataPortManager,
            p_min_chunk_size: ?*u32,
            p_max_chunk_size: ?*u32,
            p_chunking_algorithm: ?*DedupChunkingAlgorithm,
            p_hashing_algorithm: ?*DedupHashingAlgorithm,
            p_compression_algorithm: ?*DedupCompressionAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeStatus: *const fn (
            self: *const IDedupDataPortManager,
            options: u32,
            path: ?BSTR,
            p_status: ?*DedupDataPortVolumeStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeDataPort: *const fn (
            self: *const IDedupDataPortManager,
            options: u32,
            path: ?BSTR,
            pp_data_port: ?*?*IDedupDataPort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getConfiguration(self: *const T, p_min_chunk_size_: ?*u32, p_max_chunk_size_: ?*u32, p_chunking_algorithm_: ?*DedupChunkingAlgorithm, p_hashing_algorithm_: ?*DedupHashingAlgorithm, p_compression_algorithm_: ?*DedupCompressionAlgorithm) HRESULT {
                return @as(*const IDedupDataPortManager.VTable, @ptrCast(self.vtable)).GetConfiguration(@as(*const IDedupDataPortManager, @ptrCast(self)), p_min_chunk_size_, p_max_chunk_size_, p_chunking_algorithm_, p_hashing_algorithm_, p_compression_algorithm_);
            }
            pub inline fn getVolumeStatus(self: *const T, options_: u32, path_: ?BSTR, p_status_: ?*DedupDataPortVolumeStatus) HRESULT {
                return @as(*const IDedupDataPortManager.VTable, @ptrCast(self.vtable)).GetVolumeStatus(@as(*const IDedupDataPortManager, @ptrCast(self)), options_, path_, p_status_);
            }
            pub inline fn getVolumeDataPort(self: *const T, options_: u32, path_: ?BSTR, pp_data_port_: ?*?*IDedupDataPort) HRESULT {
                return @as(*const IDedupDataPortManager.VTable, @ptrCast(self.vtable)).GetVolumeDataPort(@as(*const IDedupDataPortManager, @ptrCast(self)), options_, path_, pp_data_port_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (6)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
