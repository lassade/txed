//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (287)
//--------------------------------------------------------------------------------
pub const IMAPI_SECTOR_SIZE = @as(u32, 2048);
pub const IMAPI2_DEFAULT_COMMAND_TIMEOUT = @as(u32, 10);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEADDED = @as(u32, 256);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_EJECTMEDIA = @as(u32, 256);
pub const DISPID_IDISCRECORDER2_CLOSETRAY = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS = @as(u32, 258);
pub const DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS = @as(u32, 259);
pub const DISPID_IDISCRECORDER2_DISABLEMCN = @as(u32, 260);
pub const DISPID_IDISCRECORDER2_ENABLEMCN = @as(u32, 261);
pub const DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER = @as(u32, 262);
pub const DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER = @as(u32, 0);
pub const DISPID_IDISCRECORDER2_VENDORID = @as(u32, 513);
pub const DISPID_IDISCRECORDER2_PRODUCTID = @as(u32, 514);
pub const DISPID_IDISCRECORDER2_PRODUCTREVISION = @as(u32, 515);
pub const DISPID_IDISCRECORDER2_VOLUMENAME = @as(u32, 516);
pub const DISPID_IDISCRECORDER2_VOLUMEPATHNAMES = @as(u32, 517);
pub const DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA = @as(u32, 518);
pub const DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER = @as(u32, 519);
pub const DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES = @as(u32, 520);
pub const DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES = @as(u32, 521);
pub const DISPID_IDISCRECORDER2_SUPPORTEDPROFILES = @as(u32, 522);
pub const DISPID_IDISCRECORDER2_CURRENTPROFILES = @as(u32, 523);
pub const DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES = @as(u32, 524);
pub const DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER = @as(u32, 525);
pub const DISPID_IWRITEENGINE2_WRITESECTION = @as(u32, 512);
pub const DISPID_IWRITEENGINE2_CANCELWRITE = @as(u32, 513);
pub const DISPID_IWRITEENGINE2_DISCRECORDER = @as(u32, 256);
pub const DISPID_IWRITEENGINE2_USESTREAMINGWRITE12 = @as(u32, 257);
pub const DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND = @as(u32, 258);
pub const DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND = @as(u32, 259);
pub const DISPID_IWRITEENGINE2_BYTESPERSECTOR = @as(u32, 260);
pub const DISPID_IWRITEENGINE2_WRITEINPROGRESS = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_STARTLBA = @as(u32, 256);
pub const DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA = @as(u32, 258);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA = @as(u32, 259);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER = @as(u32, 260);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER = @as(u32, 262);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER = @as(u32, 263);
pub const DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER = @as(u32, 264);
pub const DISPID_DWRITEENGINE2EVENTS_UPDATE = @as(u32, 256);
pub const DISPID_IDISCFORMAT2_RECORDERSUPPORTED = @as(u32, 2048);
pub const DISPID_IDISCFORMAT2_MEDIASUPPORTED = @as(u32, 2049);
pub const DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK = @as(u32, 1792);
pub const DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK = @as(u32, 1793);
pub const DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES = @as(u32, 1794);
pub const DISPID_IDISCFORMAT2ERASE_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2ERASE_FULLERASE = @as(u32, 257);
pub const DISPID_IDISCFORMAT2ERASE_MEDIATYPE = @as(u32, 258);
pub const DISPID_IDISCFORMAT2ERASE_CLIENTNAME = @as(u32, 259);
pub const DISPID_IDISCFORMAT2ERASE_ERASEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED = @as(u32, 257);
pub const DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE = @as(u32, 260);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS = @as(u32, 262);
pub const DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS = @as(u32, 263);
pub const DISPID_IDISCFORMAT2DATA_TOTALSECTORS = @as(u32, 264);
pub const DISPID_IDISCFORMAT2DATA_FREESECTORS = @as(u32, 265);
pub const DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION = @as(u32, 267);
pub const DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION = @as(u32, 268);
pub const DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE = @as(u32, 270);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE = @as(u32, 271);
pub const DISPID_IDISCFORMAT2DATA_CLIENTNAME = @as(u32, 272);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED = @as(u32, 275);
pub const DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV = @as(u32, 276);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS = @as(u32, 277);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 278);
pub const DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE = @as(u32, 279);
pub const DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES = @as(u32, 280);
pub const DISPID_IDISCFORMAT2DATA_WRITE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_CANCELWRITE = @as(u32, 513);
pub const DISPID_IDISCFORMAT2DATA_SETWRITESPEED = @as(u32, 514);
pub const DISPID_DDISCFORMAT2DATAEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAO_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS = @as(u32, 259);
pub const DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA = @as(u32, 260);
pub const DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA = @as(u32, 261);
pub const DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA = @as(u32, 262);
pub const DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA = @as(u32, 263);
pub const DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE = @as(u32, 267);
pub const DISPID_IDISCFORMAT2TAO_CLIENTNAME = @as(u32, 270);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED = @as(u32, 271);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 272);
pub const DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS = @as(u32, 275);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 276);
pub const DISPID_IDISCFORMAT2TAO_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK = @as(u32, 513);
pub const DISPID_IDISCFORMAT2TAO_CANCELADDTRACK = @as(u32, 514);
pub const DISPID_IDISCFORMAT2TAO_FINISHMEDIA = @as(u32, 515);
pub const DISPID_IDISCFORMAT2TAO_SETWRITESPEED = @as(u32, 516);
pub const DISPID_DDISCFORMAT2TAOEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 772);
pub const DISPID_IDISCFORMAT2RAWCD_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION = @as(u32, 259);
pub const DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT = @as(u32, 260);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE = @as(u32, 261);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES = @as(u32, 264);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE = @as(u32, 265);
pub const DISPID_IDISCFORMAT2RAWCD_CLIENTNAME = @as(u32, 266);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED = @as(u32, 267);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 268);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV = @as(u32, 270);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS = @as(u32, 271);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 272);
pub const DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION = @as(u32, 514);
pub const DISPID_IDISCFORMAT2RAWCD_CANCELWRITE = @as(u32, 515);
pub const DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA = @as(u32, 516);
pub const DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED = @as(u32, 517);
pub const DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_CD = @as(u32, 75);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_DVD = @as(u32, 680);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_BD = @as(u32, 2195);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD = @as(u32, 4568);
pub const DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA = @as(u32, 256);
pub const DISPID_IMULTISESSION_INUSE = @as(u32, 257);
pub const DISPID_IMULTISESSION_IMPORTRECORDER = @as(u32, 258);
pub const DISPID_IMULTISESSION_FIRSTDATASESSION = @as(u32, 512);
pub const DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION = @as(u32, 513);
pub const DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION = @as(u32, 514);
pub const DISPID_IMULTISESSION_NEXTWRITABLEADDRESS = @as(u32, 515);
pub const DISPID_IMULTISESSION_FREESECTORS = @as(u32, 516);
pub const DISPID_IMULTISESSION_WRITEUNITSIZE = @as(u32, 517);
pub const DISPID_IMULTISESSION_LASTWRITTENADDRESS = @as(u32, 518);
pub const DISPID_IMULTISESSION_SECTORSONMEDIA = @as(u32, 519);
pub const DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE = @as(u32, 512);
pub const DISPID_IRAWCDIMAGECREATOR_ADDTRACK = @as(u32, 513);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP = @as(u32, 514);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR = @as(u32, 515);
pub const DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE = @as(u32, 256);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT = @as(u32, 257);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT = @as(u32, 258);
pub const DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO = @as(u32, 259);
pub const DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER = @as(u32, 260);
pub const DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER = @as(u32, 261);
pub const DISPID_IRAWCDIMAGECREATOR_TRACKINFO = @as(u32, 262);
pub const DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS = @as(u32, 263);
pub const DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC = @as(u32, 264);
pub const DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS = @as(u32, 265);
pub const DISPID_IRAWCDTRACKINFO_STARTINGLBA = @as(u32, 256);
pub const DISPID_IRAWCDTRACKINFO_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IRAWCDTRACKINFO_TRACKNUMBER = @as(u32, 258);
pub const DISPID_IRAWCDTRACKINFO_SECTORTYPE = @as(u32, 259);
pub const DISPID_IRAWCDTRACKINFO_ISRC = @as(u32, 260);
pub const DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING = @as(u32, 261);
pub const DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS = @as(u32, 262);
pub const DISPID_IBLOCKRANGE_STARTLBA = @as(u32, 256);
pub const DISPID_IBLOCKRANGE_ENDLBA = @as(u32, 257);
pub const DISPID_IBLOCKRANGELIST_BLOCKRANGES = @as(u32, 256);
pub const IMAPILib2_MajorVersion = @as(u32, 1);
pub const IMAPILib2_MinorVersion = @as(u32, 0);
pub const IMAPI2FS_BOOT_ENTRY_COUNT_MAX = @as(u32, 32);
pub const DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE = @as(u32, 256);
pub const DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT = @as(u32, 257);
pub const IMAPI2FS_MajorVersion = @as(u32, 1);
pub const IMAPI2FS_MinorVersion = @as(u32, 0);
pub const IMAPI2FS_FullVersion_STR = "1.0";
pub const IMAPI2FS_FullVersion_WSTR = "1.0";
pub const MP_MSGCLASS_SYSTEM = @as(u32, 1);
pub const MP_MSGCLASS_REPLICATION = @as(u32, 2);
pub const MP_MSGCLASS_DELIVERY_REPORT = @as(u32, 3);
pub const MP_MSGCLASS_NONDELIVERY_REPORT = @as(u32, 4);
pub const MP_STATUS_SUCCESS = @as(u32, 0);
pub const MP_STATUS_RETRY = @as(u32, 1);
pub const MP_STATUS_ABORT_DELIVERY = @as(u32, 2);
pub const MP_STATUS_BAD_MAIL = @as(u32, 3);
pub const MP_STATUS_SUBMITTED = @as(u32, 4);
pub const MP_STATUS_CATEGORIZED = @as(u32, 5);
pub const MP_STATUS_ABANDON_DELIVERY = @as(u32, 6);
pub const RP_RECIP_FLAGS_RESERVED = @as(u32, 15);
pub const RP_DSN_NOTIFY_SUCCESS = @as(u32, 16777216);
pub const RP_DSN_NOTIFY_FAILURE = @as(u32, 33554432);
pub const RP_DSN_NOTIFY_DELAY = @as(u32, 67108864);
pub const RP_DSN_NOTIFY_NEVER = @as(u32, 134217728);
pub const RP_DSN_NOTIFY_MASK = @as(u32, 251658240);
pub const RP_HANDLED = @as(u32, 16);
pub const RP_GENERAL_FAILURE = @as(u32, 32);
pub const RP_DSN_HANDLED = @as(u32, 64);
pub const RP_DELIVERED = @as(u32, 272);
pub const RP_DSN_SENT_NDR = @as(u32, 1104);
pub const RP_FAILED = @as(u32, 2096);
pub const RP_UNRESOLVED = @as(u32, 4144);
pub const RP_ENPANDED = @as(u32, 8208);
pub const RP_EXPANDED = @as(u32, 8208);
pub const RP_DSN_SENT_DELAYED = @as(u32, 16384);
pub const RP_DSN_SENT_EXPANDED = @as(u32, 32832);
pub const RP_DSN_SENT_RELAYED = @as(u32, 65600);
pub const RP_DSN_SENT_DELIVERED = @as(u32, 131136);
pub const RP_REMOTE_MTA_NO_DSN = @as(u32, 524288);
pub const RP_ERROR_CONTEXT_STORE = @as(u32, 1048576);
pub const RP_ERROR_CONTEXT_CAT = @as(u32, 2097152);
pub const RP_ERROR_CONTEXT_MTA = @as(u32, 4194304);
pub const RP_VOLATILE_FLAGS_MASK = @as(u32, 4026531840);
pub const RP_DSN_NOTIFY_INVALID = @as(u32, 0);
pub const MPV_INBOUND_CUTOFF_EXCEEDED = @as(u32, 1);
pub const MPV_WRITE_CONTENT = @as(u32, 2);
pub const NMP_PROCESS_POST = @as(u32, 1);
pub const NMP_PROCESS_CONTROL = @as(u32, 2);
pub const NMP_PROCESS_MODERATOR = @as(u32, 4);
pub const GUID_SMTP_SOURCE_TYPE = Guid.initString("fb65c4dc-e468-11d1-aa67-00c04fa345f6");
pub const GUID_SMTPSVC_SOURCE = Guid.initString("1b3c0666-e470-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_ON_INBOUND_COMMAND = Guid.initString("f6628c8d-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SERVER_RESPONSE = Guid.initString("f6628c8e-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_START = Guid.initString("f6628c8f-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_MESSAGE_START = Guid.initString("f6628c90-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_PER_RECIPIENT = Guid.initString("f6628c91-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_BEFORE_DATA = Guid.initString("f6628c92-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_END = Guid.initString("f6628c93-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_STORE_DRIVER = Guid.initString("59175850-e533-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_TRANSPORT_SUBMISSION = Guid.initString("ff3caa23-00b9-11d2-9dfb-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_PRECATEGORIZE = Guid.initString("a3acfb0d-83ff-11d2-9e14-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_CATEGORIZE = Guid.initString("960252a3-0a3a-11d2-9e00-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_POSTCATEGORIZE = Guid.initString("76719654-05a6-11d2-9dfd-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_ROUTER = Guid.initString("283430c9-1850-11d2-9e03-00c04fa322ba");
pub const CATID_SMTP_MSGTRACKLOG = Guid.initString("c6df52aa-7db0-11d2-94f4-00c04f79f1d6");
pub const CATID_SMTP_DNSRESOLVERRECORDSINK = Guid.initString("bd0b4366-8e03-11d2-94f6-00c04f79f1d6");
pub const CATID_SMTP_MAXMSGSIZE = Guid.initString("ebf159de-a67e-11d2-94f7-00c04f79f1d6");
pub const CATID_SMTP_LOG = Guid.initString("93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97");
pub const CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS = Guid.initString("84ff368a-fab3-43d7-bcdf-692c5b46e6b1");
pub const CLSID_SmtpCat = Guid.initString("b23c35b7-9219-11d2-9e17-00c04fa322ba");
pub const CATID_SMTP_DSN = Guid.initString("22b55731-f5f8-4d23-bd8f-87b52371a73a");
pub const SZ_PROGID_SMTPCAT = "Smtp.Cat";
pub const IMAPI_S_PROPERTIESIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const IMAPI_S_BUFFER_TO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const IMAPI_E_NOTOPENED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const IMAPI_E_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const IMAPI_E_USERABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const IMAPI_E_GENERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const IMAPI_E_MEDIUM_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const IMAPI_E_MEDIUM_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const IMAPI_E_DEVICE_NOPROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const IMAPI_E_DEVICE_NOTACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const IMAPI_E_DEVICE_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const IMAPI_E_DEVICE_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const IMAPI_E_INITIALIZE_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const IMAPI_E_INITIALIZE_ENDWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const IMAPI_E_FILESYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const IMAPI_E_FILEACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const IMAPI_E_DISCINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const IMAPI_E_TRACKNOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const IMAPI_E_TRACKOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const IMAPI_E_DISCFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const IMAPI_E_BADJOLIETNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const IMAPI_E_INVALIDIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const IMAPI_E_NOACTIVEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const IMAPI_E_NOACTIVERECORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const IMAPI_E_WRONGFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const IMAPI_E_ALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const IMAPI_E_WRONGDISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const IMAPI_E_FILEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const IMAPI_E_STASHINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const IMAPI_E_DEVICE_STILL_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const IMAPI_E_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const IMAPI_E_COMPRESSEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const IMAPI_E_ENCRYPTEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const IMAPI_E_NOTENOUGHDISKFORSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const IMAPI_E_REMOVABLESTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const IMAPI_E_CANNOT_WRITE_TO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const IMAPI_E_TRACK_NOT_BIG_ENOUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));

//--------------------------------------------------------------------------------
// Section: Types (130)
//--------------------------------------------------------------------------------
pub const DISC_RECORDER_STATE_FLAGS = enum(u32) {
    BURNING = 2,
    DOING_NOTHING = 0,
    OPENED = 1,
};
pub const RECORDER_BURNING = DISC_RECORDER_STATE_FLAGS.BURNING;
pub const RECORDER_DOING_NOTHING = DISC_RECORDER_STATE_FLAGS.DOING_NOTHING;
pub const RECORDER_OPENED = DISC_RECORDER_STATE_FLAGS.OPENED;

const CLSID_MsftDiscMaster2_Value = Guid.initString("2735412e-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscMaster2 = &CLSID_MsftDiscMaster2_Value;

const CLSID_MsftDiscRecorder2_Value = Guid.initString("2735412d-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscRecorder2 = &CLSID_MsftDiscRecorder2_Value;

const CLSID_MsftWriteEngine2_Value = Guid.initString("2735412c-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteEngine2 = &CLSID_MsftWriteEngine2_Value;

const CLSID_MsftDiscFormat2Erase_Value = Guid.initString("2735412b-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Erase = &CLSID_MsftDiscFormat2Erase_Value;

const CLSID_MsftDiscFormat2Data_Value = Guid.initString("2735412a-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Data = &CLSID_MsftDiscFormat2Data_Value;

const CLSID_MsftDiscFormat2TrackAtOnce_Value = Guid.initString("27354129-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2TrackAtOnce = &CLSID_MsftDiscFormat2TrackAtOnce_Value;

const CLSID_MsftDiscFormat2RawCD_Value = Guid.initString("27354128-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2RawCD = &CLSID_MsftDiscFormat2RawCD_Value;

const CLSID_MsftStreamZero_Value = Guid.initString("27354127-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamZero = &CLSID_MsftStreamZero_Value;

const CLSID_MsftStreamPrng001_Value = Guid.initString("27354126-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamPrng001 = &CLSID_MsftStreamPrng001_Value;

const CLSID_MsftStreamConcatenate_Value = Guid.initString("27354125-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamConcatenate = &CLSID_MsftStreamConcatenate_Value;

const CLSID_MsftStreamInterleave_Value = Guid.initString("27354124-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamInterleave = &CLSID_MsftStreamInterleave_Value;

const CLSID_MsftWriteSpeedDescriptor_Value = Guid.initString("27354123-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteSpeedDescriptor = &CLSID_MsftWriteSpeedDescriptor_Value;

const CLSID_MsftMultisessionSequential_Value = Guid.initString("27354122-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftMultisessionSequential = &CLSID_MsftMultisessionSequential_Value;

const CLSID_MsftMultisessionRandomWrite_Value = Guid.initString("b507ca24-2204-11dd-966a-001aa01bbc58");
pub const CLSID_MsftMultisessionRandomWrite = &CLSID_MsftMultisessionRandomWrite_Value;

const CLSID_MsftRawCDImageCreator_Value = Guid.initString("25983561-9d65-49ce-b335-40630d901227");
pub const CLSID_MsftRawCDImageCreator = &CLSID_MsftRawCDImageCreator_Value;

pub const IMAPI_MEDIA_PHYSICAL_TYPE = enum(i32) {
    UNKNOWN = 0,
    CDROM = 1,
    CDR = 2,
    CDRW = 3,
    DVDROM = 4,
    DVDRAM = 5,
    DVDPLUSR = 6,
    DVDPLUSRW = 7,
    DVDPLUSR_DUALLAYER = 8,
    DVDDASHR = 9,
    DVDDASHRW = 10,
    DVDDASHR_DUALLAYER = 11,
    DISK = 12,
    DVDPLUSRW_DUALLAYER = 13,
    HDDVDROM = 14,
    HDDVDR = 15,
    HDDVDRAM = 16,
    BDROM = 17,
    BDR = 18,
    BDRE = 19,
    // MAX = 19, this enum value conflicts with BDRE
};
pub const IMAPI_MEDIA_TYPE_UNKNOWN = IMAPI_MEDIA_PHYSICAL_TYPE.UNKNOWN;
pub const IMAPI_MEDIA_TYPE_CDROM = IMAPI_MEDIA_PHYSICAL_TYPE.CDROM;
pub const IMAPI_MEDIA_TYPE_CDR = IMAPI_MEDIA_PHYSICAL_TYPE.CDR;
pub const IMAPI_MEDIA_TYPE_CDRW = IMAPI_MEDIA_PHYSICAL_TYPE.CDRW;
pub const IMAPI_MEDIA_TYPE_DVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDROM;
pub const IMAPI_MEDIA_TYPE_DVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDRAM;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DVDDASHR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR;
pub const IMAPI_MEDIA_TYPE_DVDDASHRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHRW;
pub const IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DISK = IMAPI_MEDIA_PHYSICAL_TYPE.DISK;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_HDDVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDROM;
pub const IMAPI_MEDIA_TYPE_HDDVDR = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDR;
pub const IMAPI_MEDIA_TYPE_HDDVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDRAM;
pub const IMAPI_MEDIA_TYPE_BDROM = IMAPI_MEDIA_PHYSICAL_TYPE.BDROM;
pub const IMAPI_MEDIA_TYPE_BDR = IMAPI_MEDIA_PHYSICAL_TYPE.BDR;
pub const IMAPI_MEDIA_TYPE_BDRE = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;
pub const IMAPI_MEDIA_TYPE_MAX = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;

pub const IMAPI_MEDIA_WRITE_PROTECT_STATE = enum(i32) {
    UNTIL_POWERDOWN = 1,
    BY_CARTRIDGE = 2,
    BY_MEDIA_SPECIFIC_REASON = 4,
    BY_SOFTWARE_WRITE_PROTECT = 8,
    BY_DISC_CONTROL_BLOCK = 16,
    READ_ONLY_MEDIA = 16384,
};
pub const IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN = IMAPI_MEDIA_WRITE_PROTECT_STATE.UNTIL_POWERDOWN;
pub const IMAPI_WRITEPROTECTED_BY_CARTRIDGE = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_CARTRIDGE;
pub const IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_MEDIA_SPECIFIC_REASON;
pub const IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_SOFTWARE_WRITE_PROTECT;
pub const IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_DISC_CONTROL_BLOCK;
pub const IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA = IMAPI_MEDIA_WRITE_PROTECT_STATE.READ_ONLY_MEDIA;

pub const IMAPI_READ_TRACK_ADDRESS_TYPE = enum(i32) {
    LBA = 0,
    TRACK = 1,
    SESSION = 2,
};
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_LBA = IMAPI_READ_TRACK_ADDRESS_TYPE.LBA;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK = IMAPI_READ_TRACK_ADDRESS_TYPE.TRACK;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION = IMAPI_READ_TRACK_ADDRESS_TYPE.SESSION;

pub const IMAPI_MODE_PAGE_REQUEST_TYPE = enum(i32) {
    CURRENT_VALUES = 0,
    CHANGEABLE_VALUES = 1,
    DEFAULT_VALUES = 2,
    SAVED_VALUES = 3,
};
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CURRENT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CHANGEABLE_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.DEFAULT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.SAVED_VALUES;

pub const IMAPI_MODE_PAGE_TYPE = enum(i32) {
    READ_WRITE_ERROR_RECOVERY = 1,
    MRW = 3,
    WRITE_PARAMETERS = 5,
    CACHING = 8,
    INFORMATIONAL_EXCEPTIONS = 28,
    TIMEOUT_AND_PROTECT = 29,
    POWER_CONDITION = 26,
    LEGACY_CAPABILITIES = 42,
};
pub const IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY = IMAPI_MODE_PAGE_TYPE.READ_WRITE_ERROR_RECOVERY;
pub const IMAPI_MODE_PAGE_TYPE_MRW = IMAPI_MODE_PAGE_TYPE.MRW;
pub const IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS = IMAPI_MODE_PAGE_TYPE.WRITE_PARAMETERS;
pub const IMAPI_MODE_PAGE_TYPE_CACHING = IMAPI_MODE_PAGE_TYPE.CACHING;
pub const IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS = IMAPI_MODE_PAGE_TYPE.INFORMATIONAL_EXCEPTIONS;
pub const IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT = IMAPI_MODE_PAGE_TYPE.TIMEOUT_AND_PROTECT;
pub const IMAPI_MODE_PAGE_TYPE_POWER_CONDITION = IMAPI_MODE_PAGE_TYPE.POWER_CONDITION;
pub const IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES = IMAPI_MODE_PAGE_TYPE.LEGACY_CAPABILITIES;

pub const IMAPI_FEATURE_PAGE_TYPE = enum(i32) {
    PROFILE_LIST = 0,
    CORE = 1,
    MORPHING = 2,
    REMOVABLE_MEDIUM = 3,
    WRITE_PROTECT = 4,
    RANDOMLY_READABLE = 16,
    CD_MULTIREAD = 29,
    CD_READ = 30,
    DVD_READ = 31,
    RANDOMLY_WRITABLE = 32,
    INCREMENTAL_STREAMING_WRITABLE = 33,
    SECTOR_ERASABLE = 34,
    FORMATTABLE = 35,
    HARDWARE_DEFECT_MANAGEMENT = 36,
    WRITE_ONCE = 37,
    RESTRICTED_OVERWRITE = 38,
    CDRW_CAV_WRITE = 39,
    MRW = 40,
    ENHANCED_DEFECT_REPORTING = 41,
    DVD_PLUS_RW = 42,
    DVD_PLUS_R = 43,
    RIGID_RESTRICTED_OVERWRITE = 44,
    CD_TRACK_AT_ONCE = 45,
    CD_MASTERING = 46,
    DVD_DASH_WRITE = 47,
    DOUBLE_DENSITY_CD_READ = 48,
    DOUBLE_DENSITY_CD_R_WRITE = 49,
    DOUBLE_DENSITY_CD_RW_WRITE = 50,
    LAYER_JUMP_RECORDING = 51,
    CD_RW_MEDIA_WRITE_SUPPORT = 55,
    BD_PSEUDO_OVERWRITE = 56,
    DVD_PLUS_R_DUAL_LAYER = 59,
    BD_READ = 64,
    BD_WRITE = 65,
    HD_DVD_READ = 80,
    HD_DVD_WRITE = 81,
    POWER_MANAGEMENT = 256,
    SMART = 257,
    EMBEDDED_CHANGER = 258,
    CD_ANALOG_PLAY = 259,
    MICROCODE_UPDATE = 260,
    TIMEOUT = 261,
    DVD_CSS = 262,
    REAL_TIME_STREAMING = 263,
    LOGICAL_UNIT_SERIAL_NUMBER = 264,
    MEDIA_SERIAL_NUMBER = 265,
    DISC_CONTROL_BLOCKS = 266,
    DVD_CPRM = 267,
    FIRMWARE_INFORMATION = 268,
    AACS = 269,
    VCPS = 272,
};
pub const IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST = IMAPI_FEATURE_PAGE_TYPE.PROFILE_LIST;
pub const IMAPI_FEATURE_PAGE_TYPE_CORE = IMAPI_FEATURE_PAGE_TYPE.CORE;
pub const IMAPI_FEATURE_PAGE_TYPE_MORPHING = IMAPI_FEATURE_PAGE_TYPE.MORPHING;
pub const IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM = IMAPI_FEATURE_PAGE_TYPE.REMOVABLE_MEDIUM;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT = IMAPI_FEATURE_PAGE_TYPE.WRITE_PROTECT;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_READABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD = IMAPI_FEATURE_PAGE_TYPE.CD_MULTIREAD;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_READ = IMAPI_FEATURE_PAGE_TYPE.CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.INCREMENTAL_STREAMING_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE = IMAPI_FEATURE_PAGE_TYPE.SECTOR_ERASABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE = IMAPI_FEATURE_PAGE_TYPE.FORMATTABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.HARDWARE_DEFECT_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE = IMAPI_FEATURE_PAGE_TYPE.WRITE_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE = IMAPI_FEATURE_PAGE_TYPE.CDRW_CAV_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_MRW = IMAPI_FEATURE_PAGE_TYPE.MRW;
pub const IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING = IMAPI_FEATURE_PAGE_TYPE.ENHANCED_DEFECT_REPORTING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_RW;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R;
pub const IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RIGID_RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE = IMAPI_FEATURE_PAGE_TYPE.CD_TRACK_AT_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING = IMAPI_FEATURE_PAGE_TYPE.CD_MASTERING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE = IMAPI_FEATURE_PAGE_TYPE.DVD_DASH_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_R_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_RW_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING = IMAPI_FEATURE_PAGE_TYPE.LAYER_JUMP_RECORDING;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT = IMAPI_FEATURE_PAGE_TYPE.CD_RW_MEDIA_WRITE_SUPPORT;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.BD_PSEUDO_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R_DUAL_LAYER;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_READ = IMAPI_FEATURE_PAGE_TYPE.BD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_WRITE = IMAPI_FEATURE_PAGE_TYPE.BD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.POWER_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_SMART = IMAPI_FEATURE_PAGE_TYPE.SMART;
pub const IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER = IMAPI_FEATURE_PAGE_TYPE.EMBEDDED_CHANGER;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY = IMAPI_FEATURE_PAGE_TYPE.CD_ANALOG_PLAY;
pub const IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE = IMAPI_FEATURE_PAGE_TYPE.MICROCODE_UPDATE;
pub const IMAPI_FEATURE_PAGE_TYPE_TIMEOUT = IMAPI_FEATURE_PAGE_TYPE.TIMEOUT;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CSS = IMAPI_FEATURE_PAGE_TYPE.DVD_CSS;
pub const IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING = IMAPI_FEATURE_PAGE_TYPE.REAL_TIME_STREAMING;
pub const IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.LOGICAL_UNIT_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.MEDIA_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS = IMAPI_FEATURE_PAGE_TYPE.DISC_CONTROL_BLOCKS;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM = IMAPI_FEATURE_PAGE_TYPE.DVD_CPRM;
pub const IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION = IMAPI_FEATURE_PAGE_TYPE.FIRMWARE_INFORMATION;
pub const IMAPI_FEATURE_PAGE_TYPE_AACS = IMAPI_FEATURE_PAGE_TYPE.AACS;
pub const IMAPI_FEATURE_PAGE_TYPE_VCPS = IMAPI_FEATURE_PAGE_TYPE.VCPS;

pub const IMAPI_PROFILE_TYPE = enum(i32) {
    INVALID = 0,
    NON_REMOVABLE_DISK = 1,
    REMOVABLE_DISK = 2,
    MO_ERASABLE = 3,
    MO_WRITE_ONCE = 4,
    AS_MO = 5,
    CDROM = 8,
    CD_RECORDABLE = 9,
    CD_REWRITABLE = 10,
    DVDROM = 16,
    DVD_DASH_RECORDABLE = 17,
    DVD_RAM = 18,
    DVD_DASH_REWRITABLE = 19,
    DVD_DASH_RW_SEQUENTIAL = 20,
    DVD_DASH_R_DUAL_SEQUENTIAL = 21,
    DVD_DASH_R_DUAL_LAYER_JUMP = 22,
    DVD_PLUS_RW = 26,
    DVD_PLUS_R = 27,
    DDCDROM = 32,
    DDCD_RECORDABLE = 33,
    DDCD_REWRITABLE = 34,
    DVD_PLUS_RW_DUAL = 42,
    DVD_PLUS_R_DUAL = 43,
    BD_ROM = 64,
    BD_R_SEQUENTIAL = 65,
    BD_R_RANDOM_RECORDING = 66,
    BD_REWRITABLE = 67,
    HD_DVD_ROM = 80,
    HD_DVD_RECORDABLE = 81,
    HD_DVD_RAM = 82,
    NON_STANDARD = 65535,
};
pub const IMAPI_PROFILE_TYPE_INVALID = IMAPI_PROFILE_TYPE.INVALID;
pub const IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.NON_REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_MO_ERASABLE = IMAPI_PROFILE_TYPE.MO_ERASABLE;
pub const IMAPI_PROFILE_TYPE_MO_WRITE_ONCE = IMAPI_PROFILE_TYPE.MO_WRITE_ONCE;
pub const IMAPI_PROFILE_TYPE_AS_MO = IMAPI_PROFILE_TYPE.AS_MO;
pub const IMAPI_PROFILE_TYPE_CDROM = IMAPI_PROFILE_TYPE.CDROM;
pub const IMAPI_PROFILE_TYPE_CD_RECORDABLE = IMAPI_PROFILE_TYPE.CD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_CD_REWRITABLE = IMAPI_PROFILE_TYPE.CD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVDROM = IMAPI_PROFILE_TYPE.DVDROM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE = IMAPI_PROFILE_TYPE.DVD_DASH_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DVD_RAM = IMAPI_PROFILE_TYPE.DVD_RAM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE = IMAPI_PROFILE_TYPE.DVD_DASH_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_RW_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_LAYER_JUMP;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW = IMAPI_PROFILE_TYPE.DVD_PLUS_RW;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R = IMAPI_PROFILE_TYPE.DVD_PLUS_R;
pub const IMAPI_PROFILE_TYPE_DDCDROM = IMAPI_PROFILE_TYPE.DDCDROM;
pub const IMAPI_PROFILE_TYPE_DDCD_RECORDABLE = IMAPI_PROFILE_TYPE.DDCD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DDCD_REWRITABLE = IMAPI_PROFILE_TYPE.DDCD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_RW_DUAL;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_R_DUAL;
pub const IMAPI_PROFILE_TYPE_BD_ROM = IMAPI_PROFILE_TYPE.BD_ROM;
pub const IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL = IMAPI_PROFILE_TYPE.BD_R_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING = IMAPI_PROFILE_TYPE.BD_R_RANDOM_RECORDING;
pub const IMAPI_PROFILE_TYPE_BD_REWRITABLE = IMAPI_PROFILE_TYPE.BD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_ROM = IMAPI_PROFILE_TYPE.HD_DVD_ROM;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE = IMAPI_PROFILE_TYPE.HD_DVD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RAM = IMAPI_PROFILE_TYPE.HD_DVD_RAM;
pub const IMAPI_PROFILE_TYPE_NON_STANDARD = IMAPI_PROFILE_TYPE.NON_STANDARD;

pub const IMAPI_FORMAT2_DATA_WRITE_ACTION = enum(i32) {
    VALIDATING_MEDIA = 0,
    FORMATTING_MEDIA = 1,
    INITIALIZING_HARDWARE = 2,
    CALIBRATING_POWER = 3,
    WRITING_DATA = 4,
    FINALIZATION = 5,
    COMPLETED = 6,
    VERIFYING = 7,
};
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.VALIDATING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.FORMATTING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE = IMAPI_FORMAT2_DATA_WRITE_ACTION.INITIALIZING_HARDWARE;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER = IMAPI_FORMAT2_DATA_WRITE_ACTION.CALIBRATING_POWER;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA = IMAPI_FORMAT2_DATA_WRITE_ACTION.WRITING_DATA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION = IMAPI_FORMAT2_DATA_WRITE_ACTION.FINALIZATION;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED = IMAPI_FORMAT2_DATA_WRITE_ACTION.COMPLETED;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_DATA_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_DATA_MEDIA_STATE = enum(i32) {
    UNKNOWN = 0,
    INFORMATIONAL_MASK = 15,
    UNSUPPORTED_MASK = 64512,
    OVERWRITE_ONLY = 1,
    // RANDOMLY_WRITABLE = 1, this enum value conflicts with OVERWRITE_ONLY
    BLANK = 2,
    APPENDABLE = 4,
    FINAL_SESSION = 8,
    DAMAGED = 1024,
    ERASE_REQUIRED = 2048,
    NON_EMPTY_SESSION = 4096,
    WRITE_PROTECTED = 8192,
    FINALIZED = 16384,
    UNSUPPORTED_MEDIA = 32768,
};
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNKNOWN;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.INFORMATIONAL_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK = IMAPI_FORMAT2_DATA_MEDIA_STATE.BLANK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.APPENDABLE;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINAL_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED = IMAPI_FORMAT2_DATA_MEDIA_STATE.DAMAGED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED = IMAPI_FORMAT2_DATA_MEDIA_STATE.ERASE_REQUIRED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.NON_EMPTY_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED = IMAPI_FORMAT2_DATA_MEDIA_STATE.WRITE_PROTECTED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINALIZED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MEDIA;

pub const IMAPI_FORMAT2_TAO_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
    VERIFYING = 4,
};
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_TAO_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_TAO_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING = IMAPI_FORMAT2_TAO_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_TAO_WRITE_ACTION.FINISHING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_TAO_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE = enum(i32) {
    PQ_ONLY = 1,
    IS_COOKED = 2,
    IS_RAW = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.PQ_ONLY;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_COOKED;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_RAW;

pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.FINISHING;

pub const IMAPI_CD_SECTOR_TYPE = enum(i32) {
    AUDIO = 0,
    MODE_ZERO = 1,
    MODE1 = 2,
    MODE2FORM0 = 3,
    MODE2FORM1 = 4,
    MODE2FORM2 = 5,
    MODE1RAW = 6,
    MODE2FORM0RAW = 7,
    MODE2FORM1RAW = 8,
    MODE2FORM2RAW = 9,
};
pub const IMAPI_CD_SECTOR_AUDIO = IMAPI_CD_SECTOR_TYPE.AUDIO;
pub const IMAPI_CD_SECTOR_MODE_ZERO = IMAPI_CD_SECTOR_TYPE.MODE_ZERO;
pub const IMAPI_CD_SECTOR_MODE1 = IMAPI_CD_SECTOR_TYPE.MODE1;
pub const IMAPI_CD_SECTOR_MODE2FORM0 = IMAPI_CD_SECTOR_TYPE.MODE2FORM0;
pub const IMAPI_CD_SECTOR_MODE2FORM1 = IMAPI_CD_SECTOR_TYPE.MODE2FORM1;
pub const IMAPI_CD_SECTOR_MODE2FORM2 = IMAPI_CD_SECTOR_TYPE.MODE2FORM2;
pub const IMAPI_CD_SECTOR_MODE1RAW = IMAPI_CD_SECTOR_TYPE.MODE1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM0RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM0RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM1RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM2RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM2RAW;

pub const IMAPI_CD_TRACK_DIGITAL_COPY_SETTING = enum(i32) {
    PERMITTED = 0,
    PROHIBITED = 1,
    SCMS = 2,
};
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PERMITTED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PROHIBITED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_SCMS = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.SCMS;

pub const IMAPI_BURN_VERIFICATION_LEVEL = enum(i32) {
    NONE = 0,
    QUICK = 1,
    FULL = 2,
};
pub const IMAPI_BURN_VERIFICATION_NONE = IMAPI_BURN_VERIFICATION_LEVEL.NONE;
pub const IMAPI_BURN_VERIFICATION_QUICK = IMAPI_BURN_VERIFICATION_LEVEL.QUICK;
pub const IMAPI_BURN_VERIFICATION_FULL = IMAPI_BURN_VERIFICATION_LEVEL.FULL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscMaster2_Value = Guid.initString("27354130-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscMaster2 = &IID_IDiscMaster2_Value;
pub const IDiscMaster2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscMaster2,
            ppunk: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscMaster2,
            index: i32,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscMaster2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedEnvironment: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscMaster2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, ppunk_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IDiscMaster2, @ptrCast(self)), ppunk_);
            }
            pub inline fn getItem(self: *const T, index_: i32, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IDiscMaster2, @ptrCast(self)), index_, value_);
            }
            pub inline fn getCount(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IDiscMaster2, @ptrCast(self)), value_);
            }
            pub inline fn getIsSupportedEnvironment(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_IsSupportedEnvironment(@as(*const IDiscMaster2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscMaster2Events_Value = Guid.initString("27354131-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscMaster2Events = &IID_DDiscMaster2Events_Value;
pub const DDiscMaster2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        NotifyDeviceAdded: *const fn (
            self: *const DDiscMaster2Events,
            object: ?*IDispatch,
            unique_id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyDeviceRemoved: *const fn (
            self: *const DDiscMaster2Events,
            object: ?*IDispatch,
            unique_id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn notifyDeviceAdded(self: *const T, object_: ?*IDispatch, unique_id_: ?BSTR) HRESULT {
                return @as(*const DDiscMaster2Events.VTable, @ptrCast(self.vtable)).NotifyDeviceAdded(@as(*const DDiscMaster2Events, @ptrCast(self)), object_, unique_id_);
            }
            pub inline fn notifyDeviceRemoved(self: *const T, object_: ?*IDispatch, unique_id_: ?BSTR) HRESULT {
                return @as(*const DDiscMaster2Events.VTable, @ptrCast(self.vtable)).NotifyDeviceRemoved(@as(*const DDiscMaster2Events, @ptrCast(self)), object_, unique_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2Ex_Value = Guid.initString("27354132-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2Ex = &IID_IDiscRecorder2Ex_Value;
pub const IDiscRecorder2Ex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendCommandNoData: *const fn (
            self: *const IDiscRecorder2Ex,
            cdb: [*:0]u8,
            cdb_size: u32,
            sense_buffer: *[18]u8,
            timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendCommandSendDataToDevice: *const fn (
            self: *const IDiscRecorder2Ex,
            cdb: [*:0]u8,
            cdb_size: u32,
            sense_buffer: *[18]u8,
            timeout: u32,
            buffer: [*:0]u8,
            buffer_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendCommandGetDataFromDevice: *const fn (
            self: *const IDiscRecorder2Ex,
            cdb: [*:0]u8,
            cdb_size: u32,
            sense_buffer: *[18]u8,
            timeout: u32,
            buffer: [*:0]u8,
            buffer_size: u32,
            buffer_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDvdStructure: *const fn (
            self: *const IDiscRecorder2Ex,
            format: u32,
            address: u32,
            layer: u32,
            agid: u32,
            data: [*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDvdStructure: *const fn (
            self: *const IDiscRecorder2Ex,
            format: u32,
            data: [*:0]u8,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterDescriptor: *const fn (
            self: *const IDiscRecorder2Ex,
            data: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceDescriptor: *const fn (
            self: *const IDiscRecorder2Ex,
            data: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiscInformation: *const fn (
            self: *const IDiscRecorder2Ex,
            disc_information: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrackInformation: *const fn (
            self: *const IDiscRecorder2Ex,
            address: u32,
            address_type: IMAPI_READ_TRACK_ADDRESS_TYPE,
            track_information: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFeaturePage: *const fn (
            self: *const IDiscRecorder2Ex,
            requested_feature: IMAPI_FEATURE_PAGE_TYPE,
            current_feature_only: BOOLEAN,
            feature_data: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModePage: *const fn (
            self: *const IDiscRecorder2Ex,
            requested_mode_page: IMAPI_MODE_PAGE_TYPE,
            request_type: IMAPI_MODE_PAGE_REQUEST_TYPE,
            mode_page_data: [*]?*u8,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModePage: *const fn (
            self: *const IDiscRecorder2Ex,
            request_type: IMAPI_MODE_PAGE_REQUEST_TYPE,
            data: [*:0]u8,
            byte_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedFeaturePages: *const fn (
            self: *const IDiscRecorder2Ex,
            current_feature_only: BOOLEAN,
            feature_data: [*]?*IMAPI_FEATURE_PAGE_TYPE,
            byte_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProfiles: *const fn (
            self: *const IDiscRecorder2Ex,
            current_only: BOOLEAN,
            profile_types: [*]?*IMAPI_PROFILE_TYPE,
            valid_profiles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedModePages: *const fn (
            self: *const IDiscRecorder2Ex,
            request_type: IMAPI_MODE_PAGE_REQUEST_TYPE,
            mode_page_types: [*]?*IMAPI_MODE_PAGE_TYPE,
            valid_pages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetByteAlignmentMask: *const fn (
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumNonPageAlignedTransferSize: *const fn (
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumPageAlignedTransferSize: *const fn (
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn sendCommandNoData(self: *const T, cdb_: [*:0]u8, cdb_size_: u32, sense_buffer_: *[18]u8, timeout_: u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandNoData(@as(*const IDiscRecorder2Ex, @ptrCast(self)), cdb_, cdb_size_, sense_buffer_, timeout_);
            }
            pub inline fn sendCommandSendDataToDevice(self: *const T, cdb_: [*:0]u8, cdb_size_: u32, sense_buffer_: *[18]u8, timeout_: u32, buffer_: [*:0]u8, buffer_size_: u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandSendDataToDevice(@as(*const IDiscRecorder2Ex, @ptrCast(self)), cdb_, cdb_size_, sense_buffer_, timeout_, buffer_, buffer_size_);
            }
            pub inline fn sendCommandGetDataFromDevice(self: *const T, cdb_: [*:0]u8, cdb_size_: u32, sense_buffer_: *[18]u8, timeout_: u32, buffer_: [*:0]u8, buffer_size_: u32, buffer_fetched_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandGetDataFromDevice(@as(*const IDiscRecorder2Ex, @ptrCast(self)), cdb_, cdb_size_, sense_buffer_, timeout_, buffer_, buffer_size_, buffer_fetched_);
            }
            pub inline fn readDvdStructure(self: *const T, format_: u32, address_: u32, layer_: u32, agid_: u32, data_: [*]?*u8, count_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).ReadDvdStructure(@as(*const IDiscRecorder2Ex, @ptrCast(self)), format_, address_, layer_, agid_, data_, count_);
            }
            pub inline fn sendDvdStructure(self: *const T, format_: u32, data_: [*:0]u8, count_: u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendDvdStructure(@as(*const IDiscRecorder2Ex, @ptrCast(self)), format_, data_, count_);
            }
            pub inline fn getAdapterDescriptor(self: *const T, data_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetAdapterDescriptor(@as(*const IDiscRecorder2Ex, @ptrCast(self)), data_, byte_size_);
            }
            pub inline fn getDeviceDescriptor(self: *const T, data_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetDeviceDescriptor(@as(*const IDiscRecorder2Ex, @ptrCast(self)), data_, byte_size_);
            }
            pub inline fn getDiscInformation(self: *const T, disc_information_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetDiscInformation(@as(*const IDiscRecorder2Ex, @ptrCast(self)), disc_information_, byte_size_);
            }
            pub inline fn getTrackInformation(self: *const T, address_: u32, address_type_: IMAPI_READ_TRACK_ADDRESS_TYPE, track_information_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetTrackInformation(@as(*const IDiscRecorder2Ex, @ptrCast(self)), address_, address_type_, track_information_, byte_size_);
            }
            pub inline fn getFeaturePage(self: *const T, requested_feature_: IMAPI_FEATURE_PAGE_TYPE, current_feature_only_: BOOLEAN, feature_data_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetFeaturePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requested_feature_, current_feature_only_, feature_data_, byte_size_);
            }
            pub inline fn getModePage(self: *const T, requested_mode_page_: IMAPI_MODE_PAGE_TYPE, request_type_: IMAPI_MODE_PAGE_REQUEST_TYPE, mode_page_data_: [*]?*u8, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetModePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requested_mode_page_, request_type_, mode_page_data_, byte_size_);
            }
            pub inline fn setModePage(self: *const T, request_type_: IMAPI_MODE_PAGE_REQUEST_TYPE, data_: [*:0]u8, byte_size_: u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SetModePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), request_type_, data_, byte_size_);
            }
            pub inline fn getSupportedFeaturePages(self: *const T, current_feature_only_: BOOLEAN, feature_data_: [*]?*IMAPI_FEATURE_PAGE_TYPE, byte_size_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedFeaturePages(@as(*const IDiscRecorder2Ex, @ptrCast(self)), current_feature_only_, feature_data_, byte_size_);
            }
            pub inline fn getSupportedProfiles(self: *const T, current_only_: BOOLEAN, profile_types_: [*]?*IMAPI_PROFILE_TYPE, valid_profiles_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedProfiles(@as(*const IDiscRecorder2Ex, @ptrCast(self)), current_only_, profile_types_, valid_profiles_);
            }
            pub inline fn getSupportedModePages(self: *const T, request_type_: IMAPI_MODE_PAGE_REQUEST_TYPE, mode_page_types_: [*]?*IMAPI_MODE_PAGE_TYPE, valid_pages_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedModePages(@as(*const IDiscRecorder2Ex, @ptrCast(self)), request_type_, mode_page_types_, valid_pages_);
            }
            pub inline fn getByteAlignmentMask(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetByteAlignmentMask(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value_);
            }
            pub inline fn getMaximumNonPageAlignedTransferSize(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetMaximumNonPageAlignedTransferSize(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value_);
            }
            pub inline fn getMaximumPageAlignedTransferSize(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetMaximumPageAlignedTransferSize(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2_Value = Guid.initString("27354133-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2 = &IID_IDiscRecorder2_Value;
pub const IDiscRecorder2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EjectMedia: *const fn (
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseTray: *const fn (
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcquireExclusiveAccess: *const fn (
            self: *const IDiscRecorder2,
            force: i16,
            ___m_i_d_l___i_disc_recorder20000: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseExclusiveAccess: *const fn (
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableMcn: *const fn (
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableMcn: *const fn (
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDiscRecorder: *const fn (
            self: *const IDiscRecorder2,
            recorder_unique_id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveDiscRecorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductRevision: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumePathNames: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceCanLoadMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LegacyDeviceNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            legacy_device_number: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedFeaturePages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFeaturePages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedProfiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedModePages: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExclusiveAccessOwner: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn ejectMedia(self: *const T) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).EjectMedia(@as(*const IDiscRecorder2, @ptrCast(self)));
            }
            pub inline fn closeTray(self: *const T) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).CloseTray(@as(*const IDiscRecorder2, @ptrCast(self)));
            }
            pub inline fn acquireExclusiveAccess(self: *const T, force_: i16, ___m_i_d_l___i_disc_recorder20000_: ?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).AcquireExclusiveAccess(@as(*const IDiscRecorder2, @ptrCast(self)), force_, ___m_i_d_l___i_disc_recorder20000_);
            }
            pub inline fn releaseExclusiveAccess(self: *const T) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).ReleaseExclusiveAccess(@as(*const IDiscRecorder2, @ptrCast(self)));
            }
            pub inline fn disableMcn(self: *const T) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).DisableMcn(@as(*const IDiscRecorder2, @ptrCast(self)));
            }
            pub inline fn enableMcn(self: *const T) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).EnableMcn(@as(*const IDiscRecorder2, @ptrCast(self)));
            }
            pub inline fn initializeDiscRecorder(self: *const T, recorder_unique_id_: ?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).InitializeDiscRecorder(@as(*const IDiscRecorder2, @ptrCast(self)), recorder_unique_id_);
            }
            pub inline fn getActiveDiscRecorder(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ActiveDiscRecorder(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getVendorId(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VendorId(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getProductId(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ProductId(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getProductRevision(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ProductRevision(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getVolumeName(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VolumeName(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getVolumePathNames(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VolumePathNames(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getDeviceCanLoadMedia(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_DeviceCanLoadMedia(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getLegacyDeviceNumber(self: *const T, legacy_device_number_: ?*i32) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_LegacyDeviceNumber(@as(*const IDiscRecorder2, @ptrCast(self)), legacy_device_number_);
            }
            pub inline fn getSupportedFeaturePages(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedFeaturePages(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentFeaturePages(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_CurrentFeaturePages(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedProfiles(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedProfiles(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentProfiles(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_CurrentProfiles(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedModePages(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedModePages(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
            pub inline fn getExclusiveAccessOwner(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ExclusiveAccessOwner(@as(*const IDiscRecorder2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2_Value = Guid.initString("27354135-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2 = &IID_IWriteEngine2_Value;
pub const IWriteEngine2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        WriteSection: *const fn (
            self: *const IWriteEngine2,
            data: ?*IStream,
            starting_block_address: i32,
            number_of_blocks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: *const fn (
            self: *const IWriteEngine2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*IDiscRecorder2Ex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*?*IDiscRecorder2Ex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseStreamingWrite12: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseStreamingWrite12: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingSectorsPerSecond: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingSectorsPerSecond: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EndingSectorsPerSecond: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndingSectorsPerSecond: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BytesPerSector: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BytesPerSector: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteInProgress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn writeSection(self: *const T, data_: ?*IStream, starting_block_address_: i32, number_of_blocks_: i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).WriteSection(@as(*const IWriteEngine2, @ptrCast(self)), data_, starting_block_address_, number_of_blocks_);
            }
            pub inline fn cancelWrite(self: *const T) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IWriteEngine2, @ptrCast(self)));
            }
            pub inline fn putRecorder(self: *const T, value_: ?*IDiscRecorder2Ex) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getRecorder(self: *const T, value_: ?*?*IDiscRecorder2Ex) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn putUseStreamingWrite12(self: *const T, value_: i16) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_UseStreamingWrite12(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getUseStreamingWrite12(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_UseStreamingWrite12(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn putStartingSectorsPerSecond(self: *const T, value_: i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_StartingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getStartingSectorsPerSecond(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_StartingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn putEndingSectorsPerSecond(self: *const T, value_: i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_EndingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getEndingSectorsPerSecond(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_EndingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn putBytesPerSector(self: *const T, value_: i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_BytesPerSector(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getBytesPerSector(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_BytesPerSector(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
            pub inline fn getWriteInProgress(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_WriteInProgress(@as(*const IWriteEngine2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2EventArgs_Value = Guid.initString("27354136-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2EventArgs = &IID_IWriteEngine2EventArgs_Value;
pub const IWriteEngine2EventArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastReadLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSystemBuffer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSystemBuffer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSystemBuffer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStartLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_StartLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getSectorCount(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_SectorCount(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getLastReadLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_LastReadLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getLastWrittenLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_LastWrittenLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getTotalSystemBuffer(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_TotalSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getUsedSystemBuffer(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_UsedSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getFreeSystemBuffer(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_FreeSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DWriteEngine2Events_Value = Guid.initString("27354137-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DWriteEngine2Events = &IID_DWriteEngine2Events_Value;
pub const DWriteEngine2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DWriteEngine2Events,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, progress_: ?*IDispatch) HRESULT {
                return @as(*const DWriteEngine2Events.VTable, @ptrCast(self.vtable)).Update(@as(*const DWriteEngine2Events, @ptrCast(self)), object_, progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2_Value = Guid.initString("27354152-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2 = &IID_IDiscFormat2_Value;
pub const IDiscFormat2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        IsRecorderSupported: *const fn (
            self: *const IDiscFormat2,
            recorder: ?*IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrentMediaSupported: *const fn (
            self: *const IDiscFormat2,
            recorder: ?*IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaPhysicallyBlank: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaHeuristicallyBlank: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedMediaTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn isRecorderSupported(self: *const T, recorder_: ?*IDiscRecorder2, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).IsRecorderSupported(@as(*const IDiscFormat2, @ptrCast(self)), recorder_, value_);
            }
            pub inline fn isCurrentMediaSupported(self: *const T, recorder_: ?*IDiscRecorder2, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).IsCurrentMediaSupported(@as(*const IDiscFormat2, @ptrCast(self)), recorder_, value_);
            }
            pub inline fn getMediaPhysicallyBlank(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_MediaPhysicallyBlank(@as(*const IDiscFormat2, @ptrCast(self)), value_);
            }
            pub inline fn getMediaHeuristicallyBlank(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_MediaHeuristicallyBlank(@as(*const IDiscFormat2, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedMediaTypes(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_SupportedMediaTypes(@as(*const IDiscFormat2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Erase_Value = Guid.initString("27354156-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Erase = &IID_IDiscFormat2Erase_Value;
pub const IDiscFormat2Erase = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullErase: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullErase: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Erase,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EraseMedia: *const fn (
            self: *const IDiscFormat2Erase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDiscFormat2.MethodMixin(T);
            pub inline fn putRecorder(self: *const T, value_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn getRecorder(self: *const T, value_: ?*?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn putFullErase(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_FullErase(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn getFullErase(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_FullErase(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentPhysicalMediaType(self: *const T, value_: ?*IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn putClientName(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn getClientName(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2Erase, @ptrCast(self)), value_);
            }
            pub inline fn eraseMedia(self: *const T) HRESULT {
                return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).EraseMedia(@as(*const IDiscFormat2Erase, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2EraseEvents_Value = Guid.initString("2735413a-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2EraseEvents = &IID_DDiscFormat2EraseEvents_Value;
pub const DDiscFormat2EraseEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DDiscFormat2EraseEvents,
            object: ?*IDispatch,
            elapsed_seconds: i32,
            estimated_total_seconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, elapsed_seconds_: i32, estimated_total_seconds_: i32) HRESULT {
                return @as(*const DDiscFormat2EraseEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2EraseEvents, @ptrCast(self)), object_, elapsed_seconds_, estimated_total_seconds_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Data_Value = Guid.initString("27354153-9f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Data = &IID_IDiscFormat2Data_Value;
pub const IDiscFormat2Data = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PostgapAlreadyInImage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PostgapAlreadyInImage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMediaStatus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteProtectStatus: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceMediaToBeClosed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceMediaToBeClosed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableConsumerDvdCompatibilityMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableConsumerDvdCompatibilityMode: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            supported_speeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            supported_speed_descriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceOverwrite: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceOverwrite: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2Data,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: *const fn (
            self: *const IDiscFormat2Data,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: *const fn (
            self: *const IDiscFormat2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: *const fn (
            self: *const IDiscFormat2Data,
            requested_sectors_per_second: i32,
            rotation_type_is_pure_c_a_v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDiscFormat2.MethodMixin(T);
            pub inline fn putRecorder(self: *const T, value_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getRecorder(self: *const T, value_: ?*?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn putBufferUnderrunFreeDisabled(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getBufferUnderrunFreeDisabled(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn putPostgapAlreadyInImage(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_PostgapAlreadyInImage(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getPostgapAlreadyInImage(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_PostgapAlreadyInImage(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentMediaStatus(self: *const T, value_: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentMediaStatus(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getWriteProtectStatus(self: *const T, value_: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_WriteProtectStatus(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getTotalSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getFreeSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getNextWritableAddress(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_NextWritableAddress(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getStartAddressOfPreviousSession(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_StartAddressOfPreviousSession(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getLastWrittenAddressOfPreviousSession(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_LastWrittenAddressOfPreviousSession(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn putForceMediaToBeClosed(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ForceMediaToBeClosed(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getForceMediaToBeClosed(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ForceMediaToBeClosed(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn putDisableConsumerDvdCompatibilityMode(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_DisableConsumerDvdCompatibilityMode(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getDisableConsumerDvdCompatibilityMode(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_DisableConsumerDvdCompatibilityMode(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentPhysicalMediaType(self: *const T, value_: ?*IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn putClientName(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getClientName(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedWriteSpeeds(self: *const T, supported_speeds_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2Data, @ptrCast(self)), supported_speeds_);
            }
            pub inline fn getSupportedWriteSpeedDescriptors(self: *const T, supported_speed_descriptors_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2Data, @ptrCast(self)), supported_speed_descriptors_);
            }
            pub inline fn putForceOverwrite(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ForceOverwrite(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getForceOverwrite(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ForceOverwrite(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn getMultisessionInterfaces(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_MultisessionInterfaces(@as(*const IDiscFormat2Data, @ptrCast(self)), value_);
            }
            pub inline fn write(self: *const T, data_: ?*IStream) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).Write(@as(*const IDiscFormat2Data, @ptrCast(self)), data_);
            }
            pub inline fn cancelWrite(self: *const T) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IDiscFormat2Data, @ptrCast(self)));
            }
            pub inline fn setWriteSpeed(self: *const T, requested_sectors_per_second_: i32, rotation_type_is_pure_c_a_v_: i16) HRESULT {
                return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), requested_sectors_per_second_, rotation_type_is_pure_c_a_v_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2DataEvents_Value = Guid.initString("2735413c-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2DataEvents = &IID_DDiscFormat2DataEvents_Value;
pub const DDiscFormat2DataEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DDiscFormat2DataEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, progress_: ?*IDispatch) HRESULT {
                return @as(*const DDiscFormat2DataEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2DataEvents, @ptrCast(self)), object_, progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2DataEventArgs_Value = Guid.initString("2735413d-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2DataEventArgs = &IID_IDiscFormat2DataEventArgs_Value;
pub const IDiscFormat2DataEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2DataEventArgs,
            value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
            pub inline fn getElapsedTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getRemainingTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getTotalTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_TotalTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentAction(self: *const T, value_: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION) HRESULT {
                return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnce_Value = Guid.initString("27354154-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnce = &IID_IDiscFormat2TrackAtOnce_Value;
pub const IDiscFormat2TrackAtOnce = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: *const fn (
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAudioTrack: *const fn (
            self: *const IDiscFormat2TrackAtOnce,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelAddTrack: *const fn (
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMedia: *const fn (
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: *const fn (
            self: *const IDiscFormat2TrackAtOnce,
            requested_sectors_per_second: i32,
            rotation_type_is_pure_c_a_v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DoNotFinalizeMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DoNotFinalizeMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            supported_speeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnce,
            supported_speed_descriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDiscFormat2.MethodMixin(T);
            pub inline fn prepareMedia(self: *const T) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).PrepareMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
            }
            pub inline fn addAudioTrack(self: *const T, data_: ?*IStream) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).AddAudioTrack(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), data_);
            }
            pub inline fn cancelAddTrack(self: *const T) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).CancelAddTrack(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
            }
            pub inline fn releaseMedia(self: *const T) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).ReleaseMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
            }
            pub inline fn setWriteSpeed(self: *const T, requested_sectors_per_second_: i32, rotation_type_is_pure_c_a_v_: i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), requested_sectors_per_second_, rotation_type_is_pure_c_a_v_);
            }
            pub inline fn putRecorder(self: *const T, value_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getRecorder(self: *const T, value_: ?*?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn putBufferUnderrunFreeDisabled(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getBufferUnderrunFreeDisabled(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getNumberOfExistingTracks(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_NumberOfExistingTracks(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getTotalSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getFreeSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getUsedSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_UsedSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn putDoNotFinalizeMedia(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_DoNotFinalizeMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getDoNotFinalizeMedia(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_DoNotFinalizeMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getExpectedTableOfContents(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_ExpectedTableOfContents(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentPhysicalMediaType(self: *const T, value_: ?*IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn putClientName(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getClientName(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedWriteSpeeds(self: *const T, supported_speeds_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), supported_speeds_);
            }
            pub inline fn getSupportedWriteSpeedDescriptors(self: *const T, supported_speed_descriptors_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), supported_speed_descriptors_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2TrackAtOnceEvents_Value = Guid.initString("2735413f-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2TrackAtOnceEvents = &IID_DDiscFormat2TrackAtOnceEvents_Value;
pub const DDiscFormat2TrackAtOnceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DDiscFormat2TrackAtOnceEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, progress_: ?*IDispatch) HRESULT {
                return @as(*const DDiscFormat2TrackAtOnceEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2TrackAtOnceEvents, @ptrCast(self)), object_, progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnceEventArgs_Value = Guid.initString("27354140-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnceEventArgs = &IID_IDiscFormat2TrackAtOnceEventArgs_Value;
pub const IDiscFormat2TrackAtOnceEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTrackNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
            pub inline fn getCurrentTrackNumber(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentTrackNumber(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentAction(self: *const T, value_: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getElapsedTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getRemainingTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCD_Value = Guid.initString("27354155-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCD = &IID_IDiscFormat2RawCD_Value;
pub const IDiscFormat2RawCD = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: *const fn (
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMedia: *const fn (
            self: *const IDiscFormat2RawCD,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMedia2: *const fn (
            self: *const IDiscFormat2RawCD,
            data: ?*IStream,
            stream_lead_in_sectors: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: *const fn (
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMedia: *const fn (
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: *const fn (
            self: *const IDiscFormat2RawCD,
            requested_sectors_per_second: i32,
            rotation_type_is_pure_c_a_v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfNextSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastPossibleStartOfLeadout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedSectorTypes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestedSectorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedSectorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            supported_speeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCD,
            supported_speed_descriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDiscFormat2.MethodMixin(T);
            pub inline fn prepareMedia(self: *const T) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).PrepareMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
            }
            pub inline fn writeMedia(self: *const T, data_: ?*IStream) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).WriteMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)), data_);
            }
            pub inline fn writeMedia2(self: *const T, data_: ?*IStream, stream_lead_in_sectors_: i32) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).WriteMedia2(@as(*const IDiscFormat2RawCD, @ptrCast(self)), data_, stream_lead_in_sectors_);
            }
            pub inline fn cancelWrite(self: *const T) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
            }
            pub inline fn releaseMedia(self: *const T) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).ReleaseMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
            }
            pub inline fn setWriteSpeed(self: *const T, requested_sectors_per_second_: i32, rotation_type_is_pure_c_a_v_: i16) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), requested_sectors_per_second_, rotation_type_is_pure_c_a_v_);
            }
            pub inline fn putRecorder(self: *const T, value_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getRecorder(self: *const T, value_: ?*?*IDiscRecorder2) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn putBufferUnderrunFreeDisabled(self: *const T, value_: i16) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getBufferUnderrunFreeDisabled(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getStartOfNextSession(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_StartOfNextSession(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getLastPossibleStartOfLeadout(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_LastPossibleStartOfLeadout(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentPhysicalMediaType(self: *const T, value_: ?*IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedSectorTypes(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedSectorTypes(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn putRequestedSectorType(self: *const T, value_: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_RequestedSectorType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedSectorType(self: *const T, value_: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedSectorType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn putClientName(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getClientName(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getRequestedRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getCurrentRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value_);
            }
            pub inline fn getSupportedWriteSpeeds(self: *const T, supported_speeds_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2RawCD, @ptrCast(self)), supported_speeds_);
            }
            pub inline fn getSupportedWriteSpeedDescriptors(self: *const T, supported_speed_descriptors_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2RawCD, @ptrCast(self)), supported_speed_descriptors_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2RawCDEvents_Value = Guid.initString("27354142-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2RawCDEvents = &IID_DDiscFormat2RawCDEvents_Value;
pub const DDiscFormat2RawCDEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DDiscFormat2RawCDEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, progress_: ?*IDispatch) HRESULT {
                return @as(*const DDiscFormat2RawCDEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2RawCDEvents, @ptrCast(self)), object_, progress_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCDEventArgs_Value = Guid.initString("27354143-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCDEventArgs = &IID_IDiscFormat2RawCDEventArgs_Value;
pub const IDiscFormat2RawCDEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
            pub inline fn getCurrentAction(self: *const T, value_: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION) HRESULT {
                return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getElapsedTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value_);
            }
            pub inline fn getRemainingTime(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBurnVerification_Value = Guid.initString("d2ffd834-958b-426d-8470-2a13879c6a91");
pub const IID_IBurnVerification = &IID_IBurnVerification_Value;
pub const IBurnVerification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BurnVerificationLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBurnVerification,
            value: IMAPI_BURN_VERIFICATION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BurnVerificationLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBurnVerification,
            value: ?*IMAPI_BURN_VERIFICATION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn putBurnVerificationLevel(self: *const T, value_: IMAPI_BURN_VERIFICATION_LEVEL) HRESULT {
                return @as(*const IBurnVerification.VTable, @ptrCast(self.vtable)).put_BurnVerificationLevel(@as(*const IBurnVerification, @ptrCast(self)), value_);
            }
            pub inline fn getBurnVerificationLevel(self: *const T, value_: ?*IMAPI_BURN_VERIFICATION_LEVEL) HRESULT {
                return @as(*const IBurnVerification.VTable, @ptrCast(self.vtable)).get_BurnVerificationLevel(@as(*const IBurnVerification, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteSpeedDescriptor_Value = Guid.initString("27354144-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteSpeedDescriptor = &IID_IWriteSpeedDescriptor_Value;
pub const IWriteSpeedDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteSpeedDescriptor,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RotationTypeIsPureCAV: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteSpeedDescriptor,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteSpeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IWriteSpeedDescriptor,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getMediaType(self: *const T, value_: ?*IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value_);
            }
            pub inline fn getRotationTypeIsPureCAV(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_RotationTypeIsPureCAV(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value_);
            }
            pub inline fn getWriteSpeed(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_WriteSpeed(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisession_Value = Guid.initString("27354150-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisession = &IID_IMultisession_Value;
pub const IMultisession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedOnCurrentMediaState: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisession,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InUse: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisession,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InUse: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisession,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportRecorder: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisession,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getIsSupportedOnCurrentMediaState(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_IsSupportedOnCurrentMediaState(@as(*const IMultisession, @ptrCast(self)), value_);
            }
            pub inline fn putInUse(self: *const T, value_: i16) HRESULT {
                return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).put_InUse(@as(*const IMultisession, @ptrCast(self)), value_);
            }
            pub inline fn getInUse(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_InUse(@as(*const IMultisession, @ptrCast(self)), value_);
            }
            pub inline fn getImportRecorder(self: *const T, value_: ?*?*IDiscRecorder2) HRESULT {
                return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_ImportRecorder(@as(*const IMultisession, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisessionSequential_Value = Guid.initString("27354151-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisessionSequential = &IID_IMultisessionSequential_Value;
pub const IMultisessionSequential = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFirstDataSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMultisession.MethodMixin(T);
            pub inline fn getIsFirstDataSession(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_IsFirstDataSession(@as(*const IMultisessionSequential, @ptrCast(self)), value_);
            }
            pub inline fn getStartAddressOfPreviousSession(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_StartAddressOfPreviousSession(@as(*const IMultisessionSequential, @ptrCast(self)), value_);
            }
            pub inline fn getLastWrittenAddressOfPreviousSession(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_LastWrittenAddressOfPreviousSession(@as(*const IMultisessionSequential, @ptrCast(self)), value_);
            }
            pub inline fn getNextWritableAddress(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_NextWritableAddress(@as(*const IMultisessionSequential, @ptrCast(self)), value_);
            }
            pub inline fn getFreeSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IMultisessionSequential, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionSequential2_Value = Guid.initString("b507ca22-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionSequential2 = &IID_IMultisessionSequential2_Value;
pub const IMultisessionSequential2 = extern struct {
    pub const VTable = extern struct {
        base: IMultisessionSequential.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionSequential2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMultisessionSequential.MethodMixin(T);
            pub inline fn getWriteUnitSize(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionSequential2.VTable, @ptrCast(self.vtable)).get_WriteUnitSize(@as(*const IMultisessionSequential2, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionRandomWrite_Value = Guid.initString("b507ca23-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionRandomWrite = &IID_IMultisessionRandomWrite_Value;
pub const IMultisessionRandomWrite = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddress: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMultisession.MethodMixin(T);
            pub inline fn getWriteUnitSize(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_WriteUnitSize(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value_);
            }
            pub inline fn getLastWrittenAddress(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_LastWrittenAddress(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value_);
            }
            pub inline fn getTotalSectorsOnMedia(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamPseudoRandomBased_Value = Guid.initString("27354145-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamPseudoRandomBased = &IID_IStreamPseudoRandomBased_Value;
pub const IStreamPseudoRandomBased = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Seed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IStreamPseudoRandomBased,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Seed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IStreamPseudoRandomBased,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtendedSeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IStreamPseudoRandomBased,
            values: [*]u32,
            e_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedSeed: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IStreamPseudoRandomBased,
            values: [*]?*u32,
            e_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStream.MethodMixin(T);
            pub inline fn putSeed(self: *const T, value_: u32) HRESULT {
                return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).put_Seed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), value_);
            }
            pub inline fn getSeed(self: *const T, value_: ?*u32) HRESULT {
                return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).get_Seed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), value_);
            }
            pub inline fn putExtendedSeed(self: *const T, values_: [*]u32, e_count_: u32) HRESULT {
                return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).put_ExtendedSeed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), values_, e_count_);
            }
            pub inline fn getExtendedSeed(self: *const T, values_: [*]?*u32, e_count_: ?*u32) HRESULT {
                return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).get_ExtendedSeed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), values_, e_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamConcatenate_Value = Guid.initString("27354146-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamConcatenate = &IID_IStreamConcatenate_Value;
pub const IStreamConcatenate = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: *const fn (
            self: *const IStreamConcatenate,
            stream1: ?*IStream,
            stream2: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize2: *const fn (
            self: *const IStreamConcatenate,
            streams: [*]?*IStream,
            stream_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: *const fn (
            self: *const IStreamConcatenate,
            stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append2: *const fn (
            self: *const IStreamConcatenate,
            streams: [*]?*IStream,
            stream_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStream.MethodMixin(T);
            pub inline fn initialize(self: *const T, stream1_: ?*IStream, stream2_: ?*IStream) HRESULT {
                return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamConcatenate, @ptrCast(self)), stream1_, stream2_);
            }
            pub inline fn initialize2(self: *const T, streams_: [*]?*IStream, stream_count_: u32) HRESULT {
                return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Initialize2(@as(*const IStreamConcatenate, @ptrCast(self)), streams_, stream_count_);
            }
            pub inline fn append(self: *const T, stream_: ?*IStream) HRESULT {
                return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Append(@as(*const IStreamConcatenate, @ptrCast(self)), stream_);
            }
            pub inline fn append2(self: *const T, streams_: [*]?*IStream, stream_count_: u32) HRESULT {
                return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Append2(@as(*const IStreamConcatenate, @ptrCast(self)), streams_, stream_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamInterleave_Value = Guid.initString("27354147-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamInterleave = &IID_IStreamInterleave_Value;
pub const IStreamInterleave = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: *const fn (
            self: *const IStreamInterleave,
            streams: [*]?*IStream,
            interleave_sizes: [*]u32,
            stream_count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStream.MethodMixin(T);
            pub inline fn initialize(self: *const T, streams_: [*]?*IStream, interleave_sizes_: [*]u32, stream_count_: u32) HRESULT {
                return @as(*const IStreamInterleave.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamInterleave, @ptrCast(self)), streams_, interleave_sizes_, stream_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageCreator_Value = Guid.initString("25983550-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageCreator = &IID_IRawCDImageCreator_Value;
pub const IRawCDImageCreator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateResultImage: *const fn (
            self: *const IRawCDImageCreator,
            result_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTrack: *const fn (
            self: *const IRawCDImageCreator,
            data_type: IMAPI_CD_SECTOR_TYPE,
            data: ?*IStream,
            track_index: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSpecialPregap: *const fn (
            self: *const IRawCDImageCreator,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubcodeRWGenerator: *const fn (
            self: *const IRawCDImageCreator,
            subcode: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResultingImageType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultingImageType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadout: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartOfLeadoutLimit: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadoutLimit: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableGaplessAudio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableGaplessAudio: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaCatalogNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaCatalogNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingTrackNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingTrackNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackInfo: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            track_index: i32,
            value: ?*?*IRawCDImageTrackInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastUsedUserSectorInImage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageCreator,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn createResultImage(self: *const T, result_stream_: ?*?*IStream) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).CreateResultImage(@as(*const IRawCDImageCreator, @ptrCast(self)), result_stream_);
            }
            pub inline fn addTrack(self: *const T, data_type_: IMAPI_CD_SECTOR_TYPE, data_: ?*IStream, track_index_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddTrack(@as(*const IRawCDImageCreator, @ptrCast(self)), data_type_, data_, track_index_);
            }
            pub inline fn addSpecialPregap(self: *const T, data_: ?*IStream) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddSpecialPregap(@as(*const IRawCDImageCreator, @ptrCast(self)), data_);
            }
            pub inline fn addSubcodeRWGenerator(self: *const T, subcode_: ?*IStream) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddSubcodeRWGenerator(@as(*const IRawCDImageCreator, @ptrCast(self)), subcode_);
            }
            pub inline fn putResultingImageType(self: *const T, value_: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_ResultingImageType(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getResultingImageType(self: *const T, value_: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_ResultingImageType(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getStartOfLeadout(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartOfLeadout(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn putStartOfLeadoutLimit(self: *const T, value_: i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_StartOfLeadoutLimit(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getStartOfLeadoutLimit(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartOfLeadoutLimit(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn putDisableGaplessAudio(self: *const T, value_: i16) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_DisableGaplessAudio(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getDisableGaplessAudio(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_DisableGaplessAudio(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn putMediaCatalogNumber(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_MediaCatalogNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getMediaCatalogNumber(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_MediaCatalogNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn putStartingTrackNumber(self: *const T, value_: i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_StartingTrackNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getStartingTrackNumber(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartingTrackNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getTrackInfo(self: *const T, track_index_: i32, value_: ?*?*IRawCDImageTrackInfo) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_TrackInfo(@as(*const IRawCDImageCreator, @ptrCast(self)), track_index_, value_);
            }
            pub inline fn getNumberOfExistingTracks(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_NumberOfExistingTracks(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getLastUsedUserSectorInImage(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_LastUsedUserSectorInImage(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
            pub inline fn getExpectedTableOfContents(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_ExpectedTableOfContents(@as(*const IRawCDImageCreator, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageTrackInfo_Value = Guid.initString("25983551-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageTrackInfo = &IID_IRawCDImageTrackInfo_Value;
pub const IRawCDImageTrackInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackNumber: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorType: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*IMAPI_CD_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISRC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISRC: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitalAudioCopySetting: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DigitalAudioCopySetting: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioHasPreemphasis: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioHasPreemphasis: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackIndexes: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IRawCDImageTrackInfo,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTrackIndex: *const fn (
            self: *const IRawCDImageTrackInfo,
            lba_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearTrackIndex: *const fn (
            self: *const IRawCDImageTrackInfo,
            lba_offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStartingLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_StartingLba(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getSectorCount(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_SectorCount(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getTrackNumber(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_TrackNumber(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getSectorType(self: *const T, value_: ?*IMAPI_CD_SECTOR_TYPE) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_SectorType(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getISRC(self: *const T, value_: ?*?BSTR) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_ISRC(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn putISRC(self: *const T, value_: ?BSTR) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_ISRC(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getDigitalAudioCopySetting(self: *const T, value_: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_DigitalAudioCopySetting(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn putDigitalAudioCopySetting(self: *const T, value_: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_DigitalAudioCopySetting(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getAudioHasPreemphasis(self: *const T, value_: ?*i16) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_AudioHasPreemphasis(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn putAudioHasPreemphasis(self: *const T, value_: i16) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_AudioHasPreemphasis(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn getTrackIndexes(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_TrackIndexes(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value_);
            }
            pub inline fn addTrackIndex(self: *const T, lba_offset_: i32) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).AddTrackIndex(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), lba_offset_);
            }
            pub inline fn clearTrackIndex(self: *const T, lba_offset_: i32) HRESULT {
                return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).ClearTrackIndex(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), lba_offset_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRange_Value = Guid.initString("b507ca25-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRange = &IID_IBlockRange_Value;
pub const IBlockRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBlockRange,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndLba: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBlockRange,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getStartLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IBlockRange.VTable, @ptrCast(self.vtable)).get_StartLba(@as(*const IBlockRange, @ptrCast(self)), value_);
            }
            pub inline fn getEndLba(self: *const T, value_: ?*i32) HRESULT {
                return @as(*const IBlockRange.VTable, @ptrCast(self.vtable)).get_EndLba(@as(*const IBlockRange, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRangeList_Value = Guid.initString("b507ca26-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRangeList = &IID_IBlockRangeList_Value;
pub const IBlockRangeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockRanges: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBlockRangeList,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getBlockRanges(self: *const T, value_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IBlockRangeList.VTable, @ptrCast(self.vtable)).get_BlockRanges(@as(*const IBlockRangeList, @ptrCast(self)), value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BootOptions_Value = Guid.initString("2c941fce-975b-59be-a960-9a2a262853a5");
pub const CLSID_BootOptions = &CLSID_BootOptions_Value;

const CLSID_FsiStream_Value = Guid.initString("2c941fcd-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiStream = &CLSID_FsiStream_Value;

const CLSID_FileSystemImageResult_Value = Guid.initString("2c941fcc-975b-59be-a960-9a2a262853a5");
pub const CLSID_FileSystemImageResult = &CLSID_FileSystemImageResult_Value;

const CLSID_ProgressItem_Value = Guid.initString("2c941fcb-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItem = &CLSID_ProgressItem_Value;

const CLSID_EnumProgressItems_Value = Guid.initString("2c941fca-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumProgressItems = &CLSID_EnumProgressItems_Value;

const CLSID_ProgressItems_Value = Guid.initString("2c941fc9-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItems = &CLSID_ProgressItems_Value;

const CLSID_FsiDirectoryItem_Value = Guid.initString("2c941fc8-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiDirectoryItem = &CLSID_FsiDirectoryItem_Value;

const CLSID_FsiFileItem_Value = Guid.initString("2c941fc7-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiFileItem = &CLSID_FsiFileItem_Value;

const CLSID_EnumFsiItems_Value = Guid.initString("2c941fc6-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumFsiItems = &CLSID_EnumFsiItems_Value;

const CLSID_FsiNamedStreams_Value = Guid.initString("c6b6f8ed-6d19-44b4-b539-b159b793a32d");
pub const CLSID_FsiNamedStreams = &CLSID_FsiNamedStreams_Value;

const CLSID_MsftFileSystemImage_Value = Guid.initString("2c941fc5-975b-59be-a960-9a2a262853a5");
pub const CLSID_MsftFileSystemImage = &CLSID_MsftFileSystemImage_Value;

const CLSID_MsftIsoImageManager_Value = Guid.initString("ceee3b62-8f56-4056-869b-ef16917e3efc");
pub const CLSID_MsftIsoImageManager = &CLSID_MsftIsoImageManager_Value;

const CLSID_BlockRange_Value = Guid.initString("b507ca27-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRange = &CLSID_BlockRange_Value;

const CLSID_BlockRangeList_Value = Guid.initString("b507ca28-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRangeList = &CLSID_BlockRangeList_Value;

pub const FsiItemType = enum(i32) {
    NotFound = 0,
    Directory = 1,
    File = 2,
};
pub const FsiItemNotFound = FsiItemType.NotFound;
pub const FsiItemDirectory = FsiItemType.Directory;
pub const FsiItemFile = FsiItemType.File;

pub const FsiFileSystems = enum(i32) {
    None = 0,
    ISO9660 = 1,
    Joliet = 2,
    UDF = 4,
    Unknown = 1073741824,
};
pub const FsiFileSystemNone = FsiFileSystems.None;
pub const FsiFileSystemISO9660 = FsiFileSystems.ISO9660;
pub const FsiFileSystemJoliet = FsiFileSystems.Joliet;
pub const FsiFileSystemUDF = FsiFileSystems.UDF;
pub const FsiFileSystemUnknown = FsiFileSystems.Unknown;

pub const EmulationType = enum(i32) {
    None = 0,
    @"12MFloppy" = 1,
    @"144MFloppy" = 2,
    @"288MFloppy" = 3,
    HardDisk = 4,
};
pub const EmulationNone = EmulationType.None;
pub const Emulation12MFloppy = EmulationType.@"12MFloppy";
pub const Emulation144MFloppy = EmulationType.@"144MFloppy";
pub const Emulation288MFloppy = EmulationType.@"288MFloppy";
pub const EmulationHardDisk = EmulationType.HardDisk;

pub const PlatformId = enum(i32) {
    X86 = 0,
    PowerPC = 1,
    Mac = 2,
    EFI = 239,
};
pub const PlatformX86 = PlatformId.X86;
pub const PlatformPowerPC = PlatformId.PowerPC;
pub const PlatformMac = PlatformId.Mac;
pub const PlatformEFI = PlatformId.EFI;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBootOptions_Value = Guid.initString("2c941fd4-975b-59be-a960-9a2a262853a5");
pub const IID_IBootOptions = &IID_IBootOptions_Value;
pub const IBootOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImage: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            p_val: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Manufacturer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Manufacturer: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            new_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlatformId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            p_val: ?*PlatformId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlatformId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            new_val: PlatformId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Emulation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            p_val: ?*EmulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Emulation: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            new_val: EmulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IBootOptions,
            p_val: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssignBootImage: *const fn (
            self: *const IBootOptions,
            new_val: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getBootImage(self: *const T, p_val_: ?*?*IStream) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_BootImage(@as(*const IBootOptions, @ptrCast(self)), p_val_);
            }
            pub inline fn getManufacturer(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_Manufacturer(@as(*const IBootOptions, @ptrCast(self)), p_val_);
            }
            pub inline fn putManufacturer(self: *const T, new_val_: ?BSTR) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_Manufacturer(@as(*const IBootOptions, @ptrCast(self)), new_val_);
            }
            pub inline fn getPlatformId(self: *const T, p_val_: ?*PlatformId) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_PlatformId(@as(*const IBootOptions, @ptrCast(self)), p_val_);
            }
            pub inline fn putPlatformId(self: *const T, new_val_: PlatformId) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_PlatformId(@as(*const IBootOptions, @ptrCast(self)), new_val_);
            }
            pub inline fn getEmulation(self: *const T, p_val_: ?*EmulationType) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_Emulation(@as(*const IBootOptions, @ptrCast(self)), p_val_);
            }
            pub inline fn putEmulation(self: *const T, new_val_: EmulationType) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_Emulation(@as(*const IBootOptions, @ptrCast(self)), new_val_);
            }
            pub inline fn getImageSize(self: *const T, p_val_: ?*u32) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_ImageSize(@as(*const IBootOptions, @ptrCast(self)), p_val_);
            }
            pub inline fn assignBootImage(self: *const T, new_val_: ?*IStream) HRESULT {
                return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).AssignBootImage(@as(*const IBootOptions, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItem_Value = Guid.initString("2c941fd5-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItem = &IID_IProgressItem_Value;
pub const IProgressItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItem,
            desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstBlock: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItem,
            block: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBlock: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItem,
            block: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItem,
            blocks: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getDescription(self: *const T, desc_: ?*?BSTR) HRESULT {
                return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IProgressItem, @ptrCast(self)), desc_);
            }
            pub inline fn getFirstBlock(self: *const T, block_: ?*u32) HRESULT {
                return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_FirstBlock(@as(*const IProgressItem, @ptrCast(self)), block_);
            }
            pub inline fn getLastBlock(self: *const T, block_: ?*u32) HRESULT {
                return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_LastBlock(@as(*const IProgressItem, @ptrCast(self)), block_);
            }
            pub inline fn getBlockCount(self: *const T, blocks_: ?*u32) HRESULT {
                return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_BlockCount(@as(*const IProgressItem, @ptrCast(self)), blocks_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumProgressItems_Value = Guid.initString("2c941fd6-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumProgressItems = &IID_IEnumProgressItems_Value;
pub const IEnumProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumProgressItems,
            celt: u32,
            rgelt: [*]?*IProgressItem,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumProgressItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumProgressItems,
            pp_enum: ?*?*IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IProgressItem, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumProgressItems, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumProgressItems, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumProgressItems, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumProgressItems) HRESULT {
                return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumProgressItems, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItems_Value = Guid.initString("2c941fd7-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItems = &IID_IProgressItems_Value;
pub const IProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItems,
            new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItems,
            index: i32,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItems,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressItemFromBlock: *const fn (
            self: *const IProgressItems,
            block: u32,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressItemFromDescription: *const fn (
            self: *const IProgressItems,
            description: ?BSTR,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumProgressItems: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IProgressItems,
            new_enum: ?*?*IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IProgressItems, @ptrCast(self)), new_enum_);
            }
            pub inline fn getItem(self: *const T, index_: i32, item_: ?*?*IProgressItem) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IProgressItems, @ptrCast(self)), index_, item_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IProgressItems, @ptrCast(self)), count_);
            }
            pub inline fn progressItemFromBlock(self: *const T, block_: u32, item_: ?*?*IProgressItem) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).ProgressItemFromBlock(@as(*const IProgressItems, @ptrCast(self)), block_, item_);
            }
            pub inline fn progressItemFromDescription(self: *const T, description_: ?BSTR, item_: ?*?*IProgressItem) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).ProgressItemFromDescription(@as(*const IProgressItems, @ptrCast(self)), description_, item_);
            }
            pub inline fn getEnumProgressItems(self: *const T, new_enum_: ?*?*IEnumProgressItems) HRESULT {
                return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_EnumProgressItems(@as(*const IProgressItems, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImageResult_Value = Guid.initString("2c941fd8-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImageResult = &IID_IFileSystemImageResult_Value;
pub const IFileSystemImageResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult,
            p_val: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgressItems: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult,
            p_val: ?*?*IProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalBlocks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiscId: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getImageStream(self: *const T, p_val_: ?*?*IStream) HRESULT {
                return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_ImageStream(@as(*const IFileSystemImageResult, @ptrCast(self)), p_val_);
            }
            pub inline fn getProgressItems(self: *const T, p_val_: ?*?*IProgressItems) HRESULT {
                return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_ProgressItems(@as(*const IFileSystemImageResult, @ptrCast(self)), p_val_);
            }
            pub inline fn getTotalBlocks(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_TotalBlocks(@as(*const IFileSystemImageResult, @ptrCast(self)), p_val_);
            }
            pub inline fn getBlockSize(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_BlockSize(@as(*const IFileSystemImageResult, @ptrCast(self)), p_val_);
            }
            pub inline fn getDiscId(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_DiscId(@as(*const IFileSystemImageResult, @ptrCast(self)), p_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFileSystemImageResult2_Value = Guid.initString("b507ca29-2204-11dd-966a-001aa01bbc58");
pub const IID_IFileSystemImageResult2 = &IID_IFileSystemImageResult2_Value;
pub const IFileSystemImageResult2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImageResult.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedBlocks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImageResult2,
            p_val: ?*?*IBlockRangeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileSystemImageResult.MethodMixin(T);
            pub inline fn getModifiedBlocks(self: *const T, p_val_: ?*?*IBlockRangeList) HRESULT {
                return @as(*const IFileSystemImageResult2.VTable, @ptrCast(self.vtable)).get_ModifiedBlocks(@as(*const IFileSystemImageResult2, @ptrCast(self)), p_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiItem_Value = Guid.initString("2c941fd9-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiItem = &IID_IFsiItem_Value;
pub const IFsiItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullPath: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreationTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            new_val: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastAccessedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastAccessedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            new_val: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModifiedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastModifiedTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            new_val: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHidden: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHidden: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiItem,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileSystemName: *const fn (
            self: *const IFsiItem,
            file_system: FsiFileSystems,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileSystemPath: *const fn (
            self: *const IFsiItem,
            file_system: FsiFileSystems,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getName(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn getFullPath(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_FullPath(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn getCreationTime(self: *const T, p_val_: ?*f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_CreationTime(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn putCreationTime(self: *const T, new_val_: f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_CreationTime(@as(*const IFsiItem, @ptrCast(self)), new_val_);
            }
            pub inline fn getLastAccessedTime(self: *const T, p_val_: ?*f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_LastAccessedTime(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn putLastAccessedTime(self: *const T, new_val_: f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_LastAccessedTime(@as(*const IFsiItem, @ptrCast(self)), new_val_);
            }
            pub inline fn getLastModifiedTime(self: *const T, p_val_: ?*f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_LastModifiedTime(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn putLastModifiedTime(self: *const T, new_val_: f64) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_LastModifiedTime(@as(*const IFsiItem, @ptrCast(self)), new_val_);
            }
            pub inline fn getIsHidden(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_IsHidden(@as(*const IFsiItem, @ptrCast(self)), p_val_);
            }
            pub inline fn putIsHidden(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_IsHidden(@as(*const IFsiItem, @ptrCast(self)), new_val_);
            }
            pub inline fn fileSystemName(self: *const T, file_system_: FsiFileSystems, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).FileSystemName(@as(*const IFsiItem, @ptrCast(self)), file_system_, p_val_);
            }
            pub inline fn fileSystemPath(self: *const T, file_system_: FsiFileSystems, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).FileSystemPath(@as(*const IFsiItem, @ptrCast(self)), file_system_, p_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumFsiItems_Value = Guid.initString("2c941fda-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumFsiItems = &IID_IEnumFsiItems_Value;
pub const IEnumFsiItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumFsiItems,
            celt: u32,
            rgelt: [*]?*IFsiItem,
            pcelt_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumFsiItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumFsiItems,
            pp_enum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, celt_: u32, rgelt_: [*]?*IFsiItem, pcelt_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFsiItems, @ptrCast(self)), celt_, rgelt_, pcelt_fetched_);
            }
            pub inline fn skip(self: *const T, celt_: u32) HRESULT {
                return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFsiItems, @ptrCast(self)), celt_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFsiItems, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumFsiItems) HRESULT {
                return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFsiItems, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem_Value = Guid.initString("2c941fdb-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiFileItem = &IID_IFsiFileItem_Value;
pub const IFsiFileItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem,
            p_val: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitLow: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitHigh: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem,
            p_val: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem,
            new_val: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFsiItem.MethodMixin(T);
            pub inline fn getDataSize(self: *const T, p_val_: ?*i64) HRESULT {
                return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize(@as(*const IFsiFileItem, @ptrCast(self)), p_val_);
            }
            pub inline fn getDataSize32BitLow(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize32BitLow(@as(*const IFsiFileItem, @ptrCast(self)), p_val_);
            }
            pub inline fn getDataSize32BitHigh(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize32BitHigh(@as(*const IFsiFileItem, @ptrCast(self)), p_val_);
            }
            pub inline fn getData(self: *const T, p_val_: ?*?*IStream) HRESULT {
                return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IFsiFileItem, @ptrCast(self)), p_val_);
            }
            pub inline fn putData(self: *const T, new_val_: ?*IStream) HRESULT {
                return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IFsiFileItem, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem2_Value = Guid.initString("199d0c19-11e1-40eb-8ec2-c8c822a07792");
pub const IID_IFsiFileItem2 = &IID_IFsiFileItem2_Value;
pub const IFsiFileItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiFileItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FsiNamedStreams: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem2,
            streams: ?*?*IFsiNamedStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNamedStream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem2,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: *const fn (
            self: *const IFsiFileItem2,
            name: ?BSTR,
            stream_data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStream: *const fn (
            self: *const IFsiFileItem2,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRealTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem2,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsRealTime: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiFileItem2,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFsiFileItem.MethodMixin(T);
            pub inline fn getFsiNamedStreams(self: *const T, streams_: ?*?*IFsiNamedStreams) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_FsiNamedStreams(@as(*const IFsiFileItem2, @ptrCast(self)), streams_);
            }
            pub inline fn getIsNamedStream(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_IsNamedStream(@as(*const IFsiFileItem2, @ptrCast(self)), p_val_);
            }
            pub inline fn addStream(self: *const T, name_: ?BSTR, stream_data_: ?*IStream) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IFsiFileItem2, @ptrCast(self)), name_, stream_data_);
            }
            pub inline fn removeStream(self: *const T, name_: ?BSTR) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IFsiFileItem2, @ptrCast(self)), name_);
            }
            pub inline fn getIsRealTime(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_IsRealTime(@as(*const IFsiFileItem2, @ptrCast(self)), p_val_);
            }
            pub inline fn putIsRealTime(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).put_IsRealTime(@as(*const IFsiFileItem2, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiNamedStreams_Value = Guid.initString("ed79ba56-5294-4250-8d46-f9aecee23459");
pub const IID_IFsiNamedStreams = &IID_IFsiNamedStreams_Value;
pub const IFsiNamedStreams = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiNamedStreams,
            new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiNamedStreams,
            index: i32,
            item: ?*?*IFsiFileItem2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiNamedStreams,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumNamedStreams: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiNamedStreams,
            new_enum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IFsiNamedStreams, @ptrCast(self)), new_enum_);
            }
            pub inline fn getItem(self: *const T, index_: i32, item_: ?*?*IFsiFileItem2) HRESULT {
                return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IFsiNamedStreams, @ptrCast(self)), index_, item_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IFsiNamedStreams, @ptrCast(self)), count_);
            }
            pub inline fn getEnumNamedStreams(self: *const T, new_enum_: ?*?*IEnumFsiItems) HRESULT {
                return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_EnumNamedStreams(@as(*const IFsiNamedStreams, @ptrCast(self)), new_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem_Value = Guid.initString("2c941fdc-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiDirectoryItem = &IID_IFsiDirectoryItem_Value;
pub const IFsiDirectoryItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiDirectoryItem,
            new_enum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
            item: ?*?*IFsiItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiDirectoryItem,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumFsiItems: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFsiDirectoryItem,
            new_enum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDirectory: *const fn (
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFile: *const fn (
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
            file_data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTree: *const fn (
            self: *const IFsiDirectoryItem,
            source_directory: ?BSTR,
            include_base_directory: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn (
            self: *const IFsiDirectoryItem,
            item: ?*IFsiItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTree: *const fn (
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFsiItem.MethodMixin(T);
            pub inline fn getNewEnum(self: *const T, new_enum_: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IFsiDirectoryItem, @ptrCast(self)), new_enum_);
            }
            pub inline fn getItem(self: *const T, path_: ?BSTR, item_: ?*?*IFsiItem) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IFsiDirectoryItem, @ptrCast(self)), path_, item_);
            }
            pub inline fn getCount(self: *const T, count_: ?*i32) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IFsiDirectoryItem, @ptrCast(self)), count_);
            }
            pub inline fn getEnumFsiItems(self: *const T, new_enum_: ?*?*IEnumFsiItems) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_EnumFsiItems(@as(*const IFsiDirectoryItem, @ptrCast(self)), new_enum_);
            }
            pub inline fn addDirectory(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddDirectory(@as(*const IFsiDirectoryItem, @ptrCast(self)), path_);
            }
            pub inline fn addFile(self: *const T, path_: ?BSTR, file_data_: ?*IStream) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddFile(@as(*const IFsiDirectoryItem, @ptrCast(self)), path_, file_data_);
            }
            pub inline fn addTree(self: *const T, source_directory_: ?BSTR, include_base_directory_: i16) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddTree(@as(*const IFsiDirectoryItem, @ptrCast(self)), source_directory_, include_base_directory_);
            }
            pub inline fn add(self: *const T, item_: ?*IFsiItem) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).Add(@as(*const IFsiDirectoryItem, @ptrCast(self)), item_);
            }
            pub inline fn remove(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).Remove(@as(*const IFsiDirectoryItem, @ptrCast(self)), path_);
            }
            pub inline fn removeTree(self: *const T, path_: ?BSTR) HRESULT {
                return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).RemoveTree(@as(*const IFsiDirectoryItem, @ptrCast(self)), path_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem2_Value = Guid.initString("f7fb4b9b-6d96-4d7b-9115-201b144811ef");
pub const IID_IFsiDirectoryItem2 = &IID_IFsiDirectoryItem2_Value;
pub const IFsiDirectoryItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiDirectoryItem.VTable,
        AddTreeWithNamedStreams: *const fn (
            self: *const IFsiDirectoryItem2,
            source_directory: ?BSTR,
            include_base_directory: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFsiDirectoryItem.MethodMixin(T);
            pub inline fn addTreeWithNamedStreams(self: *const T, source_directory_: ?BSTR, include_base_directory_: i16) HRESULT {
                return @as(*const IFsiDirectoryItem2.VTable, @ptrCast(self.vtable)).AddTreeWithNamedStreams(@as(*const IFsiDirectoryItem2, @ptrCast(self)), source_directory_, include_base_directory_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage_Value = Guid.initString("2c941fe1-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImage = &IID_IFileSystemImage_Value;
pub const IFileSystemImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?*IFsiDirectoryItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionStartBlock: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionStartBlock: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeMediaBlocks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FreeMediaBlocks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxMediaBlocksFromDevice: *const fn (
            self: *const IFileSystemImage,
            disc_recorder: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedBlocks: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VolumeName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportedVolumeName: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?*IBootOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptions: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: ?*IBootOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectoryCount: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChangePoint: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StrictFileSystemCompliance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StrictFileSystemCompliance: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseRestrictedCharacterSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseRestrictedCharacterSet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsToCreate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileSystemsToCreate: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsSupported: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UDFRevision: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevision: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevisionsSupported: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChooseImageDefaults: *const fn (
            self: *const IFileSystemImage,
            disc_recorder: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChooseImageDefaultsForMediaType: *const fn (
            self: *const IFileSystemImage,
            value: IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISO9660InterchangeLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevel: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevelsSupported: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateResultImage: *const fn (
            self: *const IFileSystemImage,
            result_stream: ?*?*IFileSystemImageResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exists: *const fn (
            self: *const IFileSystemImage,
            full_path: ?BSTR,
            item_type: ?*FsiItemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CalculateDiscIdentifier: *const fn (
            self: *const IFileSystemImage,
            disc_identifier: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IdentifyFileSystemsOnDisc: *const fn (
            self: *const IFileSystemImage,
            disc_recorder: ?*IDiscRecorder2,
            file_systems: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultFileSystemForImport: *const fn (
            self: *const IFileSystemImage,
            file_systems: FsiFileSystems,
            import_default: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportFileSystem: *const fn (
            self: *const IFileSystemImage,
            imported_file_system: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportSpecificFileSystem: *const fn (
            self: *const IFileSystemImage,
            file_system_to_use: FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RollbackToChangePoint: *const fn (
            self: *const IFileSystemImage,
            change_point: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockInChangePoint: *const fn (
            self: *const IFileSystemImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDirectoryItem: *const fn (
            self: *const IFileSystemImage,
            name: ?BSTR,
            new_item: ?*?*IFsiDirectoryItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileItem: *const fn (
            self: *const IFileSystemImage,
            name: ?BSTR,
            new_item: ?*?*IFsiFileItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameUDF: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameJoliet: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameISO9660: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StageFiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StageFiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            p_val: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultisessionInterfaces: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage,
            new_val: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getRoot(self: *const T, p_val_: ?*?*IFsiDirectoryItem) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_Root(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getSessionStartBlock(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_SessionStartBlock(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putSessionStartBlock(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_SessionStartBlock(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getFreeMediaBlocks(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FreeMediaBlocks(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putFreeMediaBlocks(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_FreeMediaBlocks(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn setMaxMediaBlocksFromDevice(self: *const T, disc_recorder_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).SetMaxMediaBlocksFromDevice(@as(*const IFileSystemImage, @ptrCast(self)), disc_recorder_);
            }
            pub inline fn getUsedBlocks(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UsedBlocks(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getVolumeName(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeName(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putVolumeName(self: *const T, new_val_: ?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_VolumeName(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getImportedVolumeName(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ImportedVolumeName(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getBootImageOptions(self: *const T, p_val_: ?*?*IBootOptions) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_BootImageOptions(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putBootImageOptions(self: *const T, new_val_: ?*IBootOptions) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_BootImageOptions(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getFileCount(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileCount(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getDirectoryCount(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_DirectoryCount(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getWorkingDirectory(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_WorkingDirectory(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putWorkingDirectory(self: *const T, new_val_: ?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_WorkingDirectory(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getChangePoint(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ChangePoint(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getStrictFileSystemCompliance(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_StrictFileSystemCompliance(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putStrictFileSystemCompliance(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_StrictFileSystemCompliance(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getUseRestrictedCharacterSet(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UseRestrictedCharacterSet(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putUseRestrictedCharacterSet(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_UseRestrictedCharacterSet(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getFileSystemsToCreate(self: *const T, p_val_: ?*FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileSystemsToCreate(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putFileSystemsToCreate(self: *const T, new_val_: FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_FileSystemsToCreate(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getFileSystemsSupported(self: *const T, p_val_: ?*FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileSystemsSupported(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putUDFRevision(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_UDFRevision(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getUDFRevision(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UDFRevision(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getUDFRevisionsSupported(self: *const T, p_val_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UDFRevisionsSupported(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn chooseImageDefaults(self: *const T, disc_recorder_: ?*IDiscRecorder2) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ChooseImageDefaults(@as(*const IFileSystemImage, @ptrCast(self)), disc_recorder_);
            }
            pub inline fn chooseImageDefaultsForMediaType(self: *const T, value_: IMAPI_MEDIA_PHYSICAL_TYPE) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ChooseImageDefaultsForMediaType(@as(*const IFileSystemImage, @ptrCast(self)), value_);
            }
            pub inline fn putISO9660InterchangeLevel(self: *const T, new_val_: i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_ISO9660InterchangeLevel(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getISO9660InterchangeLevel(self: *const T, p_val_: ?*i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ISO9660InterchangeLevel(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getISO9660InterchangeLevelsSupported(self: *const T, p_val_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ISO9660InterchangeLevelsSupported(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn createResultImage(self: *const T, result_stream_: ?*?*IFileSystemImageResult) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateResultImage(@as(*const IFileSystemImage, @ptrCast(self)), result_stream_);
            }
            pub inline fn exists(self: *const T, full_path_: ?BSTR, item_type_: ?*FsiItemType) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).Exists(@as(*const IFileSystemImage, @ptrCast(self)), full_path_, item_type_);
            }
            pub inline fn calculateDiscIdentifier(self: *const T, disc_identifier_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CalculateDiscIdentifier(@as(*const IFileSystemImage, @ptrCast(self)), disc_identifier_);
            }
            pub inline fn identifyFileSystemsOnDisc(self: *const T, disc_recorder_: ?*IDiscRecorder2, file_systems_: ?*FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).IdentifyFileSystemsOnDisc(@as(*const IFileSystemImage, @ptrCast(self)), disc_recorder_, file_systems_);
            }
            pub inline fn getDefaultFileSystemForImport(self: *const T, file_systems_: FsiFileSystems, import_default_: ?*FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).GetDefaultFileSystemForImport(@as(*const IFileSystemImage, @ptrCast(self)), file_systems_, import_default_);
            }
            pub inline fn importFileSystem(self: *const T, imported_file_system_: ?*FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ImportFileSystem(@as(*const IFileSystemImage, @ptrCast(self)), imported_file_system_);
            }
            pub inline fn importSpecificFileSystem(self: *const T, file_system_to_use_: FsiFileSystems) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ImportSpecificFileSystem(@as(*const IFileSystemImage, @ptrCast(self)), file_system_to_use_);
            }
            pub inline fn rollbackToChangePoint(self: *const T, change_point_: i32) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).RollbackToChangePoint(@as(*const IFileSystemImage, @ptrCast(self)), change_point_);
            }
            pub inline fn lockInChangePoint(self: *const T) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).LockInChangePoint(@as(*const IFileSystemImage, @ptrCast(self)));
            }
            pub inline fn createDirectoryItem(self: *const T, name_: ?BSTR, new_item_: ?*?*IFsiDirectoryItem) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateDirectoryItem(@as(*const IFileSystemImage, @ptrCast(self)), name_, new_item_);
            }
            pub inline fn createFileItem(self: *const T, name_: ?BSTR, new_item_: ?*?*IFsiFileItem) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateFileItem(@as(*const IFileSystemImage, @ptrCast(self)), name_, new_item_);
            }
            pub inline fn getVolumeNameUDF(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameUDF(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getVolumeNameJoliet(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameJoliet(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getVolumeNameISO9660(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameISO9660(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn getStageFiles(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_StageFiles(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putStageFiles(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_StageFiles(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
            pub inline fn getMultisessionInterfaces(self: *const T, p_val_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_MultisessionInterfaces(@as(*const IFileSystemImage, @ptrCast(self)), p_val_);
            }
            pub inline fn putMultisessionInterfaces(self: *const T, new_val_: ?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_MultisessionInterfaces(@as(*const IFileSystemImage, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage2_Value = Guid.initString("d7644b2c-1537-4767-b62f-f1387b02ddfd");
pub const IID_IFileSystemImage2 = &IID_IFileSystemImage2_Value;
pub const IFileSystemImage2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptionsArray: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage2,
            p_val: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptionsArray: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage2,
            new_val: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileSystemImage.MethodMixin(T);
            pub inline fn getBootImageOptionsArray(self: *const T, p_val_: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage2.VTable, @ptrCast(self.vtable)).get_BootImageOptionsArray(@as(*const IFileSystemImage2, @ptrCast(self)), p_val_);
            }
            pub inline fn putBootImageOptionsArray(self: *const T, new_val_: ?*SAFEARRAY) HRESULT {
                return @as(*const IFileSystemImage2.VTable, @ptrCast(self.vtable)).put_BootImageOptionsArray(@as(*const IFileSystemImage2, @ptrCast(self)), new_val_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage3_Value = Guid.initString("7cff842c-7e97-4807-8304-910dd8f7c051");
pub const IID_IFileSystemImage3 = &IID_IFileSystemImage3_Value;
pub const IFileSystemImage3 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreateRedundantUdfMetadataFiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage3,
            p_val: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreateRedundantUdfMetadataFiles: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IFileSystemImage3,
            new_val: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProbeSpecificFileSystem: *const fn (
            self: *const IFileSystemImage3,
            file_system_to_probe: FsiFileSystems,
            is_appendable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileSystemImage2.MethodMixin(T);
            pub inline fn getCreateRedundantUdfMetadataFiles(self: *const T, p_val_: ?*i16) HRESULT {
                return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).get_CreateRedundantUdfMetadataFiles(@as(*const IFileSystemImage3, @ptrCast(self)), p_val_);
            }
            pub inline fn putCreateRedundantUdfMetadataFiles(self: *const T, new_val_: i16) HRESULT {
                return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).put_CreateRedundantUdfMetadataFiles(@as(*const IFileSystemImage3, @ptrCast(self)), new_val_);
            }
            pub inline fn probeSpecificFileSystem(self: *const T, file_system_to_probe_: FsiFileSystems, is_appendable_: ?*i16) HRESULT {
                return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).ProbeSpecificFileSystem(@as(*const IFileSystemImage3, @ptrCast(self)), file_system_to_probe_, is_appendable_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageEvents_Value = Guid.initString("2c941fdf-975b-59be-a960-9a2a262853a5");
pub const IID_DFileSystemImageEvents = &IID_DFileSystemImageEvents_Value;
pub const DFileSystemImageEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: *const fn (
            self: *const DFileSystemImageEvents,
            object: ?*IDispatch,
            current_file: ?BSTR,
            copied_sectors: i32,
            total_sectors: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn update(self: *const T, object_: ?*IDispatch, current_file_: ?BSTR, copied_sectors_: i32, total_sectors_: i32) HRESULT {
                return @as(*const DFileSystemImageEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DFileSystemImageEvents, @ptrCast(self)), object_, current_file_, copied_sectors_, total_sectors_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageImportEvents_Value = Guid.initString("d25c30f9-4087-4366-9e24-e55be286424b");
pub const IID_DFileSystemImageImportEvents = &IID_DFileSystemImageImportEvents_Value;
pub const DFileSystemImageImportEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        UpdateImport: *const fn (
            self: *const DFileSystemImageImportEvents,
            object: ?*IDispatch,
            file_system: FsiFileSystems,
            current_item: ?BSTR,
            imported_directory_items: i32,
            total_directory_items: i32,
            imported_file_items: i32,
            total_file_items: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn updateImport(self: *const T, object_: ?*IDispatch, file_system_: FsiFileSystems, current_item_: ?BSTR, imported_directory_items_: i32, total_directory_items_: i32, imported_file_items_: i32, total_file_items_: i32) HRESULT {
                return @as(*const DFileSystemImageImportEvents.VTable, @ptrCast(self.vtable)).UpdateImport(@as(*const DFileSystemImageImportEvents, @ptrCast(self)), object_, file_system_, current_item_, imported_directory_items_, total_directory_items_, imported_file_items_, total_file_items_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIsoImageManager_Value = Guid.initString("6ca38be5-fbbb-4800-95a1-a438865eb0d4");
pub const IID_IIsoImageManager = &IID_IIsoImageManager_Value;
pub const IIsoImageManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IIsoImageManager,
            p_val: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stream: *const fn (
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            self: *const IIsoImageManager,
            data: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: *const fn (
            self: *const IIsoImageManager,
            val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStream: *const fn (
            self: *const IIsoImageManager,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: *const fn (
            self: *const IIsoImageManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            pub inline fn getPath(self: *const T, p_val_: ?*?BSTR) HRESULT {
                return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IIsoImageManager, @ptrCast(self)), p_val_);
            }
            pub inline fn getStream(self: *const T, data_: ?*?*IStream) HRESULT {
                return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).get_Stream(@as(*const IIsoImageManager, @ptrCast(self)), data_);
            }
            pub inline fn setPath(self: *const T, val_: ?BSTR) HRESULT {
                return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IIsoImageManager, @ptrCast(self)), val_);
            }
            pub inline fn setStream(self: *const T, data_: ?*IStream) HRESULT {
                return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).SetStream(@as(*const IIsoImageManager, @ptrCast(self)), data_);
            }
            pub inline fn validate(self: *const T) HRESULT {
                return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).Validate(@as(*const IIsoImageManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSDiscRecorderObj_Value = Guid.initString("520cca61-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscRecorderObj = &CLSID_MSDiscRecorderObj_Value;

const CLSID_MSDiscMasterObj_Value = Guid.initString("520cca63-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscMasterObj = &CLSID_MSDiscMasterObj_Value;

const CLSID_MSEnumDiscRecordersObj_Value = Guid.initString("8a03567a-63cb-4ba8-baf6-52119816d1ef");
pub const CLSID_MSEnumDiscRecordersObj = &CLSID_MSEnumDiscRecordersObj_Value;

pub const MEDIA_TYPES = enum(i32) {
    CDDA_CDROM = 1,
    CD_ROM_XA = 2,
    CD_I = 3,
    CD_EXTRA = 4,
    CD_OTHER = 5,
    SPECIAL = 6,
};
pub const MEDIA_CDDA_CDROM = MEDIA_TYPES.CDDA_CDROM;
pub const MEDIA_CD_ROM_XA = MEDIA_TYPES.CD_ROM_XA;
pub const MEDIA_CD_I = MEDIA_TYPES.CD_I;
pub const MEDIA_CD_EXTRA = MEDIA_TYPES.CD_EXTRA;
pub const MEDIA_CD_OTHER = MEDIA_TYPES.CD_OTHER;
pub const MEDIA_SPECIAL = MEDIA_TYPES.SPECIAL;

pub const MEDIA_FLAGS = enum(i32) {
    BLANK = 1,
    RW = 2,
    WRITABLE = 4,
    FORMAT_UNUSABLE_BY_IMAPI = 8,
};
pub const MEDIA_BLANK = MEDIA_FLAGS.BLANK;
pub const MEDIA_RW = MEDIA_FLAGS.RW;
pub const MEDIA_WRITABLE = MEDIA_FLAGS.WRITABLE;
pub const MEDIA_FORMAT_UNUSABLE_BY_IMAPI = MEDIA_FLAGS.FORMAT_UNUSABLE_BY_IMAPI;

pub const RECORDER_TYPES = enum(i32) {
    R = 1,
    W = 2,
};
pub const RECORDER_CDR = RECORDER_TYPES.R;
pub const RECORDER_CDRW = RECORDER_TYPES.W;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscRecorder_Value = Guid.initString("85ac9776-ca88-4cf2-894e-09598c078a41");
pub const IID_IDiscRecorder = &IID_IDiscRecorder_Value;
pub const IDiscRecorder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: *const fn (
            self: *const IDiscRecorder,
            pby_unique_i_d: [*:0]u8,
            nul_i_d_size: u32,
            nul_drive_number: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderGUID: *const fn (
            self: *const IDiscRecorder,
            pby_unique_i_d: ?[*:0]u8,
            ul_buffer_size: u32,
            pul_return_size_required: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderType: *const fn (
            self: *const IDiscRecorder,
            f_type_code: ?*RECORDER_TYPES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayNames: *const fn (
            self: *const IDiscRecorder,
            pbstr_vendor_i_d: ?*?BSTR,
            pbstr_product_i_d: ?*?BSTR,
            pbstr_revision: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBasePnPID: *const fn (
            self: *const IDiscRecorder,
            pbstr_base_pn_p_i_d: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: *const fn (
            self: *const IDiscRecorder,
            pbstr_path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderProperties: *const fn (
            self: *const IDiscRecorder,
            pp_prop_stg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecorderProperties: *const fn (
            self: *const IDiscRecorder,
            p_prop_stg: ?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderState: *const fn (
            self: *const IDiscRecorder,
            pul_dev_state_flags: ?*DISC_RECORDER_STATE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenExclusive: *const fn (
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMediaType: *const fn (
            self: *const IDiscRecorder,
            f_media_type: ?*MEDIA_TYPES,
            f_media_flags: ?*MEDIA_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMediaInfo: *const fn (
            self: *const IDiscRecorder,
            pb_sessions: ?*u8,
            pb_last_track: ?*u8,
            ul_start_address: ?*u32,
            ul_next_writable: ?*u32,
            ul_free_blocks: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Eject: *const fn (
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Erase: *const fn (
            self: *const IDiscRecorder,
            b_full_erase: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn init(self: *const T, pby_unique_i_d_: [*:0]u8, nul_i_d_size_: u32, nul_drive_number_: u32) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Init(@as(*const IDiscRecorder, @ptrCast(self)), pby_unique_i_d_, nul_i_d_size_, nul_drive_number_);
            }
            pub inline fn getRecorderGUID(self: *const T, pby_unique_i_d_: ?[*:0]u8, ul_buffer_size_: u32, pul_return_size_required_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderGUID(@as(*const IDiscRecorder, @ptrCast(self)), pby_unique_i_d_, ul_buffer_size_, pul_return_size_required_);
            }
            pub inline fn getRecorderType(self: *const T, f_type_code_: ?*RECORDER_TYPES) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderType(@as(*const IDiscRecorder, @ptrCast(self)), f_type_code_);
            }
            pub inline fn getDisplayNames(self: *const T, pbstr_vendor_i_d_: ?*?BSTR, pbstr_product_i_d_: ?*?BSTR, pbstr_revision_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetDisplayNames(@as(*const IDiscRecorder, @ptrCast(self)), pbstr_vendor_i_d_, pbstr_product_i_d_, pbstr_revision_);
            }
            pub inline fn getBasePnPID(self: *const T, pbstr_base_pn_p_i_d_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetBasePnPID(@as(*const IDiscRecorder, @ptrCast(self)), pbstr_base_pn_p_i_d_);
            }
            pub inline fn getPath(self: *const T, pbstr_path_: ?*?BSTR) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IDiscRecorder, @ptrCast(self)), pbstr_path_);
            }
            pub inline fn getRecorderProperties(self: *const T, pp_prop_stg_: ?*?*IPropertyStorage) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderProperties(@as(*const IDiscRecorder, @ptrCast(self)), pp_prop_stg_);
            }
            pub inline fn setRecorderProperties(self: *const T, p_prop_stg_: ?*IPropertyStorage) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).SetRecorderProperties(@as(*const IDiscRecorder, @ptrCast(self)), p_prop_stg_);
            }
            pub inline fn getRecorderState(self: *const T, pul_dev_state_flags_: ?*DISC_RECORDER_STATE_FLAGS) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderState(@as(*const IDiscRecorder, @ptrCast(self)), pul_dev_state_flags_);
            }
            pub inline fn openExclusive(self: *const T) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).OpenExclusive(@as(*const IDiscRecorder, @ptrCast(self)));
            }
            pub inline fn queryMediaType(self: *const T, f_media_type_: ?*MEDIA_TYPES, f_media_flags_: ?*MEDIA_FLAGS) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).QueryMediaType(@as(*const IDiscRecorder, @ptrCast(self)), f_media_type_, f_media_flags_);
            }
            pub inline fn queryMediaInfo(self: *const T, pb_sessions_: ?*u8, pb_last_track_: ?*u8, ul_start_address_: ?*u32, ul_next_writable_: ?*u32, ul_free_blocks_: ?*u32) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).QueryMediaInfo(@as(*const IDiscRecorder, @ptrCast(self)), pb_sessions_, pb_last_track_, ul_start_address_, ul_next_writable_, ul_free_blocks_);
            }
            pub inline fn eject(self: *const T) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Eject(@as(*const IDiscRecorder, @ptrCast(self)));
            }
            pub inline fn erase(self: *const T, b_full_erase_: u8) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Erase(@as(*const IDiscRecorder, @ptrCast(self)), b_full_erase_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Close(@as(*const IDiscRecorder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscRecorders_Value = Guid.initString("9b1921e1-54ac-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscRecorders = &IID_IEnumDiscRecorders_Value;
pub const IEnumDiscRecorders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumDiscRecorders,
            c_recorders: u32,
            pp_recorder: [*]?*IDiscRecorder,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumDiscRecorders,
            c_recorders: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumDiscRecorders,
            pp_enum: ?*?*IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_recorders_: u32, pp_recorder_: [*]?*IDiscRecorder, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDiscRecorders, @ptrCast(self)), c_recorders_, pp_recorder_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_recorders_: u32) HRESULT {
                return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDiscRecorders, @ptrCast(self)), c_recorders_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDiscRecorders, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumDiscRecorders) HRESULT {
                return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDiscRecorders, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscMasterFormats_Value = Guid.initString("ddf445e1-54ba-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscMasterFormats = &IID_IEnumDiscMasterFormats_Value;
pub const IEnumDiscMasterFormats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumDiscMasterFormats,
            c_formats: u32,
            lpiid_format_i_d: [*]Guid,
            pc_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumDiscMasterFormats,
            c_formats: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumDiscMasterFormats,
            pp_enum: ?*?*IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_formats_: u32, lpiid_format_i_d_: [*]Guid, pc_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), c_formats_, lpiid_format_i_d_, pc_fetched_);
            }
            pub inline fn skip(self: *const T, c_formats_: u32) HRESULT {
                return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), c_formats_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDiscMasterFormats, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumDiscMasterFormats) HRESULT {
                return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRedbookDiscMaster_Value = Guid.initString("e3bc42cd-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IRedbookDiscMaster = &IID_IRedbookDiscMaster_Value;
pub const IRedbookDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalAudioTracks: *const fn (
            self: *const IRedbookDiscMaster,
            pn_tracks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalAudioBlocks: *const fn (
            self: *const IRedbookDiscMaster,
            pn_blocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsedAudioBlocks: *const fn (
            self: *const IRedbookDiscMaster,
            pn_blocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableAudioTrackBlocks: *const fn (
            self: *const IRedbookDiscMaster,
            pn_blocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioBlockSize: *const fn (
            self: *const IRedbookDiscMaster,
            pn_block_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAudioTrack: *const fn (
            self: *const IRedbookDiscMaster,
            n_blocks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAudioTrackBlocks: *const fn (
            self: *const IRedbookDiscMaster,
            pby: [*:0]u8,
            cb: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseAudioTrack: *const fn (
            self: *const IRedbookDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTotalAudioTracks(self: *const T, pn_tracks_: ?*i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalAudioTracks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pn_tracks_);
            }
            pub inline fn getTotalAudioBlocks(self: *const T, pn_blocks_: ?*i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalAudioBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pn_blocks_);
            }
            pub inline fn getUsedAudioBlocks(self: *const T, pn_blocks_: ?*i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetUsedAudioBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pn_blocks_);
            }
            pub inline fn getAvailableAudioTrackBlocks(self: *const T, pn_blocks_: ?*i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetAvailableAudioTrackBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pn_blocks_);
            }
            pub inline fn getAudioBlockSize(self: *const T, pn_block_bytes_: ?*i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetAudioBlockSize(@as(*const IRedbookDiscMaster, @ptrCast(self)), pn_block_bytes_);
            }
            pub inline fn createAudioTrack(self: *const T, n_blocks_: i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).CreateAudioTrack(@as(*const IRedbookDiscMaster, @ptrCast(self)), n_blocks_);
            }
            pub inline fn addAudioTrackBlocks(self: *const T, pby_: [*:0]u8, cb_: i32) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).AddAudioTrackBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pby_, cb_);
            }
            pub inline fn closeAudioTrack(self: *const T) HRESULT {
                return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).CloseAudioTrack(@as(*const IRedbookDiscMaster, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IJolietDiscMaster_Value = Guid.initString("e3bc42ce-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IJolietDiscMaster = &IID_IJolietDiscMaster_Value;
pub const IJolietDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalDataBlocks: *const fn (
            self: *const IJolietDiscMaster,
            pn_blocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsedDataBlocks: *const fn (
            self: *const IJolietDiscMaster,
            pn_blocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBlockSize: *const fn (
            self: *const IJolietDiscMaster,
            pn_block_bytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddData: *const fn (
            self: *const IJolietDiscMaster,
            p_storage: ?*IStorage,
            l_file_overwrite: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJolietProperties: *const fn (
            self: *const IJolietDiscMaster,
            pp_prop_stg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetJolietProperties: *const fn (
            self: *const IJolietDiscMaster,
            p_prop_stg: ?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTotalDataBlocks(self: *const T, pn_blocks_: ?*i32) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalDataBlocks(@as(*const IJolietDiscMaster, @ptrCast(self)), pn_blocks_);
            }
            pub inline fn getUsedDataBlocks(self: *const T, pn_blocks_: ?*i32) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetUsedDataBlocks(@as(*const IJolietDiscMaster, @ptrCast(self)), pn_blocks_);
            }
            pub inline fn getDataBlockSize(self: *const T, pn_block_bytes_: ?*i32) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetDataBlockSize(@as(*const IJolietDiscMaster, @ptrCast(self)), pn_block_bytes_);
            }
            pub inline fn addData(self: *const T, p_storage_: ?*IStorage, l_file_overwrite_: i32) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).AddData(@as(*const IJolietDiscMaster, @ptrCast(self)), p_storage_, l_file_overwrite_);
            }
            pub inline fn getJolietProperties(self: *const T, pp_prop_stg_: ?*?*IPropertyStorage) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetJolietProperties(@as(*const IJolietDiscMaster, @ptrCast(self)), pp_prop_stg_);
            }
            pub inline fn setJolietProperties(self: *const T, p_prop_stg_: ?*IPropertyStorage) HRESULT {
                return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).SetJolietProperties(@as(*const IJolietDiscMaster, @ptrCast(self)), p_prop_stg_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMasterProgressEvents_Value = Guid.initString("ec9e51c1-4e5d-11d3-9144-00104ba11c5e");
pub const IID_IDiscMasterProgressEvents = &IID_IDiscMasterProgressEvents_Value;
pub const IDiscMasterProgressEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCancel: *const fn (
            self: *const IDiscMasterProgressEvents,
            pb_cancel: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyPnPActivity: *const fn (
            self: *const IDiscMasterProgressEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAddProgress: *const fn (
            self: *const IDiscMasterProgressEvents,
            n_completed_steps: i32,
            n_total_steps: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyBlockProgress: *const fn (
            self: *const IDiscMasterProgressEvents,
            n_completed: i32,
            n_total: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyTrackProgress: *const fn (
            self: *const IDiscMasterProgressEvents,
            n_current_track: i32,
            n_total_tracks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyPreparingBurn: *const fn (
            self: *const IDiscMasterProgressEvents,
            n_estimated_seconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyClosingDisc: *const fn (
            self: *const IDiscMasterProgressEvents,
            n_estimated_seconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyBurnComplete: *const fn (
            self: *const IDiscMasterProgressEvents,
            status: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEraseComplete: *const fn (
            self: *const IDiscMasterProgressEvents,
            status: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn queryCancel(self: *const T, pb_cancel_: ?*u8) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).QueryCancel(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), pb_cancel_);
            }
            pub inline fn notifyPnPActivity(self: *const T) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyPnPActivity(@as(*const IDiscMasterProgressEvents, @ptrCast(self)));
            }
            pub inline fn notifyAddProgress(self: *const T, n_completed_steps_: i32, n_total_steps_: i32) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyAddProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), n_completed_steps_, n_total_steps_);
            }
            pub inline fn notifyBlockProgress(self: *const T, n_completed_: i32, n_total_: i32) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyBlockProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), n_completed_, n_total_);
            }
            pub inline fn notifyTrackProgress(self: *const T, n_current_track_: i32, n_total_tracks_: i32) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyTrackProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), n_current_track_, n_total_tracks_);
            }
            pub inline fn notifyPreparingBurn(self: *const T, n_estimated_seconds_: i32) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyPreparingBurn(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), n_estimated_seconds_);
            }
            pub inline fn notifyClosingDisc(self: *const T, n_estimated_seconds_: i32) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyClosingDisc(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), n_estimated_seconds_);
            }
            pub inline fn notifyBurnComplete(self: *const T, status_: HRESULT) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyBurnComplete(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), status_);
            }
            pub inline fn notifyEraseComplete(self: *const T, status_: HRESULT) HRESULT {
                return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyEraseComplete(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMaster_Value = Guid.initString("520cca62-51a5-11d3-9144-00104ba11c5e");
pub const IID_IDiscMaster = &IID_IDiscMaster_Value;
pub const IDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: *const fn (
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDiscMasterFormats: *const fn (
            self: *const IDiscMaster,
            pp_enum: ?*?*IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveDiscMasterFormat: *const fn (
            self: *const IDiscMaster,
            lpiid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveDiscMasterFormat: *const fn (
            self: *const IDiscMaster,
            riid: ?*const Guid,
            pp_unk: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDiscRecorders: *const fn (
            self: *const IDiscMaster,
            pp_enum: ?*?*IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveDiscRecorder: *const fn (
            self: *const IDiscMaster,
            pp_recorder: ?*?*IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveDiscRecorder: *const fn (
            self: *const IDiscMaster,
            p_recorder: ?*IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearFormatContent: *const fn (
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressAdvise: *const fn (
            self: *const IDiscMaster,
            p_events: ?*IDiscMasterProgressEvents,
            pv_cookie: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressUnadvise: *const fn (
            self: *const IDiscMaster,
            v_cookie: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecordDisc: *const fn (
            self: *const IDiscMaster,
            b_simulate: u8,
            b_eject_after_burn: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn open(self: *const T) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).Open(@as(*const IDiscMaster, @ptrCast(self)));
            }
            pub inline fn enumDiscMasterFormats(self: *const T, pp_enum_: ?*?*IEnumDiscMasterFormats) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).EnumDiscMasterFormats(@as(*const IDiscMaster, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getActiveDiscMasterFormat(self: *const T, lpiid_: ?*Guid) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).GetActiveDiscMasterFormat(@as(*const IDiscMaster, @ptrCast(self)), lpiid_);
            }
            pub inline fn setActiveDiscMasterFormat(self: *const T, riid_: ?*const Guid, pp_unk_: ?*?*anyopaque) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).SetActiveDiscMasterFormat(@as(*const IDiscMaster, @ptrCast(self)), riid_, pp_unk_);
            }
            pub inline fn enumDiscRecorders(self: *const T, pp_enum_: ?*?*IEnumDiscRecorders) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).EnumDiscRecorders(@as(*const IDiscMaster, @ptrCast(self)), pp_enum_);
            }
            pub inline fn getActiveDiscRecorder(self: *const T, pp_recorder_: ?*?*IDiscRecorder) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).GetActiveDiscRecorder(@as(*const IDiscMaster, @ptrCast(self)), pp_recorder_);
            }
            pub inline fn setActiveDiscRecorder(self: *const T, p_recorder_: ?*IDiscRecorder) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).SetActiveDiscRecorder(@as(*const IDiscMaster, @ptrCast(self)), p_recorder_);
            }
            pub inline fn clearFormatContent(self: *const T) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ClearFormatContent(@as(*const IDiscMaster, @ptrCast(self)));
            }
            pub inline fn progressAdvise(self: *const T, p_events_: ?*IDiscMasterProgressEvents, pv_cookie_: ?*usize) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ProgressAdvise(@as(*const IDiscMaster, @ptrCast(self)), p_events_, pv_cookie_);
            }
            pub inline fn progressUnadvise(self: *const T, v_cookie_: usize) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ProgressUnadvise(@as(*const IDiscMaster, @ptrCast(self)), v_cookie_);
            }
            pub inline fn recordDisc(self: *const T, b_simulate_: u8, b_eject_after_burn_: u8) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).RecordDisc(@as(*const IDiscMaster, @ptrCast(self)), b_simulate_, b_eject_after_burn_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).Close(@as(*const IDiscMaster, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _MSGSESS = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const MSGCALLRELEASE = *const fn (
    ul_caller_data: u32,
    lp_message: ?*IMessage,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SPropAttrArray = extern struct {
    cValues: u32,
    aPropAttr: [1]u32,
};

const CLSID_tagIMMPID_MP_STRUCT_Value = Guid.initString("13384cf0-b3c4-11d1-aa92-00aa006bc80b");
pub const CLSID_tagIMMPID_MP_STRUCT = &CLSID_tagIMMPID_MP_STRUCT_Value;

pub const IMMPID_MP_ENUM = enum(i32) {
    BEFORE__ = 4095,
    RECIPIENT_LIST = 4096,
    CONTENT_FILE_NAME = 4097,
    SENDER_ADDRESS_SMTP = 4098,
    SENDER_ADDRESS_X500 = 4099,
    SENDER_ADDRESS_X400 = 4100,
    SENDER_ADDRESS_LEGACY_EX_DN = 4101,
    DOMAIN_LIST = 4102,
    PICKUP_FILE_NAME = 4103,
    AUTHENTICATED_USER_NAME = 4104,
    CONNECTION_IP_ADDRESS = 4105,
    HELO_DOMAIN = 4106,
    EIGHTBIT_MIME_OPTION = 4107,
    CHUNKING_OPTION = 4108,
    BINARYMIME_OPTION = 4109,
    REMOTE_AUTHENTICATION_TYPE = 4110,
    ERROR_CODE = 4111,
    DSN_ENVID_VALUE = 4112,
    DSN_RET_VALUE = 4113,
    REMOTE_SERVER_DSN_CAPABLE = 4114,
    ARRIVAL_TIME = 4115,
    MESSAGE_STATUS = 4116,
    EXPIRE_DELAY = 4117,
    EXPIRE_NDR = 4118,
    LOCAL_EXPIRE_DELAY = 4119,
    LOCAL_EXPIRE_NDR = 4120,
    ARRIVAL_FILETIME = 4121,
    HR_CAT_STATUS = 4122,
    MSG_GUID = 4123,
    SUPERSEDES_MSG_GUID = 4124,
    SCANNED_FOR_CRLF_DOT_CRLF = 4125,
    FOUND_EMBEDDED_CRLF_DOT_CRLF = 4126,
    MSG_SIZE_HINT = 4127,
    RFC822_MSG_ID = 4128,
    RFC822_MSG_SUBJECT = 4129,
    RFC822_FROM_ADDRESS = 4130,
    RFC822_TO_ADDRESS = 4131,
    RFC822_CC_ADDRESS = 4132,
    RFC822_BCC_ADDRESS = 4133,
    CONNECTION_SERVER_IP_ADDRESS = 4134,
    SERVER_NAME = 4135,
    SERVER_VERSION = 4136,
    NUM_RECIPIENTS = 4137,
    X_PRIORITY = 4138,
    FROM_ADDRESS = 4139,
    SENDER_ADDRESS = 4140,
    DEFERRED_DELIVERY_FILETIME = 4141,
    SENDER_ADDRESS_OTHER = 4142,
    ORIGINAL_ARRIVAL_TIME = 4143,
    MSGCLASS = 4144,
    CONTENT_TYPE = 4145,
    ENCRYPTION_TYPE = 4146,
    CONNECTION_SERVER_PORT = 4147,
    CLIENT_AUTH_USER = 4148,
    CLIENT_AUTH_TYPE = 4149,
    CRC_GLOBAL = 4150,
    CRC_RECIPS = 4151,
    INBOUND_MAIL_FROM_AUTH = 4152,
    AFTER__ = 4153,
};
pub const IMMPID_MP_BEFORE__ = IMMPID_MP_ENUM.BEFORE__;
pub const IMMPID_MP_RECIPIENT_LIST = IMMPID_MP_ENUM.RECIPIENT_LIST;
pub const IMMPID_MP_CONTENT_FILE_NAME = IMMPID_MP_ENUM.CONTENT_FILE_NAME;
pub const IMMPID_MP_SENDER_ADDRESS_SMTP = IMMPID_MP_ENUM.SENDER_ADDRESS_SMTP;
pub const IMMPID_MP_SENDER_ADDRESS_X500 = IMMPID_MP_ENUM.SENDER_ADDRESS_X500;
pub const IMMPID_MP_SENDER_ADDRESS_X400 = IMMPID_MP_ENUM.SENDER_ADDRESS_X400;
pub const IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN = IMMPID_MP_ENUM.SENDER_ADDRESS_LEGACY_EX_DN;
pub const IMMPID_MP_DOMAIN_LIST = IMMPID_MP_ENUM.DOMAIN_LIST;
pub const IMMPID_MP_PICKUP_FILE_NAME = IMMPID_MP_ENUM.PICKUP_FILE_NAME;
pub const IMMPID_MP_AUTHENTICATED_USER_NAME = IMMPID_MP_ENUM.AUTHENTICATED_USER_NAME;
pub const IMMPID_MP_CONNECTION_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_IP_ADDRESS;
pub const IMMPID_MP_HELO_DOMAIN = IMMPID_MP_ENUM.HELO_DOMAIN;
pub const IMMPID_MP_EIGHTBIT_MIME_OPTION = IMMPID_MP_ENUM.EIGHTBIT_MIME_OPTION;
pub const IMMPID_MP_CHUNKING_OPTION = IMMPID_MP_ENUM.CHUNKING_OPTION;
pub const IMMPID_MP_BINARYMIME_OPTION = IMMPID_MP_ENUM.BINARYMIME_OPTION;
pub const IMMPID_MP_REMOTE_AUTHENTICATION_TYPE = IMMPID_MP_ENUM.REMOTE_AUTHENTICATION_TYPE;
pub const IMMPID_MP_ERROR_CODE = IMMPID_MP_ENUM.ERROR_CODE;
pub const IMMPID_MP_DSN_ENVID_VALUE = IMMPID_MP_ENUM.DSN_ENVID_VALUE;
pub const IMMPID_MP_DSN_RET_VALUE = IMMPID_MP_ENUM.DSN_RET_VALUE;
pub const IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE = IMMPID_MP_ENUM.REMOTE_SERVER_DSN_CAPABLE;
pub const IMMPID_MP_ARRIVAL_TIME = IMMPID_MP_ENUM.ARRIVAL_TIME;
pub const IMMPID_MP_MESSAGE_STATUS = IMMPID_MP_ENUM.MESSAGE_STATUS;
pub const IMMPID_MP_EXPIRE_DELAY = IMMPID_MP_ENUM.EXPIRE_DELAY;
pub const IMMPID_MP_EXPIRE_NDR = IMMPID_MP_ENUM.EXPIRE_NDR;
pub const IMMPID_MP_LOCAL_EXPIRE_DELAY = IMMPID_MP_ENUM.LOCAL_EXPIRE_DELAY;
pub const IMMPID_MP_LOCAL_EXPIRE_NDR = IMMPID_MP_ENUM.LOCAL_EXPIRE_NDR;
pub const IMMPID_MP_ARRIVAL_FILETIME = IMMPID_MP_ENUM.ARRIVAL_FILETIME;
pub const IMMPID_MP_HR_CAT_STATUS = IMMPID_MP_ENUM.HR_CAT_STATUS;
pub const IMMPID_MP_MSG_GUID = IMMPID_MP_ENUM.MSG_GUID;
pub const IMMPID_MP_SUPERSEDES_MSG_GUID = IMMPID_MP_ENUM.SUPERSEDES_MSG_GUID;
pub const IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF = IMMPID_MP_ENUM.SCANNED_FOR_CRLF_DOT_CRLF;
pub const IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF = IMMPID_MP_ENUM.FOUND_EMBEDDED_CRLF_DOT_CRLF;
pub const IMMPID_MP_MSG_SIZE_HINT = IMMPID_MP_ENUM.MSG_SIZE_HINT;
pub const IMMPID_MP_RFC822_MSG_ID = IMMPID_MP_ENUM.RFC822_MSG_ID;
pub const IMMPID_MP_RFC822_MSG_SUBJECT = IMMPID_MP_ENUM.RFC822_MSG_SUBJECT;
pub const IMMPID_MP_RFC822_FROM_ADDRESS = IMMPID_MP_ENUM.RFC822_FROM_ADDRESS;
pub const IMMPID_MP_RFC822_TO_ADDRESS = IMMPID_MP_ENUM.RFC822_TO_ADDRESS;
pub const IMMPID_MP_RFC822_CC_ADDRESS = IMMPID_MP_ENUM.RFC822_CC_ADDRESS;
pub const IMMPID_MP_RFC822_BCC_ADDRESS = IMMPID_MP_ENUM.RFC822_BCC_ADDRESS;
pub const IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_SERVER_IP_ADDRESS;
pub const IMMPID_MP_SERVER_NAME = IMMPID_MP_ENUM.SERVER_NAME;
pub const IMMPID_MP_SERVER_VERSION = IMMPID_MP_ENUM.SERVER_VERSION;
pub const IMMPID_MP_NUM_RECIPIENTS = IMMPID_MP_ENUM.NUM_RECIPIENTS;
pub const IMMPID_MP_X_PRIORITY = IMMPID_MP_ENUM.X_PRIORITY;
pub const IMMPID_MP_FROM_ADDRESS = IMMPID_MP_ENUM.FROM_ADDRESS;
pub const IMMPID_MP_SENDER_ADDRESS = IMMPID_MP_ENUM.SENDER_ADDRESS;
pub const IMMPID_MP_DEFERRED_DELIVERY_FILETIME = IMMPID_MP_ENUM.DEFERRED_DELIVERY_FILETIME;
pub const IMMPID_MP_SENDER_ADDRESS_OTHER = IMMPID_MP_ENUM.SENDER_ADDRESS_OTHER;
pub const IMMPID_MP_ORIGINAL_ARRIVAL_TIME = IMMPID_MP_ENUM.ORIGINAL_ARRIVAL_TIME;
pub const IMMPID_MP_MSGCLASS = IMMPID_MP_ENUM.MSGCLASS;
pub const IMMPID_MP_CONTENT_TYPE = IMMPID_MP_ENUM.CONTENT_TYPE;
pub const IMMPID_MP_ENCRYPTION_TYPE = IMMPID_MP_ENUM.ENCRYPTION_TYPE;
pub const IMMPID_MP_CONNECTION_SERVER_PORT = IMMPID_MP_ENUM.CONNECTION_SERVER_PORT;
pub const IMMPID_MP_CLIENT_AUTH_USER = IMMPID_MP_ENUM.CLIENT_AUTH_USER;
pub const IMMPID_MP_CLIENT_AUTH_TYPE = IMMPID_MP_ENUM.CLIENT_AUTH_TYPE;
pub const IMMPID_MP_CRC_GLOBAL = IMMPID_MP_ENUM.CRC_GLOBAL;
pub const IMMPID_MP_CRC_RECIPS = IMMPID_MP_ENUM.CRC_RECIPS;
pub const IMMPID_MP_INBOUND_MAIL_FROM_AUTH = IMMPID_MP_ENUM.INBOUND_MAIL_FROM_AUTH;
pub const IMMPID_MP_AFTER__ = IMMPID_MP_ENUM.AFTER__;

const CLSID_tagIMMPID_RP_STRUCT_Value = Guid.initString("79e82048-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RP_STRUCT = &CLSID_tagIMMPID_RP_STRUCT_Value;

pub const IMMPID_RP_ENUM = enum(i32) {
    BEFORE__ = 8191,
    DSN_NOTIFY_SUCCESS = 8192,
    DSN_NOTIFY_INVALID = 8193,
    ADDRESS_TYPE = 8194,
    ADDRESS = 8195,
    ADDRESS_TYPE_SMTP = 8196,
    ERROR_CODE = 8197,
    ERROR_STRING = 8198,
    DSN_NOTIFY_VALUE = 8199,
    DSN_ORCPT_VALUE = 8200,
    ADDRESS_SMTP = 8201,
    ADDRESS_X400 = 8202,
    ADDRESS_X500 = 8203,
    LEGACY_EX_DN = 8204,
    RECIPIENT_FLAGS = 8205,
    SMTP_STATUS_STRING = 8206,
    DSN_PRE_CAT_ADDRESS = 8207,
    MDB_GUID = 8208,
    USER_GUID = 8209,
    DOMAIN = 8210,
    ADDRESS_OTHER = 8211,
    DISPLAY_NAME = 8212,
    AFTER__ = 8213,
};
pub const IMMPID_RP_BEFORE__ = IMMPID_RP_ENUM.BEFORE__;
pub const IMMPID_RP_DSN_NOTIFY_SUCCESS = IMMPID_RP_ENUM.DSN_NOTIFY_SUCCESS;
pub const IMMPID_RP_DSN_NOTIFY_INVALID = IMMPID_RP_ENUM.DSN_NOTIFY_INVALID;
pub const IMMPID_RP_ADDRESS_TYPE = IMMPID_RP_ENUM.ADDRESS_TYPE;
pub const IMMPID_RP_ADDRESS = IMMPID_RP_ENUM.ADDRESS;
pub const IMMPID_RP_ADDRESS_TYPE_SMTP = IMMPID_RP_ENUM.ADDRESS_TYPE_SMTP;
pub const IMMPID_RP_ERROR_CODE = IMMPID_RP_ENUM.ERROR_CODE;
pub const IMMPID_RP_ERROR_STRING = IMMPID_RP_ENUM.ERROR_STRING;
pub const IMMPID_RP_DSN_NOTIFY_VALUE = IMMPID_RP_ENUM.DSN_NOTIFY_VALUE;
pub const IMMPID_RP_DSN_ORCPT_VALUE = IMMPID_RP_ENUM.DSN_ORCPT_VALUE;
pub const IMMPID_RP_ADDRESS_SMTP = IMMPID_RP_ENUM.ADDRESS_SMTP;
pub const IMMPID_RP_ADDRESS_X400 = IMMPID_RP_ENUM.ADDRESS_X400;
pub const IMMPID_RP_ADDRESS_X500 = IMMPID_RP_ENUM.ADDRESS_X500;
pub const IMMPID_RP_LEGACY_EX_DN = IMMPID_RP_ENUM.LEGACY_EX_DN;
pub const IMMPID_RP_RECIPIENT_FLAGS = IMMPID_RP_ENUM.RECIPIENT_FLAGS;
pub const IMMPID_RP_SMTP_STATUS_STRING = IMMPID_RP_ENUM.SMTP_STATUS_STRING;
pub const IMMPID_RP_DSN_PRE_CAT_ADDRESS = IMMPID_RP_ENUM.DSN_PRE_CAT_ADDRESS;
pub const IMMPID_RP_MDB_GUID = IMMPID_RP_ENUM.MDB_GUID;
pub const IMMPID_RP_USER_GUID = IMMPID_RP_ENUM.USER_GUID;
pub const IMMPID_RP_DOMAIN = IMMPID_RP_ENUM.DOMAIN;
pub const IMMPID_RP_ADDRESS_OTHER = IMMPID_RP_ENUM.ADDRESS_OTHER;
pub const IMMPID_RP_DISPLAY_NAME = IMMPID_RP_ENUM.DISPLAY_NAME;
pub const IMMPID_RP_AFTER__ = IMMPID_RP_ENUM.AFTER__;

const CLSID_tagIMMPID_MPV_STRUCT_Value = Guid.initString("cbe69706-c9bd-11d1-9ff2-00c04fa37348");
pub const CLSID_tagIMMPID_MPV_STRUCT = &CLSID_tagIMMPID_MPV_STRUCT_Value;

pub const IMMPID_MPV_ENUM = enum(i32) {
    BEFORE__ = 12287,
    STORE_DRIVER_HANDLE = 12288,
    MESSAGE_CREATION_FLAGS = 12289,
    MESSAGE_OPEN_HANDLES = 12290,
    TOTAL_OPEN_HANDLES = 12291,
    TOTAL_OPEN_PROPERTY_STREAM_HANDLES = 12292,
    TOTAL_OPEN_CONTENT_HANDLES = 12293,
    AFTER__ = 12294,
};
pub const IMMPID_MPV_BEFORE__ = IMMPID_MPV_ENUM.BEFORE__;
pub const IMMPID_MPV_STORE_DRIVER_HANDLE = IMMPID_MPV_ENUM.STORE_DRIVER_HANDLE;
pub const IMMPID_MPV_MESSAGE_CREATION_FLAGS = IMMPID_MPV_ENUM.MESSAGE_CREATION_FLAGS;
pub const IMMPID_MPV_MESSAGE_OPEN_HANDLES = IMMPID_MPV_ENUM.MESSAGE_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_PROPERTY_STREAM_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_CONTENT_HANDLES;
pub const IMMPID_MPV_AFTER__ = IMMPID_MPV_ENUM.AFTER__;

pub const IMMP_MPV_STORE_DRIVER_HANDLE = extern struct {
    guidSignature: Guid,
};

const CLSID_tagIMMPID_RPV_STRUCT_Value = Guid.initString("79e82049-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RPV_STRUCT = &CLSID_tagIMMPID_RPV_STRUCT_Value;

pub const IMMPID_RPV_ENUM = enum(i32) {
    BEFORE__ = 16383,
    DONT_DELIVER = 16384,
    NO_NAME_COLLISIONS = 16385,
    AFTER__ = 16386,
};
pub const IMMPID_RPV_BEFORE__ = IMMPID_RPV_ENUM.BEFORE__;
pub const IMMPID_RPV_DONT_DELIVER = IMMPID_RPV_ENUM.DONT_DELIVER;
pub const IMMPID_RPV_NO_NAME_COLLISIONS = IMMPID_RPV_ENUM.NO_NAME_COLLISIONS;
pub const IMMPID_RPV_AFTER__ = IMMPID_RPV_ENUM.AFTER__;

const CLSID_tagIMMPID_NMP_STRUCT_Value = Guid.initString("7433a9aa-20e2-11d2-94d6-00c04fa379f1");
pub const CLSID_tagIMMPID_NMP_STRUCT = &CLSID_tagIMMPID_NMP_STRUCT_Value;

pub const IMMPID_NMP_ENUM = enum(i32) {
    BEFORE__ = 24575,
    SECONDARY_GROUPS = 24576,
    SECONDARY_ARTNUM = 24577,
    PRIMARY_GROUP = 24578,
    PRIMARY_ARTID = 24579,
    POST_TOKEN = 24580,
    NEWSGROUP_LIST = 24581,
    HEADERS = 24582,
    NNTP_PROCESSING = 24583,
    NNTP_APPROVED_HEADER = 24584,
    AFTER__ = 24585,
};
pub const IMMPID_NMP_BEFORE__ = IMMPID_NMP_ENUM.BEFORE__;
pub const IMMPID_NMP_SECONDARY_GROUPS = IMMPID_NMP_ENUM.SECONDARY_GROUPS;
pub const IMMPID_NMP_SECONDARY_ARTNUM = IMMPID_NMP_ENUM.SECONDARY_ARTNUM;
pub const IMMPID_NMP_PRIMARY_GROUP = IMMPID_NMP_ENUM.PRIMARY_GROUP;
pub const IMMPID_NMP_PRIMARY_ARTID = IMMPID_NMP_ENUM.PRIMARY_ARTID;
pub const IMMPID_NMP_POST_TOKEN = IMMPID_NMP_ENUM.POST_TOKEN;
pub const IMMPID_NMP_NEWSGROUP_LIST = IMMPID_NMP_ENUM.NEWSGROUP_LIST;
pub const IMMPID_NMP_HEADERS = IMMPID_NMP_ENUM.HEADERS;
pub const IMMPID_NMP_NNTP_PROCESSING = IMMPID_NMP_ENUM.NNTP_PROCESSING;
pub const IMMPID_NMP_NNTP_APPROVED_HEADER = IMMPID_NMP_ENUM.NNTP_APPROVED_HEADER;
pub const IMMPID_NMP_AFTER__ = IMMPID_NMP_ENUM.AFTER__;

const CLSID_tagIMMPID_CPV_STRUCT_Value = Guid.initString("a2a76b2a-e52d-11d1-aa64-00c04fa35b82");
pub const CLSID_tagIMMPID_CPV_STRUCT = &CLSID_tagIMMPID_CPV_STRUCT_Value;

pub const IMMPID_CPV_ENUM = enum(i32) {
    V_BEFORE__ = 32767,
    _START = 32768,
    V_AFTER__ = 32769,
};
pub const IMMPID_CPV_BEFORE__ = IMMPID_CPV_ENUM.V_BEFORE__;
pub const IMMPID_CP_START = IMMPID_CPV_ENUM._START;
pub const IMMPID_CPV_AFTER__ = IMMPID_CPV_ENUM.V_AFTER__;

pub const tagIMMPID_GUIDLIST_ITEM = extern struct {
    pguid: ?*const Guid,
    dwStart: u32,
    dwLast: u32,
};

//--------------------------------------------------------------------------------
// Section: Functions (6)
//--------------------------------------------------------------------------------
pub extern "mapi32" fn OpenIMsgSession(
    lp_malloc: ?*IMalloc,
    ul_flags: u32,
    lpp_msg_sess: ?*?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn CloseIMsgSession(
    lp_msg_sess: ?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn OpenIMsgOnIStg(
    lp_msg_sess: ?*_MSGSESS,
    lp_allocate_buffer: ?LPALLOCATEBUFFER,
    lp_allocate_more: ?LPALLOCATEMORE,
    lp_free_buffer: ?LPFREEBUFFER,
    lp_malloc: ?*IMalloc,
    lp_mapi_sup: ?*anyopaque,
    lp_stg: ?*IStorage,
    lpf_msg_call_release: ?*?MSGCALLRELEASE,
    ul_caller_data: u32,
    ul_flags: u32,
    lpp_msg: ?*?*IMessage,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn GetAttribIMsgOnIStg(
    lp_object: ?*anyopaque,
    lp_prop_tag_array: ?*SPropTagArray,
    lpp_prop_attr_array: ?*?*SPropAttrArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn SetAttribIMsgOnIStg(
    lp_object: ?*anyopaque,
    lp_prop_tags: ?*SPropTagArray,
    lp_prop_attrs: ?*SPropAttrArray,
    lpp_prop_problems: ?*?*SPropProblemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn MapStorageSCode(
    stg_s_code: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IMalloc = @import("../system/com.zig").IMalloc;
const IMessage = @import("../system/address_book.zig").IMessage;
const IPropertyStorage = @import("../system/com/structured_storage.zig").IPropertyStorage;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPALLOCATEBUFFER = @import("../system/address_book.zig").LPALLOCATEBUFFER;
const LPALLOCATEMORE = @import("../system/address_book.zig").LPALLOCATEMORE;
const LPFREEBUFFER = @import("../system/address_book.zig").LPFREEBUFFER;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SPropProblemArray = @import("../system/address_book.zig").SPropProblemArray;
const SPropTagArray = @import("../system/address_book.zig").SPropTagArray;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "MSGCALLRELEASE")) {
        _ = MSGCALLRELEASE;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
