//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (279)
//--------------------------------------------------------------------------------
pub const EA_CONTAINER_NAME = "ContainerName";
pub const EA_CONTAINER_SIZE = "ContainerSize";
pub const CLFS_BASELOG_EXTENSION = ".blf";
pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM = @as(u32, 8);
pub const CLFS_FLAG_NON_REENTRANT_FILTER = @as(u32, 16);
pub const CLFS_FLAG_REENTRANT_FILTER = @as(u32, 32);
pub const CLFS_FLAG_IGNORE_SHARE_ACCESS = @as(u32, 64);
pub const CLFS_FLAG_READ_IN_PROGRESS = @as(u32, 128);
pub const CLFS_FLAG_MINIFILTER_LEVEL = @as(u32, 256);
pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG = @as(u32, 512);
pub const CLFS_MARSHALLING_FLAG_NONE = @as(u32, 0);
pub const CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT = @as(u32, 1);
pub const CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL = @as(u32, 16);
pub const CLFS_FLAG_FILTER_TOP_LEVEL = @as(u32, 32);
pub const CLFS_CONTAINER_STREAM_PREFIX = "%BLF%:";
pub const CLFS_CONTAINER_RELATIVE_PREFIX = "%BLF%\\";
pub const TRANSACTION_MANAGER_VOLATILE = @as(u32, 1);
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT = @as(u32, 0);
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME = @as(u32, 2);
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES = @as(u32, 4);
pub const TRANSACTION_MANAGER_COMMIT_LOWEST = @as(u32, 8);
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY = @as(u32, 16);
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS = @as(u32, 32);
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION = @as(u32, 63);
pub const TRANSACTION_DO_NOT_PROMOTE = @as(u32, 1);
pub const TRANSACTION_MAXIMUM_OPTION = @as(u32, 1);
pub const RESOURCE_MANAGER_VOLATILE = @as(u32, 1);
pub const RESOURCE_MANAGER_COMMUNICATION = @as(u32, 2);
pub const RESOURCE_MANAGER_MAXIMUM_OPTION = @as(u32, 3);
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY = @as(u32, 1);
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO = @as(u32, 2);
pub const CRM_PROTOCOL_MAXIMUM_OPTION = @as(u32, 3);
pub const ENLISTMENT_SUPERIOR = @as(u32, 1);
pub const ENLISTMENT_MAXIMUM_OPTION = @as(u32, 1);
pub const TRANSACTION_NOTIFY_MASK = @as(u32, 1073741823);
pub const TRANSACTION_NOTIFY_PREPREPARE = @as(u32, 1);
pub const TRANSACTION_NOTIFY_PREPARE = @as(u32, 2);
pub const TRANSACTION_NOTIFY_COMMIT = @as(u32, 4);
pub const TRANSACTION_NOTIFY_ROLLBACK = @as(u32, 8);
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE = @as(u32, 16);
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE = @as(u32, 32);
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE = @as(u32, 64);
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE = @as(u32, 128);
pub const TRANSACTION_NOTIFY_RECOVER = @as(u32, 256);
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT = @as(u32, 512);
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT = @as(u32, 1024);
pub const TRANSACTION_NOTIFY_RECOVER_QUERY = @as(u32, 2048);
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE = @as(u32, 4096);
pub const TRANSACTION_NOTIFY_LAST_RECOVER = @as(u32, 8192);
pub const TRANSACTION_NOTIFY_INDOUBT = @as(u32, 16384);
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL = @as(u32, 32768);
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH = @as(u32, 65536);
pub const TRANSACTION_NOTIFY_MARSHAL = @as(u32, 131072);
pub const TRANSACTION_NOTIFY_ENLIST_MASK = @as(u32, 262144);
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED = @as(u32, 16777216);
pub const TRANSACTION_NOTIFY_TM_ONLINE = @as(u32, 33554432);
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST = @as(u32, 67108864);
pub const TRANSACTION_NOTIFY_PROMOTE = @as(u32, 134217728);
pub const TRANSACTION_NOTIFY_PROMOTE_NEW = @as(u32, 268435456);
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME = @as(u32, 536870912);
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE = @as(u32, 1073741824);
pub const TRANSACTIONMANAGER_OBJECT_PATH = "\\TransactionManager\\";
pub const TRANSACTION_OBJECT_PATH = "\\Transaction\\";
pub const ENLISTMENT_OBJECT_PATH = "\\Enlistment\\";
pub const RESOURCE_MANAGER_OBJECT_PATH = "\\ResourceManager\\";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED = @as(u32, 1);
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR = @as(u32, 1);
pub const KTM_MARSHAL_BLOB_VERSION_MINOR = @as(u32, 1);
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH = @as(u32, 64);
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH = @as(u32, 64);
pub const IOCTL_VOLUME_BASE = @as(u32, 86);
pub const IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = @as(u32, 5636096);
pub const IOCTL_VOLUME_ONLINE = @as(u32, 5685256);
pub const IOCTL_VOLUME_OFFLINE = @as(u32, 5685260);
pub const IOCTL_VOLUME_IS_CLUSTERED = @as(u32, 5636144);
pub const IOCTL_VOLUME_GET_GPT_ATTRIBUTES = @as(u32, 5636152);
pub const IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = @as(u32, 5636100);
pub const IOCTL_VOLUME_IS_OFFLINE = @as(u32, 5636112);
pub const IOCTL_VOLUME_IS_IO_CAPABLE = @as(u32, 5636116);
pub const IOCTL_VOLUME_QUERY_FAILOVER_SET = @as(u32, 5636120);
pub const IOCTL_VOLUME_QUERY_VOLUME_NUMBER = @as(u32, 5636124);
pub const IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = @as(u32, 5636128);
pub const IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = @as(u32, 5636132);
pub const IOCTL_VOLUME_IS_PARTITION = @as(u32, 5636136);
pub const IOCTL_VOLUME_READ_PLEX = @as(u32, 5652526);
pub const IOCTL_VOLUME_SET_GPT_ATTRIBUTES = @as(u32, 5636148);
pub const IOCTL_VOLUME_GET_BC_PROPERTIES = @as(u32, 5652540);
pub const IOCTL_VOLUME_ALLOCATE_BC_STREAM = @as(u32, 5685312);
pub const IOCTL_VOLUME_FREE_BC_STREAM = @as(u32, 5685316);
pub const IOCTL_VOLUME_BC_VERSION = @as(u32, 1);
pub const IOCTL_VOLUME_IS_DYNAMIC = @as(u32, 5636168);
pub const IOCTL_VOLUME_PREPARE_FOR_CRITICAL_IO = @as(u32, 5685324);
pub const IOCTL_VOLUME_QUERY_ALLOCATION_HINT = @as(u32, 5652562);
pub const IOCTL_VOLUME_UPDATE_PROPERTIES = @as(u32, 5636180);
pub const IOCTL_VOLUME_QUERY_MINIMUM_SHRINK_SIZE = @as(u32, 5652568);
pub const IOCTL_VOLUME_PREPARE_FOR_SHRINK = @as(u32, 5685340);
pub const IOCTL_VOLUME_IS_CSV = @as(u32, 5636192);
pub const IOCTL_VOLUME_POST_ONLINE = @as(u32, 5685348);
pub const IOCTL_VOLUME_GET_CSVBLOCKCACHE_CALLBACK = @as(u32, 5685352);
pub const CSV_BLOCK_CACHE_CALLBACK_VERSION = @as(u32, 1);
pub const CSV_BLOCK_AND_FILE_CACHE_CALLBACK_VERSION = @as(u32, 2);
pub const PARTITION_BASIC_DATA_GUID = Guid.initString("ebd0a0a2-b9e5-4433-87c0-68b6b72699c7");
pub const PARTITION_BSP_GUID = Guid.initString("57434f53-4df9-45b9-8e9e-2370f006457c");
pub const PARTITION_CLUSTER_GUID = Guid.initString("db97dba9-0840-4bae-97f0-ffb9a327c7e1");
pub const PARTITION_DPP_GUID = Guid.initString("57434f53-94cb-43f0-a533-d73c10cfa57d");
pub const PARTITION_ENTRY_UNUSED_GUID = Guid.initString("00000000-0000-0000-0000-000000000000");
pub const PARTITION_LDM_DATA_GUID = Guid.initString("af9b60a0-1431-4f62-bc68-3311714a69ad");
pub const PARTITION_LDM_METADATA_GUID = Guid.initString("5808c8aa-7e8f-42e0-85d2-e1e90434cfb3");
pub const PARTITION_LEGACY_BL_GUID = Guid.initString("424ca0e2-7cb2-4fb9-8143-c52a99398bc6");
pub const PARTITION_LEGACY_BL_GUID_BACKUP = Guid.initString("424c3e6c-d79f-49cb-935d-36d71467a288");
pub const PARTITION_MAIN_OS_GUID = Guid.initString("57434f53-8f45-405e-8a23-186d8a4330d3");
pub const PARTITION_MSFT_RECOVERY_GUID = Guid.initString("de94bba4-06d1-4d40-a16a-bfd50179d6ac");
pub const PARTITION_MSFT_RESERVED_GUID = Guid.initString("e3c9e316-0b5c-4db8-817d-f92df00215ae");
pub const PARTITION_MSFT_SNAPSHOT_GUID = Guid.initString("caddebf1-4400-4de8-b103-12117dcf3ccf");
pub const PARTITION_OS_DATA_GUID = Guid.initString("57434f53-23f2-44d5-a830-67bbdaa609f9");
pub const PARTITION_PATCH_GUID = Guid.initString("8967a686-96aa-6aa8-9589-a84256541090");
pub const PARTITION_PRE_INSTALLED_GUID = Guid.initString("57434f53-7fe0-4196-9b42-427b51643484");
pub const PARTITION_SERVICING_FILES_GUID = Guid.initString("57434f53-432e-4014-ae4c-8deaa9c0006a");
pub const PARTITION_SERVICING_METADATA_GUID = Guid.initString("57434f53-c691-4a05-bb4e-703dafd229ce");
pub const PARTITION_SERVICING_RESERVE_GUID = Guid.initString("57434f53-4b81-460b-a319-ffb6fe136d14");
pub const PARTITION_SERVICING_STAGING_ROOT_GUID = Guid.initString("57434f53-e84d-4e84-aaf3-ecbbbd04b9df");
pub const PARTITION_SPACES_GUID = Guid.initString("e75caf8f-f680-4cee-afa3-b001e56efc2d");
pub const PARTITION_SPACES_DATA_GUID = Guid.initString("e7addcb4-dc34-4539-9a76-ebbd07be6f7e");
pub const PARTITION_SYSTEM_GUID = Guid.initString("c12a7328-f81f-11d2-ba4b-00a0c93ec93b");
pub const PARTITION_WINDOWS_SYSTEM_GUID = Guid.initString("57434f53-e3e3-4631-a5c5-26d2243873aa");
pub const _FT_TYPES_DEFINITION_ = @as(u32, 1);
pub const CLFS_MGMT_POLICY_VERSION = @as(u32, 1);
pub const LOG_POLICY_OVERWRITE = @as(u32, 1);
pub const LOG_POLICY_PERSIST = @as(u32, 2);
pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION = @as(u32, 1);
pub const CLSID_DiskQuotaControl = Guid.initString("7988b571-ec89-11cf-9c00-00aa00a14f56");
pub const DISKQUOTA_STATE_DISABLED = @as(u32, 0);
pub const DISKQUOTA_STATE_TRACK = @as(u32, 1);
pub const DISKQUOTA_STATE_ENFORCE = @as(u32, 2);
pub const DISKQUOTA_STATE_MASK = @as(u32, 3);
pub const DISKQUOTA_FILESTATE_INCOMPLETE = @as(u32, 256);
pub const DISKQUOTA_FILESTATE_REBUILDING = @as(u32, 512);
pub const DISKQUOTA_FILESTATE_MASK = @as(u32, 768);
pub const DISKQUOTA_LOGFLAG_USER_THRESHOLD = @as(u32, 1);
pub const DISKQUOTA_LOGFLAG_USER_LIMIT = @as(u32, 2);
pub const DISKQUOTA_USER_ACCOUNT_RESOLVED = @as(u32, 0);
pub const DISKQUOTA_USER_ACCOUNT_UNAVAILABLE = @as(u32, 1);
pub const DISKQUOTA_USER_ACCOUNT_DELETED = @as(u32, 2);
pub const DISKQUOTA_USER_ACCOUNT_INVALID = @as(u32, 3);
pub const DISKQUOTA_USER_ACCOUNT_UNKNOWN = @as(u32, 4);
pub const DISKQUOTA_USER_ACCOUNT_UNRESOLVED = @as(u32, 5);
pub const INVALID_SET_FILE_POINTER = @as(u32, 4294967295);
pub const INVALID_FILE_ATTRIBUTES = @as(u32, 4294967295);
pub const SHARE_NETNAME_PARMNUM = @as(u32, 1);
pub const SHARE_TYPE_PARMNUM = @as(u32, 3);
pub const SHARE_REMARK_PARMNUM = @as(u32, 4);
pub const SHARE_PERMISSIONS_PARMNUM = @as(u32, 5);
pub const SHARE_MAX_USES_PARMNUM = @as(u32, 6);
pub const SHARE_CURRENT_USES_PARMNUM = @as(u32, 7);
pub const SHARE_PATH_PARMNUM = @as(u32, 8);
pub const SHARE_PASSWD_PARMNUM = @as(u32, 9);
pub const SHARE_FILE_SD_PARMNUM = @as(u32, 501);
pub const SHARE_SERVER_PARMNUM = @as(u32, 503);
pub const SHI1_NUM_ELEMENTS = @as(u32, 4);
pub const SHI2_NUM_ELEMENTS = @as(u32, 10);
pub const STYPE_RESERVED1 = @as(u32, 16777216);
pub const STYPE_RESERVED2 = @as(u32, 33554432);
pub const STYPE_RESERVED3 = @as(u32, 67108864);
pub const STYPE_RESERVED4 = @as(u32, 134217728);
pub const STYPE_RESERVED5 = @as(u32, 1048576);
pub const STYPE_RESERVED_ALL = @as(u32, 1073741568);
pub const SHI_USES_UNLIMITED = @as(u32, 4294967295);
pub const SHI1005_FLAGS_DFS = @as(u32, 1);
pub const SHI1005_FLAGS_DFS_ROOT = @as(u32, 2);
pub const CSC_MASK_EXT = @as(u32, 8240);
pub const CSC_MASK = @as(u32, 48);
pub const CSC_CACHE_MANUAL_REINT = @as(u32, 0);
pub const CSC_CACHE_AUTO_REINT = @as(u32, 16);
pub const CSC_CACHE_VDO = @as(u32, 32);
pub const CSC_CACHE_NONE = @as(u32, 48);
pub const SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS = @as(u32, 256);
pub const SHI1005_FLAGS_FORCE_SHARED_DELETE = @as(u32, 512);
pub const SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING = @as(u32, 1024);
pub const SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM = @as(u32, 2048);
pub const SHI1005_FLAGS_FORCE_LEVELII_OPLOCK = @as(u32, 4096);
pub const SHI1005_FLAGS_ENABLE_HASH = @as(u32, 8192);
pub const SHI1005_FLAGS_ENABLE_CA = @as(u32, 16384);
pub const SHI1005_FLAGS_ENCRYPT_DATA = @as(u32, 32768);
pub const SHI1005_FLAGS_RESERVED = @as(u32, 65536);
pub const SHI1005_FLAGS_DISABLE_CLIENT_BUFFERING = @as(u32, 131072);
pub const SHI1005_FLAGS_IDENTITY_REMOTING = @as(u32, 262144);
pub const SHI1005_FLAGS_CLUSTER_MANAGED = @as(u32, 524288);
pub const SHI1005_FLAGS_COMPRESS_DATA = @as(u32, 1048576);
pub const SESI1_NUM_ELEMENTS = @as(u32, 8);
pub const SESI2_NUM_ELEMENTS = @as(u32, 9);
pub const STATSOPT_CLR = @as(u32, 1);
pub const LZERROR_BADINHANDLE = @as(i32, -1);
pub const LZERROR_BADOUTHANDLE = @as(i32, -2);
pub const LZERROR_READ = @as(i32, -3);
pub const LZERROR_WRITE = @as(i32, -4);
pub const LZERROR_GLOBALLOC = @as(i32, -5);
pub const LZERROR_GLOBLOCK = @as(i32, -6);
pub const LZERROR_BADVALUE = @as(i32, -7);
pub const LZERROR_UNKNOWNALG = @as(i32, -8);
pub const NTMS_OBJECTNAME_LENGTH = @as(u32, 64);
pub const NTMS_DESCRIPTION_LENGTH = @as(u32, 127);
pub const NTMS_DEVICENAME_LENGTH = @as(u32, 64);
pub const NTMS_SERIALNUMBER_LENGTH = @as(u32, 32);
pub const NTMS_REVISION_LENGTH = @as(u32, 32);
pub const NTMS_BARCODE_LENGTH = @as(u32, 64);
pub const NTMS_SEQUENCE_LENGTH = @as(u32, 32);
pub const NTMS_VENDORNAME_LENGTH = @as(u32, 128);
pub const NTMS_PRODUCTNAME_LENGTH = @as(u32, 128);
pub const NTMS_USERNAME_LENGTH = @as(u32, 64);
pub const NTMS_APPLICATIONNAME_LENGTH = @as(u32, 64);
pub const NTMS_COMPUTERNAME_LENGTH = @as(u32, 64);
pub const NTMS_I1_MESSAGE_LENGTH = @as(u32, 127);
pub const NTMS_MESSAGE_LENGTH = @as(u32, 256);
pub const NTMS_POOLHIERARCHY_LENGTH = @as(u32, 512);
pub const NTMS_OMIDLABELID_LENGTH = @as(u32, 255);
pub const NTMS_OMIDLABELTYPE_LENGTH = @as(u32, 64);
pub const NTMS_OMIDLABELINFO_LENGTH = @as(u32, 256);
pub const NTMS_MAXATTR_LENGTH = @as(u32, 65536);
pub const NTMS_MAXATTR_NAMELEN = @as(u32, 32);
pub const NTMSMLI_MAXTYPE = @as(u32, 64);
pub const NTMSMLI_MAXIDSIZE = @as(u32, 256);
pub const NTMSMLI_MAXAPPDESCR = @as(u32, 256);
pub const TXF_LOG_RECORD_GENERIC_TYPE_COMMIT = @as(u32, 1);
pub const TXF_LOG_RECORD_GENERIC_TYPE_ABORT = @as(u32, 2);
pub const TXF_LOG_RECORD_GENERIC_TYPE_PREPARE = @as(u32, 4);
pub const TXF_LOG_RECORD_GENERIC_TYPE_DATA = @as(u32, 8);
pub const VS_VERSION_INFO = @as(u32, 1);
pub const VS_USER_DEFINED = @as(u32, 100);
pub const VS_FFI_SIGNATURE = @as(i32, -17890115);
pub const VS_FFI_STRUCVERSION = @as(i32, 65536);
pub const VS_FFI_FILEFLAGSMASK = @as(i32, 63);
pub const WINEFS_SETUSERKEY_SET_CAPABILITIES = @as(u32, 1);
pub const EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR = @as(u32, 5);
pub const EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR = @as(u32, 6);
pub const EFS_SUBVER_UNKNOWN = @as(u32, 0);
pub const EFS_EFS_SUBVER_EFS_CERT = @as(u32, 1);
pub const EFS_PFILE_SUBVER_RMS = @as(u32, 2);
pub const EFS_PFILE_SUBVER_APPX = @as(u32, 3);
pub const MAX_SID_SIZE = @as(u32, 256);
pub const EFS_METADATA_ADD_USER = @as(u32, 1);
pub const EFS_METADATA_REMOVE_USER = @as(u32, 2);
pub const EFS_METADATA_REPLACE_USER = @as(u32, 4);
pub const EFS_METADATA_GENERAL_OP = @as(u32, 8);
pub const WOF_PROVIDER_WIM = @as(u32, 1);
pub const WOF_PROVIDER_FILE = @as(u32, 2);
pub const WIM_PROVIDER_HASH_SIZE = @as(u32, 20);
pub const WIM_BOOT_OS_WIM = @as(u32, 1);
pub const WIM_BOOT_NOT_OS_WIM = @as(u32, 0);
pub const WIM_ENTRY_FLAG_NOT_ACTIVE = @as(u32, 1);
pub const WIM_ENTRY_FLAG_SUSPENDED = @as(u32, 2);
pub const WIM_EXTERNAL_FILE_INFO_FLAG_NOT_ACTIVE = @as(u32, 1);
pub const WIM_EXTERNAL_FILE_INFO_FLAG_SUSPENDED = @as(u32, 2);
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K = @as(u32, 0);
pub const FILE_PROVIDER_COMPRESSION_LZX = @as(u32, 1);
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K = @as(u32, 2);
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K = @as(u32, 3);
pub const ClfsNullRecord = @as(u8, 0);
pub const ClfsDataRecord = @as(u8, 1);
pub const ClfsRestartRecord = @as(u8, 2);
pub const ClfsClientRecord = @as(u8, 3);
pub const ClsContainerInitializing = @as(u32, 1);
pub const ClsContainerInactive = @as(u32, 2);
pub const ClsContainerActive = @as(u32, 4);
pub const ClsContainerActivePendingDelete = @as(u32, 8);
pub const ClsContainerPendingArchive = @as(u32, 16);
pub const ClsContainerPendingArchiveAndDelete = @as(u32, 32);
pub const ClfsContainerInitializing = @as(u32, 1);
pub const ClfsContainerInactive = @as(u32, 2);
pub const ClfsContainerActive = @as(u32, 4);
pub const ClfsContainerActivePendingDelete = @as(u32, 8);
pub const ClfsContainerPendingArchive = @as(u32, 16);
pub const ClfsContainerPendingArchiveAndDelete = @as(u32, 32);
pub const CLFS_MAX_CONTAINER_INFO = @as(u32, 256);
pub const CLFS_SCAN_INIT = @as(u8, 1);
pub const CLFS_SCAN_FORWARD = @as(u8, 2);
pub const CLFS_SCAN_BACKWARD = @as(u8, 4);
pub const CLFS_SCAN_CLOSE = @as(u8, 8);
pub const CLFS_SCAN_INITIALIZED = @as(u8, 16);
pub const CLFS_SCAN_BUFFERED = @as(u8, 32);

//--------------------------------------------------------------------------------
// Section: Types (336)
//--------------------------------------------------------------------------------
pub const FIND_FIRST_EX_FLAGS = enum(u32) {
    CASE_SENSITIVE = 1,
    LARGE_FETCH = 2,
    ON_DISK_ENTRIES_ONLY = 4,
    _,
    pub fn initFlags(o: struct {
        CASE_SENSITIVE: u1 = 0,
        LARGE_FETCH: u1 = 0,
        ON_DISK_ENTRIES_ONLY: u1 = 0,
    }) FIND_FIRST_EX_FLAGS {
        return @as(FIND_FIRST_EX_FLAGS, @enumFromInt((if (o.CASE_SENSITIVE == 1) @intFromEnum(FIND_FIRST_EX_FLAGS.CASE_SENSITIVE) else 0) | (if (o.LARGE_FETCH == 1) @intFromEnum(FIND_FIRST_EX_FLAGS.LARGE_FETCH) else 0) | (if (o.ON_DISK_ENTRIES_ONLY == 1) @intFromEnum(FIND_FIRST_EX_FLAGS.ON_DISK_ENTRIES_ONLY) else 0)));
    }
};
pub const FIND_FIRST_EX_CASE_SENSITIVE = FIND_FIRST_EX_FLAGS.CASE_SENSITIVE;
pub const FIND_FIRST_EX_LARGE_FETCH = FIND_FIRST_EX_FLAGS.LARGE_FETCH;
pub const FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY = FIND_FIRST_EX_FLAGS.ON_DISK_ENTRIES_ONLY;

pub const DEFINE_DOS_DEVICE_FLAGS = enum(u32) {
    RAW_TARGET_PATH = 1,
    REMOVE_DEFINITION = 2,
    EXACT_MATCH_ON_REMOVE = 4,
    NO_BROADCAST_SYSTEM = 8,
    LUID_BROADCAST_DRIVE = 16,
    _,
    pub fn initFlags(o: struct {
        RAW_TARGET_PATH: u1 = 0,
        REMOVE_DEFINITION: u1 = 0,
        EXACT_MATCH_ON_REMOVE: u1 = 0,
        NO_BROADCAST_SYSTEM: u1 = 0,
        LUID_BROADCAST_DRIVE: u1 = 0,
    }) DEFINE_DOS_DEVICE_FLAGS {
        return @as(DEFINE_DOS_DEVICE_FLAGS, @enumFromInt((if (o.RAW_TARGET_PATH == 1) @intFromEnum(DEFINE_DOS_DEVICE_FLAGS.RAW_TARGET_PATH) else 0) | (if (o.REMOVE_DEFINITION == 1) @intFromEnum(DEFINE_DOS_DEVICE_FLAGS.REMOVE_DEFINITION) else 0) | (if (o.EXACT_MATCH_ON_REMOVE == 1) @intFromEnum(DEFINE_DOS_DEVICE_FLAGS.EXACT_MATCH_ON_REMOVE) else 0) | (if (o.NO_BROADCAST_SYSTEM == 1) @intFromEnum(DEFINE_DOS_DEVICE_FLAGS.NO_BROADCAST_SYSTEM) else 0) | (if (o.LUID_BROADCAST_DRIVE == 1) @intFromEnum(DEFINE_DOS_DEVICE_FLAGS.LUID_BROADCAST_DRIVE) else 0)));
    }
};
pub const DDD_RAW_TARGET_PATH = DEFINE_DOS_DEVICE_FLAGS.RAW_TARGET_PATH;
pub const DDD_REMOVE_DEFINITION = DEFINE_DOS_DEVICE_FLAGS.REMOVE_DEFINITION;
pub const DDD_EXACT_MATCH_ON_REMOVE = DEFINE_DOS_DEVICE_FLAGS.EXACT_MATCH_ON_REMOVE;
pub const DDD_NO_BROADCAST_SYSTEM = DEFINE_DOS_DEVICE_FLAGS.NO_BROADCAST_SYSTEM;
pub const DDD_LUID_BROADCAST_DRIVE = DEFINE_DOS_DEVICE_FLAGS.LUID_BROADCAST_DRIVE;

pub const FILE_FLAGS_AND_ATTRIBUTES = enum(u32) {
    FILE_ATTRIBUTE_READONLY = 1,
    FILE_ATTRIBUTE_HIDDEN = 2,
    FILE_ATTRIBUTE_SYSTEM = 4,
    FILE_ATTRIBUTE_DIRECTORY = 16,
    FILE_ATTRIBUTE_ARCHIVE = 32,
    FILE_ATTRIBUTE_DEVICE = 64,
    FILE_ATTRIBUTE_NORMAL = 128,
    FILE_ATTRIBUTE_TEMPORARY = 256,
    FILE_ATTRIBUTE_SPARSE_FILE = 512,
    FILE_ATTRIBUTE_REPARSE_POINT = 1024,
    FILE_ATTRIBUTE_COMPRESSED = 2048,
    FILE_ATTRIBUTE_OFFLINE = 4096,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192,
    FILE_ATTRIBUTE_ENCRYPTED = 16384,
    FILE_ATTRIBUTE_INTEGRITY_STREAM = 32768,
    FILE_ATTRIBUTE_VIRTUAL = 65536,
    FILE_ATTRIBUTE_NO_SCRUB_DATA = 131072,
    FILE_ATTRIBUTE_EA = 262144,
    FILE_ATTRIBUTE_PINNED = 524288,
    FILE_ATTRIBUTE_UNPINNED = 1048576,
    // FILE_ATTRIBUTE_RECALL_ON_OPEN = 262144, this enum value conflicts with FILE_ATTRIBUTE_EA
    FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 4194304,
    FILE_FLAG_WRITE_THROUGH = 2147483648,
    FILE_FLAG_OVERLAPPED = 1073741824,
    FILE_FLAG_NO_BUFFERING = 536870912,
    FILE_FLAG_RANDOM_ACCESS = 268435456,
    FILE_FLAG_SEQUENTIAL_SCAN = 134217728,
    FILE_FLAG_DELETE_ON_CLOSE = 67108864,
    FILE_FLAG_BACKUP_SEMANTICS = 33554432,
    FILE_FLAG_POSIX_SEMANTICS = 16777216,
    FILE_FLAG_SESSION_AWARE = 8388608,
    FILE_FLAG_OPEN_REPARSE_POINT = 2097152,
    // FILE_FLAG_OPEN_NO_RECALL = 1048576, this enum value conflicts with FILE_ATTRIBUTE_UNPINNED
    // FILE_FLAG_FIRST_PIPE_INSTANCE = 524288, this enum value conflicts with FILE_ATTRIBUTE_PINNED
    PIPE_ACCESS_DUPLEX = 3,
    // PIPE_ACCESS_INBOUND = 1, this enum value conflicts with FILE_ATTRIBUTE_READONLY
    // PIPE_ACCESS_OUTBOUND = 2, this enum value conflicts with FILE_ATTRIBUTE_HIDDEN
    SECURITY_ANONYMOUS = 0,
    // SECURITY_IDENTIFICATION = 65536, this enum value conflicts with FILE_ATTRIBUTE_VIRTUAL
    // SECURITY_IMPERSONATION = 131072, this enum value conflicts with FILE_ATTRIBUTE_NO_SCRUB_DATA
    SECURITY_DELEGATION = 196608,
    // SECURITY_CONTEXT_TRACKING = 262144, this enum value conflicts with FILE_ATTRIBUTE_EA
    // SECURITY_EFFECTIVE_ONLY = 524288, this enum value conflicts with FILE_ATTRIBUTE_PINNED
    // SECURITY_SQOS_PRESENT = 1048576, this enum value conflicts with FILE_ATTRIBUTE_UNPINNED
    SECURITY_VALID_SQOS_FLAGS = 2031616,
    _,
    pub fn initFlags(o: struct {
        FILE_ATTRIBUTE_READONLY: u1 = 0,
        FILE_ATTRIBUTE_HIDDEN: u1 = 0,
        FILE_ATTRIBUTE_SYSTEM: u1 = 0,
        FILE_ATTRIBUTE_DIRECTORY: u1 = 0,
        FILE_ATTRIBUTE_ARCHIVE: u1 = 0,
        FILE_ATTRIBUTE_DEVICE: u1 = 0,
        FILE_ATTRIBUTE_NORMAL: u1 = 0,
        FILE_ATTRIBUTE_TEMPORARY: u1 = 0,
        FILE_ATTRIBUTE_SPARSE_FILE: u1 = 0,
        FILE_ATTRIBUTE_REPARSE_POINT: u1 = 0,
        FILE_ATTRIBUTE_COMPRESSED: u1 = 0,
        FILE_ATTRIBUTE_OFFLINE: u1 = 0,
        FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u1 = 0,
        FILE_ATTRIBUTE_ENCRYPTED: u1 = 0,
        FILE_ATTRIBUTE_INTEGRITY_STREAM: u1 = 0,
        FILE_ATTRIBUTE_VIRTUAL: u1 = 0,
        FILE_ATTRIBUTE_NO_SCRUB_DATA: u1 = 0,
        FILE_ATTRIBUTE_EA: u1 = 0,
        FILE_ATTRIBUTE_PINNED: u1 = 0,
        FILE_ATTRIBUTE_UNPINNED: u1 = 0,
        FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u1 = 0,
        FILE_FLAG_WRITE_THROUGH: u1 = 0,
        FILE_FLAG_OVERLAPPED: u1 = 0,
        FILE_FLAG_NO_BUFFERING: u1 = 0,
        FILE_FLAG_RANDOM_ACCESS: u1 = 0,
        FILE_FLAG_SEQUENTIAL_SCAN: u1 = 0,
        FILE_FLAG_DELETE_ON_CLOSE: u1 = 0,
        FILE_FLAG_BACKUP_SEMANTICS: u1 = 0,
        FILE_FLAG_POSIX_SEMANTICS: u1 = 0,
        FILE_FLAG_SESSION_AWARE: u1 = 0,
        FILE_FLAG_OPEN_REPARSE_POINT: u1 = 0,
        PIPE_ACCESS_DUPLEX: u1 = 0,
        SECURITY_ANONYMOUS: u1 = 0,
        SECURITY_DELEGATION: u1 = 0,
        SECURITY_VALID_SQOS_FLAGS: u1 = 0,
    }) FILE_FLAGS_AND_ATTRIBUTES {
        return @as(FILE_FLAGS_AND_ATTRIBUTES, @enumFromInt((if (o.FILE_ATTRIBUTE_READONLY == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_READONLY) else 0) | (if (o.FILE_ATTRIBUTE_HIDDEN == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_HIDDEN) else 0) | (if (o.FILE_ATTRIBUTE_SYSTEM == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SYSTEM) else 0) | (if (o.FILE_ATTRIBUTE_DIRECTORY == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DIRECTORY) else 0) | (if (o.FILE_ATTRIBUTE_ARCHIVE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ARCHIVE) else 0) | (if (o.FILE_ATTRIBUTE_DEVICE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DEVICE) else 0) | (if (o.FILE_ATTRIBUTE_NORMAL == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL) else 0) | (if (o.FILE_ATTRIBUTE_TEMPORARY == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_TEMPORARY) else 0) | (if (o.FILE_ATTRIBUTE_SPARSE_FILE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SPARSE_FILE) else 0) | (if (o.FILE_ATTRIBUTE_REPARSE_POINT == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_REPARSE_POINT) else 0) | (if (o.FILE_ATTRIBUTE_COMPRESSED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_COMPRESSED) else 0) | (if (o.FILE_ATTRIBUTE_OFFLINE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_OFFLINE) else 0) | (if (o.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) else 0) | (if (o.FILE_ATTRIBUTE_ENCRYPTED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ENCRYPTED) else 0) | (if (o.FILE_ATTRIBUTE_INTEGRITY_STREAM == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_INTEGRITY_STREAM) else 0) | (if (o.FILE_ATTRIBUTE_VIRTUAL == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_VIRTUAL) else 0) | (if (o.FILE_ATTRIBUTE_NO_SCRUB_DATA == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NO_SCRUB_DATA) else 0) | (if (o.FILE_ATTRIBUTE_EA == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_EA) else 0) | (if (o.FILE_ATTRIBUTE_PINNED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_PINNED) else 0) | (if (o.FILE_ATTRIBUTE_UNPINNED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_UNPINNED) else 0) | (if (o.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS) else 0) | (if (o.FILE_FLAG_WRITE_THROUGH == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_WRITE_THROUGH) else 0) | (if (o.FILE_FLAG_OVERLAPPED == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OVERLAPPED) else 0) | (if (o.FILE_FLAG_NO_BUFFERING == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_NO_BUFFERING) else 0) | (if (o.FILE_FLAG_RANDOM_ACCESS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_RANDOM_ACCESS) else 0) | (if (o.FILE_FLAG_SEQUENTIAL_SCAN == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SEQUENTIAL_SCAN) else 0) | (if (o.FILE_FLAG_DELETE_ON_CLOSE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_DELETE_ON_CLOSE) else 0) | (if (o.FILE_FLAG_BACKUP_SEMANTICS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_BACKUP_SEMANTICS) else 0) | (if (o.FILE_FLAG_POSIX_SEMANTICS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_POSIX_SEMANTICS) else 0) | (if (o.FILE_FLAG_SESSION_AWARE == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SESSION_AWARE) else 0) | (if (o.FILE_FLAG_OPEN_REPARSE_POINT == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OPEN_REPARSE_POINT) else 0) | (if (o.PIPE_ACCESS_DUPLEX == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.PIPE_ACCESS_DUPLEX) else 0) | (if (o.SECURITY_ANONYMOUS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.SECURITY_ANONYMOUS) else 0) | (if (o.SECURITY_DELEGATION == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.SECURITY_DELEGATION) else 0) | (if (o.SECURITY_VALID_SQOS_FLAGS == 1) @intFromEnum(FILE_FLAGS_AND_ATTRIBUTES.SECURITY_VALID_SQOS_FLAGS) else 0)));
    }
};
pub const FILE_ATTRIBUTE_READONLY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_READONLY;
pub const FILE_ATTRIBUTE_HIDDEN = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_HIDDEN;
pub const FILE_ATTRIBUTE_SYSTEM = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SYSTEM;
pub const FILE_ATTRIBUTE_DIRECTORY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DIRECTORY;
pub const FILE_ATTRIBUTE_ARCHIVE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ARCHIVE;
pub const FILE_ATTRIBUTE_DEVICE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DEVICE;
pub const FILE_ATTRIBUTE_NORMAL = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL;
pub const FILE_ATTRIBUTE_TEMPORARY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_TEMPORARY;
pub const FILE_ATTRIBUTE_SPARSE_FILE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SPARSE_FILE;
pub const FILE_ATTRIBUTE_REPARSE_POINT = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_REPARSE_POINT;
pub const FILE_ATTRIBUTE_COMPRESSED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_COMPRESSED;
pub const FILE_ATTRIBUTE_OFFLINE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_OFFLINE;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
pub const FILE_ATTRIBUTE_ENCRYPTED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ENCRYPTED;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_INTEGRITY_STREAM;
pub const FILE_ATTRIBUTE_VIRTUAL = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_VIRTUAL;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NO_SCRUB_DATA;
pub const FILE_ATTRIBUTE_EA = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_EA;
pub const FILE_ATTRIBUTE_PINNED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_PINNED;
pub const FILE_ATTRIBUTE_UNPINNED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_UNPINNED;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_EA;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
pub const FILE_FLAG_WRITE_THROUGH = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_WRITE_THROUGH;
pub const FILE_FLAG_OVERLAPPED = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OVERLAPPED;
pub const FILE_FLAG_NO_BUFFERING = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_NO_BUFFERING;
pub const FILE_FLAG_RANDOM_ACCESS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_RANDOM_ACCESS;
pub const FILE_FLAG_SEQUENTIAL_SCAN = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SEQUENTIAL_SCAN;
pub const FILE_FLAG_DELETE_ON_CLOSE = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_DELETE_ON_CLOSE;
pub const FILE_FLAG_BACKUP_SEMANTICS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_BACKUP_SEMANTICS;
pub const FILE_FLAG_POSIX_SEMANTICS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_POSIX_SEMANTICS;
pub const FILE_FLAG_SESSION_AWARE = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SESSION_AWARE;
pub const FILE_FLAG_OPEN_REPARSE_POINT = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OPEN_REPARSE_POINT;
pub const FILE_FLAG_OPEN_NO_RECALL = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_UNPINNED;
pub const FILE_FLAG_FIRST_PIPE_INSTANCE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_PINNED;
pub const PIPE_ACCESS_DUPLEX = FILE_FLAGS_AND_ATTRIBUTES.PIPE_ACCESS_DUPLEX;
pub const PIPE_ACCESS_INBOUND = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_READONLY;
pub const PIPE_ACCESS_OUTBOUND = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_HIDDEN;
pub const SECURITY_ANONYMOUS = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_ANONYMOUS;
pub const SECURITY_IDENTIFICATION = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_VIRTUAL;
pub const SECURITY_IMPERSONATION = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NO_SCRUB_DATA;
pub const SECURITY_DELEGATION = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_DELEGATION;
pub const SECURITY_CONTEXT_TRACKING = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_EA;
pub const SECURITY_EFFECTIVE_ONLY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_PINNED;
pub const SECURITY_SQOS_PRESENT = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_UNPINNED;
pub const SECURITY_VALID_SQOS_FLAGS = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_VALID_SQOS_FLAGS;

pub const FILE_ACCESS_FLAGS = enum(u32) {
    FILE_READ_DATA = 1,
    // FILE_LIST_DIRECTORY = 1, this enum value conflicts with FILE_READ_DATA
    FILE_WRITE_DATA = 2,
    // FILE_ADD_FILE = 2, this enum value conflicts with FILE_WRITE_DATA
    FILE_APPEND_DATA = 4,
    // FILE_ADD_SUBDIRECTORY = 4, this enum value conflicts with FILE_APPEND_DATA
    // FILE_CREATE_PIPE_INSTANCE = 4, this enum value conflicts with FILE_APPEND_DATA
    FILE_READ_EA = 8,
    FILE_WRITE_EA = 16,
    FILE_EXECUTE = 32,
    // FILE_TRAVERSE = 32, this enum value conflicts with FILE_EXECUTE
    FILE_DELETE_CHILD = 64,
    FILE_READ_ATTRIBUTES = 128,
    FILE_WRITE_ATTRIBUTES = 256,
    READ_CONTROL = 131072,
    SYNCHRONIZE = 1048576,
    STANDARD_RIGHTS_REQUIRED = 983040,
    // STANDARD_RIGHTS_READ = 131072, this enum value conflicts with READ_CONTROL
    // STANDARD_RIGHTS_WRITE = 131072, this enum value conflicts with READ_CONTROL
    // STANDARD_RIGHTS_EXECUTE = 131072, this enum value conflicts with READ_CONTROL
    STANDARD_RIGHTS_ALL = 2031616,
    SPECIFIC_RIGHTS_ALL = 65535,
    FILE_ALL_ACCESS = 2032127,
    FILE_GENERIC_READ = 1179785,
    FILE_GENERIC_WRITE = 1179926,
    FILE_GENERIC_EXECUTE = 1179808,
    _,
    pub fn initFlags(o: struct {
        FILE_READ_DATA: u1 = 0,
        FILE_WRITE_DATA: u1 = 0,
        FILE_APPEND_DATA: u1 = 0,
        FILE_READ_EA: u1 = 0,
        FILE_WRITE_EA: u1 = 0,
        FILE_EXECUTE: u1 = 0,
        FILE_DELETE_CHILD: u1 = 0,
        FILE_READ_ATTRIBUTES: u1 = 0,
        FILE_WRITE_ATTRIBUTES: u1 = 0,
        READ_CONTROL: u1 = 0,
        SYNCHRONIZE: u1 = 0,
        STANDARD_RIGHTS_REQUIRED: u1 = 0,
        STANDARD_RIGHTS_ALL: u1 = 0,
        SPECIFIC_RIGHTS_ALL: u1 = 0,
        FILE_ALL_ACCESS: u1 = 0,
        FILE_GENERIC_READ: u1 = 0,
        FILE_GENERIC_WRITE: u1 = 0,
        FILE_GENERIC_EXECUTE: u1 = 0,
    }) FILE_ACCESS_FLAGS {
        return @as(FILE_ACCESS_FLAGS, @enumFromInt((if (o.FILE_READ_DATA == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_READ_DATA) else 0) | (if (o.FILE_WRITE_DATA == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_WRITE_DATA) else 0) | (if (o.FILE_APPEND_DATA == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_APPEND_DATA) else 0) | (if (o.FILE_READ_EA == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_READ_EA) else 0) | (if (o.FILE_WRITE_EA == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_WRITE_EA) else 0) | (if (o.FILE_EXECUTE == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_EXECUTE) else 0) | (if (o.FILE_DELETE_CHILD == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_DELETE_CHILD) else 0) | (if (o.FILE_READ_ATTRIBUTES == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_READ_ATTRIBUTES) else 0) | (if (o.FILE_WRITE_ATTRIBUTES == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_WRITE_ATTRIBUTES) else 0) | (if (o.READ_CONTROL == 1) @intFromEnum(FILE_ACCESS_FLAGS.READ_CONTROL) else 0) | (if (o.SYNCHRONIZE == 1) @intFromEnum(FILE_ACCESS_FLAGS.SYNCHRONIZE) else 0) | (if (o.STANDARD_RIGHTS_REQUIRED == 1) @intFromEnum(FILE_ACCESS_FLAGS.STANDARD_RIGHTS_REQUIRED) else 0) | (if (o.STANDARD_RIGHTS_ALL == 1) @intFromEnum(FILE_ACCESS_FLAGS.STANDARD_RIGHTS_ALL) else 0) | (if (o.SPECIFIC_RIGHTS_ALL == 1) @intFromEnum(FILE_ACCESS_FLAGS.SPECIFIC_RIGHTS_ALL) else 0) | (if (o.FILE_ALL_ACCESS == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_ALL_ACCESS) else 0) | (if (o.FILE_GENERIC_READ == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_GENERIC_READ) else 0) | (if (o.FILE_GENERIC_WRITE == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_GENERIC_WRITE) else 0) | (if (o.FILE_GENERIC_EXECUTE == 1) @intFromEnum(FILE_ACCESS_FLAGS.FILE_GENERIC_EXECUTE) else 0)));
    }
};
pub const FILE_READ_DATA = FILE_ACCESS_FLAGS.FILE_READ_DATA;
pub const FILE_LIST_DIRECTORY = FILE_ACCESS_FLAGS.FILE_READ_DATA;
pub const FILE_WRITE_DATA = FILE_ACCESS_FLAGS.FILE_WRITE_DATA;
pub const FILE_ADD_FILE = FILE_ACCESS_FLAGS.FILE_WRITE_DATA;
pub const FILE_APPEND_DATA = FILE_ACCESS_FLAGS.FILE_APPEND_DATA;
pub const FILE_ADD_SUBDIRECTORY = FILE_ACCESS_FLAGS.FILE_APPEND_DATA;
pub const FILE_CREATE_PIPE_INSTANCE = FILE_ACCESS_FLAGS.FILE_APPEND_DATA;
pub const FILE_READ_EA = FILE_ACCESS_FLAGS.FILE_READ_EA;
pub const FILE_WRITE_EA = FILE_ACCESS_FLAGS.FILE_WRITE_EA;
pub const FILE_EXECUTE = FILE_ACCESS_FLAGS.FILE_EXECUTE;
pub const FILE_TRAVERSE = FILE_ACCESS_FLAGS.FILE_EXECUTE;
pub const FILE_DELETE_CHILD = FILE_ACCESS_FLAGS.FILE_DELETE_CHILD;
pub const FILE_READ_ATTRIBUTES = FILE_ACCESS_FLAGS.FILE_READ_ATTRIBUTES;
pub const FILE_WRITE_ATTRIBUTES = FILE_ACCESS_FLAGS.FILE_WRITE_ATTRIBUTES;
pub const READ_CONTROL = FILE_ACCESS_FLAGS.READ_CONTROL;
pub const SYNCHRONIZE = FILE_ACCESS_FLAGS.SYNCHRONIZE;
pub const STANDARD_RIGHTS_REQUIRED = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_REQUIRED;
pub const STANDARD_RIGHTS_READ = FILE_ACCESS_FLAGS.READ_CONTROL;
pub const STANDARD_RIGHTS_WRITE = FILE_ACCESS_FLAGS.READ_CONTROL;
pub const STANDARD_RIGHTS_EXECUTE = FILE_ACCESS_FLAGS.READ_CONTROL;
pub const STANDARD_RIGHTS_ALL = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_ALL;
pub const SPECIFIC_RIGHTS_ALL = FILE_ACCESS_FLAGS.SPECIFIC_RIGHTS_ALL;
pub const FILE_ALL_ACCESS = FILE_ACCESS_FLAGS.FILE_ALL_ACCESS;
pub const FILE_GENERIC_READ = FILE_ACCESS_FLAGS.FILE_GENERIC_READ;
pub const FILE_GENERIC_WRITE = FILE_ACCESS_FLAGS.FILE_GENERIC_WRITE;
pub const FILE_GENERIC_EXECUTE = FILE_ACCESS_FLAGS.FILE_GENERIC_EXECUTE;

pub const GET_FILE_VERSION_INFO_FLAGS = enum(u32) {
    LOCALISED = 1,
    NEUTRAL = 2,
    PREFETCHED = 4,
    _,
    pub fn initFlags(o: struct {
        LOCALISED: u1 = 0,
        NEUTRAL: u1 = 0,
        PREFETCHED: u1 = 0,
    }) GET_FILE_VERSION_INFO_FLAGS {
        return @as(GET_FILE_VERSION_INFO_FLAGS, @enumFromInt((if (o.LOCALISED == 1) @intFromEnum(GET_FILE_VERSION_INFO_FLAGS.LOCALISED) else 0) | (if (o.NEUTRAL == 1) @intFromEnum(GET_FILE_VERSION_INFO_FLAGS.NEUTRAL) else 0) | (if (o.PREFETCHED == 1) @intFromEnum(GET_FILE_VERSION_INFO_FLAGS.PREFETCHED) else 0)));
    }
};
pub const FILE_VER_GET_LOCALISED = GET_FILE_VERSION_INFO_FLAGS.LOCALISED;
pub const FILE_VER_GET_NEUTRAL = GET_FILE_VERSION_INFO_FLAGS.NEUTRAL;
pub const FILE_VER_GET_PREFETCHED = GET_FILE_VERSION_INFO_FLAGS.PREFETCHED;

pub const VER_FIND_FILE_FLAGS = enum(u32) {
    E = 1,
};
pub const VFFF_ISSHAREDFILE = VER_FIND_FILE_FLAGS.E;

pub const VER_FIND_FILE_STATUS = enum(u32) {
    CURNEDEST = 1,
    FILEINUSE = 2,
    BUFFTOOSMALL = 4,
    _,
    pub fn initFlags(o: struct {
        CURNEDEST: u1 = 0,
        FILEINUSE: u1 = 0,
        BUFFTOOSMALL: u1 = 0,
    }) VER_FIND_FILE_STATUS {
        return @as(VER_FIND_FILE_STATUS, @enumFromInt((if (o.CURNEDEST == 1) @intFromEnum(VER_FIND_FILE_STATUS.CURNEDEST) else 0) | (if (o.FILEINUSE == 1) @intFromEnum(VER_FIND_FILE_STATUS.FILEINUSE) else 0) | (if (o.BUFFTOOSMALL == 1) @intFromEnum(VER_FIND_FILE_STATUS.BUFFTOOSMALL) else 0)));
    }
};
pub const VFF_CURNEDEST = VER_FIND_FILE_STATUS.CURNEDEST;
pub const VFF_FILEINUSE = VER_FIND_FILE_STATUS.FILEINUSE;
pub const VFF_BUFFTOOSMALL = VER_FIND_FILE_STATUS.BUFFTOOSMALL;

pub const VER_INSTALL_FILE_FLAGS = enum(u32) {
    FORCEINSTALL = 1,
    DONTDELETEOLD = 2,
};
pub const VIFF_FORCEINSTALL = VER_INSTALL_FILE_FLAGS.FORCEINSTALL;
pub const VIFF_DONTDELETEOLD = VER_INSTALL_FILE_FLAGS.DONTDELETEOLD;

pub const VER_INSTALL_FILE_STATUS = enum(u32) {
    TEMPFILE = 1,
    MISMATCH = 2,
    SRCOLD = 4,
    DIFFLANG = 8,
    DIFFCODEPG = 16,
    DIFFTYPE = 32,
    WRITEPROT = 64,
    FILEINUSE = 128,
    OUTOFSPACE = 256,
    ACCESSVIOLATION = 512,
    SHARINGVIOLATION = 1024,
    CANNOTCREATE = 2048,
    CANNOTDELETE = 4096,
    CANNOTRENAME = 8192,
    CANNOTDELETECUR = 16384,
    OUTOFMEMORY = 32768,
    CANNOTREADSRC = 65536,
    CANNOTREADDST = 131072,
    BUFFTOOSMALL = 262144,
    CANNOTLOADLZ32 = 524288,
    CANNOTLOADCABINET = 1048576,
    _,
    pub fn initFlags(o: struct {
        TEMPFILE: u1 = 0,
        MISMATCH: u1 = 0,
        SRCOLD: u1 = 0,
        DIFFLANG: u1 = 0,
        DIFFCODEPG: u1 = 0,
        DIFFTYPE: u1 = 0,
        WRITEPROT: u1 = 0,
        FILEINUSE: u1 = 0,
        OUTOFSPACE: u1 = 0,
        ACCESSVIOLATION: u1 = 0,
        SHARINGVIOLATION: u1 = 0,
        CANNOTCREATE: u1 = 0,
        CANNOTDELETE: u1 = 0,
        CANNOTRENAME: u1 = 0,
        CANNOTDELETECUR: u1 = 0,
        OUTOFMEMORY: u1 = 0,
        CANNOTREADSRC: u1 = 0,
        CANNOTREADDST: u1 = 0,
        BUFFTOOSMALL: u1 = 0,
        CANNOTLOADLZ32: u1 = 0,
        CANNOTLOADCABINET: u1 = 0,
    }) VER_INSTALL_FILE_STATUS {
        return @as(VER_INSTALL_FILE_STATUS, @enumFromInt((if (o.TEMPFILE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.TEMPFILE) else 0) | (if (o.MISMATCH == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.MISMATCH) else 0) | (if (o.SRCOLD == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.SRCOLD) else 0) | (if (o.DIFFLANG == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.DIFFLANG) else 0) | (if (o.DIFFCODEPG == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.DIFFCODEPG) else 0) | (if (o.DIFFTYPE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.DIFFTYPE) else 0) | (if (o.WRITEPROT == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.WRITEPROT) else 0) | (if (o.FILEINUSE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.FILEINUSE) else 0) | (if (o.OUTOFSPACE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.OUTOFSPACE) else 0) | (if (o.ACCESSVIOLATION == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.ACCESSVIOLATION) else 0) | (if (o.SHARINGVIOLATION == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.SHARINGVIOLATION) else 0) | (if (o.CANNOTCREATE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTCREATE) else 0) | (if (o.CANNOTDELETE == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTDELETE) else 0) | (if (o.CANNOTRENAME == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTRENAME) else 0) | (if (o.CANNOTDELETECUR == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTDELETECUR) else 0) | (if (o.OUTOFMEMORY == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.OUTOFMEMORY) else 0) | (if (o.CANNOTREADSRC == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTREADSRC) else 0) | (if (o.CANNOTREADDST == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTREADDST) else 0) | (if (o.BUFFTOOSMALL == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.BUFFTOOSMALL) else 0) | (if (o.CANNOTLOADLZ32 == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTLOADLZ32) else 0) | (if (o.CANNOTLOADCABINET == 1) @intFromEnum(VER_INSTALL_FILE_STATUS.CANNOTLOADCABINET) else 0)));
    }
};
pub const VIF_TEMPFILE = VER_INSTALL_FILE_STATUS.TEMPFILE;
pub const VIF_MISMATCH = VER_INSTALL_FILE_STATUS.MISMATCH;
pub const VIF_SRCOLD = VER_INSTALL_FILE_STATUS.SRCOLD;
pub const VIF_DIFFLANG = VER_INSTALL_FILE_STATUS.DIFFLANG;
pub const VIF_DIFFCODEPG = VER_INSTALL_FILE_STATUS.DIFFCODEPG;
pub const VIF_DIFFTYPE = VER_INSTALL_FILE_STATUS.DIFFTYPE;
pub const VIF_WRITEPROT = VER_INSTALL_FILE_STATUS.WRITEPROT;
pub const VIF_FILEINUSE = VER_INSTALL_FILE_STATUS.FILEINUSE;
pub const VIF_OUTOFSPACE = VER_INSTALL_FILE_STATUS.OUTOFSPACE;
pub const VIF_ACCESSVIOLATION = VER_INSTALL_FILE_STATUS.ACCESSVIOLATION;
pub const VIF_SHARINGVIOLATION = VER_INSTALL_FILE_STATUS.SHARINGVIOLATION;
pub const VIF_CANNOTCREATE = VER_INSTALL_FILE_STATUS.CANNOTCREATE;
pub const VIF_CANNOTDELETE = VER_INSTALL_FILE_STATUS.CANNOTDELETE;
pub const VIF_CANNOTRENAME = VER_INSTALL_FILE_STATUS.CANNOTRENAME;
pub const VIF_CANNOTDELETECUR = VER_INSTALL_FILE_STATUS.CANNOTDELETECUR;
pub const VIF_OUTOFMEMORY = VER_INSTALL_FILE_STATUS.OUTOFMEMORY;
pub const VIF_CANNOTREADSRC = VER_INSTALL_FILE_STATUS.CANNOTREADSRC;
pub const VIF_CANNOTREADDST = VER_INSTALL_FILE_STATUS.CANNOTREADDST;
pub const VIF_BUFFTOOSMALL = VER_INSTALL_FILE_STATUS.BUFFTOOSMALL;
pub const VIF_CANNOTLOADLZ32 = VER_INSTALL_FILE_STATUS.CANNOTLOADLZ32;
pub const VIF_CANNOTLOADCABINET = VER_INSTALL_FILE_STATUS.CANNOTLOADCABINET;

pub const VS_FIXEDFILEINFO_FILE_FLAGS = enum(u32) {
    DEBUG = 1,
    PRERELEASE = 2,
    PATCHED = 4,
    PRIVATEBUILD = 8,
    INFOINFERRED = 16,
    SPECIALBUILD = 32,
    _,
    pub fn initFlags(o: struct {
        DEBUG: u1 = 0,
        PRERELEASE: u1 = 0,
        PATCHED: u1 = 0,
        PRIVATEBUILD: u1 = 0,
        INFOINFERRED: u1 = 0,
        SPECIALBUILD: u1 = 0,
    }) VS_FIXEDFILEINFO_FILE_FLAGS {
        return @as(VS_FIXEDFILEINFO_FILE_FLAGS, @enumFromInt((if (o.DEBUG == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.DEBUG) else 0) | (if (o.PRERELEASE == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.PRERELEASE) else 0) | (if (o.PATCHED == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.PATCHED) else 0) | (if (o.PRIVATEBUILD == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.PRIVATEBUILD) else 0) | (if (o.INFOINFERRED == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.INFOINFERRED) else 0) | (if (o.SPECIALBUILD == 1) @intFromEnum(VS_FIXEDFILEINFO_FILE_FLAGS.SPECIALBUILD) else 0)));
    }
};
pub const VS_FF_DEBUG = VS_FIXEDFILEINFO_FILE_FLAGS.DEBUG;
pub const VS_FF_PRERELEASE = VS_FIXEDFILEINFO_FILE_FLAGS.PRERELEASE;
pub const VS_FF_PATCHED = VS_FIXEDFILEINFO_FILE_FLAGS.PATCHED;
pub const VS_FF_PRIVATEBUILD = VS_FIXEDFILEINFO_FILE_FLAGS.PRIVATEBUILD;
pub const VS_FF_INFOINFERRED = VS_FIXEDFILEINFO_FILE_FLAGS.INFOINFERRED;
pub const VS_FF_SPECIALBUILD = VS_FIXEDFILEINFO_FILE_FLAGS.SPECIALBUILD;

pub const VS_FIXEDFILEINFO_FILE_OS = enum(i32) {
    UNKNOWN = 0,
    DOS = 65536,
    OS216 = 131072,
    OS232 = 196608,
    NT = 262144,
    WINCE = 327680,
    // _BASE = 0, this enum value conflicts with UNKNOWN
    _WINDOWS16 = 1,
    _PM16 = 2,
    _PM32 = 3,
    _WINDOWS32 = 4,
    DOS_WINDOWS16 = 65537,
    DOS_WINDOWS32 = 65540,
    OS216_PM16 = 131074,
    OS232_PM32 = 196611,
    NT_WINDOWS32 = 262148,
};
pub const VOS_UNKNOWN = VS_FIXEDFILEINFO_FILE_OS.UNKNOWN;
pub const VOS_DOS = VS_FIXEDFILEINFO_FILE_OS.DOS;
pub const VOS_OS216 = VS_FIXEDFILEINFO_FILE_OS.OS216;
pub const VOS_OS232 = VS_FIXEDFILEINFO_FILE_OS.OS232;
pub const VOS_NT = VS_FIXEDFILEINFO_FILE_OS.NT;
pub const VOS_WINCE = VS_FIXEDFILEINFO_FILE_OS.WINCE;
pub const VOS__BASE = VS_FIXEDFILEINFO_FILE_OS.UNKNOWN;
pub const VOS__WINDOWS16 = VS_FIXEDFILEINFO_FILE_OS._WINDOWS16;
pub const VOS__PM16 = VS_FIXEDFILEINFO_FILE_OS._PM16;
pub const VOS__PM32 = VS_FIXEDFILEINFO_FILE_OS._PM32;
pub const VOS__WINDOWS32 = VS_FIXEDFILEINFO_FILE_OS._WINDOWS32;
pub const VOS_DOS_WINDOWS16 = VS_FIXEDFILEINFO_FILE_OS.DOS_WINDOWS16;
pub const VOS_DOS_WINDOWS32 = VS_FIXEDFILEINFO_FILE_OS.DOS_WINDOWS32;
pub const VOS_OS216_PM16 = VS_FIXEDFILEINFO_FILE_OS.OS216_PM16;
pub const VOS_OS232_PM32 = VS_FIXEDFILEINFO_FILE_OS.OS232_PM32;
pub const VOS_NT_WINDOWS32 = VS_FIXEDFILEINFO_FILE_OS.NT_WINDOWS32;

pub const VS_FIXEDFILEINFO_FILE_TYPE = enum(i32) {
    UNKNOWN = 0,
    APP = 1,
    DLL = 2,
    DRV = 3,
    FONT = 4,
    VXD = 5,
    STATIC_LIB = 7,
};
pub const VFT_UNKNOWN = VS_FIXEDFILEINFO_FILE_TYPE.UNKNOWN;
pub const VFT_APP = VS_FIXEDFILEINFO_FILE_TYPE.APP;
pub const VFT_DLL = VS_FIXEDFILEINFO_FILE_TYPE.DLL;
pub const VFT_DRV = VS_FIXEDFILEINFO_FILE_TYPE.DRV;
pub const VFT_FONT = VS_FIXEDFILEINFO_FILE_TYPE.FONT;
pub const VFT_VXD = VS_FIXEDFILEINFO_FILE_TYPE.VXD;
pub const VFT_STATIC_LIB = VS_FIXEDFILEINFO_FILE_TYPE.STATIC_LIB;

pub const VS_FIXEDFILEINFO_FILE_SUBTYPE = enum(i32) {
    UNKNOWN = 0,
    DRV_PRINTER = 1,
    DRV_KEYBOARD = 2,
    DRV_LANGUAGE = 3,
    DRV_DISPLAY = 4,
    DRV_MOUSE = 5,
    DRV_NETWORK = 6,
    DRV_SYSTEM = 7,
    DRV_INSTALLABLE = 8,
    DRV_SOUND = 9,
    DRV_COMM = 10,
    DRV_INPUTMETHOD = 11,
    DRV_VERSIONED_PRINTER = 12,
    // FONT_RASTER = 1, this enum value conflicts with DRV_PRINTER
    // FONT_VECTOR = 2, this enum value conflicts with DRV_KEYBOARD
    // FONT_TRUETYPE = 3, this enum value conflicts with DRV_LANGUAGE
};
pub const VFT2_UNKNOWN = VS_FIXEDFILEINFO_FILE_SUBTYPE.UNKNOWN;
pub const VFT2_DRV_PRINTER = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_PRINTER;
pub const VFT2_DRV_KEYBOARD = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_KEYBOARD;
pub const VFT2_DRV_LANGUAGE = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_LANGUAGE;
pub const VFT2_DRV_DISPLAY = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_DISPLAY;
pub const VFT2_DRV_MOUSE = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_MOUSE;
pub const VFT2_DRV_NETWORK = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_NETWORK;
pub const VFT2_DRV_SYSTEM = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_SYSTEM;
pub const VFT2_DRV_INSTALLABLE = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_INSTALLABLE;
pub const VFT2_DRV_SOUND = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_SOUND;
pub const VFT2_DRV_COMM = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_COMM;
pub const VFT2_DRV_INPUTMETHOD = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_INPUTMETHOD;
pub const VFT2_DRV_VERSIONED_PRINTER = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_VERSIONED_PRINTER;
pub const VFT2_FONT_RASTER = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_PRINTER;
pub const VFT2_FONT_VECTOR = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_KEYBOARD;
pub const VFT2_FONT_TRUETYPE = VS_FIXEDFILEINFO_FILE_SUBTYPE.DRV_LANGUAGE;

pub const FILE_CREATION_DISPOSITION = enum(u32) {
    CREATE_NEW = 1,
    CREATE_ALWAYS = 2,
    OPEN_EXISTING = 3,
    OPEN_ALWAYS = 4,
    TRUNCATE_EXISTING = 5,
};
pub const CREATE_NEW = FILE_CREATION_DISPOSITION.CREATE_NEW;
pub const CREATE_ALWAYS = FILE_CREATION_DISPOSITION.CREATE_ALWAYS;
pub const OPEN_EXISTING = FILE_CREATION_DISPOSITION.OPEN_EXISTING;
pub const OPEN_ALWAYS = FILE_CREATION_DISPOSITION.OPEN_ALWAYS;
pub const TRUNCATE_EXISTING = FILE_CREATION_DISPOSITION.TRUNCATE_EXISTING;

pub const FILE_SHARE_MODE = enum(u32) {
    NONE = 0,
    DELETE = 4,
    READ = 1,
    WRITE = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DELETE: u1 = 0,
        READ: u1 = 0,
        WRITE: u1 = 0,
    }) FILE_SHARE_MODE {
        return @as(FILE_SHARE_MODE, @enumFromInt((if (o.NONE == 1) @intFromEnum(FILE_SHARE_MODE.NONE) else 0) | (if (o.DELETE == 1) @intFromEnum(FILE_SHARE_MODE.DELETE) else 0) | (if (o.READ == 1) @intFromEnum(FILE_SHARE_MODE.READ) else 0) | (if (o.WRITE == 1) @intFromEnum(FILE_SHARE_MODE.WRITE) else 0)));
    }
};
pub const FILE_SHARE_NONE = FILE_SHARE_MODE.NONE;
pub const FILE_SHARE_DELETE = FILE_SHARE_MODE.DELETE;
pub const FILE_SHARE_READ = FILE_SHARE_MODE.READ;
pub const FILE_SHARE_WRITE = FILE_SHARE_MODE.WRITE;

pub const SHARE_TYPE = enum(u32) {
    DISKTREE = 0,
    PRINTQ = 1,
    DEVICE = 2,
    IPC = 3,
    SPECIAL = 2147483648,
    TEMPORARY = 1073741824,
    MASK = 255,
    _,
    pub fn initFlags(o: struct {
        DISKTREE: u1 = 0,
        PRINTQ: u1 = 0,
        DEVICE: u1 = 0,
        IPC: u1 = 0,
        SPECIAL: u1 = 0,
        TEMPORARY: u1 = 0,
        MASK: u1 = 0,
    }) SHARE_TYPE {
        return @as(SHARE_TYPE, @enumFromInt((if (o.DISKTREE == 1) @intFromEnum(SHARE_TYPE.DISKTREE) else 0) | (if (o.PRINTQ == 1) @intFromEnum(SHARE_TYPE.PRINTQ) else 0) | (if (o.DEVICE == 1) @intFromEnum(SHARE_TYPE.DEVICE) else 0) | (if (o.IPC == 1) @intFromEnum(SHARE_TYPE.IPC) else 0) | (if (o.SPECIAL == 1) @intFromEnum(SHARE_TYPE.SPECIAL) else 0) | (if (o.TEMPORARY == 1) @intFromEnum(SHARE_TYPE.TEMPORARY) else 0) | (if (o.MASK == 1) @intFromEnum(SHARE_TYPE.MASK) else 0)));
    }
};
pub const STYPE_DISKTREE = SHARE_TYPE.DISKTREE;
pub const STYPE_PRINTQ = SHARE_TYPE.PRINTQ;
pub const STYPE_DEVICE = SHARE_TYPE.DEVICE;
pub const STYPE_IPC = SHARE_TYPE.IPC;
pub const STYPE_SPECIAL = SHARE_TYPE.SPECIAL;
pub const STYPE_TEMPORARY = SHARE_TYPE.TEMPORARY;
pub const STYPE_MASK = SHARE_TYPE.MASK;

pub const CLFS_FLAG = enum(u32) {
    FORCE_APPEND = 1,
    FORCE_FLUSH = 2,
    NO_FLAGS = 0,
    USE_RESERVATION = 4,
    _,
    pub fn initFlags(o: struct {
        FORCE_APPEND: u1 = 0,
        FORCE_FLUSH: u1 = 0,
        NO_FLAGS: u1 = 0,
        USE_RESERVATION: u1 = 0,
    }) CLFS_FLAG {
        return @as(CLFS_FLAG, @enumFromInt((if (o.FORCE_APPEND == 1) @intFromEnum(CLFS_FLAG.FORCE_APPEND) else 0) | (if (o.FORCE_FLUSH == 1) @intFromEnum(CLFS_FLAG.FORCE_FLUSH) else 0) | (if (o.NO_FLAGS == 1) @intFromEnum(CLFS_FLAG.NO_FLAGS) else 0) | (if (o.USE_RESERVATION == 1) @intFromEnum(CLFS_FLAG.USE_RESERVATION) else 0)));
    }
};
pub const CLFS_FLAG_FORCE_APPEND = CLFS_FLAG.FORCE_APPEND;
pub const CLFS_FLAG_FORCE_FLUSH = CLFS_FLAG.FORCE_FLUSH;
pub const CLFS_FLAG_NO_FLAGS = CLFS_FLAG.NO_FLAGS;
pub const CLFS_FLAG_USE_RESERVATION = CLFS_FLAG.USE_RESERVATION;

pub const SET_FILE_POINTER_MOVE_METHOD = enum(u32) {
    BEGIN = 0,
    CURRENT = 1,
    END = 2,
};
pub const FILE_BEGIN = SET_FILE_POINTER_MOVE_METHOD.BEGIN;
pub const FILE_CURRENT = SET_FILE_POINTER_MOVE_METHOD.CURRENT;
pub const FILE_END = SET_FILE_POINTER_MOVE_METHOD.END;

pub const MOVE_FILE_FLAGS = enum(u32) {
    COPY_ALLOWED = 2,
    CREATE_HARDLINK = 16,
    DELAY_UNTIL_REBOOT = 4,
    REPLACE_EXISTING = 1,
    WRITE_THROUGH = 8,
    FAIL_IF_NOT_TRACKABLE = 32,
    _,
    pub fn initFlags(o: struct {
        COPY_ALLOWED: u1 = 0,
        CREATE_HARDLINK: u1 = 0,
        DELAY_UNTIL_REBOOT: u1 = 0,
        REPLACE_EXISTING: u1 = 0,
        WRITE_THROUGH: u1 = 0,
        FAIL_IF_NOT_TRACKABLE: u1 = 0,
    }) MOVE_FILE_FLAGS {
        return @as(MOVE_FILE_FLAGS, @enumFromInt((if (o.COPY_ALLOWED == 1) @intFromEnum(MOVE_FILE_FLAGS.COPY_ALLOWED) else 0) | (if (o.CREATE_HARDLINK == 1) @intFromEnum(MOVE_FILE_FLAGS.CREATE_HARDLINK) else 0) | (if (o.DELAY_UNTIL_REBOOT == 1) @intFromEnum(MOVE_FILE_FLAGS.DELAY_UNTIL_REBOOT) else 0) | (if (o.REPLACE_EXISTING == 1) @intFromEnum(MOVE_FILE_FLAGS.REPLACE_EXISTING) else 0) | (if (o.WRITE_THROUGH == 1) @intFromEnum(MOVE_FILE_FLAGS.WRITE_THROUGH) else 0) | (if (o.FAIL_IF_NOT_TRACKABLE == 1) @intFromEnum(MOVE_FILE_FLAGS.FAIL_IF_NOT_TRACKABLE) else 0)));
    }
};
pub const MOVEFILE_COPY_ALLOWED = MOVE_FILE_FLAGS.COPY_ALLOWED;
pub const MOVEFILE_CREATE_HARDLINK = MOVE_FILE_FLAGS.CREATE_HARDLINK;
pub const MOVEFILE_DELAY_UNTIL_REBOOT = MOVE_FILE_FLAGS.DELAY_UNTIL_REBOOT;
pub const MOVEFILE_REPLACE_EXISTING = MOVE_FILE_FLAGS.REPLACE_EXISTING;
pub const MOVEFILE_WRITE_THROUGH = MOVE_FILE_FLAGS.WRITE_THROUGH;
pub const MOVEFILE_FAIL_IF_NOT_TRACKABLE = MOVE_FILE_FLAGS.FAIL_IF_NOT_TRACKABLE;

pub const FILE_NAME = enum(u32) {
    NORMALIZED = 0,
    OPENED = 8,
};
pub const FILE_NAME_NORMALIZED = FILE_NAME.NORMALIZED;
pub const FILE_NAME_OPENED = FILE_NAME.OPENED;

pub const LZOPENFILE_STYLE = enum(u32) {
    CANCEL = 2048,
    CREATE = 4096,
    DELETE = 512,
    EXIST = 16384,
    PARSE = 256,
    PROMPT = 8192,
    READ = 0,
    READWRITE = 2,
    REOPEN = 32768,
    SHARE_DENY_NONE = 64,
    SHARE_DENY_READ = 48,
    SHARE_DENY_WRITE = 32,
    SHARE_EXCLUSIVE = 16,
    WRITE = 1,
    // SHARE_COMPAT = 0, this enum value conflicts with READ
    VERIFY = 1024,
    _,
    pub fn initFlags(o: struct {
        CANCEL: u1 = 0,
        CREATE: u1 = 0,
        DELETE: u1 = 0,
        EXIST: u1 = 0,
        PARSE: u1 = 0,
        PROMPT: u1 = 0,
        READ: u1 = 0,
        READWRITE: u1 = 0,
        REOPEN: u1 = 0,
        SHARE_DENY_NONE: u1 = 0,
        SHARE_DENY_READ: u1 = 0,
        SHARE_DENY_WRITE: u1 = 0,
        SHARE_EXCLUSIVE: u1 = 0,
        WRITE: u1 = 0,
        VERIFY: u1 = 0,
    }) LZOPENFILE_STYLE {
        return @as(LZOPENFILE_STYLE, @enumFromInt((if (o.CANCEL == 1) @intFromEnum(LZOPENFILE_STYLE.CANCEL) else 0) | (if (o.CREATE == 1) @intFromEnum(LZOPENFILE_STYLE.CREATE) else 0) | (if (o.DELETE == 1) @intFromEnum(LZOPENFILE_STYLE.DELETE) else 0) | (if (o.EXIST == 1) @intFromEnum(LZOPENFILE_STYLE.EXIST) else 0) | (if (o.PARSE == 1) @intFromEnum(LZOPENFILE_STYLE.PARSE) else 0) | (if (o.PROMPT == 1) @intFromEnum(LZOPENFILE_STYLE.PROMPT) else 0) | (if (o.READ == 1) @intFromEnum(LZOPENFILE_STYLE.READ) else 0) | (if (o.READWRITE == 1) @intFromEnum(LZOPENFILE_STYLE.READWRITE) else 0) | (if (o.REOPEN == 1) @intFromEnum(LZOPENFILE_STYLE.REOPEN) else 0) | (if (o.SHARE_DENY_NONE == 1) @intFromEnum(LZOPENFILE_STYLE.SHARE_DENY_NONE) else 0) | (if (o.SHARE_DENY_READ == 1) @intFromEnum(LZOPENFILE_STYLE.SHARE_DENY_READ) else 0) | (if (o.SHARE_DENY_WRITE == 1) @intFromEnum(LZOPENFILE_STYLE.SHARE_DENY_WRITE) else 0) | (if (o.SHARE_EXCLUSIVE == 1) @intFromEnum(LZOPENFILE_STYLE.SHARE_EXCLUSIVE) else 0) | (if (o.WRITE == 1) @intFromEnum(LZOPENFILE_STYLE.WRITE) else 0) | (if (o.VERIFY == 1) @intFromEnum(LZOPENFILE_STYLE.VERIFY) else 0)));
    }
};
pub const OF_CANCEL = LZOPENFILE_STYLE.CANCEL;
pub const OF_CREATE = LZOPENFILE_STYLE.CREATE;
pub const OF_DELETE = LZOPENFILE_STYLE.DELETE;
pub const OF_EXIST = LZOPENFILE_STYLE.EXIST;
pub const OF_PARSE = LZOPENFILE_STYLE.PARSE;
pub const OF_PROMPT = LZOPENFILE_STYLE.PROMPT;
pub const OF_READ = LZOPENFILE_STYLE.READ;
pub const OF_READWRITE = LZOPENFILE_STYLE.READWRITE;
pub const OF_REOPEN = LZOPENFILE_STYLE.REOPEN;
pub const OF_SHARE_DENY_NONE = LZOPENFILE_STYLE.SHARE_DENY_NONE;
pub const OF_SHARE_DENY_READ = LZOPENFILE_STYLE.SHARE_DENY_READ;
pub const OF_SHARE_DENY_WRITE = LZOPENFILE_STYLE.SHARE_DENY_WRITE;
pub const OF_SHARE_EXCLUSIVE = LZOPENFILE_STYLE.SHARE_EXCLUSIVE;
pub const OF_WRITE = LZOPENFILE_STYLE.WRITE;
pub const OF_SHARE_COMPAT = LZOPENFILE_STYLE.READ;
pub const OF_VERIFY = LZOPENFILE_STYLE.VERIFY;

pub const FILE_NOTIFY_CHANGE = enum(u32) {
    FILE_NAME = 1,
    DIR_NAME = 2,
    ATTRIBUTES = 4,
    SIZE = 8,
    LAST_WRITE = 16,
    LAST_ACCESS = 32,
    CREATION = 64,
    SECURITY = 256,
    _,
    pub fn initFlags(o: struct {
        FILE_NAME: u1 = 0,
        DIR_NAME: u1 = 0,
        ATTRIBUTES: u1 = 0,
        SIZE: u1 = 0,
        LAST_WRITE: u1 = 0,
        LAST_ACCESS: u1 = 0,
        CREATION: u1 = 0,
        SECURITY: u1 = 0,
    }) FILE_NOTIFY_CHANGE {
        return @as(FILE_NOTIFY_CHANGE, @enumFromInt((if (o.FILE_NAME == 1) @intFromEnum(FILE_NOTIFY_CHANGE.FILE_NAME) else 0) | (if (o.DIR_NAME == 1) @intFromEnum(FILE_NOTIFY_CHANGE.DIR_NAME) else 0) | (if (o.ATTRIBUTES == 1) @intFromEnum(FILE_NOTIFY_CHANGE.ATTRIBUTES) else 0) | (if (o.SIZE == 1) @intFromEnum(FILE_NOTIFY_CHANGE.SIZE) else 0) | (if (o.LAST_WRITE == 1) @intFromEnum(FILE_NOTIFY_CHANGE.LAST_WRITE) else 0) | (if (o.LAST_ACCESS == 1) @intFromEnum(FILE_NOTIFY_CHANGE.LAST_ACCESS) else 0) | (if (o.CREATION == 1) @intFromEnum(FILE_NOTIFY_CHANGE.CREATION) else 0) | (if (o.SECURITY == 1) @intFromEnum(FILE_NOTIFY_CHANGE.SECURITY) else 0)));
    }
};
pub const FILE_NOTIFY_CHANGE_FILE_NAME = FILE_NOTIFY_CHANGE.FILE_NAME;
pub const FILE_NOTIFY_CHANGE_DIR_NAME = FILE_NOTIFY_CHANGE.DIR_NAME;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES = FILE_NOTIFY_CHANGE.ATTRIBUTES;
pub const FILE_NOTIFY_CHANGE_SIZE = FILE_NOTIFY_CHANGE.SIZE;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE = FILE_NOTIFY_CHANGE.LAST_WRITE;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS = FILE_NOTIFY_CHANGE.LAST_ACCESS;
pub const FILE_NOTIFY_CHANGE_CREATION = FILE_NOTIFY_CHANGE.CREATION;
pub const FILE_NOTIFY_CHANGE_SECURITY = FILE_NOTIFY_CHANGE.SECURITY;

pub const TXFS_MINIVERSION = enum(u32) {
    COMMITTED_VIEW = 0,
    DIRTY_VIEW = 65535,
    DEFAULT_VIEW = 65534,
};
pub const TXFS_MINIVERSION_COMMITTED_VIEW = TXFS_MINIVERSION.COMMITTED_VIEW;
pub const TXFS_MINIVERSION_DIRTY_VIEW = TXFS_MINIVERSION.DIRTY_VIEW;
pub const TXFS_MINIVERSION_DEFAULT_VIEW = TXFS_MINIVERSION.DEFAULT_VIEW;

pub const TAPE_POSITION_TYPE = enum(i32) {
    ABSOLUTE_POSITION = 0,
    LOGICAL_POSITION = 1,
};
pub const TAPE_ABSOLUTE_POSITION = TAPE_POSITION_TYPE.ABSOLUTE_POSITION;
pub const TAPE_LOGICAL_POSITION = TAPE_POSITION_TYPE.LOGICAL_POSITION;

pub const CREATE_TAPE_PARTITION_METHOD = enum(i32) {
    FIXED_PARTITIONS = 0,
    INITIATOR_PARTITIONS = 2,
    SELECT_PARTITIONS = 1,
};
pub const TAPE_FIXED_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.FIXED_PARTITIONS;
pub const TAPE_INITIATOR_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.INITIATOR_PARTITIONS;
pub const TAPE_SELECT_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.SELECT_PARTITIONS;

pub const REPLACE_FILE_FLAGS = enum(u32) {
    WRITE_THROUGH = 1,
    IGNORE_MERGE_ERRORS = 2,
    IGNORE_ACL_ERRORS = 4,
    _,
    pub fn initFlags(o: struct {
        WRITE_THROUGH: u1 = 0,
        IGNORE_MERGE_ERRORS: u1 = 0,
        IGNORE_ACL_ERRORS: u1 = 0,
    }) REPLACE_FILE_FLAGS {
        return @as(REPLACE_FILE_FLAGS, @enumFromInt((if (o.WRITE_THROUGH == 1) @intFromEnum(REPLACE_FILE_FLAGS.WRITE_THROUGH) else 0) | (if (o.IGNORE_MERGE_ERRORS == 1) @intFromEnum(REPLACE_FILE_FLAGS.IGNORE_MERGE_ERRORS) else 0) | (if (o.IGNORE_ACL_ERRORS == 1) @intFromEnum(REPLACE_FILE_FLAGS.IGNORE_ACL_ERRORS) else 0)));
    }
};
pub const REPLACEFILE_WRITE_THROUGH = REPLACE_FILE_FLAGS.WRITE_THROUGH;
pub const REPLACEFILE_IGNORE_MERGE_ERRORS = REPLACE_FILE_FLAGS.IGNORE_MERGE_ERRORS;
pub const REPLACEFILE_IGNORE_ACL_ERRORS = REPLACE_FILE_FLAGS.IGNORE_ACL_ERRORS;

pub const TAPEMARK_TYPE = enum(i32) {
    FILEMARKS = 1,
    LONG_FILEMARKS = 3,
    SETMARKS = 0,
    SHORT_FILEMARKS = 2,
};
pub const TAPE_FILEMARKS = TAPEMARK_TYPE.FILEMARKS;
pub const TAPE_LONG_FILEMARKS = TAPEMARK_TYPE.LONG_FILEMARKS;
pub const TAPE_SETMARKS = TAPEMARK_TYPE.SETMARKS;
pub const TAPE_SHORT_FILEMARKS = TAPEMARK_TYPE.SHORT_FILEMARKS;

pub const DISKQUOTA_USERNAME_RESOLVE = enum(u32) {
    ASYNC = 2,
    NONE = 0,
    SYNC = 1,
};
pub const DISKQUOTA_USERNAME_RESOLVE_ASYNC = DISKQUOTA_USERNAME_RESOLVE.ASYNC;
pub const DISKQUOTA_USERNAME_RESOLVE_NONE = DISKQUOTA_USERNAME_RESOLVE.NONE;
pub const DISKQUOTA_USERNAME_RESOLVE_SYNC = DISKQUOTA_USERNAME_RESOLVE.SYNC;

pub const TAPE_POSITION_METHOD = enum(i32) {
    ABSOLUTE_BLOCK = 1,
    LOGICAL_BLOCK = 2,
    REWIND = 0,
    SPACE_END_OF_DATA = 4,
    SPACE_FILEMARKS = 6,
    SPACE_RELATIVE_BLOCKS = 5,
    SPACE_SEQUENTIAL_FMKS = 7,
    SPACE_SEQUENTIAL_SMKS = 9,
    SPACE_SETMARKS = 8,
};
pub const TAPE_ABSOLUTE_BLOCK = TAPE_POSITION_METHOD.ABSOLUTE_BLOCK;
pub const TAPE_LOGICAL_BLOCK = TAPE_POSITION_METHOD.LOGICAL_BLOCK;
pub const TAPE_REWIND = TAPE_POSITION_METHOD.REWIND;
pub const TAPE_SPACE_END_OF_DATA = TAPE_POSITION_METHOD.SPACE_END_OF_DATA;
pub const TAPE_SPACE_FILEMARKS = TAPE_POSITION_METHOD.SPACE_FILEMARKS;
pub const TAPE_SPACE_RELATIVE_BLOCKS = TAPE_POSITION_METHOD.SPACE_RELATIVE_BLOCKS;
pub const TAPE_SPACE_SEQUENTIAL_FMKS = TAPE_POSITION_METHOD.SPACE_SEQUENTIAL_FMKS;
pub const TAPE_SPACE_SEQUENTIAL_SMKS = TAPE_POSITION_METHOD.SPACE_SEQUENTIAL_SMKS;
pub const TAPE_SPACE_SETMARKS = TAPE_POSITION_METHOD.SPACE_SETMARKS;

pub const NT_CREATE_FILE_DISPOSITION = enum(u32) {
    SUPERSEDE = 0,
    CREATE = 2,
    OPEN = 1,
    OPEN_IF = 3,
    OVERWRITE = 4,
    OVERWRITE_IF = 5,
};
pub const FILE_SUPERSEDE = NT_CREATE_FILE_DISPOSITION.SUPERSEDE;
pub const FILE_CREATE = NT_CREATE_FILE_DISPOSITION.CREATE;
pub const FILE_OPEN = NT_CREATE_FILE_DISPOSITION.OPEN;
pub const FILE_OPEN_IF = NT_CREATE_FILE_DISPOSITION.OPEN_IF;
pub const FILE_OVERWRITE = NT_CREATE_FILE_DISPOSITION.OVERWRITE;
pub const FILE_OVERWRITE_IF = NT_CREATE_FILE_DISPOSITION.OVERWRITE_IF;

pub const TAPE_INFORMATION_TYPE = enum(u32) {
    DRIVE_INFORMATION = 1,
    MEDIA_INFORMATION = 0,
};
pub const SET_TAPE_DRIVE_INFORMATION = TAPE_INFORMATION_TYPE.DRIVE_INFORMATION;
pub const SET_TAPE_MEDIA_INFORMATION = TAPE_INFORMATION_TYPE.MEDIA_INFORMATION;

pub const NTMS_OMID_TYPE = enum(u32) {
    FILESYSTEM_INFO = 2,
    RAW_LABEL = 1,
};
pub const NTMS_OMID_TYPE_FILESYSTEM_INFO = NTMS_OMID_TYPE.FILESYSTEM_INFO;
pub const NTMS_OMID_TYPE_RAW_LABEL = NTMS_OMID_TYPE.RAW_LABEL;

pub const LOCK_FILE_FLAGS = enum(u32) {
    EXCLUSIVE_LOCK = 2,
    FAIL_IMMEDIATELY = 1,
    _,
    pub fn initFlags(o: struct {
        EXCLUSIVE_LOCK: u1 = 0,
        FAIL_IMMEDIATELY: u1 = 0,
    }) LOCK_FILE_FLAGS {
        return @as(LOCK_FILE_FLAGS, @enumFromInt((if (o.EXCLUSIVE_LOCK == 1) @intFromEnum(LOCK_FILE_FLAGS.EXCLUSIVE_LOCK) else 0) | (if (o.FAIL_IMMEDIATELY == 1) @intFromEnum(LOCK_FILE_FLAGS.FAIL_IMMEDIATELY) else 0)));
    }
};
pub const LOCKFILE_EXCLUSIVE_LOCK = LOCK_FILE_FLAGS.EXCLUSIVE_LOCK;
pub const LOCKFILE_FAIL_IMMEDIATELY = LOCK_FILE_FLAGS.FAIL_IMMEDIATELY;

pub const LPPROGRESS_ROUTINE_CALLBACK_REASON = enum(u32) {
    CHUNK_FINISHED = 0,
    STREAM_SWITCH = 1,
};
pub const CALLBACK_CHUNK_FINISHED = LPPROGRESS_ROUTINE_CALLBACK_REASON.CHUNK_FINISHED;
pub const CALLBACK_STREAM_SWITCH = LPPROGRESS_ROUTINE_CALLBACK_REASON.STREAM_SWITCH;

pub const PREPARE_TAPE_OPERATION = enum(i32) {
    FORMAT = 5,
    LOAD = 0,
    LOCK = 3,
    TENSION = 2,
    UNLOAD = 1,
    UNLOCK = 4,
};
pub const TAPE_FORMAT = PREPARE_TAPE_OPERATION.FORMAT;
pub const TAPE_LOAD = PREPARE_TAPE_OPERATION.LOAD;
pub const TAPE_LOCK = PREPARE_TAPE_OPERATION.LOCK;
pub const TAPE_TENSION = PREPARE_TAPE_OPERATION.TENSION;
pub const TAPE_UNLOAD = PREPARE_TAPE_OPERATION.UNLOAD;
pub const TAPE_UNLOCK = PREPARE_TAPE_OPERATION.UNLOCK;

pub const GET_TAPE_DRIVE_PARAMETERS_OPERATION = enum(u32) {
    DRIVE_INFORMATION = 1,
    MEDIA_INFORMATION = 0,
};
pub const GET_TAPE_DRIVE_INFORMATION = GET_TAPE_DRIVE_PARAMETERS_OPERATION.DRIVE_INFORMATION;
pub const GET_TAPE_MEDIA_INFORMATION = GET_TAPE_DRIVE_PARAMETERS_OPERATION.MEDIA_INFORMATION;

pub const ERASE_TAPE_TYPE = enum(i32) {
    LONG = 1,
    SHORT = 0,
};
pub const TAPE_ERASE_LONG = ERASE_TAPE_TYPE.LONG;
pub const TAPE_ERASE_SHORT = ERASE_TAPE_TYPE.SHORT;

pub const FILE_ACTION = enum(u32) {
    ADDED = 1,
    REMOVED = 2,
    MODIFIED = 3,
    RENAMED_OLD_NAME = 4,
    RENAMED_NEW_NAME = 5,
};
pub const FILE_ACTION_ADDED = FILE_ACTION.ADDED;
pub const FILE_ACTION_REMOVED = FILE_ACTION.REMOVED;
pub const FILE_ACTION_MODIFIED = FILE_ACTION.MODIFIED;
pub const FILE_ACTION_RENAMED_OLD_NAME = FILE_ACTION.RENAMED_OLD_NAME;
pub const FILE_ACTION_RENAMED_NEW_NAME = FILE_ACTION.RENAMED_NEW_NAME;

pub const SHARE_INFO_PERMISSIONS = enum(u32) {
    READ = 1,
    WRITE = 2,
    CREATE = 4,
    EXEC = 8,
    DELETE = 16,
    ATRIB = 32,
    PERM = 64,
    ALL = 32768,
};
pub const ACCESS_READ = SHARE_INFO_PERMISSIONS.READ;
pub const ACCESS_WRITE = SHARE_INFO_PERMISSIONS.WRITE;
pub const ACCESS_CREATE = SHARE_INFO_PERMISSIONS.CREATE;
pub const ACCESS_EXEC = SHARE_INFO_PERMISSIONS.EXEC;
pub const ACCESS_DELETE = SHARE_INFO_PERMISSIONS.DELETE;
pub const ACCESS_ATRIB = SHARE_INFO_PERMISSIONS.ATRIB;
pub const ACCESS_PERM = SHARE_INFO_PERMISSIONS.PERM;
pub const ACCESS_ALL = SHARE_INFO_PERMISSIONS.ALL;

pub const FILE_DEVICE_TYPE = enum(u32) {
    CD_ROM = 2,
    DISK = 7,
    TAPE = 31,
    DVD = 51,
};
pub const FILE_DEVICE_CD_ROM = FILE_DEVICE_TYPE.CD_ROM;
pub const FILE_DEVICE_DISK = FILE_DEVICE_TYPE.DISK;
pub const FILE_DEVICE_TAPE = FILE_DEVICE_TYPE.TAPE;
pub const FILE_DEVICE_DVD = FILE_DEVICE_TYPE.DVD;

pub const SESSION_INFO_USER_FLAGS = enum(u32) {
    GUEST = 1,
    NOENCRYPTION = 2,
};
pub const SESS_GUEST = SESSION_INFO_USER_FLAGS.GUEST;
pub const SESS_NOENCRYPTION = SESSION_INFO_USER_FLAGS.NOENCRYPTION;

pub const WIN_STREAM_ID = enum(u32) {
    ALTERNATE_DATA = 4,
    DATA = 1,
    EA_DATA = 2,
    LINK = 5,
    OBJECT_ID = 7,
    PROPERTY_DATA = 6,
    REPARSE_DATA = 8,
    SECURITY_DATA = 3,
    SPARSE_BLOCK = 9,
    TXFS_DATA = 10,
};
pub const BACKUP_ALTERNATE_DATA = WIN_STREAM_ID.ALTERNATE_DATA;
pub const BACKUP_DATA = WIN_STREAM_ID.DATA;
pub const BACKUP_EA_DATA = WIN_STREAM_ID.EA_DATA;
pub const BACKUP_LINK = WIN_STREAM_ID.LINK;
pub const BACKUP_OBJECT_ID = WIN_STREAM_ID.OBJECT_ID;
pub const BACKUP_PROPERTY_DATA = WIN_STREAM_ID.PROPERTY_DATA;
pub const BACKUP_REPARSE_DATA = WIN_STREAM_ID.REPARSE_DATA;
pub const BACKUP_SECURITY_DATA = WIN_STREAM_ID.SECURITY_DATA;
pub const BACKUP_SPARSE_BLOCK = WIN_STREAM_ID.SPARSE_BLOCK;
pub const BACKUP_TXFS_DATA = WIN_STREAM_ID.TXFS_DATA;

pub const TXF_LOG_RECORD_TYPE = enum(u16) {
    AFFECTED_FILE = 4,
    TRUNCATE = 2,
    WRITE = 1,
};
pub const TXF_LOG_RECORD_TYPE_AFFECTED_FILE = TXF_LOG_RECORD_TYPE.AFFECTED_FILE;
pub const TXF_LOG_RECORD_TYPE_TRUNCATE = TXF_LOG_RECORD_TYPE.TRUNCATE;
pub const TXF_LOG_RECORD_TYPE_WRITE = TXF_LOG_RECORD_TYPE.WRITE;

pub const FILE_INFO_FLAGS_PERMISSIONS = enum(u32) {
    READ = 1,
    WRITE = 2,
    CREATE = 4,
    _,
    pub fn initFlags(o: struct {
        READ: u1 = 0,
        WRITE: u1 = 0,
        CREATE: u1 = 0,
    }) FILE_INFO_FLAGS_PERMISSIONS {
        return @as(FILE_INFO_FLAGS_PERMISSIONS, @enumFromInt((if (o.READ == 1) @intFromEnum(FILE_INFO_FLAGS_PERMISSIONS.READ) else 0) | (if (o.WRITE == 1) @intFromEnum(FILE_INFO_FLAGS_PERMISSIONS.WRITE) else 0) | (if (o.CREATE == 1) @intFromEnum(FILE_INFO_FLAGS_PERMISSIONS.CREATE) else 0)));
    }
};
pub const PERM_FILE_READ = FILE_INFO_FLAGS_PERMISSIONS.READ;
pub const PERM_FILE_WRITE = FILE_INFO_FLAGS_PERMISSIONS.WRITE;
pub const PERM_FILE_CREATE = FILE_INFO_FLAGS_PERMISSIONS.CREATE;

pub const SYMBOLIC_LINK_FLAGS = enum(u32) {
    DIRECTORY = 1,
    ALLOW_UNPRIVILEGED_CREATE = 2,
    _,
    pub fn initFlags(o: struct {
        DIRECTORY: u1 = 0,
        ALLOW_UNPRIVILEGED_CREATE: u1 = 0,
    }) SYMBOLIC_LINK_FLAGS {
        return @as(SYMBOLIC_LINK_FLAGS, @enumFromInt((if (o.DIRECTORY == 1) @intFromEnum(SYMBOLIC_LINK_FLAGS.DIRECTORY) else 0) | (if (o.ALLOW_UNPRIVILEGED_CREATE == 1) @intFromEnum(SYMBOLIC_LINK_FLAGS.ALLOW_UNPRIVILEGED_CREATE) else 0)));
    }
};
pub const SYMBOLIC_LINK_FLAG_DIRECTORY = SYMBOLIC_LINK_FLAGS.DIRECTORY;
pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE = SYMBOLIC_LINK_FLAGS.ALLOW_UNPRIVILEGED_CREATE;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindFileHandle = isize;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindFileNameHandle = isize;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindStreamHandle = isize;

// TODO: this type has a FreeFunc 'FindCloseChangeNotification', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindChangeNotificationHandle = isize;

// TODO: this type has a FreeFunc 'FindVolumeClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindVolumeHandle = isize;

// TODO: this type has a FreeFunc 'FindVolumeMountPointClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const FindVolumeMointPointHandle = isize;

pub const WIN32_FIND_DATAA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: [260]CHAR,
    cAlternateFileName: [14]CHAR,
};

pub const WIN32_FIND_DATAW = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: [260]u16,
    cAlternateFileName: [14]u16,
};

pub const FINDEX_INFO_LEVELS = enum(i32) {
    Standard = 0,
    Basic = 1,
    MaxInfoLevel = 2,
};
pub const FindExInfoStandard = FINDEX_INFO_LEVELS.Standard;
pub const FindExInfoBasic = FINDEX_INFO_LEVELS.Basic;
pub const FindExInfoMaxInfoLevel = FINDEX_INFO_LEVELS.MaxInfoLevel;

pub const FINDEX_SEARCH_OPS = enum(i32) {
    NameMatch = 0,
    LimitToDirectories = 1,
    LimitToDevices = 2,
    MaxSearchOp = 3,
};
pub const FindExSearchNameMatch = FINDEX_SEARCH_OPS.NameMatch;
pub const FindExSearchLimitToDirectories = FINDEX_SEARCH_OPS.LimitToDirectories;
pub const FindExSearchLimitToDevices = FINDEX_SEARCH_OPS.LimitToDevices;
pub const FindExSearchMaxSearchOp = FINDEX_SEARCH_OPS.MaxSearchOp;

pub const READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = enum(i32) {
    Information = 1,
    ExtendedInformation = 2,
};
pub const ReadDirectoryNotifyInformation = READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.Information;
pub const ReadDirectoryNotifyExtendedInformation = READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ExtendedInformation;

pub const GET_FILEEX_INFO_LEVELS = enum(i32) {
    InfoStandard = 0,
    MaxInfoLevel = 1,
};
pub const GetFileExInfoStandard = GET_FILEEX_INFO_LEVELS.InfoStandard;
pub const GetFileExMaxInfoLevel = GET_FILEEX_INFO_LEVELS.MaxInfoLevel;

pub const FILE_INFO_BY_HANDLE_CLASS = enum(i32) {
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
    FileStorageInfo = 16,
    FileAlignmentInfo = 17,
    FileIdInfo = 18,
    FileIdExtdDirectoryInfo = 19,
    FileIdExtdDirectoryRestartInfo = 20,
    FileDispositionInfoEx = 21,
    FileRenameInfoEx = 22,
    FileCaseSensitiveInfo = 23,
    FileNormalizedNameInfo = 24,
    MaximumFileInfoByHandleClass = 25,
};
pub const FileBasicInfo = FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo;
pub const FileStandardInfo = FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo;
pub const FileNameInfo = FILE_INFO_BY_HANDLE_CLASS.FileNameInfo;
pub const FileRenameInfo = FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo;
pub const FileDispositionInfo = FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo;
pub const FileAllocationInfo = FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo;
pub const FileEndOfFileInfo = FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo;
pub const FileStreamInfo = FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo;
pub const FileCompressionInfo = FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo;
pub const FileAttributeTagInfo = FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo;
pub const FileIdBothDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo;
pub const FileIdBothDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo;
pub const FileIoPriorityHintInfo = FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo;
pub const FileRemoteProtocolInfo = FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo;
pub const FileFullDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo;
pub const FileFullDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo;
pub const FileStorageInfo = FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo;
pub const FileAlignmentInfo = FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo;
pub const FileIdInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdInfo;
pub const FileIdExtdDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo;
pub const FileIdExtdDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo;
pub const FileDispositionInfoEx = FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx;
pub const FileRenameInfoEx = FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx;
pub const FileCaseSensitiveInfo = FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo;
pub const FileNormalizedNameInfo = FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo;
pub const MaximumFileInfoByHandleClass = FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass;

pub const TRANSACTION_NOTIFICATION = extern struct {
    TransactionKey: ?*anyopaque,
    TransactionNotification: u32,
    TmVirtualClock: LARGE_INTEGER,
    ArgumentLength: u32,
};

pub const TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = extern struct {
    EnlistmentId: Guid,
    UOW: Guid,
};

pub const TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = extern struct {
    TmIdentity: Guid,
    Flags: u32,
};

pub const TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = extern struct {
    SavepointId: u32,
};

pub const TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = extern struct {
    PropagationCookie: u32,
    UOW: Guid,
    TmIdentity: Guid,
    BufferLength: u32,
};

pub const TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = extern struct {
    MarshalCookie: u32,
    UOW: Guid,
};

pub const KCRM_MARSHAL_HEADER = extern struct {
    VersionMajor: u32,
    VersionMinor: u32,
    NumProtocols: u32,
    Unused: u32,
};

pub const KCRM_TRANSACTION_BLOB = extern struct {
    UOW: Guid,
    TmIdentity: Guid,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: [64]u16,
};

pub const KCRM_PROTOCOL_BLOB = extern struct {
    ProtocolId: Guid,
    StaticInfoLength: u32,
    TransactionIdInfoLength: u32,
    Unused1: u32,
    Unused2: u32,
};

pub const DISK_SPACE_INFORMATION = extern struct {
    ActualTotalAllocationUnits: u64,
    ActualAvailableAllocationUnits: u64,
    ActualPoolUnavailableAllocationUnits: u64,
    CallerTotalAllocationUnits: u64,
    CallerAvailableAllocationUnits: u64,
    CallerPoolUnavailableAllocationUnits: u64,
    UsedAllocationUnits: u64,
    TotalReservedAllocationUnits: u64,
    VolumeStorageReserveAllocationUnits: u64,
    AvailableCommittedAllocationUnits: u64,
    PoolAvailableAllocationUnits: u64,
    SectorsPerAllocationUnit: u32,
    BytesPerSector: u32,
};

pub const WIN32_FILE_ATTRIBUTE_DATA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
};

pub const BY_HANDLE_FILE_INFORMATION = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    dwVolumeSerialNumber: u32,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    nNumberOfLinks: u32,
    nFileIndexHigh: u32,
    nFileIndexLow: u32,
};

pub const CREATEFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwFileAttributes: u32,
    dwFileFlags: u32,
    dwSecurityQosFlags: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTemplateFile: ?HANDLE,
};

pub const STREAM_INFO_LEVELS = enum(i32) {
    Standard = 0,
    MaxInfoLevel = 1,
};
pub const FindStreamInfoStandard = STREAM_INFO_LEVELS.Standard;
pub const FindStreamInfoMaxInfoLevel = STREAM_INFO_LEVELS.MaxInfoLevel;

pub const WIN32_FIND_STREAM_DATA = extern struct {
    StreamSize: LARGE_INTEGER,
    cStreamName: [296]u16,
};

pub const VS_FIXEDFILEINFO = extern struct {
    dwSignature: u32,
    dwStrucVersion: u32,
    dwFileVersionMS: u32,
    dwFileVersionLS: u32,
    dwProductVersionMS: u32,
    dwProductVersionLS: u32,
    dwFileFlagsMask: u32,
    dwFileFlags: VS_FIXEDFILEINFO_FILE_FLAGS,
    dwFileOS: VS_FIXEDFILEINFO_FILE_OS,
    dwFileType: VS_FIXEDFILEINFO_FILE_TYPE,
    dwFileSubtype: VS_FIXEDFILEINFO_FILE_SUBTYPE,
    dwFileDateMS: u32,
    dwFileDateLS: u32,
};

pub const NtmsObjectsTypes = enum(i32) {
    UNKNOWN = 0,
    OBJECT = 1,
    CHANGER = 2,
    CHANGER_TYPE = 3,
    COMPUTER = 4,
    DRIVE = 5,
    DRIVE_TYPE = 6,
    IEDOOR = 7,
    IEPORT = 8,
    LIBRARY = 9,
    LIBREQUEST = 10,
    LOGICAL_MEDIA = 11,
    MEDIA_POOL = 12,
    MEDIA_TYPE = 13,
    PARTITION = 14,
    PHYSICAL_MEDIA = 15,
    STORAGESLOT = 16,
    OPREQUEST = 17,
    UI_DESTINATION = 18,
    NUMBER_OF_OBJECT_TYPES = 19,
};
pub const NTMS_UNKNOWN = NtmsObjectsTypes.UNKNOWN;
pub const NTMS_OBJECT = NtmsObjectsTypes.OBJECT;
pub const NTMS_CHANGER = NtmsObjectsTypes.CHANGER;
pub const NTMS_CHANGER_TYPE = NtmsObjectsTypes.CHANGER_TYPE;
pub const NTMS_COMPUTER = NtmsObjectsTypes.COMPUTER;
pub const NTMS_DRIVE = NtmsObjectsTypes.DRIVE;
pub const NTMS_DRIVE_TYPE = NtmsObjectsTypes.DRIVE_TYPE;
pub const NTMS_IEDOOR = NtmsObjectsTypes.IEDOOR;
pub const NTMS_IEPORT = NtmsObjectsTypes.IEPORT;
pub const NTMS_LIBRARY = NtmsObjectsTypes.LIBRARY;
pub const NTMS_LIBREQUEST = NtmsObjectsTypes.LIBREQUEST;
pub const NTMS_LOGICAL_MEDIA = NtmsObjectsTypes.LOGICAL_MEDIA;
pub const NTMS_MEDIA_POOL = NtmsObjectsTypes.MEDIA_POOL;
pub const NTMS_MEDIA_TYPE = NtmsObjectsTypes.MEDIA_TYPE;
pub const NTMS_PARTITION = NtmsObjectsTypes.PARTITION;
pub const NTMS_PHYSICAL_MEDIA = NtmsObjectsTypes.PHYSICAL_MEDIA;
pub const NTMS_STORAGESLOT = NtmsObjectsTypes.STORAGESLOT;
pub const NTMS_OPREQUEST = NtmsObjectsTypes.OPREQUEST;
pub const NTMS_UI_DESTINATION = NtmsObjectsTypes.UI_DESTINATION;
pub const NTMS_NUMBER_OF_OBJECT_TYPES = NtmsObjectsTypes.NUMBER_OF_OBJECT_TYPES;

pub const NTMS_ASYNC_IO = extern struct {
    OperationId: Guid,
    EventId: Guid,
    dwOperationType: u32,
    dwResult: u32,
    dwAsyncState: u32,
    hEvent: ?HANDLE,
    bOnStateChange: BOOL,
};

pub const NtmsAsyncStatus = enum(i32) {
    QUEUED = 0,
    WAIT_RESOURCE = 1,
    WAIT_OPERATOR = 2,
    INPROCESS = 3,
    COMPLETE = 4,
};
pub const NTMS_ASYNCSTATE_QUEUED = NtmsAsyncStatus.QUEUED;
pub const NTMS_ASYNCSTATE_WAIT_RESOURCE = NtmsAsyncStatus.WAIT_RESOURCE;
pub const NTMS_ASYNCSTATE_WAIT_OPERATOR = NtmsAsyncStatus.WAIT_OPERATOR;
pub const NTMS_ASYNCSTATE_INPROCESS = NtmsAsyncStatus.INPROCESS;
pub const NTMS_ASYNCSTATE_COMPLETE = NtmsAsyncStatus.COMPLETE;

pub const NtmsAsyncOperations = enum(i32) {
    T = 1,
};
pub const NTMS_ASYNCOP_MOUNT = NtmsAsyncOperations.T;

pub const NtmsSessionOptions = enum(i32) {
    E = 1,
};
pub const NTMS_SESSION_QUERYEXPEDITE = NtmsSessionOptions.E;

pub const NtmsMountOptions = enum(i32) {
    READ = 1,
    WRITE = 2,
    ERROR_NOT_AVAILABLE = 4,
    // ERROR_IF_UNAVAILABLE = 4, this enum value conflicts with ERROR_NOT_AVAILABLE
    ERROR_OFFLINE = 8,
    // ERROR_IF_OFFLINE = 8, this enum value conflicts with ERROR_OFFLINE
    SPECIFIC_DRIVE = 16,
    NOWAIT = 32,
};
pub const NTMS_MOUNT_READ = NtmsMountOptions.READ;
pub const NTMS_MOUNT_WRITE = NtmsMountOptions.WRITE;
pub const NTMS_MOUNT_ERROR_NOT_AVAILABLE = NtmsMountOptions.ERROR_NOT_AVAILABLE;
pub const NTMS_MOUNT_ERROR_IF_UNAVAILABLE = NtmsMountOptions.ERROR_NOT_AVAILABLE;
pub const NTMS_MOUNT_ERROR_OFFLINE = NtmsMountOptions.ERROR_OFFLINE;
pub const NTMS_MOUNT_ERROR_IF_OFFLINE = NtmsMountOptions.ERROR_OFFLINE;
pub const NTMS_MOUNT_SPECIFIC_DRIVE = NtmsMountOptions.SPECIFIC_DRIVE;
pub const NTMS_MOUNT_NOWAIT = NtmsMountOptions.NOWAIT;

pub const NtmsDismountOptions = enum(i32) {
    DEFERRED = 1,
    IMMEDIATE = 2,
};
pub const NTMS_DISMOUNT_DEFERRED = NtmsDismountOptions.DEFERRED;
pub const NTMS_DISMOUNT_IMMEDIATE = NtmsDismountOptions.IMMEDIATE;

pub const NtmsMountPriority = enum(i32) {
    DEFAULT = 0,
    HIGHEST = 15,
    HIGH = 7,
    // NORMAL = 0, this enum value conflicts with DEFAULT
    LOW = -7,
    LOWEST = -15,
};
pub const NTMS_PRIORITY_DEFAULT = NtmsMountPriority.DEFAULT;
pub const NTMS_PRIORITY_HIGHEST = NtmsMountPriority.HIGHEST;
pub const NTMS_PRIORITY_HIGH = NtmsMountPriority.HIGH;
pub const NTMS_PRIORITY_NORMAL = NtmsMountPriority.DEFAULT;
pub const NTMS_PRIORITY_LOW = NtmsMountPriority.LOW;
pub const NTMS_PRIORITY_LOWEST = NtmsMountPriority.LOWEST;

pub const NTMS_MOUNT_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: ?*anyopaque,
};

pub const NtmsAllocateOptions = enum(i32) {
    NEW = 1,
    NEXT = 2,
    ERROR_IF_UNAVAILABLE = 4,
};
pub const NTMS_ALLOCATE_NEW = NtmsAllocateOptions.NEW;
pub const NTMS_ALLOCATE_NEXT = NtmsAllocateOptions.NEXT;
pub const NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE = NtmsAllocateOptions.ERROR_IF_UNAVAILABLE;

pub const NTMS_ALLOCATION_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: ?*anyopaque,
    AllocatedFrom: Guid,
};

pub const NtmsCreateOptions = enum(i32) {
    OPEN_EXISTING = 1,
    CREATE_NEW = 2,
    OPEN_ALWAYS = 3,
};
pub const NTMS_OPEN_EXISTING = NtmsCreateOptions.OPEN_EXISTING;
pub const NTMS_CREATE_NEW = NtmsCreateOptions.CREATE_NEW;
pub const NTMS_OPEN_ALWAYS = NtmsCreateOptions.OPEN_ALWAYS;

pub const NtmsDriveState = enum(i32) {
    DISMOUNTED = 0,
    MOUNTED = 1,
    LOADED = 2,
    UNLOADED = 5,
    BEING_CLEANED = 6,
    DISMOUNTABLE = 7,
};
pub const NTMS_DRIVESTATE_DISMOUNTED = NtmsDriveState.DISMOUNTED;
pub const NTMS_DRIVESTATE_MOUNTED = NtmsDriveState.MOUNTED;
pub const NTMS_DRIVESTATE_LOADED = NtmsDriveState.LOADED;
pub const NTMS_DRIVESTATE_UNLOADED = NtmsDriveState.UNLOADED;
pub const NTMS_DRIVESTATE_BEING_CLEANED = NtmsDriveState.BEING_CLEANED;
pub const NTMS_DRIVESTATE_DISMOUNTABLE = NtmsDriveState.DISMOUNTABLE;

pub const NTMS_DRIVEINFORMATIONA = extern struct {
    Number: u32,
    State: NtmsDriveState,
    DriveType: Guid,
    szDeviceName: [64]CHAR,
    szSerialNumber: [32]CHAR,
    szRevision: [32]CHAR,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};

pub const NTMS_DRIVEINFORMATIONW = extern struct {
    Number: u32,
    State: NtmsDriveState,
    DriveType: Guid,
    szDeviceName: [64]u16,
    szSerialNumber: [32]u16,
    szRevision: [32]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};

pub const NtmsLibraryType = enum(i32) {
    UNKNOWN = 0,
    OFFLINE = 1,
    ONLINE = 2,
    STANDALONE = 3,
};
pub const NTMS_LIBRARYTYPE_UNKNOWN = NtmsLibraryType.UNKNOWN;
pub const NTMS_LIBRARYTYPE_OFFLINE = NtmsLibraryType.OFFLINE;
pub const NTMS_LIBRARYTYPE_ONLINE = NtmsLibraryType.ONLINE;
pub const NTMS_LIBRARYTYPE_STANDALONE = NtmsLibraryType.STANDALONE;

pub const NtmsLibraryFlags = enum(i32) {
    FIXEDOFFLINE = 1,
    CLEANERPRESENT = 2,
    AUTODETECTCHANGE = 4,
    IGNORECLEANERUSESREMAINING = 8,
    RECOGNIZECLEANERBARCODE = 16,
};
pub const NTMS_LIBRARYFLAG_FIXEDOFFLINE = NtmsLibraryFlags.FIXEDOFFLINE;
pub const NTMS_LIBRARYFLAG_CLEANERPRESENT = NtmsLibraryFlags.CLEANERPRESENT;
pub const NTMS_LIBRARYFLAG_AUTODETECTCHANGE = NtmsLibraryFlags.AUTODETECTCHANGE;
pub const NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING = NtmsLibraryFlags.IGNORECLEANERUSESREMAINING;
pub const NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE = NtmsLibraryFlags.RECOGNIZECLEANERBARCODE;

pub const NtmsInventoryMethod = enum(i32) {
    NONE = 0,
    FAST = 1,
    OMID = 2,
    DEFAULT = 3,
    SLOT = 4,
    STOP = 5,
    MAX = 6,
};
pub const NTMS_INVENTORY_NONE = NtmsInventoryMethod.NONE;
pub const NTMS_INVENTORY_FAST = NtmsInventoryMethod.FAST;
pub const NTMS_INVENTORY_OMID = NtmsInventoryMethod.OMID;
pub const NTMS_INVENTORY_DEFAULT = NtmsInventoryMethod.DEFAULT;
pub const NTMS_INVENTORY_SLOT = NtmsInventoryMethod.SLOT;
pub const NTMS_INVENTORY_STOP = NtmsInventoryMethod.STOP;
pub const NTMS_INVENTORY_MAX = NtmsInventoryMethod.MAX;

pub const NTMS_LIBRARYINFORMATION = extern struct {
    LibraryType: NtmsLibraryType,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: NtmsInventoryMethod,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
    AutoRecovery: BOOL,
    dwFlags: NtmsLibraryFlags,
};

pub const NTMS_CHANGERINFORMATIONA = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: [32]CHAR,
    szRevision: [32]CHAR,
    szDeviceName: [64]CHAR,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};

pub const NTMS_CHANGERINFORMATIONW = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: [32]u16,
    szRevision: [32]u16,
    szDeviceName: [64]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};

pub const NtmsSlotState = enum(i32) {
    UNKNOWN = 0,
    FULL = 1,
    EMPTY = 2,
    NOTPRESENT = 3,
    NEEDSINVENTORY = 4,
};
pub const NTMS_SLOTSTATE_UNKNOWN = NtmsSlotState.UNKNOWN;
pub const NTMS_SLOTSTATE_FULL = NtmsSlotState.FULL;
pub const NTMS_SLOTSTATE_EMPTY = NtmsSlotState.EMPTY;
pub const NTMS_SLOTSTATE_NOTPRESENT = NtmsSlotState.NOTPRESENT;
pub const NTMS_SLOTSTATE_NEEDSINVENTORY = NtmsSlotState.NEEDSINVENTORY;

pub const NTMS_STORAGESLOTINFORMATION = extern struct {
    Number: u32,
    State: u32,
    Library: Guid,
};

pub const NtmsDoorState = enum(i32) {
    UNKNOWN = 0,
    CLOSED = 1,
    OPEN = 2,
};
pub const NTMS_DOORSTATE_UNKNOWN = NtmsDoorState.UNKNOWN;
pub const NTMS_DOORSTATE_CLOSED = NtmsDoorState.CLOSED;
pub const NTMS_DOORSTATE_OPEN = NtmsDoorState.OPEN;

pub const NTMS_IEDOORINFORMATION = extern struct {
    Number: u32,
    State: NtmsDoorState,
    MaxOpenSecs: u16,
    Library: Guid,
};

pub const NtmsPortPosition = enum(i32) {
    UNKNOWN = 0,
    EXTENDED = 1,
    RETRACTED = 2,
};
pub const NTMS_PORTPOSITION_UNKNOWN = NtmsPortPosition.UNKNOWN;
pub const NTMS_PORTPOSITION_EXTENDED = NtmsPortPosition.EXTENDED;
pub const NTMS_PORTPOSITION_RETRACTED = NtmsPortPosition.RETRACTED;

pub const NtmsPortContent = enum(i32) {
    UNKNOWN = 0,
    FULL = 1,
    EMPTY = 2,
};
pub const NTMS_PORTCONTENT_UNKNOWN = NtmsPortContent.UNKNOWN;
pub const NTMS_PORTCONTENT_FULL = NtmsPortContent.FULL;
pub const NTMS_PORTCONTENT_EMPTY = NtmsPortContent.EMPTY;

pub const NTMS_IEPORTINFORMATION = extern struct {
    Number: u32,
    Content: NtmsPortContent,
    Position: NtmsPortPosition,
    MaxExtendSecs: u16,
    Library: Guid,
};

pub const NtmsBarCodeState = enum(i32) {
    OK = 1,
    UNREADABLE = 2,
};
pub const NTMS_BARCODESTATE_OK = NtmsBarCodeState.OK;
pub const NTMS_BARCODESTATE_UNREADABLE = NtmsBarCodeState.UNREADABLE;

pub const NtmsMediaState = enum(i32) {
    IDLE = 0,
    INUSE = 1,
    MOUNTED = 2,
    LOADED = 3,
    UNLOADED = 4,
    OPERROR = 5,
    OPREQ = 6,
};
pub const NTMS_MEDIASTATE_IDLE = NtmsMediaState.IDLE;
pub const NTMS_MEDIASTATE_INUSE = NtmsMediaState.INUSE;
pub const NTMS_MEDIASTATE_MOUNTED = NtmsMediaState.MOUNTED;
pub const NTMS_MEDIASTATE_LOADED = NtmsMediaState.LOADED;
pub const NTMS_MEDIASTATE_UNLOADED = NtmsMediaState.UNLOADED;
pub const NTMS_MEDIASTATE_OPERROR = NtmsMediaState.OPERROR;
pub const NTMS_MEDIASTATE_OPREQ = NtmsMediaState.OPREQ;

pub const NTMS_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]CHAR,
    BarCodeState: NtmsBarCodeState,
    szSequenceNumber: [32]CHAR,
    MediaState: NtmsMediaState,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};

pub const NTMS_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]u16,
    BarCodeState: NtmsBarCodeState,
    szSequenceNumber: [32]u16,
    MediaState: NtmsMediaState,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};

pub const NTMS_LMIDINFORMATION = extern struct {
    MediaPool: Guid,
    dwNumberOfPartitions: u32,
};

pub const NtmsPartitionState = enum(i32) {
    UNKNOWN = 0,
    UNPREPARED = 1,
    INCOMPATIBLE = 2,
    DECOMMISSIONED = 3,
    AVAILABLE = 4,
    ALLOCATED = 5,
    COMPLETE = 6,
    FOREIGN = 7,
    IMPORT = 8,
    RESERVED = 9,
};
pub const NTMS_PARTSTATE_UNKNOWN = NtmsPartitionState.UNKNOWN;
pub const NTMS_PARTSTATE_UNPREPARED = NtmsPartitionState.UNPREPARED;
pub const NTMS_PARTSTATE_INCOMPATIBLE = NtmsPartitionState.INCOMPATIBLE;
pub const NTMS_PARTSTATE_DECOMMISSIONED = NtmsPartitionState.DECOMMISSIONED;
pub const NTMS_PARTSTATE_AVAILABLE = NtmsPartitionState.AVAILABLE;
pub const NTMS_PARTSTATE_ALLOCATED = NtmsPartitionState.ALLOCATED;
pub const NTMS_PARTSTATE_COMPLETE = NtmsPartitionState.COMPLETE;
pub const NTMS_PARTSTATE_FOREIGN = NtmsPartitionState.FOREIGN;
pub const NTMS_PARTSTATE_IMPORT = NtmsPartitionState.IMPORT;
pub const NTMS_PARTSTATE_RESERVED = NtmsPartitionState.RESERVED;

pub const NTMS_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: NtmsPartitionState,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]CHAR,
    szOmidLabelInfo: [256]CHAR,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};

pub const NTMS_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: NtmsPartitionState,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]u16,
    szOmidLabelInfo: [256]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};

pub const NtmsPoolType = enum(i32) {
    UNKNOWN = 0,
    SCRATCH = 1,
    FOREIGN = 2,
    IMPORT = 3,
    APPLICATION = 1000,
};
pub const NTMS_POOLTYPE_UNKNOWN = NtmsPoolType.UNKNOWN;
pub const NTMS_POOLTYPE_SCRATCH = NtmsPoolType.SCRATCH;
pub const NTMS_POOLTYPE_FOREIGN = NtmsPoolType.FOREIGN;
pub const NTMS_POOLTYPE_IMPORT = NtmsPoolType.IMPORT;
pub const NTMS_POOLTYPE_APPLICATION = NtmsPoolType.APPLICATION;

pub const NtmsAllocationPolicy = enum(i32) {
    H = 1,
};
pub const NTMS_ALLOCATE_FROMSCRATCH = NtmsAllocationPolicy.H;

pub const NtmsDeallocationPolicy = enum(i32) {
    H = 1,
};
pub const NTMS_DEALLOCATE_TOSCRATCH = NtmsDeallocationPolicy.H;

pub const NTMS_MEDIAPOOLINFORMATION = extern struct {
    PoolType: u32,
    MediaType: Guid,
    Parent: Guid,
    AllocationPolicy: u32,
    DeallocationPolicy: u32,
    dwMaxAllocates: u32,
    dwNumberOfPhysicalMedia: u32,
    dwNumberOfLogicalMedia: u32,
    dwNumberOfMediaPools: u32,
};

pub const NtmsReadWriteCharacteristics = enum(i32) {
    UNKNOWN = 0,
    REWRITABLE = 1,
    WRITEONCE = 2,
    READONLY = 3,
};
pub const NTMS_MEDIARW_UNKNOWN = NtmsReadWriteCharacteristics.UNKNOWN;
pub const NTMS_MEDIARW_REWRITABLE = NtmsReadWriteCharacteristics.REWRITABLE;
pub const NTMS_MEDIARW_WRITEONCE = NtmsReadWriteCharacteristics.WRITEONCE;
pub const NTMS_MEDIARW_READONLY = NtmsReadWriteCharacteristics.READONLY;

pub const NTMS_MEDIATYPEINFORMATION = extern struct {
    MediaType: u32,
    NumberOfSides: u32,
    ReadWriteCharacteristics: NtmsReadWriteCharacteristics,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_DRIVETYPEINFORMATIONA = extern struct {
    szVendor: [128]CHAR,
    szProduct: [128]CHAR,
    NumberOfHeads: u32,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_DRIVETYPEINFORMATIONW = extern struct {
    szVendor: [128]u16,
    szProduct: [128]u16,
    NumberOfHeads: u32,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_CHANGERTYPEINFORMATIONA = extern struct {
    szVendor: [128]CHAR,
    szProduct: [128]CHAR,
    DeviceType: u32,
};

pub const NTMS_CHANGERTYPEINFORMATIONW = extern struct {
    szVendor: [128]u16,
    szProduct: [128]u16,
    DeviceType: u32,
};

pub const NtmsLmOperation = enum(i32) {
    REMOVE = 0,
    DISABLECHANGER = 1,
    // DISABLELIBRARY = 1, this enum value conflicts with DISABLECHANGER
    ENABLECHANGER = 2,
    // ENABLELIBRARY = 2, this enum value conflicts with ENABLECHANGER
    DISABLEDRIVE = 3,
    ENABLEDRIVE = 4,
    DISABLEMEDIA = 5,
    ENABLEMEDIA = 6,
    UPDATEOMID = 7,
    INVENTORY = 8,
    DOORACCESS = 9,
    EJECT = 10,
    EJECTCLEANER = 11,
    INJECT = 12,
    INJECTCLEANER = 13,
    PROCESSOMID = 14,
    CLEANDRIVE = 15,
    DISMOUNT = 16,
    MOUNT = 17,
    WRITESCRATCH = 18,
    CLASSIFY = 19,
    RESERVECLEANER = 20,
    RELEASECLEANER = 21,
    MAXWORKITEM = 22,
};
pub const NTMS_LM_REMOVE = NtmsLmOperation.REMOVE;
pub const NTMS_LM_DISABLECHANGER = NtmsLmOperation.DISABLECHANGER;
pub const NTMS_LM_DISABLELIBRARY = NtmsLmOperation.DISABLECHANGER;
pub const NTMS_LM_ENABLECHANGER = NtmsLmOperation.ENABLECHANGER;
pub const NTMS_LM_ENABLELIBRARY = NtmsLmOperation.ENABLECHANGER;
pub const NTMS_LM_DISABLEDRIVE = NtmsLmOperation.DISABLEDRIVE;
pub const NTMS_LM_ENABLEDRIVE = NtmsLmOperation.ENABLEDRIVE;
pub const NTMS_LM_DISABLEMEDIA = NtmsLmOperation.DISABLEMEDIA;
pub const NTMS_LM_ENABLEMEDIA = NtmsLmOperation.ENABLEMEDIA;
pub const NTMS_LM_UPDATEOMID = NtmsLmOperation.UPDATEOMID;
pub const NTMS_LM_INVENTORY = NtmsLmOperation.INVENTORY;
pub const NTMS_LM_DOORACCESS = NtmsLmOperation.DOORACCESS;
pub const NTMS_LM_EJECT = NtmsLmOperation.EJECT;
pub const NTMS_LM_EJECTCLEANER = NtmsLmOperation.EJECTCLEANER;
pub const NTMS_LM_INJECT = NtmsLmOperation.INJECT;
pub const NTMS_LM_INJECTCLEANER = NtmsLmOperation.INJECTCLEANER;
pub const NTMS_LM_PROCESSOMID = NtmsLmOperation.PROCESSOMID;
pub const NTMS_LM_CLEANDRIVE = NtmsLmOperation.CLEANDRIVE;
pub const NTMS_LM_DISMOUNT = NtmsLmOperation.DISMOUNT;
pub const NTMS_LM_MOUNT = NtmsLmOperation.MOUNT;
pub const NTMS_LM_WRITESCRATCH = NtmsLmOperation.WRITESCRATCH;
pub const NTMS_LM_CLASSIFY = NtmsLmOperation.CLASSIFY;
pub const NTMS_LM_RESERVECLEANER = NtmsLmOperation.RESERVECLEANER;
pub const NTMS_LM_RELEASECLEANER = NtmsLmOperation.RELEASECLEANER;
pub const NTMS_LM_MAXWORKITEM = NtmsLmOperation.MAXWORKITEM;

pub const NtmsLmState = enum(i32) {
    QUEUED = 0,
    INPROCESS = 1,
    PASSED = 2,
    FAILED = 3,
    INVALID = 4,
    WAITING = 5,
    DEFERRED = 6,
    // DEFFERED = 6, this enum value conflicts with DEFERRED
    CANCELLED = 7,
    STOPPED = 8,
};
pub const NTMS_LM_QUEUED = NtmsLmState.QUEUED;
pub const NTMS_LM_INPROCESS = NtmsLmState.INPROCESS;
pub const NTMS_LM_PASSED = NtmsLmState.PASSED;
pub const NTMS_LM_FAILED = NtmsLmState.FAILED;
pub const NTMS_LM_INVALID = NtmsLmState.INVALID;
pub const NTMS_LM_WAITING = NtmsLmState.WAITING;
pub const NTMS_LM_DEFERRED = NtmsLmState.DEFERRED;
pub const NTMS_LM_DEFFERED = NtmsLmState.DEFERRED;
pub const NTMS_LM_CANCELLED = NtmsLmState.CANCELLED;
pub const NTMS_LM_STOPPED = NtmsLmState.STOPPED;

pub const NTMS_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: NtmsLmOperation,
    OperationOption: u32,
    State: NtmsLmState,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};

pub const NTMS_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: NtmsLmOperation,
    OperationOption: u32,
    State: NtmsLmState,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};

pub const NtmsOpreqCommand = enum(i32) {
    UNKNOWN = 0,
    NEWMEDIA = 1,
    CLEANER = 2,
    DEVICESERVICE = 3,
    MOVEMEDIA = 4,
    MESSAGE = 5,
};
pub const NTMS_OPREQ_UNKNOWN = NtmsOpreqCommand.UNKNOWN;
pub const NTMS_OPREQ_NEWMEDIA = NtmsOpreqCommand.NEWMEDIA;
pub const NTMS_OPREQ_CLEANER = NtmsOpreqCommand.CLEANER;
pub const NTMS_OPREQ_DEVICESERVICE = NtmsOpreqCommand.DEVICESERVICE;
pub const NTMS_OPREQ_MOVEMEDIA = NtmsOpreqCommand.MOVEMEDIA;
pub const NTMS_OPREQ_MESSAGE = NtmsOpreqCommand.MESSAGE;

pub const NtmsOpreqState = enum(i32) {
    UNKNOWN = 0,
    SUBMITTED = 1,
    ACTIVE = 2,
    INPROGRESS = 3,
    REFUSED = 4,
    COMPLETE = 5,
};
pub const NTMS_OPSTATE_UNKNOWN = NtmsOpreqState.UNKNOWN;
pub const NTMS_OPSTATE_SUBMITTED = NtmsOpreqState.SUBMITTED;
pub const NTMS_OPSTATE_ACTIVE = NtmsOpreqState.ACTIVE;
pub const NTMS_OPSTATE_INPROGRESS = NtmsOpreqState.INPROGRESS;
pub const NTMS_OPSTATE_REFUSED = NtmsOpreqState.REFUSED;
pub const NTMS_OPSTATE_COMPLETE = NtmsOpreqState.COMPLETE;

pub const NTMS_OPREQUESTINFORMATIONA = extern struct {
    Request: NtmsOpreqCommand,
    Submitted: SYSTEMTIME,
    State: NtmsOpreqState,
    szMessage: [256]CHAR,
    Arg1Type: NtmsObjectsTypes,
    Arg1: Guid,
    Arg2Type: NtmsObjectsTypes,
    Arg2: Guid,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_OPREQUESTINFORMATIONW = extern struct {
    Request: NtmsOpreqCommand,
    Submitted: SYSTEMTIME,
    State: NtmsOpreqState,
    szMessage: [256]u16,
    Arg1Type: NtmsObjectsTypes,
    Arg1: Guid,
    Arg2Type: NtmsObjectsTypes,
    Arg2: Guid,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_COMPUTERINFORMATION = extern struct {
    dwLibRequestPurgeTime: u32,
    dwOpRequestPurgeTime: u32,
    dwLibRequestFlags: u32,
    dwOpRequestFlags: u32,
    dwMediaPoolPolicy: u32,
};

pub const NtmsLibRequestFlags = enum(i32) {
    AUTOPURGE = 1,
    FAILEDPURGE = 2,
};
pub const NTMS_LIBREQFLAGS_NOAUTOPURGE = NtmsLibRequestFlags.AUTOPURGE;
pub const NTMS_LIBREQFLAGS_NOFAILEDPURGE = NtmsLibRequestFlags.FAILEDPURGE;

pub const NtmsOpRequestFlags = enum(i32) {
    AUTOPURGE = 1,
    FAILEDPURGE = 2,
    ALERTS = 16,
    TRAYICON = 32,
};
pub const NTMS_OPREQFLAGS_NOAUTOPURGE = NtmsOpRequestFlags.AUTOPURGE;
pub const NTMS_OPREQFLAGS_NOFAILEDPURGE = NtmsOpRequestFlags.FAILEDPURGE;
pub const NTMS_OPREQFLAGS_NOALERTS = NtmsOpRequestFlags.ALERTS;
pub const NTMS_OPREQFLAGS_NOTRAYICON = NtmsOpRequestFlags.TRAYICON;

pub const NtmsMediaPoolPolicy = enum(i32) {
    PURGEOFFLINESCRATCH = 1,
    KEEPOFFLINEIMPORT = 2,
};
pub const NTMS_POOLPOLICY_PURGEOFFLINESCRATCH = NtmsMediaPoolPolicy.PURGEOFFLINESCRATCH;
pub const NTMS_POOLPOLICY_KEEPOFFLINEIMPORT = NtmsMediaPoolPolicy.KEEPOFFLINEIMPORT;

pub const NtmsOperationalState = enum(i32) {
    READY = 0,
    INITIALIZING = 10,
    NEEDS_SERVICE = 20,
    NOT_PRESENT = 21,
};
pub const NTMS_READY = NtmsOperationalState.READY;
pub const NTMS_INITIALIZING = NtmsOperationalState.INITIALIZING;
pub const NTMS_NEEDS_SERVICE = NtmsOperationalState.NEEDS_SERVICE;
pub const NTMS_NOT_PRESENT = NtmsOperationalState.NOT_PRESENT;

pub const NTMS_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: NtmsObjectsTypes,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: NtmsOperationalState,
    szName: [64]CHAR,
    szDescription: [127]CHAR,
    Info: extern union {
        Drive: NTMS_DRIVEINFORMATIONA,
        DriveType: NTMS_DRIVETYPEINFORMATIONA,
        Library: NTMS_LIBRARYINFORMATION,
        Changer: NTMS_CHANGERINFORMATIONA,
        ChangerType: NTMS_CHANGERTYPEINFORMATIONA,
        StorageSlot: NTMS_STORAGESLOTINFORMATION,
        IEDoor: NTMS_IEDOORINFORMATION,
        IEPort: NTMS_IEPORTINFORMATION,
        PhysicalMedia: NTMS_PMIDINFORMATIONA,
        LogicalMedia: NTMS_LMIDINFORMATION,
        Partition: NTMS_PARTITIONINFORMATIONA,
        MediaPool: NTMS_MEDIAPOOLINFORMATION,
        MediaType: NTMS_MEDIATYPEINFORMATION,
        LibRequest: NTMS_LIBREQUESTINFORMATIONA,
        OpRequest: NTMS_OPREQUESTINFORMATIONA,
        Computer: NTMS_COMPUTERINFORMATION,
    },
};

pub const NTMS_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: NtmsObjectsTypes,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: NtmsOperationalState,
    szName: [64]u16,
    szDescription: [127]u16,
    Info: extern union {
        Drive: NTMS_DRIVEINFORMATIONW,
        DriveType: NTMS_DRIVETYPEINFORMATIONW,
        Library: NTMS_LIBRARYINFORMATION,
        Changer: NTMS_CHANGERINFORMATIONW,
        ChangerType: NTMS_CHANGERTYPEINFORMATIONW,
        StorageSlot: NTMS_STORAGESLOTINFORMATION,
        IEDoor: NTMS_IEDOORINFORMATION,
        IEPort: NTMS_IEPORTINFORMATION,
        PhysicalMedia: NTMS_PMIDINFORMATIONW,
        LogicalMedia: NTMS_LMIDINFORMATION,
        Partition: NTMS_PARTITIONINFORMATIONW,
        MediaPool: NTMS_MEDIAPOOLINFORMATION,
        MediaType: NTMS_MEDIATYPEINFORMATION,
        LibRequest: NTMS_LIBREQUESTINFORMATIONW,
        OpRequest: NTMS_OPREQUESTINFORMATIONW,
        Computer: NTMS_COMPUTERINFORMATION,
    },
};

pub const NTMS_I1_LIBRARYINFORMATION = extern struct {
    LibraryType: u32,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: u32,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
};

pub const NTMS_I1_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_I1_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_I1_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]CHAR,
    BarCodeState: u32,
    szSequenceNumber: [32]CHAR,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};

pub const NTMS_I1_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]u16,
    BarCodeState: u32,
    szSequenceNumber: [32]u16,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};

pub const NTMS_I1_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]CHAR,
    szOmidLabelInfo: [256]CHAR,
    dwMountCount: u32,
    dwAllocateCount: u32,
};

pub const NTMS_I1_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]u16,
    szOmidLabelInfo: [256]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
};

pub const NTMS_I1_OPREQUESTINFORMATIONA = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: [127]CHAR,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_I1_OPREQUESTINFORMATIONW = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: [127]u16,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_I1_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: [64]CHAR,
    szDescription: [127]CHAR,
    Info: extern union {
        Drive: NTMS_DRIVEINFORMATIONA,
        DriveType: NTMS_DRIVETYPEINFORMATIONA,
        Library: NTMS_I1_LIBRARYINFORMATION,
        Changer: NTMS_CHANGERINFORMATIONA,
        ChangerType: NTMS_CHANGERTYPEINFORMATIONA,
        StorageSlot: NTMS_STORAGESLOTINFORMATION,
        IEDoor: NTMS_IEDOORINFORMATION,
        IEPort: NTMS_IEPORTINFORMATION,
        PhysicalMedia: NTMS_I1_PMIDINFORMATIONA,
        LogicalMedia: NTMS_LMIDINFORMATION,
        Partition: NTMS_I1_PARTITIONINFORMATIONA,
        MediaPool: NTMS_MEDIAPOOLINFORMATION,
        MediaType: NTMS_MEDIATYPEINFORMATION,
        LibRequest: NTMS_I1_LIBREQUESTINFORMATIONA,
        OpRequest: NTMS_I1_OPREQUESTINFORMATIONA,
    },
};

pub const NTMS_I1_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: [64]u16,
    szDescription: [127]u16,
    Info: extern union {
        Drive: NTMS_DRIVEINFORMATIONW,
        DriveType: NTMS_DRIVETYPEINFORMATIONW,
        Library: NTMS_I1_LIBRARYINFORMATION,
        Changer: NTMS_CHANGERINFORMATIONW,
        ChangerType: NTMS_CHANGERTYPEINFORMATIONW,
        StorageSlot: NTMS_STORAGESLOTINFORMATION,
        IEDoor: NTMS_IEDOORINFORMATION,
        IEPort: NTMS_IEPORTINFORMATION,
        PhysicalMedia: NTMS_I1_PMIDINFORMATIONW,
        LogicalMedia: NTMS_LMIDINFORMATION,
        Partition: NTMS_I1_PARTITIONINFORMATIONW,
        MediaPool: NTMS_MEDIAPOOLINFORMATION,
        MediaType: NTMS_MEDIATYPEINFORMATION,
        LibRequest: NTMS_I1_LIBREQUESTINFORMATIONW,
        OpRequest: NTMS_I1_OPREQUESTINFORMATIONW,
    },
};

pub const NtmsCreateNtmsMediaOptions = enum(i32) {
    E = 1,
};
pub const NTMS_ERROR_ON_DUPLICATE = NtmsCreateNtmsMediaOptions.E;

pub const NtmsEnumerateOption = enum(i32) {
    DEFAULT = 0,
    ROOTPOOL = 1,
};
pub const NTMS_ENUM_DEFAULT = NtmsEnumerateOption.DEFAULT;
pub const NTMS_ENUM_ROOTPOOL = NtmsEnumerateOption.ROOTPOOL;

pub const NtmsEjectOperation = enum(i32) {
    START = 0,
    STOP = 1,
    QUEUE = 2,
    FORCE = 3,
    IMMEDIATE = 4,
    ASK_USER = 5,
};
pub const NTMS_EJECT_START = NtmsEjectOperation.START;
pub const NTMS_EJECT_STOP = NtmsEjectOperation.STOP;
pub const NTMS_EJECT_QUEUE = NtmsEjectOperation.QUEUE;
pub const NTMS_EJECT_FORCE = NtmsEjectOperation.FORCE;
pub const NTMS_EJECT_IMMEDIATE = NtmsEjectOperation.IMMEDIATE;
pub const NTMS_EJECT_ASK_USER = NtmsEjectOperation.ASK_USER;

pub const NtmsInjectOperation = enum(i32) {
    START = 0,
    STOP = 1,
    RETRACT = 2,
    STARTMANY = 3,
};
pub const NTMS_INJECT_START = NtmsInjectOperation.START;
pub const NTMS_INJECT_STOP = NtmsInjectOperation.STOP;
pub const NTMS_INJECT_RETRACT = NtmsInjectOperation.RETRACT;
pub const NTMS_INJECT_STARTMANY = NtmsInjectOperation.STARTMANY;

pub const NTMS_FILESYSTEM_INFO = extern struct {
    FileSystemType: [64]u16,
    VolumeName: [256]u16,
    SerialNumber: u32,
};

pub const NtmsDriveType = enum(i32) {
    E = 0,
};
pub const NTMS_UNKNOWN_DRIVE = NtmsDriveType.E;

pub const NtmsAccessMask = enum(i32) {
    USE_ACCESS = 1,
    MODIFY_ACCESS = 2,
    CONTROL_ACCESS = 4,
};
pub const NTMS_USE_ACCESS = NtmsAccessMask.USE_ACCESS;
pub const NTMS_MODIFY_ACCESS = NtmsAccessMask.MODIFY_ACCESS;
pub const NTMS_CONTROL_ACCESS = NtmsAccessMask.CONTROL_ACCESS;

pub const NtmsUITypes = enum(i32) {
    INVALID = 0,
    INFO = 1,
    REQ = 2,
    ERR = 3,
    MAX = 4,
};
pub const NTMS_UITYPE_INVALID = NtmsUITypes.INVALID;
pub const NTMS_UITYPE_INFO = NtmsUITypes.INFO;
pub const NTMS_UITYPE_REQ = NtmsUITypes.REQ;
pub const NTMS_UITYPE_ERR = NtmsUITypes.ERR;
pub const NTMS_UITYPE_MAX = NtmsUITypes.MAX;

pub const NtmsUIOperations = enum(i32) {
    DEST_ADD = 1,
    DEST_DELETE = 2,
    DEST_DELETEALL = 3,
    OPERATION_MAX = 4,
};
pub const NTMS_UIDEST_ADD = NtmsUIOperations.DEST_ADD;
pub const NTMS_UIDEST_DELETE = NtmsUIOperations.DEST_DELETE;
pub const NTMS_UIDEST_DELETEALL = NtmsUIOperations.DEST_DELETEALL;
pub const NTMS_UIOPERATION_MAX = NtmsUIOperations.OPERATION_MAX;

pub const NtmsNotificationOperations = enum(i32) {
    OBJ_UPDATE = 1,
    OBJ_INSERT = 2,
    OBJ_DELETE = 3,
    EVENT_SIGNAL = 4,
    EVENT_COMPLETE = 5,
};
pub const NTMS_OBJ_UPDATE = NtmsNotificationOperations.OBJ_UPDATE;
pub const NTMS_OBJ_INSERT = NtmsNotificationOperations.OBJ_INSERT;
pub const NTMS_OBJ_DELETE = NtmsNotificationOperations.OBJ_DELETE;
pub const NTMS_EVENT_SIGNAL = NtmsNotificationOperations.EVENT_SIGNAL;
pub const NTMS_EVENT_COMPLETE = NtmsNotificationOperations.EVENT_COMPLETE;

pub const NTMS_NOTIFICATIONINFORMATION = extern struct {
    dwOperation: NtmsNotificationOperations,
    ObjectId: Guid,
};

pub const MediaLabelInfo = extern struct {
    LabelType: [64]u16,
    LabelIDSize: u32,
    LabelID: [256]u8,
    LabelAppDescr: [256]u16,
};

pub const MAXMEDIALABEL = *const fn (
    p_max_size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLAIMMEDIALABEL = *const fn (
    p_buffer: ?*const u8,
    n_buffer_size: u32,
    p_label_info: ?*MediaLabelInfo,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLAIMMEDIALABELEX = *const fn (
    p_buffer: ?*const u8,
    n_buffer_size: u32,
    p_label_info: ?*MediaLabelInfo,
    label_guid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLS_LSN = extern struct {
    Internal: u64,
};

pub const CLS_CONTEXT_MODE = enum(i32) {
    None = 0,
    UndoNext = 1,
    Previous = 2,
    Forward = 3,
};
pub const ClsContextNone = CLS_CONTEXT_MODE.None;
pub const ClsContextUndoNext = CLS_CONTEXT_MODE.UndoNext;
pub const ClsContextPrevious = CLS_CONTEXT_MODE.Previous;
pub const ClsContextForward = CLS_CONTEXT_MODE.Forward;

pub const CLFS_CONTEXT_MODE = enum(i32) {
    None = 0,
    UndoNext = 1,
    Previous = 2,
    Forward = 3,
};
pub const ClfsContextNone = CLFS_CONTEXT_MODE.None;
pub const ClfsContextUndoNext = CLFS_CONTEXT_MODE.UndoNext;
pub const ClfsContextPrevious = CLFS_CONTEXT_MODE.Previous;
pub const ClfsContextForward = CLFS_CONTEXT_MODE.Forward;

pub const CLFS_NODE_ID = extern struct {
    cType: u32,
    cbNode: u32,
};

pub const CLS_WRITE_ENTRY = extern struct {
    Buffer: ?*anyopaque,
    ByteLength: u32,
};

pub const CLS_INFORMATION = extern struct {
    TotalAvailable: i64,
    CurrentAvailable: i64,
    TotalReservation: i64,
    BaseFileSize: u64,
    ContainerSize: u64,
    TotalContainers: u32,
    FreeContainers: u32,
    TotalClients: u32,
    Attributes: u32,
    FlushThreshold: u32,
    SectorSize: u32,
    MinArchiveTailLsn: CLS_LSN,
    BaseLsn: CLS_LSN,
    LastFlushedLsn: CLS_LSN,
    LastLsn: CLS_LSN,
    RestartLsn: CLS_LSN,
    Identity: Guid,
};

pub const CLFS_LOG_NAME_INFORMATION = extern struct {
    NameLengthInBytes: u16,
    Name: [1]u16,
};

pub const CLFS_STREAM_ID_INFORMATION = extern struct {
    StreamIdentifier: u8,
};

pub const CLFS_PHYSICAL_LSN_INFORMATION = extern struct {
    StreamIdentifier: u8,
    VirtualLsn: CLS_LSN,
    PhysicalLsn: CLS_LSN,
};

pub const CLS_CONTAINER_INFORMATION = extern struct {
    FileAttributes: u32,
    CreationTime: u64,
    LastAccessTime: u64,
    LastWriteTime: u64,
    ContainerSize: i64,
    FileNameActualLength: u32,
    FileNameLength: u32,
    FileName: [256]u16,
    State: u32,
    PhysicalContainerId: u32,
    LogicalContainerId: u32,
};

pub const CLS_LOG_INFORMATION_CLASS = enum(i32) {
    BasicInformation = 0,
    BasicInformationPhysical = 1,
    PhysicalNameInformation = 2,
    StreamIdentifierInformation = 3,
    SystemMarkingInformation = 4,
    PhysicalLsnInformation = 5,
};
pub const ClfsLogBasicInformation = CLS_LOG_INFORMATION_CLASS.BasicInformation;
pub const ClfsLogBasicInformationPhysical = CLS_LOG_INFORMATION_CLASS.BasicInformationPhysical;
pub const ClfsLogPhysicalNameInformation = CLS_LOG_INFORMATION_CLASS.PhysicalNameInformation;
pub const ClfsLogStreamIdentifierInformation = CLS_LOG_INFORMATION_CLASS.StreamIdentifierInformation;
pub const ClfsLogSystemMarkingInformation = CLS_LOG_INFORMATION_CLASS.SystemMarkingInformation;
pub const ClfsLogPhysicalLsnInformation = CLS_LOG_INFORMATION_CLASS.PhysicalLsnInformation;

pub const CLS_IOSTATS_CLASS = enum(i32) {
    Default = 0,
    Max = 65535,
};
pub const ClsIoStatsDefault = CLS_IOSTATS_CLASS.Default;
pub const ClsIoStatsMax = CLS_IOSTATS_CLASS.Max;

pub const CLFS_IOSTATS_CLASS = enum(i32) {
    Default = 0,
    Max = 65535,
};
pub const ClfsIoStatsDefault = CLFS_IOSTATS_CLASS.Default;
pub const ClfsIoStatsMax = CLFS_IOSTATS_CLASS.Max;

pub const CLS_IO_STATISTICS_HEADER = extern struct {
    ubMajorVersion: u8,
    ubMinorVersion: u8,
    eStatsClass: CLFS_IOSTATS_CLASS,
    cbLength: u16,
    coffData: u32,
};

pub const CLS_IO_STATISTICS = extern struct {
    hdrIoStats: CLS_IO_STATISTICS_HEADER,
    cFlush: u64,
    cbFlush: u64,
    cMetaFlush: u64,
    cbMetaFlush: u64,
};

pub const CLS_SCAN_CONTEXT = extern struct {
    cidNode: CLFS_NODE_ID,
    hLog: ?HANDLE,
    cIndex: u32,
    cContainers: u32,
    cContainersReturned: u32,
    eScanMode: u8,
    pinfoContainer: ?*CLS_CONTAINER_INFORMATION,
};

pub const CLS_ARCHIVE_DESCRIPTOR = extern struct {
    coffLow: u64,
    coffHigh: u64,
    infoContainer: CLS_CONTAINER_INFORMATION,
};

pub const CLFS_BLOCK_ALLOCATION = *const fn (
    cb_buffer_length: u32,
    pv_user_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const CLFS_BLOCK_DEALLOCATION = *const fn (
    pv_buffer: ?*anyopaque,
    pv_user_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CLFS_LOG_ARCHIVE_MODE = enum(i32) {
    Enabled = 1,
    Disabled = 2,
};
pub const ClfsLogArchiveEnabled = CLFS_LOG_ARCHIVE_MODE.Enabled;
pub const ClfsLogArchiveDisabled = CLFS_LOG_ARCHIVE_MODE.Disabled;

pub const PCLFS_COMPLETION_ROUTINE = *const fn (
    pv_overlapped: ?*anyopaque,
    ul_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CLFS_MGMT_POLICY_TYPE = enum(i32) {
    MaximumSize = 0,
    MinimumSize = 1,
    NewContainerSize = 2,
    GrowthRate = 3,
    LogTail = 4,
    AutoShrink = 5,
    AutoGrow = 6,
    NewContainerPrefix = 7,
    NewContainerSuffix = 8,
    NewContainerExtension = 9,
    Invalid = 10,
};
pub const ClfsMgmtPolicyMaximumSize = CLFS_MGMT_POLICY_TYPE.MaximumSize;
pub const ClfsMgmtPolicyMinimumSize = CLFS_MGMT_POLICY_TYPE.MinimumSize;
pub const ClfsMgmtPolicyNewContainerSize = CLFS_MGMT_POLICY_TYPE.NewContainerSize;
pub const ClfsMgmtPolicyGrowthRate = CLFS_MGMT_POLICY_TYPE.GrowthRate;
pub const ClfsMgmtPolicyLogTail = CLFS_MGMT_POLICY_TYPE.LogTail;
pub const ClfsMgmtPolicyAutoShrink = CLFS_MGMT_POLICY_TYPE.AutoShrink;
pub const ClfsMgmtPolicyAutoGrow = CLFS_MGMT_POLICY_TYPE.AutoGrow;
pub const ClfsMgmtPolicyNewContainerPrefix = CLFS_MGMT_POLICY_TYPE.NewContainerPrefix;
pub const ClfsMgmtPolicyNewContainerSuffix = CLFS_MGMT_POLICY_TYPE.NewContainerSuffix;
pub const ClfsMgmtPolicyNewContainerExtension = CLFS_MGMT_POLICY_TYPE.NewContainerExtension;
pub const ClfsMgmtPolicyInvalid = CLFS_MGMT_POLICY_TYPE.Invalid;

pub const CLFS_MGMT_POLICY = extern struct {
    Version: u32,
    LengthInBytes: u32,
    PolicyFlags: u32,
    PolicyType: CLFS_MGMT_POLICY_TYPE,
    PolicyParameters: extern union {
        MaximumSize: extern struct {
            Containers: u32,
        },
        MinimumSize: extern struct {
            Containers: u32,
        },
        NewContainerSize: extern struct {
            SizeInBytes: u32,
        },
        GrowthRate: extern struct {
            AbsoluteGrowthInContainers: u32,
            RelativeGrowthPercentage: u32,
        },
        LogTail: extern struct {
            MinimumAvailablePercentage: u32,
            MinimumAvailableContainers: u32,
        },
        AutoShrink: extern struct {
            Percentage: u32,
        },
        AutoGrow: extern struct {
            Enabled: u32,
        },
        NewContainerPrefix: extern struct {
            PrefixLengthInBytes: u16,
            PrefixString: [1]u16,
        },
        NewContainerSuffix: extern struct {
            NextContainerSuffix: u64,
        },
        NewContainerExtension: extern struct {
            ExtensionLengthInBytes: u16,
            ExtensionString: [1]u16,
        },
    },
};

pub const CLFS_MGMT_NOTIFICATION_TYPE = enum(i32) {
    AdvanceTailNotification = 0,
    LogFullHandlerNotification = 1,
    LogUnpinnedNotification = 2,
    LogWriteNotification = 3,
};
pub const ClfsMgmtAdvanceTailNotification = CLFS_MGMT_NOTIFICATION_TYPE.AdvanceTailNotification;
pub const ClfsMgmtLogFullHandlerNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogFullHandlerNotification;
pub const ClfsMgmtLogUnpinnedNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogUnpinnedNotification;
pub const ClfsMgmtLogWriteNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogWriteNotification;

pub const CLFS_MGMT_NOTIFICATION = extern struct {
    Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    Lsn: CLS_LSN,
    LogIsPinned: u16,
};

pub const PLOG_TAIL_ADVANCE_CALLBACK = *const fn (
    h_log_file: ?HANDLE,
    lsn_target: CLS_LSN,
    pv_client_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLOG_FULL_HANDLER_CALLBACK = *const fn (
    h_log_file: ?HANDLE,
    dw_error: u32,
    f_log_is_pinned: BOOL,
    pv_client_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLOG_UNPINNED_CALLBACK = *const fn (
    h_log_file: ?HANDLE,
    pv_client_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LOG_MANAGEMENT_CALLBACKS = extern struct {
    CallbackContext: ?*anyopaque,
    AdvanceTailCallback: ?PLOG_TAIL_ADVANCE_CALLBACK,
    LogFullHandlerCallback: ?PLOG_FULL_HANDLER_CALLBACK,
    LogUnpinnedCallback: ?PLOG_UNPINNED_CALLBACK,
};

pub const DISKQUOTA_USER_INFORMATION = extern struct {
    QuotaUsed: i64,
    QuotaThreshold: i64,
    QuotaLimit: i64,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaUser_Value = Guid.initString("7988b574-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaUser = &IID_IDiskQuotaUser_Value;
pub const IDiskQuotaUser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: *const fn (
            self: *const IDiskQuotaUser,
            pul_i_d: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn (
            self: *const IDiskQuotaUser,
            psz_account_container: ?PWSTR,
            cch_account_container: u32,
            psz_logon_name: ?PWSTR,
            cch_logon_name: u32,
            psz_display_name: ?PWSTR,
            cch_display_name: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSidLength: *const fn (
            self: *const IDiskQuotaUser,
            pdw_length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSid: *const fn (
            self: *const IDiskQuotaUser,
            pb_sid_buffer: ?*u8,
            cb_sid_buffer: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaThreshold: *const fn (
            self: *const IDiskQuotaUser,
            pll_threshold: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaThresholdText: *const fn (
            self: *const IDiskQuotaUser,
            psz_text: ?PWSTR,
            cch_text: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLimit: *const fn (
            self: *const IDiskQuotaUser,
            pll_limit: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLimitText: *const fn (
            self: *const IDiskQuotaUser,
            psz_text: ?PWSTR,
            cch_text: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaUsed: *const fn (
            self: *const IDiskQuotaUser,
            pll_used: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaUsedText: *const fn (
            self: *const IDiskQuotaUser,
            psz_text: ?PWSTR,
            cch_text: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaInformation: *const fn (
            self: *const IDiskQuotaUser,
            pb_quota_info: ?*anyopaque,
            cb_quota_info: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaThreshold: *const fn (
            self: *const IDiskQuotaUser,
            ll_threshold: i64,
            f_write_through: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaLimit: *const fn (
            self: *const IDiskQuotaUser,
            ll_limit: i64,
            f_write_through: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invalidate: *const fn (
            self: *const IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccountStatus: *const fn (
            self: *const IDiskQuotaUser,
            pdw_status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getID(self: *const T, pul_i_d_: ?*u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetID(@as(*const IDiskQuotaUser, @ptrCast(self)), pul_i_d_);
            }
            pub inline fn getName(self: *const T, psz_account_container_: ?PWSTR, cch_account_container_: u32, psz_logon_name_: ?PWSTR, cch_logon_name_: u32, psz_display_name_: ?PWSTR, cch_display_name_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDiskQuotaUser, @ptrCast(self)), psz_account_container_, cch_account_container_, psz_logon_name_, cch_logon_name_, psz_display_name_, cch_display_name_);
            }
            pub inline fn getSidLength(self: *const T, pdw_length_: ?*u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetSidLength(@as(*const IDiskQuotaUser, @ptrCast(self)), pdw_length_);
            }
            pub inline fn getSid(self: *const T, pb_sid_buffer_: ?*u8, cb_sid_buffer_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetSid(@as(*const IDiskQuotaUser, @ptrCast(self)), pb_sid_buffer_, cb_sid_buffer_);
            }
            pub inline fn getQuotaThreshold(self: *const T, pll_threshold_: ?*i64) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaThreshold(@as(*const IDiskQuotaUser, @ptrCast(self)), pll_threshold_);
            }
            pub inline fn getQuotaThresholdText(self: *const T, psz_text_: ?PWSTR, cch_text_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaThresholdText(@as(*const IDiskQuotaUser, @ptrCast(self)), psz_text_, cch_text_);
            }
            pub inline fn getQuotaLimit(self: *const T, pll_limit_: ?*i64) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaLimit(@as(*const IDiskQuotaUser, @ptrCast(self)), pll_limit_);
            }
            pub inline fn getQuotaLimitText(self: *const T, psz_text_: ?PWSTR, cch_text_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaLimitText(@as(*const IDiskQuotaUser, @ptrCast(self)), psz_text_, cch_text_);
            }
            pub inline fn getQuotaUsed(self: *const T, pll_used_: ?*i64) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaUsed(@as(*const IDiskQuotaUser, @ptrCast(self)), pll_used_);
            }
            pub inline fn getQuotaUsedText(self: *const T, psz_text_: ?PWSTR, cch_text_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaUsedText(@as(*const IDiskQuotaUser, @ptrCast(self)), psz_text_, cch_text_);
            }
            pub inline fn getQuotaInformation(self: *const T, pb_quota_info_: ?*anyopaque, cb_quota_info_: u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetQuotaInformation(@as(*const IDiskQuotaUser, @ptrCast(self)), pb_quota_info_, cb_quota_info_);
            }
            pub inline fn setQuotaThreshold(self: *const T, ll_threshold_: i64, f_write_through_: BOOL) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).SetQuotaThreshold(@as(*const IDiskQuotaUser, @ptrCast(self)), ll_threshold_, f_write_through_);
            }
            pub inline fn setQuotaLimit(self: *const T, ll_limit_: i64, f_write_through_: BOOL) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).SetQuotaLimit(@as(*const IDiskQuotaUser, @ptrCast(self)), ll_limit_, f_write_through_);
            }
            pub inline fn invalidate(self: *const T) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).Invalidate(@as(*const IDiskQuotaUser, @ptrCast(self)));
            }
            pub inline fn getAccountStatus(self: *const T, pdw_status_: ?*u32) HRESULT {
                return @as(*const IDiskQuotaUser.VTable, @ptrCast(self.vtable)).GetAccountStatus(@as(*const IDiskQuotaUser, @ptrCast(self)), pdw_status_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumDiskQuotaUsers_Value = Guid.initString("7988b577-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IEnumDiskQuotaUsers = &IID_IEnumDiskQuotaUsers_Value;
pub const IEnumDiskQuotaUsers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn (
            self: *const IEnumDiskQuotaUsers,
            c_users: u32,
            rg_users: ?*?*IDiskQuotaUser,
            pc_users_fetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn (
            self: *const IEnumDiskQuotaUsers,
            c_users: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn (
            self: *const IEnumDiskQuotaUsers,
            pp_enum: ?*?*IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn next(self: *const T, c_users_: u32, rg_users_: ?*?*IDiskQuotaUser, pc_users_fetched_: ?*u32) HRESULT {
                return @as(*const IEnumDiskQuotaUsers.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDiskQuotaUsers, @ptrCast(self)), c_users_, rg_users_, pc_users_fetched_);
            }
            pub inline fn skip(self: *const T, c_users_: u32) HRESULT {
                return @as(*const IEnumDiskQuotaUsers.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDiskQuotaUsers, @ptrCast(self)), c_users_);
            }
            pub inline fn reset(self: *const T) HRESULT {
                return @as(*const IEnumDiskQuotaUsers.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDiskQuotaUsers, @ptrCast(self)));
            }
            pub inline fn clone(self: *const T, pp_enum_: ?*?*IEnumDiskQuotaUsers) HRESULT {
                return @as(*const IEnumDiskQuotaUsers.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDiskQuotaUsers, @ptrCast(self)), pp_enum_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaUserBatch_Value = Guid.initString("7988b576-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaUserBatch = &IID_IDiskQuotaUserBatch_Value;
pub const IDiskQuotaUserBatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: *const fn (
            self: *const IDiskQuotaUserBatch,
            p_user: ?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: *const fn (
            self: *const IDiskQuotaUserBatch,
            p_user: ?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: *const fn (
            self: *const IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushToDisk: *const fn (
            self: *const IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn add(self: *const T, p_user_: ?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaUserBatch.VTable, @ptrCast(self.vtable)).Add(@as(*const IDiskQuotaUserBatch, @ptrCast(self)), p_user_);
            }
            pub inline fn remove(self: *const T, p_user_: ?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaUserBatch.VTable, @ptrCast(self.vtable)).Remove(@as(*const IDiskQuotaUserBatch, @ptrCast(self)), p_user_);
            }
            pub inline fn removeAll(self: *const T) HRESULT {
                return @as(*const IDiskQuotaUserBatch.VTable, @ptrCast(self.vtable)).RemoveAll(@as(*const IDiskQuotaUserBatch, @ptrCast(self)));
            }
            pub inline fn flushToDisk(self: *const T) HRESULT {
                return @as(*const IDiskQuotaUserBatch.VTable, @ptrCast(self.vtable)).FlushToDisk(@as(*const IDiskQuotaUserBatch, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaControl_Value = Guid.initString("7988b572-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaControl = &IID_IDiskQuotaControl_Value;
pub const IDiskQuotaControl = extern struct {
    pub const VTable = extern struct {
        base: IConnectionPointContainer.VTable,
        Initialize: *const fn (
            self: *const IDiskQuotaControl,
            psz_path: ?[*:0]const u16,
            b_read_write: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaState: *const fn (
            self: *const IDiskQuotaControl,
            dw_state: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaState: *const fn (
            self: *const IDiskQuotaControl,
            pdw_state: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaLogFlags: *const fn (
            self: *const IDiskQuotaControl,
            dw_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLogFlags: *const fn (
            self: *const IDiskQuotaControl,
            pdw_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultQuotaThreshold: *const fn (
            self: *const IDiskQuotaControl,
            ll_threshold: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaThreshold: *const fn (
            self: *const IDiskQuotaControl,
            pll_threshold: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaThresholdText: *const fn (
            self: *const IDiskQuotaControl,
            psz_text: ?PWSTR,
            cch_text: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultQuotaLimit: *const fn (
            self: *const IDiskQuotaControl,
            ll_limit: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaLimit: *const fn (
            self: *const IDiskQuotaControl,
            pll_limit: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaLimitText: *const fn (
            self: *const IDiskQuotaControl,
            psz_text: ?PWSTR,
            cch_text: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserSid: *const fn (
            self: *const IDiskQuotaControl,
            p_user_sid: ?PSID,
            f_name_resolution: DISKQUOTA_USERNAME_RESOLVE,
            pp_user: ?*?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserName: *const fn (
            self: *const IDiskQuotaControl,
            psz_logon_name: ?[*:0]const u16,
            f_name_resolution: DISKQUOTA_USERNAME_RESOLVE,
            pp_user: ?*?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteUser: *const fn (
            self: *const IDiskQuotaControl,
            p_user: ?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindUserSid: *const fn (
            self: *const IDiskQuotaControl,
            p_user_sid: ?PSID,
            f_name_resolution: DISKQUOTA_USERNAME_RESOLVE,
            pp_user: ?*?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindUserName: *const fn (
            self: *const IDiskQuotaControl,
            psz_logon_name: ?[*:0]const u16,
            pp_user: ?*?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEnumUsers: *const fn (
            self: *const IDiskQuotaControl,
            rgp_user_sids: ?*?PSID,
            cp_sids: u32,
            f_name_resolution: DISKQUOTA_USERNAME_RESOLVE,
            pp_enum: ?*?*IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUserBatch: *const fn (
            self: *const IDiskQuotaControl,
            pp_batch: ?*?*IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateSidNameCache: *const fn (
            self: *const IDiskQuotaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GiveUserNameResolutionPriority: *const fn (
            self: *const IDiskQuotaControl,
            p_user: ?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutdownNameResolution: *const fn (
            self: *const IDiskQuotaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConnectionPointContainer.MethodMixin(T);
            pub inline fn initialize(self: *const T, psz_path_: ?[*:0]const u16, b_read_write_: BOOL) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDiskQuotaControl, @ptrCast(self)), psz_path_, b_read_write_);
            }
            pub inline fn setQuotaState(self: *const T, dw_state_: u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).SetQuotaState(@as(*const IDiskQuotaControl, @ptrCast(self)), dw_state_);
            }
            pub inline fn getQuotaState(self: *const T, pdw_state_: ?*u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetQuotaState(@as(*const IDiskQuotaControl, @ptrCast(self)), pdw_state_);
            }
            pub inline fn setQuotaLogFlags(self: *const T, dw_flags_: u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).SetQuotaLogFlags(@as(*const IDiskQuotaControl, @ptrCast(self)), dw_flags_);
            }
            pub inline fn getQuotaLogFlags(self: *const T, pdw_flags_: ?*u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetQuotaLogFlags(@as(*const IDiskQuotaControl, @ptrCast(self)), pdw_flags_);
            }
            pub inline fn setDefaultQuotaThreshold(self: *const T, ll_threshold_: i64) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).SetDefaultQuotaThreshold(@as(*const IDiskQuotaControl, @ptrCast(self)), ll_threshold_);
            }
            pub inline fn getDefaultQuotaThreshold(self: *const T, pll_threshold_: ?*i64) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetDefaultQuotaThreshold(@as(*const IDiskQuotaControl, @ptrCast(self)), pll_threshold_);
            }
            pub inline fn getDefaultQuotaThresholdText(self: *const T, psz_text_: ?PWSTR, cch_text_: u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetDefaultQuotaThresholdText(@as(*const IDiskQuotaControl, @ptrCast(self)), psz_text_, cch_text_);
            }
            pub inline fn setDefaultQuotaLimit(self: *const T, ll_limit_: i64) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).SetDefaultQuotaLimit(@as(*const IDiskQuotaControl, @ptrCast(self)), ll_limit_);
            }
            pub inline fn getDefaultQuotaLimit(self: *const T, pll_limit_: ?*i64) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetDefaultQuotaLimit(@as(*const IDiskQuotaControl, @ptrCast(self)), pll_limit_);
            }
            pub inline fn getDefaultQuotaLimitText(self: *const T, psz_text_: ?PWSTR, cch_text_: u32) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GetDefaultQuotaLimitText(@as(*const IDiskQuotaControl, @ptrCast(self)), psz_text_, cch_text_);
            }
            pub inline fn addUserSid(self: *const T, p_user_sid_: ?PSID, f_name_resolution_: DISKQUOTA_USERNAME_RESOLVE, pp_user_: ?*?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).AddUserSid(@as(*const IDiskQuotaControl, @ptrCast(self)), p_user_sid_, f_name_resolution_, pp_user_);
            }
            pub inline fn addUserName(self: *const T, psz_logon_name_: ?[*:0]const u16, f_name_resolution_: DISKQUOTA_USERNAME_RESOLVE, pp_user_: ?*?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).AddUserName(@as(*const IDiskQuotaControl, @ptrCast(self)), psz_logon_name_, f_name_resolution_, pp_user_);
            }
            pub inline fn deleteUser(self: *const T, p_user_: ?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).DeleteUser(@as(*const IDiskQuotaControl, @ptrCast(self)), p_user_);
            }
            pub inline fn findUserSid(self: *const T, p_user_sid_: ?PSID, f_name_resolution_: DISKQUOTA_USERNAME_RESOLVE, pp_user_: ?*?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).FindUserSid(@as(*const IDiskQuotaControl, @ptrCast(self)), p_user_sid_, f_name_resolution_, pp_user_);
            }
            pub inline fn findUserName(self: *const T, psz_logon_name_: ?[*:0]const u16, pp_user_: ?*?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).FindUserName(@as(*const IDiskQuotaControl, @ptrCast(self)), psz_logon_name_, pp_user_);
            }
            pub inline fn createEnumUsers(self: *const T, rgp_user_sids_: ?*?PSID, cp_sids_: u32, f_name_resolution_: DISKQUOTA_USERNAME_RESOLVE, pp_enum_: ?*?*IEnumDiskQuotaUsers) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).CreateEnumUsers(@as(*const IDiskQuotaControl, @ptrCast(self)), rgp_user_sids_, cp_sids_, f_name_resolution_, pp_enum_);
            }
            pub inline fn createUserBatch(self: *const T, pp_batch_: ?*?*IDiskQuotaUserBatch) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).CreateUserBatch(@as(*const IDiskQuotaControl, @ptrCast(self)), pp_batch_);
            }
            pub inline fn invalidateSidNameCache(self: *const T) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).InvalidateSidNameCache(@as(*const IDiskQuotaControl, @ptrCast(self)));
            }
            pub inline fn giveUserNameResolutionPriority(self: *const T, p_user_: ?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).GiveUserNameResolutionPriority(@as(*const IDiskQuotaControl, @ptrCast(self)), p_user_);
            }
            pub inline fn shutdownNameResolution(self: *const T) HRESULT {
                return @as(*const IDiskQuotaControl.VTable, @ptrCast(self.vtable)).ShutdownNameResolution(@as(*const IDiskQuotaControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaEvents_Value = Guid.initString("7988b579-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaEvents = &IID_IDiskQuotaEvents_Value;
pub const IDiskQuotaEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUserNameChanged: *const fn (
            self: *const IDiskQuotaEvents,
            p_user: ?*IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn onUserNameChanged(self: *const T, p_user_: ?*IDiskQuotaUser) HRESULT {
                return @as(*const IDiskQuotaEvents.VTable, @ptrCast(self.vtable)).OnUserNameChanged(@as(*const IDiskQuotaEvents, @ptrCast(self)), p_user_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EFS_CERTIFICATE_BLOB = extern struct {
    dwCertEncodingType: u32,
    cbData: u32,
    pbData: ?*u8,
};

pub const EFS_HASH_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const EFS_RPC_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const EFS_PIN_BLOB = extern struct {
    cbPadding: u32,
    cbData: u32,
    pbData: ?*u8,
};

pub const EFS_KEY_INFO = extern struct {
    dwVersion: u32,
    Entropy: u32,
    Algorithm: u32,
    KeyLength: u32,
};

pub const EFS_COMPATIBILITY_INFO = extern struct {
    EfsVersion: u32,
};

pub const EFS_VERSION_INFO = extern struct {
    EfsVersion: u32,
    SubVersion: u32,
};

pub const EFS_DECRYPTION_STATUS_INFO = extern struct {
    dwDecryptionError: u32,
    dwHashOffset: u32,
    cbHash: u32,
};

pub const EFS_ENCRYPTION_STATUS_INFO = extern struct {
    bHasCurrentKey: BOOL,
    dwEncryptionError: u32,
};

pub const ENCRYPTION_CERTIFICATE = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    pCertBlob: ?*EFS_CERTIFICATE_BLOB,
};

pub const ENCRYPTION_CERTIFICATE_HASH = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    pHash: ?*EFS_HASH_BLOB,
    lpDisplayInformation: ?PWSTR,
};

pub const ENCRYPTION_CERTIFICATE_HASH_LIST = extern struct {
    nCert_Hash: u32,
    pUsers: ?*?*ENCRYPTION_CERTIFICATE_HASH,
};

pub const ENCRYPTION_CERTIFICATE_LIST = extern struct {
    nUsers: u32,
    pUsers: ?*?*ENCRYPTION_CERTIFICATE,
};

pub const ENCRYPTED_FILE_METADATA_SIGNATURE = extern struct {
    dwEfsAccessType: u32,
    pCertificatesAdded: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
    pEfsStreamSignature: ?*EFS_RPC_BLOB,
};

pub const ENCRYPTION_PROTECTOR = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    lpProtectorDescriptor: ?PWSTR,
};

pub const ENCRYPTION_PROTECTOR_LIST = extern struct {
    nProtectors: u32,
    pProtectors: ?*?*ENCRYPTION_PROTECTOR,
};

pub const WofEnumEntryProc = *const fn (
    entry_info: ?*const anyopaque,
    user_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const WofEnumFilesProc = *const fn (
    file_path: ?[*:0]const u16,
    external_file_info: ?*anyopaque,
    user_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const WIM_ENTRY_INFO = extern struct {
    WimEntryInfoSize: u32,
    WimType: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimPath: ?[*:0]const u16,
    WimIndex: u32,
    Flags: u32,
};

pub const WIM_EXTERNAL_FILE_INFO = extern struct {
    DataSourceId: LARGE_INTEGER,
    ResourceHash: [20]u8,
    Flags: u32,
};

pub const WOF_FILE_COMPRESSION_INFO_V0 = extern struct {
    Algorithm: u32,
};

pub const WOF_FILE_COMPRESSION_INFO_V1 = extern struct {
    Algorithm: u32,
    Flags: u32,
};

pub const TXF_ID = extern struct {
    Anonymous: extern struct {
        LowPart: i64 align(4),
        HighPart: i64 align(4),
    },
};

pub const TXF_LOG_RECORD_BASE = extern struct {
    Version: u16,
    RecordType: TXF_LOG_RECORD_TYPE,
    RecordLength: u32,
};

pub const TXF_LOG_RECORD_WRITE = extern struct {
    Version: u16 align(4),
    RecordType: u16 align(4),
    RecordLength: u32 align(4),
    Flags: u32 align(4),
    TxfFileId: TXF_ID align(4),
    KtmGuid: Guid align(4),
    ByteOffsetInFile: i64 align(4),
    NumBytesWritten: u32 align(4),
    ByteOffsetInStructure: u32 align(4),
    FileNameLength: u32 align(4),
    FileNameByteOffsetInStructure: u32 align(4),
};

pub const TXF_LOG_RECORD_TRUNCATE = extern struct {
    Version: u16 align(4),
    RecordType: u16 align(4),
    RecordLength: u32 align(4),
    Flags: u32 align(4),
    TxfFileId: TXF_ID align(4),
    KtmGuid: Guid align(4),
    NewFileSize: i64 align(4),
    FileNameLength: u32 align(4),
    FileNameByteOffsetInStructure: u32 align(4),
};

pub const TXF_LOG_RECORD_AFFECTED_FILE = extern struct {
    Version: u16,
    RecordLength: u32,
    Flags: u32,
    TxfFileId: TXF_ID,
    KtmGuid: Guid,
    FileNameLength: u32,
    FileNameByteOffsetInStructure: u32,
};

pub const VOLUME_FAILOVER_SET = extern struct {
    NumberOfDisks: u32,
    DiskNumbers: [1]u32,
};

pub const VOLUME_NUMBER = extern struct {
    VolumeNumber: u32,
    VolumeManagerName: [8]u16,
};

pub const VOLUME_LOGICAL_OFFSET = extern struct {
    LogicalOffset: i64,
};

pub const VOLUME_PHYSICAL_OFFSET = extern struct {
    DiskNumber: u32,
    Offset: i64,
};

pub const VOLUME_PHYSICAL_OFFSETS = extern struct {
    NumberOfPhysicalOffsets: u32,
    PhysicalOffset: [1]VOLUME_PHYSICAL_OFFSET,
};

pub const VOLUME_READ_PLEX_INPUT = extern struct {
    ByteOffset: LARGE_INTEGER,
    Length: u32,
    PlexNumber: u32,
};

pub const VOLUME_SET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: u64,
    RevertOnClose: BOOLEAN,
    ApplyToAllConnectedVolumes: BOOLEAN,
    Reserved1: u16,
    Reserved2: u32,
};

pub const VOLUME_GET_BC_PROPERTIES_INPUT = extern struct {
    Version: u32,
    Reserved1: u32,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};

pub const VOLUME_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};

pub const VOLUME_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: BOOLEAN,
    Discardable: BOOLEAN,
    Reserved1: [2]BOOLEAN,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};

pub const VOLUME_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};

pub const FILE_EXTENT = extern struct {
    VolumeOffset: u64,
    ExtentLength: u64,
};

pub const VOLUME_CRITICAL_IO = extern struct {
    AccessType: u32,
    ExtentsCount: u32,
    Extents: [1]FILE_EXTENT,
};

pub const VOLUME_ALLOCATION_HINT_INPUT = extern struct {
    ClusterSize: u32,
    NumberOfClusters: u32,
    StartingClusterNumber: i64,
};

pub const VOLUME_ALLOCATION_HINT_OUTPUT = extern struct {
    Bitmap: [1]u32,
};

pub const VOLUME_SHRINK_INFO = extern struct {
    VolumeSize: u64,
};

pub const SHARE_INFO_0 = extern struct {
    shi0_netname: ?PWSTR,
};

pub const SHARE_INFO_1 = extern struct {
    shi1_netname: ?PWSTR,
    shi1_type: SHARE_TYPE,
    shi1_remark: ?PWSTR,
};

pub const SHARE_INFO_2 = extern struct {
    shi2_netname: ?PWSTR,
    shi2_type: SHARE_TYPE,
    shi2_remark: ?PWSTR,
    shi2_permissions: SHARE_INFO_PERMISSIONS,
    shi2_max_uses: u32,
    shi2_current_uses: u32,
    shi2_path: ?PWSTR,
    shi2_passwd: ?PWSTR,
};

pub const SHARE_INFO_501 = extern struct {
    shi501_netname: ?PWSTR,
    shi501_type: SHARE_TYPE,
    shi501_remark: ?PWSTR,
    shi501_flags: u32,
};

pub const SHARE_INFO_502 = extern struct {
    shi502_netname: ?PWSTR,
    shi502_type: SHARE_TYPE,
    shi502_remark: ?PWSTR,
    shi502_permissions: SHARE_INFO_PERMISSIONS,
    shi502_max_uses: u32,
    shi502_current_uses: u32,
    shi502_path: ?PWSTR,
    shi502_passwd: ?PWSTR,
    shi502_reserved: u32,
    shi502_security_descriptor: ?PSECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_503 = extern struct {
    shi503_netname: ?PWSTR,
    shi503_type: SHARE_TYPE,
    shi503_remark: ?PWSTR,
    shi503_permissions: SHARE_INFO_PERMISSIONS,
    shi503_max_uses: u32,
    shi503_current_uses: u32,
    shi503_path: ?PWSTR,
    shi503_passwd: ?PWSTR,
    shi503_servername: ?PWSTR,
    shi503_reserved: u32,
    shi503_security_descriptor: ?PSECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_1004 = extern struct {
    shi1004_remark: ?PWSTR,
};

pub const SHARE_INFO_1005 = extern struct {
    shi1005_flags: u32,
};

pub const SHARE_INFO_1006 = extern struct {
    shi1006_max_uses: u32,
};

pub const SHARE_INFO_1501 = extern struct {
    shi1501_reserved: u32,
    shi1501_security_descriptor: ?PSECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_1503 = extern struct {
    shi1503_sharefilter: Guid,
};

pub const SERVER_ALIAS_INFO_0 = extern struct {
    srvai0_alias: ?PWSTR,
    srvai0_target: ?PWSTR,
    srvai0_default: BOOLEAN,
    srvai0_reserved: u32,
};

pub const SESSION_INFO_0 = extern struct {
    sesi0_cname: ?PWSTR,
};

pub const SESSION_INFO_1 = extern struct {
    sesi1_cname: ?PWSTR,
    sesi1_username: ?PWSTR,
    sesi1_num_opens: u32,
    sesi1_time: u32,
    sesi1_idle_time: u32,
    sesi1_user_flags: SESSION_INFO_USER_FLAGS,
};

pub const SESSION_INFO_2 = extern struct {
    sesi2_cname: ?PWSTR,
    sesi2_username: ?PWSTR,
    sesi2_num_opens: u32,
    sesi2_time: u32,
    sesi2_idle_time: u32,
    sesi2_user_flags: SESSION_INFO_USER_FLAGS,
    sesi2_cltype_name: ?PWSTR,
};

pub const SESSION_INFO_10 = extern struct {
    sesi10_cname: ?PWSTR,
    sesi10_username: ?PWSTR,
    sesi10_time: u32,
    sesi10_idle_time: u32,
};

pub const SESSION_INFO_502 = extern struct {
    sesi502_cname: ?PWSTR,
    sesi502_username: ?PWSTR,
    sesi502_num_opens: u32,
    sesi502_time: u32,
    sesi502_idle_time: u32,
    sesi502_user_flags: SESSION_INFO_USER_FLAGS,
    sesi502_cltype_name: ?PWSTR,
    sesi502_transport: ?PWSTR,
};

pub const CONNECTION_INFO_0 = extern struct {
    coni0_id: u32,
};

pub const CONNECTION_INFO_1 = extern struct {
    coni1_id: u32,
    coni1_type: SHARE_TYPE,
    coni1_num_opens: u32,
    coni1_num_users: u32,
    coni1_time: u32,
    coni1_username: ?PWSTR,
    coni1_netname: ?PWSTR,
};

pub const FILE_INFO_2 = extern struct {
    fi2_id: u32,
};

pub const FILE_INFO_3 = extern struct {
    fi3_id: u32,
    fi3_permissions: FILE_INFO_FLAGS_PERMISSIONS,
    fi3_num_locks: u32,
    fi3_pathname: ?PWSTR,
    fi3_username: ?PWSTR,
};

pub const SERVER_CERTIFICATE_TYPE = enum(i32) {
    C = 0,
};
pub const QUIC = SERVER_CERTIFICATE_TYPE.C;

pub const SERVER_CERTIFICATE_INFO_0 = extern struct {
    srvci0_name: ?PWSTR,
    srvci0_subject: ?PWSTR,
    srvci0_issuer: ?PWSTR,
    srvci0_thumbprint: ?PWSTR,
    srvci0_friendlyname: ?PWSTR,
    srvci0_notbefore: ?PWSTR,
    srvci0_notafter: ?PWSTR,
    srvci0_storelocation: ?PWSTR,
    srvci0_storename: ?PWSTR,
    srvci0_renewalchain: ?PWSTR,
    srvci0_type: u32,
    srvci0_flags: u32,
};

pub const STAT_WORKSTATION_0 = extern struct {
    StatisticsStartTime: LARGE_INTEGER,
    BytesReceived: LARGE_INTEGER,
    SmbsReceived: LARGE_INTEGER,
    PagingReadBytesRequested: LARGE_INTEGER,
    NonPagingReadBytesRequested: LARGE_INTEGER,
    CacheReadBytesRequested: LARGE_INTEGER,
    NetworkReadBytesRequested: LARGE_INTEGER,
    BytesTransmitted: LARGE_INTEGER,
    SmbsTransmitted: LARGE_INTEGER,
    PagingWriteBytesRequested: LARGE_INTEGER,
    NonPagingWriteBytesRequested: LARGE_INTEGER,
    CacheWriteBytesRequested: LARGE_INTEGER,
    NetworkWriteBytesRequested: LARGE_INTEGER,
    InitiallyFailedOperations: u32,
    FailedCompletionOperations: u32,
    ReadOperations: u32,
    RandomReadOperations: u32,
    ReadSmbs: u32,
    LargeReadSmbs: u32,
    SmallReadSmbs: u32,
    WriteOperations: u32,
    RandomWriteOperations: u32,
    WriteSmbs: u32,
    LargeWriteSmbs: u32,
    SmallWriteSmbs: u32,
    RawReadsDenied: u32,
    RawWritesDenied: u32,
    NetworkErrors: u32,
    Sessions: u32,
    FailedSessions: u32,
    Reconnects: u32,
    CoreConnects: u32,
    Lanman20Connects: u32,
    Lanman21Connects: u32,
    LanmanNtConnects: u32,
    ServerDisconnects: u32,
    HungSessions: u32,
    UseCount: u32,
    FailedUseCount: u32,
    CurrentCommands: u32,
};

pub const STAT_SERVER_0 = extern struct {
    sts0_start: u32,
    sts0_fopens: u32,
    sts0_devopens: u32,
    sts0_jobsqueued: u32,
    sts0_sopens: u32,
    sts0_stimedout: u32,
    sts0_serrorout: u32,
    sts0_pwerrors: u32,
    sts0_permerrors: u32,
    sts0_syserrors: u32,
    sts0_bytessent_low: u32,
    sts0_bytessent_high: u32,
    sts0_bytesrcvd_low: u32,
    sts0_bytesrcvd_high: u32,
    sts0_avresponse: u32,
    sts0_reqbufneed: u32,
    sts0_bigbufneed: u32,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PFN_IO_COMPLETION = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const FH_OVERLAPPED = extern struct {
    Internal: usize,
    InternalHigh: usize,
    Offset: u32,
    OffsetHigh: u32,
    hEvent: ?HANDLE,
    pfnCompletion: ?PFN_IO_COMPLETION,
    Reserved1: usize,
    Reserved2: usize,
    Reserved3: usize,
    Reserved4: usize,
};

pub const FIO_CONTEXT = extern struct {
    m_dwTempHack: u32,
    m_dwSignature: u32,
    m_hFile: ?HANDLE,
    m_dwLinesOffset: u32,
    m_dwHeaderLength: u32,
};

pub const FCACHE_CREATE_CALLBACK = *const fn (
    lpstr_name: ?PSTR,
    lpv_data: ?*anyopaque,
    cb_file_size: ?*u32,
    cb_file_size_high: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub const FCACHE_RICHCREATE_CALLBACK = *const fn (
    lpstr_name: ?PSTR,
    lpv_data: ?*anyopaque,
    cb_file_size: ?*u32,
    cb_file_size_high: ?*u32,
    pf_did_we_scan_it: ?*BOOL,
    pf_is_stuffed: ?*BOOL,
    pf_stored_with_dots: ?*BOOL,
    pf_stored_with_terminating_dot: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub const CACHE_KEY_COMPARE = *const fn (
    cb_key1: u32,
    lpb_key1: ?*u8,
    cb_key2: u32,
    lpb_key2: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CACHE_KEY_HASH = *const fn (
    lpb_key: ?*u8,
    cb_key: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CACHE_READ_CALLBACK = *const fn (
    cb: u32,
    lpb: ?*u8,
    lpv_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CACHE_DESTROY_CALLBACK = *const fn (
    cb: u32,
    lpb: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CACHE_ACCESS_CHECK = *const fn (
    p_security_descriptor: ?PSECURITY_DESCRIPTOR,
    h_client_token: ?HANDLE,
    dw_desired_access: u32,
    generic_mapping: ?*GENERIC_MAPPING,
    privilege_set: ?*PRIVILEGE_SET,
    privilege_set_length: ?*u32,
    granted_access: ?*u32,
    access_status: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NAME_CACHE_CONTEXT = extern struct {
    m_dwSignature: u32,
};

pub const IORING_VERSION = enum(i32) {
    INVALID = 0,
    @"1" = 1,
};
pub const IORING_VERSION_INVALID = IORING_VERSION.INVALID;
pub const IORING_VERSION_1 = IORING_VERSION.@"1";

pub const IORING_FEATURE_FLAGS = enum(i32) {
    FLAGS_NONE = 0,
    UM_EMULATION = 1,
    SET_COMPLETION_EVENT = 2,
};
pub const IORING_FEATURE_FLAGS_NONE = IORING_FEATURE_FLAGS.FLAGS_NONE;
pub const IORING_FEATURE_UM_EMULATION = IORING_FEATURE_FLAGS.UM_EMULATION;
pub const IORING_FEATURE_SET_COMPLETION_EVENT = IORING_FEATURE_FLAGS.SET_COMPLETION_EVENT;

pub const IORING_OP_CODE = enum(i32) {
    NOP = 0,
    READ = 1,
    REGISTER_FILES = 2,
    REGISTER_BUFFERS = 3,
    CANCEL = 4,
};
pub const IORING_OP_NOP = IORING_OP_CODE.NOP;
pub const IORING_OP_READ = IORING_OP_CODE.READ;
pub const IORING_OP_REGISTER_FILES = IORING_OP_CODE.REGISTER_FILES;
pub const IORING_OP_REGISTER_BUFFERS = IORING_OP_CODE.REGISTER_BUFFERS;
pub const IORING_OP_CANCEL = IORING_OP_CODE.CANCEL;

pub const IORING_BUFFER_INFO = extern struct {
    Address: ?*anyopaque,
    Length: u32,
};

pub const IORING_REGISTERED_BUFFER = extern struct {
    BufferIndex: u32,
    Offset: u32,
};

pub const HIORING__ = extern struct {
    unused: i32,
};

pub const IORING_SQE_FLAGS = enum(i32) {
    E = 0,
};
pub const IOSQE_FLAGS_NONE = IORING_SQE_FLAGS.E;

pub const IORING_CREATE_REQUIRED_FLAGS = enum(i32) {
    E = 0,
};
pub const IORING_CREATE_REQUIRED_FLAGS_NONE = IORING_CREATE_REQUIRED_FLAGS.E;

pub const IORING_CREATE_ADVISORY_FLAGS = enum(i32) {
    E = 0,
};
pub const IORING_CREATE_ADVISORY_FLAGS_NONE = IORING_CREATE_ADVISORY_FLAGS.E;

pub const IORING_CREATE_FLAGS = extern struct {
    Required: IORING_CREATE_REQUIRED_FLAGS,
    Advisory: IORING_CREATE_ADVISORY_FLAGS,
};

pub const IORING_INFO = extern struct {
    IoRingVersion: IORING_VERSION,
    Flags: IORING_CREATE_FLAGS,
    SubmissionQueueSize: u32,
    CompletionQueueSize: u32,
};

pub const IORING_CAPABILITIES = extern struct {
    MaxVersion: IORING_VERSION,
    MaxSubmissionQueueSize: u32,
    MaxCompletionQueueSize: u32,
    FeatureFlags: IORING_FEATURE_FLAGS,
};

pub const IORING_REF_KIND = enum(i32) {
    AW = 0,
    EGISTERED = 1,
};
pub const IORING_REF_RAW = IORING_REF_KIND.AW;
pub const IORING_REF_REGISTERED = IORING_REF_KIND.EGISTERED;

pub const IORING_HANDLE_REF = extern struct {
    pub const HandleUnion = extern union {
        Handle: ?HANDLE,
        Index: u32,
    };
    Kind: IORING_REF_KIND,
    Handle: HandleUnion,
};

pub const IORING_BUFFER_REF = extern struct {
    pub const BufferUnion = extern union {
        Address: ?*anyopaque,
        IndexAndOffset: IORING_REGISTERED_BUFFER,
    };
    Kind: IORING_REF_KIND,
    Buffer: BufferUnion,
};

pub const IORING_CQE = extern struct {
    UserData: usize,
    ResultCode: HRESULT,
    Information: usize,
};

pub const FILE_ID_128 = extern struct {
    Identifier: [16]u8,
};

pub const FILE_NOTIFY_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: FILE_ACTION,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_NOTIFY_EXTENDED_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: FILE_ACTION,
    CreationTime: LARGE_INTEGER,
    LastModificationTime: LARGE_INTEGER,
    LastChangeTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    AllocatedLength: LARGE_INTEGER,
    FileSize: LARGE_INTEGER,
    FileAttributes: u32,
    ReparsePointTag: u32,
    FileId: LARGE_INTEGER,
    ParentFileId: LARGE_INTEGER,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_SEGMENT_ELEMENT = extern union {
    Buffer: ?*anyopaque,
    Alignment: u64,
};

pub const REPARSE_GUID_DATA_BUFFER = extern struct {
    ReparseTag: u32,
    ReparseDataLength: u16,
    Reserved: u16,
    ReparseGuid: Guid,
    GenericReparseBuffer: extern struct {
        DataBuffer: [1]u8,
    },
};

pub const TAPE_ERASE = extern struct {
    Type: ERASE_TAPE_TYPE,
    Immediate: BOOLEAN,
};

pub const TAPE_PREPARE = extern struct {
    Operation: PREPARE_TAPE_OPERATION,
    Immediate: BOOLEAN,
};

pub const TAPE_WRITE_MARKS = extern struct {
    Type: TAPEMARK_TYPE,
    Count: u32,
    Immediate: BOOLEAN,
};

pub const TAPE_GET_POSITION = extern struct {
    Type: TAPE_POSITION_TYPE,
    Partition: u32,
    Offset: LARGE_INTEGER,
};

pub const TAPE_SET_POSITION = extern struct {
    Method: TAPE_POSITION_METHOD,
    Partition: u32,
    Offset: LARGE_INTEGER,
    Immediate: BOOLEAN,
};

pub const TRANSACTION_OUTCOME = enum(i32) {
    Undetermined = 1,
    Committed = 2,
    Aborted = 3,
};
pub const TransactionOutcomeUndetermined = TRANSACTION_OUTCOME.Undetermined;
pub const TransactionOutcomeCommitted = TRANSACTION_OUTCOME.Committed;
pub const TransactionOutcomeAborted = TRANSACTION_OUTCOME.Aborted;

pub const STORAGE_BUS_TYPE = enum(i32) {
    Unknown = 0,
    Scsi = 1,
    Atapi = 2,
    Ata = 3,
    @"1394" = 4,
    Ssa = 5,
    Fibre = 6,
    Usb = 7,
    RAID = 8,
    iScsi = 9,
    Sas = 10,
    Sata = 11,
    Sd = 12,
    Mmc = 13,
    Virtual = 14,
    FileBackedVirtual = 15,
    Spaces = 16,
    Nvme = 17,
    SCM = 18,
    Ufs = 19,
    Max = 20,
    MaxReserved = 127,
};
pub const BusTypeUnknown = STORAGE_BUS_TYPE.Unknown;
pub const BusTypeScsi = STORAGE_BUS_TYPE.Scsi;
pub const BusTypeAtapi = STORAGE_BUS_TYPE.Atapi;
pub const BusTypeAta = STORAGE_BUS_TYPE.Ata;
pub const BusType1394 = STORAGE_BUS_TYPE.@"1394";
pub const BusTypeSsa = STORAGE_BUS_TYPE.Ssa;
pub const BusTypeFibre = STORAGE_BUS_TYPE.Fibre;
pub const BusTypeUsb = STORAGE_BUS_TYPE.Usb;
pub const BusTypeRAID = STORAGE_BUS_TYPE.RAID;
pub const BusTypeiScsi = STORAGE_BUS_TYPE.iScsi;
pub const BusTypeSas = STORAGE_BUS_TYPE.Sas;
pub const BusTypeSata = STORAGE_BUS_TYPE.Sata;
pub const BusTypeSd = STORAGE_BUS_TYPE.Sd;
pub const BusTypeMmc = STORAGE_BUS_TYPE.Mmc;
pub const BusTypeVirtual = STORAGE_BUS_TYPE.Virtual;
pub const BusTypeFileBackedVirtual = STORAGE_BUS_TYPE.FileBackedVirtual;
pub const BusTypeSpaces = STORAGE_BUS_TYPE.Spaces;
pub const BusTypeNvme = STORAGE_BUS_TYPE.Nvme;
pub const BusTypeSCM = STORAGE_BUS_TYPE.SCM;
pub const BusTypeUfs = STORAGE_BUS_TYPE.Ufs;
pub const BusTypeMax = STORAGE_BUS_TYPE.Max;
pub const BusTypeMaxReserved = STORAGE_BUS_TYPE.MaxReserved;

pub const OFSTRUCT = extern struct {
    cBytes: u8,
    fFixedDisk: u8,
    nErrCode: u16,
    Reserved1: u16,
    Reserved2: u16,
    szPathName: [128]CHAR,
};

pub const PFE_EXPORT_FUNC = *const fn (
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*u8,
    pv_callback_context: ?*anyopaque,
    ul_length: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFE_IMPORT_FUNC = *const fn (
    // TODO: what to do with BytesParamIndex 2?
    pb_data: ?*u8,
    pv_callback_context: ?*anyopaque,
    ul_length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WIN32_STREAM_ID = extern struct {
    dwStreamId: WIN_STREAM_ID,
    dwStreamAttributes: u32,
    Size: LARGE_INTEGER,
    dwStreamNameSize: u32,
    cStreamName: [1]u16,
};

pub const LPPROGRESS_ROUTINE = *const fn (
    total_file_size: LARGE_INTEGER,
    total_bytes_transferred: LARGE_INTEGER,
    stream_size: LARGE_INTEGER,
    stream_bytes_transferred: LARGE_INTEGER,
    dw_stream_number: u32,
    dw_callback_reason: LPPROGRESS_ROUTINE_CALLBACK_REASON,
    h_source_file: ?HANDLE,
    h_destination_file: ?HANDLE,
    lp_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const COPYFILE2_MESSAGE_TYPE = enum(i32) {
    NONE = 0,
    CHUNK_STARTED = 1,
    CHUNK_FINISHED = 2,
    STREAM_STARTED = 3,
    STREAM_FINISHED = 4,
    POLL_CONTINUE = 5,
    ERROR = 6,
    MAX = 7,
};
pub const COPYFILE2_CALLBACK_NONE = COPYFILE2_MESSAGE_TYPE.NONE;
pub const COPYFILE2_CALLBACK_CHUNK_STARTED = COPYFILE2_MESSAGE_TYPE.CHUNK_STARTED;
pub const COPYFILE2_CALLBACK_CHUNK_FINISHED = COPYFILE2_MESSAGE_TYPE.CHUNK_FINISHED;
pub const COPYFILE2_CALLBACK_STREAM_STARTED = COPYFILE2_MESSAGE_TYPE.STREAM_STARTED;
pub const COPYFILE2_CALLBACK_STREAM_FINISHED = COPYFILE2_MESSAGE_TYPE.STREAM_FINISHED;
pub const COPYFILE2_CALLBACK_POLL_CONTINUE = COPYFILE2_MESSAGE_TYPE.POLL_CONTINUE;
pub const COPYFILE2_CALLBACK_ERROR = COPYFILE2_MESSAGE_TYPE.ERROR;
pub const COPYFILE2_CALLBACK_MAX = COPYFILE2_MESSAGE_TYPE.MAX;

pub const COPYFILE2_MESSAGE_ACTION = enum(i32) {
    CONTINUE = 0,
    CANCEL = 1,
    STOP = 2,
    QUIET = 3,
    PAUSE = 4,
};
pub const COPYFILE2_PROGRESS_CONTINUE = COPYFILE2_MESSAGE_ACTION.CONTINUE;
pub const COPYFILE2_PROGRESS_CANCEL = COPYFILE2_MESSAGE_ACTION.CANCEL;
pub const COPYFILE2_PROGRESS_STOP = COPYFILE2_MESSAGE_ACTION.STOP;
pub const COPYFILE2_PROGRESS_QUIET = COPYFILE2_MESSAGE_ACTION.QUIET;
pub const COPYFILE2_PROGRESS_PAUSE = COPYFILE2_MESSAGE_ACTION.PAUSE;

pub const COPYFILE2_COPY_PHASE = enum(i32) {
    NONE = 0,
    PREPARE_SOURCE = 1,
    PREPARE_DEST = 2,
    READ_SOURCE = 3,
    WRITE_DESTINATION = 4,
    SERVER_COPY = 5,
    NAMEGRAFT_COPY = 6,
    MAX = 7,
};
pub const COPYFILE2_PHASE_NONE = COPYFILE2_COPY_PHASE.NONE;
pub const COPYFILE2_PHASE_PREPARE_SOURCE = COPYFILE2_COPY_PHASE.PREPARE_SOURCE;
pub const COPYFILE2_PHASE_PREPARE_DEST = COPYFILE2_COPY_PHASE.PREPARE_DEST;
pub const COPYFILE2_PHASE_READ_SOURCE = COPYFILE2_COPY_PHASE.READ_SOURCE;
pub const COPYFILE2_PHASE_WRITE_DESTINATION = COPYFILE2_COPY_PHASE.WRITE_DESTINATION;
pub const COPYFILE2_PHASE_SERVER_COPY = COPYFILE2_COPY_PHASE.SERVER_COPY;
pub const COPYFILE2_PHASE_NAMEGRAFT_COPY = COPYFILE2_COPY_PHASE.NAMEGRAFT_COPY;
pub const COPYFILE2_PHASE_MAX = COPYFILE2_COPY_PHASE.MAX;

pub const COPYFILE2_MESSAGE = extern struct {
    Type: COPYFILE2_MESSAGE_TYPE,
    dwPadding: u32,
    Info: extern union {
        ChunkStarted: extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: ?HANDLE,
            hDestinationFile: ?HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        },
        ChunkFinished: extern struct {
            dwStreamNumber: u32,
            dwFlags: u32,
            hSourceFile: ?HANDLE,
            hDestinationFile: ?HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
        StreamStarted: extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: ?HANDLE,
            hDestinationFile: ?HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        },
        StreamFinished: extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: ?HANDLE,
            hDestinationFile: ?HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
        PollContinue: extern struct {
            dwReserved: u32,
        },
        Error: extern struct {
            CopyPhase: COPYFILE2_COPY_PHASE,
            dwStreamNumber: u32,
            hrFailure: HRESULT,
            dwReserved: u32,
            uliChunkNumber: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
    },
};

pub const PCOPYFILE2_PROGRESS_ROUTINE = *const fn (
    p_message: ?*const COPYFILE2_MESSAGE,
    pv_callback_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) COPYFILE2_MESSAGE_ACTION;

pub const COPYFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwCopyFlags: u32,
    pfCancel: ?*BOOL,
    pProgressRoutine: ?PCOPYFILE2_PROGRESS_ROUTINE,
    pvCallbackContext: ?*anyopaque,
};

pub const COPYFILE2_EXTENDED_PARAMETERS_V2 = extern struct {
    dwSize: u32,
    dwCopyFlags: u32,
    pfCancel: ?*BOOL,
    pProgressRoutine: ?PCOPYFILE2_PROGRESS_ROUTINE,
    pvCallbackContext: ?*anyopaque,
    dwCopyFlagsV2: u32,
    ioDesiredSize: u32,
    ioDesiredRate: u32,
    reserved: [8]?*anyopaque,
};

pub const FILE_BASIC_INFO = extern struct {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    FileAttributes: u32,
};

pub const FILE_STANDARD_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: u32,
    DeletePending: BOOLEAN,
    Directory: BOOLEAN,
};

pub const FILE_NAME_INFO = extern struct {
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_RENAME_INFO = extern struct {
    Anonymous: extern union {
        ReplaceIfExists: BOOLEAN,
        Flags: u32,
    },
    RootDirectory: ?HANDLE,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_ALLOCATION_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
};

pub const FILE_END_OF_FILE_INFO = extern struct {
    EndOfFile: LARGE_INTEGER,
};

pub const FILE_STREAM_INFO = extern struct {
    NextEntryOffset: u32,
    StreamNameLength: u32,
    StreamSize: LARGE_INTEGER,
    StreamAllocationSize: LARGE_INTEGER,
    StreamName: [1]u16,
};

pub const FILE_COMPRESSION_INFO = extern struct {
    CompressedFileSize: LARGE_INTEGER,
    CompressionFormat: u16,
    CompressionUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    Reserved: [3]u8,
};

pub const FILE_ATTRIBUTE_TAG_INFO = extern struct {
    FileAttributes: u32,
    ReparseTag: u32,
};

pub const FILE_DISPOSITION_INFO = extern struct {
    DeleteFileA: BOOLEAN,
};

pub const FILE_ID_BOTH_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ShortNameLength: i8,
    ShortName: [12]u16,
    FileId: LARGE_INTEGER,
    FileName: [1]u16,
};

pub const FILE_FULL_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    FileName: [1]u16,
};

pub const PRIORITY_HINT = enum(i32) {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow = 1,
    IoPriorityHintNormal = 2,
    MaximumIoPriorityHintType = 3,
};
pub const IoPriorityHintVeryLow = PRIORITY_HINT.IoPriorityHintVeryLow;
pub const IoPriorityHintLow = PRIORITY_HINT.IoPriorityHintLow;
pub const IoPriorityHintNormal = PRIORITY_HINT.IoPriorityHintNormal;
pub const MaximumIoPriorityHintType = PRIORITY_HINT.MaximumIoPriorityHintType;

pub const FILE_IO_PRIORITY_HINT_INFO = extern struct {
    PriorityHint: PRIORITY_HINT,
};

pub const FILE_ALIGNMENT_INFO = extern struct {
    AlignmentRequirement: u32,
};

pub const FILE_STORAGE_INFO = extern struct {
    LogicalBytesPerSector: u32,
    PhysicalBytesPerSectorForAtomicity: u32,
    PhysicalBytesPerSectorForPerformance: u32,
    FileSystemEffectivePhysicalBytesPerSectorForAtomicity: u32,
    Flags: u32,
    ByteOffsetForSectorAlignment: u32,
    ByteOffsetForPartitionAlignment: u32,
};

pub const FILE_ID_INFO = extern struct {
    VolumeSerialNumber: u64,
    FileId: FILE_ID_128,
};

pub const FILE_ID_EXTD_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ReparsePointTag: u32,
    FileId: FILE_ID_128,
    FileName: [1]u16,
};

pub const FILE_REMOTE_PROTOCOL_INFO = extern struct {
    StructureVersion: u16,
    StructureSize: u16,
    Protocol: u32,
    ProtocolMajorVersion: u16,
    ProtocolMinorVersion: u16,
    ProtocolRevision: u16,
    Reserved: u16,
    Flags: u32,
    GenericReserved: extern struct {
        Reserved: [8]u32,
    },
    ProtocolSpecific: extern union {
        Smb2: extern struct {
            Server: extern struct {
                Capabilities: u32,
            },
            Share: extern struct {
                Capabilities: u32,
                CachingFlags: u32,
            },
        },
        Reserved: [16]u32,
    },
};

pub const FILE_ID_TYPE = enum(i32) {
    FileIdType = 0,
    ObjectIdType = 1,
    ExtendedFileIdType = 2,
    MaximumFileIdType = 3,
};
pub const FileIdType = FILE_ID_TYPE.FileIdType;
pub const ObjectIdType = FILE_ID_TYPE.ObjectIdType;
pub const ExtendedFileIdType = FILE_ID_TYPE.ExtendedFileIdType;
pub const MaximumFileIdType = FILE_ID_TYPE.MaximumFileIdType;

pub const FILE_ID_DESCRIPTOR = extern struct {
    dwSize: u32,
    Type: FILE_ID_TYPE,
    Anonymous: extern union {
        FileId: LARGE_INTEGER,
        ObjectId: Guid,
        ExtendedFileId: FILE_ID_128,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (411)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SearchPathW(
    lp_path: ?[*:0]const u16,
    lp_file_name: ?[*:0]const u16,
    lp_extension: ?[*:0]const u16,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u16,
    lp_file_part: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SearchPathA(
    lp_path: ?[*:0]const u8,
    lp_file_name: ?[*:0]const u8,
    lp_extension: ?[*:0]const u8,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u8,
    lp_file_part: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CompareFileTime(
    lp_file_time1: ?*const FILETIME,
    lp_file_time2: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateDirectoryA(
    lp_path_name: ?[*:0]const u8,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateDirectoryW(
    lp_path_name: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateFileA(
    lp_file_name: ?[*:0]const u8,
    dw_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_creation_disposition: FILE_CREATION_DISPOSITION,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
    h_template_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateFileW(
    lp_file_name: ?[*:0]const u16,
    dw_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_creation_disposition: FILE_CREATION_DISPOSITION,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
    h_template_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DefineDosDeviceW(
    dw_flags: DEFINE_DOS_DEVICE_FLAGS,
    lp_device_name: ?[*:0]const u16,
    lp_target_path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeleteFileA(
    lp_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeleteFileW(
    lp_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeleteVolumeMountPointW(
    lpsz_volume_mount_point: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FileTimeToLocalFileTime(
    lp_file_time: ?*const FILETIME,
    lp_local_file_time: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindClose(
    h_find_file: FindFileHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindCloseChangeNotification(
    h_change_handle: FindChangeNotificationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstChangeNotificationA(
    lp_path_name: ?[*:0]const u8,
    b_watch_subtree: BOOL,
    dw_notify_filter: FILE_NOTIFY_CHANGE,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstChangeNotificationW(
    lp_path_name: ?[*:0]const u16,
    b_watch_subtree: BOOL,
    dw_notify_filter: FILE_NOTIFY_CHANGE,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstFileA(
    lp_file_name: ?[*:0]const u8,
    lp_find_file_data: ?*WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstFileW(
    lp_file_name: ?[*:0]const u16,
    lp_find_file_data: ?*WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstFileExA(
    lp_file_name: ?[*:0]const u8,
    f_info_level_id: FINDEX_INFO_LEVELS,
    lp_find_file_data: ?*anyopaque,
    f_search_op: FINDEX_SEARCH_OPS,
    lp_search_filter: ?*anyopaque,
    dw_additional_flags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstFileExW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: FINDEX_INFO_LEVELS,
    lp_find_file_data: ?*anyopaque,
    f_search_op: FINDEX_SEARCH_OPS,
    lp_search_filter: ?*anyopaque,
    dw_additional_flags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstVolumeW(
    lpsz_volume_name: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextChangeNotification(
    h_change_handle: FindChangeNotificationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextFileA(
    h_find_file: FindFileHandle,
    lp_find_file_data: ?*WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextFileW(
    h_find_file: ?HANDLE,
    lp_find_file_data: ?*WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextVolumeW(
    h_find_volume: FindVolumeHandle,
    lpsz_volume_name: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindVolumeClose(
    h_find_volume: FindVolumeHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FlushFileBuffers(
    h_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDiskFreeSpaceA(
    lp_root_path_name: ?[*:0]const u8,
    lp_sectors_per_cluster: ?*u32,
    lp_bytes_per_sector: ?*u32,
    lp_number_of_free_clusters: ?*u32,
    lp_total_number_of_clusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDiskFreeSpaceW(
    lp_root_path_name: ?[*:0]const u16,
    lp_sectors_per_cluster: ?*u32,
    lp_bytes_per_sector: ?*u32,
    lp_number_of_free_clusters: ?*u32,
    lp_total_number_of_clusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDiskFreeSpaceExA(
    lp_directory_name: ?[*:0]const u8,
    lp_free_bytes_available_to_caller: ?*ULARGE_INTEGER,
    lp_total_number_of_bytes: ?*ULARGE_INTEGER,
    lp_total_number_of_free_bytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDiskFreeSpaceExW(
    lp_directory_name: ?[*:0]const u16,
    lp_free_bytes_available_to_caller: ?*ULARGE_INTEGER,
    lp_total_number_of_bytes: ?*ULARGE_INTEGER,
    lp_total_number_of_free_bytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn GetDiskSpaceInformationA(
    root_path: ?[*:0]const u8,
    disk_space_info: ?*DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn GetDiskSpaceInformationW(
    root_path: ?[*:0]const u16,
    disk_space_info: ?*DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDriveTypeA(
    lp_root_path_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetDriveTypeW(
    lp_root_path_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileAttributesA(
    lp_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileAttributesW(
    lp_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileAttributesExA(
    lp_file_name: ?[*:0]const u8,
    f_info_level_id: GET_FILEEX_INFO_LEVELS,
    lp_file_information: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileAttributesExW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: GET_FILEEX_INFO_LEVELS,
    lp_file_information: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileInformationByHandle(
    h_file: ?HANDLE,
    lp_file_information: ?*BY_HANDLE_FILE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileSize(
    h_file: ?HANDLE,
    lp_file_size_high: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileSizeEx(
    h_file: ?HANDLE,
    lp_file_size: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileType(
    h_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFinalPathNameByHandleA(
    h_file: ?HANDLE,
    lpsz_file_path: [*:0]u8,
    cch_file_path: u32,
    dw_flags: FILE_NAME,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFinalPathNameByHandleW(
    h_file: ?HANDLE,
    lpsz_file_path: [*:0]u16,
    cch_file_path: u32,
    dw_flags: FILE_NAME,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFileTime(
    h_file: ?HANDLE,
    lp_creation_time: ?*FILETIME,
    lp_last_access_time: ?*FILETIME,
    lp_last_write_time: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFullPathNameW(
    lp_file_name: ?[*:0]const u16,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u16,
    lp_file_part: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetFullPathNameA(
    lp_file_name: ?[*:0]const u8,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u8,
    lp_file_part: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetLogicalDrives() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetLogicalDriveStringsW(
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetLongPathNameA(
    lpsz_short_path: ?[*:0]const u8,
    lpsz_long_path: ?[*:0]u8,
    cch_buffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetLongPathNameW(
    lpsz_short_path: ?[*:0]const u16,
    lpsz_long_path: ?[*:0]u16,
    cch_buffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn AreShortNamesEnabled(
    handle: ?HANDLE,
    enabled: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetShortPathNameW(
    lpsz_long_path: ?[*:0]const u16,
    lpsz_short_path: ?[*:0]u16,
    cch_buffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTempFileNameW(
    lp_path_name: ?[*:0]const u16,
    lp_prefix_string: ?[*:0]const u16,
    u_unique: u32,
    lp_temp_file_name: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetVolumeInformationByHandleW(
    h_file: ?HANDLE,
    lp_volume_name_buffer: ?[*:0]u16,
    n_volume_name_size: u32,
    lp_volume_serial_number: ?*u32,
    lp_maximum_component_length: ?*u32,
    lp_file_system_flags: ?*u32,
    lp_file_system_name_buffer: ?[*:0]u16,
    n_file_system_name_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumeInformationW(
    lp_root_path_name: ?[*:0]const u16,
    lp_volume_name_buffer: ?[*:0]u16,
    n_volume_name_size: u32,
    lp_volume_serial_number: ?*u32,
    lp_maximum_component_length: ?*u32,
    lp_file_system_flags: ?*u32,
    lp_file_system_name_buffer: ?[*:0]u16,
    n_file_system_name_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumePathNameW(
    lpsz_file_name: ?[*:0]const u16,
    lpsz_volume_path_name: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LocalFileTimeToFileTime(
    lp_local_file_time: ?*const FILETIME,
    lp_file_time: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LockFile(
    h_file: ?HANDLE,
    dw_file_offset_low: u32,
    dw_file_offset_high: u32,
    n_number_of_bytes_to_lock_low: u32,
    n_number_of_bytes_to_lock_high: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LockFileEx(
    h_file: ?HANDLE,
    dw_flags: LOCK_FILE_FLAGS,
    dw_reserved: u32,
    n_number_of_bytes_to_lock_low: u32,
    n_number_of_bytes_to_lock_high: u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn QueryDosDeviceW(
    lp_device_name: ?[*:0]const u16,
    lp_target_path: ?[*:0]u16,
    ucch_max: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadFile(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*anyopaque,
    n_number_of_bytes_to_read: u32,
    lp_number_of_bytes_read: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadFileEx(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*anyopaque,
    n_number_of_bytes_to_read: u32,
    lp_overlapped: ?*OVERLAPPED,
    lp_completion_routine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadFileScatter(
    h_file: ?HANDLE,
    a_segment_array: ?*FILE_SEGMENT_ELEMENT,
    n_number_of_bytes_to_read: u32,
    lp_reserved: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RemoveDirectoryA(
    lp_path_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RemoveDirectoryW(
    lp_path_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetEndOfFile(
    h_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileAttributesA(
    lp_file_name: ?[*:0]const u8,
    dw_file_attributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileAttributesW(
    lp_file_name: ?[*:0]const u16,
    dw_file_attributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileInformationByHandle(
    h_file: ?HANDLE,
    file_information_class: FILE_INFO_BY_HANDLE_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lp_file_information: ?*anyopaque,
    dw_buffer_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFilePointer(
    h_file: ?HANDLE,
    l_distance_to_move: i32,
    lp_distance_to_move_high: ?*i32,
    dw_move_method: SET_FILE_POINTER_MOVE_METHOD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFilePointerEx(
    h_file: ?HANDLE,
    li_distance_to_move: LARGE_INTEGER,
    lp_new_file_pointer: ?*LARGE_INTEGER,
    dw_move_method: SET_FILE_POINTER_MOVE_METHOD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileTime(
    h_file: ?HANDLE,
    lp_creation_time: ?*const FILETIME,
    lp_last_access_time: ?*const FILETIME,
    lp_last_write_time: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileValidData(
    h_file: ?HANDLE,
    valid_data_length: i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn UnlockFile(
    h_file: ?HANDLE,
    dw_file_offset_low: u32,
    dw_file_offset_high: u32,
    n_number_of_bytes_to_unlock_low: u32,
    n_number_of_bytes_to_unlock_high: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn UnlockFileEx(
    h_file: ?HANDLE,
    dw_reserved: u32,
    n_number_of_bytes_to_unlock_low: u32,
    n_number_of_bytes_to_unlock_high: u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteFile(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*const anyopaque,
    n_number_of_bytes_to_write: u32,
    lp_number_of_bytes_written: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteFileEx(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*const anyopaque,
    n_number_of_bytes_to_write: u32,
    lp_overlapped: ?*OVERLAPPED,
    lp_completion_routine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteFileGather(
    h_file: ?HANDLE,
    a_segment_array: ?*FILE_SEGMENT_ELEMENT,
    n_number_of_bytes_to_write: u32,
    lp_reserved: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTempPathW(
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumeNameForVolumeMountPointW(
    lpsz_volume_mount_point: ?[*:0]const u16,
    lpsz_volume_name: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumePathNamesForVolumeNameW(
    lpsz_volume_name: ?[*:0]const u16,
    lpsz_volume_path_names: ?[*]u16,
    cch_buffer_length: u32,
    lpcch_return_length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn CreateFile2(
    lp_file_name: ?[*:0]const u16,
    dw_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    dw_creation_disposition: FILE_CREATION_DISPOSITION,
    p_create_ex_params: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileIoOverlappedRange(
    file_handle: ?HANDLE,
    overlapped_range_start: ?*u8,
    length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetCompressedFileSizeA(
    lp_file_name: ?[*:0]const u8,
    lp_file_size_high: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetCompressedFileSizeW(
    lp_file_name: ?[*:0]const u16,
    lp_file_size_high: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstStreamW(
    lp_file_name: ?[*:0]const u16,
    info_level: STREAM_INFO_LEVELS,
    lp_find_stream_data: ?*anyopaque,
    dw_flags: u32,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindNextStreamW(
    h_find_stream: FindStreamHandle,
    lp_find_stream_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn AreFileApisANSI() callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTempPathA(
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstFileNameW(
    lp_file_name: ?[*:0]const u16,
    dw_flags: u32,
    string_length: ?*u32,
    link_name: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindNextFileNameW(
    h_find_stream: FindFileNameHandle,
    string_length: ?*u32,
    link_name: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumeInformationA(
    lp_root_path_name: ?[*:0]const u8,
    lp_volume_name_buffer: ?[*:0]u8,
    n_volume_name_size: u32,
    lp_volume_serial_number: ?*u32,
    lp_maximum_component_length: ?*u32,
    lp_file_system_flags: ?*u32,
    lp_file_system_name_buffer: ?[*:0]u8,
    n_file_system_name_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTempFileNameA(
    lp_path_name: ?[*:0]const u8,
    lp_prefix_string: ?[*:0]const u8,
    u_unique: u32,
    lp_temp_file_name: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileApisToOEM() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileApisToANSI() callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn GetTempPath2W(
    buffer_length: u32,
    buffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn GetTempPath2A(
    buffer_length: u32,
    buffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CopyFileFromAppW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    b_fail_if_exists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateDirectoryFromAppW(
    lp_path_name: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFileFromAppW(
    lp_file_name: ?[*:0]const u16,
    dw_desired_access: u32,
    dw_share_mode: u32,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_creation_disposition: u32,
    dw_flags_and_attributes: u32,
    h_template_file: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFile2FromAppW(
    lp_file_name: ?[*:0]const u16,
    dw_desired_access: u32,
    dw_share_mode: u32,
    dw_creation_disposition: u32,
    p_create_ex_params: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn DeleteFileFromAppW(
    lp_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn FindFirstFileExFromAppW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: FINDEX_INFO_LEVELS,
    lp_find_file_data: ?*anyopaque,
    f_search_op: FINDEX_SEARCH_OPS,
    lp_search_filter: ?*anyopaque,
    dw_additional_flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn GetFileAttributesExFromAppW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: GET_FILEEX_INFO_LEVELS,
    lp_file_information: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn MoveFileFromAppW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn RemoveDirectoryFromAppW(
    lp_path_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn ReplaceFileFromAppW(
    lp_replaced_file_name: ?[*:0]const u16,
    lp_replacement_file_name: ?[*:0]const u16,
    lp_backup_file_name: ?[*:0]const u16,
    dw_replace_flags: u32,
    lp_exclude: ?*anyopaque,
    lp_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn SetFileAttributesFromAppW(
    lp_file_name: ?[*:0]const u16,
    dw_file_attributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerFindFileA(
    u_flags: VER_FIND_FILE_FLAGS,
    sz_file_name: ?[*:0]const u8,
    sz_win_dir: ?[*:0]const u8,
    sz_app_dir: ?[*:0]const u8,
    sz_cur_dir: [*:0]u8,
    pu_cur_dir_len: ?*u32,
    sz_dest_dir: [*:0]u8,
    pu_dest_dir_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) VER_FIND_FILE_STATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerFindFileW(
    u_flags: VER_FIND_FILE_FLAGS,
    sz_file_name: ?[*:0]const u16,
    sz_win_dir: ?[*:0]const u16,
    sz_app_dir: ?[*:0]const u16,
    sz_cur_dir: [*:0]u16,
    pu_cur_dir_len: ?*u32,
    sz_dest_dir: [*:0]u16,
    pu_dest_dir_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) VER_FIND_FILE_STATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerInstallFileA(
    u_flags: VER_INSTALL_FILE_FLAGS,
    sz_src_file_name: ?[*:0]const u8,
    sz_dest_file_name: ?[*:0]const u8,
    sz_src_dir: ?[*:0]const u8,
    sz_dest_dir: ?[*:0]const u8,
    sz_cur_dir: ?[*:0]const u8,
    sz_tmp_file: [*:0]u8,
    pu_tmp_file_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) VER_INSTALL_FILE_STATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerInstallFileW(
    u_flags: VER_INSTALL_FILE_FLAGS,
    sz_src_file_name: ?[*:0]const u16,
    sz_dest_file_name: ?[*:0]const u16,
    sz_src_dir: ?[*:0]const u16,
    sz_dest_dir: ?[*:0]const u16,
    sz_cur_dir: ?[*:0]const u16,
    sz_tmp_file: [*:0]u16,
    pu_tmp_file_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) VER_INSTALL_FILE_STATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn GetFileVersionInfoSizeA(
    lptstr_filename: ?[*:0]const u8,
    lpdw_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn GetFileVersionInfoSizeW(
    lptstr_filename: ?[*:0]const u16,
    lpdw_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn GetFileVersionInfoA(
    lptstr_filename: ?[*:0]const u8,
    dw_handle: u32,
    dw_len: u32,
    // TODO: what to do with BytesParamIndex 2?
    lp_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn GetFileVersionInfoW(
    lptstr_filename: ?[*:0]const u16,
    dw_handle: u32,
    dw_len: u32,
    // TODO: what to do with BytesParamIndex 2?
    lp_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "version" fn GetFileVersionInfoSizeExA(
    dw_flags: GET_FILE_VERSION_INFO_FLAGS,
    lpwstr_filename: ?[*:0]const u8,
    lpdw_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "version" fn GetFileVersionInfoSizeExW(
    dw_flags: GET_FILE_VERSION_INFO_FLAGS,
    lpwstr_filename: ?[*:0]const u16,
    lpdw_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "version" fn GetFileVersionInfoExA(
    dw_flags: GET_FILE_VERSION_INFO_FLAGS,
    lpwstr_filename: ?[*:0]const u8,
    dw_handle: u32,
    dw_len: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "version" fn GetFileVersionInfoExW(
    dw_flags: GET_FILE_VERSION_INFO_FLAGS,
    lpwstr_filename: ?[*:0]const u16,
    dw_handle: u32,
    dw_len: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn VerLanguageNameA(
    w_lang: u32,
    sz_lang: [*:0]u8,
    cch_lang: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn VerLanguageNameW(
    w_lang: u32,
    sz_lang: [*:0]u16,
    cch_lang: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerQueryValueA(
    p_block: ?*const anyopaque,
    lp_sub_block: ?[*:0]const u8,
    lplp_buffer: ?*?*anyopaque,
    pu_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "version" fn VerQueryValueW(
    p_block: ?*const anyopaque,
    lp_sub_block: ?[*:0]const u16,
    lplp_buffer: ?*?*anyopaque,
    pu_len: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "clfsw32" fn LsnEqual(
    plsn1: ?*const CLS_LSN,
    plsn2: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "clfsw32" fn LsnLess(
    plsn1: ?*const CLS_LSN,
    plsn2: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "clfsw32" fn LsnGreater(
    plsn1: ?*const CLS_LSN,
    plsn2: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "clfsw32" fn LsnNull(
    plsn: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnContainer(
    plsn: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnCreate(
    cid_container: u32,
    off_block: u32,
    c_record: u32,
    retval: *CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnBlockOffset(
    plsn: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnRecordSequence(
    plsn: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "clfsw32" fn LsnInvalid(
    plsn: ?*const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "clfsw32" fn LsnIncrement(
    plsn: ?*CLS_LSN,
    retval: *CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogFile(
    psz_log_file_name: ?[*:0]const u16,
    f_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    psa_log_file: ?*SECURITY_ATTRIBUTES,
    f_create_disposition: FILE_CREATION_DISPOSITION,
    f_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogByHandle(
    h_log: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogFile(
    psz_log_file_name: ?[*:0]const u16,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AddLogContainer(
    h_log: ?HANDLE,
    pcb_container: ?*u64,
    pwsz_container_path: ?PWSTR,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AddLogContainerSet(
    h_log: ?HANDLE,
    c_container: u16,
    pcb_container: ?*u64,
    rgwsz_container_path: [*]?PWSTR,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogContainer(
    h_log: ?HANDLE,
    pwsz_container_path: ?PWSTR,
    f_force: BOOL,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogContainerSet(
    h_log: ?HANDLE,
    c_container: u16,
    rgwsz_container_path: [*]?PWSTR,
    f_force: BOOL,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogArchiveTail(
    h_log: ?HANDLE,
    plsn_archive_tail: ?*CLS_LSN,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetEndOfLog(
    h_log: ?HANDLE,
    plsn_end: ?*CLS_LSN,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TruncateLog(
    pv_marshal: ?*anyopaque,
    plsn_end: ?*CLS_LSN,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogContainerScanContext(
    h_log: ?HANDLE,
    c_from_container: u32,
    c_containers: u32,
    e_scan_mode: u8,
    pcx_scan: ?*CLS_SCAN_CONTEXT,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ScanLogContainers(
    pcx_scan: ?*CLS_SCAN_CONTEXT,
    e_scan_mode: u8,
    p_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AlignReservedLog(
    pv_marshal: ?*anyopaque,
    c_reserved_records: u32,
    rgcb_reservation: ?*i64,
    pcb_align_reservation: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AllocReservedLog(
    pv_marshal: ?*anyopaque,
    c_reserved_records: u32,
    pcb_adjustment: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FreeReservedLog(
    pv_marshal: ?*anyopaque,
    c_reserved_records: u32,
    pcb_adjustment: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogFileInformation(
    h_log: ?HANDLE,
    pinfo_buffer: ?*CLS_INFORMATION,
    cb_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogArchiveMode(
    h_log: ?HANDLE,
    e_mode: CLFS_LOG_ARCHIVE_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogRestartArea(
    pv_marshal: ?*anyopaque,
    ppv_restart_buffer: ?*?*anyopaque,
    pcb_restart_buffer: ?*u32,
    plsn: ?*CLS_LSN,
    ppv_context: ?*?*anyopaque,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadPreviousLogRestartArea(
    pv_read_context: ?*anyopaque,
    ppv_restart_buffer: ?*?*anyopaque,
    pcb_restart_buffer: ?*u32,
    plsn_restart: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn WriteLogRestartArea(
    pv_marshal: ?*anyopaque,
    pv_restart_buffer: ?*anyopaque,
    cb_restart_buffer: u32,
    plsn_base: ?*CLS_LSN,
    f_flags: CLFS_FLAG,
    pcb_written: ?*u32,
    plsn_next: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "clfsw32" fn GetLogReservationInfo(
    pv_marshal: ?*anyopaque,
    pcb_record_number: ?*u32,
    pcb_user_reservation: ?*i64,
    pcb_commit_reservation: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AdvanceLogBase(
    pv_marshal: ?*anyopaque,
    plsn_base: ?*CLS_LSN,
    f_flags: u32,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CloseAndResetLogFile(
    h_log: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogMarshallingArea(
    h_log: ?HANDLE,
    pfn_alloc_buffer: ?CLFS_BLOCK_ALLOCATION,
    pfn_free_buffer: ?CLFS_BLOCK_DEALLOCATION,
    pv_block_alloc_context: ?*anyopaque,
    cb_marshalling_buffer: u32,
    c_max_write_buffers: u32,
    c_max_read_buffers: u32,
    ppv_marshal: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogMarshallingArea(
    pv_marshal: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReserveAndAppendLog(
    pv_marshal: ?*anyopaque,
    rg_write_entries: ?*CLS_WRITE_ENTRY,
    c_write_entries: u32,
    plsn_undo_next: ?*CLS_LSN,
    plsn_previous: ?*CLS_LSN,
    c_reserve_records: u32,
    rgcb_reservation: ?*i64,
    f_flags: CLFS_FLAG,
    plsn: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReserveAndAppendLogAligned(
    pv_marshal: ?*anyopaque,
    rg_write_entries: ?*CLS_WRITE_ENTRY,
    c_write_entries: u32,
    cb_entry_alignment: u32,
    plsn_undo_next: ?*CLS_LSN,
    plsn_previous: ?*CLS_LSN,
    c_reserve_records: u32,
    rgcb_reservation: ?*i64,
    f_flags: CLFS_FLAG,
    plsn: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FlushLogBuffers(
    pv_marshal: ?*anyopaque,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FlushLogToLsn(
    pv_marshal_context: ?*anyopaque,
    plsn_flush: ?*CLS_LSN,
    plsn_last_flushed: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogRecord(
    pv_marshal: ?*anyopaque,
    plsn_first: ?*CLS_LSN,
    e_context_mode: CLFS_CONTEXT_MODE,
    ppv_read_buffer: ?*?*anyopaque,
    pcb_read_buffer: ?*u32,
    pe_record_type: ?*u8,
    plsn_undo_next: ?*CLS_LSN,
    plsn_previous: ?*CLS_LSN,
    ppv_read_context: ?*?*anyopaque,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadNextLogRecord(
    pv_read_context: ?*anyopaque,
    ppv_buffer: ?*?*anyopaque,
    pcb_buffer: ?*u32,
    pe_record_type: ?*u8,
    plsn_user: ?*CLS_LSN,
    plsn_undo_next: ?*CLS_LSN,
    plsn_previous: ?*CLS_LSN,
    plsn_record: ?*CLS_LSN,
    p_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TerminateReadLog(
    pv_cursor_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn PrepareLogArchive(
    h_log: ?HANDLE,
    psz_base_log_file_name: [*:0]u16,
    c_len: u32,
    plsn_low: ?*const CLS_LSN,
    plsn_high: ?*const CLS_LSN,
    pc_actual_length: ?*u32,
    poff_base_log_file_data: ?*u64,
    pcb_base_log_file_length: ?*u64,
    plsn_base: ?*CLS_LSN,
    plsn_last: ?*CLS_LSN,
    plsn_current_archive_tail: ?*CLS_LSN,
    ppv_archive_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogArchiveMetadata(
    pv_archive_context: ?*anyopaque,
    cb_offset: u32,
    cb_bytes_to_read: u32,
    pb_read_buffer: ?*u8,
    pcb_bytes_read: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetNextLogArchiveExtent(
    pv_archive_context: ?*anyopaque,
    rgad_extent: ?*CLS_ARCHIVE_DESCRIPTOR,
    c_descriptors: u32,
    pc_descriptors_returned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TerminateLogArchive(
    pv_archive_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ValidateLog(
    psz_log_file_name: ?[*:0]const u16,
    psa_log_file: ?*SECURITY_ATTRIBUTES,
    pinfo_buffer: ?*CLS_INFORMATION,
    pcb_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogContainerName(
    h_log: ?HANDLE,
    cid_logical_container: u32,
    pwstr_container_name: ?[*:0]const u16,
    c_len_container_name: u32,
    pc_actual_len_container_name: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogIoStatistics(
    h_log: ?HANDLE,
    pv_stats_buffer: ?*anyopaque,
    cb_stats_buffer: u32,
    e_stats_class: CLFS_IOSTATS_CLASS,
    pcb_stats_written: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RegisterManageableLogClient(
    h_log: ?HANDLE,
    p_callbacks: ?*LOG_MANAGEMENT_CALLBACKS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeregisterManageableLogClient(
    h_log: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogNotification(
    h_log: ?HANDLE,
    p_notification: ?*CLFS_MGMT_NOTIFICATION,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn InstallLogPolicy(
    h_log: ?HANDLE,
    p_policy: ?*CLFS_MGMT_POLICY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogPolicy(
    h_log: ?HANDLE,
    e_policy_type: CLFS_MGMT_POLICY_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn QueryLogPolicy(
    h_log: ?HANDLE,
    e_policy_type: CLFS_MGMT_POLICY_TYPE,
    p_policy_buffer: ?*CLFS_MGMT_POLICY,
    pcb_policy_buffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogFileSizeWithPolicy(
    h_log: ?HANDLE,
    p_desired_size: ?*u64,
    p_resulting_size: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn HandleLogFull(
    h_log: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LogTailAdvanceFailure(
    h_log: ?HANDLE,
    dw_reason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RegisterForLogWriteNotification(
    h_log: ?HANDLE,
    cb_threshold: u32,
    f_enable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn QueryUsersOnEncryptedFile(
    lp_file_name: ?[*:0]const u16,
    p_users: ?*?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn QueryRecoveryAgentsOnEncryptedFile(
    lp_file_name: ?[*:0]const u16,
    p_recovery_agents: ?*?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn RemoveUsersFromEncryptedFile(
    lp_file_name: ?[*:0]const u16,
    p_hashes: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn AddUsersToEncryptedFile(
    lp_file_name: ?[*:0]const u16,
    p_encryption_certificates: ?*ENCRYPTION_CERTIFICATE_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn SetUserFileEncryptionKey(
    p_encryption_certificate: ?*ENCRYPTION_CERTIFICATE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advapi32" fn SetUserFileEncryptionKeyEx(
    p_encryption_certificate: ?*ENCRYPTION_CERTIFICATE,
    dw_capabilities: u32,
    dw_flags: u32,
    pv_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn FreeEncryptionCertificateHashList(
    p_users: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn EncryptionDisable(
    dir_path: ?[*:0]const u16,
    disable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn DuplicateEncryptionInfoFile(
    src_file_name: ?[*:0]const u16,
    dst_file_name: ?[*:0]const u16,
    dw_creation_distribution: u32,
    dw_attributes: u32,
    lp_security_attributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advapi32" fn GetEncryptedFileMetadata(
    lp_file_name: ?[*:0]const u16,
    pcb_metadata: ?*u32,
    ppb_metadata: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advapi32" fn SetEncryptedFileMetadata(
    lp_file_name: ?[*:0]const u16,
    pb_old_metadata: ?*u8,
    pb_new_metadata: ?*u8,
    p_owner_hash: ?*ENCRYPTION_CERTIFICATE_HASH,
    dw_operation: u32,
    p_certificates_added: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advapi32" fn FreeEncryptedFileMetadata(
    pb_metadata: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn LZStart() callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn LZDone() callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn CopyLZFile(
    hf_source: i32,
    hf_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZCopy(
    hf_source: i32,
    hf_dest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZInit(
    hf_source: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetExpandedNameA(
    lpsz_source: ?PSTR,
    lpsz_buffer: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetExpandedNameW(
    lpsz_source: ?PWSTR,
    lpsz_buffer: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZOpenFileA(
    lp_file_name: ?PSTR,
    lp_re_open_buf: ?*OFSTRUCT,
    w_style: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZOpenFileW(
    lp_file_name: ?PWSTR,
    lp_re_open_buf: ?*OFSTRUCT,
    w_style: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZSeek(
    h_file: i32,
    l_offset: i32,
    i_origin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZRead(
    h_file: i32,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?PSTR,
    cb_read: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LZClose(
    h_file: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wofutil" fn WofShouldCompressBinaries(
    volume: ?[*:0]const u16,
    algorithm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wofutil" fn WofGetDriverVersion(
    file_or_volume_handle: ?HANDLE,
    provider: u32,
    wof_version: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofSetFileDataLocation(
    file_handle: ?HANDLE,
    provider: u32,
    external_file_info: ?*anyopaque,
    length: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofIsExternalFile(
    file_path: ?[*:0]const u16,
    is_external_file: ?*BOOL,
    provider: ?*u32,
    external_file_info: ?*anyopaque,
    buffer_length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofEnumEntries(
    volume_name: ?[*:0]const u16,
    provider: u32,
    enum_proc: ?WofEnumEntryProc,
    user_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofWimAddEntry(
    volume_name: ?[*:0]const u16,
    wim_path: ?[*:0]const u16,
    wim_type: u32,
    wim_index: u32,
    data_source_id: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofWimEnumFiles(
    volume_name: ?[*:0]const u16,
    data_source_id: LARGE_INTEGER,
    enum_proc: ?WofEnumFilesProc,
    user_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofWimSuspendEntry(
    volume_name: ?[*:0]const u16,
    data_source_id: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofWimRemoveEntry(
    volume_name: ?[*:0]const u16,
    data_source_id: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofWimUpdateEntry(
    volume_name: ?[*:0]const u16,
    data_source_id: LARGE_INTEGER,
    new_wim_path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wofutil" fn WofFileEnumFiles(
    volume_name: ?[*:0]const u16,
    algorithm: u32,
    enum_proc: ?WofEnumFilesProc,
    user_data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogCreateFileReadContext(
    log_path: ?[*:0]const u16,
    beginning_lsn: CLS_LSN,
    ending_lsn: CLS_LSN,
    txf_file_id: ?*TXF_ID,
    txf_log_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogCreateRangeReadContext(
    log_path: ?[*:0]const u16,
    beginning_lsn: CLS_LSN,
    ending_lsn: CLS_LSN,
    beginning_virtual_clock: ?*LARGE_INTEGER,
    ending_virtual_clock: ?*LARGE_INTEGER,
    record_type_mask: u32,
    txf_log_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogDestroyReadContext(
    txf_log_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogReadRecords(
    txf_log_context: ?*anyopaque,
    buffer_length: u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*anyopaque,
    bytes_used: ?*u32,
    record_count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfReadMetadataInfo(
    file_handle: ?HANDLE,
    txf_file_id: ?*TXF_ID,
    last_lsn: ?*CLS_LSN,
    transaction_state: ?*u32,
    locking_transaction: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogRecordGetFileName(
    // TODO: what to do with BytesParamIndex 1?
    record_buffer: ?*anyopaque,
    record_buffer_length_in_bytes: u32,
    // TODO: what to do with BytesParamIndex 3?
    name_buffer: ?PWSTR,
    name_buffer_length_in_bytes: ?*u32,
    txf_id: ?*TXF_ID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogRecordGetGenericType(
    record_buffer: ?*anyopaque,
    record_buffer_length_in_bytes: u32,
    generic_type: ?*u32,
    virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfSetThreadMiniVersionForCreate(
    mini_version: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "txfw32" fn TxfGetThreadMiniVersionForCreate(
    mini_version: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateTransaction(
    lp_transaction_attributes: ?*SECURITY_ATTRIBUTES,
    u_o_w: ?*Guid,
    create_options: u32,
    isolation_level: u32,
    isolation_flags: u32,
    timeout: u32,
    description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransaction(
    dw_desired_access: u32,
    transaction_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitTransaction(
    transaction_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitTransactionAsync(
    transaction_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackTransaction(
    transaction_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackTransactionAsync(
    transaction_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionId(
    transaction_handle: ?HANDLE,
    transaction_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionInformation(
    transaction_handle: ?HANDLE,
    outcome: ?*u32,
    isolation_level: ?*u32,
    isolation_flags: ?*u32,
    timeout: ?*u32,
    buffer_length: u32,
    description: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetTransactionInformation(
    transaction_handle: ?HANDLE,
    isolation_level: u32,
    isolation_flags: u32,
    timeout: u32,
    description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateTransactionManager(
    lp_transaction_attributes: ?*SECURITY_ATTRIBUTES,
    log_file_name: ?PWSTR,
    create_options: u32,
    commit_strength: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransactionManager(
    log_file_name: ?PWSTR,
    desired_access: u32,
    open_options: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransactionManagerById(
    transaction_manager_id: ?*Guid,
    desired_access: u32,
    open_options: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RenameTransactionManager(
    log_file_name: ?PWSTR,
    existing_transaction_manager_guid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollforwardTransactionManager(
    transaction_manager_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverTransactionManager(
    transaction_manager_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetCurrentClockTransactionManager(
    transaction_manager_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionManagerId(
    transaction_manager_handle: ?HANDLE,
    transaction_manager_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateResourceManager(
    lp_resource_manager_attributes: ?*SECURITY_ATTRIBUTES,
    resource_manager_id: ?*Guid,
    create_options: u32,
    tm_handle: ?HANDLE,
    description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenResourceManager(
    dw_desired_access: u32,
    tm_handle: ?HANDLE,
    resource_manager_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverResourceManager(
    resource_manager_handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetNotificationResourceManager(
    resource_manager_handle: ?HANDLE,
    transaction_notification: ?*TRANSACTION_NOTIFICATION,
    notification_length: u32,
    dw_milliseconds: u32,
    return_length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetNotificationResourceManagerAsync(
    resource_manager_handle: ?HANDLE,
    transaction_notification: ?*TRANSACTION_NOTIFICATION,
    transaction_notification_length: u32,
    return_length: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetResourceManagerCompletionPort(
    resource_manager_handle: ?HANDLE,
    io_completion_port_handle: ?HANDLE,
    completion_key: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateEnlistment(
    lp_enlistment_attributes: ?*SECURITY_ATTRIBUTES,
    resource_manager_handle: ?HANDLE,
    transaction_handle: ?HANDLE,
    notification_mask: u32,
    create_options: u32,
    enlistment_key: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenEnlistment(
    dw_desired_access: u32,
    resource_manager_handle: ?HANDLE,
    enlistment_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverEnlistment(
    enlistment_handle: ?HANDLE,
    enlistment_key: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetEnlistmentRecoveryInformation(
    enlistment_handle: ?HANDLE,
    buffer_size: u32,
    buffer: ?*anyopaque,
    buffer_used: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetEnlistmentId(
    enlistment_handle: ?HANDLE,
    enlistment_id: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetEnlistmentRecoveryInformation(
    enlistment_handle: ?HANDLE,
    buffer_size: u32,
    buffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrepareEnlistment(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrePrepareEnlistment(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitEnlistment(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackEnlistment(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrePrepareComplete(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrepareComplete(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn ReadOnlyEnlistment(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitComplete(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackComplete(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SinglePhaseReject(
    enlistment_handle: ?HANDLE,
    tm_virtual_clock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareAdd(
    servername: ?PWSTR,
    level: u32,
    buf: ?*u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareEnum(
    servername: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "netapi32" fn NetShareEnumSticky(
    servername: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareGetInfo(
    servername: ?PWSTR,
    netname: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareSetInfo(
    servername: ?PWSTR,
    netname: ?PWSTR,
    level: u32,
    buf: ?*u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareDel(
    servername: ?PWSTR,
    netname: ?PWSTR,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "netapi32" fn NetShareDelSticky(
    servername: ?PWSTR,
    netname: ?PWSTR,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareCheck(
    servername: ?PWSTR,
    device: ?PWSTR,
    type: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetShareDelEx(
    servername: ?PWSTR,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "netapi32" fn NetServerAliasAdd(
    servername: ?PWSTR,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "netapi32" fn NetServerAliasDel(
    servername: ?PWSTR,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "netapi32" fn NetServerAliasEnum(
    servername: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resumehandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetSessionEnum(
    servername: ?PWSTR,
    unc_client_name: ?PWSTR,
    username: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetSessionDel(
    servername: ?PWSTR,
    unc_client_name: ?PWSTR,
    username: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetSessionGetInfo(
    servername: ?PWSTR,
    unc_client_name: ?PWSTR,
    username: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetConnectionEnum(
    servername: ?PWSTR,
    qualifier: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetFileClose(
    servername: ?PWSTR,
    fileid: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetFileEnum(
    servername: ?PWSTR,
    basepath: ?PWSTR,
    username: ?PWSTR,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetFileGetInfo(
    servername: ?PWSTR,
    fileid: u32,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "netapi32" fn NetStatisticsGet(
    server_name: ?*i8,
    service: ?*i8,
    level: u32,
    options: u32,
    buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-ioring-l1-1-0" fn QueryIoRingCapabilities(
    capabilities: ?*IORING_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn IsIoRingOpSupported(
    io_ring: ?*HIORING__,
    op: IORING_OP_CODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-ioring-l1-1-0" fn CreateIoRing(
    ioring_version: IORING_VERSION,
    flags: IORING_CREATE_FLAGS,
    submission_queue_size: u32,
    completion_queue_size: u32,
    h: ?*?*HIORING__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn GetIoRingInfo(
    io_ring: ?*HIORING__,
    info: ?*IORING_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn SubmitIoRing(
    io_ring: ?*HIORING__,
    wait_operations: u32,
    milliseconds: u32,
    submitted_entries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn CloseIoRing(
    io_ring: ?*HIORING__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn PopIoRingCompletion(
    io_ring: ?*HIORING__,
    cqe: ?*IORING_CQE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn SetIoRingCompletionEvent(
    io_ring: ?*HIORING__,
    h_event: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn BuildIoRingCancelRequest(
    io_ring: ?*HIORING__,
    file: IORING_HANDLE_REF,
    op_to_cancel: usize,
    user_data: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn BuildIoRingReadFile(
    io_ring: ?*HIORING__,
    file_ref: IORING_HANDLE_REF,
    data_ref: IORING_BUFFER_REF,
    number_of_bytes_to_read: u32,
    file_offset: u64,
    user_data: usize,
    flags: IORING_SQE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn BuildIoRingRegisterFileHandles(
    io_ring: ?*HIORING__,
    count: u32,
    handles: [*]const ?HANDLE,
    user_data: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-ioring-l1-1-0" fn BuildIoRingRegisterBuffers(
    io_ring: ?*HIORING__,
    count: u32,
    buffers: [*]const IORING_BUFFER_INFO,
    user_data: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64EnableWow64FsRedirection(
    wow64_fs_enable_redirection: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64DisableWow64FsRedirection(
    old_value: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64RevertWow64FsRedirection(
    ol_value: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetBinaryTypeA(
    lp_application_name: ?[*:0]const u8,
    lp_binary_type: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetBinaryTypeW(
    lp_application_name: ?[*:0]const u16,
    lp_binary_type: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetShortPathNameA(
    lpsz_long_path: ?[*:0]const u8,
    lpsz_short_path: ?[*:0]u8,
    cch_buffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetLongPathNameTransactedA(
    lpsz_short_path: ?[*:0]const u8,
    lpsz_long_path: ?[*:0]u8,
    cch_buffer: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetLongPathNameTransactedW(
    lpsz_short_path: ?[*:0]const u16,
    lpsz_long_path: ?[*:0]u16,
    cch_buffer: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileCompletionNotificationModes(
    file_handle: ?HANDLE,
    flags: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileShortNameA(
    h_file: ?HANDLE,
    lp_short_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetFileShortNameW(
    h_file: ?HANDLE,
    lp_short_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetTapePosition(
    h_device: ?HANDLE,
    dw_position_method: TAPE_POSITION_METHOD,
    dw_partition: u32,
    dw_offset_low: u32,
    dw_offset_high: u32,
    b_immediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTapePosition(
    h_device: ?HANDLE,
    dw_position_type: TAPE_POSITION_TYPE,
    lpdw_partition: ?*u32,
    lpdw_offset_low: ?*u32,
    lpdw_offset_high: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn PrepareTape(
    h_device: ?HANDLE,
    dw_operation: PREPARE_TAPE_OPERATION,
    b_immediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn EraseTape(
    h_device: ?HANDLE,
    dw_erase_type: ERASE_TAPE_TYPE,
    b_immediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateTapePartition(
    h_device: ?HANDLE,
    dw_partition_method: CREATE_TAPE_PARTITION_METHOD,
    dw_count: u32,
    dw_size: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteTapemark(
    h_device: ?HANDLE,
    dw_tapemark_type: TAPEMARK_TYPE,
    dw_tapemark_count: u32,
    b_immediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTapeStatus(
    h_device: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetTapeParameters(
    h_device: ?HANDLE,
    dw_operation: GET_TAPE_DRIVE_PARAMETERS_OPERATION,
    lpdw_size: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lp_tape_information: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetTapeParameters(
    h_device: ?HANDLE,
    dw_operation: TAPE_INFORMATION_TYPE,
    lp_tape_information: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn EncryptFileA(
    lp_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn EncryptFileW(
    lp_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn DecryptFileA(
    lp_file_name: ?[*:0]const u8,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn DecryptFileW(
    lp_file_name: ?[*:0]const u16,
    dw_reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn FileEncryptionStatusA(
    lp_file_name: ?[*:0]const u8,
    lp_status: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn FileEncryptionStatusW(
    lp_file_name: ?[*:0]const u16,
    lp_status: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn OpenEncryptedFileRawA(
    lp_file_name: ?[*:0]const u8,
    ul_flags: u32,
    pv_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn OpenEncryptedFileRawW(
    lp_file_name: ?[*:0]const u16,
    ul_flags: u32,
    pv_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn ReadEncryptedFileRaw(
    pf_export_callback: ?PFE_EXPORT_FUNC,
    pv_callback_context: ?*anyopaque,
    pv_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn WriteEncryptedFileRaw(
    pf_import_callback: ?PFE_IMPORT_FUNC,
    pv_callback_context: ?*anyopaque,
    pv_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CloseEncryptedFileRaw(
    pv_context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn OpenFile(
    lp_file_name: ?[*:0]const u8,
    lp_re_open_buff: ?*OFSTRUCT,
    u_style: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn BackupRead(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*u8,
    n_number_of_bytes_to_read: u32,
    lp_number_of_bytes_read: ?*u32,
    b_abort: BOOL,
    b_process_security: BOOL,
    lp_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn BackupSeek(
    h_file: ?HANDLE,
    dw_low_bytes_to_seek: u32,
    dw_high_bytes_to_seek: u32,
    lpdw_low_byte_seeked: ?*u32,
    lpdw_high_byte_seeked: ?*u32,
    lp_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn BackupWrite(
    h_file: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*u8,
    n_number_of_bytes_to_write: u32,
    lp_number_of_bytes_written: ?*u32,
    b_abort: BOOL,
    b_process_security: BOOL,
    lp_context: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetLogicalDriveStringsA(
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn SetSearchPathMode(
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateDirectoryExA(
    lp_template_directory: ?[*:0]const u8,
    lp_new_directory: ?[*:0]const u8,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateDirectoryExW(
    lp_template_directory: ?[*:0]const u16,
    lp_new_directory: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateDirectoryTransactedA(
    lp_template_directory: ?[*:0]const u8,
    lp_new_directory: ?[*:0]const u8,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateDirectoryTransactedW(
    lp_template_directory: ?[*:0]const u16,
    lp_new_directory: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn RemoveDirectoryTransactedA(
    lp_path_name: ?[*:0]const u8,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn RemoveDirectoryTransactedW(
    lp_path_name: ?[*:0]const u16,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFullPathNameTransactedA(
    lp_file_name: ?[*:0]const u8,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u8,
    lp_file_part: ?*?PSTR,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFullPathNameTransactedW(
    lp_file_name: ?[*:0]const u16,
    n_buffer_length: u32,
    lp_buffer: ?[*:0]u16,
    lp_file_part: ?*?PWSTR,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DefineDosDeviceA(
    dw_flags: DEFINE_DOS_DEVICE_FLAGS,
    lp_device_name: ?[*:0]const u8,
    lp_target_path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn QueryDosDeviceA(
    lp_device_name: ?[*:0]const u8,
    lp_target_path: ?[*:0]u8,
    ucch_max: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateFileTransactedA(
    lp_file_name: ?[*:0]const u8,
    dw_desired_access: u32,
    dw_share_mode: FILE_SHARE_MODE,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_creation_disposition: FILE_CREATION_DISPOSITION,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
    h_template_file: ?HANDLE,
    h_transaction: ?HANDLE,
    pus_mini_version: ?*TXFS_MINIVERSION,
    lp_extended_parameter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateFileTransactedW(
    lp_file_name: ?[*:0]const u16,
    dw_desired_access: u32,
    dw_share_mode: FILE_SHARE_MODE,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_creation_disposition: FILE_CREATION_DISPOSITION,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
    h_template_file: ?HANDLE,
    h_transaction: ?HANDLE,
    pus_mini_version: ?*TXFS_MINIVERSION,
    lp_extended_parameter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn ReOpenFile(
    h_original_file: ?HANDLE,
    dw_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileAttributesTransactedA(
    lp_file_name: ?[*:0]const u8,
    dw_file_attributes: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileAttributesTransactedW(
    lp_file_name: ?[*:0]const u16,
    dw_file_attributes: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileAttributesTransactedA(
    lp_file_name: ?[*:0]const u8,
    f_info_level_id: GET_FILEEX_INFO_LEVELS,
    lp_file_information: ?*anyopaque,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileAttributesTransactedW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: GET_FILEEX_INFO_LEVELS,
    lp_file_information: ?*anyopaque,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetCompressedFileSizeTransactedA(
    lp_file_name: ?[*:0]const u8,
    lp_file_size_high: ?*u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetCompressedFileSizeTransactedW(
    lp_file_name: ?[*:0]const u16,
    lp_file_size_high: ?*u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn DeleteFileTransactedA(
    lp_file_name: ?[*:0]const u8,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn DeleteFileTransactedW(
    lp_file_name: ?[*:0]const u16,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CheckNameLegalDOS8Dot3A(
    lp_name: ?[*:0]const u8,
    lp_oem_name: ?[*:0]u8,
    oem_name_size: u32,
    pb_name_contains_spaces: ?*BOOL,
    pb_name_legal: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CheckNameLegalDOS8Dot3W(
    lp_name: ?[*:0]const u16,
    lp_oem_name: ?[*:0]u8,
    oem_name_size: u32,
    pb_name_contains_spaces: ?*BOOL,
    pb_name_legal: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstFileTransactedA(
    lp_file_name: ?[*:0]const u8,
    f_info_level_id: FINDEX_INFO_LEVELS,
    lp_find_file_data: ?*anyopaque,
    f_search_op: FINDEX_SEARCH_OPS,
    lp_search_filter: ?*anyopaque,
    dw_additional_flags: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstFileTransactedW(
    lp_file_name: ?[*:0]const u16,
    f_info_level_id: FINDEX_INFO_LEVELS,
    lp_find_file_data: ?*anyopaque,
    f_search_op: FINDEX_SEARCH_OPS,
    lp_search_filter: ?*anyopaque,
    dw_additional_flags: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CopyFileA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    b_fail_if_exists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CopyFileW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    b_fail_if_exists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CopyFileExA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    pb_cancel: ?*i32,
    dw_copy_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CopyFileExW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    pb_cancel: ?*i32,
    dw_copy_flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CopyFileTransactedA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    pb_cancel: ?*i32,
    dw_copy_flags: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CopyFileTransactedW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    pb_cancel: ?*i32,
    dw_copy_flags: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn CopyFile2(
    pwsz_existing_file_name: ?[*:0]const u16,
    pwsz_new_file_name: ?[*:0]const u16,
    p_extended_parameters: ?*COPYFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileExA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    dw_flags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileExW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    dw_flags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileWithProgressA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    dw_flags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MoveFileWithProgressW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    dw_flags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn MoveFileTransactedA(
    lp_existing_file_name: ?[*:0]const u8,
    lp_new_file_name: ?[*:0]const u8,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    dw_flags: MOVE_FILE_FLAGS,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn MoveFileTransactedW(
    lp_existing_file_name: ?[*:0]const u16,
    lp_new_file_name: ?[*:0]const u16,
    lp_progress_routine: ?LPPROGRESS_ROUTINE,
    lp_data: ?*anyopaque,
    dw_flags: MOVE_FILE_FLAGS,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReplaceFileA(
    lp_replaced_file_name: ?[*:0]const u8,
    lp_replacement_file_name: ?[*:0]const u8,
    lp_backup_file_name: ?[*:0]const u8,
    dw_replace_flags: REPLACE_FILE_FLAGS,
    lp_exclude: ?*anyopaque,
    lp_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReplaceFileW(
    lp_replaced_file_name: ?[*:0]const u16,
    lp_replacement_file_name: ?[*:0]const u16,
    lp_backup_file_name: ?[*:0]const u16,
    dw_replace_flags: REPLACE_FILE_FLAGS,
    lp_exclude: ?*anyopaque,
    lp_reserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateHardLinkA(
    lp_file_name: ?[*:0]const u8,
    lp_existing_file_name: ?[*:0]const u8,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateHardLinkW(
    lp_file_name: ?[*:0]const u16,
    lp_existing_file_name: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateHardLinkTransactedA(
    lp_file_name: ?[*:0]const u8,
    lp_existing_file_name: ?[*:0]const u8,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateHardLinkTransactedW(
    lp_file_name: ?[*:0]const u16,
    lp_existing_file_name: ?[*:0]const u16,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstStreamTransactedW(
    lp_file_name: ?[*:0]const u16,
    info_level: STREAM_INFO_LEVELS,
    lp_find_stream_data: ?*anyopaque,
    dw_flags: u32,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn FindFirstFileNameTransactedW(
    lp_file_name: ?[*:0]const u16,
    dw_flags: u32,
    string_length: ?*u32,
    link_name: [*:0]u16,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetVolumeLabelA(
    lp_root_path_name: ?[*:0]const u8,
    lp_volume_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetVolumeLabelW(
    lp_root_path_name: ?[*:0]const u16,
    lp_volume_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFileBandwidthReservation(
    h_file: ?HANDLE,
    n_period_milliseconds: u32,
    n_bytes_per_period: u32,
    b_discardable: BOOL,
    lp_transfer_size: ?*u32,
    lp_num_outstanding_requests: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileBandwidthReservation(
    h_file: ?HANDLE,
    lp_period_milliseconds: ?*u32,
    lp_bytes_per_period: ?*u32,
    p_discardable: ?*i32,
    lp_transfer_size: ?*u32,
    lp_num_outstanding_requests: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadDirectoryChangesW(
    h_directory: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*anyopaque,
    n_buffer_length: u32,
    b_watch_subtree: BOOL,
    dw_notify_filter: FILE_NOTIFY_CHANGE,
    lp_bytes_returned: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
    lp_completion_routine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "kernel32" fn ReadDirectoryChangesExW(
    h_directory: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lp_buffer: ?*anyopaque,
    n_buffer_length: u32,
    b_watch_subtree: BOOL,
    dw_notify_filter: FILE_NOTIFY_CHANGE,
    lp_bytes_returned: ?*u32,
    lp_overlapped: ?*OVERLAPPED,
    lp_completion_routine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
    read_directory_notify_information_class: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstVolumeA(
    lpsz_volume_name: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextVolumeA(
    h_find_volume: FindVolumeHandle,
    lpsz_volume_name: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstVolumeMountPointA(
    lpsz_root_path_name: ?[*:0]const u8,
    lpsz_volume_mount_point: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindFirstVolumeMountPointW(
    lpsz_root_path_name: ?[*:0]const u16,
    lpsz_volume_mount_point: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextVolumeMountPointA(
    h_find_volume_mount_point: FindVolumeMointPointHandle,
    lpsz_volume_mount_point: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindNextVolumeMountPointW(
    h_find_volume_mount_point: FindVolumeMointPointHandle,
    lpsz_volume_mount_point: [*:0]u16,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindVolumeMountPointClose(
    h_find_volume_mount_point: FindVolumeMointPointHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetVolumeMountPointA(
    lpsz_volume_mount_point: ?[*:0]const u8,
    lpsz_volume_name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetVolumeMountPointW(
    lpsz_volume_mount_point: ?[*:0]const u16,
    lpsz_volume_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeleteVolumeMountPointA(
    lpsz_volume_mount_point: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumeNameForVolumeMountPointA(
    lpsz_volume_mount_point: ?[*:0]const u8,
    lpsz_volume_name: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumePathNameA(
    lpsz_file_name: ?[*:0]const u8,
    lpsz_volume_path_name: [*:0]u8,
    cch_buffer_length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetVolumePathNamesForVolumeNameA(
    lpsz_volume_name: ?[*:0]const u8,
    lpsz_volume_path_names: ?[*]u8,
    cch_buffer_length: u32,
    lpcch_return_length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFileInformationByHandleEx(
    h_file: ?HANDLE,
    file_information_class: FILE_INFO_BY_HANDLE_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lp_file_information: ?*anyopaque,
    dw_buffer_size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn OpenFileById(
    h_volume_hint: ?HANDLE,
    lp_file_id: ?*FILE_ID_DESCRIPTOR,
    dw_desired_access: FILE_ACCESS_FLAGS,
    dw_share_mode: FILE_SHARE_MODE,
    lp_security_attributes: ?*SECURITY_ATTRIBUTES,
    dw_flags_and_attributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateSymbolicLinkA(
    lp_symlink_file_name: ?[*:0]const u8,
    lp_target_file_name: ?[*:0]const u8,
    dw_flags: SYMBOLIC_LINK_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateSymbolicLinkW(
    lp_symlink_file_name: ?[*:0]const u16,
    lp_target_file_name: ?[*:0]const u16,
    dw_flags: SYMBOLIC_LINK_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateSymbolicLinkTransactedA(
    lp_symlink_file_name: ?[*:0]const u8,
    lp_target_file_name: ?[*:0]const u8,
    dw_flags: SYMBOLIC_LINK_FLAGS,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CreateSymbolicLinkTransactedW(
    lp_symlink_file_name: ?[*:0]const u16,
    lp_target_file_name: ?[*:0]const u16,
    dw_flags: SYMBOLIC_LINK_FLAGS,
    h_transaction: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "ntdll" fn NtCreateFile(
    file_handle: ?*?HANDLE,
    desired_access: u32,
    object_attributes: ?*OBJECT_ATTRIBUTES,
    io_status_block: ?*IO_STATUS_BLOCK,
    allocation_size: ?*LARGE_INTEGER,
    file_attributes: u32,
    share_access: FILE_SHARE_MODE,
    create_disposition: NT_CREATE_FILE_DISPOSITION,
    create_options: u32,
    ea_buffer: ?*anyopaque,
    ea_length: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (93)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WIN32_FIND_DATA = thismodule.WIN32_FIND_DATAA;
        pub const NTMS_DRIVEINFORMATION = thismodule.NTMS_DRIVEINFORMATIONA;
        pub const NTMS_CHANGERINFORMATION = thismodule.NTMS_CHANGERINFORMATIONA;
        pub const NTMS_PMIDINFORMATION = thismodule.NTMS_PMIDINFORMATIONA;
        pub const NTMS_PARTITIONINFORMATION = thismodule.NTMS_PARTITIONINFORMATIONA;
        pub const NTMS_DRIVETYPEINFORMATION = thismodule.NTMS_DRIVETYPEINFORMATIONA;
        pub const NTMS_CHANGERTYPEINFORMATION = thismodule.NTMS_CHANGERTYPEINFORMATIONA;
        pub const NTMS_LIBREQUESTINFORMATION = thismodule.NTMS_LIBREQUESTINFORMATIONA;
        pub const NTMS_OPREQUESTINFORMATION = thismodule.NTMS_OPREQUESTINFORMATIONA;
        pub const NTMS_OBJECTINFORMATION = thismodule.NTMS_OBJECTINFORMATIONA;
        pub const NTMS_I1_LIBREQUESTINFORMATION = thismodule.NTMS_I1_LIBREQUESTINFORMATIONA;
        pub const NTMS_I1_PMIDINFORMATION = thismodule.NTMS_I1_PMIDINFORMATIONA;
        pub const NTMS_I1_PARTITIONINFORMATION = thismodule.NTMS_I1_PARTITIONINFORMATIONA;
        pub const NTMS_I1_OPREQUESTINFORMATION = thismodule.NTMS_I1_OPREQUESTINFORMATIONA;
        pub const NTMS_I1_OBJECTINFORMATION = thismodule.NTMS_I1_OBJECTINFORMATIONA;
        pub const SearchPath = thismodule.SearchPathA;
        pub const CreateDirectory = thismodule.CreateDirectoryA;
        pub const CreateFile = thismodule.CreateFileA;
        pub const DefineDosDevice = thismodule.DefineDosDeviceA;
        pub const DeleteFile = thismodule.DeleteFileA;
        pub const DeleteVolumeMountPoint = thismodule.DeleteVolumeMountPointA;
        pub const FindFirstChangeNotification = thismodule.FindFirstChangeNotificationA;
        pub const FindFirstFile = thismodule.FindFirstFileA;
        pub const FindFirstFileEx = thismodule.FindFirstFileExA;
        pub const FindFirstVolume = thismodule.FindFirstVolumeA;
        pub const FindNextFile = thismodule.FindNextFileA;
        pub const FindNextVolume = thismodule.FindNextVolumeA;
        pub const GetDiskFreeSpace = thismodule.GetDiskFreeSpaceA;
        pub const GetDiskFreeSpaceEx = thismodule.GetDiskFreeSpaceExA;
        pub const GetDiskSpaceInformation = thismodule.GetDiskSpaceInformationA;
        pub const GetDriveType = thismodule.GetDriveTypeA;
        pub const GetFileAttributes = thismodule.GetFileAttributesA;
        pub const GetFileAttributesEx = thismodule.GetFileAttributesExA;
        pub const GetFinalPathNameByHandle = thismodule.GetFinalPathNameByHandleA;
        pub const GetFullPathName = thismodule.GetFullPathNameA;
        pub const GetLogicalDriveStrings = thismodule.GetLogicalDriveStringsA;
        pub const GetLongPathName = thismodule.GetLongPathNameA;
        pub const GetShortPathName = thismodule.GetShortPathNameA;
        pub const GetTempFileName = thismodule.GetTempFileNameA;
        pub const GetVolumeInformation = thismodule.GetVolumeInformationA;
        pub const GetVolumePathName = thismodule.GetVolumePathNameA;
        pub const QueryDosDevice = thismodule.QueryDosDeviceA;
        pub const RemoveDirectory = thismodule.RemoveDirectoryA;
        pub const SetFileAttributes = thismodule.SetFileAttributesA;
        pub const GetTempPath = thismodule.GetTempPathA;
        pub const GetVolumeNameForVolumeMountPoint = thismodule.GetVolumeNameForVolumeMountPointA;
        pub const GetVolumePathNamesForVolumeName = thismodule.GetVolumePathNamesForVolumeNameA;
        pub const GetCompressedFileSize = thismodule.GetCompressedFileSizeA;
        pub const GetTempPath2 = thismodule.GetTempPath2A;
        pub const VerFindFile = thismodule.VerFindFileA;
        pub const VerInstallFile = thismodule.VerInstallFileA;
        pub const GetFileVersionInfoSize = thismodule.GetFileVersionInfoSizeA;
        pub const GetFileVersionInfo = thismodule.GetFileVersionInfoA;
        pub const GetFileVersionInfoSizeEx = thismodule.GetFileVersionInfoSizeExA;
        pub const GetFileVersionInfoEx = thismodule.GetFileVersionInfoExA;
        pub const VerLanguageName = thismodule.VerLanguageNameA;
        pub const VerQueryValue = thismodule.VerQueryValueA;
        pub const GetExpandedName = thismodule.GetExpandedNameA;
        pub const LZOpenFile = thismodule.LZOpenFileA;
        pub const GetBinaryType = thismodule.GetBinaryTypeA;
        pub const GetLongPathNameTransacted = thismodule.GetLongPathNameTransactedA;
        pub const SetFileShortName = thismodule.SetFileShortNameA;
        pub const EncryptFile = thismodule.EncryptFileA;
        pub const DecryptFile = thismodule.DecryptFileA;
        pub const FileEncryptionStatus = thismodule.FileEncryptionStatusA;
        pub const OpenEncryptedFileRaw = thismodule.OpenEncryptedFileRawA;
        pub const CreateDirectoryEx = thismodule.CreateDirectoryExA;
        pub const CreateDirectoryTransacted = thismodule.CreateDirectoryTransactedA;
        pub const RemoveDirectoryTransacted = thismodule.RemoveDirectoryTransactedA;
        pub const GetFullPathNameTransacted = thismodule.GetFullPathNameTransactedA;
        pub const CreateFileTransacted = thismodule.CreateFileTransactedA;
        pub const SetFileAttributesTransacted = thismodule.SetFileAttributesTransactedA;
        pub const GetFileAttributesTransacted = thismodule.GetFileAttributesTransactedA;
        pub const GetCompressedFileSizeTransacted = thismodule.GetCompressedFileSizeTransactedA;
        pub const DeleteFileTransacted = thismodule.DeleteFileTransactedA;
        pub const CheckNameLegalDOS8Dot3 = thismodule.CheckNameLegalDOS8Dot3A;
        pub const FindFirstFileTransacted = thismodule.FindFirstFileTransactedA;
        pub const CopyFile = thismodule.CopyFileA;
        pub const CopyFileEx = thismodule.CopyFileExA;
        pub const CopyFileTransacted = thismodule.CopyFileTransactedA;
        pub const MoveFile = thismodule.MoveFileA;
        pub const MoveFileEx = thismodule.MoveFileExA;
        pub const MoveFileWithProgress = thismodule.MoveFileWithProgressA;
        pub const MoveFileTransacted = thismodule.MoveFileTransactedA;
        pub const ReplaceFile = thismodule.ReplaceFileA;
        pub const CreateHardLink = thismodule.CreateHardLinkA;
        pub const CreateHardLinkTransacted = thismodule.CreateHardLinkTransactedA;
        pub const SetVolumeLabel = thismodule.SetVolumeLabelA;
        pub const FindFirstVolumeMountPoint = thismodule.FindFirstVolumeMountPointA;
        pub const FindNextVolumeMountPoint = thismodule.FindNextVolumeMountPointA;
        pub const SetVolumeMountPoint = thismodule.SetVolumeMountPointA;
        pub const CreateSymbolicLink = thismodule.CreateSymbolicLinkA;
        pub const CreateSymbolicLinkTransacted = thismodule.CreateSymbolicLinkTransactedA;
    },
    .wide => struct {
        pub const WIN32_FIND_DATA = thismodule.WIN32_FIND_DATAW;
        pub const NTMS_DRIVEINFORMATION = thismodule.NTMS_DRIVEINFORMATIONW;
        pub const NTMS_CHANGERINFORMATION = thismodule.NTMS_CHANGERINFORMATIONW;
        pub const NTMS_PMIDINFORMATION = thismodule.NTMS_PMIDINFORMATIONW;
        pub const NTMS_PARTITIONINFORMATION = thismodule.NTMS_PARTITIONINFORMATIONW;
        pub const NTMS_DRIVETYPEINFORMATION = thismodule.NTMS_DRIVETYPEINFORMATIONW;
        pub const NTMS_CHANGERTYPEINFORMATION = thismodule.NTMS_CHANGERTYPEINFORMATIONW;
        pub const NTMS_LIBREQUESTINFORMATION = thismodule.NTMS_LIBREQUESTINFORMATIONW;
        pub const NTMS_OPREQUESTINFORMATION = thismodule.NTMS_OPREQUESTINFORMATIONW;
        pub const NTMS_OBJECTINFORMATION = thismodule.NTMS_OBJECTINFORMATIONW;
        pub const NTMS_I1_LIBREQUESTINFORMATION = thismodule.NTMS_I1_LIBREQUESTINFORMATIONW;
        pub const NTMS_I1_PMIDINFORMATION = thismodule.NTMS_I1_PMIDINFORMATIONW;
        pub const NTMS_I1_PARTITIONINFORMATION = thismodule.NTMS_I1_PARTITIONINFORMATIONW;
        pub const NTMS_I1_OPREQUESTINFORMATION = thismodule.NTMS_I1_OPREQUESTINFORMATIONW;
        pub const NTMS_I1_OBJECTINFORMATION = thismodule.NTMS_I1_OBJECTINFORMATIONW;
        pub const SearchPath = thismodule.SearchPathW;
        pub const CreateDirectory = thismodule.CreateDirectoryW;
        pub const CreateFile = thismodule.CreateFileW;
        pub const DefineDosDevice = thismodule.DefineDosDeviceW;
        pub const DeleteFile = thismodule.DeleteFileW;
        pub const DeleteVolumeMountPoint = thismodule.DeleteVolumeMountPointW;
        pub const FindFirstChangeNotification = thismodule.FindFirstChangeNotificationW;
        pub const FindFirstFile = thismodule.FindFirstFileW;
        pub const FindFirstFileEx = thismodule.FindFirstFileExW;
        pub const FindFirstVolume = thismodule.FindFirstVolumeW;
        pub const FindNextFile = thismodule.FindNextFileW;
        pub const FindNextVolume = thismodule.FindNextVolumeW;
        pub const GetDiskFreeSpace = thismodule.GetDiskFreeSpaceW;
        pub const GetDiskFreeSpaceEx = thismodule.GetDiskFreeSpaceExW;
        pub const GetDiskSpaceInformation = thismodule.GetDiskSpaceInformationW;
        pub const GetDriveType = thismodule.GetDriveTypeW;
        pub const GetFileAttributes = thismodule.GetFileAttributesW;
        pub const GetFileAttributesEx = thismodule.GetFileAttributesExW;
        pub const GetFinalPathNameByHandle = thismodule.GetFinalPathNameByHandleW;
        pub const GetFullPathName = thismodule.GetFullPathNameW;
        pub const GetLogicalDriveStrings = thismodule.GetLogicalDriveStringsW;
        pub const GetLongPathName = thismodule.GetLongPathNameW;
        pub const GetShortPathName = thismodule.GetShortPathNameW;
        pub const GetTempFileName = thismodule.GetTempFileNameW;
        pub const GetVolumeInformation = thismodule.GetVolumeInformationW;
        pub const GetVolumePathName = thismodule.GetVolumePathNameW;
        pub const QueryDosDevice = thismodule.QueryDosDeviceW;
        pub const RemoveDirectory = thismodule.RemoveDirectoryW;
        pub const SetFileAttributes = thismodule.SetFileAttributesW;
        pub const GetTempPath = thismodule.GetTempPathW;
        pub const GetVolumeNameForVolumeMountPoint = thismodule.GetVolumeNameForVolumeMountPointW;
        pub const GetVolumePathNamesForVolumeName = thismodule.GetVolumePathNamesForVolumeNameW;
        pub const GetCompressedFileSize = thismodule.GetCompressedFileSizeW;
        pub const GetTempPath2 = thismodule.GetTempPath2W;
        pub const VerFindFile = thismodule.VerFindFileW;
        pub const VerInstallFile = thismodule.VerInstallFileW;
        pub const GetFileVersionInfoSize = thismodule.GetFileVersionInfoSizeW;
        pub const GetFileVersionInfo = thismodule.GetFileVersionInfoW;
        pub const GetFileVersionInfoSizeEx = thismodule.GetFileVersionInfoSizeExW;
        pub const GetFileVersionInfoEx = thismodule.GetFileVersionInfoExW;
        pub const VerLanguageName = thismodule.VerLanguageNameW;
        pub const VerQueryValue = thismodule.VerQueryValueW;
        pub const GetExpandedName = thismodule.GetExpandedNameW;
        pub const LZOpenFile = thismodule.LZOpenFileW;
        pub const GetBinaryType = thismodule.GetBinaryTypeW;
        pub const GetLongPathNameTransacted = thismodule.GetLongPathNameTransactedW;
        pub const SetFileShortName = thismodule.SetFileShortNameW;
        pub const EncryptFile = thismodule.EncryptFileW;
        pub const DecryptFile = thismodule.DecryptFileW;
        pub const FileEncryptionStatus = thismodule.FileEncryptionStatusW;
        pub const OpenEncryptedFileRaw = thismodule.OpenEncryptedFileRawW;
        pub const CreateDirectoryEx = thismodule.CreateDirectoryExW;
        pub const CreateDirectoryTransacted = thismodule.CreateDirectoryTransactedW;
        pub const RemoveDirectoryTransacted = thismodule.RemoveDirectoryTransactedW;
        pub const GetFullPathNameTransacted = thismodule.GetFullPathNameTransactedW;
        pub const CreateFileTransacted = thismodule.CreateFileTransactedW;
        pub const SetFileAttributesTransacted = thismodule.SetFileAttributesTransactedW;
        pub const GetFileAttributesTransacted = thismodule.GetFileAttributesTransactedW;
        pub const GetCompressedFileSizeTransacted = thismodule.GetCompressedFileSizeTransactedW;
        pub const DeleteFileTransacted = thismodule.DeleteFileTransactedW;
        pub const CheckNameLegalDOS8Dot3 = thismodule.CheckNameLegalDOS8Dot3W;
        pub const FindFirstFileTransacted = thismodule.FindFirstFileTransactedW;
        pub const CopyFile = thismodule.CopyFileW;
        pub const CopyFileEx = thismodule.CopyFileExW;
        pub const CopyFileTransacted = thismodule.CopyFileTransactedW;
        pub const MoveFile = thismodule.MoveFileW;
        pub const MoveFileEx = thismodule.MoveFileExW;
        pub const MoveFileWithProgress = thismodule.MoveFileWithProgressW;
        pub const MoveFileTransacted = thismodule.MoveFileTransactedW;
        pub const ReplaceFile = thismodule.ReplaceFileW;
        pub const CreateHardLink = thismodule.CreateHardLinkW;
        pub const CreateHardLinkTransacted = thismodule.CreateHardLinkTransactedW;
        pub const SetVolumeLabel = thismodule.SetVolumeLabelW;
        pub const FindFirstVolumeMountPoint = thismodule.FindFirstVolumeMountPointW;
        pub const FindNextVolumeMountPoint = thismodule.FindNextVolumeMountPointW;
        pub const SetVolumeMountPoint = thismodule.SetVolumeMountPointW;
        pub const CreateSymbolicLink = thismodule.CreateSymbolicLinkW;
        pub const CreateSymbolicLinkTransacted = thismodule.CreateSymbolicLinkTransactedW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WIN32_FIND_DATA = *opaque {};
        pub const NTMS_DRIVEINFORMATION = *opaque {};
        pub const NTMS_CHANGERINFORMATION = *opaque {};
        pub const NTMS_PMIDINFORMATION = *opaque {};
        pub const NTMS_PARTITIONINFORMATION = *opaque {};
        pub const NTMS_DRIVETYPEINFORMATION = *opaque {};
        pub const NTMS_CHANGERTYPEINFORMATION = *opaque {};
        pub const NTMS_LIBREQUESTINFORMATION = *opaque {};
        pub const NTMS_OPREQUESTINFORMATION = *opaque {};
        pub const NTMS_OBJECTINFORMATION = *opaque {};
        pub const NTMS_I1_LIBREQUESTINFORMATION = *opaque {};
        pub const NTMS_I1_PMIDINFORMATION = *opaque {};
        pub const NTMS_I1_PARTITIONINFORMATION = *opaque {};
        pub const NTMS_I1_OPREQUESTINFORMATION = *opaque {};
        pub const NTMS_I1_OBJECTINFORMATION = *opaque {};
        pub const SearchPath = *opaque {};
        pub const CreateDirectory = *opaque {};
        pub const CreateFile = *opaque {};
        pub const DefineDosDevice = *opaque {};
        pub const DeleteFile = *opaque {};
        pub const DeleteVolumeMountPoint = *opaque {};
        pub const FindFirstChangeNotification = *opaque {};
        pub const FindFirstFile = *opaque {};
        pub const FindFirstFileEx = *opaque {};
        pub const FindFirstVolume = *opaque {};
        pub const FindNextFile = *opaque {};
        pub const FindNextVolume = *opaque {};
        pub const GetDiskFreeSpace = *opaque {};
        pub const GetDiskFreeSpaceEx = *opaque {};
        pub const GetDiskSpaceInformation = *opaque {};
        pub const GetDriveType = *opaque {};
        pub const GetFileAttributes = *opaque {};
        pub const GetFileAttributesEx = *opaque {};
        pub const GetFinalPathNameByHandle = *opaque {};
        pub const GetFullPathName = *opaque {};
        pub const GetLogicalDriveStrings = *opaque {};
        pub const GetLongPathName = *opaque {};
        pub const GetShortPathName = *opaque {};
        pub const GetTempFileName = *opaque {};
        pub const GetVolumeInformation = *opaque {};
        pub const GetVolumePathName = *opaque {};
        pub const QueryDosDevice = *opaque {};
        pub const RemoveDirectory = *opaque {};
        pub const SetFileAttributes = *opaque {};
        pub const GetTempPath = *opaque {};
        pub const GetVolumeNameForVolumeMountPoint = *opaque {};
        pub const GetVolumePathNamesForVolumeName = *opaque {};
        pub const GetCompressedFileSize = *opaque {};
        pub const GetTempPath2 = *opaque {};
        pub const VerFindFile = *opaque {};
        pub const VerInstallFile = *opaque {};
        pub const GetFileVersionInfoSize = *opaque {};
        pub const GetFileVersionInfo = *opaque {};
        pub const GetFileVersionInfoSizeEx = *opaque {};
        pub const GetFileVersionInfoEx = *opaque {};
        pub const VerLanguageName = *opaque {};
        pub const VerQueryValue = *opaque {};
        pub const GetExpandedName = *opaque {};
        pub const LZOpenFile = *opaque {};
        pub const GetBinaryType = *opaque {};
        pub const GetLongPathNameTransacted = *opaque {};
        pub const SetFileShortName = *opaque {};
        pub const EncryptFile = *opaque {};
        pub const DecryptFile = *opaque {};
        pub const FileEncryptionStatus = *opaque {};
        pub const OpenEncryptedFileRaw = *opaque {};
        pub const CreateDirectoryEx = *opaque {};
        pub const CreateDirectoryTransacted = *opaque {};
        pub const RemoveDirectoryTransacted = *opaque {};
        pub const GetFullPathNameTransacted = *opaque {};
        pub const CreateFileTransacted = *opaque {};
        pub const SetFileAttributesTransacted = *opaque {};
        pub const GetFileAttributesTransacted = *opaque {};
        pub const GetCompressedFileSizeTransacted = *opaque {};
        pub const DeleteFileTransacted = *opaque {};
        pub const CheckNameLegalDOS8Dot3 = *opaque {};
        pub const FindFirstFileTransacted = *opaque {};
        pub const CopyFile = *opaque {};
        pub const CopyFileEx = *opaque {};
        pub const CopyFileTransacted = *opaque {};
        pub const MoveFile = *opaque {};
        pub const MoveFileEx = *opaque {};
        pub const MoveFileWithProgress = *opaque {};
        pub const MoveFileTransacted = *opaque {};
        pub const ReplaceFile = *opaque {};
        pub const CreateHardLink = *opaque {};
        pub const CreateHardLinkTransacted = *opaque {};
        pub const SetVolumeLabel = *opaque {};
        pub const FindFirstVolumeMountPoint = *opaque {};
        pub const FindNextVolumeMountPoint = *opaque {};
        pub const SetVolumeMountPoint = *opaque {};
        pub const CreateSymbolicLink = *opaque {};
        pub const CreateSymbolicLinkTransacted = *opaque {};
    } else struct {
        pub const WIN32_FIND_DATA = @compileError("'WIN32_FIND_DATA' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVEINFORMATION = @compileError("'NTMS_DRIVEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERINFORMATION = @compileError("'NTMS_CHANGERINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PMIDINFORMATION = @compileError("'NTMS_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PARTITIONINFORMATION = @compileError("'NTMS_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVETYPEINFORMATION = @compileError("'NTMS_DRIVETYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERTYPEINFORMATION = @compileError("'NTMS_CHANGERTYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_LIBREQUESTINFORMATION = @compileError("'NTMS_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OPREQUESTINFORMATION = @compileError("'NTMS_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OBJECTINFORMATION = @compileError("'NTMS_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_LIBREQUESTINFORMATION = @compileError("'NTMS_I1_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PMIDINFORMATION = @compileError("'NTMS_I1_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PARTITIONINFORMATION = @compileError("'NTMS_I1_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OPREQUESTINFORMATION = @compileError("'NTMS_I1_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OBJECTINFORMATION = @compileError("'NTMS_I1_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const SearchPath = @compileError("'SearchPath' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectory = @compileError("'CreateDirectory' requires that UNICODE be set to true or false in the root module");
        pub const CreateFile = @compileError("'CreateFile' requires that UNICODE be set to true or false in the root module");
        pub const DefineDosDevice = @compileError("'DefineDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFile = @compileError("'DeleteFile' requires that UNICODE be set to true or false in the root module");
        pub const DeleteVolumeMountPoint = @compileError("'DeleteVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstChangeNotification = @compileError("'FindFirstChangeNotification' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFile = @compileError("'FindFirstFile' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileEx = @compileError("'FindFirstFileEx' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolume = @compileError("'FindFirstVolume' requires that UNICODE be set to true or false in the root module");
        pub const FindNextFile = @compileError("'FindNextFile' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolume = @compileError("'FindNextVolume' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpace = @compileError("'GetDiskFreeSpace' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpaceEx = @compileError("'GetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskSpaceInformation = @compileError("'GetDiskSpaceInformation' requires that UNICODE be set to true or false in the root module");
        pub const GetDriveType = @compileError("'GetDriveType' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributes = @compileError("'GetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesEx = @compileError("'GetFileAttributesEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFinalPathNameByHandle = @compileError("'GetFinalPathNameByHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathName = @compileError("'GetFullPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetLogicalDriveStrings = @compileError("'GetLogicalDriveStrings' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathName = @compileError("'GetLongPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetShortPathName = @compileError("'GetShortPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetTempFileName = @compileError("'GetTempFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeInformation = @compileError("'GetVolumeInformation' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathName = @compileError("'GetVolumePathName' requires that UNICODE be set to true or false in the root module");
        pub const QueryDosDevice = @compileError("'QueryDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectory = @compileError("'RemoveDirectory' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributes = @compileError("'SetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetTempPath = @compileError("'GetTempPath' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeNameForVolumeMountPoint = @compileError("'GetVolumeNameForVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathNamesForVolumeName = @compileError("'GetVolumePathNamesForVolumeName' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSize = @compileError("'GetCompressedFileSize' requires that UNICODE be set to true or false in the root module");
        pub const GetTempPath2 = @compileError("'GetTempPath2' requires that UNICODE be set to true or false in the root module");
        pub const VerFindFile = @compileError("'VerFindFile' requires that UNICODE be set to true or false in the root module");
        pub const VerInstallFile = @compileError("'VerInstallFile' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoSize = @compileError("'GetFileVersionInfoSize' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfo = @compileError("'GetFileVersionInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoSizeEx = @compileError("'GetFileVersionInfoSizeEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoEx = @compileError("'GetFileVersionInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const VerLanguageName = @compileError("'VerLanguageName' requires that UNICODE be set to true or false in the root module");
        pub const VerQueryValue = @compileError("'VerQueryValue' requires that UNICODE be set to true or false in the root module");
        pub const GetExpandedName = @compileError("'GetExpandedName' requires that UNICODE be set to true or false in the root module");
        pub const LZOpenFile = @compileError("'LZOpenFile' requires that UNICODE be set to true or false in the root module");
        pub const GetBinaryType = @compileError("'GetBinaryType' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathNameTransacted = @compileError("'GetLongPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileShortName = @compileError("'SetFileShortName' requires that UNICODE be set to true or false in the root module");
        pub const EncryptFile = @compileError("'EncryptFile' requires that UNICODE be set to true or false in the root module");
        pub const DecryptFile = @compileError("'DecryptFile' requires that UNICODE be set to true or false in the root module");
        pub const FileEncryptionStatus = @compileError("'FileEncryptionStatus' requires that UNICODE be set to true or false in the root module");
        pub const OpenEncryptedFileRaw = @compileError("'OpenEncryptedFileRaw' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryEx = @compileError("'CreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryTransacted = @compileError("'CreateDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectoryTransacted = @compileError("'RemoveDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathNameTransacted = @compileError("'GetFullPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileTransacted = @compileError("'CreateFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributesTransacted = @compileError("'SetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesTransacted = @compileError("'GetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSizeTransacted = @compileError("'GetCompressedFileSizeTransacted' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFileTransacted = @compileError("'DeleteFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CheckNameLegalDOS8Dot3 = @compileError("'CheckNameLegalDOS8Dot3' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileTransacted = @compileError("'FindFirstFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CopyFile = @compileError("'CopyFile' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileEx = @compileError("'CopyFileEx' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileTransacted = @compileError("'CopyFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const MoveFile = @compileError("'MoveFile' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileEx = @compileError("'MoveFileEx' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileWithProgress = @compileError("'MoveFileWithProgress' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileTransacted = @compileError("'MoveFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const ReplaceFile = @compileError("'ReplaceFile' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLink = @compileError("'CreateHardLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLinkTransacted = @compileError("'CreateHardLinkTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeLabel = @compileError("'SetVolumeLabel' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolumeMountPoint = @compileError("'FindFirstVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolumeMountPoint = @compileError("'FindNextVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeMountPoint = @compileError("'SetVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLink = @compileError("'CreateSymbolicLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLinkTransacted = @compileError("'CreateSymbolicLinkTransacted' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (25)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const GENERIC_MAPPING = @import("../security.zig").GENERIC_MAPPING;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const IConnectionPointContainer = @import("../system/com.zig").IConnectionPointContainer;
const IO_STATUS_BLOCK = @import("../system/windows_programming.zig").IO_STATUS_BLOCK;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LPOVERLAPPED_COMPLETION_ROUTINE = @import("../system/io.zig").LPOVERLAPPED_COMPLETION_ROUTINE;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OBJECT_ATTRIBUTES = @import("../system/windows_programming.zig").OBJECT_ATTRIBUTES;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const PRIVILEGE_SET = @import("../security.zig").PRIVILEGE_SET;
const PSECURITY_DESCRIPTOR = @import("../security.zig").PSECURITY_DESCRIPTOR;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SID = @import("../security.zig").SID;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "MAXMEDIALABEL")) {
        _ = MAXMEDIALABEL;
    }
    if (@hasDecl(@This(), "CLAIMMEDIALABEL")) {
        _ = CLAIMMEDIALABEL;
    }
    if (@hasDecl(@This(), "CLAIMMEDIALABELEX")) {
        _ = CLAIMMEDIALABELEX;
    }
    if (@hasDecl(@This(), "CLFS_BLOCK_ALLOCATION")) {
        _ = CLFS_BLOCK_ALLOCATION;
    }
    if (@hasDecl(@This(), "CLFS_BLOCK_DEALLOCATION")) {
        _ = CLFS_BLOCK_DEALLOCATION;
    }
    if (@hasDecl(@This(), "PCLFS_COMPLETION_ROUTINE")) {
        _ = PCLFS_COMPLETION_ROUTINE;
    }
    if (@hasDecl(@This(), "PLOG_TAIL_ADVANCE_CALLBACK")) {
        _ = PLOG_TAIL_ADVANCE_CALLBACK;
    }
    if (@hasDecl(@This(), "PLOG_FULL_HANDLER_CALLBACK")) {
        _ = PLOG_FULL_HANDLER_CALLBACK;
    }
    if (@hasDecl(@This(), "PLOG_UNPINNED_CALLBACK")) {
        _ = PLOG_UNPINNED_CALLBACK;
    }
    if (@hasDecl(@This(), "WofEnumEntryProc")) {
        _ = WofEnumEntryProc;
    }
    if (@hasDecl(@This(), "WofEnumFilesProc")) {
        _ = WofEnumFilesProc;
    }
    if (@hasDecl(@This(), "FCACHE_CREATE_CALLBACK")) {
        _ = FCACHE_CREATE_CALLBACK;
    }
    if (@hasDecl(@This(), "FCACHE_RICHCREATE_CALLBACK")) {
        _ = FCACHE_RICHCREATE_CALLBACK;
    }
    if (@hasDecl(@This(), "CACHE_KEY_COMPARE")) {
        _ = CACHE_KEY_COMPARE;
    }
    if (@hasDecl(@This(), "CACHE_KEY_HASH")) {
        _ = CACHE_KEY_HASH;
    }
    if (@hasDecl(@This(), "CACHE_READ_CALLBACK")) {
        _ = CACHE_READ_CALLBACK;
    }
    if (@hasDecl(@This(), "CACHE_DESTROY_CALLBACK")) {
        _ = CACHE_DESTROY_CALLBACK;
    }
    if (@hasDecl(@This(), "CACHE_ACCESS_CHECK")) {
        _ = CACHE_ACCESS_CHECK;
    }
    if (@hasDecl(@This(), "PFE_EXPORT_FUNC")) {
        _ = PFE_EXPORT_FUNC;
    }
    if (@hasDecl(@This(), "PFE_IMPORT_FUNC")) {
        _ = PFE_IMPORT_FUNC;
    }
    if (@hasDecl(@This(), "LPPROGRESS_ROUTINE")) {
        _ = LPPROGRESS_ROUTINE;
    }
    if (@hasDecl(@This(), "PCOPYFILE2_PROGRESS_ROUTINE")) {
        _ = PCOPYFILE2_PROGRESS_ROUTINE;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
