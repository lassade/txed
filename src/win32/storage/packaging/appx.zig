//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (22)
//--------------------------------------------------------------------------------
pub const PACKAGE_PROPERTY_FRAMEWORK = @as(u32, 1);
pub const PACKAGE_PROPERTY_RESOURCE = @as(u32, 2);
pub const PACKAGE_PROPERTY_BUNDLE = @as(u32, 4);
pub const PACKAGE_PROPERTY_OPTIONAL = @as(u32, 8);
pub const PACKAGE_FILTER_HEAD = @as(u32, 16);
pub const PACKAGE_FILTER_DIRECT = @as(u32, 32);
pub const PACKAGE_FILTER_RESOURCE = @as(u32, 64);
pub const PACKAGE_FILTER_BUNDLE = @as(u32, 128);
pub const PACKAGE_INFORMATION_BASIC = @as(u32, 0);
pub const PACKAGE_INFORMATION_FULL = @as(u32, 256);
pub const PACKAGE_PROPERTY_DEVELOPMENT_MODE = @as(u32, 65536);
pub const PACKAGE_FILTER_OPTIONAL = @as(u32, 131072);
pub const PACKAGE_PROPERTY_IS_IN_RELATED_SET = @as(u32, 262144);
pub const PACKAGE_FILTER_IS_IN_RELATED_SET = @as(u32, 262144);
pub const PACKAGE_PROPERTY_STATIC = @as(u32, 524288);
pub const PACKAGE_FILTER_STATIC = @as(u32, 524288);
pub const PACKAGE_PROPERTY_DYNAMIC = @as(u32, 1048576);
pub const PACKAGE_FILTER_DYNAMIC = @as(u32, 1048576);
pub const PACKAGE_PROPERTY_HOSTRUNTIME = @as(u32, 2097152);
pub const PACKAGE_FILTER_HOSTRUNTIME = @as(u32, 2097152);
pub const PACKAGE_FILTER_ALL_LOADED = @as(u32, 0);
pub const PACKAGE_DEPENDENCY_RANK_DEFAULT = @as(u32, 0);

//--------------------------------------------------------------------------------
// Section: Types (125)
//--------------------------------------------------------------------------------
const CLSID_AppxFactory_Value = Guid.initString("5842a140-ff9f-4166-8f5c-62f5b7b0c781");
pub const CLSID_AppxFactory = &CLSID_AppxFactory_Value;

const CLSID_AppxBundleFactory_Value = Guid.initString("378e0446-5384-43b7-8877-e7dbdd883446");
pub const CLSID_AppxBundleFactory = &CLSID_AppxBundleFactory_Value;

const CLSID_AppxPackagingDiagnosticEventSinkManager_Value = Guid.initString("50ca0a46-1588-4161-8ed2-ef9e469ced5d");
pub const CLSID_AppxPackagingDiagnosticEventSinkManager = &CLSID_AppxPackagingDiagnosticEventSinkManager_Value;

const CLSID_AppxEncryptionFactory_Value = Guid.initString("dc664fdd-d868-46ee-8780-8d196cb739f7");
pub const CLSID_AppxEncryptionFactory = &CLSID_AppxEncryptionFactory_Value;

const CLSID_AppxPackageEditor_Value = Guid.initString("f004f2ca-aebc-4b0d-bf58-e516d5bcc0ab");
pub const CLSID_AppxPackageEditor = &CLSID_AppxPackageEditor_Value;

pub const APPX_PACKAGE_SETTINGS = extern struct {
    forceZip32: BOOL,
    hashMethod: ?*IUri,
};

pub const APPX_COMPRESSION_OPTION = enum(i32) {
    NONE = 0,
    NORMAL = 1,
    MAXIMUM = 2,
    FAST = 3,
    SUPERFAST = 4,
};
pub const APPX_COMPRESSION_OPTION_NONE = APPX_COMPRESSION_OPTION.NONE;
pub const APPX_COMPRESSION_OPTION_NORMAL = APPX_COMPRESSION_OPTION.NORMAL;
pub const APPX_COMPRESSION_OPTION_MAXIMUM = APPX_COMPRESSION_OPTION.MAXIMUM;
pub const APPX_COMPRESSION_OPTION_FAST = APPX_COMPRESSION_OPTION.FAST;
pub const APPX_COMPRESSION_OPTION_SUPERFAST = APPX_COMPRESSION_OPTION.SUPERFAST;

pub const APPX_PACKAGE_WRITER_PAYLOAD_STREAM = extern struct {
    inputStream: ?*IStream,
    fileName: ?[*:0]const u16,
    contentType: ?[*:0]const u16,
    compressionOption: APPX_COMPRESSION_OPTION,
};

pub const APPX_FOOTPRINT_FILE_TYPE = enum(i32) {
    MANIFEST = 0,
    BLOCKMAP = 1,
    SIGNATURE = 2,
    CODEINTEGRITY = 3,
    CONTENTGROUPMAP = 4,
};
pub const APPX_FOOTPRINT_FILE_TYPE_MANIFEST = APPX_FOOTPRINT_FILE_TYPE.MANIFEST;
pub const APPX_FOOTPRINT_FILE_TYPE_BLOCKMAP = APPX_FOOTPRINT_FILE_TYPE.BLOCKMAP;
pub const APPX_FOOTPRINT_FILE_TYPE_SIGNATURE = APPX_FOOTPRINT_FILE_TYPE.SIGNATURE;
pub const APPX_FOOTPRINT_FILE_TYPE_CODEINTEGRITY = APPX_FOOTPRINT_FILE_TYPE.CODEINTEGRITY;
pub const APPX_FOOTPRINT_FILE_TYPE_CONTENTGROUPMAP = APPX_FOOTPRINT_FILE_TYPE.CONTENTGROUPMAP;

pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE = enum(i32) {
    FIRST = 0,
    // MANIFEST = 0, this enum value conflicts with FIRST
    BLOCKMAP = 1,
    SIGNATURE = 2,
    // LAST = 2, this enum value conflicts with SIGNATURE
};
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_FIRST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.FIRST;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_MANIFEST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.FIRST;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_BLOCKMAP = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.BLOCKMAP;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_SIGNATURE = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.SIGNATURE;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_LAST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.SIGNATURE;

pub const APPX_CAPABILITIES = enum(u32) {
    INTERNET_CLIENT = 1,
    INTERNET_CLIENT_SERVER = 2,
    PRIVATE_NETWORK_CLIENT_SERVER = 4,
    DOCUMENTS_LIBRARY = 8,
    PICTURES_LIBRARY = 16,
    VIDEOS_LIBRARY = 32,
    MUSIC_LIBRARY = 64,
    ENTERPRISE_AUTHENTICATION = 128,
    SHARED_USER_CERTIFICATES = 256,
    REMOVABLE_STORAGE = 512,
    APPOINTMENTS = 1024,
    CONTACTS = 2048,
    _,
    pub fn initFlags(o: struct {
        INTERNET_CLIENT: u1 = 0,
        INTERNET_CLIENT_SERVER: u1 = 0,
        PRIVATE_NETWORK_CLIENT_SERVER: u1 = 0,
        DOCUMENTS_LIBRARY: u1 = 0,
        PICTURES_LIBRARY: u1 = 0,
        VIDEOS_LIBRARY: u1 = 0,
        MUSIC_LIBRARY: u1 = 0,
        ENTERPRISE_AUTHENTICATION: u1 = 0,
        SHARED_USER_CERTIFICATES: u1 = 0,
        REMOVABLE_STORAGE: u1 = 0,
        APPOINTMENTS: u1 = 0,
        CONTACTS: u1 = 0,
    }) APPX_CAPABILITIES {
        return @as(APPX_CAPABILITIES, @enumFromInt((if (o.INTERNET_CLIENT == 1) @intFromEnum(APPX_CAPABILITIES.INTERNET_CLIENT) else 0) | (if (o.INTERNET_CLIENT_SERVER == 1) @intFromEnum(APPX_CAPABILITIES.INTERNET_CLIENT_SERVER) else 0) | (if (o.PRIVATE_NETWORK_CLIENT_SERVER == 1) @intFromEnum(APPX_CAPABILITIES.PRIVATE_NETWORK_CLIENT_SERVER) else 0) | (if (o.DOCUMENTS_LIBRARY == 1) @intFromEnum(APPX_CAPABILITIES.DOCUMENTS_LIBRARY) else 0) | (if (o.PICTURES_LIBRARY == 1) @intFromEnum(APPX_CAPABILITIES.PICTURES_LIBRARY) else 0) | (if (o.VIDEOS_LIBRARY == 1) @intFromEnum(APPX_CAPABILITIES.VIDEOS_LIBRARY) else 0) | (if (o.MUSIC_LIBRARY == 1) @intFromEnum(APPX_CAPABILITIES.MUSIC_LIBRARY) else 0) | (if (o.ENTERPRISE_AUTHENTICATION == 1) @intFromEnum(APPX_CAPABILITIES.ENTERPRISE_AUTHENTICATION) else 0) | (if (o.SHARED_USER_CERTIFICATES == 1) @intFromEnum(APPX_CAPABILITIES.SHARED_USER_CERTIFICATES) else 0) | (if (o.REMOVABLE_STORAGE == 1) @intFromEnum(APPX_CAPABILITIES.REMOVABLE_STORAGE) else 0) | (if (o.APPOINTMENTS == 1) @intFromEnum(APPX_CAPABILITIES.APPOINTMENTS) else 0) | (if (o.CONTACTS == 1) @intFromEnum(APPX_CAPABILITIES.CONTACTS) else 0)));
    }
};
pub const APPX_CAPABILITY_INTERNET_CLIENT = APPX_CAPABILITIES.INTERNET_CLIENT;
pub const APPX_CAPABILITY_INTERNET_CLIENT_SERVER = APPX_CAPABILITIES.INTERNET_CLIENT_SERVER;
pub const APPX_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER = APPX_CAPABILITIES.PRIVATE_NETWORK_CLIENT_SERVER;
pub const APPX_CAPABILITY_DOCUMENTS_LIBRARY = APPX_CAPABILITIES.DOCUMENTS_LIBRARY;
pub const APPX_CAPABILITY_PICTURES_LIBRARY = APPX_CAPABILITIES.PICTURES_LIBRARY;
pub const APPX_CAPABILITY_VIDEOS_LIBRARY = APPX_CAPABILITIES.VIDEOS_LIBRARY;
pub const APPX_CAPABILITY_MUSIC_LIBRARY = APPX_CAPABILITIES.MUSIC_LIBRARY;
pub const APPX_CAPABILITY_ENTERPRISE_AUTHENTICATION = APPX_CAPABILITIES.ENTERPRISE_AUTHENTICATION;
pub const APPX_CAPABILITY_SHARED_USER_CERTIFICATES = APPX_CAPABILITIES.SHARED_USER_CERTIFICATES;
pub const APPX_CAPABILITY_REMOVABLE_STORAGE = APPX_CAPABILITIES.REMOVABLE_STORAGE;
pub const APPX_CAPABILITY_APPOINTMENTS = APPX_CAPABILITIES.APPOINTMENTS;
pub const APPX_CAPABILITY_CONTACTS = APPX_CAPABILITIES.CONTACTS;

pub const APPX_PACKAGE_ARCHITECTURE = enum(i32) {
    X86 = 0,
    ARM = 5,
    X64 = 9,
    NEUTRAL = 11,
    ARM64 = 12,
};
pub const APPX_PACKAGE_ARCHITECTURE_X86 = APPX_PACKAGE_ARCHITECTURE.X86;
pub const APPX_PACKAGE_ARCHITECTURE_ARM = APPX_PACKAGE_ARCHITECTURE.ARM;
pub const APPX_PACKAGE_ARCHITECTURE_X64 = APPX_PACKAGE_ARCHITECTURE.X64;
pub const APPX_PACKAGE_ARCHITECTURE_NEUTRAL = APPX_PACKAGE_ARCHITECTURE.NEUTRAL;
pub const APPX_PACKAGE_ARCHITECTURE_ARM64 = APPX_PACKAGE_ARCHITECTURE.ARM64;

pub const APPX_PACKAGE_ARCHITECTURE2 = enum(i32) {
    X86 = 0,
    ARM = 5,
    X64 = 9,
    NEUTRAL = 11,
    ARM64 = 12,
    X86_ON_ARM64 = 14,
    UNKNOWN = 65535,
};
pub const APPX_PACKAGE_ARCHITECTURE2_X86 = APPX_PACKAGE_ARCHITECTURE2.X86;
pub const APPX_PACKAGE_ARCHITECTURE2_ARM = APPX_PACKAGE_ARCHITECTURE2.ARM;
pub const APPX_PACKAGE_ARCHITECTURE2_X64 = APPX_PACKAGE_ARCHITECTURE2.X64;
pub const APPX_PACKAGE_ARCHITECTURE2_NEUTRAL = APPX_PACKAGE_ARCHITECTURE2.NEUTRAL;
pub const APPX_PACKAGE_ARCHITECTURE2_ARM64 = APPX_PACKAGE_ARCHITECTURE2.ARM64;
pub const APPX_PACKAGE_ARCHITECTURE2_X86_ON_ARM64 = APPX_PACKAGE_ARCHITECTURE2.X86_ON_ARM64;
pub const APPX_PACKAGE_ARCHITECTURE2_UNKNOWN = APPX_PACKAGE_ARCHITECTURE2.UNKNOWN;

pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE = enum(i32) {
    APPLICATION = 0,
    RESOURCE = 1,
};
pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE_APPLICATION = APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE.APPLICATION;
pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE_RESOURCE = APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE.RESOURCE;

pub const DX_FEATURE_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    @"9" = 1,
    @"10" = 2,
    @"11" = 3,
};
pub const DX_FEATURE_LEVEL_UNSPECIFIED = DX_FEATURE_LEVEL.UNSPECIFIED;
pub const DX_FEATURE_LEVEL_9 = DX_FEATURE_LEVEL.@"9";
pub const DX_FEATURE_LEVEL_10 = DX_FEATURE_LEVEL.@"10";
pub const DX_FEATURE_LEVEL_11 = DX_FEATURE_LEVEL.@"11";

pub const APPX_CAPABILITY_CLASS_TYPE = enum(i32) {
    DEFAULT = 0,
    GENERAL = 1,
    RESTRICTED = 2,
    WINDOWS = 4,
    ALL = 7,
    CUSTOM = 8,
};
pub const APPX_CAPABILITY_CLASS_DEFAULT = APPX_CAPABILITY_CLASS_TYPE.DEFAULT;
pub const APPX_CAPABILITY_CLASS_GENERAL = APPX_CAPABILITY_CLASS_TYPE.GENERAL;
pub const APPX_CAPABILITY_CLASS_RESTRICTED = APPX_CAPABILITY_CLASS_TYPE.RESTRICTED;
pub const APPX_CAPABILITY_CLASS_WINDOWS = APPX_CAPABILITY_CLASS_TYPE.WINDOWS;
pub const APPX_CAPABILITY_CLASS_ALL = APPX_CAPABILITY_CLASS_TYPE.ALL;
pub const APPX_CAPABILITY_CLASS_CUSTOM = APPX_CAPABILITY_CLASS_TYPE.CUSTOM;

pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE = enum(i32) {
    START = 0,
    CHANGE = 1,
    DETAILS = 2,
    END = 3,
};
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_START = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.START;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_CHANGE = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.CHANGE;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_DETAILS = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.DETAILS;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_END = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.END;

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFactory_Value = Guid.initString("beb94909-e451-438b-b5a7-d79e767b75d8");
pub const IID_IAppxFactory = &IID_IAppxFactory_Value;
pub const IAppxFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePackageWriter: *const fn (
            self: *const IAppxFactory,
            output_stream: ?*IStream,
            settings: ?*APPX_PACKAGE_SETTINGS,
            package_writer: ?*?*IAppxPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePackageReader: *const fn (
            self: *const IAppxFactory,
            input_stream: ?*IStream,
            package_reader: ?*?*IAppxPackageReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateManifestReader: *const fn (
            self: *const IAppxFactory,
            input_stream: ?*IStream,
            manifest_reader: ?*?*IAppxManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBlockMapReader: *const fn (
            self: *const IAppxFactory,
            input_stream: ?*IStream,
            block_map_reader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateValidatedBlockMapReader: *const fn (
            self: *const IAppxFactory,
            block_map_stream: ?*IStream,
            signature_file_name: ?[*:0]const u16,
            block_map_reader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createPackageWriter(self: *const T, output_stream_: ?*IStream, settings_: ?*APPX_PACKAGE_SETTINGS, package_writer_: ?*?*IAppxPackageWriter) HRESULT {
                return @as(*const IAppxFactory.VTable, @ptrCast(self.vtable)).CreatePackageWriter(@as(*const IAppxFactory, @ptrCast(self)), output_stream_, settings_, package_writer_);
            }
            pub inline fn createPackageReader(self: *const T, input_stream_: ?*IStream, package_reader_: ?*?*IAppxPackageReader) HRESULT {
                return @as(*const IAppxFactory.VTable, @ptrCast(self.vtable)).CreatePackageReader(@as(*const IAppxFactory, @ptrCast(self)), input_stream_, package_reader_);
            }
            pub inline fn createManifestReader(self: *const T, input_stream_: ?*IStream, manifest_reader_: ?*?*IAppxManifestReader) HRESULT {
                return @as(*const IAppxFactory.VTable, @ptrCast(self.vtable)).CreateManifestReader(@as(*const IAppxFactory, @ptrCast(self)), input_stream_, manifest_reader_);
            }
            pub inline fn createBlockMapReader(self: *const T, input_stream_: ?*IStream, block_map_reader_: ?*?*IAppxBlockMapReader) HRESULT {
                return @as(*const IAppxFactory.VTable, @ptrCast(self.vtable)).CreateBlockMapReader(@as(*const IAppxFactory, @ptrCast(self)), input_stream_, block_map_reader_);
            }
            pub inline fn createValidatedBlockMapReader(self: *const T, block_map_stream_: ?*IStream, signature_file_name_: ?[*:0]const u16, block_map_reader_: ?*?*IAppxBlockMapReader) HRESULT {
                return @as(*const IAppxFactory.VTable, @ptrCast(self.vtable)).CreateValidatedBlockMapReader(@as(*const IAppxFactory, @ptrCast(self)), block_map_stream_, signature_file_name_, block_map_reader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxFactory2_Value = Guid.initString("f1346df2-c282-4e22-b918-743a929a8d55");
pub const IID_IAppxFactory2 = &IID_IAppxFactory2_Value;
pub const IAppxFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentGroupMapReader: *const fn (
            self: *const IAppxFactory2,
            input_stream: ?*IStream,
            content_group_map_reader: ?*?*IAppxContentGroupMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSourceContentGroupMapReader: *const fn (
            self: *const IAppxFactory2,
            input_stream: ?*IStream,
            reader: ?*?*IAppxSourceContentGroupMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContentGroupMapWriter: *const fn (
            self: *const IAppxFactory2,
            stream: ?*IStream,
            content_group_map_writer: ?*?*IAppxContentGroupMapWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createContentGroupMapReader(self: *const T, input_stream_: ?*IStream, content_group_map_reader_: ?*?*IAppxContentGroupMapReader) HRESULT {
                return @as(*const IAppxFactory2.VTable, @ptrCast(self.vtable)).CreateContentGroupMapReader(@as(*const IAppxFactory2, @ptrCast(self)), input_stream_, content_group_map_reader_);
            }
            pub inline fn createSourceContentGroupMapReader(self: *const T, input_stream_: ?*IStream, reader_: ?*?*IAppxSourceContentGroupMapReader) HRESULT {
                return @as(*const IAppxFactory2.VTable, @ptrCast(self.vtable)).CreateSourceContentGroupMapReader(@as(*const IAppxFactory2, @ptrCast(self)), input_stream_, reader_);
            }
            pub inline fn createContentGroupMapWriter(self: *const T, stream_: ?*IStream, content_group_map_writer_: ?*?*IAppxContentGroupMapWriter) HRESULT {
                return @as(*const IAppxFactory2.VTable, @ptrCast(self.vtable)).CreateContentGroupMapWriter(@as(*const IAppxFactory2, @ptrCast(self)), stream_, content_group_map_writer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxPackageReader_Value = Guid.initString("b5c49650-99bc-481c-9a34-3d53a4106708");
pub const IID_IAppxPackageReader = &IID_IAppxPackageReader_Value;
pub const IAppxPackageReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBlockMap: *const fn (
            self: *const IAppxPackageReader,
            block_map_reader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFootprintFile: *const fn (
            self: *const IAppxPackageReader,
            type: APPX_FOOTPRINT_FILE_TYPE,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadFile: *const fn (
            self: *const IAppxPackageReader,
            file_name: ?[*:0]const u16,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadFiles: *const fn (
            self: *const IAppxPackageReader,
            files_enumerator: ?*?*IAppxFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManifest: *const fn (
            self: *const IAppxPackageReader,
            manifest_reader: ?*?*IAppxManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBlockMap(self: *const T, block_map_reader_: ?*?*IAppxBlockMapReader) HRESULT {
                return @as(*const IAppxPackageReader.VTable, @ptrCast(self.vtable)).GetBlockMap(@as(*const IAppxPackageReader, @ptrCast(self)), block_map_reader_);
            }
            pub inline fn getFootprintFile(self: *const T, type_: APPX_FOOTPRINT_FILE_TYPE, file_: ?*?*IAppxFile) HRESULT {
                return @as(*const IAppxPackageReader.VTable, @ptrCast(self.vtable)).GetFootprintFile(@as(*const IAppxPackageReader, @ptrCast(self)), type_, file_);
            }
            pub inline fn getPayloadFile(self: *const T, file_name_: ?[*:0]const u16, file_: ?*?*IAppxFile) HRESULT {
                return @as(*const IAppxPackageReader.VTable, @ptrCast(self.vtable)).GetPayloadFile(@as(*const IAppxPackageReader, @ptrCast(self)), file_name_, file_);
            }
            pub inline fn getPayloadFiles(self: *const T, files_enumerator_: ?*?*IAppxFilesEnumerator) HRESULT {
                return @as(*const IAppxPackageReader.VTable, @ptrCast(self.vtable)).GetPayloadFiles(@as(*const IAppxPackageReader, @ptrCast(self)), files_enumerator_);
            }
            pub inline fn getManifest(self: *const T, manifest_reader_: ?*?*IAppxManifestReader) HRESULT {
                return @as(*const IAppxPackageReader.VTable, @ptrCast(self.vtable)).GetManifest(@as(*const IAppxPackageReader, @ptrCast(self)), manifest_reader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxPackageWriter_Value = Guid.initString("9099e33b-246f-41e4-881a-008eb613f858");
pub const IID_IAppxPackageWriter = &IID_IAppxPackageWriter_Value;
pub const IAppxPackageWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFile: *const fn (
            self: *const IAppxPackageWriter,
            file_name: ?[*:0]const u16,
            content_type: ?[*:0]const u16,
            compression_option: APPX_COMPRESSION_OPTION,
            input_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxPackageWriter,
            manifest: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadFile(self: *const T, file_name_: ?[*:0]const u16, content_type_: ?[*:0]const u16, compression_option_: APPX_COMPRESSION_OPTION, input_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxPackageWriter.VTable, @ptrCast(self.vtable)).AddPayloadFile(@as(*const IAppxPackageWriter, @ptrCast(self)), file_name_, content_type_, compression_option_, input_stream_);
            }
            pub inline fn close(self: *const T, manifest_: ?*IStream) HRESULT {
                return @as(*const IAppxPackageWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxPackageWriter, @ptrCast(self)), manifest_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageWriter2_Value = Guid.initString("2cf5c4fd-e54c-4ea5-ba4e-f8c4b105a8c8");
pub const IID_IAppxPackageWriter2 = &IID_IAppxPackageWriter2_Value;
pub const IAppxPackageWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: *const fn (
            self: *const IAppxPackageWriter2,
            manifest: ?*IStream,
            content_group_map: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn close(self: *const T, manifest_: ?*IStream, content_group_map_: ?*IStream) HRESULT {
                return @as(*const IAppxPackageWriter2.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxPackageWriter2, @ptrCast(self)), manifest_, content_group_map_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageWriter3_Value = Guid.initString("a83aacd3-41c0-4501-b8a3-74164f50b2fd");
pub const IID_IAppxPackageWriter3 = &IID_IAppxPackageWriter3_Value;
pub const IAppxPackageWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFiles: *const fn (
            self: *const IAppxPackageWriter3,
            file_count: u32,
            payload_files: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM,
            memory_limit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadFiles(self: *const T, file_count_: u32, payload_files_: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM, memory_limit_: u64) HRESULT {
                return @as(*const IAppxPackageWriter3.VTable, @ptrCast(self.vtable)).AddPayloadFiles(@as(*const IAppxPackageWriter3, @ptrCast(self)), file_count_, payload_files_, memory_limit_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFile_Value = Guid.initString("91df827b-94fd-468f-827b-57f41b2f6f2e");
pub const IID_IAppxFile = &IID_IAppxFile_Value;
pub const IAppxFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCompressionOption: *const fn (
            self: *const IAppxFile,
            compression_option: ?*APPX_COMPRESSION_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentType: *const fn (
            self: *const IAppxFile,
            content_type: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn (
            self: *const IAppxFile,
            file_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const IAppxFile,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: *const fn (
            self: *const IAppxFile,
            stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCompressionOption(self: *const T, compression_option_: ?*APPX_COMPRESSION_OPTION) HRESULT {
                return @as(*const IAppxFile.VTable, @ptrCast(self.vtable)).GetCompressionOption(@as(*const IAppxFile, @ptrCast(self)), compression_option_);
            }
            pub inline fn getContentType(self: *const T, content_type_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxFile.VTable, @ptrCast(self.vtable)).GetContentType(@as(*const IAppxFile, @ptrCast(self)), content_type_);
            }
            pub inline fn getName(self: *const T, file_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxFile.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxFile, @ptrCast(self)), file_name_);
            }
            pub inline fn getSize(self: *const T, size_: ?*u64) HRESULT {
                return @as(*const IAppxFile.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IAppxFile, @ptrCast(self)), size_);
            }
            pub inline fn getStream(self: *const T, stream_: ?*?*IStream) HRESULT {
                return @as(*const IAppxFile.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IAppxFile, @ptrCast(self)), stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFilesEnumerator_Value = Guid.initString("f007eeaf-9831-411c-9847-917cdc62d1fe");
pub const IID_IAppxFilesEnumerator = &IID_IAppxFilesEnumerator_Value;
pub const IAppxFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxFilesEnumerator,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxFilesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxFilesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, file_: ?*?*IAppxFile) HRESULT {
                return @as(*const IAppxFilesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxFilesEnumerator, @ptrCast(self)), file_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxFilesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxFilesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxFilesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxFilesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapReader_Value = Guid.initString("5efec991-bca3-42d1-9ec2-e92d609ec22a");
pub const IID_IAppxBlockMapReader = &IID_IAppxBlockMapReader_Value;
pub const IAppxBlockMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFile: *const fn (
            self: *const IAppxBlockMapReader,
            filename: ?[*:0]const u16,
            file: ?*?*IAppxBlockMapFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiles: *const fn (
            self: *const IAppxBlockMapReader,
            enumerator: ?*?*IAppxBlockMapFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashMethod: *const fn (
            self: *const IAppxBlockMapReader,
            hash_method: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: *const fn (
            self: *const IAppxBlockMapReader,
            block_map_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFile(self: *const T, filename_: ?[*:0]const u16, file_: ?*?*IAppxBlockMapFile) HRESULT {
                return @as(*const IAppxBlockMapReader.VTable, @ptrCast(self.vtable)).GetFile(@as(*const IAppxBlockMapReader, @ptrCast(self)), filename_, file_);
            }
            pub inline fn getFiles(self: *const T, enumerator_: ?*?*IAppxBlockMapFilesEnumerator) HRESULT {
                return @as(*const IAppxBlockMapReader.VTable, @ptrCast(self.vtable)).GetFiles(@as(*const IAppxBlockMapReader, @ptrCast(self)), enumerator_);
            }
            pub inline fn getHashMethod(self: *const T, hash_method_: ?*?*IUri) HRESULT {
                return @as(*const IAppxBlockMapReader.VTable, @ptrCast(self.vtable)).GetHashMethod(@as(*const IAppxBlockMapReader, @ptrCast(self)), hash_method_);
            }
            pub inline fn getStream(self: *const T, block_map_stream_: ?*?*IStream) HRESULT {
                return @as(*const IAppxBlockMapReader.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IAppxBlockMapReader, @ptrCast(self)), block_map_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapFile_Value = Guid.initString("277672ac-4f63-42c1-8abc-beae3600eb59");
pub const IID_IAppxBlockMapFile = &IID_IAppxBlockMapFile_Value;
pub const IAppxBlockMapFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBlocks: *const fn (
            self: *const IAppxBlockMapFile,
            blocks: ?*?*IAppxBlockMapBlocksEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalFileHeaderSize: *const fn (
            self: *const IAppxBlockMapFile,
            lfh_size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn (
            self: *const IAppxBlockMapFile,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUncompressedSize: *const fn (
            self: *const IAppxBlockMapFile,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateFileHash: *const fn (
            self: *const IAppxBlockMapFile,
            file_stream: ?*IStream,
            is_valid: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBlocks(self: *const T, blocks_: ?*?*IAppxBlockMapBlocksEnumerator) HRESULT {
                return @as(*const IAppxBlockMapFile.VTable, @ptrCast(self.vtable)).GetBlocks(@as(*const IAppxBlockMapFile, @ptrCast(self)), blocks_);
            }
            pub inline fn getLocalFileHeaderSize(self: *const T, lfh_size_: ?*u32) HRESULT {
                return @as(*const IAppxBlockMapFile.VTable, @ptrCast(self.vtable)).GetLocalFileHeaderSize(@as(*const IAppxBlockMapFile, @ptrCast(self)), lfh_size_);
            }
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxBlockMapFile.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxBlockMapFile, @ptrCast(self)), name_);
            }
            pub inline fn getUncompressedSize(self: *const T, size_: ?*u64) HRESULT {
                return @as(*const IAppxBlockMapFile.VTable, @ptrCast(self.vtable)).GetUncompressedSize(@as(*const IAppxBlockMapFile, @ptrCast(self)), size_);
            }
            pub inline fn validateFileHash(self: *const T, file_stream_: ?*IStream, is_valid_: ?*BOOL) HRESULT {
                return @as(*const IAppxBlockMapFile.VTable, @ptrCast(self.vtable)).ValidateFileHash(@as(*const IAppxBlockMapFile, @ptrCast(self)), file_stream_, is_valid_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapFilesEnumerator_Value = Guid.initString("02b856a2-4262-4070-bacb-1a8cbbc42305");
pub const IID_IAppxBlockMapFilesEnumerator = &IID_IAppxBlockMapFilesEnumerator_Value;
pub const IAppxBlockMapFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxBlockMapFilesEnumerator,
            file: ?*?*IAppxBlockMapFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxBlockMapFilesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxBlockMapFilesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, file_: ?*?*IAppxBlockMapFile) HRESULT {
                return @as(*const IAppxBlockMapFilesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxBlockMapFilesEnumerator, @ptrCast(self)), file_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxBlockMapFilesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxBlockMapFilesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxBlockMapFilesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxBlockMapFilesEnumerator, @ptrCast(self)), has_current_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapBlock_Value = Guid.initString("75cf3930-3244-4fe0-a8c8-e0bcb270b889");
pub const IID_IAppxBlockMapBlock = &IID_IAppxBlockMapBlock_Value;
pub const IAppxBlockMapBlock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHash: *const fn (
            self: *const IAppxBlockMapBlock,
            buffer_size: ?*u32,
            buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressedSize: *const fn (
            self: *const IAppxBlockMapBlock,
            size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getHash(self: *const T, buffer_size_: ?*u32, buffer_: ?*?*u8) HRESULT {
                return @as(*const IAppxBlockMapBlock.VTable, @ptrCast(self.vtable)).GetHash(@as(*const IAppxBlockMapBlock, @ptrCast(self)), buffer_size_, buffer_);
            }
            pub inline fn getCompressedSize(self: *const T, size_: ?*u32) HRESULT {
                return @as(*const IAppxBlockMapBlock.VTable, @ptrCast(self.vtable)).GetCompressedSize(@as(*const IAppxBlockMapBlock, @ptrCast(self)), size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapBlocksEnumerator_Value = Guid.initString("6b429b5b-36ef-479e-b9eb-0c1482b49e16");
pub const IID_IAppxBlockMapBlocksEnumerator = &IID_IAppxBlockMapBlocksEnumerator_Value;
pub const IAppxBlockMapBlocksEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxBlockMapBlocksEnumerator,
            block: ?*?*IAppxBlockMapBlock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxBlockMapBlocksEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxBlockMapBlocksEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, block_: ?*?*IAppxBlockMapBlock) HRESULT {
                return @as(*const IAppxBlockMapBlocksEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxBlockMapBlocksEnumerator, @ptrCast(self)), block_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxBlockMapBlocksEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxBlockMapBlocksEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxBlockMapBlocksEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxBlockMapBlocksEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestReader_Value = Guid.initString("4e1bd148-55a0-4480-a3d1-15544710637c");
pub const IID_IAppxManifestReader = &IID_IAppxManifestReader_Value;
pub const IAppxManifestReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: *const fn (
            self: *const IAppxManifestReader,
            package_id: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: *const fn (
            self: *const IAppxManifestReader,
            package_properties: ?*?*IAppxManifestProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageDependencies: *const fn (
            self: *const IAppxManifestReader,
            dependencies: ?*?*IAppxManifestPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapabilities: *const fn (
            self: *const IAppxManifestReader,
            capabilities: ?*APPX_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResources: *const fn (
            self: *const IAppxManifestReader,
            resources: ?*?*IAppxManifestResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceCapabilities: *const fn (
            self: *const IAppxManifestReader,
            device_capabilities: ?*?*IAppxManifestDeviceCapabilitiesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrerequisite: *const fn (
            self: *const IAppxManifestReader,
            name: ?[*:0]const u16,
            value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplications: *const fn (
            self: *const IAppxManifestReader,
            applications: ?*?*IAppxManifestApplicationsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: *const fn (
            self: *const IAppxManifestReader,
            manifest_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPackageId(self: *const T, package_id_: ?*?*IAppxManifestPackageId) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetPackageId(@as(*const IAppxManifestReader, @ptrCast(self)), package_id_);
            }
            pub inline fn getProperties(self: *const T, package_properties_: ?*?*IAppxManifestProperties) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IAppxManifestReader, @ptrCast(self)), package_properties_);
            }
            pub inline fn getPackageDependencies(self: *const T, dependencies_: ?*?*IAppxManifestPackageDependenciesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetPackageDependencies(@as(*const IAppxManifestReader, @ptrCast(self)), dependencies_);
            }
            pub inline fn getCapabilities(self: *const T, capabilities_: ?*APPX_CAPABILITIES) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IAppxManifestReader, @ptrCast(self)), capabilities_);
            }
            pub inline fn getResources(self: *const T, resources_: ?*?*IAppxManifestResourcesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetResources(@as(*const IAppxManifestReader, @ptrCast(self)), resources_);
            }
            pub inline fn getDeviceCapabilities(self: *const T, device_capabilities_: ?*?*IAppxManifestDeviceCapabilitiesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetDeviceCapabilities(@as(*const IAppxManifestReader, @ptrCast(self)), device_capabilities_);
            }
            pub inline fn getPrerequisite(self: *const T, name_: ?[*:0]const u16, value_: ?*u64) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetPrerequisite(@as(*const IAppxManifestReader, @ptrCast(self)), name_, value_);
            }
            pub inline fn getApplications(self: *const T, applications_: ?*?*IAppxManifestApplicationsEnumerator) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetApplications(@as(*const IAppxManifestReader, @ptrCast(self)), applications_);
            }
            pub inline fn getStream(self: *const T, manifest_stream_: ?*?*IStream) HRESULT {
                return @as(*const IAppxManifestReader.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IAppxManifestReader, @ptrCast(self)), manifest_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxManifestReader2_Value = Guid.initString("d06f67bc-b31d-4eba-a8af-638e73e77b4d");
pub const IID_IAppxManifestReader2 = &IID_IAppxManifestReader2_Value;
pub const IAppxManifestReader2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader.VTable,
        GetQualifiedResources: *const fn (
            self: *const IAppxManifestReader2,
            resources: ?*?*IAppxManifestQualifiedResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAppxManifestReader.MethodMixin(T);
            pub inline fn getQualifiedResources(self: *const T, resources_: ?*?*IAppxManifestQualifiedResourcesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader2.VTable, @ptrCast(self.vtable)).GetQualifiedResources(@as(*const IAppxManifestReader2, @ptrCast(self)), resources_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader3_Value = Guid.initString("c43825ab-69b7-400a-9709-cc37f5a72d24");
pub const IID_IAppxManifestReader3 = &IID_IAppxManifestReader3_Value;
pub const IAppxManifestReader3 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader2.VTable,
        GetCapabilitiesByCapabilityClass: *const fn (
            self: *const IAppxManifestReader3,
            capability_class: APPX_CAPABILITY_CLASS_TYPE,
            capabilities: ?*?*IAppxManifestCapabilitiesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetDeviceFamilies: *const fn (
            self: *const IAppxManifestReader3,
            target_device_families: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAppxManifestReader2.MethodMixin(T);
            pub inline fn getCapabilitiesByCapabilityClass(self: *const T, capability_class_: APPX_CAPABILITY_CLASS_TYPE, capabilities_: ?*?*IAppxManifestCapabilitiesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader3.VTable, @ptrCast(self.vtable)).GetCapabilitiesByCapabilityClass(@as(*const IAppxManifestReader3, @ptrCast(self)), capability_class_, capabilities_);
            }
            pub inline fn getTargetDeviceFamilies(self: *const T, target_device_families_: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader3.VTable, @ptrCast(self.vtable)).GetTargetDeviceFamilies(@as(*const IAppxManifestReader3, @ptrCast(self)), target_device_families_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader4_Value = Guid.initString("4579bb7c-741d-4161-b5a1-47bd3b78ad9b");
pub const IID_IAppxManifestReader4 = &IID_IAppxManifestReader4_Value;
pub const IAppxManifestReader4 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader3.VTable,
        GetOptionalPackageInfo: *const fn (
            self: *const IAppxManifestReader4,
            optional_package_info: ?*?*IAppxManifestOptionalPackageInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAppxManifestReader3.MethodMixin(T);
            pub inline fn getOptionalPackageInfo(self: *const T, optional_package_info_: ?*?*IAppxManifestOptionalPackageInfo) HRESULT {
                return @as(*const IAppxManifestReader4.VTable, @ptrCast(self.vtable)).GetOptionalPackageInfo(@as(*const IAppxManifestReader4, @ptrCast(self)), optional_package_info_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestReader5_Value = Guid.initString("8d7ae132-a690-4c00-b75a-6aae1feaac80");
pub const IID_IAppxManifestReader5 = &IID_IAppxManifestReader5_Value;
pub const IAppxManifestReader5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMainPackageDependencies: *const fn (
            self: *const IAppxManifestReader5,
            main_package_dependencies: ?*?*IAppxManifestMainPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getMainPackageDependencies(self: *const T, main_package_dependencies_: ?*?*IAppxManifestMainPackageDependenciesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader5.VTable, @ptrCast(self.vtable)).GetMainPackageDependencies(@as(*const IAppxManifestReader5, @ptrCast(self)), main_package_dependencies_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestReader6_Value = Guid.initString("34deaca4-d3c0-4e3e-b312-e42625e3807e");
pub const IID_IAppxManifestReader6 = &IID_IAppxManifestReader6_Value;
pub const IAppxManifestReader6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsNonQualifiedResourcePackage: *const fn (
            self: *const IAppxManifestReader6,
            is_non_qualified_resource_package: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIsNonQualifiedResourcePackage(self: *const T, is_non_qualified_resource_package_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestReader6.VTable, @ptrCast(self.vtable)).GetIsNonQualifiedResourcePackage(@as(*const IAppxManifestReader6, @ptrCast(self)), is_non_qualified_resource_package_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader7_Value = Guid.initString("8efe6f27-0ce0-4988-b32d-738eb63db3b7");
pub const IID_IAppxManifestReader7 = &IID_IAppxManifestReader7_Value;
pub const IAppxManifestReader7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDriverDependencies: *const fn (
            self: *const IAppxManifestReader7,
            driver_dependencies: ?*?*IAppxManifestDriverDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOSPackageDependencies: *const fn (
            self: *const IAppxManifestReader7,
            os_package_dependencies: ?*?*IAppxManifestOSPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHostRuntimeDependencies: *const fn (
            self: *const IAppxManifestReader7,
            host_runtime_dependencies: ?*?*IAppxManifestHostRuntimeDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDriverDependencies(self: *const T, driver_dependencies_: ?*?*IAppxManifestDriverDependenciesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader7.VTable, @ptrCast(self.vtable)).GetDriverDependencies(@as(*const IAppxManifestReader7, @ptrCast(self)), driver_dependencies_);
            }
            pub inline fn getOSPackageDependencies(self: *const T, os_package_dependencies_: ?*?*IAppxManifestOSPackageDependenciesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader7.VTable, @ptrCast(self.vtable)).GetOSPackageDependencies(@as(*const IAppxManifestReader7, @ptrCast(self)), os_package_dependencies_);
            }
            pub inline fn getHostRuntimeDependencies(self: *const T, host_runtime_dependencies_: ?*?*IAppxManifestHostRuntimeDependenciesEnumerator) HRESULT {
                return @as(*const IAppxManifestReader7.VTable, @ptrCast(self.vtable)).GetHostRuntimeDependencies(@as(*const IAppxManifestReader7, @ptrCast(self)), host_runtime_dependencies_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverDependenciesEnumerator_Value = Guid.initString("fe039db2-467f-4755-8404-8f5eb6865b33");
pub const IID_IAppxManifestDriverDependenciesEnumerator = &IID_IAppxManifestDriverDependenciesEnumerator_Value;
pub const IAppxManifestDriverDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestDriverDependenciesEnumerator,
            driver_dependency: ?*?*IAppxManifestDriverDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestDriverDependenciesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestDriverDependenciesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, driver_dependency_: ?*?*IAppxManifestDriverDependency) HRESULT {
                return @as(*const IAppxManifestDriverDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestDriverDependenciesEnumerator, @ptrCast(self)), driver_dependency_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDriverDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestDriverDependenciesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDriverDependenciesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestDriverDependenciesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverDependency_Value = Guid.initString("1210cb94-5a92-4602-be24-79f318af4af9");
pub const IID_IAppxManifestDriverDependency = &IID_IAppxManifestDriverDependency_Value;
pub const IAppxManifestDriverDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDriverConstraints: *const fn (
            self: *const IAppxManifestDriverDependency,
            driver_constraints: ?*?*IAppxManifestDriverConstraintsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getDriverConstraints(self: *const T, driver_constraints_: ?*?*IAppxManifestDriverConstraintsEnumerator) HRESULT {
                return @as(*const IAppxManifestDriverDependency.VTable, @ptrCast(self.vtable)).GetDriverConstraints(@as(*const IAppxManifestDriverDependency, @ptrCast(self)), driver_constraints_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverConstraintsEnumerator_Value = Guid.initString("d402b2d1-f600-49e0-95e6-975d8da13d89");
pub const IID_IAppxManifestDriverConstraintsEnumerator = &IID_IAppxManifestDriverConstraintsEnumerator_Value;
pub const IAppxManifestDriverConstraintsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestDriverConstraintsEnumerator,
            driver_constraint: ?*?*IAppxManifestDriverConstraint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestDriverConstraintsEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestDriverConstraintsEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, driver_constraint_: ?*?*IAppxManifestDriverConstraint) HRESULT {
                return @as(*const IAppxManifestDriverConstraintsEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestDriverConstraintsEnumerator, @ptrCast(self)), driver_constraint_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDriverConstraintsEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestDriverConstraintsEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDriverConstraintsEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestDriverConstraintsEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverConstraint_Value = Guid.initString("c031bee4-bbcc-48ea-a237-c34045c80a07");
pub const IID_IAppxManifestDriverConstraint = &IID_IAppxManifestDriverConstraint_Value;
pub const IAppxManifestDriverConstraint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestDriverConstraint,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: *const fn (
            self: *const IAppxManifestDriverConstraint,
            min_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinDate: *const fn (
            self: *const IAppxManifestDriverConstraint,
            min_date: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestDriverConstraint.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestDriverConstraint, @ptrCast(self)), name_);
            }
            pub inline fn getMinVersion(self: *const T, min_version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestDriverConstraint.VTable, @ptrCast(self.vtable)).GetMinVersion(@as(*const IAppxManifestDriverConstraint, @ptrCast(self)), min_version_);
            }
            pub inline fn getMinDate(self: *const T, min_date_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestDriverConstraint.VTable, @ptrCast(self.vtable)).GetMinDate(@as(*const IAppxManifestDriverConstraint, @ptrCast(self)), min_date_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestOSPackageDependenciesEnumerator_Value = Guid.initString("b84e2fc3-f8ec-4bc1-8ae2-156346f5ffea");
pub const IID_IAppxManifestOSPackageDependenciesEnumerator = &IID_IAppxManifestOSPackageDependenciesEnumerator_Value;
pub const IAppxManifestOSPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            os_package_dependency: ?*?*IAppxManifestOSPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, os_package_dependency_: ?*?*IAppxManifestOSPackageDependency) HRESULT {
                return @as(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestOSPackageDependenciesEnumerator, @ptrCast(self)), os_package_dependency_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestOSPackageDependenciesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestOSPackageDependenciesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestOSPackageDependency_Value = Guid.initString("154995ee-54a6-4f14-ac97-d8cf0519644b");
pub const IID_IAppxManifestOSPackageDependency = &IID_IAppxManifestOSPackageDependency_Value;
pub const IAppxManifestOSPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestOSPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn (
            self: *const IAppxManifestOSPackageDependency,
            version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestOSPackageDependency.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestOSPackageDependency, @ptrCast(self)), name_);
            }
            pub inline fn getVersion(self: *const T, version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestOSPackageDependency.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IAppxManifestOSPackageDependency, @ptrCast(self)), version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependenciesEnumerator_Value = Guid.initString("6427a646-7f49-433e-b1a6-0da309f6885a");
pub const IID_IAppxManifestHostRuntimeDependenciesEnumerator = &IID_IAppxManifestHostRuntimeDependenciesEnumerator_Value;
pub const IAppxManifestHostRuntimeDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            host_runtime_dependency: ?*?*IAppxManifestHostRuntimeDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, host_runtime_dependency_: ?*?*IAppxManifestHostRuntimeDependency) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestHostRuntimeDependenciesEnumerator, @ptrCast(self)), host_runtime_dependency_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestHostRuntimeDependenciesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestHostRuntimeDependenciesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependency_Value = Guid.initString("3455d234-8414-410d-95c7-7b35255b8391");
pub const IID_IAppxManifestHostRuntimeDependency = &IID_IAppxManifestHostRuntimeDependency_Value;
pub const IAppxManifestHostRuntimeDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestHostRuntimeDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: *const fn (
            self: *const IAppxManifestHostRuntimeDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: *const fn (
            self: *const IAppxManifestHostRuntimeDependency,
            min_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependency.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestHostRuntimeDependency, @ptrCast(self)), name_);
            }
            pub inline fn getPublisher(self: *const T, publisher_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependency.VTable, @ptrCast(self.vtable)).GetPublisher(@as(*const IAppxManifestHostRuntimeDependency, @ptrCast(self)), publisher_);
            }
            pub inline fn getMinVersion(self: *const T, min_version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependency.VTable, @ptrCast(self.vtable)).GetMinVersion(@as(*const IAppxManifestHostRuntimeDependency, @ptrCast(self)), min_version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependency2_Value = Guid.initString("c26f23a8-ee10-4ad6-b898-2b4d7aebfe6a");
pub const IID_IAppxManifestHostRuntimeDependency2 = &IID_IAppxManifestHostRuntimeDependency2_Value;
pub const IAppxManifestHostRuntimeDependency2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageFamilyName: *const fn (
            self: *const IAppxManifestHostRuntimeDependency2,
            package_family_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPackageFamilyName(self: *const T, package_family_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestHostRuntimeDependency2.VTable, @ptrCast(self.vtable)).GetPackageFamilyName(@as(*const IAppxManifestHostRuntimeDependency2, @ptrCast(self)), package_family_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestOptionalPackageInfo_Value = Guid.initString("2634847d-5b5d-4fe5-a243-002ff95edc7e");
pub const IID_IAppxManifestOptionalPackageInfo = &IID_IAppxManifestOptionalPackageInfo_Value;
pub const IAppxManifestOptionalPackageInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsOptionalPackage: *const fn (
            self: *const IAppxManifestOptionalPackageInfo,
            is_optional_package: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainPackageName: *const fn (
            self: *const IAppxManifestOptionalPackageInfo,
            main_package_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIsOptionalPackage(self: *const T, is_optional_package_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestOptionalPackageInfo.VTable, @ptrCast(self.vtable)).GetIsOptionalPackage(@as(*const IAppxManifestOptionalPackageInfo, @ptrCast(self)), is_optional_package_);
            }
            pub inline fn getMainPackageName(self: *const T, main_package_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestOptionalPackageInfo.VTable, @ptrCast(self.vtable)).GetMainPackageName(@as(*const IAppxManifestOptionalPackageInfo, @ptrCast(self)), main_package_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestMainPackageDependenciesEnumerator_Value = Guid.initString("a99c4f00-51d2-4f0f-ba46-7ed5255ebdff");
pub const IID_IAppxManifestMainPackageDependenciesEnumerator = &IID_IAppxManifestMainPackageDependenciesEnumerator_Value;
pub const IAppxManifestMainPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            main_package_dependency: ?*?*IAppxManifestMainPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, main_package_dependency_: ?*?*IAppxManifestMainPackageDependency) HRESULT {
                return @as(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestMainPackageDependenciesEnumerator, @ptrCast(self)), main_package_dependency_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestMainPackageDependenciesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestMainPackageDependenciesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestMainPackageDependency_Value = Guid.initString("05d0611c-bc29-46d5-97e2-84b9c79bd8ae");
pub const IID_IAppxManifestMainPackageDependency = &IID_IAppxManifestMainPackageDependency_Value;
pub const IAppxManifestMainPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestMainPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: *const fn (
            self: *const IAppxManifestMainPackageDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFamilyName: *const fn (
            self: *const IAppxManifestMainPackageDependency,
            package_family_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestMainPackageDependency.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestMainPackageDependency, @ptrCast(self)), name_);
            }
            pub inline fn getPublisher(self: *const T, publisher_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestMainPackageDependency.VTable, @ptrCast(self.vtable)).GetPublisher(@as(*const IAppxManifestMainPackageDependency, @ptrCast(self)), publisher_);
            }
            pub inline fn getPackageFamilyName(self: *const T, package_family_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestMainPackageDependency.VTable, @ptrCast(self.vtable)).GetPackageFamilyName(@as(*const IAppxManifestMainPackageDependency, @ptrCast(self)), package_family_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageId_Value = Guid.initString("283ce2d7-7153-4a91-9649-7a0f7240945f");
pub const IID_IAppxManifestPackageId = &IID_IAppxManifestPackageId_Value;
pub const IAppxManifestPackageId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestPackageId,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArchitecture: *const fn (
            self: *const IAppxManifestPackageId,
            architecture: ?*APPX_PACKAGE_ARCHITECTURE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: *const fn (
            self: *const IAppxManifestPackageId,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn (
            self: *const IAppxManifestPackageId,
            package_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResourceId: *const fn (
            self: *const IAppxManifestPackageId,
            resource_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComparePublisher: *const fn (
            self: *const IAppxManifestPackageId,
            other: ?[*:0]const u16,
            is_same: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFullName: *const fn (
            self: *const IAppxManifestPackageId,
            package_full_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFamilyName: *const fn (
            self: *const IAppxManifestPackageId,
            package_family_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestPackageId, @ptrCast(self)), name_);
            }
            pub inline fn getArchitecture(self: *const T, architecture_: ?*APPX_PACKAGE_ARCHITECTURE) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetArchitecture(@as(*const IAppxManifestPackageId, @ptrCast(self)), architecture_);
            }
            pub inline fn getPublisher(self: *const T, publisher_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetPublisher(@as(*const IAppxManifestPackageId, @ptrCast(self)), publisher_);
            }
            pub inline fn getVersion(self: *const T, package_version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IAppxManifestPackageId, @ptrCast(self)), package_version_);
            }
            pub inline fn getResourceId(self: *const T, resource_id_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetResourceId(@as(*const IAppxManifestPackageId, @ptrCast(self)), resource_id_);
            }
            pub inline fn comparePublisher(self: *const T, other_: ?[*:0]const u16, is_same_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).ComparePublisher(@as(*const IAppxManifestPackageId, @ptrCast(self)), other_, is_same_);
            }
            pub inline fn getPackageFullName(self: *const T, package_full_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetPackageFullName(@as(*const IAppxManifestPackageId, @ptrCast(self)), package_full_name_);
            }
            pub inline fn getPackageFamilyName(self: *const T, package_family_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageId.VTable, @ptrCast(self.vtable)).GetPackageFamilyName(@as(*const IAppxManifestPackageId, @ptrCast(self)), package_family_name_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestPackageId2_Value = Guid.initString("2256999d-d617-42f1-880e-0ba4542319d5");
pub const IID_IAppxManifestPackageId2 = &IID_IAppxManifestPackageId2_Value;
pub const IAppxManifestPackageId2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestPackageId.VTable,
        GetArchitecture2: *const fn (
            self: *const IAppxManifestPackageId2,
            architecture: ?*APPX_PACKAGE_ARCHITECTURE2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAppxManifestPackageId.MethodMixin(T);
            pub inline fn getArchitecture2(self: *const T, architecture_: ?*APPX_PACKAGE_ARCHITECTURE2) HRESULT {
                return @as(*const IAppxManifestPackageId2.VTable, @ptrCast(self.vtable)).GetArchitecture2(@as(*const IAppxManifestPackageId2, @ptrCast(self)), architecture_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestProperties_Value = Guid.initString("03faf64d-f26f-4b2c-aaf7-8fe7789b8bca");
pub const IID_IAppxManifestProperties = &IID_IAppxManifestProperties_Value;
pub const IAppxManifestProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoolValue: *const fn (
            self: *const IAppxManifestProperties,
            name: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: *const fn (
            self: *const IAppxManifestProperties,
            name: ?[*:0]const u16,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getBoolValue(self: *const T, name_: ?[*:0]const u16, value_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestProperties.VTable, @ptrCast(self.vtable)).GetBoolValue(@as(*const IAppxManifestProperties, @ptrCast(self)), name_, value_);
            }
            pub inline fn getStringValue(self: *const T, name_: ?[*:0]const u16, value_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestProperties.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const IAppxManifestProperties, @ptrCast(self)), name_, value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestTargetDeviceFamiliesEnumerator_Value = Guid.initString("36537f36-27a4-4788-88c0-733819575017");
pub const IID_IAppxManifestTargetDeviceFamiliesEnumerator = &IID_IAppxManifestTargetDeviceFamiliesEnumerator_Value;
pub const IAppxManifestTargetDeviceFamiliesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            target_device_family: ?*?*IAppxManifestTargetDeviceFamily,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, target_device_family_: ?*?*IAppxManifestTargetDeviceFamily) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestTargetDeviceFamiliesEnumerator, @ptrCast(self)), target_device_family_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestTargetDeviceFamiliesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestTargetDeviceFamiliesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestTargetDeviceFamily_Value = Guid.initString("9091b09b-c8d5-4f31-8687-a338259faefb");
pub const IID_IAppxManifestTargetDeviceFamily = &IID_IAppxManifestTargetDeviceFamily_Value;
pub const IAppxManifestTargetDeviceFamily = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestTargetDeviceFamily,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: *const fn (
            self: *const IAppxManifestTargetDeviceFamily,
            min_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxVersionTested: *const fn (
            self: *const IAppxManifestTargetDeviceFamily,
            max_version_tested: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamily.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestTargetDeviceFamily, @ptrCast(self)), name_);
            }
            pub inline fn getMinVersion(self: *const T, min_version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamily.VTable, @ptrCast(self.vtable)).GetMinVersion(@as(*const IAppxManifestTargetDeviceFamily, @ptrCast(self)), min_version_);
            }
            pub inline fn getMaxVersionTested(self: *const T, max_version_tested_: ?*u64) HRESULT {
                return @as(*const IAppxManifestTargetDeviceFamily.VTable, @ptrCast(self.vtable)).GetMaxVersionTested(@as(*const IAppxManifestTargetDeviceFamily, @ptrCast(self)), max_version_tested_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependenciesEnumerator_Value = Guid.initString("b43bbcf9-65a6-42dd-bac0-8c6741e7f5a4");
pub const IID_IAppxManifestPackageDependenciesEnumerator = &IID_IAppxManifestPackageDependenciesEnumerator_Value;
pub const IAppxManifestPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestPackageDependenciesEnumerator,
            dependency: ?*?*IAppxManifestPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestPackageDependenciesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestPackageDependenciesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, dependency_: ?*?*IAppxManifestPackageDependency) HRESULT {
                return @as(*const IAppxManifestPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestPackageDependenciesEnumerator, @ptrCast(self)), dependency_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestPackageDependenciesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestPackageDependenciesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestPackageDependenciesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependency_Value = Guid.initString("e4946b59-733e-43f0-a724-3bde4c1285a0");
pub const IID_IAppxManifestPackageDependency = &IID_IAppxManifestPackageDependency_Value;
pub const IAppxManifestPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxManifestPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: *const fn (
            self: *const IAppxManifestPackageDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: *const fn (
            self: *const IAppxManifestPackageDependency,
            min_version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageDependency.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxManifestPackageDependency, @ptrCast(self)), name_);
            }
            pub inline fn getPublisher(self: *const T, publisher_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestPackageDependency.VTable, @ptrCast(self.vtable)).GetPublisher(@as(*const IAppxManifestPackageDependency, @ptrCast(self)), publisher_);
            }
            pub inline fn getMinVersion(self: *const T, min_version_: ?*u64) HRESULT {
                return @as(*const IAppxManifestPackageDependency.VTable, @ptrCast(self.vtable)).GetMinVersion(@as(*const IAppxManifestPackageDependency, @ptrCast(self)), min_version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependency2_Value = Guid.initString("dda0b713-f3ff-49d3-898a-2786780c5d98");
pub const IID_IAppxManifestPackageDependency2 = &IID_IAppxManifestPackageDependency2_Value;
pub const IAppxManifestPackageDependency2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestPackageDependency.VTable,
        GetMaxMajorVersionTested: *const fn (
            self: *const IAppxManifestPackageDependency2,
            max_major_version_tested: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAppxManifestPackageDependency.MethodMixin(T);
            pub inline fn getMaxMajorVersionTested(self: *const T, max_major_version_tested_: ?*u16) HRESULT {
                return @as(*const IAppxManifestPackageDependency2.VTable, @ptrCast(self.vtable)).GetMaxMajorVersionTested(@as(*const IAppxManifestPackageDependency2, @ptrCast(self)), max_major_version_tested_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestPackageDependency3_Value = Guid.initString("1ac56374-6198-4d6b-92e4-749d5ab8a895");
pub const IID_IAppxManifestPackageDependency3 = &IID_IAppxManifestPackageDependency3_Value;
pub const IAppxManifestPackageDependency3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsOptional: *const fn (
            self: *const IAppxManifestPackageDependency3,
            is_optional: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIsOptional(self: *const T, is_optional_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestPackageDependency3.VTable, @ptrCast(self.vtable)).GetIsOptional(@as(*const IAppxManifestPackageDependency3, @ptrCast(self)), is_optional_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestResourcesEnumerator_Value = Guid.initString("de4dfbbd-881a-48bb-858c-d6f2baeae6ed");
pub const IID_IAppxManifestResourcesEnumerator = &IID_IAppxManifestResourcesEnumerator_Value;
pub const IAppxManifestResourcesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestResourcesEnumerator,
            resource: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestResourcesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestResourcesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, resource_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestResourcesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestResourcesEnumerator, @ptrCast(self)), resource_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestResourcesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestResourcesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestResourcesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestResourcesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestDeviceCapabilitiesEnumerator_Value = Guid.initString("30204541-427b-4a1c-bacf-655bf463a540");
pub const IID_IAppxManifestDeviceCapabilitiesEnumerator = &IID_IAppxManifestDeviceCapabilitiesEnumerator_Value;
pub const IAppxManifestDeviceCapabilitiesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            device_capability: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, device_capability_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestDeviceCapabilitiesEnumerator, @ptrCast(self)), device_capability_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestDeviceCapabilitiesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestDeviceCapabilitiesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestCapabilitiesEnumerator_Value = Guid.initString("11d22258-f470-42c1-b291-8361c5437e41");
pub const IID_IAppxManifestCapabilitiesEnumerator = &IID_IAppxManifestCapabilitiesEnumerator_Value;
pub const IAppxManifestCapabilitiesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestCapabilitiesEnumerator,
            capability: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestCapabilitiesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestCapabilitiesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, capability_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestCapabilitiesEnumerator, @ptrCast(self)), capability_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestCapabilitiesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestCapabilitiesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestCapabilitiesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestApplicationsEnumerator_Value = Guid.initString("9eb8a55a-f04b-4d0d-808d-686185d4847a");
pub const IID_IAppxManifestApplicationsEnumerator = &IID_IAppxManifestApplicationsEnumerator_Value;
pub const IAppxManifestApplicationsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestApplicationsEnumerator,
            application: ?*?*IAppxManifestApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestApplicationsEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestApplicationsEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, application_: ?*?*IAppxManifestApplication) HRESULT {
                return @as(*const IAppxManifestApplicationsEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestApplicationsEnumerator, @ptrCast(self)), application_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestApplicationsEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestApplicationsEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestApplicationsEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestApplicationsEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestApplication_Value = Guid.initString("5da89bf4-3773-46be-b650-7e744863b7e8");
pub const IID_IAppxManifestApplication = &IID_IAppxManifestApplication_Value;
pub const IAppxManifestApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringValue: *const fn (
            self: *const IAppxManifestApplication,
            name: ?[*:0]const u16,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppUserModelId: *const fn (
            self: *const IAppxManifestApplication,
            app_user_model_id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStringValue(self: *const T, name_: ?[*:0]const u16, value_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestApplication.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const IAppxManifestApplication, @ptrCast(self)), name_, value_);
            }
            pub inline fn getAppUserModelId(self: *const T, app_user_model_id_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestApplication.VTable, @ptrCast(self.vtable)).GetAppUserModelId(@as(*const IAppxManifestApplication, @ptrCast(self)), app_user_model_id_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestQualifiedResourcesEnumerator_Value = Guid.initString("8ef6adfe-3762-4a8f-9373-2fc5d444c8d2");
pub const IID_IAppxManifestQualifiedResourcesEnumerator = &IID_IAppxManifestQualifiedResourcesEnumerator_Value;
pub const IAppxManifestQualifiedResourcesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            resource: ?*?*IAppxManifestQualifiedResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, resource_: ?*?*IAppxManifestQualifiedResource) HRESULT {
                return @as(*const IAppxManifestQualifiedResourcesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxManifestQualifiedResourcesEnumerator, @ptrCast(self)), resource_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestQualifiedResourcesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxManifestQualifiedResourcesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxManifestQualifiedResourcesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxManifestQualifiedResourcesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestQualifiedResource_Value = Guid.initString("3b53a497-3c5c-48d1-9ea3-bb7eac8cd7d4");
pub const IID_IAppxManifestQualifiedResource = &IID_IAppxManifestQualifiedResource_Value;
pub const IAppxManifestQualifiedResource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLanguage: *const fn (
            self: *const IAppxManifestQualifiedResource,
            language: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScale: *const fn (
            self: *const IAppxManifestQualifiedResource,
            scale: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDXFeatureLevel: *const fn (
            self: *const IAppxManifestQualifiedResource,
            dx_feature_level: ?*DX_FEATURE_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getLanguage(self: *const T, language_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxManifestQualifiedResource.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IAppxManifestQualifiedResource, @ptrCast(self)), language_);
            }
            pub inline fn getScale(self: *const T, scale_: ?*u32) HRESULT {
                return @as(*const IAppxManifestQualifiedResource.VTable, @ptrCast(self.vtable)).GetScale(@as(*const IAppxManifestQualifiedResource, @ptrCast(self)), scale_);
            }
            pub inline fn getDXFeatureLevel(self: *const T, dx_feature_level_: ?*DX_FEATURE_LEVEL) HRESULT {
                return @as(*const IAppxManifestQualifiedResource.VTable, @ptrCast(self.vtable)).GetDXFeatureLevel(@as(*const IAppxManifestQualifiedResource, @ptrCast(self)), dx_feature_level_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleFactory_Value = Guid.initString("bba65864-965f-4a5f-855f-f074bdbf3a7b");
pub const IID_IAppxBundleFactory = &IID_IAppxBundleFactory_Value;
pub const IAppxBundleFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBundleWriter: *const fn (
            self: *const IAppxBundleFactory,
            output_stream: ?*IStream,
            bundle_version: u64,
            bundle_writer: ?*?*IAppxBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBundleReader: *const fn (
            self: *const IAppxBundleFactory,
            input_stream: ?*IStream,
            bundle_reader: ?*?*IAppxBundleReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBundleManifestReader: *const fn (
            self: *const IAppxBundleFactory,
            input_stream: ?*IStream,
            manifest_reader: ?*?*IAppxBundleManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createBundleWriter(self: *const T, output_stream_: ?*IStream, bundle_version_: u64, bundle_writer_: ?*?*IAppxBundleWriter) HRESULT {
                return @as(*const IAppxBundleFactory.VTable, @ptrCast(self.vtable)).CreateBundleWriter(@as(*const IAppxBundleFactory, @ptrCast(self)), output_stream_, bundle_version_, bundle_writer_);
            }
            pub inline fn createBundleReader(self: *const T, input_stream_: ?*IStream, bundle_reader_: ?*?*IAppxBundleReader) HRESULT {
                return @as(*const IAppxBundleFactory.VTable, @ptrCast(self.vtable)).CreateBundleReader(@as(*const IAppxBundleFactory, @ptrCast(self)), input_stream_, bundle_reader_);
            }
            pub inline fn createBundleManifestReader(self: *const T, input_stream_: ?*IStream, manifest_reader_: ?*?*IAppxBundleManifestReader) HRESULT {
                return @as(*const IAppxBundleFactory.VTable, @ptrCast(self.vtable)).CreateBundleManifestReader(@as(*const IAppxBundleFactory, @ptrCast(self)), input_stream_, manifest_reader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleWriter_Value = Guid.initString("ec446fe8-bfec-4c64-ab4f-49f038f0c6d2");
pub const IID_IAppxBundleWriter = &IID_IAppxBundleWriter_Value;
pub const IAppxBundleWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackage: *const fn (
            self: *const IAppxBundleWriter,
            file_name: ?[*:0]const u16,
            package_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadPackage(self: *const T, file_name_: ?[*:0]const u16, package_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxBundleWriter.VTable, @ptrCast(self.vtable)).AddPayloadPackage(@as(*const IAppxBundleWriter, @ptrCast(self)), file_name_, package_stream_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IAppxBundleWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxBundleWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter2_Value = Guid.initString("6d8fe971-01cc-49a0-b685-233851279962");
pub const IID_IAppxBundleWriter2 = &IID_IAppxBundleWriter2_Value;
pub const IAppxBundleWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExternalPackageReference: *const fn (
            self: *const IAppxBundleWriter2,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addExternalPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxBundleWriter2.VTable, @ptrCast(self.vtable)).AddExternalPackageReference(@as(*const IAppxBundleWriter2, @ptrCast(self)), file_name_, input_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter3_Value = Guid.initString("ad711152-f969-4193-82d5-9ddf2786d21a");
pub const IID_IAppxBundleWriter3 = &IID_IAppxBundleWriter3_Value;
pub const IAppxBundleWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPackageReference: *const fn (
            self: *const IAppxBundleWriter3,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxBundleWriter3,
            hash_method_string: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxBundleWriter3.VTable, @ptrCast(self.vtable)).AddPackageReference(@as(*const IAppxBundleWriter3, @ptrCast(self)), file_name_, input_stream_);
            }
            pub inline fn close(self: *const T, hash_method_string_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxBundleWriter3.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxBundleWriter3, @ptrCast(self)), hash_method_string_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter4_Value = Guid.initString("9cd9d523-5009-4c01-9882-dc029fbd47a3");
pub const IID_IAppxBundleWriter4 = &IID_IAppxBundleWriter4_Value;
pub const IAppxBundleWriter4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackage: *const fn (
            self: *const IAppxBundleWriter4,
            file_name: ?[*:0]const u16,
            package_stream: ?*IStream,
            is_default_applicable_package: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPackageReference: *const fn (
            self: *const IAppxBundleWriter4,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
            is_default_applicable_package: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExternalPackageReference: *const fn (
            self: *const IAppxBundleWriter4,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
            is_default_applicable_package: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadPackage(self: *const T, file_name_: ?[*:0]const u16, package_stream_: ?*IStream, is_default_applicable_package_: BOOL) HRESULT {
                return @as(*const IAppxBundleWriter4.VTable, @ptrCast(self.vtable)).AddPayloadPackage(@as(*const IAppxBundleWriter4, @ptrCast(self)), file_name_, package_stream_, is_default_applicable_package_);
            }
            pub inline fn addPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream, is_default_applicable_package_: BOOL) HRESULT {
                return @as(*const IAppxBundleWriter4.VTable, @ptrCast(self.vtable)).AddPackageReference(@as(*const IAppxBundleWriter4, @ptrCast(self)), file_name_, input_stream_, is_default_applicable_package_);
            }
            pub inline fn addExternalPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream, is_default_applicable_package_: BOOL) HRESULT {
                return @as(*const IAppxBundleWriter4.VTable, @ptrCast(self.vtable)).AddExternalPackageReference(@as(*const IAppxBundleWriter4, @ptrCast(self)), file_name_, input_stream_, is_default_applicable_package_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleReader_Value = Guid.initString("dd75b8c0-ba76-43b0-ae0f-68656a1dc5c8");
pub const IID_IAppxBundleReader = &IID_IAppxBundleReader_Value;
pub const IAppxBundleReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFootprintFile: *const fn (
            self: *const IAppxBundleReader,
            file_type: APPX_BUNDLE_FOOTPRINT_FILE_TYPE,
            footprint_file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlockMap: *const fn (
            self: *const IAppxBundleReader,
            block_map_reader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManifest: *const fn (
            self: *const IAppxBundleReader,
            manifest_reader: ?*?*IAppxBundleManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadPackages: *const fn (
            self: *const IAppxBundleReader,
            payload_packages: ?*?*IAppxFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadPackage: *const fn (
            self: *const IAppxBundleReader,
            file_name: ?[*:0]const u16,
            payload_package: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFootprintFile(self: *const T, file_type_: APPX_BUNDLE_FOOTPRINT_FILE_TYPE, footprint_file_: ?*?*IAppxFile) HRESULT {
                return @as(*const IAppxBundleReader.VTable, @ptrCast(self.vtable)).GetFootprintFile(@as(*const IAppxBundleReader, @ptrCast(self)), file_type_, footprint_file_);
            }
            pub inline fn getBlockMap(self: *const T, block_map_reader_: ?*?*IAppxBlockMapReader) HRESULT {
                return @as(*const IAppxBundleReader.VTable, @ptrCast(self.vtable)).GetBlockMap(@as(*const IAppxBundleReader, @ptrCast(self)), block_map_reader_);
            }
            pub inline fn getManifest(self: *const T, manifest_reader_: ?*?*IAppxBundleManifestReader) HRESULT {
                return @as(*const IAppxBundleReader.VTable, @ptrCast(self.vtable)).GetManifest(@as(*const IAppxBundleReader, @ptrCast(self)), manifest_reader_);
            }
            pub inline fn getPayloadPackages(self: *const T, payload_packages_: ?*?*IAppxFilesEnumerator) HRESULT {
                return @as(*const IAppxBundleReader.VTable, @ptrCast(self.vtable)).GetPayloadPackages(@as(*const IAppxBundleReader, @ptrCast(self)), payload_packages_);
            }
            pub inline fn getPayloadPackage(self: *const T, file_name_: ?[*:0]const u16, payload_package_: ?*?*IAppxFile) HRESULT {
                return @as(*const IAppxBundleReader.VTable, @ptrCast(self.vtable)).GetPayloadPackage(@as(*const IAppxBundleReader, @ptrCast(self)), file_name_, payload_package_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestReader_Value = Guid.initString("cf0ebbc1-cc99-4106-91eb-e67462e04fb0");
pub const IID_IAppxBundleManifestReader = &IID_IAppxBundleManifestReader_Value;
pub const IAppxBundleManifestReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: *const fn (
            self: *const IAppxBundleManifestReader,
            package_id: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageInfoItems: *const fn (
            self: *const IAppxBundleManifestReader,
            package_info_items: ?*?*IAppxBundleManifestPackageInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: *const fn (
            self: *const IAppxBundleManifestReader,
            manifest_stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPackageId(self: *const T, package_id_: ?*?*IAppxManifestPackageId) HRESULT {
                return @as(*const IAppxBundleManifestReader.VTable, @ptrCast(self.vtable)).GetPackageId(@as(*const IAppxBundleManifestReader, @ptrCast(self)), package_id_);
            }
            pub inline fn getPackageInfoItems(self: *const T, package_info_items_: ?*?*IAppxBundleManifestPackageInfoEnumerator) HRESULT {
                return @as(*const IAppxBundleManifestReader.VTable, @ptrCast(self.vtable)).GetPackageInfoItems(@as(*const IAppxBundleManifestReader, @ptrCast(self)), package_info_items_);
            }
            pub inline fn getStream(self: *const T, manifest_stream_: ?*?*IStream) HRESULT {
                return @as(*const IAppxBundleManifestReader.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IAppxBundleManifestReader, @ptrCast(self)), manifest_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestReader2_Value = Guid.initString("5517df70-033f-4af2-8213-87d766805c02");
pub const IID_IAppxBundleManifestReader2 = &IID_IAppxBundleManifestReader2_Value;
pub const IAppxBundleManifestReader2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionalBundles: *const fn (
            self: *const IAppxBundleManifestReader2,
            optional_bundles: ?*?*IAppxBundleManifestOptionalBundleInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getOptionalBundles(self: *const T, optional_bundles_: ?*?*IAppxBundleManifestOptionalBundleInfoEnumerator) HRESULT {
                return @as(*const IAppxBundleManifestReader2.VTable, @ptrCast(self.vtable)).GetOptionalBundles(@as(*const IAppxBundleManifestReader2, @ptrCast(self)), optional_bundles_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestPackageInfoEnumerator_Value = Guid.initString("f9b856ee-49a6-4e19-b2b0-6a2406d63a32");
pub const IID_IAppxBundleManifestPackageInfoEnumerator = &IID_IAppxBundleManifestPackageInfoEnumerator_Value;
pub const IAppxBundleManifestPackageInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            package_info: ?*?*IAppxBundleManifestPackageInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, package_info_: ?*?*IAppxBundleManifestPackageInfo) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfoEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxBundleManifestPackageInfoEnumerator, @ptrCast(self)), package_info_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfoEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxBundleManifestPackageInfoEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfoEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxBundleManifestPackageInfoEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestPackageInfo_Value = Guid.initString("54cd06c1-268f-40bb-8ed2-757a9ebaec8d");
pub const IID_IAppxBundleManifestPackageInfo = &IID_IAppxBundleManifestPackageInfo_Value;
pub const IAppxBundleManifestPackageInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageType: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            package_type: ?*APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageId: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            package_id: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            file_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResources: *const fn (
            self: *const IAppxBundleManifestPackageInfo,
            resources: ?*?*IAppxManifestQualifiedResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPackageType(self: *const T, package_type_: ?*APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetPackageType(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), package_type_);
            }
            pub inline fn getPackageId(self: *const T, package_id_: ?*?*IAppxManifestPackageId) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetPackageId(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), package_id_);
            }
            pub inline fn getFileName(self: *const T, file_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), file_name_);
            }
            pub inline fn getOffset(self: *const T, offset_: ?*u64) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), offset_);
            }
            pub inline fn getSize(self: *const T, size_: ?*u64) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), size_);
            }
            pub inline fn getResources(self: *const T, resources_: ?*?*IAppxManifestQualifiedResourcesEnumerator) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo.VTable, @ptrCast(self.vtable)).GetResources(@as(*const IAppxBundleManifestPackageInfo, @ptrCast(self)), resources_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestPackageInfo2_Value = Guid.initString("44c2acbc-b2cf-4ccb-bbdb-9c6da8c3bc9e");
pub const IID_IAppxBundleManifestPackageInfo2 = &IID_IAppxBundleManifestPackageInfo2_Value;
pub const IAppxBundleManifestPackageInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsPackageReference: *const fn (
            self: *const IAppxBundleManifestPackageInfo2,
            is_package_reference: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIsNonQualifiedResourcePackage: *const fn (
            self: *const IAppxBundleManifestPackageInfo2,
            is_non_qualified_resource_package: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIsDefaultApplicablePackage: *const fn (
            self: *const IAppxBundleManifestPackageInfo2,
            is_default_applicable_package: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIsPackageReference(self: *const T, is_package_reference_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo2.VTable, @ptrCast(self.vtable)).GetIsPackageReference(@as(*const IAppxBundleManifestPackageInfo2, @ptrCast(self)), is_package_reference_);
            }
            pub inline fn getIsNonQualifiedResourcePackage(self: *const T, is_non_qualified_resource_package_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo2.VTable, @ptrCast(self.vtable)).GetIsNonQualifiedResourcePackage(@as(*const IAppxBundleManifestPackageInfo2, @ptrCast(self)), is_non_qualified_resource_package_);
            }
            pub inline fn getIsDefaultApplicablePackage(self: *const T, is_default_applicable_package_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo2.VTable, @ptrCast(self.vtable)).GetIsDefaultApplicablePackage(@as(*const IAppxBundleManifestPackageInfo2, @ptrCast(self)), is_default_applicable_package_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxBundleManifestPackageInfo3_Value = Guid.initString("6ba74b98-bb74-4296-80d0-5f4256a99675");
pub const IID_IAppxBundleManifestPackageInfo3 = &IID_IAppxBundleManifestPackageInfo3_Value;
pub const IAppxBundleManifestPackageInfo3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetDeviceFamilies: *const fn (
            self: *const IAppxBundleManifestPackageInfo3,
            target_device_families: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getTargetDeviceFamilies(self: *const T, target_device_families_: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo3.VTable, @ptrCast(self.vtable)).GetTargetDeviceFamilies(@as(*const IAppxBundleManifestPackageInfo3, @ptrCast(self)), target_device_families_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxBundleManifestPackageInfo4_Value = Guid.initString("5da6f13d-a8a7-4532-857c-1393d659371d");
pub const IID_IAppxBundleManifestPackageInfo4 = &IID_IAppxBundleManifestPackageInfo4_Value;
pub const IAppxBundleManifestPackageInfo4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsStub: *const fn (
            self: *const IAppxBundleManifestPackageInfo4,
            is_stub: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getIsStub(self: *const T, is_stub_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestPackageInfo4.VTable, @ptrCast(self.vtable)).GetIsStub(@as(*const IAppxBundleManifestPackageInfo4, @ptrCast(self)), is_stub_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestOptionalBundleInfoEnumerator_Value = Guid.initString("9a178793-f97e-46ac-aaca-dd5ba4c177c8");
pub const IID_IAppxBundleManifestOptionalBundleInfoEnumerator = &IID_IAppxBundleManifestOptionalBundleInfoEnumerator_Value;
pub const IAppxBundleManifestOptionalBundleInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            optional_bundle: ?*?*IAppxBundleManifestOptionalBundleInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, optional_bundle_: ?*?*IAppxBundleManifestOptionalBundleInfo) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxBundleManifestOptionalBundleInfoEnumerator, @ptrCast(self)), optional_bundle_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxBundleManifestOptionalBundleInfoEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxBundleManifestOptionalBundleInfoEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestOptionalBundleInfo_Value = Guid.initString("515bf2e8-bcb0-4d69-8c48-e383147b6e12");
pub const IID_IAppxBundleManifestOptionalBundleInfo = &IID_IAppxBundleManifestOptionalBundleInfo_Value;
pub const IAppxBundleManifestOptionalBundleInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfo,
            package_id: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfo,
            file_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageInfoItems: *const fn (
            self: *const IAppxBundleManifestOptionalBundleInfo,
            package_info_items: ?*?*IAppxBundleManifestPackageInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getPackageId(self: *const T, package_id_: ?*?*IAppxManifestPackageId) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfo.VTable, @ptrCast(self.vtable)).GetPackageId(@as(*const IAppxBundleManifestOptionalBundleInfo, @ptrCast(self)), package_id_);
            }
            pub inline fn getFileName(self: *const T, file_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfo.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IAppxBundleManifestOptionalBundleInfo, @ptrCast(self)), file_name_);
            }
            pub inline fn getPackageInfoItems(self: *const T, package_info_items_: ?*?*IAppxBundleManifestPackageInfoEnumerator) HRESULT {
                return @as(*const IAppxBundleManifestOptionalBundleInfo.VTable, @ptrCast(self.vtable)).GetPackageInfoItems(@as(*const IAppxBundleManifestOptionalBundleInfo, @ptrCast(self)), package_info_items_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupFilesEnumerator_Value = Guid.initString("1a09a2fd-7440-44eb-8c84-848205a6a1cc");
pub const IID_IAppxContentGroupFilesEnumerator = &IID_IAppxContentGroupFilesEnumerator_Value;
pub const IAppxContentGroupFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxContentGroupFilesEnumerator,
            file: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxContentGroupFilesEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxContentGroupFilesEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, file_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxContentGroupFilesEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxContentGroupFilesEnumerator, @ptrCast(self)), file_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxContentGroupFilesEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxContentGroupFilesEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxContentGroupFilesEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxContentGroupFilesEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroup_Value = Guid.initString("328f6468-c04f-4e3c-b6fa-6b8d27f3003a");
pub const IID_IAppxContentGroup = &IID_IAppxContentGroup_Value;
pub const IAppxContentGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: *const fn (
            self: *const IAppxContentGroup,
            group_name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiles: *const fn (
            self: *const IAppxContentGroup,
            enumerator: ?*?*IAppxContentGroupFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getName(self: *const T, group_name_: ?*?PWSTR) HRESULT {
                return @as(*const IAppxContentGroup.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAppxContentGroup, @ptrCast(self)), group_name_);
            }
            pub inline fn getFiles(self: *const T, enumerator_: ?*?*IAppxContentGroupFilesEnumerator) HRESULT {
                return @as(*const IAppxContentGroup.VTable, @ptrCast(self.vtable)).GetFiles(@as(*const IAppxContentGroup, @ptrCast(self)), enumerator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupsEnumerator_Value = Guid.initString("3264e477-16d1-4d63-823e-7d2984696634");
pub const IID_IAppxContentGroupsEnumerator = &IID_IAppxContentGroupsEnumerator_Value;
pub const IAppxContentGroupsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: *const fn (
            self: *const IAppxContentGroupsEnumerator,
            stream: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: *const fn (
            self: *const IAppxContentGroupsEnumerator,
            has_current: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: *const fn (
            self: *const IAppxContentGroupsEnumerator,
            has_next: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getCurrent(self: *const T, stream_: ?*?*IAppxContentGroup) HRESULT {
                return @as(*const IAppxContentGroupsEnumerator.VTable, @ptrCast(self.vtable)).GetCurrent(@as(*const IAppxContentGroupsEnumerator, @ptrCast(self)), stream_);
            }
            pub inline fn getHasCurrent(self: *const T, has_current_: ?*BOOL) HRESULT {
                return @as(*const IAppxContentGroupsEnumerator.VTable, @ptrCast(self.vtable)).GetHasCurrent(@as(*const IAppxContentGroupsEnumerator, @ptrCast(self)), has_current_);
            }
            pub inline fn moveNext(self: *const T, has_next_: ?*BOOL) HRESULT {
                return @as(*const IAppxContentGroupsEnumerator.VTable, @ptrCast(self.vtable)).MoveNext(@as(*const IAppxContentGroupsEnumerator, @ptrCast(self)), has_next_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupMapReader_Value = Guid.initString("418726d8-dd99-4f5d-9886-157add20de01");
pub const IID_IAppxContentGroupMapReader = &IID_IAppxContentGroupMapReader_Value;
pub const IAppxContentGroupMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequiredGroup: *const fn (
            self: *const IAppxContentGroupMapReader,
            required_group: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutomaticGroups: *const fn (
            self: *const IAppxContentGroupMapReader,
            automatic_groups_enumerator: ?*?*IAppxContentGroupsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRequiredGroup(self: *const T, required_group_: ?*?*IAppxContentGroup) HRESULT {
                return @as(*const IAppxContentGroupMapReader.VTable, @ptrCast(self.vtable)).GetRequiredGroup(@as(*const IAppxContentGroupMapReader, @ptrCast(self)), required_group_);
            }
            pub inline fn getAutomaticGroups(self: *const T, automatic_groups_enumerator_: ?*?*IAppxContentGroupsEnumerator) HRESULT {
                return @as(*const IAppxContentGroupMapReader.VTable, @ptrCast(self.vtable)).GetAutomaticGroups(@as(*const IAppxContentGroupMapReader, @ptrCast(self)), automatic_groups_enumerator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxSourceContentGroupMapReader_Value = Guid.initString("f329791d-540b-4a9f-bc75-3282b7d73193");
pub const IID_IAppxSourceContentGroupMapReader = &IID_IAppxSourceContentGroupMapReader_Value;
pub const IAppxSourceContentGroupMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequiredGroup: *const fn (
            self: *const IAppxSourceContentGroupMapReader,
            required_group: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutomaticGroups: *const fn (
            self: *const IAppxSourceContentGroupMapReader,
            automatic_groups_enumerator: ?*?*IAppxContentGroupsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getRequiredGroup(self: *const T, required_group_: ?*?*IAppxContentGroup) HRESULT {
                return @as(*const IAppxSourceContentGroupMapReader.VTable, @ptrCast(self.vtable)).GetRequiredGroup(@as(*const IAppxSourceContentGroupMapReader, @ptrCast(self)), required_group_);
            }
            pub inline fn getAutomaticGroups(self: *const T, automatic_groups_enumerator_: ?*?*IAppxContentGroupsEnumerator) HRESULT {
                return @as(*const IAppxSourceContentGroupMapReader.VTable, @ptrCast(self.vtable)).GetAutomaticGroups(@as(*const IAppxSourceContentGroupMapReader, @ptrCast(self)), automatic_groups_enumerator_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupMapWriter_Value = Guid.initString("d07ab776-a9de-4798-8c14-3db31e687c78");
pub const IID_IAppxContentGroupMapWriter = &IID_IAppxContentGroupMapWriter_Value;
pub const IAppxContentGroupMapWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAutomaticGroup: *const fn (
            self: *const IAppxContentGroupMapWriter,
            group_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAutomaticFile: *const fn (
            self: *const IAppxContentGroupMapWriter,
            file_name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxContentGroupMapWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addAutomaticGroup(self: *const T, group_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxContentGroupMapWriter.VTable, @ptrCast(self.vtable)).AddAutomaticGroup(@as(*const IAppxContentGroupMapWriter, @ptrCast(self)), group_name_);
            }
            pub inline fn addAutomaticFile(self: *const T, file_name_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxContentGroupMapWriter.VTable, @ptrCast(self.vtable)).AddAutomaticFile(@as(*const IAppxContentGroupMapWriter, @ptrCast(self)), file_name_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IAppxContentGroupMapWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxContentGroupMapWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxPackagingDiagnosticEventSink_Value = Guid.initString("17239d47-6adb-45d2-80f6-f9cbc3bf059d");
pub const IID_IAppxPackagingDiagnosticEventSink = &IID_IAppxPackagingDiagnosticEventSink_Value;
pub const IAppxPackagingDiagnosticEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportContextChange: *const fn (
            self: *const IAppxPackagingDiagnosticEventSink,
            change_type: APPX_PACKAGING_CONTEXT_CHANGE_TYPE,
            context_id: i32,
            context_name: ?[*:0]const u8,
            context_message: ?[*:0]const u16,
            details_message: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportError: *const fn (
            self: *const IAppxPackagingDiagnosticEventSink,
            error_message: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reportContextChange(self: *const T, change_type_: APPX_PACKAGING_CONTEXT_CHANGE_TYPE, context_id_: i32, context_name_: ?[*:0]const u8, context_message_: ?[*:0]const u16, details_message_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxPackagingDiagnosticEventSink.VTable, @ptrCast(self.vtable)).ReportContextChange(@as(*const IAppxPackagingDiagnosticEventSink, @ptrCast(self)), change_type_, context_id_, context_name_, context_message_, details_message_);
            }
            pub inline fn reportError(self: *const T, error_message_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxPackagingDiagnosticEventSink.VTable, @ptrCast(self.vtable)).ReportError(@as(*const IAppxPackagingDiagnosticEventSink, @ptrCast(self)), error_message_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxPackagingDiagnosticEventSinkManager_Value = Guid.initString("369648fa-a7eb-4909-a15d-6954a078f18a");
pub const IID_IAppxPackagingDiagnosticEventSinkManager = &IID_IAppxPackagingDiagnosticEventSinkManager_Value;
pub const IAppxPackagingDiagnosticEventSinkManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSinkForProcess: *const fn (
            self: *const IAppxPackagingDiagnosticEventSinkManager,
            sink: ?*IAppxPackagingDiagnosticEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setSinkForProcess(self: *const T, sink_: ?*IAppxPackagingDiagnosticEventSink) HRESULT {
                return @as(*const IAppxPackagingDiagnosticEventSinkManager.VTable, @ptrCast(self.vtable)).SetSinkForProcess(@as(*const IAppxPackagingDiagnosticEventSinkManager, @ptrCast(self)), sink_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPX_ENCRYPTED_PACKAGE_SETTINGS = extern struct {
    keyLength: u32,
    encryptionAlgorithm: ?[*:0]const u16,
    useDiffusion: BOOL,
    blockMapHashAlgorithm: ?*IUri,
};

pub const APPX_ENCRYPTED_PACKAGE_OPTIONS = enum(u32) {
    NONE = 0,
    DIFFUSION = 1,
    PAGE_HASHING = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DIFFUSION: u1 = 0,
        PAGE_HASHING: u1 = 0,
    }) APPX_ENCRYPTED_PACKAGE_OPTIONS {
        return @as(APPX_ENCRYPTED_PACKAGE_OPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(APPX_ENCRYPTED_PACKAGE_OPTIONS.NONE) else 0) | (if (o.DIFFUSION == 1) @intFromEnum(APPX_ENCRYPTED_PACKAGE_OPTIONS.DIFFUSION) else 0) | (if (o.PAGE_HASHING == 1) @intFromEnum(APPX_ENCRYPTED_PACKAGE_OPTIONS.PAGE_HASHING) else 0)));
    }
};
pub const APPX_ENCRYPTED_PACKAGE_OPTION_NONE = APPX_ENCRYPTED_PACKAGE_OPTIONS.NONE;
pub const APPX_ENCRYPTED_PACKAGE_OPTION_DIFFUSION = APPX_ENCRYPTED_PACKAGE_OPTIONS.DIFFUSION;
pub const APPX_ENCRYPTED_PACKAGE_OPTION_PAGE_HASHING = APPX_ENCRYPTED_PACKAGE_OPTIONS.PAGE_HASHING;

pub const APPX_ENCRYPTED_PACKAGE_SETTINGS2 = extern struct {
    keyLength: u32,
    encryptionAlgorithm: ?[*:0]const u16,
    blockMapHashAlgorithm: ?*IUri,
    options: u32,
};

pub const APPX_KEY_INFO = extern struct {
    keyLength: u32,
    keyIdLength: u32,
    key: ?*u8,
    keyId: ?*u8,
};

pub const APPX_ENCRYPTED_EXEMPTIONS = extern struct {
    count: u32,
    plainTextFiles: ?*?PWSTR,
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptionFactory_Value = Guid.initString("80e8e04d-8c88-44ae-a011-7cadf6fb2e72");
pub const IID_IAppxEncryptionFactory = &IID_IAppxEncryptionFactory_Value;
pub const IAppxEncryptionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptPackage: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            key_info: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageWriter: *const fn (
            self: *const IAppxEncryptionFactory,
            output_stream: ?*IStream,
            manifest_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            package_writer: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageReader: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            key_info: ?*const APPX_KEY_INFO,
            package_reader: ?*?*IAppxPackageReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptBundle: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptBundle: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            key_info: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleWriter: *const fn (
            self: *const IAppxEncryptionFactory,
            output_stream: ?*IStream,
            bundle_version: u64,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            bundle_writer: ?*?*IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleReader: *const fn (
            self: *const IAppxEncryptionFactory,
            input_stream: ?*IStream,
            key_info: ?*const APPX_KEY_INFO,
            bundle_reader: ?*?*IAppxBundleReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn encryptPackage(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).EncryptPackage(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, output_stream_, settings_, key_info_, exempted_files_);
            }
            pub inline fn decryptPackage(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, key_info_: ?*const APPX_KEY_INFO) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).DecryptPackage(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, output_stream_, key_info_);
            }
            pub inline fn createEncryptedPackageWriter(self: *const T, output_stream_: ?*IStream, manifest_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, package_writer_: ?*?*IAppxEncryptedPackageWriter) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).CreateEncryptedPackageWriter(@as(*const IAppxEncryptionFactory, @ptrCast(self)), output_stream_, manifest_stream_, settings_, key_info_, exempted_files_, package_writer_);
            }
            pub inline fn createEncryptedPackageReader(self: *const T, input_stream_: ?*IStream, key_info_: ?*const APPX_KEY_INFO, package_reader_: ?*?*IAppxPackageReader) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).CreateEncryptedPackageReader(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, key_info_, package_reader_);
            }
            pub inline fn encryptBundle(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).EncryptBundle(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, output_stream_, settings_, key_info_, exempted_files_);
            }
            pub inline fn decryptBundle(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, key_info_: ?*const APPX_KEY_INFO) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).DecryptBundle(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, output_stream_, key_info_);
            }
            pub inline fn createEncryptedBundleWriter(self: *const T, output_stream_: ?*IStream, bundle_version_: u64, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, bundle_writer_: ?*?*IAppxEncryptedBundleWriter) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).CreateEncryptedBundleWriter(@as(*const IAppxEncryptionFactory, @ptrCast(self)), output_stream_, bundle_version_, settings_, key_info_, exempted_files_, bundle_writer_);
            }
            pub inline fn createEncryptedBundleReader(self: *const T, input_stream_: ?*IStream, key_info_: ?*const APPX_KEY_INFO, bundle_reader_: ?*?*IAppxBundleReader) HRESULT {
                return @as(*const IAppxEncryptionFactory.VTable, @ptrCast(self.vtable)).CreateEncryptedBundleReader(@as(*const IAppxEncryptionFactory, @ptrCast(self)), input_stream_, key_info_, bundle_reader_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory2_Value = Guid.initString("c1b11eee-c4ba-4ab2-a55d-d015fe8ff64f");
pub const IID_IAppxEncryptionFactory2 = &IID_IAppxEncryptionFactory2_Value;
pub const IAppxEncryptionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateEncryptedPackageWriter: *const fn (
            self: *const IAppxEncryptionFactory2,
            output_stream: ?*IStream,
            manifest_stream: ?*IStream,
            content_group_map_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            package_writer: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createEncryptedPackageWriter(self: *const T, output_stream_: ?*IStream, manifest_stream_: ?*IStream, content_group_map_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, package_writer_: ?*?*IAppxEncryptedPackageWriter) HRESULT {
                return @as(*const IAppxEncryptionFactory2.VTable, @ptrCast(self.vtable)).CreateEncryptedPackageWriter(@as(*const IAppxEncryptionFactory2, @ptrCast(self)), output_stream_, manifest_stream_, content_group_map_stream_, settings_, key_info_, exempted_files_, package_writer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory3_Value = Guid.initString("09edca37-cd64-47d6-b7e8-1cb11d4f7e05");
pub const IID_IAppxEncryptionFactory3 = &IID_IAppxEncryptionFactory3_Value;
pub const IAppxEncryptionFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: *const fn (
            self: *const IAppxEncryptionFactory3,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageWriter: *const fn (
            self: *const IAppxEncryptionFactory3,
            output_stream: ?*IStream,
            manifest_stream: ?*IStream,
            content_group_map_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            package_writer: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptBundle: *const fn (
            self: *const IAppxEncryptionFactory3,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleWriter: *const fn (
            self: *const IAppxEncryptionFactory3,
            output_stream: ?*IStream,
            bundle_version: u64,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            bundle_writer: ?*?*IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn encryptPackage(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS) HRESULT {
                return @as(*const IAppxEncryptionFactory3.VTable, @ptrCast(self.vtable)).EncryptPackage(@as(*const IAppxEncryptionFactory3, @ptrCast(self)), input_stream_, output_stream_, settings_, key_info_, exempted_files_);
            }
            pub inline fn createEncryptedPackageWriter(self: *const T, output_stream_: ?*IStream, manifest_stream_: ?*IStream, content_group_map_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, package_writer_: ?*?*IAppxEncryptedPackageWriter) HRESULT {
                return @as(*const IAppxEncryptionFactory3.VTable, @ptrCast(self.vtable)).CreateEncryptedPackageWriter(@as(*const IAppxEncryptionFactory3, @ptrCast(self)), output_stream_, manifest_stream_, content_group_map_stream_, settings_, key_info_, exempted_files_, package_writer_);
            }
            pub inline fn encryptBundle(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS) HRESULT {
                return @as(*const IAppxEncryptionFactory3.VTable, @ptrCast(self.vtable)).EncryptBundle(@as(*const IAppxEncryptionFactory3, @ptrCast(self)), input_stream_, output_stream_, settings_, key_info_, exempted_files_);
            }
            pub inline fn createEncryptedBundleWriter(self: *const T, output_stream_: ?*IStream, bundle_version_: u64, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, bundle_writer_: ?*?*IAppxEncryptedBundleWriter) HRESULT {
                return @as(*const IAppxEncryptionFactory3.VTable, @ptrCast(self.vtable)).CreateEncryptedBundleWriter(@as(*const IAppxEncryptionFactory3, @ptrCast(self)), output_stream_, bundle_version_, settings_, key_info_, exempted_files_, bundle_writer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory4_Value = Guid.initString("a879611f-12fd-41fe-85d5-06ae779bbaf5");
pub const IID_IAppxEncryptionFactory4 = &IID_IAppxEncryptionFactory4_Value;
pub const IAppxEncryptionFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: *const fn (
            self: *const IAppxEncryptionFactory4,
            input_stream: ?*IStream,
            output_stream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
            exempted_files: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            memory_limit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn encryptPackage(self: *const T, input_stream_: ?*IStream, output_stream_: ?*IStream, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO, exempted_files_: ?*const APPX_ENCRYPTED_EXEMPTIONS, memory_limit_: u64) HRESULT {
                return @as(*const IAppxEncryptionFactory4.VTable, @ptrCast(self.vtable)).EncryptPackage(@as(*const IAppxEncryptionFactory4, @ptrCast(self)), input_stream_, output_stream_, settings_, key_info_, exempted_files_, memory_limit_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedPackageWriter_Value = Guid.initString("f43d0b0b-1379-40e2-9b29-682ea2bf42af");
pub const IID_IAppxEncryptedPackageWriter = &IID_IAppxEncryptedPackageWriter_Value;
pub const IAppxEncryptedPackageWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFileEncrypted: *const fn (
            self: *const IAppxEncryptedPackageWriter,
            file_name: ?[*:0]const u16,
            compression_option: APPX_COMPRESSION_OPTION,
            input_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadFileEncrypted(self: *const T, file_name_: ?[*:0]const u16, compression_option_: APPX_COMPRESSION_OPTION, input_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxEncryptedPackageWriter.VTable, @ptrCast(self.vtable)).AddPayloadFileEncrypted(@as(*const IAppxEncryptedPackageWriter, @ptrCast(self)), file_name_, compression_option_, input_stream_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IAppxEncryptedPackageWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxEncryptedPackageWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedPackageWriter2_Value = Guid.initString("3e475447-3a25-40b5-8ad2-f953ae50c92d");
pub const IID_IAppxEncryptedPackageWriter2 = &IID_IAppxEncryptedPackageWriter2_Value;
pub const IAppxEncryptedPackageWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFilesEncrypted: *const fn (
            self: *const IAppxEncryptedPackageWriter2,
            file_count: u32,
            payload_files: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM,
            memory_limit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadFilesEncrypted(self: *const T, file_count_: u32, payload_files_: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM, memory_limit_: u64) HRESULT {
                return @as(*const IAppxEncryptedPackageWriter2.VTable, @ptrCast(self.vtable)).AddPayloadFilesEncrypted(@as(*const IAppxEncryptedPackageWriter2, @ptrCast(self)), file_count_, payload_files_, memory_limit_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedBundleWriter_Value = Guid.initString("80b0902f-7bf0-4117-b8c6-4279ef81ee77");
pub const IID_IAppxEncryptedBundleWriter = &IID_IAppxEncryptedBundleWriter_Value;
pub const IAppxEncryptedBundleWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackageEncrypted: *const fn (
            self: *const IAppxEncryptedBundleWriter,
            file_name: ?[*:0]const u16,
            package_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: *const fn (
            self: *const IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadPackageEncrypted(self: *const T, file_name_: ?[*:0]const u16, package_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxEncryptedBundleWriter.VTable, @ptrCast(self.vtable)).AddPayloadPackageEncrypted(@as(*const IAppxEncryptedBundleWriter, @ptrCast(self)), file_name_, package_stream_);
            }
            pub inline fn close(self: *const T) HRESULT {
                return @as(*const IAppxEncryptedBundleWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const IAppxEncryptedBundleWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptedBundleWriter2_Value = Guid.initString("e644be82-f0fa-42b8-a956-8d1cb48ee379");
pub const IID_IAppxEncryptedBundleWriter2 = &IID_IAppxEncryptedBundleWriter2_Value;
pub const IAppxEncryptedBundleWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExternalPackageReference: *const fn (
            self: *const IAppxEncryptedBundleWriter2,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addExternalPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxEncryptedBundleWriter2.VTable, @ptrCast(self.vtable)).AddExternalPackageReference(@as(*const IAppxEncryptedBundleWriter2, @ptrCast(self)), file_name_, input_stream_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION = enum(i32) {
    A = 0,
};
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION_APPEND_DELTA = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION.A;

pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS = enum(u32) {
    NONE = 0,
    SKIP_VALIDATION = 1,
    LOCALIZED = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SKIP_VALIDATION: u1 = 0,
        LOCALIZED: u1 = 0,
    }) APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS {
        return @as(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.NONE) else 0) | (if (o.SKIP_VALIDATION == 1) @intFromEnum(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.SKIP_VALIDATION) else 0) | (if (o.LOCALIZED == 1) @intFromEnum(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.LOCALIZED) else 0)));
    }
};
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_NONE = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.NONE;
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_SKIP_VALIDATION = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.SKIP_VALIDATION;
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_LOCALIZED = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.LOCALIZED;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptedBundleWriter3_Value = Guid.initString("0d34deb3-5cae-4dd3-977c-504932a51d31");
pub const IID_IAppxEncryptedBundleWriter3 = &IID_IAppxEncryptedBundleWriter3_Value;
pub const IAppxEncryptedBundleWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackageEncrypted: *const fn (
            self: *const IAppxEncryptedBundleWriter3,
            file_name: ?[*:0]const u16,
            package_stream: ?*IStream,
            is_default_applicable_package: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExternalPackageReference: *const fn (
            self: *const IAppxEncryptedBundleWriter3,
            file_name: ?[*:0]const u16,
            input_stream: ?*IStream,
            is_default_applicable_package: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn addPayloadPackageEncrypted(self: *const T, file_name_: ?[*:0]const u16, package_stream_: ?*IStream, is_default_applicable_package_: BOOL) HRESULT {
                return @as(*const IAppxEncryptedBundleWriter3.VTable, @ptrCast(self.vtable)).AddPayloadPackageEncrypted(@as(*const IAppxEncryptedBundleWriter3, @ptrCast(self)), file_name_, package_stream_, is_default_applicable_package_);
            }
            pub inline fn addExternalPackageReference(self: *const T, file_name_: ?[*:0]const u16, input_stream_: ?*IStream, is_default_applicable_package_: BOOL) HRESULT {
                return @as(*const IAppxEncryptedBundleWriter3.VTable, @ptrCast(self.vtable)).AddExternalPackageReference(@as(*const IAppxEncryptedBundleWriter3, @ptrCast(self)), file_name_, input_stream_, is_default_applicable_package_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageEditor_Value = Guid.initString("e2adb6dc-5e71-4416-86b6-86e5f5291a6b");
pub const IID_IAppxPackageEditor = &IID_IAppxPackageEditor_Value;
pub const IAppxPackageEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWorkingDirectory: *const fn (
            self: *const IAppxPackageEditor,
            working_directory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDeltaPackage: *const fn (
            self: *const IAppxPackageEditor,
            updated_package_stream: ?*IStream,
            baseline_package_stream: ?*IStream,
            delta_package_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDeltaPackageUsingBaselineBlockMap: *const fn (
            self: *const IAppxPackageEditor,
            updated_package_stream: ?*IStream,
            baseline_block_map_stream: ?*IStream,
            baseline_package_full_name: ?[*:0]const u16,
            delta_package_stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdatePackage: *const fn (
            self: *const IAppxPackageEditor,
            baseline_package_stream: ?*IStream,
            delta_package_stream: ?*IStream,
            update_option: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateEncryptedPackage: *const fn (
            self: *const IAppxPackageEditor,
            baseline_encrypted_package_stream: ?*IStream,
            delta_package_stream: ?*IStream,
            update_option: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            key_info: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdatePackageManifest: *const fn (
            self: *const IAppxPackageEditor,
            package_stream: ?*IStream,
            updated_manifest_stream: ?*IStream,
            is_package_encrypted: BOOL,
            options: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setWorkingDirectory(self: *const T, working_directory_: ?[*:0]const u16) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).SetWorkingDirectory(@as(*const IAppxPackageEditor, @ptrCast(self)), working_directory_);
            }
            pub inline fn createDeltaPackage(self: *const T, updated_package_stream_: ?*IStream, baseline_package_stream_: ?*IStream, delta_package_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).CreateDeltaPackage(@as(*const IAppxPackageEditor, @ptrCast(self)), updated_package_stream_, baseline_package_stream_, delta_package_stream_);
            }
            pub inline fn createDeltaPackageUsingBaselineBlockMap(self: *const T, updated_package_stream_: ?*IStream, baseline_block_map_stream_: ?*IStream, baseline_package_full_name_: ?[*:0]const u16, delta_package_stream_: ?*IStream) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).CreateDeltaPackageUsingBaselineBlockMap(@as(*const IAppxPackageEditor, @ptrCast(self)), updated_package_stream_, baseline_block_map_stream_, baseline_package_full_name_, delta_package_stream_);
            }
            pub inline fn updatePackage(self: *const T, baseline_package_stream_: ?*IStream, delta_package_stream_: ?*IStream, update_option_: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).UpdatePackage(@as(*const IAppxPackageEditor, @ptrCast(self)), baseline_package_stream_, delta_package_stream_, update_option_);
            }
            pub inline fn updateEncryptedPackage(self: *const T, baseline_encrypted_package_stream_: ?*IStream, delta_package_stream_: ?*IStream, update_option_: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION, settings_: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, key_info_: ?*const APPX_KEY_INFO) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).UpdateEncryptedPackage(@as(*const IAppxPackageEditor, @ptrCast(self)), baseline_encrypted_package_stream_, delta_package_stream_, update_option_, settings_, key_info_);
            }
            pub inline fn updatePackageManifest(self: *const T, package_stream_: ?*IStream, updated_manifest_stream_: ?*IStream, is_package_encrypted_: BOOL, options_: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS) HRESULT {
                return @as(*const IAppxPackageEditor.VTable, @ptrCast(self.vtable)).UpdatePackageManifest(@as(*const IAppxPackageEditor, @ptrCast(self)), package_stream_, updated_manifest_stream_, is_package_encrypted_, options_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PACKAGE_VERSION = extern struct {
    Anonymous: extern union {
        Version: u64 align(4),
        Anonymous: extern struct {
            Revision: u16,
            Build: u16,
            Minor: u16,
            Major: u16,
        } align(4),
    },
};

pub const PACKAGE_ID = extern struct {
    reserved: u32 align(4),
    processorArchitecture: u32 align(4),
    version: PACKAGE_VERSION align(4),
    name: ?PWSTR align(4),
    publisher: ?PWSTR align(4),
    resourceId: ?PWSTR align(4),
    publisherId: ?PWSTR align(4),
};

pub const PackagePathType = enum(i32) {
    Install = 0,
    Mutable = 1,
    Effective = 2,
    MachineExternal = 3,
    UserExternal = 4,
    EffectiveExternal = 5,
};
pub const PackagePathType_Install = PackagePathType.Install;
pub const PackagePathType_Mutable = PackagePathType.Mutable;
pub const PackagePathType_Effective = PackagePathType.Effective;
pub const PackagePathType_MachineExternal = PackagePathType.MachineExternal;
pub const PackagePathType_UserExternal = PackagePathType.UserExternal;
pub const PackagePathType_EffectiveExternal = PackagePathType.EffectiveExternal;

pub const PackageOrigin = enum(i32) {
    Unknown = 0,
    Unsigned = 1,
    Inbox = 2,
    Store = 3,
    DeveloperUnsigned = 4,
    DeveloperSigned = 5,
    LineOfBusiness = 6,
};
pub const PackageOrigin_Unknown = PackageOrigin.Unknown;
pub const PackageOrigin_Unsigned = PackageOrigin.Unsigned;
pub const PackageOrigin_Inbox = PackageOrigin.Inbox;
pub const PackageOrigin_Store = PackageOrigin.Store;
pub const PackageOrigin_DeveloperUnsigned = PackageOrigin.DeveloperUnsigned;
pub const PackageOrigin_DeveloperSigned = PackageOrigin.DeveloperSigned;
pub const PackageOrigin_LineOfBusiness = PackageOrigin.LineOfBusiness;

pub const _PACKAGE_INFO_REFERENCE = extern struct {
    reserved: ?*anyopaque,
};

pub const PACKAGE_INFO = extern struct {
    reserved: u32 align(4),
    flags: u32 align(4),
    path: ?PWSTR align(4),
    packageFullName: ?PWSTR align(4),
    packageFamilyName: ?PWSTR align(4),
    packageId: PACKAGE_ID align(4),
};

pub const CreatePackageDependencyOptions = enum(i32) {
    None = 0,
    DoNotVerifyDependencyResolution = 1,
    ScopeIsSystem = 2,
};
pub const CreatePackageDependencyOptions_None = CreatePackageDependencyOptions.None;
pub const CreatePackageDependencyOptions_DoNotVerifyDependencyResolution = CreatePackageDependencyOptions.DoNotVerifyDependencyResolution;
pub const CreatePackageDependencyOptions_ScopeIsSystem = CreatePackageDependencyOptions.ScopeIsSystem;

pub const PackageDependencyLifetimeKind = enum(i32) {
    Process = 0,
    FilePath = 1,
    RegistryKey = 2,
};
pub const PackageDependencyLifetimeKind_Process = PackageDependencyLifetimeKind.Process;
pub const PackageDependencyLifetimeKind_FilePath = PackageDependencyLifetimeKind.FilePath;
pub const PackageDependencyLifetimeKind_RegistryKey = PackageDependencyLifetimeKind.RegistryKey;

pub const AddPackageDependencyOptions = enum(i32) {
    None = 0,
    PrependIfRankCollision = 1,
};
pub const AddPackageDependencyOptions_None = AddPackageDependencyOptions.None;
pub const AddPackageDependencyOptions_PrependIfRankCollision = AddPackageDependencyOptions.PrependIfRankCollision;

pub const PackageDependencyProcessorArchitectures = enum(i32) {
    None = 0,
    Neutral = 1,
    X86 = 2,
    X64 = 4,
    Arm = 8,
    Arm64 = 16,
    X86A64 = 32,
};
pub const PackageDependencyProcessorArchitectures_None = PackageDependencyProcessorArchitectures.None;
pub const PackageDependencyProcessorArchitectures_Neutral = PackageDependencyProcessorArchitectures.Neutral;
pub const PackageDependencyProcessorArchitectures_X86 = PackageDependencyProcessorArchitectures.X86;
pub const PackageDependencyProcessorArchitectures_X64 = PackageDependencyProcessorArchitectures.X64;
pub const PackageDependencyProcessorArchitectures_Arm = PackageDependencyProcessorArchitectures.Arm;
pub const PackageDependencyProcessorArchitectures_Arm64 = PackageDependencyProcessorArchitectures.Arm64;
pub const PackageDependencyProcessorArchitectures_X86A64 = PackageDependencyProcessorArchitectures.X86A64;

pub const PACKAGEDEPENDENCY_CONTEXT__ = extern struct {
    unused: i32,
};

pub const AppPolicyLifecycleManagement = enum(i32) {
    Unmanaged = 0,
    Managed = 1,
};
pub const AppPolicyLifecycleManagement_Unmanaged = AppPolicyLifecycleManagement.Unmanaged;
pub const AppPolicyLifecycleManagement_Managed = AppPolicyLifecycleManagement.Managed;

pub const AppPolicyWindowingModel = enum(i32) {
    None = 0,
    Universal = 1,
    ClassicDesktop = 2,
    ClassicPhone = 3,
};
pub const AppPolicyWindowingModel_None = AppPolicyWindowingModel.None;
pub const AppPolicyWindowingModel_Universal = AppPolicyWindowingModel.Universal;
pub const AppPolicyWindowingModel_ClassicDesktop = AppPolicyWindowingModel.ClassicDesktop;
pub const AppPolicyWindowingModel_ClassicPhone = AppPolicyWindowingModel.ClassicPhone;

pub const AppPolicyMediaFoundationCodecLoading = enum(i32) {
    All = 0,
    InboxOnly = 1,
};
pub const AppPolicyMediaFoundationCodecLoading_All = AppPolicyMediaFoundationCodecLoading.All;
pub const AppPolicyMediaFoundationCodecLoading_InboxOnly = AppPolicyMediaFoundationCodecLoading.InboxOnly;

pub const AppPolicyClrCompat = enum(i32) {
    Other = 0,
    ClassicDesktop = 1,
    Universal = 2,
    PackagedDesktop = 3,
};
pub const AppPolicyClrCompat_Other = AppPolicyClrCompat.Other;
pub const AppPolicyClrCompat_ClassicDesktop = AppPolicyClrCompat.ClassicDesktop;
pub const AppPolicyClrCompat_Universal = AppPolicyClrCompat.Universal;
pub const AppPolicyClrCompat_PackagedDesktop = AppPolicyClrCompat.PackagedDesktop;

pub const AppPolicyThreadInitializationType = enum(i32) {
    None = 0,
    InitializeWinRT = 1,
};
pub const AppPolicyThreadInitializationType_None = AppPolicyThreadInitializationType.None;
pub const AppPolicyThreadInitializationType_InitializeWinRT = AppPolicyThreadInitializationType.InitializeWinRT;

pub const AppPolicyShowDeveloperDiagnostic = enum(i32) {
    None = 0,
    ShowUI = 1,
};
pub const AppPolicyShowDeveloperDiagnostic_None = AppPolicyShowDeveloperDiagnostic.None;
pub const AppPolicyShowDeveloperDiagnostic_ShowUI = AppPolicyShowDeveloperDiagnostic.ShowUI;

pub const AppPolicyProcessTerminationMethod = enum(i32) {
    ExitProcess = 0,
    TerminateProcess = 1,
};
pub const AppPolicyProcessTerminationMethod_ExitProcess = AppPolicyProcessTerminationMethod.ExitProcess;
pub const AppPolicyProcessTerminationMethod_TerminateProcess = AppPolicyProcessTerminationMethod.TerminateProcess;

pub const AppPolicyCreateFileAccess = enum(i32) {
    Full = 0,
    Limited = 1,
};
pub const AppPolicyCreateFileAccess_Full = AppPolicyCreateFileAccess.Full;
pub const AppPolicyCreateFileAccess_Limited = AppPolicyCreateFileAccess.Limited;

pub const PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__ = extern struct {
    unused: i32,
};

//--------------------------------------------------------------------------------
// Section: Functions (63)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetCurrentPackageId(
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetCurrentPackageFullName(
    package_full_name_length: ?*u32,
    package_full_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetCurrentPackageFamilyName(
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetCurrentPackagePath(
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackageId(
    h_process: ?HANDLE,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackageFullName(
    h_process: ?HANDLE,
    package_full_name_length: ?*u32,
    package_full_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetPackageFullNameFromToken(
    token: ?HANDLE,
    package_full_name_length: ?*u32,
    package_full_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackageFamilyName(
    h_process: ?HANDLE,
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetPackageFamilyNameFromToken(
    token: ?HANDLE,
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackagePath(
    package_id: ?*const PACKAGE_ID,
    reserved: u32,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn GetPackagePathByFullName(
    package_full_name: ?[*:0]const u16,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn GetStagedPackagePathByFullName(
    package_full_name: ?[*:0]const u16,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetPackagePathByFullName2(
    package_full_name: ?[*:0]const u16,
    package_path_type: PackagePathType,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetStagedPackagePathByFullName2(
    package_full_name: ?[*:0]const u16,
    package_path_type: PackagePathType,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetCurrentPackageInfo2(
    flags: u32,
    package_path_type: PackagePathType,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetCurrentPackagePath2(
    package_path_type: PackagePathType,
    path_length: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn GetCurrentApplicationUserModelId(
    application_user_model_id_length: ?*u32,
    application_user_model_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn GetApplicationUserModelId(
    h_process: ?HANDLE,
    application_user_model_id_length: ?*u32,
    application_user_model_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetApplicationUserModelIdFromToken(
    token: ?HANDLE,
    application_user_model_id_length: ?*u32,
    application_user_model_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageFullName(
    package_full_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageFamilyName(
    package_family_name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageId(
    package_id: ?*const PACKAGE_ID,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyApplicationUserModelId(
    application_user_model_id: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageRelativeApplicationId(
    package_relative_application_id: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn PackageIdFromFullName(
    package_full_name: ?[*:0]const u16,
    flags: u32,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn PackageFullNameFromId(
    package_id: ?*const PACKAGE_ID,
    package_full_name_length: ?*u32,
    package_full_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn PackageFamilyNameFromId(
    package_id: ?*const PACKAGE_ID,
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn PackageFamilyNameFromFullName(
    package_full_name: ?[*:0]const u16,
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn PackageNameAndPublisherIdFromFamilyName(
    package_family_name: ?[*:0]const u16,
    package_name_length: ?*u32,
    package_name: ?[*:0]u16,
    package_publisher_id_length: ?*u32,
    package_publisher_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn FormatApplicationUserModelId(
    package_family_name: ?[*:0]const u16,
    package_relative_application_id: ?[*:0]const u16,
    application_user_model_id_length: ?*u32,
    application_user_model_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn ParseApplicationUserModelId(
    application_user_model_id: ?[*:0]const u16,
    package_family_name_length: ?*u32,
    package_family_name: ?[*:0]u16,
    package_relative_application_id_length: ?*u32,
    package_relative_application_id: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackagesByPackageFamily(
    package_family_name: ?[*:0]const u16,
    count: ?*u32,
    package_full_names: ?[*]?PWSTR,
    buffer_length: ?*u32,
    buffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn FindPackagesByPackageFamily(
    package_family_name: ?[*:0]const u16,
    package_filters: u32,
    count: ?*u32,
    package_full_names: ?[*]?PWSTR,
    buffer_length: ?*u32,
    buffer: ?[*:0]u16,
    package_properties: ?[*]u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetStagedPackageOrigin(
    package_full_name: ?[*:0]const u16,
    origin: ?*PackageOrigin,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetCurrentPackageInfo(
    flags: u32,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn OpenPackageInfoByFullName(
    package_full_name: ?[*:0]const u16,
    reserved: u32,
    package_info_reference: ?*?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn OpenPackageInfoByFullNameForUser(
    user_sid: ?PSID,
    package_full_name: ?[*:0]const u16,
    reserved: u32,
    package_info_reference: ?*?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn ClosePackageInfo(
    package_info_reference: ?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetPackageInfo(
    package_info_reference: ?*_PACKAGE_INFO_REFERENCE,
    flags: u32,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "kernel32" fn GetPackageApplicationIds(
    package_info_reference: ?*_PACKAGE_INFO_REFERENCE,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetPackageInfo2(
    package_info_reference: ?*_PACKAGE_INFO_REFERENCE,
    flags: u32,
    package_path_type: PackagePathType,
    buffer_length: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn CheckIsMSIXPackage(
    package_full_name: ?[*:0]const u16,
    is_m_s_i_x_package: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn TryCreatePackageDependency(
    user: ?PSID,
    package_family_name: ?[*:0]const u16,
    min_version: PACKAGE_VERSION,
    package_dependency_processor_architectures: PackageDependencyProcessorArchitectures,
    lifetime_kind: PackageDependencyLifetimeKind,
    lifetime_artifact: ?[*:0]const u16,
    options: CreatePackageDependencyOptions,
    package_dependency_id: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn DeletePackageDependency(
    package_dependency_id: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn AddPackageDependency(
    package_dependency_id: ?[*:0]const u16,
    rank: i32,
    options: AddPackageDependencyOptions,
    package_dependency_context: ?*?*PACKAGEDEPENDENCY_CONTEXT__,
    package_full_name: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn RemovePackageDependency(
    package_dependency_context: ?*PACKAGEDEPENDENCY_CONTEXT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn GetResolvedPackageFullNameForPackageDependency(
    package_dependency_id: ?[*:0]const u16,
    package_full_name: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernelbase" fn GetIdForPackageDependencyContext(
    package_dependency_context: ?*PACKAGEDEPENDENCY_CONTEXT__,
    package_dependency_id: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn AppPolicyGetLifecycleManagement(
    process_token: ?HANDLE,
    policy: ?*AppPolicyLifecycleManagement,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetWindowingModel(
    process_token: ?HANDLE,
    policy: ?*AppPolicyWindowingModel,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetMediaFoundationCodecLoading(
    process_token: ?HANDLE,
    policy: ?*AppPolicyMediaFoundationCodecLoading,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetClrCompat(
    process_token: ?HANDLE,
    policy: ?*AppPolicyClrCompat,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetThreadInitializationType(
    process_token: ?HANDLE,
    policy: ?*AppPolicyThreadInitializationType,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetShowDeveloperDiagnostic(
    process_token: ?HANDLE,
    policy: ?*AppPolicyShowDeveloperDiagnostic,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetProcessTerminationMethod(
    process_token: ?HANDLE,
    policy: ?*AppPolicyProcessTerminationMethod,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn AppPolicyGetCreateFileAccess(
    process_token: ?HANDLE,
    policy: ?*AppPolicyCreateFileAccess,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

pub extern "kernel32" fn CreatePackageVirtualizationContext(
    package_family_name: ?[*:0]const u16,
    context: ?*?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn ActivatePackageVirtualizationContext(
    context: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
    cookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn ReleasePackageVirtualizationContext(
    context: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn DeactivatePackageVirtualizationContext(
    cookie: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn DuplicatePackageVirtualizationContext(
    source_context: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
    dest_context: ?*?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn GetCurrentPackageVirtualizationContext() callconv(@import("std").os.windows.WINAPI) ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__;

pub extern "kernel32" fn GetProcessesInVirtualizationContext(
    package_family_name: ?[*:0]const u16,
    count: ?*u32,
    processes: ?*?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const IUri = @import("../../system/com.zig").IUri;
const PSID = @import("../../foundation.zig").PSID;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WIN32_ERROR = @import("../../foundation.zig").WIN32_ERROR;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
