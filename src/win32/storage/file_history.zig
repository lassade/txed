//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (42)
//--------------------------------------------------------------------------------
pub const FHCFG_E_CORRUPT_CONFIG_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220736));
pub const FHCFG_E_CONFIG_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220735));
pub const FHCFG_E_CONFIG_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220734));
pub const FHCFG_E_NO_VALID_CONFIGURATION_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220733));
pub const FHCFG_E_TARGET_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220732));
pub const FHCFG_E_CONFIGURATION_PREVIOUSLY_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220731));
pub const FHCFG_E_TARGET_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220730));
pub const FHCFG_E_TARGET_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220729));
pub const FHCFG_E_TARGET_NOT_ENOUGH_FREE_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220728));
pub const FHCFG_E_TARGET_CANNOT_BE_USED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220727));
pub const FHCFG_E_INVALID_REHYDRATION_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220726));
pub const FHCFG_E_RECOMMENDATION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220720));
pub const FHCFG_E_TARGET_REHYDRATED_ELSEWHERE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220719));
pub const FHCFG_E_LEGACY_TARGET_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220718));
pub const FHCFG_E_LEGACY_TARGET_VALIDATION_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220717));
pub const FHCFG_E_LEGACY_BACKUP_USER_EXCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220716));
pub const FHCFG_E_LEGACY_BACKUP_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220715));
pub const FHSVC_E_BACKUP_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219968));
pub const FHSVC_E_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219967));
pub const FHSVC_E_CONFIG_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219966));
pub const FHSVC_E_CONFIG_DISABLED_GP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219965));
pub const FHSVC_E_FATAL_CONFIG_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219964));
pub const FHSVC_E_CONFIG_REHYDRATING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219963));
pub const FH_STATE_NOT_TRACKED = @as(u32, 0);
pub const FH_STATE_OFF = @as(u32, 1);
pub const FH_STATE_DISABLED_BY_GP = @as(u32, 2);
pub const FH_STATE_FATAL_CONFIG_ERROR = @as(u32, 3);
pub const FH_STATE_MIGRATING = @as(u32, 4);
pub const FH_STATE_REHYDRATING = @as(u32, 5);
pub const FH_STATE_TARGET_FS_LIMITATION = @as(u32, 13);
pub const FH_STATE_TARGET_ACCESS_DENIED = @as(u32, 14);
pub const FH_STATE_TARGET_VOLUME_DIRTY = @as(u32, 15);
pub const FH_STATE_TARGET_FULL_RETENTION_MAX = @as(u32, 16);
pub const FH_STATE_TARGET_FULL = @as(u32, 17);
pub const FH_STATE_STAGING_FULL = @as(u32, 18);
pub const FH_STATE_TARGET_LOW_SPACE_RETENTION_MAX = @as(u32, 19);
pub const FH_STATE_TARGET_LOW_SPACE = @as(u32, 20);
pub const FH_STATE_TARGET_ABSENT = @as(u32, 21);
pub const FH_STATE_TOO_MUCH_BEHIND = @as(u32, 240);
pub const FH_STATE_NO_ERROR = @as(u32, 255);
pub const FH_STATE_BACKUP_NOT_SUPPORTED = @as(u32, 2064);
pub const FH_STATE_RUNNING = @as(u32, 256);

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
const CLSID_FhConfigMgr_Value = Guid.initString("ed43bb3c-09e9-498a-9df6-2177244c6db4");
pub const CLSID_FhConfigMgr = &CLSID_FhConfigMgr_Value;

const CLSID_FhReassociation_Value = Guid.initString("4d728e35-16fa-4320-9e8b-bfd7100a8846");
pub const CLSID_FhReassociation = &CLSID_FhReassociation_Value;

pub const FH_TARGET_PROPERTY_TYPE = enum(i32) {
    FH_TARGET_NAME = 0,
    FH_TARGET_URL = 1,
    FH_TARGET_DRIVE_TYPE = 2,
    MAX_TARGET_PROPERTY = 3,
};
pub const FH_TARGET_NAME = FH_TARGET_PROPERTY_TYPE.FH_TARGET_NAME;
pub const FH_TARGET_URL = FH_TARGET_PROPERTY_TYPE.FH_TARGET_URL;
pub const FH_TARGET_DRIVE_TYPE = FH_TARGET_PROPERTY_TYPE.FH_TARGET_DRIVE_TYPE;
pub const MAX_TARGET_PROPERTY = FH_TARGET_PROPERTY_TYPE.MAX_TARGET_PROPERTY;

pub const FH_TARGET_DRIVE_TYPES = enum(i32) {
    UNKNOWN = 0,
    REMOVABLE = 2,
    FIXED = 3,
    REMOTE = 4,
};
pub const FH_DRIVE_UNKNOWN = FH_TARGET_DRIVE_TYPES.UNKNOWN;
pub const FH_DRIVE_REMOVABLE = FH_TARGET_DRIVE_TYPES.REMOVABLE;
pub const FH_DRIVE_FIXED = FH_TARGET_DRIVE_TYPES.FIXED;
pub const FH_DRIVE_REMOTE = FH_TARGET_DRIVE_TYPES.REMOTE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhTarget_Value = Guid.initString("d87965fd-2bad-4657-bd3b-9567eb300ced");
pub const IID_IFhTarget = &IID_IFhTarget_Value;
pub const IFhTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringProperty: *const fn (
            self: *const IFhTarget,
            property_type: FH_TARGET_PROPERTY_TYPE,
            property_value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumericalProperty: *const fn (
            self: *const IFhTarget,
            property_type: FH_TARGET_PROPERTY_TYPE,
            property_value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getStringProperty(self: *const T, property_type_: FH_TARGET_PROPERTY_TYPE, property_value_: ?*?BSTR) HRESULT {
                return @as(*const IFhTarget.VTable, @ptrCast(self.vtable)).GetStringProperty(@as(*const IFhTarget, @ptrCast(self)), property_type_, property_value_);
            }
            pub inline fn getNumericalProperty(self: *const T, property_type_: FH_TARGET_PROPERTY_TYPE, property_value_: ?*u64) HRESULT {
                return @as(*const IFhTarget.VTable, @ptrCast(self.vtable)).GetNumericalProperty(@as(*const IFhTarget, @ptrCast(self)), property_type_, property_value_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhScopeIterator_Value = Guid.initString("3197abce-532a-44c6-8615-f3666566a720");
pub const IID_IFhScopeIterator = &IID_IFhScopeIterator_Value;
pub const IFhScopeIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToNextItem: *const fn (
            self: *const IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: *const fn (
            self: *const IFhScopeIterator,
            item: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn moveToNextItem(self: *const T) HRESULT {
                return @as(*const IFhScopeIterator.VTable, @ptrCast(self.vtable)).MoveToNextItem(@as(*const IFhScopeIterator, @ptrCast(self)));
            }
            pub inline fn getItem(self: *const T, item_: ?*?BSTR) HRESULT {
                return @as(*const IFhScopeIterator.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IFhScopeIterator, @ptrCast(self)), item_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FH_PROTECTED_ITEM_CATEGORY = enum(i32) {
    FH_FOLDER = 0,
    FH_LIBRARY = 1,
    MAX_PROTECTED_ITEM_CATEGORY = 2,
};
pub const FH_FOLDER = FH_PROTECTED_ITEM_CATEGORY.FH_FOLDER;
pub const FH_LIBRARY = FH_PROTECTED_ITEM_CATEGORY.FH_LIBRARY;
pub const MAX_PROTECTED_ITEM_CATEGORY = FH_PROTECTED_ITEM_CATEGORY.MAX_PROTECTED_ITEM_CATEGORY;

pub const FH_LOCAL_POLICY_TYPE = enum(i32) {
    FH_FREQUENCY = 0,
    FH_RETENTION_TYPE = 1,
    FH_RETENTION_AGE = 2,
    MAX_LOCAL_POLICY = 3,
};
pub const FH_FREQUENCY = FH_LOCAL_POLICY_TYPE.FH_FREQUENCY;
pub const FH_RETENTION_TYPE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_TYPE;
pub const FH_RETENTION_AGE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_AGE;
pub const MAX_LOCAL_POLICY = FH_LOCAL_POLICY_TYPE.MAX_LOCAL_POLICY;

pub const FH_RETENTION_TYPES = enum(i32) {
    FH_RETENTION_DISABLED = 0,
    FH_RETENTION_UNLIMITED = 1,
    FH_RETENTION_AGE_BASED = 2,
    MAX_RETENTION_TYPE = 3,
};
pub const FH_RETENTION_DISABLED = FH_RETENTION_TYPES.FH_RETENTION_DISABLED;
pub const FH_RETENTION_UNLIMITED = FH_RETENTION_TYPES.FH_RETENTION_UNLIMITED;
pub const FH_RETENTION_AGE_BASED = FH_RETENTION_TYPES.FH_RETENTION_AGE_BASED;
pub const MAX_RETENTION_TYPE = FH_RETENTION_TYPES.MAX_RETENTION_TYPE;

pub const FH_BACKUP_STATUS = enum(i32) {
    FH_STATUS_DISABLED = 0,
    FH_STATUS_DISABLED_BY_GP = 1,
    FH_STATUS_ENABLED = 2,
    FH_STATUS_REHYDRATING = 3,
    MAX_BACKUP_STATUS = 4,
};
pub const FH_STATUS_DISABLED = FH_BACKUP_STATUS.FH_STATUS_DISABLED;
pub const FH_STATUS_DISABLED_BY_GP = FH_BACKUP_STATUS.FH_STATUS_DISABLED_BY_GP;
pub const FH_STATUS_ENABLED = FH_BACKUP_STATUS.FH_STATUS_ENABLED;
pub const FH_STATUS_REHYDRATING = FH_BACKUP_STATUS.FH_STATUS_REHYDRATING;
pub const MAX_BACKUP_STATUS = FH_BACKUP_STATUS.MAX_BACKUP_STATUS;

pub const FH_DEVICE_VALIDATION_RESULT = enum(i32) {
    FH_ACCESS_DENIED = 0,
    FH_INVALID_DRIVE_TYPE = 1,
    FH_READ_ONLY_PERMISSION = 2,
    FH_CURRENT_DEFAULT = 3,
    FH_NAMESPACE_EXISTS = 4,
    FH_TARGET_PART_OF_LIBRARY = 5,
    FH_VALID_TARGET = 6,
    MAX_VALIDATION_RESULT = 7,
};
pub const FH_ACCESS_DENIED = FH_DEVICE_VALIDATION_RESULT.FH_ACCESS_DENIED;
pub const FH_INVALID_DRIVE_TYPE = FH_DEVICE_VALIDATION_RESULT.FH_INVALID_DRIVE_TYPE;
pub const FH_READ_ONLY_PERMISSION = FH_DEVICE_VALIDATION_RESULT.FH_READ_ONLY_PERMISSION;
pub const FH_CURRENT_DEFAULT = FH_DEVICE_VALIDATION_RESULT.FH_CURRENT_DEFAULT;
pub const FH_NAMESPACE_EXISTS = FH_DEVICE_VALIDATION_RESULT.FH_NAMESPACE_EXISTS;
pub const FH_TARGET_PART_OF_LIBRARY = FH_DEVICE_VALIDATION_RESULT.FH_TARGET_PART_OF_LIBRARY;
pub const FH_VALID_TARGET = FH_DEVICE_VALIDATION_RESULT.FH_VALID_TARGET;
pub const MAX_VALIDATION_RESULT = FH_DEVICE_VALIDATION_RESULT.MAX_VALIDATION_RESULT;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhConfigMgr_Value = Guid.initString("6a5fea5b-bf8f-4ee5-b8c3-44d8a0d7331c");
pub const IID_IFhConfigMgr = &IID_IFhConfigMgr_Value;
pub const IFhConfigMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadConfiguration: *const fn (
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDefaultConfiguration: *const fn (
            self: *const IFhConfigMgr,
            overwrite_if_exists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveConfiguration: *const fn (
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRemoveExcludeRule: *const fn (
            self: *const IFhConfigMgr,
            add: BOOL,
            category: FH_PROTECTED_ITEM_CATEGORY,
            item: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIncludeExcludeRules: *const fn (
            self: *const IFhConfigMgr,
            include: BOOL,
            category: FH_PROTECTED_ITEM_CATEGORY,
            iterator: ?*?*IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalPolicy: *const fn (
            self: *const IFhConfigMgr,
            local_policy_type: FH_LOCAL_POLICY_TYPE,
            policy_value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocalPolicy: *const fn (
            self: *const IFhConfigMgr,
            local_policy_type: FH_LOCAL_POLICY_TYPE,
            policy_value: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStatus: *const fn (
            self: *const IFhConfigMgr,
            backup_status: ?*FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStatus: *const fn (
            self: *const IFhConfigMgr,
            backup_status: FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTarget: *const fn (
            self: *const IFhConfigMgr,
            default_target: ?*?*IFhTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateTarget: *const fn (
            self: *const IFhConfigMgr,
            target_url: ?BSTR,
            validation_result: ?*FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProvisionAndSetNewTarget: *const fn (
            self: *const IFhConfigMgr,
            target_url: ?BSTR,
            target_name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDefaultTargetRecommendation: *const fn (
            self: *const IFhConfigMgr,
            recommend: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProtectionStatus: *const fn (
            self: *const IFhConfigMgr,
            protection_state: ?*u32,
            protected_until_time: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn loadConfiguration(self: *const T) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).LoadConfiguration(@as(*const IFhConfigMgr, @ptrCast(self)));
            }
            pub inline fn createDefaultConfiguration(self: *const T, overwrite_if_exists_: BOOL) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).CreateDefaultConfiguration(@as(*const IFhConfigMgr, @ptrCast(self)), overwrite_if_exists_);
            }
            pub inline fn saveConfiguration(self: *const T) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).SaveConfiguration(@as(*const IFhConfigMgr, @ptrCast(self)));
            }
            pub inline fn addRemoveExcludeRule(self: *const T, add_: BOOL, category_: FH_PROTECTED_ITEM_CATEGORY, item_: ?BSTR) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).AddRemoveExcludeRule(@as(*const IFhConfigMgr, @ptrCast(self)), add_, category_, item_);
            }
            pub inline fn getIncludeExcludeRules(self: *const T, include_: BOOL, category_: FH_PROTECTED_ITEM_CATEGORY, iterator_: ?*?*IFhScopeIterator) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).GetIncludeExcludeRules(@as(*const IFhConfigMgr, @ptrCast(self)), include_, category_, iterator_);
            }
            pub inline fn getLocalPolicy(self: *const T, local_policy_type_: FH_LOCAL_POLICY_TYPE, policy_value_: ?*u64) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).GetLocalPolicy(@as(*const IFhConfigMgr, @ptrCast(self)), local_policy_type_, policy_value_);
            }
            pub inline fn setLocalPolicy(self: *const T, local_policy_type_: FH_LOCAL_POLICY_TYPE, policy_value_: u64) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).SetLocalPolicy(@as(*const IFhConfigMgr, @ptrCast(self)), local_policy_type_, policy_value_);
            }
            pub inline fn getBackupStatus(self: *const T, backup_status_: ?*FH_BACKUP_STATUS) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).GetBackupStatus(@as(*const IFhConfigMgr, @ptrCast(self)), backup_status_);
            }
            pub inline fn setBackupStatus(self: *const T, backup_status_: FH_BACKUP_STATUS) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).SetBackupStatus(@as(*const IFhConfigMgr, @ptrCast(self)), backup_status_);
            }
            pub inline fn getDefaultTarget(self: *const T, default_target_: ?*?*IFhTarget) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).GetDefaultTarget(@as(*const IFhConfigMgr, @ptrCast(self)), default_target_);
            }
            pub inline fn validateTarget(self: *const T, target_url_: ?BSTR, validation_result_: ?*FH_DEVICE_VALIDATION_RESULT) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).ValidateTarget(@as(*const IFhConfigMgr, @ptrCast(self)), target_url_, validation_result_);
            }
            pub inline fn provisionAndSetNewTarget(self: *const T, target_url_: ?BSTR, target_name_: ?BSTR) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).ProvisionAndSetNewTarget(@as(*const IFhConfigMgr, @ptrCast(self)), target_url_, target_name_);
            }
            pub inline fn changeDefaultTargetRecommendation(self: *const T, recommend_: BOOL) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).ChangeDefaultTargetRecommendation(@as(*const IFhConfigMgr, @ptrCast(self)), recommend_);
            }
            pub inline fn queryProtectionStatus(self: *const T, protection_state_: ?*u32, protected_until_time_: ?*?BSTR) HRESULT {
                return @as(*const IFhConfigMgr.VTable, @ptrCast(self.vtable)).QueryProtectionStatus(@as(*const IFhConfigMgr, @ptrCast(self)), protection_state_, protected_until_time_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhReassociation_Value = Guid.initString("6544a28a-f68d-47ac-91ef-16b2b36aa3ee");
pub const IID_IFhReassociation = &IID_IFhReassociation_Value;
pub const IFhReassociation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateTarget: *const fn (
            self: *const IFhReassociation,
            target_url: ?BSTR,
            validation_result: ?*FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanTargetForConfigurations: *const fn (
            self: *const IFhReassociation,
            target_url: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigurationDetails: *const fn (
            self: *const IFhReassociation,
            index: u32,
            user_name: ?*?BSTR,
            pc_name: ?*?BSTR,
            backup_time: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectConfiguration: *const fn (
            self: *const IFhReassociation,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformReassociation: *const fn (
            self: *const IFhReassociation,
            overwrite_if_exists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn validateTarget(self: *const T, target_url_: ?BSTR, validation_result_: ?*FH_DEVICE_VALIDATION_RESULT) HRESULT {
                return @as(*const IFhReassociation.VTable, @ptrCast(self.vtable)).ValidateTarget(@as(*const IFhReassociation, @ptrCast(self)), target_url_, validation_result_);
            }
            pub inline fn scanTargetForConfigurations(self: *const T, target_url_: ?BSTR) HRESULT {
                return @as(*const IFhReassociation.VTable, @ptrCast(self.vtable)).ScanTargetForConfigurations(@as(*const IFhReassociation, @ptrCast(self)), target_url_);
            }
            pub inline fn getConfigurationDetails(self: *const T, index_: u32, user_name_: ?*?BSTR, pc_name_: ?*?BSTR, backup_time_: ?*FILETIME) HRESULT {
                return @as(*const IFhReassociation.VTable, @ptrCast(self.vtable)).GetConfigurationDetails(@as(*const IFhReassociation, @ptrCast(self)), index_, user_name_, pc_name_, backup_time_);
            }
            pub inline fn selectConfiguration(self: *const T, index_: u32) HRESULT {
                return @as(*const IFhReassociation.VTable, @ptrCast(self.vtable)).SelectConfiguration(@as(*const IFhReassociation, @ptrCast(self)), index_);
            }
            pub inline fn performReassociation(self: *const T, overwrite_if_exists_: BOOL) HRESULT {
                return @as(*const IFhReassociation.VTable, @ptrCast(self.vtable)).PerformReassociation(@as(*const IFhReassociation, @ptrCast(self)), overwrite_if_exists_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FhBackupStopReason = enum(i32) {
    InvalidStopReason = 0,
    LimitUserBusyMachineOnAC = 1,
    LimitUserIdleMachineOnDC = 2,
    LimitUserBusyMachineOnDC = 3,
    Cancelled = 4,
};
pub const BackupInvalidStopReason = FhBackupStopReason.InvalidStopReason;
pub const BackupLimitUserBusyMachineOnAC = FhBackupStopReason.LimitUserBusyMachineOnAC;
pub const BackupLimitUserIdleMachineOnDC = FhBackupStopReason.LimitUserIdleMachineOnDC;
pub const BackupLimitUserBusyMachineOnDC = FhBackupStopReason.LimitUserBusyMachineOnDC;
pub const BackupCancelled = FhBackupStopReason.Cancelled;

//--------------------------------------------------------------------------------
// Section: Functions (7)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceOpenPipe(
    start_service_if_stopped: BOOL,
    pipe: ?*FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceClosePipe(
    pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStartBackup(
    pipe: FH_SERVICE_PIPE_HANDLE,
    low_priority_io: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStopBackup(
    pipe: FH_SERVICE_PIPE_HANDLE,
    stop_tracking: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceReloadConfiguration(
    pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceBlockBackup(
    pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceUnblockBackup(
    pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FH_SERVICE_PIPE_HANDLE = @import("../system/windows_programming.zig").FH_SERVICE_PIPE_HANDLE;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
