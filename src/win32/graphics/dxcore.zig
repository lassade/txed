//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const _FACDXCORE = @as(u32, 2176);
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D11_GRAPHICS = Guid.initString("8c47866b-7583-450d-f0f0-6bada895af4b");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS = Guid.initString("0c9ece4d-2f6e-4f01-8c96-e89e331b47b1");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_CORE_COMPUTE = Guid.initString("248e2800-a793-4724-abaa-23a6de1be090");

//--------------------------------------------------------------------------------
// Section: Types (13)
//--------------------------------------------------------------------------------
pub const DXCoreAdapterProperty = enum(u32) {
    InstanceLuid = 0,
    DriverVersion = 1,
    DriverDescription = 2,
    HardwareID = 3,
    KmdModelVersion = 4,
    ComputePreemptionGranularity = 5,
    GraphicsPreemptionGranularity = 6,
    DedicatedAdapterMemory = 7,
    DedicatedSystemMemory = 8,
    SharedSystemMemory = 9,
    AcgCompatible = 10,
    IsHardware = 11,
    IsIntegrated = 12,
    IsDetachable = 13,
    HardwareIDParts = 14,
};
pub const InstanceLuid = DXCoreAdapterProperty.InstanceLuid;
pub const DriverVersion = DXCoreAdapterProperty.DriverVersion;
pub const DriverDescription = DXCoreAdapterProperty.DriverDescription;
pub const HardwareID = DXCoreAdapterProperty.HardwareID;
pub const KmdModelVersion = DXCoreAdapterProperty.KmdModelVersion;
pub const ComputePreemptionGranularity = DXCoreAdapterProperty.ComputePreemptionGranularity;
pub const GraphicsPreemptionGranularity = DXCoreAdapterProperty.GraphicsPreemptionGranularity;
pub const DedicatedAdapterMemory = DXCoreAdapterProperty.DedicatedAdapterMemory;
pub const DedicatedSystemMemory = DXCoreAdapterProperty.DedicatedSystemMemory;
pub const SharedSystemMemory = DXCoreAdapterProperty.SharedSystemMemory;
pub const AcgCompatible = DXCoreAdapterProperty.AcgCompatible;
pub const IsHardware = DXCoreAdapterProperty.IsHardware;
pub const IsIntegrated = DXCoreAdapterProperty.IsIntegrated;
pub const IsDetachable = DXCoreAdapterProperty.IsDetachable;
pub const HardwareIDParts = DXCoreAdapterProperty.HardwareIDParts;

pub const DXCoreAdapterState = enum(u32) {
    IsDriverUpdateInProgress = 0,
    AdapterMemoryBudget = 1,
};
pub const IsDriverUpdateInProgress = DXCoreAdapterState.IsDriverUpdateInProgress;
pub const AdapterMemoryBudget = DXCoreAdapterState.AdapterMemoryBudget;

pub const DXCoreSegmentGroup = enum(u32) {
    Local = 0,
    NonLocal = 1,
};
pub const Local = DXCoreSegmentGroup.Local;
pub const NonLocal = DXCoreSegmentGroup.NonLocal;

pub const DXCoreNotificationType = enum(u32) {
    ListStale = 0,
    NoLongerValid = 1,
    BudgetChange = 2,
    HardwareContentProtectionTeardown = 3,
};
pub const AdapterListStale = DXCoreNotificationType.ListStale;
pub const AdapterNoLongerValid = DXCoreNotificationType.NoLongerValid;
pub const AdapterBudgetChange = DXCoreNotificationType.BudgetChange;
pub const AdapterHardwareContentProtectionTeardown = DXCoreNotificationType.HardwareContentProtectionTeardown;

pub const DXCoreAdapterPreference = enum(u32) {
    Hardware = 0,
    MinimumPower = 1,
    HighPerformance = 2,
};
pub const Hardware = DXCoreAdapterPreference.Hardware;
pub const MinimumPower = DXCoreAdapterPreference.MinimumPower;
pub const HighPerformance = DXCoreAdapterPreference.HighPerformance;

pub const DXCoreHardwareID = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSysID: u32,
    revision: u32,
};

pub const DXCoreHardwareIDParts = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSystemID: u32,
    subVendorID: u32,
    revisionID: u32,
};

pub const DXCoreAdapterMemoryBudgetNodeSegmentGroup = extern struct {
    nodeIndex: u32,
    segmentGroup: DXCoreSegmentGroup,
};

pub const DXCoreAdapterMemoryBudget = extern struct {
    budget: u64,
    currentUsage: u64,
    availableForReservation: u64,
    currentReservation: u64,
};

pub const PFN_DXCORE_NOTIFICATION_CALLBACK = *const fn (
    notification_type: DXCoreNotificationType,
    object: ?*IUnknown,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const IID_IDXCoreAdapter_Value = Guid.initString("f0db4c7f-fe5a-42a2-bd62-f2a6cf6fc83e");
pub const IID_IDXCoreAdapter = &IID_IDXCoreAdapter_Value;
pub const IDXCoreAdapter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsValid: *const fn (
            self: *const IDXCoreAdapter,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsAttributeSupported: *const fn (
            self: *const IDXCoreAdapter,
            attribute_g_u_i_d: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsPropertySupported: *const fn (
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetProperty: *const fn (
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            buffer_size: usize,
            // TODO: what to do with BytesParamIndex 1?
            property_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertySize: *const fn (
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            buffer_size: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsQueryStateSupported: *const fn (
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        QueryState: *const fn (
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            input_state_details_size: usize,
            // TODO: what to do with BytesParamIndex 1?
            input_state_details: ?*const anyopaque,
            output_buffer_size: usize,
            // TODO: what to do with BytesParamIndex 3?
            output_buffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSetStateSupported: *const fn (
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        SetState: *const fn (
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            input_state_details_size: usize,
            // TODO: what to do with BytesParamIndex 1?
            input_state_details: ?*const anyopaque,
            input_data_size: usize,
            // TODO: what to do with BytesParamIndex 3?
            input_data: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFactory: *const fn (
            self: *const IDXCoreAdapter,
            riid: ?*const Guid,
            ppv_factory: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isValid(self: *const T) bool {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).IsValid(@as(*const IDXCoreAdapter, @ptrCast(self)));
            }
            pub inline fn isAttributeSupported(self: *const T, attribute_g_u_i_d_: ?*const Guid) bool {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).IsAttributeSupported(@as(*const IDXCoreAdapter, @ptrCast(self)), attribute_g_u_i_d_);
            }
            pub inline fn isPropertySupported(self: *const T, property_: DXCoreAdapterProperty) bool {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).IsPropertySupported(@as(*const IDXCoreAdapter, @ptrCast(self)), property_);
            }
            pub inline fn getProperty(self: *const T, property_: DXCoreAdapterProperty, buffer_size_: usize, property_data_: ?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IDXCoreAdapter, @ptrCast(self)), property_, buffer_size_, property_data_);
            }
            pub inline fn getPropertySize(self: *const T, property_: DXCoreAdapterProperty, buffer_size_: ?*usize) HRESULT {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).GetPropertySize(@as(*const IDXCoreAdapter, @ptrCast(self)), property_, buffer_size_);
            }
            pub inline fn isQueryStateSupported(self: *const T, property_: DXCoreAdapterState) bool {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).IsQueryStateSupported(@as(*const IDXCoreAdapter, @ptrCast(self)), property_);
            }
            pub inline fn queryState(self: *const T, state_: DXCoreAdapterState, input_state_details_size_: usize, input_state_details_: ?*const anyopaque, output_buffer_size_: usize, output_buffer_: ?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).QueryState(@as(*const IDXCoreAdapter, @ptrCast(self)), state_, input_state_details_size_, input_state_details_, output_buffer_size_, output_buffer_);
            }
            pub inline fn isSetStateSupported(self: *const T, property_: DXCoreAdapterState) bool {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).IsSetStateSupported(@as(*const IDXCoreAdapter, @ptrCast(self)), property_);
            }
            pub inline fn setState(self: *const T, state_: DXCoreAdapterState, input_state_details_size_: usize, input_state_details_: ?*const anyopaque, input_data_size_: usize, input_data_: ?*const anyopaque) HRESULT {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).SetState(@as(*const IDXCoreAdapter, @ptrCast(self)), state_, input_state_details_size_, input_state_details_, input_data_size_, input_data_);
            }
            pub inline fn getFactory(self: *const T, riid_: ?*const Guid, ppv_factory_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapter.VTable, @ptrCast(self.vtable)).GetFactory(@as(*const IDXCoreAdapter, @ptrCast(self)), riid_, ppv_factory_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXCoreAdapterList_Value = Guid.initString("526c7776-40e9-459b-b711-f32ad76dfc28");
pub const IID_IDXCoreAdapterList = &IID_IDXCoreAdapterList_Value;
pub const IDXCoreAdapterList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdapter: *const fn (
            self: *const IDXCoreAdapterList,
            index: u32,
            riid: ?*const Guid,
            ppv_adapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterCount: *const fn (
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        IsStale: *const fn (
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetFactory: *const fn (
            self: *const IDXCoreAdapterList,
            riid: ?*const Guid,
            ppv_factory: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Sort: *const fn (
            self: *const IDXCoreAdapterList,
            num_preferences: u32,
            preferences: [*]const DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAdapterPreferenceSupported: *const fn (
            self: *const IDXCoreAdapterList,
            preference: DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) bool,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getAdapter(self: *const T, index_: u32, riid_: ?*const Guid, ppv_adapter_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).GetAdapter(@as(*const IDXCoreAdapterList, @ptrCast(self)), index_, riid_, ppv_adapter_);
            }
            pub inline fn getAdapterCount(self: *const T) u32 {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).GetAdapterCount(@as(*const IDXCoreAdapterList, @ptrCast(self)));
            }
            pub inline fn isStale(self: *const T) bool {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).IsStale(@as(*const IDXCoreAdapterList, @ptrCast(self)));
            }
            pub inline fn getFactory(self: *const T, riid_: ?*const Guid, ppv_factory_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).GetFactory(@as(*const IDXCoreAdapterList, @ptrCast(self)), riid_, ppv_factory_);
            }
            pub inline fn sort(self: *const T, num_preferences_: u32, preferences_: [*]const DXCoreAdapterPreference) HRESULT {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).Sort(@as(*const IDXCoreAdapterList, @ptrCast(self)), num_preferences_, preferences_);
            }
            pub inline fn isAdapterPreferenceSupported(self: *const T, preference_: DXCoreAdapterPreference) bool {
                return @as(*const IDXCoreAdapterList.VTable, @ptrCast(self.vtable)).IsAdapterPreferenceSupported(@as(*const IDXCoreAdapterList, @ptrCast(self)), preference_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXCoreAdapterFactory_Value = Guid.initString("78ee5945-c36e-4b13-a669-005dd11c0f06");
pub const IID_IDXCoreAdapterFactory = &IID_IDXCoreAdapterFactory_Value;
pub const IDXCoreAdapterFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateAdapterList: *const fn (
            self: *const IDXCoreAdapterFactory,
            num_attributes: u32,
            filter_attributes: [*]const Guid,
            riid: ?*const Guid,
            ppv_adapter_list: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterByLuid: *const fn (
            self: *const IDXCoreAdapterFactory,
            adapter_l_u_i_d: ?*const LUID,
            riid: ?*const Guid,
            ppv_adapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsNotificationTypeSupported: *const fn (
            self: *const IDXCoreAdapterFactory,
            notification_type: DXCoreNotificationType,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        RegisterEventNotification: *const fn (
            self: *const IDXCoreAdapterFactory,
            dx_core_object: ?*IUnknown,
            notification_type: DXCoreNotificationType,
            callback_function: ?PFN_DXCORE_NOTIFICATION_CALLBACK,
            callback_context: ?*anyopaque,
            event_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterEventNotification: *const fn (
            self: *const IDXCoreAdapterFactory,
            event_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createAdapterList(self: *const T, num_attributes_: u32, filter_attributes_: [*]const Guid, riid_: ?*const Guid, ppv_adapter_list_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapterFactory.VTable, @ptrCast(self.vtable)).CreateAdapterList(@as(*const IDXCoreAdapterFactory, @ptrCast(self)), num_attributes_, filter_attributes_, riid_, ppv_adapter_list_);
            }
            pub inline fn getAdapterByLuid(self: *const T, adapter_l_u_i_d_: ?*const LUID, riid_: ?*const Guid, ppv_adapter_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXCoreAdapterFactory.VTable, @ptrCast(self.vtable)).GetAdapterByLuid(@as(*const IDXCoreAdapterFactory, @ptrCast(self)), adapter_l_u_i_d_, riid_, ppv_adapter_);
            }
            pub inline fn isNotificationTypeSupported(self: *const T, notification_type_: DXCoreNotificationType) bool {
                return @as(*const IDXCoreAdapterFactory.VTable, @ptrCast(self.vtable)).IsNotificationTypeSupported(@as(*const IDXCoreAdapterFactory, @ptrCast(self)), notification_type_);
            }
            pub inline fn registerEventNotification(self: *const T, dx_core_object_: ?*IUnknown, notification_type_: DXCoreNotificationType, callback_function_: ?PFN_DXCORE_NOTIFICATION_CALLBACK, callback_context_: ?*anyopaque, event_cookie_: ?*u32) HRESULT {
                return @as(*const IDXCoreAdapterFactory.VTable, @ptrCast(self.vtable)).RegisterEventNotification(@as(*const IDXCoreAdapterFactory, @ptrCast(self)), dx_core_object_, notification_type_, callback_function_, callback_context_, event_cookie_);
            }
            pub inline fn unregisterEventNotification(self: *const T, event_cookie_: u32) HRESULT {
                return @as(*const IDXCoreAdapterFactory.VTable, @ptrCast(self.vtable)).UnregisterEventNotification(@as(*const IDXCoreAdapterFactory, @ptrCast(self)), event_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (1)
//--------------------------------------------------------------------------------
pub extern "dxcore" fn DXCoreCreateAdapterFactory(
    riid: ?*const Guid,
    ppv_factory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (4)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;
const LUID = @import("../foundation.zig").LUID;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_DXCORE_NOTIFICATION_CALLBACK")) {
        _ = PFN_DXCORE_NOTIFICATION_CALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
