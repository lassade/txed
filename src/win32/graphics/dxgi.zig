//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (70)
//--------------------------------------------------------------------------------
pub const DXGI_USAGE_SHADER_INPUT = @as(u32, 16);
pub const DXGI_USAGE_RENDER_TARGET_OUTPUT = @as(u32, 32);
pub const DXGI_USAGE_BACK_BUFFER = @as(u32, 64);
pub const DXGI_USAGE_SHARED = @as(u32, 128);
pub const DXGI_USAGE_READ_ONLY = @as(u32, 256);
pub const DXGI_USAGE_DISCARD_ON_PRESENT = @as(u32, 512);
pub const DXGI_USAGE_UNORDERED_ACCESS = @as(u32, 1024);
pub const DXGI_MAP_READ = @as(u32, 1);
pub const DXGI_MAP_WRITE = @as(u32, 2);
pub const DXGI_MAP_DISCARD = @as(u32, 4);
pub const DXGI_ENUM_MODES_INTERLACED = @as(u32, 1);
pub const DXGI_ENUM_MODES_SCALING = @as(u32, 2);
pub const DXGI_MAX_SWAP_CHAIN_BUFFERS = @as(u32, 16);
pub const DXGI_PRESENT_TEST = @as(u32, 1);
pub const DXGI_PRESENT_DO_NOT_SEQUENCE = @as(u32, 2);
pub const DXGI_PRESENT_RESTART = @as(u32, 4);
pub const DXGI_PRESENT_DO_NOT_WAIT = @as(u32, 8);
pub const DXGI_PRESENT_STEREO_PREFER_RIGHT = @as(u32, 16);
pub const DXGI_PRESENT_STEREO_TEMPORARY_MONO = @as(u32, 32);
pub const DXGI_PRESENT_RESTRICT_TO_OUTPUT = @as(u32, 64);
pub const DXGI_PRESENT_USE_DURATION = @as(u32, 256);
pub const DXGI_PRESENT_ALLOW_TEARING = @as(u32, 512);
pub const DXGI_MWA_NO_WINDOW_CHANGES = @as(u32, 1);
pub const DXGI_MWA_NO_ALT_ENTER = @as(u32, 2);
pub const DXGI_MWA_NO_PRINT_SCREEN = @as(u32, 4);
pub const DXGI_MWA_VALID = @as(u32, 7);
pub const DXGI_ENUM_MODES_STEREO = @as(u32, 4);
pub const DXGI_ENUM_MODES_DISABLED_STEREO = @as(u32, 8);
pub const DXGI_SHARED_RESOURCE_READ = @as(u32, 2147483648);
pub const DXGI_SHARED_RESOURCE_WRITE = @as(u32, 1);
pub const DXGI_DEBUG_BINARY_VERSION = @as(u32, 1);
pub const DXGI_DEBUG_ALL = Guid.initString("e48ae283-da80-490b-87e6-43e9a9cfda08");
pub const DXGI_DEBUG_DX = Guid.initString("35cdd7fc-13b2-421d-a5d7-7e4451287d64");
pub const DXGI_DEBUG_DXGI = Guid.initString("25cddaa4-b1c6-47e1-ac3e-98875b5a2e2a");
pub const DXGI_DEBUG_APP = Guid.initString("06cd6e01-4219-4ebd-8709-27ed23360c62");
pub const DXGI_INFO_QUEUE_MESSAGE_ID_STRING_FROM_APPLICATION = @as(u32, 0);
pub const DXGI_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT = @as(u32, 1024);
pub const DXGI_CREATE_FACTORY_DEBUG = @as(u32, 1);
pub const DXGI_ERROR_INVALID_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270527));
pub const DXGI_ERROR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270526));
pub const DXGI_ERROR_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270525));
pub const DXGI_ERROR_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270524));
pub const DXGI_ERROR_DEVICE_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270523));
pub const DXGI_ERROR_DEVICE_HUNG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270522));
pub const DXGI_ERROR_DEVICE_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270521));
pub const DXGI_ERROR_WAS_STILL_DRAWING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270518));
pub const DXGI_ERROR_FRAME_STATISTICS_DISJOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270517));
pub const DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270516));
pub const DXGI_ERROR_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270496));
pub const DXGI_ERROR_NONEXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270495));
pub const DXGI_ERROR_NOT_CURRENTLY_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270494));
pub const DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270493));
pub const DXGI_ERROR_REMOTE_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270492));
pub const DXGI_ERROR_ACCESS_LOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270490));
pub const DXGI_ERROR_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270489));
pub const DXGI_ERROR_SESSION_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270488));
pub const DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270487));
pub const DXGI_ERROR_CANNOT_PROTECT_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270486));
pub const DXGI_ERROR_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270485));
pub const DXGI_ERROR_NAME_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270484));
pub const DXGI_ERROR_SDK_COMPONENT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270483));
pub const DXGI_ERROR_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270482));
pub const DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270480));
pub const DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270479));
pub const DXGI_ERROR_NON_COMPOSITED_UI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270478));
pub const DXGI_ERROR_MODE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270491));
pub const DXGI_ERROR_CACHE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270477));
pub const DXGI_ERROR_CACHE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270476));
pub const DXGI_ERROR_CACHE_HASH_COLLISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270475));
pub const DXGI_ERROR_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005270474));

//--------------------------------------------------------------------------------
// Section: Types (106)
//--------------------------------------------------------------------------------
pub const DXGI_RGBA = extern struct {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
};

pub const DXGI_RESOURCE_PRIORITY = enum(u32) {
    MINIMUM = 671088640,
    LOW = 1342177280,
    NORMAL = 2013265920,
    HIGH = 2684354560,
    MAXIMUM = 3355443200,
};
pub const DXGI_RESOURCE_PRIORITY_MINIMUM = DXGI_RESOURCE_PRIORITY.MINIMUM;
pub const DXGI_RESOURCE_PRIORITY_LOW = DXGI_RESOURCE_PRIORITY.LOW;
pub const DXGI_RESOURCE_PRIORITY_NORMAL = DXGI_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_RESOURCE_PRIORITY_HIGH = DXGI_RESOURCE_PRIORITY.HIGH;
pub const DXGI_RESOURCE_PRIORITY_MAXIMUM = DXGI_RESOURCE_PRIORITY.MAXIMUM;

pub const DXGI_FRAME_STATISTICS = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
};

pub const DXGI_MAPPED_RECT = extern struct {
    Pitch: i32,
    pBits: ?*u8,
};

pub const DXGI_ADAPTER_DESC = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
};

pub const DXGI_OUTPUT_DESC = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
};

pub const DXGI_SHARED_RESOURCE = extern struct {
    Handle: ?HANDLE,
};

pub const DXGI_RESIDENCY = enum(i32) {
    FULLY_RESIDENT = 1,
    RESIDENT_IN_SHARED_MEMORY = 2,
    EVICTED_TO_DISK = 3,
};
pub const DXGI_RESIDENCY_FULLY_RESIDENT = DXGI_RESIDENCY.FULLY_RESIDENT;
pub const DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = DXGI_RESIDENCY.RESIDENT_IN_SHARED_MEMORY;
pub const DXGI_RESIDENCY_EVICTED_TO_DISK = DXGI_RESIDENCY.EVICTED_TO_DISK;

pub const DXGI_SURFACE_DESC = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    SampleDesc: DXGI_SAMPLE_DESC,
};

pub const DXGI_SWAP_EFFECT = enum(i32) {
    DISCARD = 0,
    SEQUENTIAL = 1,
    FLIP_SEQUENTIAL = 3,
    FLIP_DISCARD = 4,
};
pub const DXGI_SWAP_EFFECT_DISCARD = DXGI_SWAP_EFFECT.DISCARD;
pub const DXGI_SWAP_EFFECT_SEQUENTIAL = DXGI_SWAP_EFFECT.SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = DXGI_SWAP_EFFECT.FLIP_SEQUENTIAL;
pub const DXGI_SWAP_EFFECT_FLIP_DISCARD = DXGI_SWAP_EFFECT.FLIP_DISCARD;

pub const DXGI_SWAP_CHAIN_FLAG = enum(i32) {
    NONPREROTATED = 1,
    ALLOW_MODE_SWITCH = 2,
    GDI_COMPATIBLE = 4,
    RESTRICTED_CONTENT = 8,
    RESTRICT_SHARED_RESOURCE_DRIVER = 16,
    DISPLAY_ONLY = 32,
    FRAME_LATENCY_WAITABLE_OBJECT = 64,
    FOREGROUND_LAYER = 128,
    FULLSCREEN_VIDEO = 256,
    YUV_VIDEO = 512,
    HW_PROTECTED = 1024,
    ALLOW_TEARING = 2048,
    RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = 4096,
};
pub const DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = DXGI_SWAP_CHAIN_FLAG.NONPREROTATED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = DXGI_SWAP_CHAIN_FLAG.ALLOW_MODE_SWITCH;
pub const DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE = DXGI_SWAP_CHAIN_FLAG.GDI_COMPATIBLE;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_CONTENT;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = DXGI_SWAP_CHAIN_FLAG.RESTRICT_SHARED_RESOURCE_DRIVER;
pub const DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY = DXGI_SWAP_CHAIN_FLAG.DISPLAY_ONLY;
pub const DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = DXGI_SWAP_CHAIN_FLAG.FRAME_LATENCY_WAITABLE_OBJECT;
pub const DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER = DXGI_SWAP_CHAIN_FLAG.FOREGROUND_LAYER;
pub const DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO = DXGI_SWAP_CHAIN_FLAG.FULLSCREEN_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = DXGI_SWAP_CHAIN_FLAG.YUV_VIDEO;
pub const DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED = DXGI_SWAP_CHAIN_FLAG.HW_PROTECTED;
pub const DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = DXGI_SWAP_CHAIN_FLAG.ALLOW_TEARING;
pub const DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = DXGI_SWAP_CHAIN_FLAG.RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS;

pub const DXGI_SWAP_CHAIN_DESC = extern struct {
    BufferDesc: DXGI_MODE_DESC,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    OutputWindow: ?HWND,
    Windowed: BOOL,
    SwapEffect: DXGI_SWAP_EFFECT,
    Flags: u32,
};

const IID_IDXGIObject_Value = Guid.initString("aec22fb8-76f3-4639-9be0-28eb43a67a2e");
pub const IID_IDXGIObject = &IID_IDXGIObject_Value;
pub const IDXGIObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPrivateData: *const fn (
            self: *const IDXGIObject,
            name: ?*const Guid,
            data_size: u32,
            // TODO: what to do with BytesParamIndex 1?
            p_data: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrivateDataInterface: *const fn (
            self: *const IDXGIObject,
            name: ?*const Guid,
            p_unknown: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateData: *const fn (
            self: *const IDXGIObject,
            name: ?*const Guid,
            p_data_size: ?*u32,
            // TODO: what to do with BytesParamIndex 1?
            p_data: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: *const fn (
            self: *const IDXGIObject,
            riid: ?*const Guid,
            pp_parent: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setPrivateData(self: *const T, name_: ?*const Guid, data_size_: u32, p_data_: ?*const anyopaque) HRESULT {
                return @as(*const IDXGIObject.VTable, @ptrCast(self.vtable)).SetPrivateData(@as(*const IDXGIObject, @ptrCast(self)), name_, data_size_, p_data_);
            }
            pub inline fn setPrivateDataInterface(self: *const T, name_: ?*const Guid, p_unknown_: ?*IUnknown) HRESULT {
                return @as(*const IDXGIObject.VTable, @ptrCast(self.vtable)).SetPrivateDataInterface(@as(*const IDXGIObject, @ptrCast(self)), name_, p_unknown_);
            }
            pub inline fn getPrivateData(self: *const T, name_: ?*const Guid, p_data_size_: ?*u32, p_data_: ?*anyopaque) HRESULT {
                return @as(*const IDXGIObject.VTable, @ptrCast(self.vtable)).GetPrivateData(@as(*const IDXGIObject, @ptrCast(self)), name_, p_data_size_, p_data_);
            }
            pub inline fn getParent(self: *const T, riid_: ?*const Guid, pp_parent_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGIObject.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IDXGIObject, @ptrCast(self)), riid_, pp_parent_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDeviceSubObject_Value = Guid.initString("3d3e0379-f9de-4d58-bb6c-18d62992f1a6");
pub const IID_IDXGIDeviceSubObject = &IID_IDXGIDeviceSubObject_Value;
pub const IDXGIDeviceSubObject = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDevice: *const fn (
            self: *const IDXGIDeviceSubObject,
            riid: ?*const Guid,
            pp_device: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn getDevice(self: *const T, riid_: ?*const Guid, pp_device_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGIDeviceSubObject.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IDXGIDeviceSubObject, @ptrCast(self)), riid_, pp_device_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIResource_Value = Guid.initString("035f3ab4-482e-4e50-b41f-8a7f8bd8960b");
pub const IID_IDXGIResource = &IID_IDXGIResource_Value;
pub const IDXGIResource = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetSharedHandle: *const fn (
            self: *const IDXGIResource,
            p_shared_handle: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsage: *const fn (
            self: *const IDXGIResource,
            p_usage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEvictionPriority: *const fn (
            self: *const IDXGIResource,
            eviction_priority: DXGI_RESOURCE_PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvictionPriority: *const fn (
            self: *const IDXGIResource,
            p_eviction_priority: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
            pub inline fn getSharedHandle(self: *const T, p_shared_handle_: ?*?HANDLE) HRESULT {
                return @as(*const IDXGIResource.VTable, @ptrCast(self.vtable)).GetSharedHandle(@as(*const IDXGIResource, @ptrCast(self)), p_shared_handle_);
            }
            pub inline fn getUsage(self: *const T, p_usage_: ?*u32) HRESULT {
                return @as(*const IDXGIResource.VTable, @ptrCast(self.vtable)).GetUsage(@as(*const IDXGIResource, @ptrCast(self)), p_usage_);
            }
            pub inline fn setEvictionPriority(self: *const T, eviction_priority_: DXGI_RESOURCE_PRIORITY) HRESULT {
                return @as(*const IDXGIResource.VTable, @ptrCast(self.vtable)).SetEvictionPriority(@as(*const IDXGIResource, @ptrCast(self)), eviction_priority_);
            }
            pub inline fn getEvictionPriority(self: *const T, p_eviction_priority_: ?*u32) HRESULT {
                return @as(*const IDXGIResource.VTable, @ptrCast(self.vtable)).GetEvictionPriority(@as(*const IDXGIResource, @ptrCast(self)), p_eviction_priority_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIKeyedMutex_Value = Guid.initString("9d8e1289-d7b3-465f-8126-250e349af85d");
pub const IID_IDXGIKeyedMutex = &IID_IDXGIKeyedMutex_Value;
pub const IDXGIKeyedMutex = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        AcquireSync: *const fn (
            self: *const IDXGIKeyedMutex,
            key: u64,
            dw_milliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSync: *const fn (
            self: *const IDXGIKeyedMutex,
            key: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
            pub inline fn acquireSync(self: *const T, key_: u64, dw_milliseconds_: u32) HRESULT {
                return @as(*const IDXGIKeyedMutex.VTable, @ptrCast(self.vtable)).AcquireSync(@as(*const IDXGIKeyedMutex, @ptrCast(self)), key_, dw_milliseconds_);
            }
            pub inline fn releaseSync(self: *const T, key_: u64) HRESULT {
                return @as(*const IDXGIKeyedMutex.VTable, @ptrCast(self.vtable)).ReleaseSync(@as(*const IDXGIKeyedMutex, @ptrCast(self)), key_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISurface_Value = Guid.initString("cafcb56c-6ac3-4889-bf47-9e23bbd260ec");
pub const IID_IDXGISurface = &IID_IDXGISurface_Value;
pub const IDXGISurface = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        GetDesc: *const fn (
            self: *const IDXGISurface,
            p_desc: ?*DXGI_SURFACE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Map: *const fn (
            self: *const IDXGISurface,
            p_locked_rect: ?*DXGI_MAPPED_RECT,
            map_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmap: *const fn (
            self: *const IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
            pub inline fn getDesc(self: *const T, p_desc_: ?*DXGI_SURFACE_DESC) HRESULT {
                return @as(*const IDXGISurface.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const IDXGISurface, @ptrCast(self)), p_desc_);
            }
            pub inline fn map(self: *const T, p_locked_rect_: ?*DXGI_MAPPED_RECT, map_flags_: u32) HRESULT {
                return @as(*const IDXGISurface.VTable, @ptrCast(self.vtable)).Map(@as(*const IDXGISurface, @ptrCast(self)), p_locked_rect_, map_flags_);
            }
            pub inline fn unmap(self: *const T) HRESULT {
                return @as(*const IDXGISurface.VTable, @ptrCast(self.vtable)).Unmap(@as(*const IDXGISurface, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGISurface1_Value = Guid.initString("4ae63092-6327-4c1b-80ae-bfe12ea32b86");
pub const IID_IDXGISurface1 = &IID_IDXGISurface1_Value;
pub const IDXGISurface1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface.VTable,
        GetDC: *const fn (
            self: *const IDXGISurface1,
            discard: BOOL,
            phdc: ?*?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDC: *const fn (
            self: *const IDXGISurface1,
            p_dirty_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISurface.MethodMixin(T);
            pub inline fn getDC(self: *const T, discard_: BOOL, phdc_: ?*?HDC) HRESULT {
                return @as(*const IDXGISurface1.VTable, @ptrCast(self.vtable)).GetDC(@as(*const IDXGISurface1, @ptrCast(self)), discard_, phdc_);
            }
            pub inline fn releaseDC(self: *const T, p_dirty_rect_: ?*RECT) HRESULT {
                return @as(*const IDXGISurface1.VTable, @ptrCast(self.vtable)).ReleaseDC(@as(*const IDXGISurface1, @ptrCast(self)), p_dirty_rect_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIAdapter_Value = Guid.initString("2411e7e1-12ac-4ccf-bd14-9798e8534dc0");
pub const IID_IDXGIAdapter = &IID_IDXGIAdapter_Value;
pub const IDXGIAdapter = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumOutputs: *const fn (
            self: *const IDXGIAdapter,
            output: u32,
            pp_output: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDesc: *const fn (
            self: *const IDXGIAdapter,
            p_desc: ?*DXGI_ADAPTER_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckInterfaceSupport: *const fn (
            self: *const IDXGIAdapter,
            interface_name: ?*const Guid,
            p_u_m_d_version: ?*LARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn enumOutputs(self: *const T, output_: u32, pp_output_: ?*?*IDXGIOutput) HRESULT {
                return @as(*const IDXGIAdapter.VTable, @ptrCast(self.vtable)).EnumOutputs(@as(*const IDXGIAdapter, @ptrCast(self)), output_, pp_output_);
            }
            pub inline fn getDesc(self: *const T, p_desc_: ?*DXGI_ADAPTER_DESC) HRESULT {
                return @as(*const IDXGIAdapter.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const IDXGIAdapter, @ptrCast(self)), p_desc_);
            }
            pub inline fn checkInterfaceSupport(self: *const T, interface_name_: ?*const Guid, p_u_m_d_version_: ?*LARGE_INTEGER) HRESULT {
                return @as(*const IDXGIAdapter.VTable, @ptrCast(self.vtable)).CheckInterfaceSupport(@as(*const IDXGIAdapter, @ptrCast(self)), interface_name_, p_u_m_d_version_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIOutput_Value = Guid.initString("ae02eedb-c735-4690-8d52-5a8dc20213aa");
pub const IID_IDXGIOutput = &IID_IDXGIOutput_Value;
pub const IDXGIOutput = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: *const fn (
            self: *const IDXGIOutput,
            p_desc: ?*DXGI_OUTPUT_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayModeList: *const fn (
            self: *const IDXGIOutput,
            enum_format: DXGI_FORMAT,
            flags: u32,
            p_num_modes: ?*u32,
            p_desc: ?[*]DXGI_MODE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestMatchingMode: *const fn (
            self: *const IDXGIOutput,
            p_mode_to_match: ?*const DXGI_MODE_DESC,
            p_closest_match: ?*DXGI_MODE_DESC,
            p_concerned_device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForVBlank: *const fn (
            self: *const IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TakeOwnership: *const fn (
            self: *const IDXGIOutput,
            p_device: ?*IUnknown,
            exclusive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseOwnership: *const fn (
            self: *const IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetGammaControlCapabilities: *const fn (
            self: *const IDXGIOutput,
            p_gamma_caps: ?*DXGI_GAMMA_CONTROL_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGammaControl: *const fn (
            self: *const IDXGIOutput,
            p_array: ?*const DXGI_GAMMA_CONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGammaControl: *const fn (
            self: *const IDXGIOutput,
            p_array: ?*DXGI_GAMMA_CONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplaySurface: *const fn (
            self: *const IDXGIOutput,
            p_scanout_surface: ?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplaySurfaceData: *const fn (
            self: *const IDXGIOutput,
            p_destination: ?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameStatistics: *const fn (
            self: *const IDXGIOutput,
            p_stats: ?*DXGI_FRAME_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn getDesc(self: *const T, p_desc_: ?*DXGI_OUTPUT_DESC) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const IDXGIOutput, @ptrCast(self)), p_desc_);
            }
            pub inline fn getDisplayModeList(self: *const T, enum_format_: DXGI_FORMAT, flags_: u32, p_num_modes_: ?*u32, p_desc_: ?[*]DXGI_MODE_DESC) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetDisplayModeList(@as(*const IDXGIOutput, @ptrCast(self)), enum_format_, flags_, p_num_modes_, p_desc_);
            }
            pub inline fn findClosestMatchingMode(self: *const T, p_mode_to_match_: ?*const DXGI_MODE_DESC, p_closest_match_: ?*DXGI_MODE_DESC, p_concerned_device_: ?*IUnknown) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).FindClosestMatchingMode(@as(*const IDXGIOutput, @ptrCast(self)), p_mode_to_match_, p_closest_match_, p_concerned_device_);
            }
            pub inline fn waitForVBlank(self: *const T) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).WaitForVBlank(@as(*const IDXGIOutput, @ptrCast(self)));
            }
            pub inline fn takeOwnership(self: *const T, p_device_: ?*IUnknown, exclusive_: BOOL) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).TakeOwnership(@as(*const IDXGIOutput, @ptrCast(self)), p_device_, exclusive_);
            }
            pub inline fn releaseOwnership(self: *const T) void {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).ReleaseOwnership(@as(*const IDXGIOutput, @ptrCast(self)));
            }
            pub inline fn getGammaControlCapabilities(self: *const T, p_gamma_caps_: ?*DXGI_GAMMA_CONTROL_CAPABILITIES) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetGammaControlCapabilities(@as(*const IDXGIOutput, @ptrCast(self)), p_gamma_caps_);
            }
            pub inline fn setGammaControl(self: *const T, p_array_: ?*const DXGI_GAMMA_CONTROL) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).SetGammaControl(@as(*const IDXGIOutput, @ptrCast(self)), p_array_);
            }
            pub inline fn getGammaControl(self: *const T, p_array_: ?*DXGI_GAMMA_CONTROL) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetGammaControl(@as(*const IDXGIOutput, @ptrCast(self)), p_array_);
            }
            pub inline fn setDisplaySurface(self: *const T, p_scanout_surface_: ?*IDXGISurface) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).SetDisplaySurface(@as(*const IDXGIOutput, @ptrCast(self)), p_scanout_surface_);
            }
            pub inline fn getDisplaySurfaceData(self: *const T, p_destination_: ?*IDXGISurface) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetDisplaySurfaceData(@as(*const IDXGIOutput, @ptrCast(self)), p_destination_);
            }
            pub inline fn getFrameStatistics(self: *const T, p_stats_: ?*DXGI_FRAME_STATISTICS) HRESULT {
                return @as(*const IDXGIOutput.VTable, @ptrCast(self.vtable)).GetFrameStatistics(@as(*const IDXGIOutput, @ptrCast(self)), p_stats_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGISwapChain_Value = Guid.initString("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a");
pub const IID_IDXGISwapChain = &IID_IDXGISwapChain_Value;
pub const IDXGISwapChain = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDeviceSubObject.VTable,
        Present: *const fn (
            self: *const IDXGISwapChain,
            sync_interval: u32,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: *const fn (
            self: *const IDXGISwapChain,
            buffer: u32,
            riid: ?*const Guid,
            pp_surface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullscreenState: *const fn (
            self: *const IDXGISwapChain,
            fullscreen: BOOL,
            p_target: ?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullscreenState: *const fn (
            self: *const IDXGISwapChain,
            p_fullscreen: ?*BOOL,
            pp_target: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDesc: *const fn (
            self: *const IDXGISwapChain,
            p_desc: ?*DXGI_SWAP_CHAIN_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBuffers: *const fn (
            self: *const IDXGISwapChain,
            buffer_count: u32,
            width: u32,
            height: u32,
            new_format: DXGI_FORMAT,
            swap_chain_flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeTarget: *const fn (
            self: *const IDXGISwapChain,
            p_new_target_parameters: ?*const DXGI_MODE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingOutput: *const fn (
            self: *const IDXGISwapChain,
            pp_output: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameStatistics: *const fn (
            self: *const IDXGISwapChain,
            p_stats: ?*DXGI_FRAME_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastPresentCount: *const fn (
            self: *const IDXGISwapChain,
            p_last_present_count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDeviceSubObject.MethodMixin(T);
            pub inline fn present(self: *const T, sync_interval_: u32, flags_: u32) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).Present(@as(*const IDXGISwapChain, @ptrCast(self)), sync_interval_, flags_);
            }
            pub inline fn getBuffer(self: *const T, buffer_: u32, riid_: ?*const Guid, pp_surface_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDXGISwapChain, @ptrCast(self)), buffer_, riid_, pp_surface_);
            }
            pub inline fn setFullscreenState(self: *const T, fullscreen_: BOOL, p_target_: ?*IDXGIOutput) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).SetFullscreenState(@as(*const IDXGISwapChain, @ptrCast(self)), fullscreen_, p_target_);
            }
            pub inline fn getFullscreenState(self: *const T, p_fullscreen_: ?*BOOL, pp_target_: ?*?*IDXGIOutput) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetFullscreenState(@as(*const IDXGISwapChain, @ptrCast(self)), p_fullscreen_, pp_target_);
            }
            pub inline fn getDesc(self: *const T, p_desc_: ?*DXGI_SWAP_CHAIN_DESC) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const IDXGISwapChain, @ptrCast(self)), p_desc_);
            }
            pub inline fn resizeBuffers(self: *const T, buffer_count_: u32, width_: u32, height_: u32, new_format_: DXGI_FORMAT, swap_chain_flags_: u32) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).ResizeBuffers(@as(*const IDXGISwapChain, @ptrCast(self)), buffer_count_, width_, height_, new_format_, swap_chain_flags_);
            }
            pub inline fn resizeTarget(self: *const T, p_new_target_parameters_: ?*const DXGI_MODE_DESC) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).ResizeTarget(@as(*const IDXGISwapChain, @ptrCast(self)), p_new_target_parameters_);
            }
            pub inline fn getContainingOutput(self: *const T, pp_output_: ?*?*IDXGIOutput) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetContainingOutput(@as(*const IDXGISwapChain, @ptrCast(self)), pp_output_);
            }
            pub inline fn getFrameStatistics(self: *const T, p_stats_: ?*DXGI_FRAME_STATISTICS) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetFrameStatistics(@as(*const IDXGISwapChain, @ptrCast(self)), p_stats_);
            }
            pub inline fn getLastPresentCount(self: *const T, p_last_present_count_: ?*u32) HRESULT {
                return @as(*const IDXGISwapChain.VTable, @ptrCast(self.vtable)).GetLastPresentCount(@as(*const IDXGISwapChain, @ptrCast(self)), p_last_present_count_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory_Value = Guid.initString("7b7166ec-21c7-44ae-b21a-c9ae321ae369");
pub const IID_IDXGIFactory = &IID_IDXGIFactory_Value;
pub const IDXGIFactory = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        EnumAdapters: *const fn (
            self: *const IDXGIFactory,
            adapter: u32,
            pp_adapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeWindowAssociation: *const fn (
            self: *const IDXGIFactory,
            window_handle: ?HWND,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowAssociation: *const fn (
            self: *const IDXGIFactory,
            p_window_handle: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSwapChain: *const fn (
            self: *const IDXGIFactory,
            p_device: ?*IUnknown,
            p_desc: ?*DXGI_SWAP_CHAIN_DESC,
            pp_swap_chain: ?*?*IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSoftwareAdapter: *const fn (
            self: *const IDXGIFactory,
            module: ?HINSTANCE,
            pp_adapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn enumAdapters(self: *const T, adapter_: u32, pp_adapter_: ?*?*IDXGIAdapter) HRESULT {
                return @as(*const IDXGIFactory.VTable, @ptrCast(self.vtable)).EnumAdapters(@as(*const IDXGIFactory, @ptrCast(self)), adapter_, pp_adapter_);
            }
            pub inline fn makeWindowAssociation(self: *const T, window_handle_: ?HWND, flags_: u32) HRESULT {
                return @as(*const IDXGIFactory.VTable, @ptrCast(self.vtable)).MakeWindowAssociation(@as(*const IDXGIFactory, @ptrCast(self)), window_handle_, flags_);
            }
            pub inline fn getWindowAssociation(self: *const T, p_window_handle_: ?*?HWND) HRESULT {
                return @as(*const IDXGIFactory.VTable, @ptrCast(self.vtable)).GetWindowAssociation(@as(*const IDXGIFactory, @ptrCast(self)), p_window_handle_);
            }
            pub inline fn createSwapChain(self: *const T, p_device_: ?*IUnknown, p_desc_: ?*DXGI_SWAP_CHAIN_DESC, pp_swap_chain_: ?*?*IDXGISwapChain) HRESULT {
                return @as(*const IDXGIFactory.VTable, @ptrCast(self.vtable)).CreateSwapChain(@as(*const IDXGIFactory, @ptrCast(self)), p_device_, p_desc_, pp_swap_chain_);
            }
            pub inline fn createSoftwareAdapter(self: *const T, module_: ?HINSTANCE, pp_adapter_: ?*?*IDXGIAdapter) HRESULT {
                return @as(*const IDXGIFactory.VTable, @ptrCast(self.vtable)).CreateSoftwareAdapter(@as(*const IDXGIFactory, @ptrCast(self)), module_, pp_adapter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIDevice_Value = Guid.initString("54ec77fa-1377-44e6-8c32-88fd5f44c84c");
pub const IID_IDXGIDevice = &IID_IDXGIDevice_Value;
pub const IDXGIDevice = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetAdapter: *const fn (
            self: *const IDXGIDevice,
            p_adapter: ?*?*IDXGIAdapter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSurface: *const fn (
            self: *const IDXGIDevice,
            p_desc: ?*const DXGI_SURFACE_DESC,
            num_surfaces: u32,
            usage: u32,
            p_shared_resource: ?*const DXGI_SHARED_RESOURCE,
            pp_surface: [*]?*IDXGISurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryResourceResidency: *const fn (
            self: *const IDXGIDevice,
            pp_resources: [*]?*IUnknown,
            p_residency_status: [*]DXGI_RESIDENCY,
            num_resources: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGPUThreadPriority: *const fn (
            self: *const IDXGIDevice,
            priority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGPUThreadPriority: *const fn (
            self: *const IDXGIDevice,
            p_priority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn getAdapter(self: *const T, p_adapter_: ?*?*IDXGIAdapter) HRESULT {
                return @as(*const IDXGIDevice.VTable, @ptrCast(self.vtable)).GetAdapter(@as(*const IDXGIDevice, @ptrCast(self)), p_adapter_);
            }
            pub inline fn createSurface(self: *const T, p_desc_: ?*const DXGI_SURFACE_DESC, num_surfaces_: u32, usage_: u32, p_shared_resource_: ?*const DXGI_SHARED_RESOURCE, pp_surface_: [*]?*IDXGISurface) HRESULT {
                return @as(*const IDXGIDevice.VTable, @ptrCast(self.vtable)).CreateSurface(@as(*const IDXGIDevice, @ptrCast(self)), p_desc_, num_surfaces_, usage_, p_shared_resource_, pp_surface_);
            }
            pub inline fn queryResourceResidency(self: *const T, pp_resources_: [*]?*IUnknown, p_residency_status_: [*]DXGI_RESIDENCY, num_resources_: u32) HRESULT {
                return @as(*const IDXGIDevice.VTable, @ptrCast(self.vtable)).QueryResourceResidency(@as(*const IDXGIDevice, @ptrCast(self)), pp_resources_, p_residency_status_, num_resources_);
            }
            pub inline fn setGPUThreadPriority(self: *const T, priority_: i32) HRESULT {
                return @as(*const IDXGIDevice.VTable, @ptrCast(self.vtable)).SetGPUThreadPriority(@as(*const IDXGIDevice, @ptrCast(self)), priority_);
            }
            pub inline fn getGPUThreadPriority(self: *const T, p_priority_: ?*i32) HRESULT {
                return @as(*const IDXGIDevice.VTable, @ptrCast(self.vtable)).GetGPUThreadPriority(@as(*const IDXGIDevice, @ptrCast(self)), p_priority_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
    }) DXGI_ADAPTER_FLAG {
        return @as(DXGI_ADAPTER_FLAG, @enumFromInt((if (o.NONE == 1) @intFromEnum(DXGI_ADAPTER_FLAG.NONE) else 0) | (if (o.REMOTE == 1) @intFromEnum(DXGI_ADAPTER_FLAG.REMOTE) else 0) | (if (o.SOFTWARE == 1) @intFromEnum(DXGI_ADAPTER_FLAG.SOFTWARE) else 0)));
    }
};
pub const DXGI_ADAPTER_FLAG_NONE = DXGI_ADAPTER_FLAG.NONE;
pub const DXGI_ADAPTER_FLAG_REMOTE = DXGI_ADAPTER_FLAG.REMOTE;
pub const DXGI_ADAPTER_FLAG_SOFTWARE = DXGI_ADAPTER_FLAG.SOFTWARE;

pub const DXGI_ADAPTER_DESC1 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
};

pub const DXGI_DISPLAY_COLOR_SPACE = extern struct {
    PrimaryCoordinates: [16]f32,
    WhitePoints: [32]f32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIFactory1_Value = Guid.initString("770aae78-f26f-4dba-a829-253c83d1b387");
pub const IID_IDXGIFactory1 = &IID_IDXGIFactory1_Value;
pub const IDXGIFactory1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory.VTable,
        EnumAdapters1: *const fn (
            self: *const IDXGIFactory1,
            adapter: u32,
            pp_adapter: ?*?*IDXGIAdapter1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrent: *const fn (
            self: *const IDXGIFactory1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory.MethodMixin(T);
            pub inline fn enumAdapters1(self: *const T, adapter_: u32, pp_adapter_: ?*?*IDXGIAdapter1) HRESULT {
                return @as(*const IDXGIFactory1.VTable, @ptrCast(self.vtable)).EnumAdapters1(@as(*const IDXGIFactory1, @ptrCast(self)), adapter_, pp_adapter_);
            }
            pub inline fn isCurrent(self: *const T) BOOL {
                return @as(*const IDXGIFactory1.VTable, @ptrCast(self.vtable)).IsCurrent(@as(*const IDXGIFactory1, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIAdapter1_Value = Guid.initString("29038f61-3839-4626-91fd-086879011a05");
pub const IID_IDXGIAdapter1 = &IID_IDXGIAdapter1_Value;
pub const IDXGIAdapter1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter.VTable,
        GetDesc1: *const fn (
            self: *const IDXGIAdapter1,
            p_desc: ?*DXGI_ADAPTER_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIAdapter.MethodMixin(T);
            pub inline fn getDesc1(self: *const T, p_desc_: ?*DXGI_ADAPTER_DESC1) HRESULT {
                return @as(*const IDXGIAdapter1.VTable, @ptrCast(self.vtable)).GetDesc1(@as(*const IDXGIAdapter1, @ptrCast(self)), p_desc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXGIDevice1_Value = Guid.initString("77db970f-6276-48ba-ba28-070143b4392c");
pub const IID_IDXGIDevice1 = &IID_IDXGIDevice1_Value;
pub const IDXGIDevice1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice.VTable,
        SetMaximumFrameLatency: *const fn (
            self: *const IDXGIDevice1,
            max_latency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumFrameLatency: *const fn (
            self: *const IDXGIDevice1,
            p_max_latency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDevice.MethodMixin(T);
            pub inline fn setMaximumFrameLatency(self: *const T, max_latency_: u32) HRESULT {
                return @as(*const IDXGIDevice1.VTable, @ptrCast(self.vtable)).SetMaximumFrameLatency(@as(*const IDXGIDevice1, @ptrCast(self)), max_latency_);
            }
            pub inline fn getMaximumFrameLatency(self: *const T, p_max_latency_: ?*u32) HRESULT {
                return @as(*const IDXGIDevice1.VTable, @ptrCast(self.vtable)).GetMaximumFrameLatency(@as(*const IDXGIDevice1, @ptrCast(self)), p_max_latency_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDisplayControl_Value = Guid.initString("ea9dbf1a-c88e-4486-854a-98aa0138f30c");
pub const IID_IDXGIDisplayControl = &IID_IDXGIDisplayControl_Value;
pub const IDXGIDisplayControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStereoEnabled: *const fn (
            self: *const IDXGIDisplayControl,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetStereoEnabled: *const fn (
            self: *const IDXGIDisplayControl,
            enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn isStereoEnabled(self: *const T) BOOL {
                return @as(*const IDXGIDisplayControl.VTable, @ptrCast(self.vtable)).IsStereoEnabled(@as(*const IDXGIDisplayControl, @ptrCast(self)));
            }
            pub inline fn setStereoEnabled(self: *const T, enabled_: BOOL) void {
                return @as(*const IDXGIDisplayControl.VTable, @ptrCast(self.vtable)).SetStereoEnabled(@as(*const IDXGIDisplayControl, @ptrCast(self)), enabled_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_MOVE_RECT = extern struct {
    SourcePoint: POINT,
    DestinationRect: RECT,
};

pub const DXGI_OUTDUPL_DESC = extern struct {
    ModeDesc: DXGI_MODE_DESC,
    Rotation: DXGI_MODE_ROTATION,
    DesktopImageInSystemMemory: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_POSITION = extern struct {
    Position: POINT,
    Visible: BOOL,
};

pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE = enum(i32) {
    MONOCHROME = 1,
    COLOR = 2,
    MASKED_COLOR = 4,
};
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MONOCHROME;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.COLOR;
pub const DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR = DXGI_OUTDUPL_POINTER_SHAPE_TYPE.MASKED_COLOR;

pub const DXGI_OUTDUPL_POINTER_SHAPE_INFO = extern struct {
    Type: u32,
    Width: u32,
    Height: u32,
    Pitch: u32,
    HotSpot: POINT,
};

pub const DXGI_OUTDUPL_FRAME_INFO = extern struct {
    LastPresentTime: LARGE_INTEGER,
    LastMouseUpdateTime: LARGE_INTEGER,
    AccumulatedFrames: u32,
    RectsCoalesced: BOOL,
    ProtectedContentMaskedOut: BOOL,
    PointerPosition: DXGI_OUTDUPL_POINTER_POSITION,
    TotalMetadataBufferSize: u32,
    PointerShapeBufferSize: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutputDuplication_Value = Guid.initString("191cfac3-a341-470d-b26e-a864f428319c");
pub const IID_IDXGIOutputDuplication = &IID_IDXGIOutputDuplication_Value;
pub const IDXGIOutputDuplication = extern struct {
    pub const VTable = extern struct {
        base: IDXGIObject.VTable,
        GetDesc: *const fn (
            self: *const IDXGIOutputDuplication,
            p_desc: ?*DXGI_OUTDUPL_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        AcquireNextFrame: *const fn (
            self: *const IDXGIOutputDuplication,
            timeout_in_milliseconds: u32,
            p_frame_info: ?*DXGI_OUTDUPL_FRAME_INFO,
            pp_desktop_resource: ?*?*IDXGIResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameDirtyRects: *const fn (
            self: *const IDXGIOutputDuplication,
            dirty_rects_buffer_size: u32,
            // TODO: what to do with BytesParamIndex 0?
            p_dirty_rects_buffer: ?*RECT,
            p_dirty_rects_buffer_size_required: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameMoveRects: *const fn (
            self: *const IDXGIOutputDuplication,
            move_rects_buffer_size: u32,
            // TODO: what to do with BytesParamIndex 0?
            p_move_rect_buffer: ?*DXGI_OUTDUPL_MOVE_RECT,
            p_move_rects_buffer_size_required: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFramePointerShape: *const fn (
            self: *const IDXGIOutputDuplication,
            pointer_shape_buffer_size: u32,
            // TODO: what to do with BytesParamIndex 0?
            p_pointer_shape_buffer: ?*anyopaque,
            p_pointer_shape_buffer_size_required: ?*u32,
            p_pointer_shape_info: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapDesktopSurface: *const fn (
            self: *const IDXGIOutputDuplication,
            p_locked_rect: ?*DXGI_MAPPED_RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnMapDesktopSurface: *const fn (
            self: *const IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFrame: *const fn (
            self: *const IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIObject.MethodMixin(T);
            pub inline fn getDesc(self: *const T, p_desc_: ?*DXGI_OUTDUPL_DESC) void {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const IDXGIOutputDuplication, @ptrCast(self)), p_desc_);
            }
            pub inline fn acquireNextFrame(self: *const T, timeout_in_milliseconds_: u32, p_frame_info_: ?*DXGI_OUTDUPL_FRAME_INFO, pp_desktop_resource_: ?*?*IDXGIResource) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).AcquireNextFrame(@as(*const IDXGIOutputDuplication, @ptrCast(self)), timeout_in_milliseconds_, p_frame_info_, pp_desktop_resource_);
            }
            pub inline fn getFrameDirtyRects(self: *const T, dirty_rects_buffer_size_: u32, p_dirty_rects_buffer_: ?*RECT, p_dirty_rects_buffer_size_required_: ?*u32) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).GetFrameDirtyRects(@as(*const IDXGIOutputDuplication, @ptrCast(self)), dirty_rects_buffer_size_, p_dirty_rects_buffer_, p_dirty_rects_buffer_size_required_);
            }
            pub inline fn getFrameMoveRects(self: *const T, move_rects_buffer_size_: u32, p_move_rect_buffer_: ?*DXGI_OUTDUPL_MOVE_RECT, p_move_rects_buffer_size_required_: ?*u32) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).GetFrameMoveRects(@as(*const IDXGIOutputDuplication, @ptrCast(self)), move_rects_buffer_size_, p_move_rect_buffer_, p_move_rects_buffer_size_required_);
            }
            pub inline fn getFramePointerShape(self: *const T, pointer_shape_buffer_size_: u32, p_pointer_shape_buffer_: ?*anyopaque, p_pointer_shape_buffer_size_required_: ?*u32, p_pointer_shape_info_: ?*DXGI_OUTDUPL_POINTER_SHAPE_INFO) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).GetFramePointerShape(@as(*const IDXGIOutputDuplication, @ptrCast(self)), pointer_shape_buffer_size_, p_pointer_shape_buffer_, p_pointer_shape_buffer_size_required_, p_pointer_shape_info_);
            }
            pub inline fn mapDesktopSurface(self: *const T, p_locked_rect_: ?*DXGI_MAPPED_RECT) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).MapDesktopSurface(@as(*const IDXGIOutputDuplication, @ptrCast(self)), p_locked_rect_);
            }
            pub inline fn unMapDesktopSurface(self: *const T) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).UnMapDesktopSurface(@as(*const IDXGIOutputDuplication, @ptrCast(self)));
            }
            pub inline fn releaseFrame(self: *const T) HRESULT {
                return @as(*const IDXGIOutputDuplication.VTable, @ptrCast(self.vtable)).ReleaseFrame(@as(*const IDXGIOutputDuplication, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISurface2_Value = Guid.initString("aba496dd-b617-4cb8-a866-bc44d7eb1fa2");
pub const IID_IDXGISurface2 = &IID_IDXGISurface2_Value;
pub const IDXGISurface2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISurface1.VTable,
        GetResource: *const fn (
            self: *const IDXGISurface2,
            riid: ?*const Guid,
            pp_parent_resource: ?*?*anyopaque,
            p_subresource_index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISurface1.MethodMixin(T);
            pub inline fn getResource(self: *const T, riid_: ?*const Guid, pp_parent_resource_: ?*?*anyopaque, p_subresource_index_: ?*u32) HRESULT {
                return @as(*const IDXGISurface2.VTable, @ptrCast(self.vtable)).GetResource(@as(*const IDXGISurface2, @ptrCast(self)), riid_, pp_parent_resource_, p_subresource_index_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIResource1_Value = Guid.initString("30961379-4609-4a41-998e-54fe567ee0c1");
pub const IID_IDXGIResource1 = &IID_IDXGIResource1_Value;
pub const IDXGIResource1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIResource.VTable,
        CreateSubresourceSurface: *const fn (
            self: *const IDXGIResource1,
            index: u32,
            pp_surface: ?*?*IDXGISurface2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSharedHandle: *const fn (
            self: *const IDXGIResource1,
            p_attributes: ?*const SECURITY_ATTRIBUTES,
            dw_access: u32,
            lp_name: ?[*:0]const u16,
            p_handle: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIResource.MethodMixin(T);
            pub inline fn createSubresourceSurface(self: *const T, index_: u32, pp_surface_: ?*?*IDXGISurface2) HRESULT {
                return @as(*const IDXGIResource1.VTable, @ptrCast(self.vtable)).CreateSubresourceSurface(@as(*const IDXGIResource1, @ptrCast(self)), index_, pp_surface_);
            }
            pub inline fn createSharedHandle(self: *const T, p_attributes_: ?*const SECURITY_ATTRIBUTES, dw_access_: u32, lp_name_: ?[*:0]const u16, p_handle_: ?*?HANDLE) HRESULT {
                return @as(*const IDXGIResource1.VTable, @ptrCast(self.vtable)).CreateSharedHandle(@as(*const IDXGIResource1, @ptrCast(self)), p_attributes_, dw_access_, lp_name_, p_handle_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_PRIORITY = enum(i32) {
    LOW = 1,
    NORMAL = 2,
    HIGH = 3,
};
pub const DXGI_OFFER_RESOURCE_PRIORITY_LOW = DXGI_OFFER_RESOURCE_PRIORITY.LOW;
pub const DXGI_OFFER_RESOURCE_PRIORITY_NORMAL = DXGI_OFFER_RESOURCE_PRIORITY.NORMAL;
pub const DXGI_OFFER_RESOURCE_PRIORITY_HIGH = DXGI_OFFER_RESOURCE_PRIORITY.HIGH;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDevice2_Value = Guid.initString("05008617-fbfd-4051-a790-144884b4f6a9");
pub const IID_IDXGIDevice2 = &IID_IDXGIDevice2_Value;
pub const IDXGIDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice1.VTable,
        OfferResources: *const fn (
            self: *const IDXGIDevice2,
            num_resources: u32,
            pp_resources: [*]?*IDXGIResource,
            priority: DXGI_OFFER_RESOURCE_PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReclaimResources: *const fn (
            self: *const IDXGIDevice2,
            num_resources: u32,
            pp_resources: [*]?*IDXGIResource,
            p_discarded: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnqueueSetEvent: *const fn (
            self: *const IDXGIDevice2,
            h_event: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDevice1.MethodMixin(T);
            pub inline fn offerResources(self: *const T, num_resources_: u32, pp_resources_: [*]?*IDXGIResource, priority_: DXGI_OFFER_RESOURCE_PRIORITY) HRESULT {
                return @as(*const IDXGIDevice2.VTable, @ptrCast(self.vtable)).OfferResources(@as(*const IDXGIDevice2, @ptrCast(self)), num_resources_, pp_resources_, priority_);
            }
            pub inline fn reclaimResources(self: *const T, num_resources_: u32, pp_resources_: [*]?*IDXGIResource, p_discarded_: ?*BOOL) HRESULT {
                return @as(*const IDXGIDevice2.VTable, @ptrCast(self.vtable)).ReclaimResources(@as(*const IDXGIDevice2, @ptrCast(self)), num_resources_, pp_resources_, p_discarded_);
            }
            pub inline fn enqueueSetEvent(self: *const T, h_event_: ?HANDLE) HRESULT {
                return @as(*const IDXGIDevice2.VTable, @ptrCast(self.vtable)).EnqueueSetEvent(@as(*const IDXGIDevice2, @ptrCast(self)), h_event_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MODE_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    RefreshRate: DXGI_RATIONAL,
    Format: DXGI_FORMAT,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Stereo: BOOL,
};

pub const DXGI_SCALING = enum(i32) {
    STRETCH = 0,
    NONE = 1,
    ASPECT_RATIO_STRETCH = 2,
};
pub const DXGI_SCALING_STRETCH = DXGI_SCALING.STRETCH;
pub const DXGI_SCALING_NONE = DXGI_SCALING.NONE;
pub const DXGI_SCALING_ASPECT_RATIO_STRETCH = DXGI_SCALING.ASPECT_RATIO_STRETCH;

pub const DXGI_SWAP_CHAIN_DESC1 = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    Stereo: BOOL,
    SampleDesc: DXGI_SAMPLE_DESC,
    BufferUsage: u32,
    BufferCount: u32,
    Scaling: DXGI_SCALING,
    SwapEffect: DXGI_SWAP_EFFECT,
    AlphaMode: DXGI_ALPHA_MODE,
    Flags: u32,
};

pub const DXGI_SWAP_CHAIN_FULLSCREEN_DESC = extern struct {
    RefreshRate: DXGI_RATIONAL,
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER,
    Scaling: DXGI_MODE_SCALING,
    Windowed: BOOL,
};

pub const DXGI_PRESENT_PARAMETERS = extern struct {
    DirtyRectsCount: u32,
    pDirtyRects: ?*RECT,
    pScrollRect: ?*RECT,
    pScrollOffset: ?*POINT,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGISwapChain1_Value = Guid.initString("790a45f7-0d42-4876-983a-0a55cfe6f4aa");
pub const IID_IDXGISwapChain1 = &IID_IDXGISwapChain1_Value;
pub const IDXGISwapChain1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain.VTable,
        GetDesc1: *const fn (
            self: *const IDXGISwapChain1,
            p_desc: ?*DXGI_SWAP_CHAIN_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullscreenDesc: *const fn (
            self: *const IDXGISwapChain1,
            p_desc: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHwnd: *const fn (
            self: *const IDXGISwapChain1,
            p_hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCoreWindow: *const fn (
            self: *const IDXGISwapChain1,
            refiid: ?*const Guid,
            pp_unk: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Present1: *const fn (
            self: *const IDXGISwapChain1,
            sync_interval: u32,
            present_flags: u32,
            p_present_parameters: ?*const DXGI_PRESENT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTemporaryMonoSupported: *const fn (
            self: *const IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetRestrictToOutput: *const fn (
            self: *const IDXGISwapChain1,
            pp_restrict_to_output: ?*?*IDXGIOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: *const fn (
            self: *const IDXGISwapChain1,
            p_color: ?*const DXGI_RGBA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: *const fn (
            self: *const IDXGISwapChain1,
            p_color: ?*DXGI_RGBA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: *const fn (
            self: *const IDXGISwapChain1,
            rotation: DXGI_MODE_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRotation: *const fn (
            self: *const IDXGISwapChain1,
            p_rotation: ?*DXGI_MODE_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISwapChain.MethodMixin(T);
            pub inline fn getDesc1(self: *const T, p_desc_: ?*DXGI_SWAP_CHAIN_DESC1) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetDesc1(@as(*const IDXGISwapChain1, @ptrCast(self)), p_desc_);
            }
            pub inline fn getFullscreenDesc(self: *const T, p_desc_: ?*DXGI_SWAP_CHAIN_FULLSCREEN_DESC) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetFullscreenDesc(@as(*const IDXGISwapChain1, @ptrCast(self)), p_desc_);
            }
            pub inline fn getHwnd(self: *const T, p_hwnd_: ?*?HWND) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetHwnd(@as(*const IDXGISwapChain1, @ptrCast(self)), p_hwnd_);
            }
            pub inline fn getCoreWindow(self: *const T, refiid_: ?*const Guid, pp_unk_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetCoreWindow(@as(*const IDXGISwapChain1, @ptrCast(self)), refiid_, pp_unk_);
            }
            pub inline fn present1(self: *const T, sync_interval_: u32, present_flags_: u32, p_present_parameters_: ?*const DXGI_PRESENT_PARAMETERS) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).Present1(@as(*const IDXGISwapChain1, @ptrCast(self)), sync_interval_, present_flags_, p_present_parameters_);
            }
            pub inline fn isTemporaryMonoSupported(self: *const T) BOOL {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).IsTemporaryMonoSupported(@as(*const IDXGISwapChain1, @ptrCast(self)));
            }
            pub inline fn getRestrictToOutput(self: *const T, pp_restrict_to_output_: ?*?*IDXGIOutput) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetRestrictToOutput(@as(*const IDXGISwapChain1, @ptrCast(self)), pp_restrict_to_output_);
            }
            pub inline fn setBackgroundColor(self: *const T, p_color_: ?*const DXGI_RGBA) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IDXGISwapChain1, @ptrCast(self)), p_color_);
            }
            pub inline fn getBackgroundColor(self: *const T, p_color_: ?*DXGI_RGBA) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IDXGISwapChain1, @ptrCast(self)), p_color_);
            }
            pub inline fn setRotation(self: *const T, rotation_: DXGI_MODE_ROTATION) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IDXGISwapChain1, @ptrCast(self)), rotation_);
            }
            pub inline fn getRotation(self: *const T, p_rotation_: ?*DXGI_MODE_ROTATION) HRESULT {
                return @as(*const IDXGISwapChain1.VTable, @ptrCast(self.vtable)).GetRotation(@as(*const IDXGISwapChain1, @ptrCast(self)), p_rotation_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIFactory2_Value = Guid.initString("50c83a1c-e072-4c48-87b0-3630fa36a6d0");
pub const IID_IDXGIFactory2 = &IID_IDXGIFactory2_Value;
pub const IDXGIFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory1.VTable,
        IsWindowedStereoEnabled: *const fn (
            self: *const IDXGIFactory2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        CreateSwapChainForHwnd: *const fn (
            self: *const IDXGIFactory2,
            p_device: ?*IUnknown,
            h_wnd: ?HWND,
            p_desc: ?*const DXGI_SWAP_CHAIN_DESC1,
            p_fullscreen_desc: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC,
            p_restrict_to_output: ?*IDXGIOutput,
            pp_swap_chain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSwapChainForCoreWindow: *const fn (
            self: *const IDXGIFactory2,
            p_device: ?*IUnknown,
            p_window: ?*IUnknown,
            p_desc: ?*const DXGI_SWAP_CHAIN_DESC1,
            p_restrict_to_output: ?*IDXGIOutput,
            pp_swap_chain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSharedResourceAdapterLuid: *const fn (
            self: *const IDXGIFactory2,
            h_resource: ?HANDLE,
            p_luid: ?*LUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterStereoStatusWindow: *const fn (
            self: *const IDXGIFactory2,
            window_handle: ?HWND,
            w_msg: u32,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterStereoStatusEvent: *const fn (
            self: *const IDXGIFactory2,
            h_event: ?HANDLE,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterStereoStatus: *const fn (
            self: *const IDXGIFactory2,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        RegisterOcclusionStatusWindow: *const fn (
            self: *const IDXGIFactory2,
            window_handle: ?HWND,
            w_msg: u32,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterOcclusionStatusEvent: *const fn (
            self: *const IDXGIFactory2,
            h_event: ?HANDLE,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterOcclusionStatus: *const fn (
            self: *const IDXGIFactory2,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CreateSwapChainForComposition: *const fn (
            self: *const IDXGIFactory2,
            p_device: ?*IUnknown,
            p_desc: ?*const DXGI_SWAP_CHAIN_DESC1,
            p_restrict_to_output: ?*IDXGIOutput,
            pp_swap_chain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory1.MethodMixin(T);
            pub inline fn isWindowedStereoEnabled(self: *const T) BOOL {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).IsWindowedStereoEnabled(@as(*const IDXGIFactory2, @ptrCast(self)));
            }
            pub inline fn createSwapChainForHwnd(self: *const T, p_device_: ?*IUnknown, h_wnd_: ?HWND, p_desc_: ?*const DXGI_SWAP_CHAIN_DESC1, p_fullscreen_desc_: ?*const DXGI_SWAP_CHAIN_FULLSCREEN_DESC, p_restrict_to_output_: ?*IDXGIOutput, pp_swap_chain_: ?*?*IDXGISwapChain1) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).CreateSwapChainForHwnd(@as(*const IDXGIFactory2, @ptrCast(self)), p_device_, h_wnd_, p_desc_, p_fullscreen_desc_, p_restrict_to_output_, pp_swap_chain_);
            }
            pub inline fn createSwapChainForCoreWindow(self: *const T, p_device_: ?*IUnknown, p_window_: ?*IUnknown, p_desc_: ?*const DXGI_SWAP_CHAIN_DESC1, p_restrict_to_output_: ?*IDXGIOutput, pp_swap_chain_: ?*?*IDXGISwapChain1) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).CreateSwapChainForCoreWindow(@as(*const IDXGIFactory2, @ptrCast(self)), p_device_, p_window_, p_desc_, p_restrict_to_output_, pp_swap_chain_);
            }
            pub inline fn getSharedResourceAdapterLuid(self: *const T, h_resource_: ?HANDLE, p_luid_: ?*LUID) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).GetSharedResourceAdapterLuid(@as(*const IDXGIFactory2, @ptrCast(self)), h_resource_, p_luid_);
            }
            pub inline fn registerStereoStatusWindow(self: *const T, window_handle_: ?HWND, w_msg_: u32, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).RegisterStereoStatusWindow(@as(*const IDXGIFactory2, @ptrCast(self)), window_handle_, w_msg_, pdw_cookie_);
            }
            pub inline fn registerStereoStatusEvent(self: *const T, h_event_: ?HANDLE, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).RegisterStereoStatusEvent(@as(*const IDXGIFactory2, @ptrCast(self)), h_event_, pdw_cookie_);
            }
            pub inline fn unregisterStereoStatus(self: *const T, dw_cookie_: u32) void {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).UnregisterStereoStatus(@as(*const IDXGIFactory2, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn registerOcclusionStatusWindow(self: *const T, window_handle_: ?HWND, w_msg_: u32, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).RegisterOcclusionStatusWindow(@as(*const IDXGIFactory2, @ptrCast(self)), window_handle_, w_msg_, pdw_cookie_);
            }
            pub inline fn registerOcclusionStatusEvent(self: *const T, h_event_: ?HANDLE, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).RegisterOcclusionStatusEvent(@as(*const IDXGIFactory2, @ptrCast(self)), h_event_, pdw_cookie_);
            }
            pub inline fn unregisterOcclusionStatus(self: *const T, dw_cookie_: u32) void {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).UnregisterOcclusionStatus(@as(*const IDXGIFactory2, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn createSwapChainForComposition(self: *const T, p_device_: ?*IUnknown, p_desc_: ?*const DXGI_SWAP_CHAIN_DESC1, p_restrict_to_output_: ?*IDXGIOutput, pp_swap_chain_: ?*?*IDXGISwapChain1) HRESULT {
                return @as(*const IDXGIFactory2.VTable, @ptrCast(self.vtable)).CreateSwapChainForComposition(@as(*const IDXGIFactory2, @ptrCast(self)), p_device_, p_desc_, p_restrict_to_output_, pp_swap_chain_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GRAPHICS_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    PRIMITIVE_BOUNDARY = 1,
    TRIANGLE_BOUNDARY = 2,
    PIXEL_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PRIMITIVE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.TRIANGLE_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.PIXEL_BOUNDARY;
pub const DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_GRAPHICS_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_COMPUTE_PREEMPTION_GRANULARITY = enum(i32) {
    DMA_BUFFER_BOUNDARY = 0,
    DISPATCH_BOUNDARY = 1,
    THREAD_GROUP_BOUNDARY = 2,
    THREAD_BOUNDARY = 3,
    INSTRUCTION_BOUNDARY = 4,
};
pub const DXGI_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DMA_BUFFER_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.DISPATCH_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_GROUP_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_THREAD_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.THREAD_BOUNDARY;
pub const DXGI_COMPUTE_PREEMPTION_INSTRUCTION_BOUNDARY = DXGI_COMPUTE_PREEMPTION_GRANULARITY.INSTRUCTION_BOUNDARY;

pub const DXGI_ADAPTER_DESC2 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: u32,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIAdapter2_Value = Guid.initString("0aa1ae0a-fa0e-4b84-8644-e05ff8e5acb5");
pub const IID_IDXGIAdapter2 = &IID_IDXGIAdapter2_Value;
pub const IDXGIAdapter2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter1.VTable,
        GetDesc2: *const fn (
            self: *const IDXGIAdapter2,
            p_desc: ?*DXGI_ADAPTER_DESC2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIAdapter1.MethodMixin(T);
            pub inline fn getDesc2(self: *const T, p_desc_: ?*DXGI_ADAPTER_DESC2) HRESULT {
                return @as(*const IDXGIAdapter2.VTable, @ptrCast(self.vtable)).GetDesc2(@as(*const IDXGIAdapter2, @ptrCast(self)), p_desc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIOutput1_Value = Guid.initString("00cddea8-939b-4b83-a340-a685226666cc");
pub const IID_IDXGIOutput1 = &IID_IDXGIOutput1_Value;
pub const IDXGIOutput1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput.VTable,
        GetDisplayModeList1: *const fn (
            self: *const IDXGIOutput1,
            enum_format: DXGI_FORMAT,
            flags: u32,
            p_num_modes: ?*u32,
            p_desc: ?[*]DXGI_MODE_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestMatchingMode1: *const fn (
            self: *const IDXGIOutput1,
            p_mode_to_match: ?*const DXGI_MODE_DESC1,
            p_closest_match: ?*DXGI_MODE_DESC1,
            p_concerned_device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplaySurfaceData1: *const fn (
            self: *const IDXGIOutput1,
            p_destination: ?*IDXGIResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DuplicateOutput: *const fn (
            self: *const IDXGIOutput1,
            p_device: ?*IUnknown,
            pp_output_duplication: ?*?*IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput.MethodMixin(T);
            pub inline fn getDisplayModeList1(self: *const T, enum_format_: DXGI_FORMAT, flags_: u32, p_num_modes_: ?*u32, p_desc_: ?[*]DXGI_MODE_DESC1) HRESULT {
                return @as(*const IDXGIOutput1.VTable, @ptrCast(self.vtable)).GetDisplayModeList1(@as(*const IDXGIOutput1, @ptrCast(self)), enum_format_, flags_, p_num_modes_, p_desc_);
            }
            pub inline fn findClosestMatchingMode1(self: *const T, p_mode_to_match_: ?*const DXGI_MODE_DESC1, p_closest_match_: ?*DXGI_MODE_DESC1, p_concerned_device_: ?*IUnknown) HRESULT {
                return @as(*const IDXGIOutput1.VTable, @ptrCast(self.vtable)).FindClosestMatchingMode1(@as(*const IDXGIOutput1, @ptrCast(self)), p_mode_to_match_, p_closest_match_, p_concerned_device_);
            }
            pub inline fn getDisplaySurfaceData1(self: *const T, p_destination_: ?*IDXGIResource) HRESULT {
                return @as(*const IDXGIOutput1.VTable, @ptrCast(self.vtable)).GetDisplaySurfaceData1(@as(*const IDXGIOutput1, @ptrCast(self)), p_destination_);
            }
            pub inline fn duplicateOutput(self: *const T, p_device_: ?*IUnknown, pp_output_duplication_: ?*?*IDXGIOutputDuplication) HRESULT {
                return @as(*const IDXGIOutput1.VTable, @ptrCast(self.vtable)).DuplicateOutput(@as(*const IDXGIOutput1, @ptrCast(self)), p_device_, pp_output_duplication_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDevice3_Value = Guid.initString("6007896c-3244-4afd-bf18-a6d3beda5023");
pub const IID_IDXGIDevice3 = &IID_IDXGIDevice3_Value;
pub const IDXGIDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice2.VTable,
        Trim: *const fn (
            self: *const IDXGIDevice3,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDevice2.MethodMixin(T);
            pub inline fn trim(self: *const T) void {
                return @as(*const IDXGIDevice3.VTable, @ptrCast(self.vtable)).Trim(@as(*const IDXGIDevice3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MATRIX_3X2_F = extern struct {
    _11: f32,
    _12: f32,
    _21: f32,
    _22: f32,
    _31: f32,
    _32: f32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChain2_Value = Guid.initString("a8be2ac4-199f-4946-b331-79599fb98de7");
pub const IID_IDXGISwapChain2 = &IID_IDXGISwapChain2_Value;
pub const IDXGISwapChain2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain1.VTable,
        SetSourceSize: *const fn (
            self: *const IDXGISwapChain2,
            width: u32,
            height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceSize: *const fn (
            self: *const IDXGISwapChain2,
            p_width: ?*u32,
            p_height: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaximumFrameLatency: *const fn (
            self: *const IDXGISwapChain2,
            max_latency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumFrameLatency: *const fn (
            self: *const IDXGISwapChain2,
            p_max_latency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameLatencyWaitableObject: *const fn (
            self: *const IDXGISwapChain2,
        ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        SetMatrixTransform: *const fn (
            self: *const IDXGISwapChain2,
            p_matrix: ?*const DXGI_MATRIX_3X2_F,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMatrixTransform: *const fn (
            self: *const IDXGISwapChain2,
            p_matrix: ?*DXGI_MATRIX_3X2_F,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISwapChain1.MethodMixin(T);
            pub inline fn setSourceSize(self: *const T, width_: u32, height_: u32) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).SetSourceSize(@as(*const IDXGISwapChain2, @ptrCast(self)), width_, height_);
            }
            pub inline fn getSourceSize(self: *const T, p_width_: ?*u32, p_height_: ?*u32) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).GetSourceSize(@as(*const IDXGISwapChain2, @ptrCast(self)), p_width_, p_height_);
            }
            pub inline fn setMaximumFrameLatency(self: *const T, max_latency_: u32) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).SetMaximumFrameLatency(@as(*const IDXGISwapChain2, @ptrCast(self)), max_latency_);
            }
            pub inline fn getMaximumFrameLatency(self: *const T, p_max_latency_: ?*u32) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).GetMaximumFrameLatency(@as(*const IDXGISwapChain2, @ptrCast(self)), p_max_latency_);
            }
            pub inline fn getFrameLatencyWaitableObject(self: *const T) ?HANDLE {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).GetFrameLatencyWaitableObject(@as(*const IDXGISwapChain2, @ptrCast(self)));
            }
            pub inline fn setMatrixTransform(self: *const T, p_matrix_: ?*const DXGI_MATRIX_3X2_F) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).SetMatrixTransform(@as(*const IDXGISwapChain2, @ptrCast(self)), p_matrix_);
            }
            pub inline fn getMatrixTransform(self: *const T, p_matrix_: ?*DXGI_MATRIX_3X2_F) HRESULT {
                return @as(*const IDXGISwapChain2.VTable, @ptrCast(self.vtable)).GetMatrixTransform(@as(*const IDXGISwapChain2, @ptrCast(self)), p_matrix_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput2_Value = Guid.initString("595e39d1-2724-4663-99b1-da969de28364");
pub const IID_IDXGIOutput2 = &IID_IDXGIOutput2_Value;
pub const IDXGIOutput2 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput1.VTable,
        SupportsOverlays: *const fn (
            self: *const IDXGIOutput2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput1.MethodMixin(T);
            pub inline fn supportsOverlays(self: *const T) BOOL {
                return @as(*const IDXGIOutput2.VTable, @ptrCast(self.vtable)).SupportsOverlays(@as(*const IDXGIOutput2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactory3_Value = Guid.initString("25483823-cd46-4c7d-86ca-47aa95b837bd");
pub const IID_IDXGIFactory3 = &IID_IDXGIFactory3_Value;
pub const IDXGIFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory2.VTable,
        GetCreationFlags: *const fn (
            self: *const IDXGIFactory3,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory2.MethodMixin(T);
            pub inline fn getCreationFlags(self: *const T) u32 {
                return @as(*const IDXGIFactory3.VTable, @ptrCast(self.vtable)).GetCreationFlags(@as(*const IDXGIFactory3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DECODE_SWAP_CHAIN_DESC = extern struct {
    Flags: u32,
};

pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS = enum(i32) {
    NOMINAL_RANGE = 1,
    BT709 = 2,
    xvYCC = 4,
};
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_NOMINAL_RANGE = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.NOMINAL_RANGE;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_BT709 = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.BT709;
pub const DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_xvYCC = DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS.xvYCC;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDecodeSwapChain_Value = Guid.initString("2633066b-4514-4c7a-8fd8-12ea98059d18");
pub const IID_IDXGIDecodeSwapChain = &IID_IDXGIDecodeSwapChain_Value;
pub const IDXGIDecodeSwapChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PresentBuffer: *const fn (
            self: *const IDXGIDecodeSwapChain,
            buffer_to_present: u32,
            sync_interval: u32,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceRect: *const fn (
            self: *const IDXGIDecodeSwapChain,
            p_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTargetRect: *const fn (
            self: *const IDXGIDecodeSwapChain,
            p_rect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestSize: *const fn (
            self: *const IDXGIDecodeSwapChain,
            width: u32,
            height: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceRect: *const fn (
            self: *const IDXGIDecodeSwapChain,
            p_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetRect: *const fn (
            self: *const IDXGIDecodeSwapChain,
            p_rect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestSize: *const fn (
            self: *const IDXGIDecodeSwapChain,
            p_width: ?*u32,
            p_height: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorSpace: *const fn (
            self: *const IDXGIDecodeSwapChain,
            color_space: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorSpace: *const fn (
            self: *const IDXGIDecodeSwapChain,
        ) callconv(@import("std").os.windows.WINAPI) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn presentBuffer(self: *const T, buffer_to_present_: u32, sync_interval_: u32, flags_: u32) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).PresentBuffer(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), buffer_to_present_, sync_interval_, flags_);
            }
            pub inline fn setSourceRect(self: *const T, p_rect_: ?*const RECT) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).SetSourceRect(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), p_rect_);
            }
            pub inline fn setTargetRect(self: *const T, p_rect_: ?*const RECT) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).SetTargetRect(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), p_rect_);
            }
            pub inline fn setDestSize(self: *const T, width_: u32, height_: u32) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).SetDestSize(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), width_, height_);
            }
            pub inline fn getSourceRect(self: *const T, p_rect_: ?*RECT) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).GetSourceRect(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), p_rect_);
            }
            pub inline fn getTargetRect(self: *const T, p_rect_: ?*RECT) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).GetTargetRect(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), p_rect_);
            }
            pub inline fn getDestSize(self: *const T, p_width_: ?*u32, p_height_: ?*u32) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).GetDestSize(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), p_width_, p_height_);
            }
            pub inline fn setColorSpace(self: *const T, color_space_: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) HRESULT {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).SetColorSpace(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)), color_space_);
            }
            pub inline fn getColorSpace(self: *const T) DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
                return @as(*const IDXGIDecodeSwapChain.VTable, @ptrCast(self.vtable)).GetColorSpace(@as(*const IDXGIDecodeSwapChain, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIFactoryMedia_Value = Guid.initString("41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12");
pub const IID_IDXGIFactoryMedia = &IID_IDXGIFactoryMedia_Value;
pub const IDXGIFactoryMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSwapChainForCompositionSurfaceHandle: *const fn (
            self: *const IDXGIFactoryMedia,
            p_device: ?*IUnknown,
            h_surface: ?HANDLE,
            p_desc: ?*const DXGI_SWAP_CHAIN_DESC1,
            p_restrict_to_output: ?*IDXGIOutput,
            pp_swap_chain: ?*?*IDXGISwapChain1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDecodeSwapChainForCompositionSurfaceHandle: *const fn (
            self: *const IDXGIFactoryMedia,
            p_device: ?*IUnknown,
            h_surface: ?HANDLE,
            p_desc: ?*DXGI_DECODE_SWAP_CHAIN_DESC,
            p_yuv_decode_buffers: ?*IDXGIResource,
            p_restrict_to_output: ?*IDXGIOutput,
            pp_swap_chain: ?*?*IDXGIDecodeSwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn createSwapChainForCompositionSurfaceHandle(self: *const T, p_device_: ?*IUnknown, h_surface_: ?HANDLE, p_desc_: ?*const DXGI_SWAP_CHAIN_DESC1, p_restrict_to_output_: ?*IDXGIOutput, pp_swap_chain_: ?*?*IDXGISwapChain1) HRESULT {
                return @as(*const IDXGIFactoryMedia.VTable, @ptrCast(self.vtable)).CreateSwapChainForCompositionSurfaceHandle(@as(*const IDXGIFactoryMedia, @ptrCast(self)), p_device_, h_surface_, p_desc_, p_restrict_to_output_, pp_swap_chain_);
            }
            pub inline fn createDecodeSwapChainForCompositionSurfaceHandle(self: *const T, p_device_: ?*IUnknown, h_surface_: ?HANDLE, p_desc_: ?*DXGI_DECODE_SWAP_CHAIN_DESC, p_yuv_decode_buffers_: ?*IDXGIResource, p_restrict_to_output_: ?*IDXGIOutput, pp_swap_chain_: ?*?*IDXGIDecodeSwapChain) HRESULT {
                return @as(*const IDXGIFactoryMedia.VTable, @ptrCast(self.vtable)).CreateDecodeSwapChainForCompositionSurfaceHandle(@as(*const IDXGIFactoryMedia, @ptrCast(self)), p_device_, h_surface_, p_desc_, p_yuv_decode_buffers_, p_restrict_to_output_, pp_swap_chain_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FRAME_PRESENTATION_MODE = enum(i32) {
    COMPOSED = 0,
    OVERLAY = 1,
    NONE = 2,
    COMPOSITION_FAILURE = 3,
};
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSED = DXGI_FRAME_PRESENTATION_MODE.COMPOSED;
pub const DXGI_FRAME_PRESENTATION_MODE_OVERLAY = DXGI_FRAME_PRESENTATION_MODE.OVERLAY;
pub const DXGI_FRAME_PRESENTATION_MODE_NONE = DXGI_FRAME_PRESENTATION_MODE.NONE;
pub const DXGI_FRAME_PRESENTATION_MODE_COMPOSITION_FAILURE = DXGI_FRAME_PRESENTATION_MODE.COMPOSITION_FAILURE;

pub const DXGI_FRAME_STATISTICS_MEDIA = extern struct {
    PresentCount: u32,
    PresentRefreshCount: u32,
    SyncRefreshCount: u32,
    SyncQPCTime: LARGE_INTEGER,
    SyncGPUTime: LARGE_INTEGER,
    CompositionMode: DXGI_FRAME_PRESENTATION_MODE,
    ApprovedPresentDuration: u32,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGISwapChainMedia_Value = Guid.initString("dd95b90b-f05f-4f6a-bd65-25bfb264bd84");
pub const IID_IDXGISwapChainMedia = &IID_IDXGISwapChainMedia_Value;
pub const IDXGISwapChainMedia = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameStatisticsMedia: *const fn (
            self: *const IDXGISwapChainMedia,
            p_stats: ?*DXGI_FRAME_STATISTICS_MEDIA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPresentDuration: *const fn (
            self: *const IDXGISwapChainMedia,
            duration: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckPresentDurationSupport: *const fn (
            self: *const IDXGISwapChainMedia,
            desired_present_duration: u32,
            p_closest_smaller_present_duration: ?*u32,
            p_closest_larger_present_duration: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn getFrameStatisticsMedia(self: *const T, p_stats_: ?*DXGI_FRAME_STATISTICS_MEDIA) HRESULT {
                return @as(*const IDXGISwapChainMedia.VTable, @ptrCast(self.vtable)).GetFrameStatisticsMedia(@as(*const IDXGISwapChainMedia, @ptrCast(self)), p_stats_);
            }
            pub inline fn setPresentDuration(self: *const T, duration_: u32) HRESULT {
                return @as(*const IDXGISwapChainMedia.VTable, @ptrCast(self.vtable)).SetPresentDuration(@as(*const IDXGISwapChainMedia, @ptrCast(self)), duration_);
            }
            pub inline fn checkPresentDurationSupport(self: *const T, desired_present_duration_: u32, p_closest_smaller_present_duration_: ?*u32, p_closest_larger_present_duration_: ?*u32) HRESULT {
                return @as(*const IDXGISwapChainMedia.VTable, @ptrCast(self.vtable)).CheckPresentDurationSupport(@as(*const IDXGISwapChainMedia, @ptrCast(self)), desired_present_duration_, p_closest_smaller_present_duration_, p_closest_larger_present_duration_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_SUPPORT_FLAG = enum(i32) {
    DIRECT = 1,
    SCALING = 2,
};
pub const DXGI_OVERLAY_SUPPORT_FLAG_DIRECT = DXGI_OVERLAY_SUPPORT_FLAG.DIRECT;
pub const DXGI_OVERLAY_SUPPORT_FLAG_SCALING = DXGI_OVERLAY_SUPPORT_FLAG.SCALING;

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIOutput3_Value = Guid.initString("8a6bb301-7e7e-41f4-a8e0-5b32f7f99b18");
pub const IID_IDXGIOutput3 = &IID_IDXGIOutput3_Value;
pub const IDXGIOutput3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput2.VTable,
        CheckOverlaySupport: *const fn (
            self: *const IDXGIOutput3,
            enum_format: DXGI_FORMAT,
            p_concerned_device: ?*IUnknown,
            p_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput2.MethodMixin(T);
            pub inline fn checkOverlaySupport(self: *const T, enum_format_: DXGI_FORMAT, p_concerned_device_: ?*IUnknown, p_flags_: ?*u32) HRESULT {
                return @as(*const IDXGIOutput3.VTable, @ptrCast(self.vtable)).CheckOverlaySupport(@as(*const IDXGIOutput3, @ptrCast(self)), enum_format_, p_concerned_device_, p_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    PRESENT = 1,
    OVERLAY_PRESENT = 2,
};
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.PRESENT;
pub const DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT = DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG.OVERLAY_PRESENT;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGISwapChain3_Value = Guid.initString("94d99bdb-f1f8-4ab0-b236-7da0170edab1");
pub const IID_IDXGISwapChain3 = &IID_IDXGISwapChain3_Value;
pub const IDXGISwapChain3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain2.VTable,
        GetCurrentBackBufferIndex: *const fn (
            self: *const IDXGISwapChain3,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CheckColorSpaceSupport: *const fn (
            self: *const IDXGISwapChain3,
            color_space: DXGI_COLOR_SPACE_TYPE,
            p_color_space_support: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorSpace1: *const fn (
            self: *const IDXGISwapChain3,
            color_space: DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBuffers1: *const fn (
            self: *const IDXGISwapChain3,
            buffer_count: u32,
            width: u32,
            height: u32,
            format: DXGI_FORMAT,
            swap_chain_flags: u32,
            p_creation_node_mask: [*]const u32,
            pp_present_queue: [*]?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISwapChain2.MethodMixin(T);
            pub inline fn getCurrentBackBufferIndex(self: *const T) u32 {
                return @as(*const IDXGISwapChain3.VTable, @ptrCast(self.vtable)).GetCurrentBackBufferIndex(@as(*const IDXGISwapChain3, @ptrCast(self)));
            }
            pub inline fn checkColorSpaceSupport(self: *const T, color_space_: DXGI_COLOR_SPACE_TYPE, p_color_space_support_: ?*u32) HRESULT {
                return @as(*const IDXGISwapChain3.VTable, @ptrCast(self.vtable)).CheckColorSpaceSupport(@as(*const IDXGISwapChain3, @ptrCast(self)), color_space_, p_color_space_support_);
            }
            pub inline fn setColorSpace1(self: *const T, color_space_: DXGI_COLOR_SPACE_TYPE) HRESULT {
                return @as(*const IDXGISwapChain3.VTable, @ptrCast(self.vtable)).SetColorSpace1(@as(*const IDXGISwapChain3, @ptrCast(self)), color_space_);
            }
            pub inline fn resizeBuffers1(self: *const T, buffer_count_: u32, width_: u32, height_: u32, format_: DXGI_FORMAT, swap_chain_flags_: u32, p_creation_node_mask_: [*]const u32, pp_present_queue_: [*]?*IUnknown) HRESULT {
                return @as(*const IDXGISwapChain3.VTable, @ptrCast(self.vtable)).ResizeBuffers1(@as(*const IDXGISwapChain3, @ptrCast(self)), buffer_count_, width_, height_, format_, swap_chain_flags_, p_creation_node_mask_, pp_present_queue_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG = enum(i32) {
    T = 1,
};
pub const DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT = DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG.T;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput4_Value = Guid.initString("dc7dca35-2196-414d-9f53-617884032a60");
pub const IID_IDXGIOutput4 = &IID_IDXGIOutput4_Value;
pub const IDXGIOutput4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput3.VTable,
        CheckOverlayColorSpaceSupport: *const fn (
            self: *const IDXGIOutput4,
            format: DXGI_FORMAT,
            color_space: DXGI_COLOR_SPACE_TYPE,
            p_concerned_device: ?*IUnknown,
            p_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput3.MethodMixin(T);
            pub inline fn checkOverlayColorSpaceSupport(self: *const T, format_: DXGI_FORMAT, color_space_: DXGI_COLOR_SPACE_TYPE, p_concerned_device_: ?*IUnknown, p_flags_: ?*u32) HRESULT {
                return @as(*const IDXGIOutput4.VTable, @ptrCast(self.vtable)).CheckOverlayColorSpaceSupport(@as(*const IDXGIOutput4, @ptrCast(self)), format_, color_space_, p_concerned_device_, p_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXGIFactory4_Value = Guid.initString("1bc6ea02-ef36-464f-bf0c-21ca39e5168a");
pub const IID_IDXGIFactory4 = &IID_IDXGIFactory4_Value;
pub const IDXGIFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory3.VTable,
        EnumAdapterByLuid: *const fn (
            self: *const IDXGIFactory4,
            adapter_luid: LUID,
            riid: ?*const Guid,
            ppv_adapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumWarpAdapter: *const fn (
            self: *const IDXGIFactory4,
            riid: ?*const Guid,
            ppv_adapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory3.MethodMixin(T);
            pub inline fn enumAdapterByLuid(self: *const T, adapter_luid_: LUID, riid_: ?*const Guid, ppv_adapter_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGIFactory4.VTable, @ptrCast(self.vtable)).EnumAdapterByLuid(@as(*const IDXGIFactory4, @ptrCast(self)), adapter_luid_, riid_, ppv_adapter_);
            }
            pub inline fn enumWarpAdapter(self: *const T, riid_: ?*const Guid, ppv_adapter_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGIFactory4.VTable, @ptrCast(self.vtable)).EnumWarpAdapter(@as(*const IDXGIFactory4, @ptrCast(self)), riid_, ppv_adapter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_MEMORY_SEGMENT_GROUP = enum(i32) {
    LOCAL = 0,
    NON_LOCAL = 1,
};
pub const DXGI_MEMORY_SEGMENT_GROUP_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.LOCAL;
pub const DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL = DXGI_MEMORY_SEGMENT_GROUP.NON_LOCAL;

pub const DXGI_QUERY_VIDEO_MEMORY_INFO = extern struct {
    Budget: u64,
    CurrentUsage: u64,
    AvailableForReservation: u64,
    CurrentReservation: u64,
};

const IID_IDXGIAdapter3_Value = Guid.initString("645967a4-1392-4310-a798-8053ce3e93fd");
pub const IID_IDXGIAdapter3 = &IID_IDXGIAdapter3_Value;
pub const IDXGIAdapter3 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter2.VTable,
        RegisterHardwareContentProtectionTeardownStatusEvent: *const fn (
            self: *const IDXGIAdapter3,
            h_event: ?HANDLE,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterHardwareContentProtectionTeardownStatus: *const fn (
            self: *const IDXGIAdapter3,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        QueryVideoMemoryInfo: *const fn (
            self: *const IDXGIAdapter3,
            node_index: u32,
            memory_segment_group: DXGI_MEMORY_SEGMENT_GROUP,
            p_video_memory_info: ?*DXGI_QUERY_VIDEO_MEMORY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoMemoryReservation: *const fn (
            self: *const IDXGIAdapter3,
            node_index: u32,
            memory_segment_group: DXGI_MEMORY_SEGMENT_GROUP,
            reservation: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterVideoMemoryBudgetChangeNotificationEvent: *const fn (
            self: *const IDXGIAdapter3,
            h_event: ?HANDLE,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterVideoMemoryBudgetChangeNotification: *const fn (
            self: *const IDXGIAdapter3,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIAdapter2.MethodMixin(T);
            pub inline fn registerHardwareContentProtectionTeardownStatusEvent(self: *const T, h_event_: ?HANDLE, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).RegisterHardwareContentProtectionTeardownStatusEvent(@as(*const IDXGIAdapter3, @ptrCast(self)), h_event_, pdw_cookie_);
            }
            pub inline fn unregisterHardwareContentProtectionTeardownStatus(self: *const T, dw_cookie_: u32) void {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).UnregisterHardwareContentProtectionTeardownStatus(@as(*const IDXGIAdapter3, @ptrCast(self)), dw_cookie_);
            }
            pub inline fn queryVideoMemoryInfo(self: *const T, node_index_: u32, memory_segment_group_: DXGI_MEMORY_SEGMENT_GROUP, p_video_memory_info_: ?*DXGI_QUERY_VIDEO_MEMORY_INFO) HRESULT {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).QueryVideoMemoryInfo(@as(*const IDXGIAdapter3, @ptrCast(self)), node_index_, memory_segment_group_, p_video_memory_info_);
            }
            pub inline fn setVideoMemoryReservation(self: *const T, node_index_: u32, memory_segment_group_: DXGI_MEMORY_SEGMENT_GROUP, reservation_: u64) HRESULT {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).SetVideoMemoryReservation(@as(*const IDXGIAdapter3, @ptrCast(self)), node_index_, memory_segment_group_, reservation_);
            }
            pub inline fn registerVideoMemoryBudgetChangeNotificationEvent(self: *const T, h_event_: ?HANDLE, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).RegisterVideoMemoryBudgetChangeNotificationEvent(@as(*const IDXGIAdapter3, @ptrCast(self)), h_event_, pdw_cookie_);
            }
            pub inline fn unregisterVideoMemoryBudgetChangeNotification(self: *const T, dw_cookie_: u32) void {
                return @as(*const IDXGIAdapter3.VTable, @ptrCast(self.vtable)).UnregisterVideoMemoryBudgetChangeNotification(@as(*const IDXGIAdapter3, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTDUPL_FLAG = enum(i32) {
    Y = 1,
};
pub const DXGI_OUTDUPL_COMPOSITED_UI_CAPTURE_ONLY = DXGI_OUTDUPL_FLAG.Y;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput5_Value = Guid.initString("80a07424-ab52-42eb-833c-0c42fd282d98");
pub const IID_IDXGIOutput5 = &IID_IDXGIOutput5_Value;
pub const IDXGIOutput5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput4.VTable,
        DuplicateOutput1: *const fn (
            self: *const IDXGIOutput5,
            p_device: ?*IUnknown,
            flags: u32,
            supported_formats_count: u32,
            p_supported_formats: [*]const DXGI_FORMAT,
            pp_output_duplication: ?*?*IDXGIOutputDuplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput4.MethodMixin(T);
            pub inline fn duplicateOutput1(self: *const T, p_device_: ?*IUnknown, flags_: u32, supported_formats_count_: u32, p_supported_formats_: [*]const DXGI_FORMAT, pp_output_duplication_: ?*?*IDXGIOutputDuplication) HRESULT {
                return @as(*const IDXGIOutput5.VTable, @ptrCast(self.vtable)).DuplicateOutput1(@as(*const IDXGIOutput5, @ptrCast(self)), p_device_, flags_, supported_formats_count_, p_supported_formats_, pp_output_duplication_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_HDR_METADATA_TYPE = enum(i32) {
    NONE = 0,
    HDR10 = 1,
    HDR10PLUS = 2,
};
pub const DXGI_HDR_METADATA_TYPE_NONE = DXGI_HDR_METADATA_TYPE.NONE;
pub const DXGI_HDR_METADATA_TYPE_HDR10 = DXGI_HDR_METADATA_TYPE.HDR10;
pub const DXGI_HDR_METADATA_TYPE_HDR10PLUS = DXGI_HDR_METADATA_TYPE.HDR10PLUS;

pub const DXGI_HDR_METADATA_HDR10 = extern struct {
    RedPrimary: [2]u16,
    GreenPrimary: [2]u16,
    BluePrimary: [2]u16,
    WhitePoint: [2]u16,
    MaxMasteringLuminance: u32,
    MinMasteringLuminance: u32,
    MaxContentLightLevel: u16,
    MaxFrameAverageLightLevel: u16,
};

pub const DXGI_HDR_METADATA_HDR10PLUS = extern struct {
    Data: [72]u8,
};

const IID_IDXGISwapChain4_Value = Guid.initString("3d585d5a-bd4a-489e-b1f4-3dbcb6452ffb");
pub const IID_IDXGISwapChain4 = &IID_IDXGISwapChain4_Value;
pub const IDXGISwapChain4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGISwapChain3.VTable,
        SetHDRMetaData: *const fn (
            self: *const IDXGISwapChain4,
            type: DXGI_HDR_METADATA_TYPE,
            size: u32,
            p_meta_data: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGISwapChain3.MethodMixin(T);
            pub inline fn setHDRMetaData(self: *const T, type_: DXGI_HDR_METADATA_TYPE, size_: u32, p_meta_data_: ?[*]u8) HRESULT {
                return @as(*const IDXGISwapChain4.VTable, @ptrCast(self.vtable)).SetHDRMetaData(@as(*const IDXGISwapChain4, @ptrCast(self)), type_, size_, p_meta_data_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OFFER_RESOURCE_FLAGS = enum(i32) {
    T = 1,
};
pub const DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT = DXGI_OFFER_RESOURCE_FLAGS.T;

pub const DXGI_RECLAIM_RESOURCE_RESULTS = enum(i32) {
    OK = 0,
    DISCARDED = 1,
    NOT_COMMITTED = 2,
};
pub const DXGI_RECLAIM_RESOURCE_RESULT_OK = DXGI_RECLAIM_RESOURCE_RESULTS.OK;
pub const DXGI_RECLAIM_RESOURCE_RESULT_DISCARDED = DXGI_RECLAIM_RESOURCE_RESULTS.DISCARDED;
pub const DXGI_RECLAIM_RESOURCE_RESULT_NOT_COMMITTED = DXGI_RECLAIM_RESOURCE_RESULTS.NOT_COMMITTED;

const IID_IDXGIDevice4_Value = Guid.initString("95b4f95f-d8da-4ca4-9ee6-3b76d5968a10");
pub const IID_IDXGIDevice4 = &IID_IDXGIDevice4_Value;
pub const IDXGIDevice4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDevice3.VTable,
        OfferResources1: *const fn (
            self: *const IDXGIDevice4,
            num_resources: u32,
            pp_resources: [*]?*IDXGIResource,
            priority: DXGI_OFFER_RESOURCE_PRIORITY,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReclaimResources1: *const fn (
            self: *const IDXGIDevice4,
            num_resources: u32,
            pp_resources: [*]?*IDXGIResource,
            p_results: ?*DXGI_RECLAIM_RESOURCE_RESULTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDevice3.MethodMixin(T);
            pub inline fn offerResources1(self: *const T, num_resources_: u32, pp_resources_: [*]?*IDXGIResource, priority_: DXGI_OFFER_RESOURCE_PRIORITY, flags_: u32) HRESULT {
                return @as(*const IDXGIDevice4.VTable, @ptrCast(self.vtable)).OfferResources1(@as(*const IDXGIDevice4, @ptrCast(self)), num_resources_, pp_resources_, priority_, flags_);
            }
            pub inline fn reclaimResources1(self: *const T, num_resources_: u32, pp_resources_: [*]?*IDXGIResource, p_results_: ?*DXGI_RECLAIM_RESOURCE_RESULTS) HRESULT {
                return @as(*const IDXGIDevice4.VTable, @ptrCast(self.vtable)).ReclaimResources1(@as(*const IDXGIDevice4, @ptrCast(self)), num_resources_, pp_resources_, p_results_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_FEATURE = enum(i32) {
    G = 0,
};
pub const DXGI_FEATURE_PRESENT_ALLOW_TEARING = DXGI_FEATURE.G;

const IID_IDXGIFactory5_Value = Guid.initString("7632e1f5-ee65-4dca-87fd-84cd75f8838d");
pub const IID_IDXGIFactory5 = &IID_IDXGIFactory5_Value;
pub const IDXGIFactory5 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory4.VTable,
        CheckFeatureSupport: *const fn (
            self: *const IDXGIFactory5,
            feature: DXGI_FEATURE,
            // TODO: what to do with BytesParamIndex 2?
            p_feature_support_data: ?*anyopaque,
            feature_support_data_size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory4.MethodMixin(T);
            pub inline fn checkFeatureSupport(self: *const T, feature_: DXGI_FEATURE, p_feature_support_data_: ?*anyopaque, feature_support_data_size_: u32) HRESULT {
                return @as(*const IDXGIFactory5.VTable, @ptrCast(self.vtable)).CheckFeatureSupport(@as(*const IDXGIFactory5, @ptrCast(self)), feature_, p_feature_support_data_, feature_support_data_size_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_ADAPTER_FLAG3 = enum(u32) {
    NONE = 0,
    REMOTE = 1,
    SOFTWARE = 2,
    ACG_COMPATIBLE = 4,
    SUPPORT_MONITORED_FENCES = 8,
    SUPPORT_NON_MONITORED_FENCES = 16,
    KEYED_MUTEX_CONFORMANCE = 32,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REMOTE: u1 = 0,
        SOFTWARE: u1 = 0,
        ACG_COMPATIBLE: u1 = 0,
        SUPPORT_MONITORED_FENCES: u1 = 0,
        SUPPORT_NON_MONITORED_FENCES: u1 = 0,
        KEYED_MUTEX_CONFORMANCE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) DXGI_ADAPTER_FLAG3 {
        return @as(DXGI_ADAPTER_FLAG3, @enumFromInt((if (o.NONE == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.NONE) else 0) | (if (o.REMOTE == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.REMOTE) else 0) | (if (o.SOFTWARE == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.SOFTWARE) else 0) | (if (o.ACG_COMPATIBLE == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE) else 0) | (if (o.SUPPORT_MONITORED_FENCES == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES) else 0) | (if (o.SUPPORT_NON_MONITORED_FENCES == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES) else 0) | (if (o.KEYED_MUTEX_CONFORMANCE == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE) else 0) | (if (o.FORCE_DWORD == 1) @intFromEnum(DXGI_ADAPTER_FLAG3.FORCE_DWORD) else 0)));
    }
};
pub const DXGI_ADAPTER_FLAG3_NONE = DXGI_ADAPTER_FLAG3.NONE;
pub const DXGI_ADAPTER_FLAG3_REMOTE = DXGI_ADAPTER_FLAG3.REMOTE;
pub const DXGI_ADAPTER_FLAG3_SOFTWARE = DXGI_ADAPTER_FLAG3.SOFTWARE;
pub const DXGI_ADAPTER_FLAG3_ACG_COMPATIBLE = DXGI_ADAPTER_FLAG3.ACG_COMPATIBLE;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_SUPPORT_NON_MONITORED_FENCES = DXGI_ADAPTER_FLAG3.SUPPORT_NON_MONITORED_FENCES;
pub const DXGI_ADAPTER_FLAG3_KEYED_MUTEX_CONFORMANCE = DXGI_ADAPTER_FLAG3.KEYED_MUTEX_CONFORMANCE;
pub const DXGI_ADAPTER_FLAG3_FORCE_DWORD = DXGI_ADAPTER_FLAG3.FORCE_DWORD;

pub const DXGI_ADAPTER_DESC3 = extern struct {
    Description: [128]u16,
    VendorId: u32,
    DeviceId: u32,
    SubSysId: u32,
    Revision: u32,
    DedicatedVideoMemory: usize,
    DedicatedSystemMemory: usize,
    SharedSystemMemory: usize,
    AdapterLuid: LUID,
    Flags: DXGI_ADAPTER_FLAG3,
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY,
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY,
};

const IID_IDXGIAdapter4_Value = Guid.initString("3c8d99d1-4fbf-4181-a82c-af66bf7bd24e");
pub const IID_IDXGIAdapter4 = &IID_IDXGIAdapter4_Value;
pub const IDXGIAdapter4 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIAdapter3.VTable,
        GetDesc3: *const fn (
            self: *const IDXGIAdapter4,
            p_desc: ?*DXGI_ADAPTER_DESC3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIAdapter3.MethodMixin(T);
            pub inline fn getDesc3(self: *const T, p_desc_: ?*DXGI_ADAPTER_DESC3) HRESULT {
                return @as(*const IDXGIAdapter4.VTable, @ptrCast(self.vtable)).GetDesc3(@as(*const IDXGIAdapter4, @ptrCast(self)), p_desc_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_OUTPUT_DESC1 = extern struct {
    DeviceName: [32]u16,
    DesktopCoordinates: RECT,
    AttachedToDesktop: BOOL,
    Rotation: DXGI_MODE_ROTATION,
    Monitor: ?HMONITOR,
    BitsPerColor: u32,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    RedPrimary: [2]f32,
    GreenPrimary: [2]f32,
    BluePrimary: [2]f32,
    WhitePoint: [2]f32,
    MinLuminance: f32,
    MaxLuminance: f32,
    MaxFullFrameLuminance: f32,
};

pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS = enum(u32) {
    FULLSCREEN = 1,
    WINDOWED = 2,
    CURSOR_STRETCHED = 4,
    _,
    pub fn initFlags(o: struct {
        FULLSCREEN: u1 = 0,
        WINDOWED: u1 = 0,
        CURSOR_STRETCHED: u1 = 0,
    }) DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS {
        return @as(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS, @enumFromInt((if (o.FULLSCREEN == 1) @intFromEnum(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN) else 0) | (if (o.WINDOWED == 1) @intFromEnum(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED) else 0) | (if (o.CURSOR_STRETCHED == 1) @intFromEnum(DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED) else 0)));
    }
};
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_FULLSCREEN = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.FULLSCREEN;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_WINDOWED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.WINDOWED;
pub const DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_CURSOR_STRETCHED = DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS.CURSOR_STRETCHED;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IDXGIOutput6_Value = Guid.initString("068346e8-aaec-4b84-add7-137f513f77a1");
pub const IID_IDXGIOutput6 = &IID_IDXGIOutput6_Value;
pub const IDXGIOutput6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIOutput5.VTable,
        GetDesc1: *const fn (
            self: *const IDXGIOutput6,
            p_desc: ?*DXGI_OUTPUT_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckHardwareCompositionSupport: *const fn (
            self: *const IDXGIOutput6,
            p_flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIOutput5.MethodMixin(T);
            pub inline fn getDesc1(self: *const T, p_desc_: ?*DXGI_OUTPUT_DESC1) HRESULT {
                return @as(*const IDXGIOutput6.VTable, @ptrCast(self.vtable)).GetDesc1(@as(*const IDXGIOutput6, @ptrCast(self)), p_desc_);
            }
            pub inline fn checkHardwareCompositionSupport(self: *const T, p_flags_: ?*u32) HRESULT {
                return @as(*const IDXGIOutput6.VTable, @ptrCast(self.vtable)).CheckHardwareCompositionSupport(@as(*const IDXGIOutput6, @ptrCast(self)), p_flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_GPU_PREFERENCE = enum(i32) {
    UNSPECIFIED = 0,
    MINIMUM_POWER = 1,
    HIGH_PERFORMANCE = 2,
};
pub const DXGI_GPU_PREFERENCE_UNSPECIFIED = DXGI_GPU_PREFERENCE.UNSPECIFIED;
pub const DXGI_GPU_PREFERENCE_MINIMUM_POWER = DXGI_GPU_PREFERENCE.MINIMUM_POWER;
pub const DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE = DXGI_GPU_PREFERENCE.HIGH_PERFORMANCE;

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IDXGIFactory6_Value = Guid.initString("c1b6694f-ff09-44a9-b03c-77900a0a1d17");
pub const IID_IDXGIFactory6 = &IID_IDXGIFactory6_Value;
pub const IDXGIFactory6 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory5.VTable,
        EnumAdapterByGpuPreference: *const fn (
            self: *const IDXGIFactory6,
            adapter: u32,
            gpu_preference: DXGI_GPU_PREFERENCE,
            riid: ?*const Guid,
            ppv_adapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory5.MethodMixin(T);
            pub inline fn enumAdapterByGpuPreference(self: *const T, adapter_: u32, gpu_preference_: DXGI_GPU_PREFERENCE, riid_: ?*const Guid, ppv_adapter_: ?*?*anyopaque) HRESULT {
                return @as(*const IDXGIFactory6.VTable, @ptrCast(self.vtable)).EnumAdapterByGpuPreference(@as(*const IDXGIFactory6, @ptrCast(self)), adapter_, gpu_preference_, riid_, ppv_adapter_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IDXGIFactory7_Value = Guid.initString("a4966eed-76db-44da-84c1-ee9a7afb20a8");
pub const IID_IDXGIFactory7 = &IID_IDXGIFactory7_Value;
pub const IDXGIFactory7 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIFactory6.VTable,
        RegisterAdaptersChangedEvent: *const fn (
            self: *const IDXGIFactory7,
            h_event: ?HANDLE,
            pdw_cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAdaptersChangedEvent: *const fn (
            self: *const IDXGIFactory7,
            dw_cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIFactory6.MethodMixin(T);
            pub inline fn registerAdaptersChangedEvent(self: *const T, h_event_: ?HANDLE, pdw_cookie_: ?*u32) HRESULT {
                return @as(*const IDXGIFactory7.VTable, @ptrCast(self.vtable)).RegisterAdaptersChangedEvent(@as(*const IDXGIFactory7, @ptrCast(self)), h_event_, pdw_cookie_);
            }
            pub inline fn unregisterAdaptersChangedEvent(self: *const T, dw_cookie_: u32) HRESULT {
                return @as(*const IDXGIFactory7.VTable, @ptrCast(self.vtable)).UnregisterAdaptersChangedEvent(@as(*const IDXGIFactory7, @ptrCast(self)), dw_cookie_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_DEBUG_RLO_FLAGS = enum(u32) {
    SUMMARY = 1,
    DETAIL = 2,
    IGNORE_INTERNAL = 4,
    ALL = 7,
    _,
    pub fn initFlags(o: struct {
        SUMMARY: u1 = 0,
        DETAIL: u1 = 0,
        IGNORE_INTERNAL: u1 = 0,
        ALL: u1 = 0,
    }) DXGI_DEBUG_RLO_FLAGS {
        return @as(DXGI_DEBUG_RLO_FLAGS, @enumFromInt((if (o.SUMMARY == 1) @intFromEnum(DXGI_DEBUG_RLO_FLAGS.SUMMARY) else 0) | (if (o.DETAIL == 1) @intFromEnum(DXGI_DEBUG_RLO_FLAGS.DETAIL) else 0) | (if (o.IGNORE_INTERNAL == 1) @intFromEnum(DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL) else 0) | (if (o.ALL == 1) @intFromEnum(DXGI_DEBUG_RLO_FLAGS.ALL) else 0)));
    }
};
pub const DXGI_DEBUG_RLO_SUMMARY = DXGI_DEBUG_RLO_FLAGS.SUMMARY;
pub const DXGI_DEBUG_RLO_DETAIL = DXGI_DEBUG_RLO_FLAGS.DETAIL;
pub const DXGI_DEBUG_RLO_IGNORE_INTERNAL = DXGI_DEBUG_RLO_FLAGS.IGNORE_INTERNAL;
pub const DXGI_DEBUG_RLO_ALL = DXGI_DEBUG_RLO_FLAGS.ALL;

pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY = enum(i32) {
    UNKNOWN = 0,
    MISCELLANEOUS = 1,
    INITIALIZATION = 2,
    CLEANUP = 3,
    COMPILATION = 4,
    STATE_CREATION = 5,
    STATE_SETTING = 6,
    STATE_GETTING = 7,
    RESOURCE_MANIPULATION = 8,
    EXECUTION = 9,
    SHADER = 10,
};
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_UNKNOWN = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.UNKNOWN;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_MISCELLANEOUS = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.MISCELLANEOUS;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_INITIALIZATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.INITIALIZATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_CLEANUP = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.CLEANUP;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_COMPILATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.COMPILATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_CREATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_CREATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_SETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_SETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_GETTING = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.STATE_GETTING;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.RESOURCE_MANIPULATION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_EXECUTION = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.EXECUTION;
pub const DXGI_INFO_QUEUE_MESSAGE_CATEGORY_SHADER = DXGI_INFO_QUEUE_MESSAGE_CATEGORY.SHADER;

pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY = enum(i32) {
    CORRUPTION = 0,
    ERROR = 1,
    WARNING = 2,
    INFO = 3,
    MESSAGE = 4,
};
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_CORRUPTION = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.CORRUPTION;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_ERROR = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.ERROR;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_WARNING = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.WARNING;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_INFO = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.INFO;
pub const DXGI_INFO_QUEUE_MESSAGE_SEVERITY_MESSAGE = DXGI_INFO_QUEUE_MESSAGE_SEVERITY.MESSAGE;

pub const DXGI_INFO_QUEUE_MESSAGE = extern struct {
    Producer: Guid,
    Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    ID: i32,
    pDescription: ?*const u8,
    DescriptionByteLength: usize,
};

pub const DXGI_INFO_QUEUE_FILTER_DESC = extern struct {
    NumCategories: u32,
    pCategoryList: ?*DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
    NumSeverities: u32,
    pSeverityList: ?*DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
    NumIDs: u32,
    pIDList: ?*i32,
};

pub const DXGI_INFO_QUEUE_FILTER = extern struct {
    AllowList: DXGI_INFO_QUEUE_FILTER_DESC,
    DenyList: DXGI_INFO_QUEUE_FILTER_DESC,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIInfoQueue_Value = Guid.initString("d67441c7-672a-476f-9e82-cd55b44949ce");
pub const IID_IDXGIInfoQueue = &IID_IDXGIInfoQueue_Value;
pub const IDXGIInfoQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMessageCountLimit: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            message_count_limit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearStoredMessages: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetMessage: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            message_index: u64,
            // TODO: what to do with BytesParamIndex 3?
            p_message: ?*DXGI_INFO_QUEUE_MESSAGE,
            p_message_byte_length: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumStoredMessagesAllowedByRetrievalFilters: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumStoredMessages: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesDiscardedByMessageCountLimit: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetMessageCountLimit: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesAllowedByStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetNumMessagesDeniedByStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        AddStorageFilterEntries: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            // TODO: what to do with BytesParamIndex 2?
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
            p_filter_byte_length: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PushEmptyStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushDenyAllStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushCopyOfStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopStorageFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetStorageFilterStackSize: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddRetrievalFilterEntries: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            // TODO: what to do with BytesParamIndex 2?
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
            p_filter_byte_length: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PushEmptyRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushDenyAllRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushCopyOfRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            p_filter: ?*DXGI_INFO_QUEUE_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopRetrievalFilter: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetRetrievalFilterStackSize: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddMessage: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            i_d: i32,
            p_description: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplicationMessage: *const fn (
            self: *const IDXGIInfoQueue,
            severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            p_description: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnCategory: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
            b_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnSeverity: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
            b_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakOnID: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            i_d: i32,
            b_enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakOnCategory: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetBreakOnSeverity: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetBreakOnID: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            i_d: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetMuteDebugOutput: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
            b_mute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetMuteDebugOutput: *const fn (
            self: *const IDXGIInfoQueue,
            producer: Guid,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn setMessageCountLimit(self: *const T, producer_: Guid, message_count_limit_: u64) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).SetMessageCountLimit(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, message_count_limit_);
            }
            pub inline fn clearStoredMessages(self: *const T, producer_: Guid) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).ClearStoredMessages(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getMessage(self: *const T, producer_: Guid, message_index_: u64, p_message_: ?*DXGI_INFO_QUEUE_MESSAGE, p_message_byte_length_: ?*usize) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetMessage(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, message_index_, p_message_, p_message_byte_length_);
            }
            pub inline fn getNumStoredMessagesAllowedByRetrievalFilters(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetNumStoredMessagesAllowedByRetrievalFilters(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getNumStoredMessages(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetNumStoredMessages(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getNumMessagesDiscardedByMessageCountLimit(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetNumMessagesDiscardedByMessageCountLimit(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getMessageCountLimit(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetMessageCountLimit(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getNumMessagesAllowedByStorageFilter(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetNumMessagesAllowedByStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getNumMessagesDeniedByStorageFilter(self: *const T, producer_: Guid) u64 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetNumMessagesDeniedByStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn addStorageFilterEntries(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).AddStorageFilterEntries(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_);
            }
            pub inline fn getStorageFilter(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER, p_filter_byte_length_: ?*usize) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_, p_filter_byte_length_);
            }
            pub inline fn clearStorageFilter(self: *const T, producer_: Guid) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).ClearStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushEmptyStorageFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushEmptyStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushDenyAllStorageFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushDenyAllStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushCopyOfStorageFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushCopyOfStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushStorageFilter(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_);
            }
            pub inline fn popStorageFilter(self: *const T, producer_: Guid) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PopStorageFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getStorageFilterStackSize(self: *const T, producer_: Guid) u32 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetStorageFilterStackSize(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn addRetrievalFilterEntries(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).AddRetrievalFilterEntries(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_);
            }
            pub inline fn getRetrievalFilter(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER, p_filter_byte_length_: ?*usize) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_, p_filter_byte_length_);
            }
            pub inline fn clearRetrievalFilter(self: *const T, producer_: Guid) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).ClearRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushEmptyRetrievalFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushEmptyRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushDenyAllRetrievalFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushDenyAllRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushCopyOfRetrievalFilter(self: *const T, producer_: Guid) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushCopyOfRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn pushRetrievalFilter(self: *const T, producer_: Guid, p_filter_: ?*DXGI_INFO_QUEUE_FILTER) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PushRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, p_filter_);
            }
            pub inline fn popRetrievalFilter(self: *const T, producer_: Guid) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).PopRetrievalFilter(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn getRetrievalFilterStackSize(self: *const T, producer_: Guid) u32 {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetRetrievalFilterStackSize(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
            pub inline fn addMessage(self: *const T, producer_: Guid, category_: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, severity_: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, i_d_: i32, p_description_: ?[*:0]const u8) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).AddMessage(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, category_, severity_, i_d_, p_description_);
            }
            pub inline fn addApplicationMessage(self: *const T, severity_: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, p_description_: ?[*:0]const u8) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).AddApplicationMessage(@as(*const IDXGIInfoQueue, @ptrCast(self)), severity_, p_description_);
            }
            pub inline fn setBreakOnCategory(self: *const T, producer_: Guid, category_: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, b_enable_: BOOL) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).SetBreakOnCategory(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, category_, b_enable_);
            }
            pub inline fn setBreakOnSeverity(self: *const T, producer_: Guid, severity_: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, b_enable_: BOOL) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).SetBreakOnSeverity(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, severity_, b_enable_);
            }
            pub inline fn setBreakOnID(self: *const T, producer_: Guid, i_d_: i32, b_enable_: BOOL) HRESULT {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).SetBreakOnID(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, i_d_, b_enable_);
            }
            pub inline fn getBreakOnCategory(self: *const T, producer_: Guid, category_: DXGI_INFO_QUEUE_MESSAGE_CATEGORY) BOOL {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetBreakOnCategory(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, category_);
            }
            pub inline fn getBreakOnSeverity(self: *const T, producer_: Guid, severity_: DXGI_INFO_QUEUE_MESSAGE_SEVERITY) BOOL {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetBreakOnSeverity(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, severity_);
            }
            pub inline fn getBreakOnID(self: *const T, producer_: Guid, i_d_: i32) BOOL {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetBreakOnID(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, i_d_);
            }
            pub inline fn setMuteDebugOutput(self: *const T, producer_: Guid, b_mute_: BOOL) void {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).SetMuteDebugOutput(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_, b_mute_);
            }
            pub inline fn getMuteDebugOutput(self: *const T, producer_: Guid) BOOL {
                return @as(*const IDXGIInfoQueue.VTable, @ptrCast(self.vtable)).GetMuteDebugOutput(@as(*const IDXGIInfoQueue, @ptrCast(self)), producer_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDXGIDebug_Value = Guid.initString("119e7452-de9e-40fe-8806-88f90c12b441");
pub const IID_IDXGIDebug = &IID_IDXGIDebug_Value;
pub const IDXGIDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportLiveObjects: *const fn (
            self: *const IDXGIDebug,
            apiid: Guid,
            flags: DXGI_DEBUG_RLO_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn reportLiveObjects(self: *const T, apiid_: Guid, flags_: DXGI_DEBUG_RLO_FLAGS) HRESULT {
                return @as(*const IDXGIDebug.VTable, @ptrCast(self.vtable)).ReportLiveObjects(@as(*const IDXGIDebug, @ptrCast(self)), apiid_, flags_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IDXGIDebug1_Value = Guid.initString("c5a05f0c-16f2-4adf-9f4d-a8c4d58ac550");
pub const IID_IDXGIDebug1 = &IID_IDXGIDebug1_Value;
pub const IDXGIDebug1 = extern struct {
    pub const VTable = extern struct {
        base: IDXGIDebug.VTable,
        EnableLeakTrackingForThread: *const fn (
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DisableLeakTrackingForThread: *const fn (
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) void,
        IsLeakTrackingEnabledForThread: *const fn (
            self: *const IDXGIDebug1,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDXGIDebug.MethodMixin(T);
            pub inline fn enableLeakTrackingForThread(self: *const T) void {
                return @as(*const IDXGIDebug1.VTable, @ptrCast(self.vtable)).EnableLeakTrackingForThread(@as(*const IDXGIDebug1, @ptrCast(self)));
            }
            pub inline fn disableLeakTrackingForThread(self: *const T) void {
                return @as(*const IDXGIDebug1.VTable, @ptrCast(self.vtable)).DisableLeakTrackingForThread(@as(*const IDXGIDebug1, @ptrCast(self)));
            }
            pub inline fn isLeakTrackingEnabledForThread(self: *const T) BOOL {
                return @as(*const IDXGIDebug1.VTable, @ptrCast(self.vtable)).IsLeakTrackingEnabledForThread(@as(*const IDXGIDebug1, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXGI_Message_Id = enum(i32) {
    IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow = 0,
    IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred = 1,
    IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred = 2,
    IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged = 3,
    IDXGISwapChain_Creation_MaxBufferCountExceeded = 4,
    IDXGISwapChain_Creation_TooFewBuffers = 5,
    IDXGISwapChain_Creation_NoOutputWindow = 6,
    IDXGISwapChain_Destruction_OtherMethodsCalled = 7,
    IDXGISwapChain_GetDesc_pDescIsNULL = 8,
    IDXGISwapChain_GetBuffer_ppSurfaceIsNULL = 9,
    IDXGISwapChain_GetBuffer_NoAllocatedBuffers = 10,
    IDXGISwapChain_GetBuffer_iBufferMustBeZero = 11,
    IDXGISwapChain_GetBuffer_iBufferOOB = 12,
    IDXGISwapChain_GetContainingOutput_ppOutputIsNULL = 13,
    IDXGISwapChain_Present_SyncIntervalOOB = 14,
    IDXGISwapChain_Present_InvalidNonPreRotatedFlag = 15,
    IDXGISwapChain_Present_NoAllocatedBuffers = 16,
    IDXGISwapChain_Present_GetDXGIAdapterFailed = 17,
    IDXGISwapChain_ResizeBuffers_BufferCountOOB = 18,
    IDXGISwapChain_ResizeBuffers_UnreleasedReferences = 19,
    IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag = 20,
    IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag = 21,
    IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero = 22,
    IDXGISwapChain_SetFullscreenState_InvalidTarget = 23,
    IDXGISwapChain_GetFrameStatistics_pStatsIsNULL = 24,
    IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL = 25,
    IDXGISwapChain_SetFullscreenState_RemoteNotSupported = 26,
    IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex = 27,
    IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL = 28,
    IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL = 29,
    IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL = 30,
    IDXGIFactory_CreateSwapChain_pDescIsNULL = 31,
    IDXGIFactory_CreateSwapChain_UnknownSwapEffect = 32,
    IDXGIFactory_CreateSwapChain_InvalidFlags = 33,
    IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed = 34,
    IDXGIFactory_CreateSwapChain_NullDeviceInterface = 35,
    IDXGIFactory_GetWindowAssociation_phWndIsNULL = 36,
    IDXGIFactory_MakeWindowAssociation_InvalidFlags = 37,
    IDXGISurface_Map_InvalidSurface = 38,
    IDXGISurface_Map_FlagsSetToZero = 39,
    IDXGISurface_Map_DiscardAndReadFlagSet = 40,
    IDXGISurface_Map_DiscardButNotWriteFlagSet = 41,
    IDXGISurface_Map_NoCPUAccess = 42,
    IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic = 43,
    IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic = 44,
    IDXGIOutput_GetDisplayModeList_pNumModesIsNULL = 45,
    IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight = 46,
    IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice = 47,
    IDXGIOutput_TakeOwnership_pDeviceIsNULL = 48,
    IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice = 49,
    IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL = 50,
    IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed = 51,
    IDXGIOutput_GetFrameStatistics_NoOwnerDevice = 52,
    IDXGIOutput_GetFrameStatistics_pStatsIsNULL = 53,
    IDXGIOutput_SetGammaControl_NoOwnerDevice = 54,
    IDXGIOutput_GetGammaControl_NoOwnerDevice = 55,
    IDXGIOutput_GetGammaControl_NoGammaControls = 56,
    IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary = 57,
    IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid = 58,
    IDXGIOutput_SetDisplaySurface_NoOwnerDevice = 59,
    IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported = 60,
    IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported = 61,
    IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported = 62,
    IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource = 63,
    IDXGIObject_GetPrivateData_puiDataSizeIsNULL = 64,
    IDXGISwapChain_Creation_InvalidOutputWindow = 65,
    IDXGISwapChain_Release_SwapChainIsFullscreen = 66,
    IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat = 67,
    IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL = 68,
    IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice = 69,
    IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL = 70,
    IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero = 71,
    IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration = 72,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering = 73,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling = 74,
    IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination = 75,
    IDXGIFactory_Creation_CalledFromDllMain = 76,
    IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice = 77,
    IDXGISwapChain_Creation_InvalidWindowStyle = 78,
    IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics = 79,
    IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput = 80,
    IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL = 81,
    IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows = 82,
    IDXGIFactory_Release_CalledFromDllMain = 83,
    IDXGISwapChain_Present_UnreleasedHDC = 84,
    IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags = 85,
    IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags = 86,
    IDXGISurface1_GetDC_pHdcIsNULL = 87,
    IDXGISurface1_GetDC_SurfaceNotTexture2D = 88,
    IDXGISurface1_GetDC_GDICompatibleFlagNotSet = 89,
    IDXGISurface1_GetDC_UnreleasedHDC = 90,
    IDXGISurface_Map_NoCPUAccess2 = 91,
    IDXGISurface1_ReleaseDC_GetDCNotCalled = 92,
    IDXGISurface1_ReleaseDC_InvalidRectangleDimensions = 93,
    IDXGIOutput_TakeOwnership_RemoteOutputNotSupported = 94,
    IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported = 95,
    IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported = 96,
    IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory = 97,
    IDXGISwapChain_Present_NonOptimalFSConfiguration = 98,
    IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10 = 99,
    IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential = 100,
    IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential = 101,
    IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential = 102,
    IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential = 103,
    IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential = 104,
    IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation = 105,
    IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid = 106,
    IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag = 107,
    IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified = 108,
    IDXGISwapChain_Present_EmptyScrollRect = 109,
    IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds = 110,
    IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset = 111,
    IDXGISwapChain_Present_EmptyDirtyRect = 112,
    IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds = 113,
    IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags = 114,
    IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined = 115,
    IDXGISwapChain_Present_UnsupportedFlags = 116,
    IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition = 117,
    IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory = 118,
    IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter = 119,
    IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput = 120,
    IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen = 121,
    IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain = 122,
    IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag = 123,
    IDXGIFactory_CreateSwapChain_UnavailableInSession0 = 124,
    IDXGIFactory_MakeWindowAssociation_UnavailableInSession0 = 125,
    IDXGIFactory_GetWindowAssociation_UnavailableInSession0 = 126,
    IDXGIAdapter_EnumOutputs_UnavailableInSession0 = 127,
    IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled = 128,
    IDXGIFactory2_UnregisterStatus_CookieNotFound = 129,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay = 130,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential = 131,
    IDXGISwapChain_Present_ProtectedContentWithRDPDriver = 132,
    IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity = 133,
    IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero = 134,
    IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported = 135,
    IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter = 136,
    IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7 = 137,
    IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain = 138,
    IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain = 139,
    IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero = 140,
    IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly = 141,
    IDXGIFactory_CreateSwapChain_ScalingUnrecognized = 142,
    IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported = 143,
    IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported = 144,
    IDXGISwapChain_Present_RestartIsFullscreenOnly = 145,
    IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly = 146,
    IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported = 147,
    IDXGISwapChain1_SetBackgroundColor_OutOfRange = 148,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported = 149,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported = 150,
    IDXGISwapchain_Present_ScrollUnsupported = 151,
    IDXGISwapChain1_SetRotation_UnsupportedOS = 152,
    IDXGISwapChain1_GetRotation_UnsupportedOS = 153,
    IDXGISwapchain_Present_FullscreenRotation = 154,
    IDXGISwapChain_Present_PartialPresentationWithMSAABuffers = 155,
    IDXGISwapChain1_SetRotation_FlipSequentialRequired = 156,
    IDXGISwapChain1_SetRotation_InvalidRotation = 157,
    IDXGISwapChain1_GetRotation_FlipSequentialRequired = 158,
    IDXGISwapChain_GetHwnd_WrongType = 159,
    IDXGISwapChain_GetCompositionSurface_WrongType = 160,
    IDXGISwapChain_GetCoreWindow_WrongType = 161,
    IDXGISwapChain_GetFullscreenDesc_NonHwnd = 162,
    IDXGISwapChain_SetFullscreenState_CoreWindow = 163,
    IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7 = 164,
    IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL = 165,
    IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps = 166,
    IDXGIFactory_MakeWindowAssociation_ModernApp = 167,
    IDXGISwapChain_ResizeTarget_ModernApp = 168,
    IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL = 169,
    IDXGIOutput_SetDisplaySurface_ModernApp = 170,
    IDXGIOutput_TakeOwnership_ModernApp = 171,
    IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid = 172,
    IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle = 173,
    IDXGISurface1_GetDC_ModernApp = 174,
    IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer = 175,
    IDXGISwapChain_Present_TemporaryMonoAndPreferRight = 176,
    IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence = 177,
    IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo = 178,
    IDXGISwapChain_Present_TemporaryMonoUnsupported = 179,
    IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch = 180,
    IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard = 181,
    IDXGIFactory_CreateSwapChain_AlphaUnrecognized = 182,
    IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly = 183,
    IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly = 184,
    IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch = 185,
    IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy = 186,
    IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy = 187,
    IDXGIResource1_CreateSubresourceSurface_InvalidIndex = 188,
    IDXGIFactory_CreateSwapChainForComposition_InvalidScaling = 189,
    IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect = 190,
    IDXGIResource1_CreateSharedHandle_UnsupportedOS = 191,
    IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS = 192,
    IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS = 193,
    IDXGIOutput1_DuplicateOutput_UnsupportedOS = 194,
    IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS = 195,
    IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode = 196,
    IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource = 197,
    IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID = 198,
    IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS = 199,
    IDXGIOutput1_GetDisplaySurfaceData1_2DOnly = 200,
    IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly = 201,
    IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite = 202,
    IDXGIOutput1_GetDisplaySurfaceData1_NoShared = 203,
    IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1 = 204,
    IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource = 205,
    IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps = 206,
    IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated = 207,
    IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = 208,
    IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = 209,
    IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly = 210,
    IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen = 211,
    IDXGISwapChain_SetFullscreenState_Waitable = 212,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag = 213,
    IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable = 214,
    IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable = 215,
    IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL = 216,
    IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable = 217,
    IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds = 218,
    IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly = 219,
    IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter = 220,
    IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling = 221,
    IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode = 222,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag = 223,
    IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull = 224,
    IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain = 225,
    IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite = 226,
    IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale = 227,
    IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull = 228,
    IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain = 229,
    DXGIGetDebugInterface1_NULL_ppDebug = 230,
    DXGIGetDebugInterface1_InvalidFlags = 231,
    IDXGISwapChain_Present_Decode = 232,
    IDXGISwapChain_ResizeBuffers_Decode = 233,
    IDXGISwapChain_SetSourceSize_FlipModel = 234,
    IDXGISwapChain_SetSourceSize_Decode = 235,
    IDXGISwapChain_SetSourceSize_WidthHeight = 236,
    IDXGISwapChain_GetSourceSize_NullPointers = 237,
    IDXGISwapChain_GetSourceSize_Decode = 238,
    IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags = 239,
    IDXGIDecodeSwapChain_SetSourceRect_InvalidRect = 240,
    IDXGIDecodeSwapChain_SetTargetRect_InvalidRect = 241,
    IDXGIDecodeSwapChain_SetDestSize_InvalidSize = 242,
    IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer = 243,
    IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer = 244,
    IDXGIDecodeSwapChain_GetDestSize_InvalidPointer = 245,
    IDXGISwapChain_PresentBuffer_YUV = 246,
    IDXGISwapChain_SetSourceSize_YUV = 247,
    IDXGISwapChain_GetSourceSize_YUV = 248,
    IDXGISwapChain_SetMatrixTransform_YUV = 249,
    IDXGISwapChain_GetMatrixTransform_YUV = 250,
    IDXGISwapChain_Present_PartialPresentation_YUV = 251,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV = 252,
    IDXGISwapChain_ResizeBuffers_Alignment_YUV = 253,
    IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV = 254,
    IDXGIOutput3_CheckOverlaySupport_NullPointers = 255,
    IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice = 256,
    IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag = 257,
    IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard = 258,
    IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers = 259,
    IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice = 260,
    IDXGISwapChain3_CheckColorSpaceSupport_NullPointers = 261,
    IDXGISwapChain3_SetColorSpace1_InvalidColorSpace = 262,
    IDXGIFactory_CreateSwapChain_InvalidHwProtect = 263,
    IDXGIFactory_CreateSwapChain_HwProtectUnsupported = 264,
    IDXGISwapChain_ResizeBuffers_InvalidHwProtect = 265,
    IDXGISwapChain_ResizeBuffers_HwProtectUnsupported = 266,
    IDXGISwapChain_ResizeBuffers1_D3D12Only = 267,
    IDXGISwapChain_ResizeBuffers1_FlipModel = 268,
    IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired = 269,
    IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag = 270,
    IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag = 271,
    IDXGIFactory_CreateSwapChain_10BitFormatNotSupported = 272,
    IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired = 273,
    IDXGIFactory_CreateSwapChain_InvalidDevice = 274,
    IDXGIOutput_TakeOwnership_Unsupported = 275,
    IDXGIFactory_CreateSwapChain_InvalidQueue = 276,
    IDXGISwapChain3_ResizeBuffers1_InvalidQueue = 277,
    IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling = 278,
    IDXGISwapChain3_SetHDRMetaData_InvalidSize = 279,
    IDXGISwapChain3_SetHDRMetaData_InvalidPointer = 280,
    IDXGISwapChain3_SetHDRMetaData_InvalidType = 281,
    IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid = 282,
    IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero = 283,
    IDXGISwapChain_Present_AllowTearingRequiresCreationFlag = 284,
    IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag = 285,
    IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly = 286,
    IDXGIFactory_CheckFeatureSupport_InvalidFeature = 287,
    IDXGIFactory_CheckFeatureSupport_InvalidSize = 288,
    IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer = 289,
    IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied = 290,
    IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied = 291,
    IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired = 292,
    IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound = 293,
    IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect = 294,
    IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged = 295,
    IDXGISwapChain_Present_11On12_Released_Resource = 296,
    IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr = 297,
    IDXGIFactory_MakeWindowAssociation_NoOpBehavior = 298,
    Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow = 1000,
    Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount = 1001,
    Phone_IDXGISwapChain_SetFullscreenState_NotAvailable = 1002,
    Phone_IDXGISwapChain_ResizeBuffers_NotAvailable = 1003,
    Phone_IDXGISwapChain_ResizeTarget_NotAvailable = 1004,
    Phone_IDXGISwapChain_Present_InvalidLayerIndex = 1005,
    Phone_IDXGISwapChain_Present_MultipleLayerIndex = 1006,
    Phone_IDXGISwapChain_Present_InvalidLayerFlag = 1007,
    Phone_IDXGISwapChain_Present_InvalidRotation = 1008,
    Phone_IDXGISwapChain_Present_InvalidBlend = 1009,
    Phone_IDXGISwapChain_Present_InvalidResource = 1010,
    Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource = 1011,
    Phone_IDXGISwapChain_Present_InvalidIndexForPrimary = 1012,
    Phone_IDXGISwapChain_Present_InvalidIndexForOverlay = 1013,
    Phone_IDXGISwapChain_Present_InvalidSubResourceIndex = 1014,
    Phone_IDXGISwapChain_Present_InvalidSourceRect = 1015,
    Phone_IDXGISwapChain_Present_InvalidDestinationRect = 1016,
    Phone_IDXGISwapChain_Present_MultipleResource = 1017,
    Phone_IDXGISwapChain_Present_NotSharedResource = 1018,
    Phone_IDXGISwapChain_Present_InvalidFlag = 1019,
    Phone_IDXGISwapChain_Present_InvalidInterval = 1020,
    Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported = 1021,
    Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp = 1022,
    Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp = 1023,
    Phone_IDXGISwapChain_Present_ReplaceInterval0With1 = 1024,
    Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor = 1025,
    Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering = 1026,
    Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount = 1027,
    Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only = 1028,
    Phone_IDXGISwapChain_Present1_RequiresOverlays = 1029,
    Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired = 1030,
    Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired = 1031,
};
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_InvalidOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_BufferWidthInferred;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_BufferHeightInferred;
pub const DXGI_MSG_IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged = DXGI_Message_Id.IDXGISwapChain_CreationOrResizeBuffers_NoScanoutFlagChanged;
pub const DXGI_MSG_IDXGISwapChain_Creation_MaxBufferCountExceeded = DXGI_Message_Id.IDXGISwapChain_Creation_MaxBufferCountExceeded;
pub const DXGI_MSG_IDXGISwapChain_Creation_TooFewBuffers = DXGI_Message_Id.IDXGISwapChain_Creation_TooFewBuffers;
pub const DXGI_MSG_IDXGISwapChain_Creation_NoOutputWindow = DXGI_Message_Id.IDXGISwapChain_Creation_NoOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_Destruction_OtherMethodsCalled = DXGI_Message_Id.IDXGISwapChain_Destruction_OtherMethodsCalled;
pub const DXGI_MSG_IDXGISwapChain_GetDesc_pDescIsNULL = DXGI_Message_Id.IDXGISwapChain_GetDesc_pDescIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_ppSurfaceIsNULL = DXGI_Message_Id.IDXGISwapChain_GetBuffer_ppSurfaceIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_NoAllocatedBuffers = DXGI_Message_Id.IDXGISwapChain_GetBuffer_NoAllocatedBuffers;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_iBufferMustBeZero = DXGI_Message_Id.IDXGISwapChain_GetBuffer_iBufferMustBeZero;
pub const DXGI_MSG_IDXGISwapChain_GetBuffer_iBufferOOB = DXGI_Message_Id.IDXGISwapChain_GetBuffer_iBufferOOB;
pub const DXGI_MSG_IDXGISwapChain_GetContainingOutput_ppOutputIsNULL = DXGI_Message_Id.IDXGISwapChain_GetContainingOutput_ppOutputIsNULL;
pub const DXGI_MSG_IDXGISwapChain_Present_SyncIntervalOOB = DXGI_Message_Id.IDXGISwapChain_Present_SyncIntervalOOB;
pub const DXGI_MSG_IDXGISwapChain_Present_InvalidNonPreRotatedFlag = DXGI_Message_Id.IDXGISwapChain_Present_InvalidNonPreRotatedFlag;
pub const DXGI_MSG_IDXGISwapChain_Present_NoAllocatedBuffers = DXGI_Message_Id.IDXGISwapChain_Present_NoAllocatedBuffers;
pub const DXGI_MSG_IDXGISwapChain_Present_GetDXGIAdapterFailed = DXGI_Message_Id.IDXGISwapChain_Present_GetDXGIAdapterFailed;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_BufferCountOOB = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_BufferCountOOB;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_UnreleasedReferences = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_UnreleasedReferences;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidSwapChainFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidNonPreRotatedFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_RefreshRateDivideByZero;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_InvalidTarget = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_InvalidTarget;
pub const DXGI_MSG_IDXGISwapChain_GetFrameStatistics_pStatsIsNULL = DXGI_Message_Id.IDXGISwapChain_GetFrameStatistics_pStatsIsNULL;
pub const DXGI_MSG_IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL = DXGI_Message_Id.IDXGISwapChain_GetLastPresentCount_pLastPresentCountIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_RemoteNotSupported = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_RemoteNotSupported;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex = DXGI_Message_Id.IDXGIOutput_TakeOwnership_FailedToAcquireFullscreenMutex;
pub const DXGI_MSG_IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSoftwareAdapter_ppAdapterInterfaceIsNULL;
pub const DXGI_MSG_IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL = DXGI_Message_Id.IDXGIFactory_EnumAdapters_ppAdapterInterfaceIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ppSwapChainIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pDescIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pDescIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnknownSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnknownSwapEffect;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidFlags;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NonPreRotatedFlagAndWindowed;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NullDeviceInterface = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NullDeviceInterface;
pub const DXGI_MSG_IDXGIFactory_GetWindowAssociation_phWndIsNULL = DXGI_Message_Id.IDXGIFactory_GetWindowAssociation_phWndIsNULL;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_InvalidFlags = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_InvalidFlags;
pub const DXGI_MSG_IDXGISurface_Map_InvalidSurface = DXGI_Message_Id.IDXGISurface_Map_InvalidSurface;
pub const DXGI_MSG_IDXGISurface_Map_FlagsSetToZero = DXGI_Message_Id.IDXGISurface_Map_FlagsSetToZero;
pub const DXGI_MSG_IDXGISurface_Map_DiscardAndReadFlagSet = DXGI_Message_Id.IDXGISurface_Map_DiscardAndReadFlagSet;
pub const DXGI_MSG_IDXGISurface_Map_DiscardButNotWriteFlagSet = DXGI_Message_Id.IDXGISurface_Map_DiscardButNotWriteFlagSet;
pub const DXGI_MSG_IDXGISurface_Map_NoCPUAccess = DXGI_Message_Id.IDXGISurface_Map_NoCPUAccess;
pub const DXGI_MSG_IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic = DXGI_Message_Id.IDXGISurface_Map_ReadFlagSetButCPUAccessIsDynamic;
pub const DXGI_MSG_IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic = DXGI_Message_Id.IDXGISurface_Map_DiscardFlagSetButCPUAccessIsNotDynamic;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_pNumModesIsNULL = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_pNumModesIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_ModeHasInvalidWidthOrHeight;
pub const DXGI_MSG_IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetCammaControlCapabilities_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_pDeviceIsNULL = DXGI_Message_Id.IDXGIOutput_TakeOwnership_pDeviceIsNULL;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_pDestinationIsNULL;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_MapOfDestinationFailed;
pub const DXGI_MSG_IDXGIOutput_GetFrameStatistics_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetFrameStatistics_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetFrameStatistics_pStatsIsNULL = DXGI_Message_Id.IDXGIOutput_GetFrameStatistics_pStatsIsNULL;
pub const DXGI_MSG_IDXGIOutput_SetGammaControl_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_SetGammaControl_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetGammaControl_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_GetGammaControl_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_GetGammaControl_NoGammaControls = DXGI_Message_Id.IDXGIOutput_GetGammaControl_NoGammaControls;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_IDXGIResourceNotSupportedBypPrimary;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_pPrimaryIsInvalid;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_NoOwnerDevice = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_NoOwnerDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_RemoteDeviceNotSupported;
pub const DXGI_MSG_IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource = DXGI_Message_Id.IDXGIDevice_CreateSurface_InvalidParametersWithpSharedResource;
pub const DXGI_MSG_IDXGIObject_GetPrivateData_puiDataSizeIsNULL = DXGI_Message_Id.IDXGIObject_GetPrivateData_puiDataSizeIsNULL;
pub const DXGI_MSG_IDXGISwapChain_Creation_InvalidOutputWindow = DXGI_Message_Id.IDXGISwapChain_Creation_InvalidOutputWindow;
pub const DXGI_MSG_IDXGISwapChain_Release_SwapChainIsFullscreen = DXGI_Message_Id.IDXGISwapChain_Release_SwapChainIsFullscreen;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_InvalidTargetSurfaceFormat;
pub const DXGI_MSG_IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL = DXGI_Message_Id.IDXGIFactory_CreateSoftwareAdapter_ModuleIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_pModeToMatchOrpClosestMatchIsNULL;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_ModeHasRefreshRateDenominatorZero;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_UnknownFormatIsInvalidForConfiguration;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScanlineOrdering;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeScaling;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_InvalidDisplayModeFormatAndDeviceCombination;
pub const DXGI_MSG_IDXGIFactory_Creation_CalledFromDllMain = DXGI_Message_Id.IDXGIFactory_Creation_CalledFromDllMain;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_OutputNotOwnedBySwapChainDevice;
pub const DXGI_MSG_IDXGISwapChain_Creation_InvalidWindowStyle = DXGI_Message_Id.IDXGISwapChain_Creation_InvalidWindowStyle;
pub const DXGI_MSG_IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics = DXGI_Message_Id.IDXGISwapChain_GetFrameStatistics_UnsupportedStatistics;
pub const DXGI_MSG_IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput = DXGI_Message_Id.IDXGISwapChain_GetContainingOutput_SwapchainAdapterDoesNotControlOutput;
pub const DXGI_MSG_IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL = DXGI_Message_Id.IDXGIOutput_SetOrGetGammaControl_pArrayIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FullscreenInvalidForChildWindows;
pub const DXGI_MSG_IDXGIFactory_Release_CalledFromDllMain = DXGI_Message_Id.IDXGIFactory_Release_CalledFromDllMain;
pub const DXGI_MSG_IDXGISwapChain_Present_UnreleasedHDC = DXGI_Message_Id.IDXGISwapChain_Present_UnreleasedHDC;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_NonPreRotatedAndGDICompatibleFlags;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_NonPreRotatedAndGDICompatibleFlags;
pub const DXGI_MSG_IDXGISurface1_GetDC_pHdcIsNULL = DXGI_Message_Id.IDXGISurface1_GetDC_pHdcIsNULL;
pub const DXGI_MSG_IDXGISurface1_GetDC_SurfaceNotTexture2D = DXGI_Message_Id.IDXGISurface1_GetDC_SurfaceNotTexture2D;
pub const DXGI_MSG_IDXGISurface1_GetDC_GDICompatibleFlagNotSet = DXGI_Message_Id.IDXGISurface1_GetDC_GDICompatibleFlagNotSet;
pub const DXGI_MSG_IDXGISurface1_GetDC_UnreleasedHDC = DXGI_Message_Id.IDXGISurface1_GetDC_UnreleasedHDC;
pub const DXGI_MSG_IDXGISurface_Map_NoCPUAccess2 = DXGI_Message_Id.IDXGISurface_Map_NoCPUAccess2;
pub const DXGI_MSG_IDXGISurface1_ReleaseDC_GetDCNotCalled = DXGI_Message_Id.IDXGISurface1_ReleaseDC_GetDCNotCalled;
pub const DXGI_MSG_IDXGISurface1_ReleaseDC_InvalidRectangleDimensions = DXGI_Message_Id.IDXGISurface1_ReleaseDC_InvalidRectangleDimensions;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_FindClosestMatchingMode_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported = DXGI_Message_Id.IDXGIOutput_GetDisplayModeList_RemoteOutputNotSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pDeviceHasMismatchedDXGIFactory;
pub const DXGI_MSG_IDXGISwapChain_Present_NonOptimalFSConfiguration = DXGI_Message_Id.IDXGISwapChain_Present_NonOptimalFSConfiguration;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10 = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FlipSequentialNotSupportedOnD3D10;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_BufferCountOOBForFlipSequential;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidFormatForFlipSequential;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_MultiSamplingNotSupportedForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_BufferCountOOBForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidFormatForFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationBeforeStandardPresentation;
pub const DXGI_MSG_IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid = DXGI_Message_Id.IDXGISwapChain_Present_FullscreenPartialPresentIsInvalid;
pub const DXGI_MSG_IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag = DXGI_Message_Id.IDXGISwapChain_Present_InvalidPresentTestOrDoNotSequenceFlag;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified = DXGI_Message_Id.IDXGISwapChain_Present_ScrollInfoWithNoDirtyRectsSpecified;
pub const DXGI_MSG_IDXGISwapChain_Present_EmptyScrollRect = DXGI_Message_Id.IDXGISwapChain_Present_EmptyScrollRect;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds = DXGI_Message_Id.IDXGISwapChain_Present_ScrollRectOutOfBackbufferBounds;
pub const DXGI_MSG_IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset = DXGI_Message_Id.IDXGISwapChain_Present_ScrollRectOutOfBackbufferBoundsWithOffset;
pub const DXGI_MSG_IDXGISwapChain_Present_EmptyDirtyRect = DXGI_Message_Id.IDXGISwapChain_Present_EmptyDirtyRect;
pub const DXGI_MSG_IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds = DXGI_Message_Id.IDXGISwapChain_Present_DirtyRectOutOfBackbufferBounds;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnsupportedBufferUsageFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined = DXGI_Message_Id.IDXGISwapChain_Present_DoNotSequenceFlagSetButPreviousBufferIsUndefined;
pub const DXGI_MSG_IDXGISwapChain_Present_UnsupportedFlags = DXGI_Message_Id.IDXGISwapChain_Present_UnsupportedFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition = DXGI_Message_Id.IDXGISwapChain_Present_FlipModelChainMustResizeOrCreateOnFSTransition;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_pRestrictToOutputFromOtherIDXGIFactory;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_RestrictOutputNotSupportedOnAdapter;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput = DXGI_Message_Id.IDXGISwapChain_Present_RestrictToOutputFlagSetButInvalidpRestrictToOutput;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen = DXGI_Message_Id.IDXGISwapChain_Present_RestrictToOutputFlagdWithFullscreen;
pub const DXGI_MSG_IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain = DXGI_Message_Id.IDXGISwapChain_Present_RestrictOutputFlagWithStaleSwapChain;
pub const DXGI_MSG_IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag = DXGI_Message_Id.IDXGISwapChain_Present_OtherFlagsCausingInvalidPresentTestFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_UnavailableInSession0;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_UnavailableInSession0;
pub const DXGI_MSG_IDXGIFactory_GetWindowAssociation_UnavailableInSession0 = DXGI_Message_Id.IDXGIFactory_GetWindowAssociation_UnavailableInSession0;
pub const DXGI_MSG_IDXGIAdapter_EnumOutputs_UnavailableInSession0 = DXGI_Message_Id.IDXGIAdapter_EnumOutputs_UnavailableInSession0;
pub const DXGI_MSG_IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled = DXGI_Message_Id.IDXGISwapChain_CreationOrSetFullscreenState_StereoDisabled;
pub const DXGI_MSG_IDXGIFactory2_UnregisterStatus_CookieNotFound = DXGI_Message_Id.IDXGIFactory2_UnregisterStatus_CookieNotFound;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFSOrOverlay;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithoutFlipSequential;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentWithRDPDriver = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentWithRDPDriver;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedContentInWindowedModeWithDWMOffOrInvalidDisplayAffinity;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_WidthOrHeightIsZero;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_OnlyFlipSequentialSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnAdapter;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7 = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_UnsupportedOnWindows7;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FSTransitionWithCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_InvalidWithCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_WidthOrHeightIsZero;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingNoneIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingUnrecognized = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingUnrecognized;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyFullscreenUnsupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapChain_Present_RestartIsFullscreenOnly = DXGI_Message_Id.IDXGISwapChain_Present_RestartIsFullscreenOnly;
pub const DXGI_MSG_IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly = DXGI_Message_Id.IDXGISwapChain_Present_ProtectedWindowlessPresentationRequiresDisplayOnly;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapChain1_SetBackgroundColor_OutOfRange = DXGI_Message_Id.IDXGISwapChain1_SetBackgroundColor_OutOfRange;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyFullscreenUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyUnsupported;
pub const DXGI_MSG_IDXGISwapchain_Present_ScrollUnsupported = DXGI_Message_Id.IDXGISwapchain_Present_ScrollUnsupported;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_UnsupportedOS = DXGI_Message_Id.IDXGISwapChain1_SetRotation_UnsupportedOS;
pub const DXGI_MSG_IDXGISwapChain1_GetRotation_UnsupportedOS = DXGI_Message_Id.IDXGISwapChain1_GetRotation_UnsupportedOS;
pub const DXGI_MSG_IDXGISwapchain_Present_FullscreenRotation = DXGI_Message_Id.IDXGISwapchain_Present_FullscreenRotation;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationWithMSAABuffers = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationWithMSAABuffers;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_FlipSequentialRequired = DXGI_Message_Id.IDXGISwapChain1_SetRotation_FlipSequentialRequired;
pub const DXGI_MSG_IDXGISwapChain1_SetRotation_InvalidRotation = DXGI_Message_Id.IDXGISwapChain1_SetRotation_InvalidRotation;
pub const DXGI_MSG_IDXGISwapChain1_GetRotation_FlipSequentialRequired = DXGI_Message_Id.IDXGISwapChain1_GetRotation_FlipSequentialRequired;
pub const DXGI_MSG_IDXGISwapChain_GetHwnd_WrongType = DXGI_Message_Id.IDXGISwapChain_GetHwnd_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetCompositionSurface_WrongType = DXGI_Message_Id.IDXGISwapChain_GetCompositionSurface_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetCoreWindow_WrongType = DXGI_Message_Id.IDXGISwapChain_GetCoreWindow_WrongType;
pub const DXGI_MSG_IDXGISwapChain_GetFullscreenDesc_NonHwnd = DXGI_Message_Id.IDXGISwapChain_GetFullscreenDesc_NonHwnd;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_CoreWindow = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_CoreWindow;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7 = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_UnsupportedOnWindows7;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsNULL;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FSUnsupportedForModernApps;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_ModernApp = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_ModernApp;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_ModernApp = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_ModernApp;
pub const DXGI_MSG_IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL = DXGI_Message_Id.IDXGISwapChain_ResizeTarget_pNewTargetParametersIsNULL;
pub const DXGI_MSG_IDXGIOutput_SetDisplaySurface_ModernApp = DXGI_Message_Id.IDXGIOutput_SetDisplaySurface_ModernApp;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_ModernApp = DXGI_Message_Id.IDXGIOutput_TakeOwnership_ModernApp;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_pWindowIsInvalid;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCompositionSurface_InvalidHandle;
pub const DXGI_MSG_IDXGISurface1_GetDC_ModernApp = DXGI_Message_Id.IDXGISurface1_GetDC_ModernApp;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ScalingNoneRequiresWindows8OrNewer;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoAndPreferRight = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoAndPreferRight;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithDoNotSequence;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoOrPreferRightWithoutStereo;
pub const DXGI_MSG_IDXGISwapChain_Present_TemporaryMonoUnsupported = DXGI_Message_Id.IDXGISwapChain_Present_TemporaryMonoUnsupported;
pub const DXGI_MSG_IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch = DXGI_Message_Id.IDXGIOutput_GetDisplaySurfaceData_ArraySizeMismatch;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentationWithSwapEffectDiscard;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaUnrecognized = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaUnrecognized;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaIsWindowlessOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AlphaIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_RestrictToOutputAdapterMismatch;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_DisplayOnlyOnLegacy;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_DisplayOnlyOnLegacy;
pub const DXGI_MSG_IDXGIResource1_CreateSubresourceSurface_InvalidIndex = DXGI_Message_Id.IDXGIResource1_CreateSubresourceSurface_InvalidIndex;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_InvalidScaling = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_InvalidScaling;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForCoreWindow_InvalidSwapEffect;
pub const DXGI_MSG_IDXGIResource1_CreateSharedHandle_UnsupportedOS = DXGI_Message_Id.IDXGIResource1_CreateSharedHandle_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS = DXGI_Message_Id.IDXGIFactory2_RegisterOcclusionStatusWindow_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS = DXGI_Message_Id.IDXGIFactory2_RegisterOcclusionStatusEvent_UnsupportedOS;
pub const DXGI_MSG_IDXGIOutput1_DuplicateOutput_UnsupportedOS = DXGI_Message_Id.IDXGIOutput1_DuplicateOutput_UnsupportedOS;
pub const DXGI_MSG_IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS = DXGI_Message_Id.IDXGIDisplayControl_IsStereoEnabled_UnsupportedOS;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForComposition_InvalidAlphaMode;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_InvalidResource;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_InvalidLUID;
pub const DXGI_MSG_IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS = DXGI_Message_Id.IDXGIFactory_GetSharedResourceAdapterLuid_UnsupportedOS;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_2DOnly = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_2DOnly;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_StagingOnly;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_NeedCPUAccessWrite;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_NoShared = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_NoShared;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1 = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_OnlyMipLevels1;
pub const DXGI_MSG_IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource = DXGI_Message_Id.IDXGIOutput1_GetDisplaySurfaceData1_MappedOrOfferedResource;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_FSUnsupportedForModernApps;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FailedToGoFSButNonPreRotated;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = DXGI_Message_Id.IDXGIFactory_CreateSwapChainOrRegisterOcclusionStatus_BlitModelUsedWhileRegisteredForOcclusionStatusEvents;
pub const DXGI_MSG_IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents = DXGI_Message_Id.IDXGISwapChain_Present_BlitModelUsedWhileRegisteredForOcclusionStatusEvents;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_WaitableSwapChainsAreNotFullscreen;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_Waitable = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_Waitable;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveWaitableFlag;
pub const DXGI_MSG_IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_GetFrameLatencyWaitableObject_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_GetMaximumFrameLatency_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL = DXGI_Message_Id.IDXGISwapChain_GetMaximumFrameLatency_pMaxLatencyIsNULL;
pub const DXGI_MSG_IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable = DXGI_Message_Id.IDXGISwapChain_SetMaximumFrameLatency_OnlyWaitable;
pub const DXGI_MSG_IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds = DXGI_Message_Id.IDXGISwapChain_SetMaximumFrameLatency_MaxLatencyIsOutOfBounds;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ForegroundIsCoreWindowOnly;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_ForegroundUnsupportedOnAdapter;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidScaling;
pub const DXGI_MSG_IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode = DXGI_Message_Id.IDXGIFactory2_CreateSwapChainForCoreWindow_InvalidAlphaMode;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveForegroundFlag;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixPointerCannotBeNull;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_RequiresCompositionSwapChain;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixMustBeFinite;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_MatrixMustBeTranslateAndOrScale;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_MatrixPointerCannotBeNull;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_RequiresCompositionSwapChain;
pub const DXGI_MSG_DXGIGetDebugInterface1_NULL_ppDebug = DXGI_Message_Id.DXGIGetDebugInterface1_NULL_ppDebug;
pub const DXGI_MSG_DXGIGetDebugInterface1_InvalidFlags = DXGI_Message_Id.DXGIGetDebugInterface1_InvalidFlags;
pub const DXGI_MSG_IDXGISwapChain_Present_Decode = DXGI_Message_Id.IDXGISwapChain_Present_Decode;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_Decode = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_Decode;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_FlipModel = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_FlipModel;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_Decode = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_Decode;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_WidthHeight = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_WidthHeight;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_NullPointers = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_NullPointers;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_Decode = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_Decode;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags = DXGI_Message_Id.IDXGIDecodeSwapChain_SetColorSpace_InvalidFlags;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetSourceRect_InvalidRect = DXGI_Message_Id.IDXGIDecodeSwapChain_SetSourceRect_InvalidRect;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetTargetRect_InvalidRect = DXGI_Message_Id.IDXGIDecodeSwapChain_SetTargetRect_InvalidRect;
pub const DXGI_MSG_IDXGIDecodeSwapChain_SetDestSize_InvalidSize = DXGI_Message_Id.IDXGIDecodeSwapChain_SetDestSize_InvalidSize;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetSourceRect_InvalidPointer;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetTargetRect_InvalidPointer;
pub const DXGI_MSG_IDXGIDecodeSwapChain_GetDestSize_InvalidPointer = DXGI_Message_Id.IDXGIDecodeSwapChain_GetDestSize_InvalidPointer;
pub const DXGI_MSG_IDXGISwapChain_PresentBuffer_YUV = DXGI_Message_Id.IDXGISwapChain_PresentBuffer_YUV;
pub const DXGI_MSG_IDXGISwapChain_SetSourceSize_YUV = DXGI_Message_Id.IDXGISwapChain_SetSourceSize_YUV;
pub const DXGI_MSG_IDXGISwapChain_GetSourceSize_YUV = DXGI_Message_Id.IDXGISwapChain_GetSourceSize_YUV;
pub const DXGI_MSG_IDXGISwapChain_SetMatrixTransform_YUV = DXGI_Message_Id.IDXGISwapChain_SetMatrixTransform_YUV;
pub const DXGI_MSG_IDXGISwapChain_GetMatrixTransform_YUV = DXGI_Message_Id.IDXGISwapChain_GetMatrixTransform_YUV;
pub const DXGI_MSG_IDXGISwapChain_Present_PartialPresentation_YUV = DXGI_Message_Id.IDXGISwapChain_Present_PartialPresentation_YUV;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveFlag_YUV;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_Alignment_YUV = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_Alignment_YUV;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_ShaderInputUnsupported_YUV;
pub const DXGI_MSG_IDXGIOutput3_CheckOverlaySupport_NullPointers = DXGI_Message_Id.IDXGIOutput3_CheckOverlaySupport_NullPointers;
pub const DXGI_MSG_IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput3_CheckOverlaySupport_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag = DXGI_Message_Id.IDXGIAdapter_EnumOutputs2_InvalidEnumOutputs2Flag;
pub const DXGI_MSG_IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard = DXGI_Message_Id.IDXGISwapChain_CreationOrSetFullscreenState_FSUnsupportedForFlipDiscard;
pub const DXGI_MSG_IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers = DXGI_Message_Id.IDXGIOutput4_CheckOverlayColorSpaceSupport_NullPointers;
pub const DXGI_MSG_IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice = DXGI_Message_Id.IDXGIOutput4_CheckOverlayColorSpaceSupport_IDXGIDeviceNotSupportedBypConcernedDevice;
pub const DXGI_MSG_IDXGISwapChain3_CheckColorSpaceSupport_NullPointers = DXGI_Message_Id.IDXGISwapChain3_CheckColorSpaceSupport_NullPointers;
pub const DXGI_MSG_IDXGISwapChain3_SetColorSpace1_InvalidColorSpace = DXGI_Message_Id.IDXGISwapChain3_SetColorSpace1_InvalidColorSpace;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidHwProtect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidHwProtect;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_HwProtectUnsupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_HwProtectUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidHwProtect = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidHwProtect;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_HwProtectUnsupported = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_HwProtectUnsupported;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_D3D12Only = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_D3D12Only;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_FlipModel = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_FlipModel;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers1_NodeMaskAndQueueRequired;
pub const DXGI_MSG_IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag = DXGI_Message_Id.IDXGISwapChain_CreateSwapChain_InvalidHwProtectGdiFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_InvalidHwProtectGdiFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_10BitFormatNotSupported = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_10BitFormatNotSupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_FlipSwapEffectRequired;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidDevice = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidDevice;
pub const DXGI_MSG_IDXGIOutput_TakeOwnership_Unsupported = DXGI_Message_Id.IDXGIOutput_TakeOwnership_Unsupported;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_InvalidQueue = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_InvalidQueue;
pub const DXGI_MSG_IDXGISwapChain3_ResizeBuffers1_InvalidQueue = DXGI_Message_Id.IDXGISwapChain3_ResizeBuffers1_InvalidQueue;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling = DXGI_Message_Id.IDXGIFactory_CreateSwapChainForHwnd_InvalidScaling;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidSize = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidSize;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidPointer = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidPointer;
pub const DXGI_MSG_IDXGISwapChain3_SetHDRMetaData_InvalidType = DXGI_Message_Id.IDXGISwapChain3_SetHDRMetaData_InvalidType;
pub const DXGI_MSG_IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid = DXGI_Message_Id.IDXGISwapChain_Present_FullscreenAllowTearingIsInvalid;
pub const DXGI_MSG_IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero = DXGI_Message_Id.IDXGISwapChain_Present_AllowTearingRequiresPresentIntervalZero;
pub const DXGI_MSG_IDXGISwapChain_Present_AllowTearingRequiresCreationFlag = DXGI_Message_Id.IDXGISwapChain_Present_AllowTearingRequiresCreationFlag;
pub const DXGI_MSG_IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag = DXGI_Message_Id.IDXGISwapChain_ResizeBuffers_CannotAddOrRemoveAllowTearingFlag;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_AllowTearingFlagIsFlipModelOnly;
pub const DXGI_MSG_IDXGIFactory_CheckFeatureSupport_InvalidFeature = DXGI_Message_Id.IDXGIFactory_CheckFeatureSupport_InvalidFeature;
pub const DXGI_MSG_IDXGIFactory_CheckFeatureSupport_InvalidSize = DXGI_Message_Id.IDXGIFactory_CheckFeatureSupport_InvalidSize;
pub const DXGI_MSG_IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer = DXGI_Message_Id.IDXGIOutput6_CheckHardwareCompositionSupport_NullPointer;
pub const DXGI_MSG_IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied = DXGI_Message_Id.IDXGISwapChain_SetFullscreenState_PerMonitorDpiShimApplied;
pub const DXGI_MSG_IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied = DXGI_Message_Id.IDXGIOutput_DuplicateOutput_PerMonitorDpiShimApplied;
pub const DXGI_MSG_IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired = DXGI_Message_Id.IDXGIOutput_DuplicateOutput1_PerMonitorDpiRequired;
pub const DXGI_MSG_IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound = DXGI_Message_Id.IDXGIFactory7_UnregisterAdaptersChangedEvent_CookieNotFound;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_LegacyBltModelSwapEffect;
pub const DXGI_MSG_IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged = DXGI_Message_Id.IDXGISwapChain4_SetHDRMetaData_MetadataUnchanged;
pub const DXGI_MSG_IDXGISwapChain_Present_11On12_Released_Resource = DXGI_Message_Id.IDXGISwapChain_Present_11On12_Released_Resource;
pub const DXGI_MSG_IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr = DXGI_Message_Id.IDXGIFactory_CreateSwapChain_MultipleSwapchainRefToSurface_DeferredDtr;
pub const DXGI_MSG_IDXGIFactory_MakeWindowAssociation_NoOpBehavior = DXGI_Message_Id.IDXGIFactory_MakeWindowAssociation_NoOpBehavior;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_DISCARD_BufferCount;
pub const DXGI_MSG_Phone_IDXGISwapChain_SetFullscreenState_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_SetFullscreenState_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_ResizeBuffers_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_ResizeBuffers_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_ResizeTarget_NotAvailable = DXGI_Message_Id.Phone_IDXGISwapChain_ResizeTarget_NotAvailable;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidLayerIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidLayerIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_MultipleLayerIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_MultipleLayerIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidLayerFlag = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidLayerFlag;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidRotation = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidRotation;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidBlend = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidBlend;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidMultiPlaneOverlayResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidIndexForPrimary = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidIndexForPrimary;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidIndexForOverlay = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidIndexForOverlay;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidSubResourceIndex = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidSubResourceIndex;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidSourceRect = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidSourceRect;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidDestinationRect = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidDestinationRect;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_MultipleResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_MultipleResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_NotSharedResource = DXGI_Message_Id.Phone_IDXGISwapChain_Present_NotSharedResource;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidFlag = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidFlag;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_InvalidInterval = DXGI_Message_Id.Phone_IDXGISwapChain_Present_InvalidInterval;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_MSAA_NotSupported;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_ScalingAspectRatioStretch_Supported_ModernApp;
pub const DXGI_MSG_Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp = DXGI_Message_Id.Phone_IDXGISwapChain_GetFrameStatistics_NotAvailable_ModernApp;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present_ReplaceInterval0With1 = DXGI_Message_Id.Phone_IDXGISwapChain_Present_ReplaceInterval0With1;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FailedRegisterWithCompositor;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_NotForegroundWindow_AtRendering;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FLIP_SEQUENTIAL_BufferCount;
pub const DXGI_MSG_Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only = DXGI_Message_Id.Phone_IDXGIFactory_CreateSwapChain_FLIP_Modern_CoreWindow_Only;
pub const DXGI_MSG_Phone_IDXGISwapChain_Present1_RequiresOverlays = DXGI_Message_Id.Phone_IDXGISwapChain_Present1_RequiresOverlays;
pub const DXGI_MSG_Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired = DXGI_Message_Id.Phone_IDXGISwapChain_SetBackgroundColor_FlipSequentialRequired;
pub const DXGI_MSG_Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired = DXGI_Message_Id.Phone_IDXGISwapChain_GetBackgroundColor_FlipSequentialRequired;

const IID_IDXGraphicsAnalysis_Value = Guid.initString("9f251514-9d4d-4902-9d60-18988ab7d4b5");
pub const IID_IDXGraphicsAnalysis = &IID_IDXGraphicsAnalysis_Value;
pub const IDXGraphicsAnalysis = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCapture: *const fn (
            self: *const IDXGraphicsAnalysis,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndCapture: *const fn (
            self: *const IDXGraphicsAnalysis,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            pub inline fn beginCapture(self: *const T) void {
                return @as(*const IDXGraphicsAnalysis.VTable, @ptrCast(self.vtable)).BeginCapture(@as(*const IDXGraphicsAnalysis, @ptrCast(self)));
            }
            pub inline fn endCapture(self: *const T) void {
                return @as(*const IDXGraphicsAnalysis.VTable, @ptrCast(self.vtable)).EndCapture(@as(*const IDXGraphicsAnalysis, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "dxgi" fn CreateDXGIFactory(
    riid: ?*const Guid,
    pp_factory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "dxgi" fn CreateDXGIFactory1(
    riid: ?*const Guid,
    pp_factory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn CreateDXGIFactory2(
    flags: u32,
    riid: ?*const Guid,
    pp_factory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "dxgi" fn DXGIGetDebugInterface1(
    flags: u32,
    riid: ?*const Guid,
    p_debug: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "dxgi" fn DXGIDeclareAdapterRemovalSupport() callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const DXGI_ALPHA_MODE = @import("../graphics/dxgi/common.zig").DXGI_ALPHA_MODE;
const DXGI_COLOR_SPACE_TYPE = @import("../graphics/dxgi/common.zig").DXGI_COLOR_SPACE_TYPE;
const DXGI_FORMAT = @import("../graphics/dxgi/common.zig").DXGI_FORMAT;
const DXGI_GAMMA_CONTROL = @import("../graphics/dxgi/common.zig").DXGI_GAMMA_CONTROL;
const DXGI_GAMMA_CONTROL_CAPABILITIES = @import("../graphics/dxgi/common.zig").DXGI_GAMMA_CONTROL_CAPABILITIES;
const DXGI_MODE_DESC = @import("../graphics/dxgi/common.zig").DXGI_MODE_DESC;
const DXGI_MODE_ROTATION = @import("../graphics/dxgi/common.zig").DXGI_MODE_ROTATION;
const DXGI_MODE_SCALING = @import("../graphics/dxgi/common.zig").DXGI_MODE_SCALING;
const DXGI_MODE_SCANLINE_ORDER = @import("../graphics/dxgi/common.zig").DXGI_MODE_SCANLINE_ORDER;
const DXGI_RATIONAL = @import("../graphics/dxgi/common.zig").DXGI_RATIONAL;
const DXGI_SAMPLE_DESC = @import("../graphics/dxgi/common.zig").DXGI_SAMPLE_DESC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LUID = @import("../foundation.zig").LUID;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("dxgi/common.zig");
